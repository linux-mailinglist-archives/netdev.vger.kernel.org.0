Return-Path: <netdev-owner@vger.kernel.org>
X-Original-To: lists+netdev@lfdr.de
Delivered-To: lists+netdev@lfdr.de
Received: from out1.vger.email (out1.vger.email [IPv6:2620:137:e000::1:20])
	by mail.lfdr.de (Postfix) with ESMTP id 3811C668D61
	for <lists+netdev@lfdr.de>; Fri, 13 Jan 2023 07:31:15 +0100 (CET)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S240805AbjAMG05 (ORCPT <rfc822;lists+netdev@lfdr.de>);
        Fri, 13 Jan 2023 01:26:57 -0500
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:33448 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S234084AbjAMGYk (ORCPT
        <rfc822;netdev@vger.kernel.org>); Fri, 13 Jan 2023 01:24:40 -0500
Received: from bombadil.infradead.org (bombadil.infradead.org [IPv6:2607:7c80:54:3::133])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id 4D7EE69B18;
        Thu, 12 Jan 2023 22:24:13 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; q=dns/txt; c=relaxed/relaxed;
        d=infradead.org; s=bombadil.20210309; h=Content-Transfer-Encoding:
        MIME-Version:References:In-Reply-To:Message-Id:Date:Subject:Cc:To:From:Sender
        :Reply-To:Content-Type:Content-ID:Content-Description;
        bh=/ZPcKj/M7aotav00bFh4XCt43CoWTvJ2TvvhHRQgw1Y=; b=jZ0clS1I8IsYNCJnOEVNMdjq5m
        EijUOl//GMqVd8oy1sl0EFnbqPW14g2MdelyBkk5oMWNA0fKpzQog4GvRo+G1il5F+QSl10EZOvAs
        qJowSSFWP+9yIZnPBlmfwXXCXb9Mm+gH9rWokmBLodslZv/zwamsgyMzGShGLSJrjtuTkeHcRXDS5
        L3DPaGYCfI1LjtBCQBhNFVNZOgQb6YVuAkVSDvXNpIOoZLqriq3wQQESJ8loWwEYyVfynQNCG0cNH
        AY02CjuVEty96DcNS7teQAW5B5byvrsheW2ifDns784jas8Qd+rwZGLCFTiSwxW7vte06MafKghsb
        1ezM4CIw==;
Received: from [2001:4bb8:181:656b:9509:7d20:8d39:f895] (helo=localhost)
        by bombadil.infradead.org with esmtpsa (Exim 4.94.2 #2 (Red Hat Linux))
        id 1pGDTi-000lOW-Ec; Fri, 13 Jan 2023 06:23:57 +0000
From:   Christoph Hellwig <hch@lst.de>
To:     Yoshinori Sato <ysato@users.sourceforge.jp>,
        Rich Felker <dalias@libc.org>, Arnd Bergmann <arnd@arndb.de>,
        Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Cc:     Laurent Pinchart <laurent.pinchart@ideasonboard.com>,
        Kieran Bingham <kieran.bingham+renesas@ideasonboard.com>,
        Geert Uytterhoeven <geert+renesas@glider.be>,
        linux-kernel@vger.kernel.org, linux-watchdog@vger.kernel.org,
        devicetree@vger.kernel.org, linux-arch@vger.kernel.org,
        dmaengine@vger.kernel.org, dri-devel@lists.freedesktop.org,
        linux-renesas-soc@vger.kernel.org, linux-i2c@vger.kernel.org,
        linux-input@vger.kernel.org, linux-media@vger.kernel.org,
        linux-mmc@vger.kernel.org, linux-mtd@lists.infradead.org,
        netdev@vger.kernel.org, linux-gpio@vger.kernel.org,
        linux-rtc@vger.kernel.org, linux-spi@vger.kernel.org,
        linux-serial@vger.kernel.org, linux-usb@vger.kernel.org,
        linux-fbdev@vger.kernel.org, alsa-devel@alsa-project.org,
        linux-sh@vger.kernel.org
Subject: [PATCH 03/22] remove arch/sh
Date:   Fri, 13 Jan 2023 07:23:20 +0100
Message-Id: <20230113062339.1909087-4-hch@lst.de>
X-Mailer: git-send-email 2.39.0
In-Reply-To: <20230113062339.1909087-1-hch@lst.de>
References: <20230113062339.1909087-1-hch@lst.de>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
X-SRS-Rewrite: SMTP reverse-path rewritten from <hch@infradead.org> by bombadil.infradead.org. See http://www.infradead.org/rpr.html
Precedence: bulk
List-ID: <netdev.vger.kernel.org>
X-Mailing-List: netdev@vger.kernel.org

The Linux SH port has been mostly abandoned for years, with the last
minor maintainer updated being in November 2021.  Drop it as it drags
maintainance of the rest of the kernel down.

Signed-off-by: Christoph Hellwig <hch@lst.de>
---
 Documentation/arch.rst                        |    1 -
 Documentation/sh/booting.rst                  |   12 -
 Documentation/sh/features.rst                 |    3 -
 Documentation/sh/index.rst                    |   56 -
 Documentation/sh/new-machine.rst              |  277 ---
 Documentation/sh/register-banks.rst           |   40 -
 MAINTAINERS                                   |   10 -
 arch/sh/Kbuild                                |    7 -
 arch/sh/Kconfig                               |  793 --------
 arch/sh/Kconfig.cpu                           |  100 -
 arch/sh/Kconfig.debug                         |   78 -
 arch/sh/Makefile                              |  215 ---
 arch/sh/boards/Kconfig                        |  400 ----
 arch/sh/boards/Makefile                       |   20 -
 arch/sh/boards/board-apsh4a3a.c               |  182 --
 arch/sh/boards/board-apsh4ad0a.c              |  132 --
 arch/sh/boards/board-edosk7705.c              |   79 -
 arch/sh/boards/board-edosk7760.c              |  178 --
 arch/sh/boards/board-espt.c                   |  105 --
 arch/sh/boards/board-magicpanelr2.c           |  390 ----
 arch/sh/boards/board-polaris.c                |  156 --
 arch/sh/boards/board-secureedge5410.c         |   75 -
 arch/sh/boards/board-sh2007.c                 |  146 --
 arch/sh/boards/board-sh7757lcr.c              |  604 -------
 arch/sh/boards/board-sh7785lcr.c              |  384 ----
 arch/sh/boards/board-shmin.c                  |   35 -
 arch/sh/boards/board-titan.c                  |   21 -
 arch/sh/boards/board-urquell.c                |  218 ---
 arch/sh/boards/mach-ap325rxa/Makefile         |    3 -
 arch/sh/boards/mach-ap325rxa/sdram.S          |   66 -
 arch/sh/boards/mach-ap325rxa/setup.c          |  573 ------
 arch/sh/boards/mach-dreamcast/Makefile        |    7 -
 arch/sh/boards/mach-dreamcast/irq.c           |  155 --
 arch/sh/boards/mach-dreamcast/rtc.c           |   96 -
 arch/sh/boards/mach-dreamcast/setup.c         |   39 -
 arch/sh/boards/mach-ecovec24/Makefile         |   10 -
 arch/sh/boards/mach-ecovec24/sdram.S          |  108 --
 arch/sh/boards/mach-ecovec24/setup.c          | 1521 ----------------
 arch/sh/boards/mach-highlander/Kconfig        |   26 -
 arch/sh/boards/mach-highlander/Makefile       |   12 -
 arch/sh/boards/mach-highlander/irq-r7780mp.c  |   71 -
 arch/sh/boards/mach-highlander/irq-r7780rp.c  |   64 -
 arch/sh/boards/mach-highlander/irq-r7785rp.c  |   83 -
 .../boards/mach-highlander/pinmux-r7785rp.c   |   17 -
 arch/sh/boards/mach-highlander/psw.c          |  119 --
 arch/sh/boards/mach-highlander/setup.c        |  416 -----
 arch/sh/boards/mach-hp6xx/Makefile            |    8 -
 arch/sh/boards/mach-hp6xx/hp6xx_apm.c         |  109 --
 arch/sh/boards/mach-hp6xx/pm.c                |  156 --
 arch/sh/boards/mach-hp6xx/pm_wakeup.S         |   39 -
 arch/sh/boards/mach-hp6xx/setup.c             |  172 --
 arch/sh/boards/mach-kfr2r09/Makefile          |    5 -
 arch/sh/boards/mach-kfr2r09/lcd_wqvga.c       |  275 ---
 arch/sh/boards/mach-kfr2r09/sdram.S           |   77 -
 arch/sh/boards/mach-kfr2r09/setup.c           |  649 -------
 arch/sh/boards/mach-landisk/Makefile          |    6 -
 arch/sh/boards/mach-landisk/gio.c             |  164 --
 arch/sh/boards/mach-landisk/irq.c             |   63 -
 arch/sh/boards/mach-landisk/psw.c             |  140 --
 arch/sh/boards/mach-landisk/setup.c           |  102 --
 arch/sh/boards/mach-lboxre2/Makefile          |    6 -
 arch/sh/boards/mach-lboxre2/irq.c             |   27 -
 arch/sh/boards/mach-lboxre2/setup.c           |   79 -
 arch/sh/boards/mach-microdev/Makefile         |    6 -
 arch/sh/boards/mach-microdev/fdc37c93xapm.c   |  157 --
 arch/sh/boards/mach-microdev/io.c             |  123 --
 arch/sh/boards/mach-microdev/irq.c            |  150 --
 arch/sh/boards/mach-microdev/setup.c          |  197 --
 arch/sh/boards/mach-migor/Kconfig             |   16 -
 arch/sh/boards/mach-migor/Makefile            |    3 -
 arch/sh/boards/mach-migor/lcd_qvga.c          |  163 --
 arch/sh/boards/mach-migor/sdram.S             |   66 -
 arch/sh/boards/mach-migor/setup.c             |  649 -------
 arch/sh/boards/mach-r2d/Kconfig               |   24 -
 arch/sh/boards/mach-r2d/Makefile              |    6 -
 arch/sh/boards/mach-r2d/irq.c                 |  156 --
 arch/sh/boards/mach-r2d/setup.c               |  305 ----
 arch/sh/boards/mach-rsk/Kconfig               |   29 -
 arch/sh/boards/mach-rsk/Makefile              |    5 -
 arch/sh/boards/mach-rsk/devices-rsk7203.c     |  137 --
 arch/sh/boards/mach-rsk/devices-rsk7264.c     |   55 -
 arch/sh/boards/mach-rsk/devices-rsk7269.c     |   57 -
 arch/sh/boards/mach-rsk/setup.c               |   84 -
 arch/sh/boards/mach-sdk7780/Kconfig           |   17 -
 arch/sh/boards/mach-sdk7780/Makefile          |    6 -
 arch/sh/boards/mach-sdk7780/irq.c             |   43 -
 arch/sh/boards/mach-sdk7780/setup.c           |   96 -
 arch/sh/boards/mach-sdk7786/Makefile          |    5 -
 arch/sh/boards/mach-sdk7786/fpga.c            |   69 -
 arch/sh/boards/mach-sdk7786/gpio.c            |   46 -
 arch/sh/boards/mach-sdk7786/irq.c             |   45 -
 arch/sh/boards/mach-sdk7786/nmi.c             |   80 -
 arch/sh/boards/mach-sdk7786/setup.c           |  266 ---
 arch/sh/boards/mach-sdk7786/sram.c            |   69 -
 arch/sh/boards/mach-se/7206/Makefile          |    6 -
 arch/sh/boards/mach-se/7206/irq.c             |  151 --
 arch/sh/boards/mach-se/7206/setup.c           |   96 -
 arch/sh/boards/mach-se/7343/Makefile          |    6 -
 arch/sh/boards/mach-se/7343/irq.c             |  123 --
 arch/sh/boards/mach-se/7343/setup.c           |  182 --
 arch/sh/boards/mach-se/770x/Makefile          |    6 -
 arch/sh/boards/mach-se/770x/irq.c             |  109 --
 arch/sh/boards/mach-se/770x/setup.c           |  205 ---
 arch/sh/boards/mach-se/7721/Makefile          |    2 -
 arch/sh/boards/mach-se/7721/irq.c             |   42 -
 arch/sh/boards/mach-se/7721/setup.c           |   92 -
 arch/sh/boards/mach-se/7722/Makefile          |   11 -
 arch/sh/boards/mach-se/7722/irq.c             |  116 --
 arch/sh/boards/mach-se/7722/setup.c           |  190 --
 arch/sh/boards/mach-se/7724/Makefile          |   11 -
 arch/sh/boards/mach-se/7724/irq.c             |  143 --
 arch/sh/boards/mach-se/7724/sdram.S           |  128 --
 arch/sh/boards/mach-se/7724/setup.c           |  986 ----------
 arch/sh/boards/mach-se/7751/Makefile          |    6 -
 arch/sh/boards/mach-se/7751/irq.c             |   51 -
 arch/sh/boards/mach-se/7751/setup.c           |   60 -
 arch/sh/boards/mach-se/7780/Makefile          |   11 -
 arch/sh/boards/mach-se/7780/irq.c             |   65 -
 arch/sh/boards/mach-se/7780/setup.c           |  111 --
 arch/sh/boards/mach-se/Makefile               |   11 -
 arch/sh/boards/mach-se/board-se7619.c         |   27 -
 arch/sh/boards/mach-sh03/Makefile             |    7 -
 arch/sh/boards/mach-sh03/rtc.c                |  143 --
 arch/sh/boards/mach-sh03/setup.c              |   97 -
 arch/sh/boards/mach-sh7763rdp/Makefile        |    2 -
 arch/sh/boards/mach-sh7763rdp/irq.c           |   42 -
 arch/sh/boards/mach-sh7763rdp/setup.c         |  213 ---
 arch/sh/boards/mach-x3proto/Makefile          |    4 -
 arch/sh/boards/mach-x3proto/gpio.c            |  136 --
 arch/sh/boards/mach-x3proto/ilsel.c           |  156 --
 arch/sh/boards/mach-x3proto/setup.c           |  270 ---
 arch/sh/boards/of-generic.c                   |  172 --
 arch/sh/boot/.gitignore                       |    5 -
 arch/sh/boot/Makefile                         |  115 --
 arch/sh/boot/compressed/.gitignore            |    2 -
 arch/sh/boot/compressed/Makefile              |   66 -
 arch/sh/boot/compressed/ashiftrt.S            |    2 -
 arch/sh/boot/compressed/ashldi3.c             |    2 -
 arch/sh/boot/compressed/ashlsi3.S             |    2 -
 arch/sh/boot/compressed/ashrsi3.S             |    2 -
 arch/sh/boot/compressed/cache.c               |   13 -
 arch/sh/boot/compressed/head_32.S             |  126 --
 arch/sh/boot/compressed/head_64.S             |  159 --
 arch/sh/boot/compressed/lshrsi3.S             |    2 -
 arch/sh/boot/compressed/misc.c                |  146 --
 arch/sh/boot/compressed/vmlinux.scr           |   10 -
 arch/sh/boot/dts/Makefile                     |    2 -
 arch/sh/boot/dts/j2_mimas_v2.dts              |   99 -
 arch/sh/boot/romimage/Makefile                |   30 -
 arch/sh/boot/romimage/head.S                  |   85 -
 arch/sh/boot/romimage/mmcif-sh7724.c          |   78 -
 arch/sh/boot/romimage/vmlinux.scr             |    8 -
 arch/sh/cchips/Kconfig                        |   46 -
 arch/sh/cchips/hd6446x/Makefile               |    4 -
 arch/sh/cchips/hd6446x/hd64461.c              |  112 --
 arch/sh/configs/ap325rxa_defconfig            |  103 --
 arch/sh/configs/apsh4a3a_defconfig            |   91 -
 arch/sh/configs/apsh4ad0a_defconfig           |  122 --
 arch/sh/configs/dreamcast_defconfig           |   72 -
 arch/sh/configs/ecovec24-romimage_defconfig   |   58 -
 arch/sh/configs/ecovec24_defconfig            |  132 --
 arch/sh/configs/edosk7705_defconfig           |   35 -
 arch/sh/configs/edosk7760_defconfig           |  114 --
 arch/sh/configs/espt_defconfig                |  114 --
 arch/sh/configs/hp6xx_defconfig               |   60 -
 arch/sh/configs/j2_defconfig                  |   42 -
 arch/sh/configs/kfr2r09-romimage_defconfig    |   53 -
 arch/sh/configs/kfr2r09_defconfig             |   84 -
 arch/sh/configs/landisk_defconfig             |  115 --
 arch/sh/configs/lboxre2_defconfig             |   62 -
 arch/sh/configs/magicpanelr2_defconfig        |   90 -
 arch/sh/configs/microdev_defconfig            |   43 -
 arch/sh/configs/migor_defconfig               |   94 -
 arch/sh/configs/polaris_defconfig             |   83 -
 arch/sh/configs/r7780mp_defconfig             |  109 --
 arch/sh/configs/r7785rp_defconfig             |  107 --
 arch/sh/configs/rsk7201_defconfig             |   63 -
 arch/sh/configs/rsk7203_defconfig             |  121 --
 arch/sh/configs/rsk7264_defconfig             |   71 -
 arch/sh/configs/rsk7269_defconfig             |   56 -
 arch/sh/configs/rts7751r2d1_defconfig         |   91 -
 arch/sh/configs/rts7751r2dplus_defconfig      |   96 -
 arch/sh/configs/sdk7780_defconfig             |  139 --
 arch/sh/configs/sdk7786_defconfig             |  217 ---
 arch/sh/configs/se7206_defconfig              |  108 --
 arch/sh/configs/se7343_defconfig              |   96 -
 arch/sh/configs/se7619_defconfig              |   43 -
 arch/sh/configs/se7705_defconfig              |   54 -
 arch/sh/configs/se7712_defconfig              |  101 --
 arch/sh/configs/se7721_defconfig              |  127 --
 arch/sh/configs/se7722_defconfig              |   56 -
 arch/sh/configs/se7724_defconfig              |  132 --
 arch/sh/configs/se7750_defconfig              |   55 -
 arch/sh/configs/se7751_defconfig              |   46 -
 arch/sh/configs/se7780_defconfig              |  106 --
 arch/sh/configs/secureedge5410_defconfig      |   53 -
 arch/sh/configs/sh03_defconfig                |  126 --
 arch/sh/configs/sh2007_defconfig              |  199 --
 arch/sh/configs/sh7710voipgw_defconfig        |   55 -
 arch/sh/configs/sh7724_generic_defconfig      |   41 -
 arch/sh/configs/sh7757lcr_defconfig           |   85 -
 arch/sh/configs/sh7763rdp_defconfig           |  116 --
 arch/sh/configs/sh7770_generic_defconfig      |   43 -
 arch/sh/configs/sh7785lcr_32bit_defconfig     |  149 --
 arch/sh/configs/sh7785lcr_defconfig           |  117 --
 arch/sh/configs/shmin_defconfig               |   52 -
 arch/sh/configs/shx3_defconfig                |  103 --
 arch/sh/configs/titan_defconfig               |  272 ---
 arch/sh/configs/ul2_defconfig                 |   84 -
 arch/sh/configs/urquell_defconfig             |  147 --
 arch/sh/drivers/Kconfig                       |   20 -
 arch/sh/drivers/Makefile                      |   11 -
 arch/sh/drivers/dma/Kconfig                   |   74 -
 arch/sh/drivers/dma/Makefile                  |    9 -
 arch/sh/drivers/dma/dma-api.c                 |  417 -----
 arch/sh/drivers/dma/dma-g2.c                  |  197 --
 arch/sh/drivers/dma/dma-pvr2.c                |  102 --
 arch/sh/drivers/dma/dma-sh.c                  |  414 -----
 arch/sh/drivers/dma/dma-sysfs.c               |  164 --
 arch/sh/drivers/dma/dmabrg.c                  |  196 --
 arch/sh/drivers/heartbeat.c                   |  152 --
 arch/sh/drivers/pci/Makefile                  |   27 -
 arch/sh/drivers/pci/common.c                  |  159 --
 arch/sh/drivers/pci/fixups-dreamcast.c        |   84 -
 arch/sh/drivers/pci/fixups-landisk.c          |   57 -
 arch/sh/drivers/pci/fixups-r7780rp.c          |   18 -
 arch/sh/drivers/pci/fixups-rts7751r2d.c       |   64 -
 arch/sh/drivers/pci/fixups-sdk7780.c          |   40 -
 arch/sh/drivers/pci/fixups-sdk7786.c          |   64 -
 arch/sh/drivers/pci/fixups-se7751.c           |  113 --
 arch/sh/drivers/pci/fixups-sh03.c             |   33 -
 arch/sh/drivers/pci/fixups-snapgear.c         |   37 -
 arch/sh/drivers/pci/fixups-titan.c            |   36 -
 arch/sh/drivers/pci/ops-dreamcast.c           |   79 -
 arch/sh/drivers/pci/ops-sh4.c                 |  105 --
 arch/sh/drivers/pci/ops-sh7786.c              |  168 --
 arch/sh/drivers/pci/pci-dreamcast.c           |   97 -
 arch/sh/drivers/pci/pci-sh4.h                 |  182 --
 arch/sh/drivers/pci/pci-sh7751.c              |  179 --
 arch/sh/drivers/pci/pci-sh7751.h              |  126 --
 arch/sh/drivers/pci/pci-sh7780.c              |  407 -----
 arch/sh/drivers/pci/pci-sh7780.h              |   43 -
 arch/sh/drivers/pci/pci.c                     |  298 ---
 arch/sh/drivers/pci/pcie-sh7786.c             |  609 -------
 arch/sh/drivers/pci/pcie-sh7786.h             |  577 ------
 arch/sh/drivers/platform_early.c              |  340 ----
 arch/sh/drivers/push-switch.c                 |  136 --
 arch/sh/drivers/superhyway/Makefile           |    7 -
 arch/sh/drivers/superhyway/ops-sh4-202.c      |  168 --
 arch/sh/include/asm/Kbuild                    |    5 -
 arch/sh/include/asm/adc.h                     |   12 -
 arch/sh/include/asm/addrspace.h               |   63 -
 arch/sh/include/asm/alignment.h               |   22 -
 arch/sh/include/asm/asm-offsets.h             |    2 -
 arch/sh/include/asm/atomic-grb.h              |   86 -
 arch/sh/include/asm/atomic-irq.h              |   72 -
 arch/sh/include/asm/atomic-llsc.h             |   88 -
 arch/sh/include/asm/atomic.h                  |   38 -
 arch/sh/include/asm/barrier.h                 |   45 -
 arch/sh/include/asm/bitops-cas.h              |   94 -
 arch/sh/include/asm/bitops-grb.h              |  173 --
 arch/sh/include/asm/bitops-llsc.h             |  147 --
 arch/sh/include/asm/bitops-op32.h             |  143 --
 arch/sh/include/asm/bitops.h                  |   72 -
 arch/sh/include/asm/bl_bit.h                  |    2 -
 arch/sh/include/asm/bl_bit_32.h               |   34 -
 arch/sh/include/asm/bug.h                     |  121 --
 arch/sh/include/asm/bugs.h                    |   74 -
 arch/sh/include/asm/cache.h                   |   46 -
 arch/sh/include/asm/cache_insns.h             |    2 -
 arch/sh/include/asm/cache_insns_32.h          |   22 -
 arch/sh/include/asm/cacheflush.h              |  106 --
 arch/sh/include/asm/checksum.h                |    2 -
 arch/sh/include/asm/checksum_32.h             |  203 ---
 arch/sh/include/asm/clock.h                   |   17 -
 arch/sh/include/asm/cmpxchg-cas.h             |   25 -
 arch/sh/include/asm/cmpxchg-grb.h             |   95 -
 arch/sh/include/asm/cmpxchg-irq.h             |   54 -
 arch/sh/include/asm/cmpxchg-llsc.h            |   53 -
 arch/sh/include/asm/cmpxchg-xchg.h            |   50 -
 arch/sh/include/asm/cmpxchg.h                 |   74 -
 arch/sh/include/asm/device.h                  |   17 -
 arch/sh/include/asm/dma-register.h            |   50 -
 arch/sh/include/asm/dma.h                     |  140 --
 arch/sh/include/asm/dmabrg.h                  |   24 -
 arch/sh/include/asm/dwarf.h                   |  417 -----
 arch/sh/include/asm/elf.h                     |  211 ---
 arch/sh/include/asm/entry-macros.S            |  123 --
 arch/sh/include/asm/extable.h                 |    7 -
 arch/sh/include/asm/fb.h                      |   20 -
 arch/sh/include/asm/fixmap.h                  |   86 -
 arch/sh/include/asm/flat.h                    |   33 -
 arch/sh/include/asm/fpu.h                     |   69 -
 arch/sh/include/asm/freq.h                    |   12 -
 arch/sh/include/asm/ftrace.h                  |   48 -
 arch/sh/include/asm/futex-cas.h               |   35 -
 arch/sh/include/asm/futex-irq.h               |   25 -
 arch/sh/include/asm/futex-llsc.h              |   42 -
 arch/sh/include/asm/futex.h                   |   72 -
 arch/sh/include/asm/gpio.h                    |   50 -
 arch/sh/include/asm/hardirq.h                 |   11 -
 arch/sh/include/asm/hd64461.h                 |  252 ---
 arch/sh/include/asm/heartbeat.h               |   19 -
 arch/sh/include/asm/hugetlb.h                 |   38 -
 arch/sh/include/asm/hw_breakpoint.h           |   70 -
 arch/sh/include/asm/hw_irq.h                  |   36 -
 arch/sh/include/asm/i2c-sh7760.h              |   21 -
 arch/sh/include/asm/io.h                      |  294 ---
 arch/sh/include/asm/io_generic.h              |   19 -
 arch/sh/include/asm/io_noioport.h             |   86 -
 arch/sh/include/asm/io_trapped.h              |   59 -
 arch/sh/include/asm/irq.h                     |   58 -
 arch/sh/include/asm/irqflags.h                |   10 -
 arch/sh/include/asm/kdebug.h                  |   19 -
 arch/sh/include/asm/kexec.h                   |   72 -
 arch/sh/include/asm/kgdb.h                    |   38 -
 arch/sh/include/asm/kprobes.h                 |   57 -
 arch/sh/include/asm/linkage.h                 |    8 -
 arch/sh/include/asm/machvec.h                 |   41 -
 arch/sh/include/asm/mmiowb.h                  |   12 -
 arch/sh/include/asm/mmu.h                     |  107 --
 arch/sh/include/asm/mmu_context.h             |  178 --
 arch/sh/include/asm/mmu_context_32.h          |   51 -
 arch/sh/include/asm/mmzone.h                  |   45 -
 arch/sh/include/asm/module.h                  |   14 -
 arch/sh/include/asm/page.h                    |  186 --
 arch/sh/include/asm/pci.h                     |   91 -
 arch/sh/include/asm/perf_event.h              |   30 -
 arch/sh/include/asm/pgalloc.h                 |   40 -
 arch/sh/include/asm/pgtable-2level.h          |   24 -
 arch/sh/include/asm/pgtable-3level.h          |   59 -
 arch/sh/include/asm/pgtable.h                 |  150 --
 arch/sh/include/asm/pgtable_32.h              |  462 -----
 arch/sh/include/asm/platform_early.h          |   61 -
 arch/sh/include/asm/posix_types.h             |    2 -
 arch/sh/include/asm/processor.h               |  173 --
 arch/sh/include/asm/processor_32.h            |  202 ---
 arch/sh/include/asm/ptrace.h                  |  139 --
 arch/sh/include/asm/ptrace_32.h               |   14 -
 arch/sh/include/asm/push-switch.h             |   32 -
 arch/sh/include/asm/reboot.h                  |   22 -
 arch/sh/include/asm/romimage-macros.h         |   74 -
 arch/sh/include/asm/rtc.h                     |   15 -
 arch/sh/include/asm/seccomp.h                 |   21 -
 arch/sh/include/asm/sections.h                |   12 -
 arch/sh/include/asm/setup.h                   |   25 -
 arch/sh/include/asm/sfp-machine.h             |   80 -
 arch/sh/include/asm/sh7760fb.h                |  198 --
 arch/sh/include/asm/sh_bios.h                 |   28 -
 arch/sh/include/asm/shmparam.h                |   19 -
 arch/sh/include/asm/siu.h                     |   20 -
 arch/sh/include/asm/smc37c93x.h               |  191 --
 arch/sh/include/asm/smp-ops.h                 |   52 -
 arch/sh/include/asm/smp.h                     |   83 -
 arch/sh/include/asm/sparsemem.h               |   12 -
 arch/sh/include/asm/spi.h                     |   14 -
 arch/sh/include/asm/spinlock-cas.h            |   89 -
 arch/sh/include/asm/spinlock-llsc.h           |  198 --
 arch/sh/include/asm/spinlock.h                |   19 -
 arch/sh/include/asm/spinlock_types.h          |   22 -
 arch/sh/include/asm/sram.h                    |   39 -
 arch/sh/include/asm/stackprotector.h          |   21 -
 arch/sh/include/asm/stacktrace.h              |   21 -
 arch/sh/include/asm/string.h                  |    2 -
 arch/sh/include/asm/string_32.h               |  102 --
 arch/sh/include/asm/suspend.h                 |   97 -
 arch/sh/include/asm/switch_to.h               |    7 -
 arch/sh/include/asm/switch_to_32.h            |  131 --
 arch/sh/include/asm/syscall.h                 |    9 -
 arch/sh/include/asm/syscall_32.h              |   69 -
 arch/sh/include/asm/syscalls.h                |   14 -
 arch/sh/include/asm/syscalls_32.h             |   27 -
 arch/sh/include/asm/thread_info.h             |  171 --
 arch/sh/include/asm/timex.h                   |   24 -
 arch/sh/include/asm/tlb.h                     |   29 -
 arch/sh/include/asm/tlbflush.h                |   52 -
 arch/sh/include/asm/topology.h                |   28 -
 arch/sh/include/asm/traps.h                   |   18 -
 arch/sh/include/asm/traps_32.h                |   61 -
 arch/sh/include/asm/types.h                   |   16 -
 arch/sh/include/asm/uaccess.h                 |  133 --
 arch/sh/include/asm/uaccess_32.h              |  227 ---
 arch/sh/include/asm/uncached.h                |   59 -
 arch/sh/include/asm/unistd.h                  |   31 -
 arch/sh/include/asm/unwinder.h                |   32 -
 arch/sh/include/asm/user.h                    |   55 -
 arch/sh/include/asm/vermagic.h                |   30 -
 arch/sh/include/asm/vga.h                     |    7 -
 arch/sh/include/asm/vmalloc.h                 |    4 -
 arch/sh/include/asm/vmlinux.lds.h             |   18 -
 arch/sh/include/asm/watchdog.h                |  159 --
 arch/sh/include/asm/word-at-a-time.h          |   54 -
 arch/sh/include/cpu-common/cpu/addrspace.h    |   16 -
 arch/sh/include/cpu-common/cpu/mmu_context.h  |   13 -
 arch/sh/include/cpu-common/cpu/pfc.h          |   18 -
 arch/sh/include/cpu-common/cpu/rtc.h          |    9 -
 arch/sh/include/cpu-common/cpu/sigcontext.h   |   18 -
 arch/sh/include/cpu-common/cpu/timer.h        |    7 -
 arch/sh/include/cpu-sh2/cpu/cache.h           |   40 -
 arch/sh/include/cpu-sh2/cpu/freq.h            |   15 -
 arch/sh/include/cpu-sh2/cpu/watchdog.h        |   66 -
 arch/sh/include/cpu-sh2a/cpu/addrspace.h      |   11 -
 arch/sh/include/cpu-sh2a/cpu/cache.h          |   40 -
 arch/sh/include/cpu-sh2a/cpu/freq.h           |   13 -
 arch/sh/include/cpu-sh2a/cpu/rtc.h            |    9 -
 arch/sh/include/cpu-sh2a/cpu/sh7203.h         |  144 --
 arch/sh/include/cpu-sh2a/cpu/sh7264.h         |  169 --
 arch/sh/include/cpu-sh2a/cpu/sh7269.h         |  213 ---
 arch/sh/include/cpu-sh2a/cpu/watchdog.h       |    2 -
 arch/sh/include/cpu-sh3/cpu/adc.h             |   29 -
 arch/sh/include/cpu-sh3/cpu/cache.h           |   40 -
 arch/sh/include/cpu-sh3/cpu/dac.h             |   42 -
 arch/sh/include/cpu-sh3/cpu/dma-register.h    |   38 -
 arch/sh/include/cpu-sh3/cpu/dma.h             |   19 -
 arch/sh/include/cpu-sh3/cpu/freq.h            |   24 -
 arch/sh/include/cpu-sh3/cpu/gpio.h            |   78 -
 arch/sh/include/cpu-sh3/cpu/mmu_context.h     |   42 -
 arch/sh/include/cpu-sh3/cpu/serial.h          |   11 -
 arch/sh/include/cpu-sh3/cpu/sh7720.h          |  175 --
 arch/sh/include/cpu-sh3/cpu/watchdog.h        |   22 -
 arch/sh/include/cpu-sh4/cpu/addrspace.h       |   41 -
 arch/sh/include/cpu-sh4/cpu/cache.h           |   41 -
 arch/sh/include/cpu-sh4/cpu/dma-register.h    |   98 -
 arch/sh/include/cpu-sh4/cpu/dma.h             |   18 -
 arch/sh/include/cpu-sh4/cpu/fpu.h             |   30 -
 arch/sh/include/cpu-sh4/cpu/freq.h            |   74 -
 arch/sh/include/cpu-sh4/cpu/mmu_context.h     |   79 -
 arch/sh/include/cpu-sh4/cpu/rtc.h             |   14 -
 arch/sh/include/cpu-sh4/cpu/sh7722.h          |  252 ---
 arch/sh/include/cpu-sh4/cpu/sh7723.h          |  285 ---
 arch/sh/include/cpu-sh4/cpu/sh7724.h          |  319 ----
 arch/sh/include/cpu-sh4/cpu/sh7734.h          |  307 ----
 arch/sh/include/cpu-sh4/cpu/sh7757.h          |  290 ---
 arch/sh/include/cpu-sh4/cpu/sh7785.h          |  260 ---
 arch/sh/include/cpu-sh4/cpu/sh7786.h          |  138 --
 arch/sh/include/cpu-sh4/cpu/shx3.h            |   65 -
 arch/sh/include/cpu-sh4/cpu/sigcontext.h      |   25 -
 arch/sh/include/cpu-sh4/cpu/sq.h              |   33 -
 arch/sh/include/cpu-sh4/cpu/watchdog.h        |   41 -
 arch/sh/include/cpu-sh4a/cpu/dma.h            |   72 -
 arch/sh/include/cpu-sh4a/cpu/serial.h         |    8 -
 arch/sh/include/mach-common/mach/highlander.h |  208 ---
 arch/sh/include/mach-common/mach/hp6xx.h      |   59 -
 arch/sh/include/mach-common/mach/lboxre2.h    |   24 -
 .../include/mach-common/mach/magicpanelr2.h   |   64 -
 .../sh/include/mach-common/mach/mangle-port.h |   46 -
 arch/sh/include/mach-common/mach/microdev.h   |   69 -
 arch/sh/include/mach-common/mach/r2d.h        |   71 -
 arch/sh/include/mach-common/mach/romimage.h   |   12 -
 arch/sh/include/mach-common/mach/sdk7780.h    |   79 -
 .../include/mach-common/mach/secureedge5410.h |   47 -
 arch/sh/include/mach-common/mach/sh2007.h     |  118 --
 arch/sh/include/mach-common/mach/sh7763rdp.h  |   50 -
 arch/sh/include/mach-common/mach/sh7785lcr.h  |   58 -
 arch/sh/include/mach-common/mach/shmin.h      |   10 -
 arch/sh/include/mach-common/mach/titan.h      |   20 -
 arch/sh/include/mach-common/mach/urquell.h    |   69 -
 arch/sh/include/mach-dreamcast/mach/dma.h     |   29 -
 arch/sh/include/mach-dreamcast/mach/maple.h   |   38 -
 arch/sh/include/mach-dreamcast/mach/pci.h     |   24 -
 arch/sh/include/mach-dreamcast/mach/sysasic.h |   46 -
 .../mach-ecovec24/mach/partner-jet-setup.txt  |   82 -
 arch/sh/include/mach-ecovec24/mach/romimage.h |   48 -
 arch/sh/include/mach-kfr2r09/mach/kfr2r09.h   |   24 -
 .../mach-kfr2r09/mach/partner-jet-setup.txt   |  144 --
 arch/sh/include/mach-kfr2r09/mach/romimage.h  |   31 -
 arch/sh/include/mach-landisk/mach/gio.h       |   38 -
 .../mach-landisk/mach/iodata_landisk.h        |   46 -
 arch/sh/include/mach-migor/mach/migor.h       |   16 -
 arch/sh/include/mach-sdk7786/mach/fpga.h      |  156 --
 arch/sh/include/mach-sdk7786/mach/irq.h       |    8 -
 arch/sh/include/mach-se/mach/mrshpc.h         |   53 -
 arch/sh/include/mach-se/mach/se.h             |  120 --
 arch/sh/include/mach-se/mach/se7206.h         |   14 -
 arch/sh/include/mach-se/mach/se7343.h         |  143 --
 arch/sh/include/mach-se/mach/se7721.h         |   68 -
 arch/sh/include/mach-se/mach/se7722.h         |   98 -
 arch/sh/include/mach-se/mach/se7724.h         |   69 -
 arch/sh/include/mach-se/mach/se7751.h         |   75 -
 arch/sh/include/mach-se/mach/se7780.h         |  106 --
 arch/sh/include/mach-sh03/mach/io.h           |   26 -
 arch/sh/include/mach-sh03/mach/sh03.h         |   19 -
 arch/sh/include/mach-x3proto/mach/hardware.h  |   13 -
 arch/sh/include/mach-x3proto/mach/ilsel.h     |   46 -
 arch/sh/include/uapi/asm/Kbuild               |    4 -
 arch/sh/include/uapi/asm/auxvec.h             |   39 -
 arch/sh/include/uapi/asm/byteorder.h          |   11 -
 arch/sh/include/uapi/asm/cachectl.h           |   20 -
 arch/sh/include/uapi/asm/cpu-features.h       |   28 -
 arch/sh/include/uapi/asm/hw_breakpoint.h      |    5 -
 arch/sh/include/uapi/asm/ioctls.h             |  116 --
 arch/sh/include/uapi/asm/posix_types.h        |    2 -
 arch/sh/include/uapi/asm/posix_types_32.h     |   23 -
 arch/sh/include/uapi/asm/ptrace.h             |   30 -
 arch/sh/include/uapi/asm/ptrace_32.h          |   78 -
 arch/sh/include/uapi/asm/sigcontext.h         |   25 -
 arch/sh/include/uapi/asm/signal.h             |   18 -
 arch/sh/include/uapi/asm/sockios.h            |   18 -
 arch/sh/include/uapi/asm/stat.h               |   78 -
 arch/sh/include/uapi/asm/swab.h               |   50 -
 arch/sh/include/uapi/asm/unistd.h             |    2 -
 arch/sh/kernel/.gitignore                     |    2 -
 arch/sh/kernel/Makefile                       |   49 -
 arch/sh/kernel/asm-offsets.c                  |   60 -
 arch/sh/kernel/cpu/Makefile                   |   21 -
 arch/sh/kernel/cpu/adc.c                      |   37 -
 arch/sh/kernel/cpu/clock-cpg.c                |   78 -
 arch/sh/kernel/cpu/clock.c                    |   52 -
 arch/sh/kernel/cpu/fpu.c                      |   92 -
 arch/sh/kernel/cpu/init.c                     |  366 ----
 arch/sh/kernel/cpu/irq/Makefile               |    6 -
 arch/sh/kernel/cpu/irq/imask.c                |   85 -
 arch/sh/kernel/cpu/irq/ipr.c                  |   80 -
 arch/sh/kernel/cpu/pfc.c                      |   25 -
 arch/sh/kernel/cpu/proc.c                     |  151 --
 arch/sh/kernel/cpu/sh2/Makefile               |   12 -
 arch/sh/kernel/cpu/sh2/clock-sh7619.c         |   74 -
 arch/sh/kernel/cpu/sh2/entry.S                |  373 ----
 arch/sh/kernel/cpu/sh2/ex.S                   |   44 -
 arch/sh/kernel/cpu/sh2/probe.c                |   71 -
 arch/sh/kernel/cpu/sh2/setup-sh7619.c         |  205 ---
 arch/sh/kernel/cpu/sh2/smp-j2.c               |  136 --
 arch/sh/kernel/cpu/sh2a/Makefile              |   25 -
 arch/sh/kernel/cpu/sh2a/clock-sh7201.c        |   82 -
 arch/sh/kernel/cpu/sh2a/clock-sh7203.c        |   78 -
 arch/sh/kernel/cpu/sh2a/clock-sh7206.c        |   80 -
 arch/sh/kernel/cpu/sh2a/clock-sh7264.c        |  157 --
 arch/sh/kernel/cpu/sh2a/clock-sh7269.c        |  181 --
 arch/sh/kernel/cpu/sh2a/entry.S               |  247 ---
 arch/sh/kernel/cpu/sh2a/ex.S                  |   70 -
 arch/sh/kernel/cpu/sh2a/fpu.c                 |  572 ------
 arch/sh/kernel/cpu/sh2a/opcode_helper.c       |   51 -
 arch/sh/kernel/cpu/sh2a/pinmux-sh7203.c       |   27 -
 arch/sh/kernel/cpu/sh2a/pinmux-sh7264.c       |   27 -
 arch/sh/kernel/cpu/sh2a/pinmux-sh7269.c       |   28 -
 arch/sh/kernel/cpu/sh2a/probe.c               |   57 -
 arch/sh/kernel/cpu/sh2a/setup-mxg.c           |  175 --
 arch/sh/kernel/cpu/sh2a/setup-sh7201.c        |  418 -----
 arch/sh/kernel/cpu/sh2a/setup-sh7203.c        |  355 ----
 arch/sh/kernel/cpu/sh2a/setup-sh7206.c        |  291 ---
 arch/sh/kernel/cpu/sh2a/setup-sh7264.c        |  552 ------
 arch/sh/kernel/cpu/sh2a/setup-sh7269.c        |  568 ------
 arch/sh/kernel/cpu/sh3/Makefile               |   34 -
 arch/sh/kernel/cpu/sh3/clock-sh3.c            |   86 -
 arch/sh/kernel/cpu/sh3/clock-sh7705.c         |   81 -
 arch/sh/kernel/cpu/sh3/clock-sh7706.c         |   81 -
 arch/sh/kernel/cpu/sh3/clock-sh7709.c         |   82 -
 arch/sh/kernel/cpu/sh3/clock-sh7710.c         |   75 -
 arch/sh/kernel/cpu/sh3/clock-sh7712.c         |   68 -
 arch/sh/kernel/cpu/sh3/entry.S                |  509 ------
 arch/sh/kernel/cpu/sh3/ex.S                   |   56 -
 arch/sh/kernel/cpu/sh3/pinmux-sh7720.c        |   27 -
 arch/sh/kernel/cpu/sh3/probe.c                |  108 --
 arch/sh/kernel/cpu/sh3/serial-sh770x.c        |   34 -
 arch/sh/kernel/cpu/sh3/serial-sh7710.c        |   21 -
 arch/sh/kernel/cpu/sh3/serial-sh7720.c        |   38 -
 arch/sh/kernel/cpu/sh3/setup-sh3.c            |   69 -
 arch/sh/kernel/cpu/sh3/setup-sh7705.c         |  190 --
 arch/sh/kernel/cpu/sh3/setup-sh770x.c         |  246 ---
 arch/sh/kernel/cpu/sh3/setup-sh7710.c         |  189 --
 arch/sh/kernel/cpu/sh3/setup-sh7720.c         |  286 ---
 arch/sh/kernel/cpu/sh3/swsusp.S               |  144 --
 arch/sh/kernel/cpu/sh4/Makefile               |   37 -
 arch/sh/kernel/cpu/sh4/clock-sh4-202.c        |  174 --
 arch/sh/kernel/cpu/sh4/clock-sh4.c            |   77 -
 arch/sh/kernel/cpu/sh4/fpu.c                  |  425 -----
 arch/sh/kernel/cpu/sh4/perf_event.c           |  265 ---
 arch/sh/kernel/cpu/sh4/probe.c                |  260 ---
 arch/sh/kernel/cpu/sh4/setup-sh4-202.c        |  139 --
 arch/sh/kernel/cpu/sh4/setup-sh7750.c         |  359 ----
 arch/sh/kernel/cpu/sh4/setup-sh7760.c         |  297 ---
 arch/sh/kernel/cpu/sh4/softfloat.c            |  930 ----------
 arch/sh/kernel/cpu/sh4/sq.c                   |  414 -----
 arch/sh/kernel/cpu/sh4a/Makefile              |   53 -
 arch/sh/kernel/cpu/sh4a/clock-sh7343.c        |  277 ---
 arch/sh/kernel/cpu/sh4a/clock-sh7366.c        |  270 ---
 arch/sh/kernel/cpu/sh4a/clock-sh7722.c        |  253 ---
 arch/sh/kernel/cpu/sh4a/clock-sh7723.c        |  301 ----
 arch/sh/kernel/cpu/sh4a/clock-sh7724.c        |  367 ----
 arch/sh/kernel/cpu/sh4a/clock-sh7734.c        |  256 ---
 arch/sh/kernel/cpu/sh4a/clock-sh7757.c        |  152 --
 arch/sh/kernel/cpu/sh4a/clock-sh7763.c        |  116 --
 arch/sh/kernel/cpu/sh4a/clock-sh7770.c        |   70 -
 arch/sh/kernel/cpu/sh4a/clock-sh7780.c        |  122 --
 arch/sh/kernel/cpu/sh4a/clock-sh7785.c        |  174 --
 arch/sh/kernel/cpu/sh4a/clock-sh7786.c        |  189 --
 arch/sh/kernel/cpu/sh4a/clock-shx3.c          |  148 --
 arch/sh/kernel/cpu/sh4a/intc-shx3.c           |   31 -
 arch/sh/kernel/cpu/sh4a/perf_event.c          |  299 ---
 arch/sh/kernel/cpu/sh4a/pinmux-sh7722.c       |   21 -
 arch/sh/kernel/cpu/sh4a/pinmux-sh7723.c       |   27 -
 arch/sh/kernel/cpu/sh4a/pinmux-sh7724.c       |   32 -
 arch/sh/kernel/cpu/sh4a/pinmux-sh7734.c       |   32 -
 arch/sh/kernel/cpu/sh4a/pinmux-sh7757.c       |   32 -
 arch/sh/kernel/cpu/sh4a/pinmux-sh7785.c       |   27 -
 arch/sh/kernel/cpu/sh4a/pinmux-sh7786.c       |   32 -
 arch/sh/kernel/cpu/sh4a/pinmux-shx3.c         |   26 -
 arch/sh/kernel/cpu/sh4a/serial-sh7722.c       |   24 -
 arch/sh/kernel/cpu/sh4a/setup-sh7343.c        |  444 -----
 arch/sh/kernel/cpu/sh4a/setup-sh7366.c        |  388 ----
 arch/sh/kernel/cpu/sh4a/setup-sh7722.c        |  666 -------
 arch/sh/kernel/cpu/sh4a/setup-sh7723.c        |  644 -------
 arch/sh/kernel/cpu/sh4a/setup-sh7724.c        | 1288 -------------
 arch/sh/kernel/cpu/sh4a/setup-sh7734.c        |  621 -------
 arch/sh/kernel/cpu/sh4a/setup-sh7757.c        | 1242 -------------
 arch/sh/kernel/cpu/sh4a/setup-sh7763.c        |  455 -----
 arch/sh/kernel/cpu/sh4a/setup-sh7770.c        |  571 ------
 arch/sh/kernel/cpu/sh4a/setup-sh7780.c        |  505 ------
 arch/sh/kernel/cpu/sh4a/setup-sh7785.c        |  608 -------
 arch/sh/kernel/cpu/sh4a/setup-sh7786.c        |  841 ---------
 arch/sh/kernel/cpu/sh4a/setup-shx3.c          |  396 ----
 arch/sh/kernel/cpu/sh4a/smp-shx3.c            |  146 --
 arch/sh/kernel/cpu/sh4a/ubc.c                 |  130 --
 arch/sh/kernel/cpu/shmobile/Makefile          |    8 -
 arch/sh/kernel/cpu/shmobile/cpuidle.c         |   95 -
 arch/sh/kernel/cpu/shmobile/pm.c              |  153 --
 arch/sh/kernel/cpu/shmobile/sleep.S           |  402 -----
 arch/sh/kernel/crash_dump.c                   |   27 -
 arch/sh/kernel/debugtraps.S                   |   38 -
 arch/sh/kernel/disassemble.c                  |  572 ------
 arch/sh/kernel/dma-coherent.c                 |   33 -
 arch/sh/kernel/dumpstack.c                    |  156 --
 arch/sh/kernel/dwarf.c                        | 1206 -------------
 arch/sh/kernel/entry-common.S                 |  400 ----
 arch/sh/kernel/ftrace.c                       |  365 ----
 arch/sh/kernel/head_32.S                      |  365 ----
 arch/sh/kernel/hw_breakpoint.c                |  408 -----
 arch/sh/kernel/idle.c                         |   57 -
 arch/sh/kernel/io.c                           |  111 --
 arch/sh/kernel/io_trapped.c                   |  291 ---
 arch/sh/kernel/iomap.c                        |  162 --
 arch/sh/kernel/ioport.c                       |   41 -
 arch/sh/kernel/irq.c                          |  249 ---
 arch/sh/kernel/irq_32.c                       |   54 -
 arch/sh/kernel/kdebugfs.c                     |   14 -
 arch/sh/kernel/kgdb.c                         |  378 ----
 arch/sh/kernel/kprobes.c                      |  452 -----
 arch/sh/kernel/machine_kexec.c                |  204 ---
 arch/sh/kernel/machvec.c                      |  122 --
 arch/sh/kernel/module.c                       |  104 --
 arch/sh/kernel/nmi_debug.c                    |   75 -
 arch/sh/kernel/perf_callchain.c               |   32 -
 arch/sh/kernel/perf_event.c                   |  363 ----
 arch/sh/kernel/process.c                      |   77 -
 arch/sh/kernel/process_32.c                   |  197 --
 arch/sh/kernel/ptrace.c                       |   34 -
 arch/sh/kernel/ptrace_32.c                    |  487 -----
 arch/sh/kernel/reboot.c                       |   96 -
 arch/sh/kernel/relocate_kernel.S              |  230 ---
 arch/sh/kernel/return_address.c               |   56 -
 arch/sh/kernel/setup.c                        |  356 ----
 arch/sh/kernel/sh_bios.c                      |  169 --
 arch/sh/kernel/sh_ksyms_32.c                  |  118 --
 arch/sh/kernel/signal_32.c                    |  507 ------
 arch/sh/kernel/smp.c                          |  471 -----
 arch/sh/kernel/stacktrace.c                   |   79 -
 arch/sh/kernel/swsusp.c                       |   35 -
 arch/sh/kernel/sys_sh.c                       |   96 -
 arch/sh/kernel/sys_sh32.c                     |   61 -
 arch/sh/kernel/syscalls/Makefile              |   32 -
 arch/sh/kernel/syscalls/syscall.tbl           |  455 -----
 arch/sh/kernel/syscalls_32.S                  |   17 -
 arch/sh/kernel/time.c                         |   45 -
 arch/sh/kernel/topology.c                     |   74 -
 arch/sh/kernel/traps.c                        |  204 ---
 arch/sh/kernel/traps_32.c                     |  795 --------
 arch/sh/kernel/unwinder.c                     |  165 --
 arch/sh/kernel/vmlinux.lds.S                  |   82 -
 arch/sh/kernel/vsyscall/.gitignore            |    2 -
 arch/sh/kernel/vsyscall/Makefile              |   36 -
 arch/sh/kernel/vsyscall/vsyscall-note.S       |   26 -
 arch/sh/kernel/vsyscall/vsyscall-sigreturn.S  |   75 -
 arch/sh/kernel/vsyscall/vsyscall-syscall.S    |   11 -
 arch/sh/kernel/vsyscall/vsyscall-trapa.S      |   40 -
 arch/sh/kernel/vsyscall/vsyscall.c            |   93 -
 arch/sh/kernel/vsyscall/vsyscall.lds.S        |   85 -
 arch/sh/lib/Makefile                          |   32 -
 arch/sh/lib/__clear_user.S                    |  109 --
 arch/sh/lib/ashiftrt.S                        |  128 --
 arch/sh/lib/ashldi3.c                         |   30 -
 arch/sh/lib/ashlsi3.S                         |  189 --
 arch/sh/lib/ashrdi3.c                         |   32 -
 arch/sh/lib/ashrsi3.S                         |  179 --
 arch/sh/lib/checksum.S                        |  365 ----
 arch/sh/lib/copy_page.S                       |  390 ----
 arch/sh/lib/delay.c                           |   54 -
 arch/sh/lib/div64-generic.c                   |   20 -
 arch/sh/lib/div64.S                           |   47 -
 arch/sh/lib/io.c                              |   79 -
 arch/sh/lib/libgcc.h                          |   27 -
 arch/sh/lib/lshrdi3.c                         |   30 -
 arch/sh/lib/lshrsi3.S                         |  188 --
 arch/sh/lib/mcount.S                          |  287 ---
 arch/sh/lib/memchr.S                          |   27 -
 arch/sh/lib/memcpy-sh4.S                      |  800 --------
 arch/sh/lib/memcpy.S                          |  228 ---
 arch/sh/lib/memmove.S                         |  255 ---
 arch/sh/lib/memset-sh4.S                      |  108 --
 arch/sh/lib/memset.S                          |   59 -
 arch/sh/lib/movmem.S                          |  217 ---
 arch/sh/lib/strlen.S                          |   71 -
 arch/sh/lib/udiv_qrnnd.S                      |   60 -
 arch/sh/lib/udivsi3.S                         |   66 -
 arch/sh/lib/udivsi3_i4i-Os.S                  |  128 --
 arch/sh/lib/udivsi3_i4i.S                     |  645 -------
 arch/sh/math-emu/Makefile                     |    2 -
 arch/sh/math-emu/math.c                       |  506 ------
 arch/sh/math-emu/sfp-util.h                   |   73 -
 arch/sh/mm/Kconfig                            |  254 ---
 arch/sh/mm/Makefile                           |   45 -
 arch/sh/mm/alignment.c                        |  189 --
 arch/sh/mm/asids-debugfs.c                    |   59 -
 arch/sh/mm/cache-debugfs.c                    |  109 --
 arch/sh/mm/cache-j2.c                         |   64 -
 arch/sh/mm/cache-sh2.c                        |   90 -
 arch/sh/mm/cache-sh2a.c                       |  188 --
 arch/sh/mm/cache-sh3.c                        |  102 --
 arch/sh/mm/cache-sh4.c                        |  390 ----
 arch/sh/mm/cache-sh7705.c                     |  194 --
 arch/sh/mm/cache-shx3.c                       |   44 -
 arch/sh/mm/cache.c                            |  360 ----
 arch/sh/mm/consistent.c                       |   65 -
 arch/sh/mm/extable_32.c                       |   24 -
 arch/sh/mm/fault.c                            |  504 ------
 arch/sh/mm/flush-sh4.c                        |  111 --
 arch/sh/mm/hugetlbpage.c                      |   82 -
 arch/sh/mm/init.c                             |  424 -----
 arch/sh/mm/ioremap.c                          |  192 --
 arch/sh/mm/ioremap.h                          |   23 -
 arch/sh/mm/ioremap_fixed.c                    |  135 --
 arch/sh/mm/kmap.c                             |   65 -
 arch/sh/mm/mmap.c                             |  184 --
 arch/sh/mm/nommu.c                            |   98 -
 arch/sh/mm/numa.c                             |   56 -
 arch/sh/mm/pgtable.c                          |   57 -
 arch/sh/mm/pmb.c                              |  887 ---------
 arch/sh/mm/sram.c                             |   35 -
 arch/sh/mm/tlb-debugfs.c                      |  160 --
 arch/sh/mm/tlb-pteaex.c                       |  106 --
 arch/sh/mm/tlb-sh3.c                          |   95 -
 arch/sh/mm/tlb-sh4.c                          |  108 --
 arch/sh/mm/tlb-urb.c                          |   93 -
 arch/sh/mm/tlbex_32.c                         |   82 -
 arch/sh/mm/tlbflush_32.c                      |  137 --
 arch/sh/mm/uncached.c                         |   44 -
 arch/sh/tools/Makefile                        |   16 -
 arch/sh/tools/gen-mach-types                  |   48 -
 arch/sh/tools/mach-types                      |   67 -
 drivers/clocksource/sh_cmt.c                  |    8 -
 drivers/clocksource/sh_mtu2.c                 |    8 -
 drivers/clocksource/sh_tmu.c                  |    8 -
 drivers/i2c/busses/Kconfig                    |    4 +-
 drivers/media/platform/renesas/Kconfig        |    2 +-
 drivers/mmc/host/Kconfig                      |    6 +-
 drivers/mmc/host/sh_mmcif.c                   |   21 +-
 drivers/net/ethernet/8390/Kconfig             |    2 +-
 drivers/net/ethernet/renesas/Kconfig          |    2 +-
 drivers/net/ethernet/smsc/Kconfig             |    4 +-
 drivers/rtc/Kconfig                           |    4 +-
 drivers/rtc/rtc-sh.c                          |   18 +-
 drivers/spi/Kconfig                           |    4 +-
 drivers/tty/serial/Kconfig                    |    3 +-
 drivers/tty/serial/sh-sci.c                   |   57 -
 drivers/tty/vt/keyboard.c                     |    2 +-
 drivers/usb/renesas_usbhs/Kconfig             |    2 +-
 drivers/video/console/Kconfig                 |    2 +-
 drivers/video/logo/Kconfig                    |   15 -
 drivers/video/logo/Makefile                   |    3 -
 drivers/video/logo/logo.c                     |   12 -
 drivers/video/logo/logo_superh_clut224.ppm    | 1604 -----------------
 drivers/video/logo/logo_superh_vga16.ppm      | 1604 -----------------
 fs/Kconfig.binfmt                             |    2 +-
 fs/minix/Kconfig                              |    2 +-
 include/linux/cpuhotplug.h                    |    1 -
 include/linux/sh_intc.h                       |    4 -
 init/Kconfig                                  |    2 +-
 kernel/sysctl.c                               |    3 +-
 lib/Kconfig.debug                             |    2 +-
 lib/math/div64.c                              |    4 +-
 lib/test_user_copy.c                          |    3 +-
 scripts/coccinelle/misc/cond_no_effect.cocci  |   13 +-
 scripts/head-object-list.txt                  |    1 -
 sound/soc/sh/Kconfig                          |    4 +-
 tools/include/asm/barrier.h                   |    2 -
 tools/perf/util/dwarf-regs.c                  |    1 -
 785 files changed, 36 insertions(+), 97715 deletions(-)
 delete mode 100644 Documentation/sh/booting.rst
 delete mode 100644 Documentation/sh/features.rst
 delete mode 100644 Documentation/sh/index.rst
 delete mode 100644 Documentation/sh/new-machine.rst
 delete mode 100644 Documentation/sh/register-banks.rst
 delete mode 100644 arch/sh/Kbuild
 delete mode 100644 arch/sh/Kconfig
 delete mode 100644 arch/sh/Kconfig.cpu
 delete mode 100644 arch/sh/Kconfig.debug
 delete mode 100644 arch/sh/Makefile
 delete mode 100644 arch/sh/boards/Kconfig
 delete mode 100644 arch/sh/boards/Makefile
 delete mode 100644 arch/sh/boards/board-apsh4a3a.c
 delete mode 100644 arch/sh/boards/board-apsh4ad0a.c
 delete mode 100644 arch/sh/boards/board-edosk7705.c
 delete mode 100644 arch/sh/boards/board-edosk7760.c
 delete mode 100644 arch/sh/boards/board-espt.c
 delete mode 100644 arch/sh/boards/board-magicpanelr2.c
 delete mode 100644 arch/sh/boards/board-polaris.c
 delete mode 100644 arch/sh/boards/board-secureedge5410.c
 delete mode 100644 arch/sh/boards/board-sh2007.c
 delete mode 100644 arch/sh/boards/board-sh7757lcr.c
 delete mode 100644 arch/sh/boards/board-sh7785lcr.c
 delete mode 100644 arch/sh/boards/board-shmin.c
 delete mode 100644 arch/sh/boards/board-titan.c
 delete mode 100644 arch/sh/boards/board-urquell.c
 delete mode 100644 arch/sh/boards/mach-ap325rxa/Makefile
 delete mode 100644 arch/sh/boards/mach-ap325rxa/sdram.S
 delete mode 100644 arch/sh/boards/mach-ap325rxa/setup.c
 delete mode 100644 arch/sh/boards/mach-dreamcast/Makefile
 delete mode 100644 arch/sh/boards/mach-dreamcast/irq.c
 delete mode 100644 arch/sh/boards/mach-dreamcast/rtc.c
 delete mode 100644 arch/sh/boards/mach-dreamcast/setup.c
 delete mode 100644 arch/sh/boards/mach-ecovec24/Makefile
 delete mode 100644 arch/sh/boards/mach-ecovec24/sdram.S
 delete mode 100644 arch/sh/boards/mach-ecovec24/setup.c
 delete mode 100644 arch/sh/boards/mach-highlander/Kconfig
 delete mode 100644 arch/sh/boards/mach-highlander/Makefile
 delete mode 100644 arch/sh/boards/mach-highlander/irq-r7780mp.c
 delete mode 100644 arch/sh/boards/mach-highlander/irq-r7780rp.c
 delete mode 100644 arch/sh/boards/mach-highlander/irq-r7785rp.c
 delete mode 100644 arch/sh/boards/mach-highlander/pinmux-r7785rp.c
 delete mode 100644 arch/sh/boards/mach-highlander/psw.c
 delete mode 100644 arch/sh/boards/mach-highlander/setup.c
 delete mode 100644 arch/sh/boards/mach-hp6xx/Makefile
 delete mode 100644 arch/sh/boards/mach-hp6xx/hp6xx_apm.c
 delete mode 100644 arch/sh/boards/mach-hp6xx/pm.c
 delete mode 100644 arch/sh/boards/mach-hp6xx/pm_wakeup.S
 delete mode 100644 arch/sh/boards/mach-hp6xx/setup.c
 delete mode 100644 arch/sh/boards/mach-kfr2r09/Makefile
 delete mode 100644 arch/sh/boards/mach-kfr2r09/lcd_wqvga.c
 delete mode 100644 arch/sh/boards/mach-kfr2r09/sdram.S
 delete mode 100644 arch/sh/boards/mach-kfr2r09/setup.c
 delete mode 100644 arch/sh/boards/mach-landisk/Makefile
 delete mode 100644 arch/sh/boards/mach-landisk/gio.c
 delete mode 100644 arch/sh/boards/mach-landisk/irq.c
 delete mode 100644 arch/sh/boards/mach-landisk/psw.c
 delete mode 100644 arch/sh/boards/mach-landisk/setup.c
 delete mode 100644 arch/sh/boards/mach-lboxre2/Makefile
 delete mode 100644 arch/sh/boards/mach-lboxre2/irq.c
 delete mode 100644 arch/sh/boards/mach-lboxre2/setup.c
 delete mode 100644 arch/sh/boards/mach-microdev/Makefile
 delete mode 100644 arch/sh/boards/mach-microdev/fdc37c93xapm.c
 delete mode 100644 arch/sh/boards/mach-microdev/io.c
 delete mode 100644 arch/sh/boards/mach-microdev/irq.c
 delete mode 100644 arch/sh/boards/mach-microdev/setup.c
 delete mode 100644 arch/sh/boards/mach-migor/Kconfig
 delete mode 100644 arch/sh/boards/mach-migor/Makefile
 delete mode 100644 arch/sh/boards/mach-migor/lcd_qvga.c
 delete mode 100644 arch/sh/boards/mach-migor/sdram.S
 delete mode 100644 arch/sh/boards/mach-migor/setup.c
 delete mode 100644 arch/sh/boards/mach-r2d/Kconfig
 delete mode 100644 arch/sh/boards/mach-r2d/Makefile
 delete mode 100644 arch/sh/boards/mach-r2d/irq.c
 delete mode 100644 arch/sh/boards/mach-r2d/setup.c
 delete mode 100644 arch/sh/boards/mach-rsk/Kconfig
 delete mode 100644 arch/sh/boards/mach-rsk/Makefile
 delete mode 100644 arch/sh/boards/mach-rsk/devices-rsk7203.c
 delete mode 100644 arch/sh/boards/mach-rsk/devices-rsk7264.c
 delete mode 100644 arch/sh/boards/mach-rsk/devices-rsk7269.c
 delete mode 100644 arch/sh/boards/mach-rsk/setup.c
 delete mode 100644 arch/sh/boards/mach-sdk7780/Kconfig
 delete mode 100644 arch/sh/boards/mach-sdk7780/Makefile
 delete mode 100644 arch/sh/boards/mach-sdk7780/irq.c
 delete mode 100644 arch/sh/boards/mach-sdk7780/setup.c
 delete mode 100644 arch/sh/boards/mach-sdk7786/Makefile
 delete mode 100644 arch/sh/boards/mach-sdk7786/fpga.c
 delete mode 100644 arch/sh/boards/mach-sdk7786/gpio.c
 delete mode 100644 arch/sh/boards/mach-sdk7786/irq.c
 delete mode 100644 arch/sh/boards/mach-sdk7786/nmi.c
 delete mode 100644 arch/sh/boards/mach-sdk7786/setup.c
 delete mode 100644 arch/sh/boards/mach-sdk7786/sram.c
 delete mode 100644 arch/sh/boards/mach-se/7206/Makefile
 delete mode 100644 arch/sh/boards/mach-se/7206/irq.c
 delete mode 100644 arch/sh/boards/mach-se/7206/setup.c
 delete mode 100644 arch/sh/boards/mach-se/7343/Makefile
 delete mode 100644 arch/sh/boards/mach-se/7343/irq.c
 delete mode 100644 arch/sh/boards/mach-se/7343/setup.c
 delete mode 100644 arch/sh/boards/mach-se/770x/Makefile
 delete mode 100644 arch/sh/boards/mach-se/770x/irq.c
 delete mode 100644 arch/sh/boards/mach-se/770x/setup.c
 delete mode 100644 arch/sh/boards/mach-se/7721/Makefile
 delete mode 100644 arch/sh/boards/mach-se/7721/irq.c
 delete mode 100644 arch/sh/boards/mach-se/7721/setup.c
 delete mode 100644 arch/sh/boards/mach-se/7722/Makefile
 delete mode 100644 arch/sh/boards/mach-se/7722/irq.c
 delete mode 100644 arch/sh/boards/mach-se/7722/setup.c
 delete mode 100644 arch/sh/boards/mach-se/7724/Makefile
 delete mode 100644 arch/sh/boards/mach-se/7724/irq.c
 delete mode 100644 arch/sh/boards/mach-se/7724/sdram.S
 delete mode 100644 arch/sh/boards/mach-se/7724/setup.c
 delete mode 100644 arch/sh/boards/mach-se/7751/Makefile
 delete mode 100644 arch/sh/boards/mach-se/7751/irq.c
 delete mode 100644 arch/sh/boards/mach-se/7751/setup.c
 delete mode 100644 arch/sh/boards/mach-se/7780/Makefile
 delete mode 100644 arch/sh/boards/mach-se/7780/irq.c
 delete mode 100644 arch/sh/boards/mach-se/7780/setup.c
 delete mode 100644 arch/sh/boards/mach-se/Makefile
 delete mode 100644 arch/sh/boards/mach-se/board-se7619.c
 delete mode 100644 arch/sh/boards/mach-sh03/Makefile
 delete mode 100644 arch/sh/boards/mach-sh03/rtc.c
 delete mode 100644 arch/sh/boards/mach-sh03/setup.c
 delete mode 100644 arch/sh/boards/mach-sh7763rdp/Makefile
 delete mode 100644 arch/sh/boards/mach-sh7763rdp/irq.c
 delete mode 100644 arch/sh/boards/mach-sh7763rdp/setup.c
 delete mode 100644 arch/sh/boards/mach-x3proto/Makefile
 delete mode 100644 arch/sh/boards/mach-x3proto/gpio.c
 delete mode 100644 arch/sh/boards/mach-x3proto/ilsel.c
 delete mode 100644 arch/sh/boards/mach-x3proto/setup.c
 delete mode 100644 arch/sh/boards/of-generic.c
 delete mode 100644 arch/sh/boot/.gitignore
 delete mode 100644 arch/sh/boot/Makefile
 delete mode 100644 arch/sh/boot/compressed/.gitignore
 delete mode 100644 arch/sh/boot/compressed/Makefile
 delete mode 100644 arch/sh/boot/compressed/ashiftrt.S
 delete mode 100644 arch/sh/boot/compressed/ashldi3.c
 delete mode 100644 arch/sh/boot/compressed/ashlsi3.S
 delete mode 100644 arch/sh/boot/compressed/ashrsi3.S
 delete mode 100644 arch/sh/boot/compressed/cache.c
 delete mode 100644 arch/sh/boot/compressed/head_32.S
 delete mode 100644 arch/sh/boot/compressed/head_64.S
 delete mode 100644 arch/sh/boot/compressed/lshrsi3.S
 delete mode 100644 arch/sh/boot/compressed/misc.c
 delete mode 100644 arch/sh/boot/compressed/vmlinux.scr
 delete mode 100644 arch/sh/boot/dts/Makefile
 delete mode 100644 arch/sh/boot/dts/j2_mimas_v2.dts
 delete mode 100644 arch/sh/boot/romimage/Makefile
 delete mode 100644 arch/sh/boot/romimage/head.S
 delete mode 100644 arch/sh/boot/romimage/mmcif-sh7724.c
 delete mode 100644 arch/sh/boot/romimage/vmlinux.scr
 delete mode 100644 arch/sh/cchips/Kconfig
 delete mode 100644 arch/sh/cchips/hd6446x/Makefile
 delete mode 100644 arch/sh/cchips/hd6446x/hd64461.c
 delete mode 100644 arch/sh/configs/ap325rxa_defconfig
 delete mode 100644 arch/sh/configs/apsh4a3a_defconfig
 delete mode 100644 arch/sh/configs/apsh4ad0a_defconfig
 delete mode 100644 arch/sh/configs/dreamcast_defconfig
 delete mode 100644 arch/sh/configs/ecovec24-romimage_defconfig
 delete mode 100644 arch/sh/configs/ecovec24_defconfig
 delete mode 100644 arch/sh/configs/edosk7705_defconfig
 delete mode 100644 arch/sh/configs/edosk7760_defconfig
 delete mode 100644 arch/sh/configs/espt_defconfig
 delete mode 100644 arch/sh/configs/hp6xx_defconfig
 delete mode 100644 arch/sh/configs/j2_defconfig
 delete mode 100644 arch/sh/configs/kfr2r09-romimage_defconfig
 delete mode 100644 arch/sh/configs/kfr2r09_defconfig
 delete mode 100644 arch/sh/configs/landisk_defconfig
 delete mode 100644 arch/sh/configs/lboxre2_defconfig
 delete mode 100644 arch/sh/configs/magicpanelr2_defconfig
 delete mode 100644 arch/sh/configs/microdev_defconfig
 delete mode 100644 arch/sh/configs/migor_defconfig
 delete mode 100644 arch/sh/configs/polaris_defconfig
 delete mode 100644 arch/sh/configs/r7780mp_defconfig
 delete mode 100644 arch/sh/configs/r7785rp_defconfig
 delete mode 100644 arch/sh/configs/rsk7201_defconfig
 delete mode 100644 arch/sh/configs/rsk7203_defconfig
 delete mode 100644 arch/sh/configs/rsk7264_defconfig
 delete mode 100644 arch/sh/configs/rsk7269_defconfig
 delete mode 100644 arch/sh/configs/rts7751r2d1_defconfig
 delete mode 100644 arch/sh/configs/rts7751r2dplus_defconfig
 delete mode 100644 arch/sh/configs/sdk7780_defconfig
 delete mode 100644 arch/sh/configs/sdk7786_defconfig
 delete mode 100644 arch/sh/configs/se7206_defconfig
 delete mode 100644 arch/sh/configs/se7343_defconfig
 delete mode 100644 arch/sh/configs/se7619_defconfig
 delete mode 100644 arch/sh/configs/se7705_defconfig
 delete mode 100644 arch/sh/configs/se7712_defconfig
 delete mode 100644 arch/sh/configs/se7721_defconfig
 delete mode 100644 arch/sh/configs/se7722_defconfig
 delete mode 100644 arch/sh/configs/se7724_defconfig
 delete mode 100644 arch/sh/configs/se7750_defconfig
 delete mode 100644 arch/sh/configs/se7751_defconfig
 delete mode 100644 arch/sh/configs/se7780_defconfig
 delete mode 100644 arch/sh/configs/secureedge5410_defconfig
 delete mode 100644 arch/sh/configs/sh03_defconfig
 delete mode 100644 arch/sh/configs/sh2007_defconfig
 delete mode 100644 arch/sh/configs/sh7710voipgw_defconfig
 delete mode 100644 arch/sh/configs/sh7724_generic_defconfig
 delete mode 100644 arch/sh/configs/sh7757lcr_defconfig
 delete mode 100644 arch/sh/configs/sh7763rdp_defconfig
 delete mode 100644 arch/sh/configs/sh7770_generic_defconfig
 delete mode 100644 arch/sh/configs/sh7785lcr_32bit_defconfig
 delete mode 100644 arch/sh/configs/sh7785lcr_defconfig
 delete mode 100644 arch/sh/configs/shmin_defconfig
 delete mode 100644 arch/sh/configs/shx3_defconfig
 delete mode 100644 arch/sh/configs/titan_defconfig
 delete mode 100644 arch/sh/configs/ul2_defconfig
 delete mode 100644 arch/sh/configs/urquell_defconfig
 delete mode 100644 arch/sh/drivers/Kconfig
 delete mode 100644 arch/sh/drivers/Makefile
 delete mode 100644 arch/sh/drivers/dma/Kconfig
 delete mode 100644 arch/sh/drivers/dma/Makefile
 delete mode 100644 arch/sh/drivers/dma/dma-api.c
 delete mode 100644 arch/sh/drivers/dma/dma-g2.c
 delete mode 100644 arch/sh/drivers/dma/dma-pvr2.c
 delete mode 100644 arch/sh/drivers/dma/dma-sh.c
 delete mode 100644 arch/sh/drivers/dma/dma-sysfs.c
 delete mode 100644 arch/sh/drivers/dma/dmabrg.c
 delete mode 100644 arch/sh/drivers/heartbeat.c
 delete mode 100644 arch/sh/drivers/pci/Makefile
 delete mode 100644 arch/sh/drivers/pci/common.c
 delete mode 100644 arch/sh/drivers/pci/fixups-dreamcast.c
 delete mode 100644 arch/sh/drivers/pci/fixups-landisk.c
 delete mode 100644 arch/sh/drivers/pci/fixups-r7780rp.c
 delete mode 100644 arch/sh/drivers/pci/fixups-rts7751r2d.c
 delete mode 100644 arch/sh/drivers/pci/fixups-sdk7780.c
 delete mode 100644 arch/sh/drivers/pci/fixups-sdk7786.c
 delete mode 100644 arch/sh/drivers/pci/fixups-se7751.c
 delete mode 100644 arch/sh/drivers/pci/fixups-sh03.c
 delete mode 100644 arch/sh/drivers/pci/fixups-snapgear.c
 delete mode 100644 arch/sh/drivers/pci/fixups-titan.c
 delete mode 100644 arch/sh/drivers/pci/ops-dreamcast.c
 delete mode 100644 arch/sh/drivers/pci/ops-sh4.c
 delete mode 100644 arch/sh/drivers/pci/ops-sh7786.c
 delete mode 100644 arch/sh/drivers/pci/pci-dreamcast.c
 delete mode 100644 arch/sh/drivers/pci/pci-sh4.h
 delete mode 100644 arch/sh/drivers/pci/pci-sh7751.c
 delete mode 100644 arch/sh/drivers/pci/pci-sh7751.h
 delete mode 100644 arch/sh/drivers/pci/pci-sh7780.c
 delete mode 100644 arch/sh/drivers/pci/pci-sh7780.h
 delete mode 100644 arch/sh/drivers/pci/pci.c
 delete mode 100644 arch/sh/drivers/pci/pcie-sh7786.c
 delete mode 100644 arch/sh/drivers/pci/pcie-sh7786.h
 delete mode 100644 arch/sh/drivers/platform_early.c
 delete mode 100644 arch/sh/drivers/push-switch.c
 delete mode 100644 arch/sh/drivers/superhyway/Makefile
 delete mode 100644 arch/sh/drivers/superhyway/ops-sh4-202.c
 delete mode 100644 arch/sh/include/asm/Kbuild
 delete mode 100644 arch/sh/include/asm/adc.h
 delete mode 100644 arch/sh/include/asm/addrspace.h
 delete mode 100644 arch/sh/include/asm/alignment.h
 delete mode 100644 arch/sh/include/asm/asm-offsets.h
 delete mode 100644 arch/sh/include/asm/atomic-grb.h
 delete mode 100644 arch/sh/include/asm/atomic-irq.h
 delete mode 100644 arch/sh/include/asm/atomic-llsc.h
 delete mode 100644 arch/sh/include/asm/atomic.h
 delete mode 100644 arch/sh/include/asm/barrier.h
 delete mode 100644 arch/sh/include/asm/bitops-cas.h
 delete mode 100644 arch/sh/include/asm/bitops-grb.h
 delete mode 100644 arch/sh/include/asm/bitops-llsc.h
 delete mode 100644 arch/sh/include/asm/bitops-op32.h
 delete mode 100644 arch/sh/include/asm/bitops.h
 delete mode 100644 arch/sh/include/asm/bl_bit.h
 delete mode 100644 arch/sh/include/asm/bl_bit_32.h
 delete mode 100644 arch/sh/include/asm/bug.h
 delete mode 100644 arch/sh/include/asm/bugs.h
 delete mode 100644 arch/sh/include/asm/cache.h
 delete mode 100644 arch/sh/include/asm/cache_insns.h
 delete mode 100644 arch/sh/include/asm/cache_insns_32.h
 delete mode 100644 arch/sh/include/asm/cacheflush.h
 delete mode 100644 arch/sh/include/asm/checksum.h
 delete mode 100644 arch/sh/include/asm/checksum_32.h
 delete mode 100644 arch/sh/include/asm/clock.h
 delete mode 100644 arch/sh/include/asm/cmpxchg-cas.h
 delete mode 100644 arch/sh/include/asm/cmpxchg-grb.h
 delete mode 100644 arch/sh/include/asm/cmpxchg-irq.h
 delete mode 100644 arch/sh/include/asm/cmpxchg-llsc.h
 delete mode 100644 arch/sh/include/asm/cmpxchg-xchg.h
 delete mode 100644 arch/sh/include/asm/cmpxchg.h
 delete mode 100644 arch/sh/include/asm/device.h
 delete mode 100644 arch/sh/include/asm/dma-register.h
 delete mode 100644 arch/sh/include/asm/dma.h
 delete mode 100644 arch/sh/include/asm/dmabrg.h
 delete mode 100644 arch/sh/include/asm/dwarf.h
 delete mode 100644 arch/sh/include/asm/elf.h
 delete mode 100644 arch/sh/include/asm/entry-macros.S
 delete mode 100644 arch/sh/include/asm/extable.h
 delete mode 100644 arch/sh/include/asm/fb.h
 delete mode 100644 arch/sh/include/asm/fixmap.h
 delete mode 100644 arch/sh/include/asm/flat.h
 delete mode 100644 arch/sh/include/asm/fpu.h
 delete mode 100644 arch/sh/include/asm/freq.h
 delete mode 100644 arch/sh/include/asm/ftrace.h
 delete mode 100644 arch/sh/include/asm/futex-cas.h
 delete mode 100644 arch/sh/include/asm/futex-irq.h
 delete mode 100644 arch/sh/include/asm/futex-llsc.h
 delete mode 100644 arch/sh/include/asm/futex.h
 delete mode 100644 arch/sh/include/asm/gpio.h
 delete mode 100644 arch/sh/include/asm/hardirq.h
 delete mode 100644 arch/sh/include/asm/hd64461.h
 delete mode 100644 arch/sh/include/asm/heartbeat.h
 delete mode 100644 arch/sh/include/asm/hugetlb.h
 delete mode 100644 arch/sh/include/asm/hw_breakpoint.h
 delete mode 100644 arch/sh/include/asm/hw_irq.h
 delete mode 100644 arch/sh/include/asm/i2c-sh7760.h
 delete mode 100644 arch/sh/include/asm/io.h
 delete mode 100644 arch/sh/include/asm/io_generic.h
 delete mode 100644 arch/sh/include/asm/io_noioport.h
 delete mode 100644 arch/sh/include/asm/io_trapped.h
 delete mode 100644 arch/sh/include/asm/irq.h
 delete mode 100644 arch/sh/include/asm/irqflags.h
 delete mode 100644 arch/sh/include/asm/kdebug.h
 delete mode 100644 arch/sh/include/asm/kexec.h
 delete mode 100644 arch/sh/include/asm/kgdb.h
 delete mode 100644 arch/sh/include/asm/kprobes.h
 delete mode 100644 arch/sh/include/asm/linkage.h
 delete mode 100644 arch/sh/include/asm/machvec.h
 delete mode 100644 arch/sh/include/asm/mmiowb.h
 delete mode 100644 arch/sh/include/asm/mmu.h
 delete mode 100644 arch/sh/include/asm/mmu_context.h
 delete mode 100644 arch/sh/include/asm/mmu_context_32.h
 delete mode 100644 arch/sh/include/asm/mmzone.h
 delete mode 100644 arch/sh/include/asm/module.h
 delete mode 100644 arch/sh/include/asm/page.h
 delete mode 100644 arch/sh/include/asm/pci.h
 delete mode 100644 arch/sh/include/asm/perf_event.h
 delete mode 100644 arch/sh/include/asm/pgalloc.h
 delete mode 100644 arch/sh/include/asm/pgtable-2level.h
 delete mode 100644 arch/sh/include/asm/pgtable-3level.h
 delete mode 100644 arch/sh/include/asm/pgtable.h
 delete mode 100644 arch/sh/include/asm/pgtable_32.h
 delete mode 100644 arch/sh/include/asm/platform_early.h
 delete mode 100644 arch/sh/include/asm/posix_types.h
 delete mode 100644 arch/sh/include/asm/processor.h
 delete mode 100644 arch/sh/include/asm/processor_32.h
 delete mode 100644 arch/sh/include/asm/ptrace.h
 delete mode 100644 arch/sh/include/asm/ptrace_32.h
 delete mode 100644 arch/sh/include/asm/push-switch.h
 delete mode 100644 arch/sh/include/asm/reboot.h
 delete mode 100644 arch/sh/include/asm/romimage-macros.h
 delete mode 100644 arch/sh/include/asm/rtc.h
 delete mode 100644 arch/sh/include/asm/seccomp.h
 delete mode 100644 arch/sh/include/asm/sections.h
 delete mode 100644 arch/sh/include/asm/setup.h
 delete mode 100644 arch/sh/include/asm/sfp-machine.h
 delete mode 100644 arch/sh/include/asm/sh7760fb.h
 delete mode 100644 arch/sh/include/asm/sh_bios.h
 delete mode 100644 arch/sh/include/asm/shmparam.h
 delete mode 100644 arch/sh/include/asm/siu.h
 delete mode 100644 arch/sh/include/asm/smc37c93x.h
 delete mode 100644 arch/sh/include/asm/smp-ops.h
 delete mode 100644 arch/sh/include/asm/smp.h
 delete mode 100644 arch/sh/include/asm/sparsemem.h
 delete mode 100644 arch/sh/include/asm/spi.h
 delete mode 100644 arch/sh/include/asm/spinlock-cas.h
 delete mode 100644 arch/sh/include/asm/spinlock-llsc.h
 delete mode 100644 arch/sh/include/asm/spinlock.h
 delete mode 100644 arch/sh/include/asm/spinlock_types.h
 delete mode 100644 arch/sh/include/asm/sram.h
 delete mode 100644 arch/sh/include/asm/stackprotector.h
 delete mode 100644 arch/sh/include/asm/stacktrace.h
 delete mode 100644 arch/sh/include/asm/string.h
 delete mode 100644 arch/sh/include/asm/string_32.h
 delete mode 100644 arch/sh/include/asm/suspend.h
 delete mode 100644 arch/sh/include/asm/switch_to.h
 delete mode 100644 arch/sh/include/asm/switch_to_32.h
 delete mode 100644 arch/sh/include/asm/syscall.h
 delete mode 100644 arch/sh/include/asm/syscall_32.h
 delete mode 100644 arch/sh/include/asm/syscalls.h
 delete mode 100644 arch/sh/include/asm/syscalls_32.h
 delete mode 100644 arch/sh/include/asm/thread_info.h
 delete mode 100644 arch/sh/include/asm/timex.h
 delete mode 100644 arch/sh/include/asm/tlb.h
 delete mode 100644 arch/sh/include/asm/tlbflush.h
 delete mode 100644 arch/sh/include/asm/topology.h
 delete mode 100644 arch/sh/include/asm/traps.h
 delete mode 100644 arch/sh/include/asm/traps_32.h
 delete mode 100644 arch/sh/include/asm/types.h
 delete mode 100644 arch/sh/include/asm/uaccess.h
 delete mode 100644 arch/sh/include/asm/uaccess_32.h
 delete mode 100644 arch/sh/include/asm/uncached.h
 delete mode 100644 arch/sh/include/asm/unistd.h
 delete mode 100644 arch/sh/include/asm/unwinder.h
 delete mode 100644 arch/sh/include/asm/user.h
 delete mode 100644 arch/sh/include/asm/vermagic.h
 delete mode 100644 arch/sh/include/asm/vga.h
 delete mode 100644 arch/sh/include/asm/vmalloc.h
 delete mode 100644 arch/sh/include/asm/vmlinux.lds.h
 delete mode 100644 arch/sh/include/asm/watchdog.h
 delete mode 100644 arch/sh/include/asm/word-at-a-time.h
 delete mode 100644 arch/sh/include/cpu-common/cpu/addrspace.h
 delete mode 100644 arch/sh/include/cpu-common/cpu/mmu_context.h
 delete mode 100644 arch/sh/include/cpu-common/cpu/pfc.h
 delete mode 100644 arch/sh/include/cpu-common/cpu/rtc.h
 delete mode 100644 arch/sh/include/cpu-common/cpu/sigcontext.h
 delete mode 100644 arch/sh/include/cpu-common/cpu/timer.h
 delete mode 100644 arch/sh/include/cpu-sh2/cpu/cache.h
 delete mode 100644 arch/sh/include/cpu-sh2/cpu/freq.h
 delete mode 100644 arch/sh/include/cpu-sh2/cpu/watchdog.h
 delete mode 100644 arch/sh/include/cpu-sh2a/cpu/addrspace.h
 delete mode 100644 arch/sh/include/cpu-sh2a/cpu/cache.h
 delete mode 100644 arch/sh/include/cpu-sh2a/cpu/freq.h
 delete mode 100644 arch/sh/include/cpu-sh2a/cpu/rtc.h
 delete mode 100644 arch/sh/include/cpu-sh2a/cpu/sh7203.h
 delete mode 100644 arch/sh/include/cpu-sh2a/cpu/sh7264.h
 delete mode 100644 arch/sh/include/cpu-sh2a/cpu/sh7269.h
 delete mode 100644 arch/sh/include/cpu-sh2a/cpu/watchdog.h
 delete mode 100644 arch/sh/include/cpu-sh3/cpu/adc.h
 delete mode 100644 arch/sh/include/cpu-sh3/cpu/cache.h
 delete mode 100644 arch/sh/include/cpu-sh3/cpu/dac.h
 delete mode 100644 arch/sh/include/cpu-sh3/cpu/dma-register.h
 delete mode 100644 arch/sh/include/cpu-sh3/cpu/dma.h
 delete mode 100644 arch/sh/include/cpu-sh3/cpu/freq.h
 delete mode 100644 arch/sh/include/cpu-sh3/cpu/gpio.h
 delete mode 100644 arch/sh/include/cpu-sh3/cpu/mmu_context.h
 delete mode 100644 arch/sh/include/cpu-sh3/cpu/serial.h
 delete mode 100644 arch/sh/include/cpu-sh3/cpu/sh7720.h
 delete mode 100644 arch/sh/include/cpu-sh3/cpu/watchdog.h
 delete mode 100644 arch/sh/include/cpu-sh4/cpu/addrspace.h
 delete mode 100644 arch/sh/include/cpu-sh4/cpu/cache.h
 delete mode 100644 arch/sh/include/cpu-sh4/cpu/dma-register.h
 delete mode 100644 arch/sh/include/cpu-sh4/cpu/dma.h
 delete mode 100644 arch/sh/include/cpu-sh4/cpu/fpu.h
 delete mode 100644 arch/sh/include/cpu-sh4/cpu/freq.h
 delete mode 100644 arch/sh/include/cpu-sh4/cpu/mmu_context.h
 delete mode 100644 arch/sh/include/cpu-sh4/cpu/rtc.h
 delete mode 100644 arch/sh/include/cpu-sh4/cpu/sh7722.h
 delete mode 100644 arch/sh/include/cpu-sh4/cpu/sh7723.h
 delete mode 100644 arch/sh/include/cpu-sh4/cpu/sh7724.h
 delete mode 100644 arch/sh/include/cpu-sh4/cpu/sh7734.h
 delete mode 100644 arch/sh/include/cpu-sh4/cpu/sh7757.h
 delete mode 100644 arch/sh/include/cpu-sh4/cpu/sh7785.h
 delete mode 100644 arch/sh/include/cpu-sh4/cpu/sh7786.h
 delete mode 100644 arch/sh/include/cpu-sh4/cpu/shx3.h
 delete mode 100644 arch/sh/include/cpu-sh4/cpu/sigcontext.h
 delete mode 100644 arch/sh/include/cpu-sh4/cpu/sq.h
 delete mode 100644 arch/sh/include/cpu-sh4/cpu/watchdog.h
 delete mode 100644 arch/sh/include/cpu-sh4a/cpu/dma.h
 delete mode 100644 arch/sh/include/cpu-sh4a/cpu/serial.h
 delete mode 100644 arch/sh/include/mach-common/mach/highlander.h
 delete mode 100644 arch/sh/include/mach-common/mach/hp6xx.h
 delete mode 100644 arch/sh/include/mach-common/mach/lboxre2.h
 delete mode 100644 arch/sh/include/mach-common/mach/magicpanelr2.h
 delete mode 100644 arch/sh/include/mach-common/mach/mangle-port.h
 delete mode 100644 arch/sh/include/mach-common/mach/microdev.h
 delete mode 100644 arch/sh/include/mach-common/mach/r2d.h
 delete mode 100644 arch/sh/include/mach-common/mach/romimage.h
 delete mode 100644 arch/sh/include/mach-common/mach/sdk7780.h
 delete mode 100644 arch/sh/include/mach-common/mach/secureedge5410.h
 delete mode 100644 arch/sh/include/mach-common/mach/sh2007.h
 delete mode 100644 arch/sh/include/mach-common/mach/sh7763rdp.h
 delete mode 100644 arch/sh/include/mach-common/mach/sh7785lcr.h
 delete mode 100644 arch/sh/include/mach-common/mach/shmin.h
 delete mode 100644 arch/sh/include/mach-common/mach/titan.h
 delete mode 100644 arch/sh/include/mach-common/mach/urquell.h
 delete mode 100644 arch/sh/include/mach-dreamcast/mach/dma.h
 delete mode 100644 arch/sh/include/mach-dreamcast/mach/maple.h
 delete mode 100644 arch/sh/include/mach-dreamcast/mach/pci.h
 delete mode 100644 arch/sh/include/mach-dreamcast/mach/sysasic.h
 delete mode 100644 arch/sh/include/mach-ecovec24/mach/partner-jet-setup.txt
 delete mode 100644 arch/sh/include/mach-ecovec24/mach/romimage.h
 delete mode 100644 arch/sh/include/mach-kfr2r09/mach/kfr2r09.h
 delete mode 100644 arch/sh/include/mach-kfr2r09/mach/partner-jet-setup.txt
 delete mode 100644 arch/sh/include/mach-kfr2r09/mach/romimage.h
 delete mode 100644 arch/sh/include/mach-landisk/mach/gio.h
 delete mode 100644 arch/sh/include/mach-landisk/mach/iodata_landisk.h
 delete mode 100644 arch/sh/include/mach-migor/mach/migor.h
 delete mode 100644 arch/sh/include/mach-sdk7786/mach/fpga.h
 delete mode 100644 arch/sh/include/mach-sdk7786/mach/irq.h
 delete mode 100644 arch/sh/include/mach-se/mach/mrshpc.h
 delete mode 100644 arch/sh/include/mach-se/mach/se.h
 delete mode 100644 arch/sh/include/mach-se/mach/se7206.h
 delete mode 100644 arch/sh/include/mach-se/mach/se7343.h
 delete mode 100644 arch/sh/include/mach-se/mach/se7721.h
 delete mode 100644 arch/sh/include/mach-se/mach/se7722.h
 delete mode 100644 arch/sh/include/mach-se/mach/se7724.h
 delete mode 100644 arch/sh/include/mach-se/mach/se7751.h
 delete mode 100644 arch/sh/include/mach-se/mach/se7780.h
 delete mode 100644 arch/sh/include/mach-sh03/mach/io.h
 delete mode 100644 arch/sh/include/mach-sh03/mach/sh03.h
 delete mode 100644 arch/sh/include/mach-x3proto/mach/hardware.h
 delete mode 100644 arch/sh/include/mach-x3proto/mach/ilsel.h
 delete mode 100644 arch/sh/include/uapi/asm/Kbuild
 delete mode 100644 arch/sh/include/uapi/asm/auxvec.h
 delete mode 100644 arch/sh/include/uapi/asm/byteorder.h
 delete mode 100644 arch/sh/include/uapi/asm/cachectl.h
 delete mode 100644 arch/sh/include/uapi/asm/cpu-features.h
 delete mode 100644 arch/sh/include/uapi/asm/hw_breakpoint.h
 delete mode 100644 arch/sh/include/uapi/asm/ioctls.h
 delete mode 100644 arch/sh/include/uapi/asm/posix_types.h
 delete mode 100644 arch/sh/include/uapi/asm/posix_types_32.h
 delete mode 100644 arch/sh/include/uapi/asm/ptrace.h
 delete mode 100644 arch/sh/include/uapi/asm/ptrace_32.h
 delete mode 100644 arch/sh/include/uapi/asm/sigcontext.h
 delete mode 100644 arch/sh/include/uapi/asm/signal.h
 delete mode 100644 arch/sh/include/uapi/asm/sockios.h
 delete mode 100644 arch/sh/include/uapi/asm/stat.h
 delete mode 100644 arch/sh/include/uapi/asm/swab.h
 delete mode 100644 arch/sh/include/uapi/asm/unistd.h
 delete mode 100644 arch/sh/kernel/.gitignore
 delete mode 100644 arch/sh/kernel/Makefile
 delete mode 100644 arch/sh/kernel/asm-offsets.c
 delete mode 100644 arch/sh/kernel/cpu/Makefile
 delete mode 100644 arch/sh/kernel/cpu/adc.c
 delete mode 100644 arch/sh/kernel/cpu/clock-cpg.c
 delete mode 100644 arch/sh/kernel/cpu/clock.c
 delete mode 100644 arch/sh/kernel/cpu/fpu.c
 delete mode 100644 arch/sh/kernel/cpu/init.c
 delete mode 100644 arch/sh/kernel/cpu/irq/Makefile
 delete mode 100644 arch/sh/kernel/cpu/irq/imask.c
 delete mode 100644 arch/sh/kernel/cpu/irq/ipr.c
 delete mode 100644 arch/sh/kernel/cpu/pfc.c
 delete mode 100644 arch/sh/kernel/cpu/proc.c
 delete mode 100644 arch/sh/kernel/cpu/sh2/Makefile
 delete mode 100644 arch/sh/kernel/cpu/sh2/clock-sh7619.c
 delete mode 100644 arch/sh/kernel/cpu/sh2/entry.S
 delete mode 100644 arch/sh/kernel/cpu/sh2/ex.S
 delete mode 100644 arch/sh/kernel/cpu/sh2/probe.c
 delete mode 100644 arch/sh/kernel/cpu/sh2/setup-sh7619.c
 delete mode 100644 arch/sh/kernel/cpu/sh2/smp-j2.c
 delete mode 100644 arch/sh/kernel/cpu/sh2a/Makefile
 delete mode 100644 arch/sh/kernel/cpu/sh2a/clock-sh7201.c
 delete mode 100644 arch/sh/kernel/cpu/sh2a/clock-sh7203.c
 delete mode 100644 arch/sh/kernel/cpu/sh2a/clock-sh7206.c
 delete mode 100644 arch/sh/kernel/cpu/sh2a/clock-sh7264.c
 delete mode 100644 arch/sh/kernel/cpu/sh2a/clock-sh7269.c
 delete mode 100644 arch/sh/kernel/cpu/sh2a/entry.S
 delete mode 100644 arch/sh/kernel/cpu/sh2a/ex.S
 delete mode 100644 arch/sh/kernel/cpu/sh2a/fpu.c
 delete mode 100644 arch/sh/kernel/cpu/sh2a/opcode_helper.c
 delete mode 100644 arch/sh/kernel/cpu/sh2a/pinmux-sh7203.c
 delete mode 100644 arch/sh/kernel/cpu/sh2a/pinmux-sh7264.c
 delete mode 100644 arch/sh/kernel/cpu/sh2a/pinmux-sh7269.c
 delete mode 100644 arch/sh/kernel/cpu/sh2a/probe.c
 delete mode 100644 arch/sh/kernel/cpu/sh2a/setup-mxg.c
 delete mode 100644 arch/sh/kernel/cpu/sh2a/setup-sh7201.c
 delete mode 100644 arch/sh/kernel/cpu/sh2a/setup-sh7203.c
 delete mode 100644 arch/sh/kernel/cpu/sh2a/setup-sh7206.c
 delete mode 100644 arch/sh/kernel/cpu/sh2a/setup-sh7264.c
 delete mode 100644 arch/sh/kernel/cpu/sh2a/setup-sh7269.c
 delete mode 100644 arch/sh/kernel/cpu/sh3/Makefile
 delete mode 100644 arch/sh/kernel/cpu/sh3/clock-sh3.c
 delete mode 100644 arch/sh/kernel/cpu/sh3/clock-sh7705.c
 delete mode 100644 arch/sh/kernel/cpu/sh3/clock-sh7706.c
 delete mode 100644 arch/sh/kernel/cpu/sh3/clock-sh7709.c
 delete mode 100644 arch/sh/kernel/cpu/sh3/clock-sh7710.c
 delete mode 100644 arch/sh/kernel/cpu/sh3/clock-sh7712.c
 delete mode 100644 arch/sh/kernel/cpu/sh3/entry.S
 delete mode 100644 arch/sh/kernel/cpu/sh3/ex.S
 delete mode 100644 arch/sh/kernel/cpu/sh3/pinmux-sh7720.c
 delete mode 100644 arch/sh/kernel/cpu/sh3/probe.c
 delete mode 100644 arch/sh/kernel/cpu/sh3/serial-sh770x.c
 delete mode 100644 arch/sh/kernel/cpu/sh3/serial-sh7710.c
 delete mode 100644 arch/sh/kernel/cpu/sh3/serial-sh7720.c
 delete mode 100644 arch/sh/kernel/cpu/sh3/setup-sh3.c
 delete mode 100644 arch/sh/kernel/cpu/sh3/setup-sh7705.c
 delete mode 100644 arch/sh/kernel/cpu/sh3/setup-sh770x.c
 delete mode 100644 arch/sh/kernel/cpu/sh3/setup-sh7710.c
 delete mode 100644 arch/sh/kernel/cpu/sh3/setup-sh7720.c
 delete mode 100644 arch/sh/kernel/cpu/sh3/swsusp.S
 delete mode 100644 arch/sh/kernel/cpu/sh4/Makefile
 delete mode 100644 arch/sh/kernel/cpu/sh4/clock-sh4-202.c
 delete mode 100644 arch/sh/kernel/cpu/sh4/clock-sh4.c
 delete mode 100644 arch/sh/kernel/cpu/sh4/fpu.c
 delete mode 100644 arch/sh/kernel/cpu/sh4/perf_event.c
 delete mode 100644 arch/sh/kernel/cpu/sh4/probe.c
 delete mode 100644 arch/sh/kernel/cpu/sh4/setup-sh4-202.c
 delete mode 100644 arch/sh/kernel/cpu/sh4/setup-sh7750.c
 delete mode 100644 arch/sh/kernel/cpu/sh4/setup-sh7760.c
 delete mode 100644 arch/sh/kernel/cpu/sh4/softfloat.c
 delete mode 100644 arch/sh/kernel/cpu/sh4/sq.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/Makefile
 delete mode 100644 arch/sh/kernel/cpu/sh4a/clock-sh7343.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/clock-sh7366.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/clock-sh7722.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/clock-sh7723.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/clock-sh7724.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/clock-sh7734.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/clock-sh7757.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/clock-sh7763.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/clock-sh7770.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/clock-sh7780.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/clock-sh7785.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/clock-sh7786.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/clock-shx3.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/intc-shx3.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/perf_event.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/pinmux-sh7722.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/pinmux-sh7723.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/pinmux-sh7724.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/pinmux-sh7734.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/pinmux-sh7757.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/pinmux-sh7785.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/pinmux-sh7786.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/pinmux-shx3.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/serial-sh7722.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/setup-sh7343.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/setup-sh7366.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/setup-sh7722.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/setup-sh7723.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/setup-sh7724.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/setup-sh7734.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/setup-sh7757.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/setup-sh7763.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/setup-sh7770.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/setup-sh7780.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/setup-sh7785.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/setup-sh7786.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/setup-shx3.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/smp-shx3.c
 delete mode 100644 arch/sh/kernel/cpu/sh4a/ubc.c
 delete mode 100644 arch/sh/kernel/cpu/shmobile/Makefile
 delete mode 100644 arch/sh/kernel/cpu/shmobile/cpuidle.c
 delete mode 100644 arch/sh/kernel/cpu/shmobile/pm.c
 delete mode 100644 arch/sh/kernel/cpu/shmobile/sleep.S
 delete mode 100644 arch/sh/kernel/crash_dump.c
 delete mode 100644 arch/sh/kernel/debugtraps.S
 delete mode 100644 arch/sh/kernel/disassemble.c
 delete mode 100644 arch/sh/kernel/dma-coherent.c
 delete mode 100644 arch/sh/kernel/dumpstack.c
 delete mode 100644 arch/sh/kernel/dwarf.c
 delete mode 100644 arch/sh/kernel/entry-common.S
 delete mode 100644 arch/sh/kernel/ftrace.c
 delete mode 100644 arch/sh/kernel/head_32.S
 delete mode 100644 arch/sh/kernel/hw_breakpoint.c
 delete mode 100644 arch/sh/kernel/idle.c
 delete mode 100644 arch/sh/kernel/io.c
 delete mode 100644 arch/sh/kernel/io_trapped.c
 delete mode 100644 arch/sh/kernel/iomap.c
 delete mode 100644 arch/sh/kernel/ioport.c
 delete mode 100644 arch/sh/kernel/irq.c
 delete mode 100644 arch/sh/kernel/irq_32.c
 delete mode 100644 arch/sh/kernel/kdebugfs.c
 delete mode 100644 arch/sh/kernel/kgdb.c
 delete mode 100644 arch/sh/kernel/kprobes.c
 delete mode 100644 arch/sh/kernel/machine_kexec.c
 delete mode 100644 arch/sh/kernel/machvec.c
 delete mode 100644 arch/sh/kernel/module.c
 delete mode 100644 arch/sh/kernel/nmi_debug.c
 delete mode 100644 arch/sh/kernel/perf_callchain.c
 delete mode 100644 arch/sh/kernel/perf_event.c
 delete mode 100644 arch/sh/kernel/process.c
 delete mode 100644 arch/sh/kernel/process_32.c
 delete mode 100644 arch/sh/kernel/ptrace.c
 delete mode 100644 arch/sh/kernel/ptrace_32.c
 delete mode 100644 arch/sh/kernel/reboot.c
 delete mode 100644 arch/sh/kernel/relocate_kernel.S
 delete mode 100644 arch/sh/kernel/return_address.c
 delete mode 100644 arch/sh/kernel/setup.c
 delete mode 100644 arch/sh/kernel/sh_bios.c
 delete mode 100644 arch/sh/kernel/sh_ksyms_32.c
 delete mode 100644 arch/sh/kernel/signal_32.c
 delete mode 100644 arch/sh/kernel/smp.c
 delete mode 100644 arch/sh/kernel/stacktrace.c
 delete mode 100644 arch/sh/kernel/swsusp.c
 delete mode 100644 arch/sh/kernel/sys_sh.c
 delete mode 100644 arch/sh/kernel/sys_sh32.c
 delete mode 100644 arch/sh/kernel/syscalls/Makefile
 delete mode 100644 arch/sh/kernel/syscalls/syscall.tbl
 delete mode 100644 arch/sh/kernel/syscalls_32.S
 delete mode 100644 arch/sh/kernel/time.c
 delete mode 100644 arch/sh/kernel/topology.c
 delete mode 100644 arch/sh/kernel/traps.c
 delete mode 100644 arch/sh/kernel/traps_32.c
 delete mode 100644 arch/sh/kernel/unwinder.c
 delete mode 100644 arch/sh/kernel/vmlinux.lds.S
 delete mode 100644 arch/sh/kernel/vsyscall/.gitignore
 delete mode 100644 arch/sh/kernel/vsyscall/Makefile
 delete mode 100644 arch/sh/kernel/vsyscall/vsyscall-note.S
 delete mode 100644 arch/sh/kernel/vsyscall/vsyscall-sigreturn.S
 delete mode 100644 arch/sh/kernel/vsyscall/vsyscall-syscall.S
 delete mode 100644 arch/sh/kernel/vsyscall/vsyscall-trapa.S
 delete mode 100644 arch/sh/kernel/vsyscall/vsyscall.c
 delete mode 100644 arch/sh/kernel/vsyscall/vsyscall.lds.S
 delete mode 100644 arch/sh/lib/Makefile
 delete mode 100644 arch/sh/lib/__clear_user.S
 delete mode 100644 arch/sh/lib/ashiftrt.S
 delete mode 100644 arch/sh/lib/ashldi3.c
 delete mode 100644 arch/sh/lib/ashlsi3.S
 delete mode 100644 arch/sh/lib/ashrdi3.c
 delete mode 100644 arch/sh/lib/ashrsi3.S
 delete mode 100644 arch/sh/lib/checksum.S
 delete mode 100644 arch/sh/lib/copy_page.S
 delete mode 100644 arch/sh/lib/delay.c
 delete mode 100644 arch/sh/lib/div64-generic.c
 delete mode 100644 arch/sh/lib/div64.S
 delete mode 100644 arch/sh/lib/io.c
 delete mode 100644 arch/sh/lib/libgcc.h
 delete mode 100644 arch/sh/lib/lshrdi3.c
 delete mode 100644 arch/sh/lib/lshrsi3.S
 delete mode 100644 arch/sh/lib/mcount.S
 delete mode 100644 arch/sh/lib/memchr.S
 delete mode 100644 arch/sh/lib/memcpy-sh4.S
 delete mode 100644 arch/sh/lib/memcpy.S
 delete mode 100644 arch/sh/lib/memmove.S
 delete mode 100644 arch/sh/lib/memset-sh4.S
 delete mode 100644 arch/sh/lib/memset.S
 delete mode 100644 arch/sh/lib/movmem.S
 delete mode 100644 arch/sh/lib/strlen.S
 delete mode 100644 arch/sh/lib/udiv_qrnnd.S
 delete mode 100644 arch/sh/lib/udivsi3.S
 delete mode 100644 arch/sh/lib/udivsi3_i4i-Os.S
 delete mode 100644 arch/sh/lib/udivsi3_i4i.S
 delete mode 100644 arch/sh/math-emu/Makefile
 delete mode 100644 arch/sh/math-emu/math.c
 delete mode 100644 arch/sh/math-emu/sfp-util.h
 delete mode 100644 arch/sh/mm/Kconfig
 delete mode 100644 arch/sh/mm/Makefile
 delete mode 100644 arch/sh/mm/alignment.c
 delete mode 100644 arch/sh/mm/asids-debugfs.c
 delete mode 100644 arch/sh/mm/cache-debugfs.c
 delete mode 100644 arch/sh/mm/cache-j2.c
 delete mode 100644 arch/sh/mm/cache-sh2.c
 delete mode 100644 arch/sh/mm/cache-sh2a.c
 delete mode 100644 arch/sh/mm/cache-sh3.c
 delete mode 100644 arch/sh/mm/cache-sh4.c
 delete mode 100644 arch/sh/mm/cache-sh7705.c
 delete mode 100644 arch/sh/mm/cache-shx3.c
 delete mode 100644 arch/sh/mm/cache.c
 delete mode 100644 arch/sh/mm/consistent.c
 delete mode 100644 arch/sh/mm/extable_32.c
 delete mode 100644 arch/sh/mm/fault.c
 delete mode 100644 arch/sh/mm/flush-sh4.c
 delete mode 100644 arch/sh/mm/hugetlbpage.c
 delete mode 100644 arch/sh/mm/init.c
 delete mode 100644 arch/sh/mm/ioremap.c
 delete mode 100644 arch/sh/mm/ioremap.h
 delete mode 100644 arch/sh/mm/ioremap_fixed.c
 delete mode 100644 arch/sh/mm/kmap.c
 delete mode 100644 arch/sh/mm/mmap.c
 delete mode 100644 arch/sh/mm/nommu.c
 delete mode 100644 arch/sh/mm/numa.c
 delete mode 100644 arch/sh/mm/pgtable.c
 delete mode 100644 arch/sh/mm/pmb.c
 delete mode 100644 arch/sh/mm/sram.c
 delete mode 100644 arch/sh/mm/tlb-debugfs.c
 delete mode 100644 arch/sh/mm/tlb-pteaex.c
 delete mode 100644 arch/sh/mm/tlb-sh3.c
 delete mode 100644 arch/sh/mm/tlb-sh4.c
 delete mode 100644 arch/sh/mm/tlb-urb.c
 delete mode 100644 arch/sh/mm/tlbex_32.c
 delete mode 100644 arch/sh/mm/tlbflush_32.c
 delete mode 100644 arch/sh/mm/uncached.c
 delete mode 100644 arch/sh/tools/Makefile
 delete mode 100644 arch/sh/tools/gen-mach-types
 delete mode 100644 arch/sh/tools/mach-types
 delete mode 100644 drivers/video/logo/logo_superh_clut224.ppm
 delete mode 100644 drivers/video/logo/logo_superh_vga16.ppm

diff --git a/Documentation/arch.rst b/Documentation/arch.rst
index 41a66a8b38e424..18669458eec4dd 100644
--- a/Documentation/arch.rst
+++ b/Documentation/arch.rst
@@ -22,7 +22,6 @@ implementation.
    powerpc/index
    riscv/index
    s390/index
-   sh/index
    sparc/index
    x86/index
    xtensa/index
diff --git a/Documentation/sh/booting.rst b/Documentation/sh/booting.rst
deleted file mode 100644
index d851c49a01bf07..00000000000000
--- a/Documentation/sh/booting.rst
+++ /dev/null
@@ -1,12 +0,0 @@
-.. SPDX-License-Identifier: GPL-2.0
-
-DeviceTree Booting
-------------------
-
-  Device-tree compatible SH bootloaders are expected to provide the physical
-  address of the device tree blob in r4. Since legacy bootloaders did not
-  guarantee any particular initial register state, kernels built to
-  inter-operate with old bootloaders must either use a builtin DTB or
-  select a legacy board option (something other than CONFIG_SH_DEVICE_TREE)
-  that does not use device tree. Support for the latter is being phased out
-  in favor of device tree.
diff --git a/Documentation/sh/features.rst b/Documentation/sh/features.rst
deleted file mode 100644
index f722af3b6c9934..00000000000000
--- a/Documentation/sh/features.rst
+++ /dev/null
@@ -1,3 +0,0 @@
-.. SPDX-License-Identifier: GPL-2.0
-
-.. kernel-feat:: $srctree/Documentation/features sh
diff --git a/Documentation/sh/index.rst b/Documentation/sh/index.rst
deleted file mode 100644
index c64776738cf6b2..00000000000000
--- a/Documentation/sh/index.rst
+++ /dev/null
@@ -1,56 +0,0 @@
-=======================
-SuperH Interfaces Guide
-=======================
-
-:Author: Paul Mundt
-
-.. toctree::
-    :maxdepth: 1
-
-    booting
-    new-machine
-    register-banks
-
-    features
-
-Memory Management
-=================
-
-SH-4
-----
-
-Store Queue API
-~~~~~~~~~~~~~~~
-
-.. kernel-doc:: arch/sh/kernel/cpu/sh4/sq.c
-   :export:
-
-Machine Specific Interfaces
-===========================
-
-mach-dreamcast
---------------
-
-.. kernel-doc:: arch/sh/boards/mach-dreamcast/rtc.c
-   :internal:
-
-mach-x3proto
-------------
-
-.. kernel-doc:: arch/sh/boards/mach-x3proto/ilsel.c
-   :export:
-
-Busses
-======
-
-SuperHyway
-----------
-
-.. kernel-doc:: drivers/sh/superhyway/superhyway.c
-   :export:
-
-Maple
------
-
-.. kernel-doc:: drivers/sh/maple/maple.c
-   :export:
diff --git a/Documentation/sh/new-machine.rst b/Documentation/sh/new-machine.rst
deleted file mode 100644
index e501c52b3b30d2..00000000000000
--- a/Documentation/sh/new-machine.rst
+++ /dev/null
@@ -1,277 +0,0 @@
-.. SPDX-License-Identifier: GPL-2.0
-
-=============================
-Adding a new board to LinuxSH
-=============================
-
-               Paul Mundt <lethal@linux-sh.org>
-
-This document attempts to outline what steps are necessary to add support
-for new boards to the LinuxSH port under the new 2.5 and 2.6 kernels. This
-also attempts to outline some of the noticeable changes between the 2.4
-and the 2.5/2.6 SH backend.
-
-1. New Directory Structure
-==========================
-
-The first thing to note is the new directory structure. Under 2.4, most
-of the board-specific code (with the exception of stboards) ended up
-in arch/sh/kernel/ directly, with board-specific headers ending up in
-include/asm-sh/. For the new kernel, things are broken out by board type,
-companion chip type, and CPU type. Looking at a tree view of this directory
-hierarchy looks like the following:
-
-Board-specific code::
-
-    .
-    |-- arch
-    |   `-- sh
-    |       `-- boards
-    |           |-- adx
-    |           |   `-- board-specific files
-    |           |-- bigsur
-    |           |   `-- board-specific files
-    |           |
-    |           ... more boards here ...
-    |
-    `-- include
-	`-- asm-sh
-	    |-- adx
-	    |   `-- board-specific headers
-	    |-- bigsur
-	    |   `-- board-specific headers
-	    |
-	    .. more boards here ...
-
-Next, for companion chips::
-
-    .
-    `-- arch
-	`-- sh
-	    `-- cchips
-		`-- hd6446x
-		    `-- hd64461
-			`-- cchip-specific files
-
-... and so on. Headers for the companion chips are treated the same way as
-board-specific headers. Thus, include/asm-sh/hd64461 is home to all of the
-hd64461-specific headers.
-
-Finally, CPU family support is also abstracted::
-
-    .
-    |-- arch
-    |   `-- sh
-    |       |-- kernel
-    |       |   `-- cpu
-    |       |       |-- sh2
-    |       |       |   `-- SH-2 generic files
-    |       |       |-- sh3
-    |       |       |   `-- SH-3 generic files
-    |       |       `-- sh4
-    |       |           `-- SH-4 generic files
-    |       `-- mm
-    |           `-- This is also broken out per CPU family, so each family can
-    |               have their own set of cache/tlb functions.
-    |
-    `-- include
-	`-- asm-sh
-	    |-- cpu-sh2
-	    |   `-- SH-2 specific headers
-	    |-- cpu-sh3
-	    |   `-- SH-3 specific headers
-	    `-- cpu-sh4
-		`-- SH-4 specific headers
-
-It should be noted that CPU subtypes are _not_ abstracted. Thus, these still
-need to be dealt with by the CPU family specific code.
-
-2. Adding a New Board
-=====================
-
-The first thing to determine is whether the board you are adding will be
-isolated, or whether it will be part of a family of boards that can mostly
-share the same board-specific code with minor differences.
-
-In the first case, this is just a matter of making a directory for your
-board in arch/sh/boards/ and adding rules to hook your board in with the
-build system (more on this in the next section). However, for board families
-it makes more sense to have a common top-level arch/sh/boards/ directory
-and then populate that with sub-directories for each member of the family.
-Both the Solution Engine and the hp6xx boards are an example of this.
-
-After you have setup your new arch/sh/boards/ directory, remember that you
-should also add a directory in include/asm-sh for headers localized to this
-board (if there are going to be more than one). In order to interoperate
-seamlessly with the build system, it's best to have this directory the same
-as the arch/sh/boards/ directory name, though if your board is again part of
-a family, the build system has ways of dealing with this (via incdir-y
-overloading), and you can feel free to name the directory after the family
-member itself.
-
-There are a few things that each board is required to have, both in the
-arch/sh/boards and the include/asm-sh/ hierarchy. In order to better
-explain this, we use some examples for adding an imaginary board. For
-setup code, we're required at the very least to provide definitions for
-get_system_type() and platform_setup(). For our imaginary board, this
-might look something like::
-
-    /*
-    * arch/sh/boards/vapor/setup.c - Setup code for imaginary board
-    */
-    #include <linux/init.h>
-
-    const char *get_system_type(void)
-    {
-	    return "FooTech Vaporboard";
-    }
-
-    int __init platform_setup(void)
-    {
-	    /*
-	    * If our hardware actually existed, we would do real
-	    * setup here. Though it's also sane to leave this empty
-	    * if there's no real init work that has to be done for
-	    * this board.
-	    */
-
-	    /* Start-up imaginary PCI ... */
-
-	    /* And whatever else ... */
-
-	    return 0;
-    }
-
-Our new imaginary board will also have to tie into the machvec in order for it
-to be of any use.
-
-machvec functions fall into a number of categories:
-
- - I/O functions to IO memory (inb etc) and PCI/main memory (readb etc).
- - I/O mapping functions (ioport_map, ioport_unmap, etc).
- - a 'heartbeat' function.
- - PCI and IRQ initialization routines.
- - Consistent allocators (for boards that need special allocators,
-   particularly for allocating out of some board-specific SRAM for DMA
-   handles).
-
-There are machvec functions added and removed over time, so always be sure to
-consult include/asm-sh/machvec.h for the current state of the machvec.
-
-The kernel will automatically wrap in generic routines for undefined function
-pointers in the machvec at boot time, as machvec functions are referenced
-unconditionally throughout most of the tree. Some boards have incredibly
-sparse machvecs (such as the dreamcast and sh03), whereas others must define
-virtually everything (rts7751r2d).
-
-Adding a new machine is relatively trivial (using vapor as an example):
-
-If the board-specific definitions are quite minimalistic, as is the case for
-the vast majority of boards, simply having a single board-specific header is
-sufficient.
-
- - add a new file include/asm-sh/vapor.h which contains prototypes for
-   any machine specific IO functions prefixed with the machine name, for
-   example vapor_inb. These will be needed when filling out the machine
-   vector.
-
-   Note that these prototypes are generated automatically by setting
-   __IO_PREFIX to something sensible. A typical example would be::
-
-	#define __IO_PREFIX vapor
-	#include <asm/io_generic.h>
-
-   somewhere in the board-specific header. Any boards being ported that still
-   have a legacy io.h should remove it entirely and switch to the new model.
-
- - Add machine vector definitions to the board's setup.c. At a bare minimum,
-   this must be defined as something like::
-
-	struct sh_machine_vector mv_vapor __initmv = {
-		.mv_name = "vapor",
-	};
-	ALIAS_MV(vapor)
-
- - finally add a file arch/sh/boards/vapor/io.c, which contains definitions of
-   the machine specific io functions (if there are enough to warrant it).
-
-3. Hooking into the Build System
-================================
-
-Now that we have the corresponding directories setup, and all of the
-board-specific code is in place, it's time to look at how to get the
-whole mess to fit into the build system.
-
-Large portions of the build system are now entirely dynamic, and merely
-require the proper entry here and there in order to get things done.
-
-The first thing to do is to add an entry to arch/sh/Kconfig, under the
-"System type" menu::
-
-    config SH_VAPOR
-	    bool "Vapor"
-	    help
-	    select Vapor if configuring for a FooTech Vaporboard.
-
-next, this has to be added into arch/sh/Makefile. All boards require a
-machdir-y entry in order to be built. This entry needs to be the name of
-the board directory as it appears in arch/sh/boards, even if it is in a
-sub-directory (in which case, all parent directories below arch/sh/boards/
-need to be listed). For our new board, this entry can look like::
-
-    machdir-$(CONFIG_SH_VAPOR)	+= vapor
-
-provided that we've placed everything in the arch/sh/boards/vapor/ directory.
-
-Next, the build system assumes that your include/asm-sh directory will also
-be named the same. If this is not the case (as is the case with multiple
-boards belonging to a common family), then the directory name needs to be
-implicitly appended to incdir-y. The existing code manages this for the
-Solution Engine and hp6xx boards, so see these for an example.
-
-Once that is taken care of, it's time to add an entry for the mach type.
-This is done by adding an entry to the end of the arch/sh/tools/mach-types
-list. The method for doing this is self explanatory, and so we won't waste
-space restating it here. After this is done, you will be able to use
-implicit checks for your board if you need this somewhere throughout the
-common code, such as::
-
-	/* Make sure we're on the FooTech Vaporboard */
-	if (!mach_is_vapor())
-		return -ENODEV;
-
-also note that the mach_is_boardname() check will be implicitly forced to
-lowercase, regardless of the fact that the mach-types entries are all
-uppercase. You can read the script if you really care, but it's pretty ugly,
-so you probably don't want to do that.
-
-Now all that's left to do is providing a defconfig for your new board. This
-way, other people who end up with this board can simply use this config
-for reference instead of trying to guess what settings are supposed to be
-used on it.
-
-Also, as soon as you have copied over a sample .config for your new board
-(assume arch/sh/configs/vapor_defconfig), you can also use this directly as a
-build target, and it will be implicitly listed as such in the help text.
-
-Looking at the 'make help' output, you should now see something like:
-
-Architecture specific targets (sh):
-
-  =======================   =============================================
-  zImage                    Compressed kernel image (arch/sh/boot/zImage)
-  adx_defconfig             Build for adx
-  cqreek_defconfig          Build for cqreek
-  dreamcast_defconfig       Build for dreamcast
-  ...
-  vapor_defconfig           Build for vapor
-  =======================   =============================================
-
-which then allows you to do::
-
-    $ make ARCH=sh CROSS_COMPILE=sh4-linux- vapor_defconfig vmlinux
-
-which will in turn copy the defconfig for this board, run it through
-oldconfig (prompting you for any new options since the time of creation),
-and start you on your way to having a functional kernel for your new
-board.
diff --git a/Documentation/sh/register-banks.rst b/Documentation/sh/register-banks.rst
deleted file mode 100644
index 2bef5c8fcbbc06..00000000000000
--- a/Documentation/sh/register-banks.rst
+++ /dev/null
@@ -1,40 +0,0 @@
-.. SPDX-License-Identifier: GPL-2.0
-
-==========================================
-Notes on register bank usage in the kernel
-==========================================
-
-Introduction
-------------
-
-The SH-3 and SH-4 CPU families traditionally include a single partial register
-bank (selected by SR.RB, only r0 ... r7 are banked), whereas other families
-may have more full-featured banking or simply no such capabilities at all.
-
-SR.RB banking
--------------
-
-In the case of this type of banking, banked registers are mapped directly to
-r0 ... r7 if SR.RB is set to the bank we are interested in, otherwise ldc/stc
-can still be used to reference the banked registers (as r0_bank ... r7_bank)
-when in the context of another bank. The developer must keep the SR.RB value
-in mind when writing code that utilizes these banked registers, for obvious
-reasons. Userspace is also not able to poke at the bank1 values, so these can
-be used rather effectively as scratch registers by the kernel.
-
-Presently the kernel uses several of these registers.
-
-	- r0_bank, r1_bank (referenced as k0 and k1, used for scratch
-	  registers when doing exception handling).
-
-	- r2_bank (used to track the EXPEVT/INTEVT code)
-
-		- Used by do_IRQ() and friends for doing irq mapping based off
-		  of the interrupt exception vector jump table offset
-
-	- r6_bank (global interrupt mask)
-
-		- The SR.IMASK interrupt handler makes use of this to set the
-		  interrupt priority level (used by local_irq_enable())
-
-	- r7_bank (current)
diff --git a/MAINTAINERS b/MAINTAINERS
index e278cd5d0de00e..5899ff135e3deb 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -20067,16 +20067,6 @@ S:	Maintained
 F:	Documentation/devicetree/bindings/watchdog/sunplus,sp7021-wdt.yaml
 F:	drivers/watchdog/sunplus_wdt.c
 
-SUPERH
-M:	Yoshinori Sato <ysato@users.sourceforge.jp>
-M:	Rich Felker <dalias@libc.org>
-L:	linux-sh@vger.kernel.org
-S:	Maintained
-Q:	http://patchwork.kernel.org/project/linux-sh/list/
-F:	Documentation/sh/
-F:	arch/sh/
-F:	drivers/sh/
-
 SUSPEND TO RAM
 M:	"Rafael J. Wysocki" <rafael@kernel.org>
 M:	Len Brown <len.brown@intel.com>
diff --git a/arch/sh/Kbuild b/arch/sh/Kbuild
deleted file mode 100644
index be171880977e5d..00000000000000
--- a/arch/sh/Kbuild
+++ /dev/null
@@ -1,7 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-only
-obj-y				+= kernel/ mm/ boards/
-obj-$(CONFIG_SH_FPU_EMU)	+= math-emu/
-obj-$(CONFIG_USE_BUILTIN_DTB)	+= boot/dts/
-
-# for cleaning
-subdir- += boot
diff --git a/arch/sh/Kconfig b/arch/sh/Kconfig
deleted file mode 100644
index 0665ac0add0b49..00000000000000
--- a/arch/sh/Kconfig
+++ /dev/null
@@ -1,793 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-config SUPERH
-	def_bool y
-	select ARCH_32BIT_OFF_T
-	select ARCH_ENABLE_MEMORY_HOTPLUG if SPARSEMEM && MMU
-	select ARCH_ENABLE_MEMORY_HOTREMOVE if SPARSEMEM && MMU
-	select ARCH_HAVE_CUSTOM_GPIO_H
-	select ARCH_HAVE_NMI_SAFE_CMPXCHG if (GUSA_RB || CPU_SH4A)
-	select ARCH_HAS_BINFMT_FLAT if !MMU
-	select ARCH_HAS_CURRENT_STACK_POINTER
-	select ARCH_HAS_GIGANTIC_PAGE
-	select ARCH_HAS_GCOV_PROFILE_ALL
-	select ARCH_HAS_PTE_SPECIAL
-	select ARCH_HAS_TICK_BROADCAST if GENERIC_CLOCKEVENTS_BROADCAST
-	select ARCH_HIBERNATION_POSSIBLE if MMU
-	select ARCH_MIGHT_HAVE_PC_PARPORT
-	select ARCH_WANT_IPC_PARSE_VERSION
-	select CPU_NO_EFFICIENT_FFS
-	select DMA_DECLARE_COHERENT
-	select GENERIC_ATOMIC64
-	select GENERIC_CMOS_UPDATE if SH_SH03 || SH_DREAMCAST
-	select GENERIC_IDLE_POLL_SETUP
-	select GENERIC_IRQ_SHOW
-	select GENERIC_PCI_IOMAP if PCI
-	select GENERIC_SCHED_CLOCK
-	select GENERIC_SMP_IDLE_THREAD
-	select GUP_GET_PXX_LOW_HIGH if X2TLB
-	select HAVE_ARCH_AUDITSYSCALL
-	select HAVE_ARCH_KGDB
-	select HAVE_ARCH_SECCOMP_FILTER
-	select HAVE_ARCH_TRACEHOOK
-	select HAVE_DEBUG_BUGVERBOSE
-	select HAVE_DEBUG_KMEMLEAK
-	select HAVE_DYNAMIC_FTRACE
-	select HAVE_FAST_GUP if MMU
-	select HAVE_FUNCTION_GRAPH_TRACER
-	select HAVE_FUNCTION_TRACER
-	select HAVE_FTRACE_MCOUNT_RECORD
-	select HAVE_HW_BREAKPOINT
-	select HAVE_IOREMAP_PROT if MMU && !X2TLB
-	select HAVE_KERNEL_BZIP2
-	select HAVE_KERNEL_GZIP
-	select HAVE_KERNEL_LZMA
-	select HAVE_KERNEL_LZO
-	select HAVE_KERNEL_XZ
-	select HAVE_KPROBES
-	select HAVE_KRETPROBES
-	select HAVE_MIXED_BREAKPOINTS_REGS
-	select HAVE_MOD_ARCH_SPECIFIC if DWARF_UNWINDER
-	select HAVE_NMI
-	select HAVE_PATA_PLATFORM
-	select HAVE_PERF_EVENTS
-	select HAVE_REGS_AND_STACK_ACCESS_API
-	select HAVE_UID16
-	select HAVE_SOFTIRQ_ON_OWN_STACK if IRQSTACKS
-	select HAVE_STACKPROTECTOR
-	select HAVE_SYSCALL_TRACEPOINTS
-	select IRQ_FORCED_THREADING
-	select MODULES_USE_ELF_RELA
-	select NEED_SG_DMA_LENGTH
-	select NO_DMA if !MMU && !DMA_COHERENT
-	select NO_GENERIC_PCI_IOPORT_MAP if PCI
-	select OLD_SIGACTION
-	select OLD_SIGSUSPEND
-	select PCI_DOMAINS if PCI
-	select PERF_EVENTS
-	select PERF_USE_VMALLOC
-	select RTC_LIB
-	select SPARSE_IRQ
-	select TRACE_IRQFLAGS_SUPPORT
-	help
-	  The SuperH is a RISC processor targeted for use in embedded systems
-	  and consumer electronics; it was also used in the Sega Dreamcast
-	  gaming console.  The SuperH port has a home page at
-	  <http://www.linux-sh.org/>.
-
-config GENERIC_BUG
-	def_bool y
-	depends on BUG
-
-config GENERIC_HWEIGHT
-	def_bool y
-
-config GENERIC_CALIBRATE_DELAY
-	bool
-
-config GENERIC_LOCKBREAK
-	def_bool y
-	depends on SMP && PREEMPTION
-
-config ARCH_SUSPEND_POSSIBLE
-	def_bool n
-
-config ARCH_HIBERNATION_POSSIBLE
-	def_bool n
-
-config SYS_SUPPORTS_APM_EMULATION
-	bool
-	select ARCH_SUSPEND_POSSIBLE
-
-config SYS_SUPPORTS_SMP
-	bool
-
-config SYS_SUPPORTS_NUMA
-	bool
-
-config STACKTRACE_SUPPORT
-	def_bool y
-
-config LOCKDEP_SUPPORT
-	def_bool y
-
-config ARCH_HAS_ILOG2_U32
-	def_bool n
-
-config ARCH_HAS_ILOG2_U64
-	def_bool n
-
-config NO_IOPORT_MAP
-	def_bool !PCI
-	depends on !SH_SH4202_MICRODEV && !SH_SHMIN && !SH_HP6XX && \
-		   !SH_SOLUTION_ENGINE
-
-config IO_TRAPPED
-	bool
-
-config SWAP_IO_SPACE
-	bool
-
-config DMA_COHERENT
-	bool
-
-config DMA_NONCOHERENT
-	def_bool !NO_DMA && !DMA_COHERENT
-	select ARCH_HAS_DMA_PREP_COHERENT
-	select ARCH_HAS_SYNC_DMA_FOR_DEVICE
-	select DMA_DIRECT_REMAP
-
-config PGTABLE_LEVELS
-	default 3 if X2TLB
-	default 2
-
-menu "System type"
-
-#
-# Processor families
-#
-config CPU_SH2
-	bool
-	select SH_INTC
-
-config CPU_SH2A
-	bool
-	select CPU_SH2
-	select UNCACHED_MAPPING
-
-config CPU_J2
-	bool
-	select CPU_SH2
-	select OF
-	select OF_EARLY_FLATTREE
-
-config CPU_SH3
-	bool
-	select CPU_HAS_INTEVT
-	select CPU_HAS_SR_RB
-	select SH_INTC
-	select SYS_SUPPORTS_SH_TMU
-
-config CPU_SH4
-	bool
-	select ARCH_SUPPORTS_HUGETLBFS if MMU
-	select CPU_HAS_INTEVT
-	select CPU_HAS_SR_RB
-	select CPU_HAS_FPU if !CPU_SH4AL_DSP
-	select SH_INTC
-	select SYS_SUPPORTS_SH_TMU
-
-config CPU_SH4A
-	bool
-	select CPU_SH4
-
-config CPU_SH4AL_DSP
-	bool
-	select CPU_SH4A
-	select CPU_HAS_DSP
-
-config CPU_SHX2
-	bool
-
-config CPU_SHX3
-	bool
-	select DMA_COHERENT
-	select SYS_SUPPORTS_SMP
-	select SYS_SUPPORTS_NUMA
-
-config ARCH_SHMOBILE
-	bool
-	select ARCH_SUSPEND_POSSIBLE
-	select PM
-
-config CPU_HAS_PMU
-       depends on CPU_SH4 || CPU_SH4A
-       default y
-       bool
-
-choice
-	prompt "Processor sub-type selection"
-
-#
-# Processor subtypes
-#
-
-# SH-2 Processor Support
-
-config CPU_SUBTYPE_SH7619
-	bool "Support SH7619 processor"
-	select CPU_SH2
-	select SYS_SUPPORTS_SH_CMT
-
-config CPU_SUBTYPE_J2
-	bool "Support J2 processor"
-	select CPU_J2
-	select SYS_SUPPORTS_SMP
-	select GENERIC_CLOCKEVENTS_BROADCAST if SMP
-
-# SH-2A Processor Support
-
-config CPU_SUBTYPE_SH7201
-	bool "Support SH7201 processor"
-	select CPU_SH2A
-	select CPU_HAS_FPU
-	select SYS_SUPPORTS_SH_MTU2
- 
-config CPU_SUBTYPE_SH7203
-	bool "Support SH7203 processor"
-	select CPU_SH2A
-	select CPU_HAS_FPU
-	select SYS_SUPPORTS_SH_CMT
-	select SYS_SUPPORTS_SH_MTU2
-	select PINCTRL
-
-config CPU_SUBTYPE_SH7206
-	bool "Support SH7206 processor"
-	select CPU_SH2A
-	select SYS_SUPPORTS_SH_CMT
-	select SYS_SUPPORTS_SH_MTU2
-
-config CPU_SUBTYPE_SH7263
-	bool "Support SH7263 processor"
-	select CPU_SH2A
-	select CPU_HAS_FPU
-	select SYS_SUPPORTS_SH_CMT
-	select SYS_SUPPORTS_SH_MTU2
-
-config CPU_SUBTYPE_SH7264
-	bool "Support SH7264 processor"
-	select CPU_SH2A
-	select CPU_HAS_FPU
-	select SYS_SUPPORTS_SH_CMT
-	select SYS_SUPPORTS_SH_MTU2
-	select PINCTRL
-
-config CPU_SUBTYPE_SH7269
-	bool "Support SH7269 processor"
-	select CPU_SH2A
-	select CPU_HAS_FPU
-	select SYS_SUPPORTS_SH_CMT
-	select SYS_SUPPORTS_SH_MTU2
-	select PINCTRL
-
-config CPU_SUBTYPE_MXG
-	bool "Support MX-G processor"
-	select CPU_SH2A
-	select SYS_SUPPORTS_SH_MTU2
-	help
-	  Select MX-G if running on an R8A03022BG part.
-
-# SH-3 Processor Support
-
-config CPU_SUBTYPE_SH7705
-	bool "Support SH7705 processor"
-	select CPU_SH3
-
-config CPU_SUBTYPE_SH7706
-	bool "Support SH7706 processor"
-	select CPU_SH3
-	help
-	  Select SH7706 if you have a 133 Mhz SH-3 HD6417706 CPU.
-
-config CPU_SUBTYPE_SH7707
-	bool "Support SH7707 processor"
-	select CPU_SH3
-	help
-	  Select SH7707 if you have a  60 Mhz SH-3 HD6417707 CPU.
-
-config CPU_SUBTYPE_SH7708
-	bool "Support SH7708 processor"
-	select CPU_SH3
-	help
-	  Select SH7708 if you have a  60 Mhz SH-3 HD6417708S or
-	  if you have a 100 Mhz SH-3 HD6417708R CPU.
-
-config CPU_SUBTYPE_SH7709
-	bool "Support SH7709 processor"
-	select CPU_SH3
-	help
-	  Select SH7709 if you have a  80 Mhz SH-3 HD6417709 CPU.
-
-config CPU_SUBTYPE_SH7710
-	bool "Support SH7710 processor"
-	select CPU_SH3
-	select CPU_HAS_DSP
-	help
-	  Select SH7710 if you have a SH3-DSP SH7710 CPU.
-
-config CPU_SUBTYPE_SH7712
-	bool "Support SH7712 processor"
-	select CPU_SH3
-	select CPU_HAS_DSP
-	help
-	  Select SH7712 if you have a SH3-DSP SH7712 CPU.
-
-config CPU_SUBTYPE_SH7720
-	bool "Support SH7720 processor"
-	select CPU_SH3
-	select CPU_HAS_DSP
-	select SYS_SUPPORTS_SH_CMT
-	select USB_OHCI_SH if USB_OHCI_HCD
-	select PINCTRL
-	help
-	  Select SH7720 if you have a SH3-DSP SH7720 CPU.
-
-config CPU_SUBTYPE_SH7721
-	bool "Support SH7721 processor"
-	select CPU_SH3
-	select CPU_HAS_DSP
-	select SYS_SUPPORTS_SH_CMT
-	select USB_OHCI_SH if USB_OHCI_HCD
-	help
-	  Select SH7721 if you have a SH3-DSP SH7721 CPU.
-
-# SH-4 Processor Support
-
-config CPU_SUBTYPE_SH7750
-	bool "Support SH7750 processor"
-	select CPU_SH4
-	help
-	  Select SH7750 if you have a 200 Mhz SH-4 HD6417750 CPU.
-
-config CPU_SUBTYPE_SH7091
-	bool "Support SH7091 processor"
-	select CPU_SH4
-	help
-	  Select SH7091 if you have an SH-4 based Sega device (such as
-	  the Dreamcast, Naomi, and Naomi 2).
-
-config CPU_SUBTYPE_SH7750R
-	bool "Support SH7750R processor"
-	select CPU_SH4
-
-config CPU_SUBTYPE_SH7750S
-	bool "Support SH7750S processor"
-	select CPU_SH4
-
-config CPU_SUBTYPE_SH7751
-	bool "Support SH7751 processor"
-	select CPU_SH4
-	help
-	  Select SH7751 if you have a 166 Mhz SH-4 HD6417751 CPU,
-	  or if you have a HD6417751R CPU.
-
-config CPU_SUBTYPE_SH7751R
-	bool "Support SH7751R processor"
-	select CPU_SH4
-
-config CPU_SUBTYPE_SH7760
-	bool "Support SH7760 processor"
-	select CPU_SH4
-
-config CPU_SUBTYPE_SH4_202
-	bool "Support SH4-202 processor"
-	select CPU_SH4
-
-# SH-4A Processor Support
-
-config CPU_SUBTYPE_SH7723
-	bool "Support SH7723 processor"
-	select CPU_SH4A
-	select CPU_SHX2
-	select ARCH_SHMOBILE
-	select ARCH_SPARSEMEM_ENABLE
-	select SYS_SUPPORTS_SH_CMT
-	select PINCTRL
-	help
-	  Select SH7723 if you have an SH-MobileR2 CPU.
-
-config CPU_SUBTYPE_SH7724
-	bool "Support SH7724 processor"
-	select CPU_SH4A
-	select CPU_SHX2
-	select ARCH_SHMOBILE
-	select ARCH_SPARSEMEM_ENABLE
-	select SYS_SUPPORTS_SH_CMT
-	select PINCTRL
-	help
-	  Select SH7724 if you have an SH-MobileR2R CPU.
-
-config CPU_SUBTYPE_SH7734
-	bool "Support SH7734 processor"
-	select CPU_SH4A
-	select CPU_SHX2
-	select PINCTRL
-	help
-	  Select SH7734 if you have a SH4A SH7734 CPU.
-
-config CPU_SUBTYPE_SH7757
-	bool "Support SH7757 processor"
-	select CPU_SH4A
-	select CPU_SHX2
-	select PINCTRL
-	help
-	  Select SH7757 if you have a SH4A SH7757 CPU.
-
-config CPU_SUBTYPE_SH7763
-	bool "Support SH7763 processor"
-	select CPU_SH4A
-	select USB_OHCI_SH if USB_OHCI_HCD
-	help
-	  Select SH7763 if you have a SH4A SH7763(R5S77631) CPU.
-
-config CPU_SUBTYPE_SH7770
-	bool "Support SH7770 processor"
-	select CPU_SH4A
-
-config CPU_SUBTYPE_SH7780
-	bool "Support SH7780 processor"
-	select CPU_SH4A
-
-config CPU_SUBTYPE_SH7785
-	bool "Support SH7785 processor"
-	select CPU_SH4A
-	select CPU_SHX2
-	select ARCH_SPARSEMEM_ENABLE
-	select SYS_SUPPORTS_NUMA
-	select PINCTRL
-
-config CPU_SUBTYPE_SH7786
-	bool "Support SH7786 processor"
-	select CPU_SH4A
-	select CPU_SHX3
-	select CPU_HAS_PTEAEX
-	select GENERIC_CLOCKEVENTS_BROADCAST if SMP
-	select USB_OHCI_SH if USB_OHCI_HCD
-	select USB_EHCI_SH if USB_EHCI_HCD
-	select PINCTRL
-
-config CPU_SUBTYPE_SHX3
-	bool "Support SH-X3 processor"
-	select CPU_SH4A
-	select CPU_SHX3
-	select GENERIC_CLOCKEVENTS_BROADCAST if SMP
-	select GPIOLIB
-	select PINCTRL
-
-# SH4AL-DSP Processor Support
-
-config CPU_SUBTYPE_SH7343
-	bool "Support SH7343 processor"
-	select CPU_SH4AL_DSP
-	select ARCH_SHMOBILE
-	select SYS_SUPPORTS_SH_CMT
-
-config CPU_SUBTYPE_SH7722
-	bool "Support SH7722 processor"
-	select CPU_SH4AL_DSP
-	select CPU_SHX2
-	select ARCH_SHMOBILE
-	select ARCH_SPARSEMEM_ENABLE
-	select SYS_SUPPORTS_NUMA
-	select SYS_SUPPORTS_SH_CMT
-	select PINCTRL
-
-config CPU_SUBTYPE_SH7366
-	bool "Support SH7366 processor"
-	select CPU_SH4AL_DSP
-	select CPU_SHX2
-	select ARCH_SHMOBILE
-	select ARCH_SPARSEMEM_ENABLE
-	select SYS_SUPPORTS_NUMA
-	select SYS_SUPPORTS_SH_CMT
-
-endchoice
-
-source "arch/sh/mm/Kconfig"
- 
-source "arch/sh/Kconfig.cpu"
-
-source "arch/sh/boards/Kconfig"
-
-menu "Timer and clock configuration"
-
-config SH_PCLK_FREQ
-	int "Peripheral clock frequency (in Hz)"
-	depends on SH_CLK_CPG_LEGACY
-	default "31250000" if CPU_SUBTYPE_SH7619
-	default "33333333" if CPU_SUBTYPE_SH7770 || \
-			      CPU_SUBTYPE_SH7760 || \
-			      CPU_SUBTYPE_SH7705 || \
-			      CPU_SUBTYPE_SH7203 || \
-			      CPU_SUBTYPE_SH7206 || \
-			      CPU_SUBTYPE_SH7263 || \
-			      CPU_SUBTYPE_MXG
-	default "60000000" if CPU_SUBTYPE_SH7751 || CPU_SUBTYPE_SH7751R
-	default "66000000" if CPU_SUBTYPE_SH4_202
-	default "50000000"
-	help
-	  This option is used to specify the peripheral clock frequency.
-	  This is necessary for determining the reference clock value on
-	  platforms lacking an RTC.
-
-config SH_CLK_CPG
-	def_bool y
-
-config SH_CLK_CPG_LEGACY
-	depends on SH_CLK_CPG
-	def_bool y if !CPU_SUBTYPE_SH7785 && !ARCH_SHMOBILE && \
-		      !CPU_SHX3 && !CPU_SUBTYPE_SH7757 && \
-		      !CPU_SUBTYPE_SH7734 && !CPU_SUBTYPE_SH7264 && \
-		      !CPU_SUBTYPE_SH7269
-
-endmenu
-
-menu "CPU Frequency scaling"
-source "drivers/cpufreq/Kconfig"
-endmenu
-
-source "arch/sh/drivers/Kconfig"
-
-endmenu
-
-menu "Kernel features"
-
-source "kernel/Kconfig.hz"
-
-config KEXEC
-	bool "kexec system call (EXPERIMENTAL)"
-	depends on MMU
-	select KEXEC_CORE
-	help
-	  kexec is a system call that implements the ability to shutdown your
-	  current kernel, and to start another kernel.  It is like a reboot
-	  but it is independent of the system firmware.  And like a reboot
-	  you can start any kernel with it, not just Linux.
-
-	  The name comes from the similarity to the exec system call.
-
-	  It is an ongoing process to be certain the hardware in a machine
-	  is properly shutdown, so do not be surprised if this code does not
-	  initially work for you.  As of this writing the exact hardware
-	  interface is strongly in flux, so no good recommendation can be
-	  made.
-
-config CRASH_DUMP
-	bool "kernel crash dumps (EXPERIMENTAL)"
-	depends on BROKEN_ON_SMP
-	help
-	  Generate crash dump after being started by kexec.
-	  This should be normally only set in special crash dump kernels
-	  which are loaded in the main kernel with kexec-tools into
-	  a specially reserved region and then later executed after
-	  a crash by kdump/kexec. The crash dump kernel must be compiled
-	  to a memory address not used by the main kernel using
-	  PHYSICAL_START.
-
-	  For more details see Documentation/admin-guide/kdump/kdump.rst
-
-config KEXEC_JUMP
-	bool "kexec jump (EXPERIMENTAL)"
-	depends on KEXEC && HIBERNATION
-	help
-	  Jump between original kernel and kexeced kernel and invoke
-	  code via KEXEC
-
-config PHYSICAL_START
-	hex "Physical address where the kernel is loaded" if (EXPERT || CRASH_DUMP)
-	default MEMORY_START
-	help
-	  This gives the physical address where the kernel is loaded
-	  and is ordinarily the same as MEMORY_START.
-
-	  Different values are primarily used in the case of kexec on panic
-	  where the fail safe kernel needs to run at a different address
-	  than the panic-ed kernel.
-
-config SMP
-	bool "Symmetric multi-processing support"
-	depends on SYS_SUPPORTS_SMP
-	help
-	  This enables support for systems with more than one CPU. If you have
-	  a system with only one CPU, say N. If you have a system with more
-	  than one CPU, say Y.
-
-	  If you say N here, the kernel will run on uni- and multiprocessor
-	  machines, but will use only one CPU of a multiprocessor machine. If
-	  you say Y here, the kernel will run on many, but not all,
-	  uniprocessor machines. On a uniprocessor machine, the kernel
-	  will run faster if you say N here.
-
-	  People using multiprocessor machines who say Y here should also say
-	  Y to "Enhanced Real Time Clock Support", below.
-
-	  See also <file:Documentation/admin-guide/lockup-watchdogs.rst> and the SMP-HOWTO
-	  available at <https://www.tldp.org/docs.html#howto>.
-
-	  If you don't know what to do here, say N.
-
-config NR_CPUS
-	int "Maximum number of CPUs (2-32)"
-	range 2 32
-	depends on SMP
-	default "4" if CPU_SUBTYPE_SHX3
-	default "2"
-	help
-	  This allows you to specify the maximum number of CPUs which this
-	  kernel will support.  The maximum supported value is 32 and the
-	  minimum value which makes sense is 2.
-
-	  This is purely to save memory - each supported CPU adds
-	  approximately eight kilobytes to the kernel image.
-
-config HOTPLUG_CPU
-	bool "Support for hot-pluggable CPUs (EXPERIMENTAL)"
-	depends on SMP
-	help
-	  Say Y here to experiment with turning CPUs off and on.  CPUs
-	  can be controlled through /sys/devices/system/cpu.
-
-config GUSA
-	def_bool y
-	depends on !SMP
-	help
-	  This enables support for gUSA (general UserSpace Atomicity).
-	  This is the default implementation for both UP and non-ll/sc
-	  CPUs, and is used by the libc, amongst others.
-
-	  For additional information, design information can be found 
-	  in <http://lc.linux.or.jp/lc2002/papers/niibe0919p.pdf>.
-
-	  This should only be disabled for special cases where alternate
-	  atomicity implementations exist.
-
-config GUSA_RB
-	bool "Implement atomic operations by roll-back (gRB) (EXPERIMENTAL)"
-	depends on GUSA && CPU_SH3 || (CPU_SH4 && !CPU_SH4A)
-	help
-	  Enabling this option will allow the kernel to implement some
-	  atomic operations using a software implementation of load-locked/
-	  store-conditional (LLSC). On machines which do not have hardware
-	  LLSC, this should be more efficient than the other alternative of
-	  disabling interrupts around the atomic sequence.
-
-config HW_PERF_EVENTS
-	bool "Enable hardware performance counter support for perf events"
-	depends on PERF_EVENTS && CPU_HAS_PMU
-	default y
-	help
-	  Enable hardware performance counter support for perf events. If
-	  disabled, perf events will use software events only.
-
-source "drivers/sh/Kconfig"
-
-endmenu
-
-menu "Boot options"
-
-config USE_BUILTIN_DTB
-	bool "Use builtin DTB"
-	default n
-	depends on SH_DEVICE_TREE
-	help
-	  Link a device tree blob for particular hardware into the kernel,
-	  suppressing use of the DTB pointer provided by the bootloader.
-	  This option should only be used with legacy bootloaders that are
-	  not capable of providing a DTB to the kernel, or for experimental
-	  hardware without stable device tree bindings.
-
-config BUILTIN_DTB_SOURCE
-	string "Source file for builtin DTB"
-	default ""
-	depends on USE_BUILTIN_DTB
-	help
-	  Base name (without suffix, relative to arch/sh/boot/dts) for the
-	  a DTS file that will be used to produce the DTB linked into the
-	  kernel.
-
-config ZERO_PAGE_OFFSET
-	hex
-	default "0x00010000" if PAGE_SIZE_64KB || SH_RTS7751R2D || \
-				SH_7751_SOLUTION_ENGINE
-	default "0x00004000" if PAGE_SIZE_16KB || SH_SH03
-	default "0x00002000" if PAGE_SIZE_8KB
-	default "0x00001000"
-	help
-	  This sets the default offset of zero page.
-
-config BOOT_LINK_OFFSET
-	hex
-	default "0x00210000" if SH_SHMIN
-	default "0x00810000" if SH_7780_SOLUTION_ENGINE
-	default "0x009e0000" if SH_TITAN
-	default "0x01800000" if SH_SDK7780
-	default "0x02000000" if SH_EDOSK7760
-	default "0x00800000"
-	help
-	  This option allows you to set the link address offset of the zImage.
-	  This can be useful if you are on a board which has a small amount of
-	  memory.
-
-config ENTRY_OFFSET
-	hex
-	default "0x00001000" if PAGE_SIZE_4KB
-	default "0x00002000" if PAGE_SIZE_8KB
-	default "0x00004000" if PAGE_SIZE_16KB
-	default "0x00010000" if PAGE_SIZE_64KB
-	default "0x00000000"
-
-config ROMIMAGE_MMCIF
-	bool "Include MMCIF loader in romImage (EXPERIMENTAL)"
-	depends on CPU_SUBTYPE_SH7724
-	help
-	  Say Y here to include experimental MMCIF loading code in
-	  romImage. With this enabled it is possible to write the romImage
-	  kernel image to an MMC card and boot the kernel straight from
-	  the reset vector. At reset the processor Mask ROM will load the
-	  first part of the romImage which in turn loads the rest the kernel
-	  image to RAM using the MMCIF hardware block.
-
-choice
-	prompt "Kernel command line"
-	optional
-	default CMDLINE_OVERWRITE
-	help
-	  Setting this option allows the kernel command line arguments
-	  to be set.
-
-config CMDLINE_OVERWRITE
-	bool "Overwrite bootloader kernel arguments"
-	help
-	  Given string will overwrite any arguments passed in by
-	  a bootloader.
-
-config CMDLINE_EXTEND
-	bool "Extend bootloader kernel arguments"
-	help
-	  Given string will be concatenated with arguments passed in
-	  by a bootloader.
-
-endchoice
-
-config CMDLINE
-	string "Kernel command line arguments string"
-	depends on CMDLINE_OVERWRITE || CMDLINE_EXTEND
-	default "console=ttySC1,115200"
-
-endmenu
-
-menu "Bus options"
-
-config SUPERHYWAY
-	tristate "SuperHyway Bus support"
-	depends on CPU_SUBTYPE_SH4_202
-
-config MAPLE
-	bool "Maple Bus support"
-	depends on SH_DREAMCAST
-	help
-	 The Maple Bus is SEGA's serial communication bus for peripherals
-	 on the Dreamcast. Without this bus support you won't be able to
-	 get your Dreamcast keyboard etc to work, so most users
-	 probably want to say 'Y' here, unless you are only using the
-	 Dreamcast with a serial line terminal or a remote network
-	 connection.
-
-endmenu
-
-menu "Power management options (EXPERIMENTAL)"
-
-source "kernel/power/Kconfig"
-
-source "drivers/cpuidle/Kconfig"
-
-endmenu
diff --git a/arch/sh/Kconfig.cpu b/arch/sh/Kconfig.cpu
deleted file mode 100644
index fff419f3d7574c..00000000000000
--- a/arch/sh/Kconfig.cpu
+++ /dev/null
@@ -1,100 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-menu "Processor features"
-
-choice
-	prompt "Endianness selection" 
-	default CPU_LITTLE_ENDIAN
-	help
-	  Some SuperH machines can be configured for either little or big
-	  endian byte order. These modes require different kernels.
-
-config CPU_LITTLE_ENDIAN
-	bool "Little Endian"
-
-config CPU_BIG_ENDIAN
-	bool "Big Endian"
-
-endchoice
-
-config SH_FPU
-	def_bool y
-	prompt "FPU support"
-	depends on CPU_HAS_FPU
-	help
-	  Selecting this option will enable support for SH processors that
-	  have FPU units (ie, SH77xx).
-
-	  This option must be set in order to enable the FPU.
-
-config SH_FPU_EMU
-	def_bool n
-	prompt "FPU emulation support"
-	depends on !SH_FPU
-	help
-	  Selecting this option will enable support for software FPU emulation.
-	  Most SH-3 users will want to say Y here, whereas most SH-4 users will
-	  want to say N.
-
-config SH_DSP
-	def_bool y
-	prompt "DSP support"
-	depends on CPU_HAS_DSP
-	help
-	  Selecting this option will enable support for SH processors that
-	  have DSP units (ie, SH2-DSP, SH3-DSP, and SH4AL-DSP).
-
-	  This option must be set in order to enable the DSP.
-
-config SH_ADC
-	def_bool y
-	prompt "ADC support"
-	depends on CPU_SH3
-	help
-	  Selecting this option will allow the Linux kernel to use SH3 on-chip
-	  ADC module.
-
-	  If unsure, say N.
-
-config SH_STORE_QUEUES
-	bool "Support for Store Queues"
-	depends on CPU_SH4
-	help
-	  Selecting this option will enable an in-kernel API for manipulating
-	  the store queues integrated in the SH-4 processors.
-
-config SPECULATIVE_EXECUTION
-	bool "Speculative subroutine return"
-	depends on CPU_SUBTYPE_SH7780 || CPU_SUBTYPE_SH7785 || CPU_SUBTYPE_SH7786
-	help
-	  This enables support for a speculative instruction fetch for
-	  subroutine return. There are various pitfalls associated with
-	  this, as outlined in the SH7780 hardware manual.
-
-	  If unsure, say N.
-
-config CPU_HAS_INTEVT
-	bool
-
-config CPU_HAS_IPR_IRQ
-	bool
-
-config CPU_HAS_SR_RB
-	bool
-	help
-	  This will enable the use of SR.RB register bank usage. Processors
-	  that are lacking this bit must have another method in place for
-	  accomplishing what is taken care of by the banked registers.
-
-	  See <file:Documentation/sh/register-banks.rst> for further
-	  information on SR.RB and register banking in the kernel in general.
-
-config CPU_HAS_PTEAEX
-	bool
-
-config CPU_HAS_DSP
-	bool
-
-config CPU_HAS_FPU
-	bool
-
-endmenu
diff --git a/arch/sh/Kconfig.debug b/arch/sh/Kconfig.debug
deleted file mode 100644
index 10290e5c1f4387..00000000000000
--- a/arch/sh/Kconfig.debug
+++ /dev/null
@@ -1,78 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-
-config SH_STANDARD_BIOS
-	bool "Use LinuxSH standard BIOS"
-	help
-	  Say Y here if your target has the gdb-sh-stub
-	  package from www.m17n.org (or any conforming standard LinuxSH BIOS)
-	  in FLASH or EPROM.  The kernel will use standard BIOS calls during
-	  boot for various housekeeping tasks (including calls to read and
-	  write characters to a system console, get a MAC address from an
-	  on-board Ethernet interface, and shut down the hardware).  Note this
-	  does not work with machines with an existing operating system in
-	  mask ROM and no flash (WindowsCE machines fall in this category).
-	  If unsure, say N.
-
-config STACK_DEBUG
-	bool "Check for stack overflows"
-	depends on DEBUG_KERNEL
-	help
-	  This option will cause messages to be printed if free stack space
-	  drops below a certain limit. Saying Y here will add overhead to
-	  every function call and will therefore incur a major
-	  performance hit. Most users should say N.
-
-config 4KSTACKS
-	bool "Use 4Kb for kernel stacks instead of 8Kb"
-	depends on DEBUG_KERNEL && (MMU || BROKEN) && !PAGE_SIZE_64KB
-	help
-	  If you say Y here the kernel will use a 4Kb stacksize for the
-	  kernel stack attached to each process/thread. This facilitates
-	  running more threads on a system and also reduces the pressure
-	  on the VM subsystem for higher order allocations. This option
-	  will also use IRQ stacks to compensate for the reduced stackspace.
-
-config IRQSTACKS
-	bool "Use separate kernel stacks when processing interrupts"
-	depends on DEBUG_KERNEL && BROKEN
-	help
-	  If you say Y here the kernel will use separate kernel stacks
-	  for handling hard and soft interrupts.  This can help avoid
-	  overflowing the process kernel stacks.
-
-config DUMP_CODE
-	bool "Show disassembly of nearby code in register dumps"
-	depends on DEBUG_KERNEL
-	default y if DEBUG_BUGVERBOSE
-	default n
-	help
-	  This prints out a code trace of the instructions leading up to
-	  the faulting instruction as a debugging aid. As this does grow
-	  the kernel in size a bit, most users will want to say N here.
-
-	  Those looking for more verbose debugging output should say Y.
-
-config DWARF_UNWINDER
-	bool "Enable the DWARF unwinder for stacktraces"
-	depends on DEBUG_KERNEL
-	select FRAME_POINTER
-	default n
-	help
-	  Enabling this option will make stacktraces more accurate, at
-	  the cost of an increase in overall kernel size.
-
-config SH_NO_BSS_INIT
-	bool "Avoid zeroing BSS (to speed-up startup on suitable platforms)"
-	depends on DEBUG_KERNEL
-	default n
-	help
-	  If running in painfully slow environments, such as an RTL
-	  simulation or from remote memory via SHdebug, where the memory
-	  can already be guaranteed to ber zeroed on boot, say Y.
-
-	  For all other cases, say N. If this option seems perplexing, or
-	  you aren't sure, say N.
-
-config MCOUNT
-	def_bool y
-	depends on STACK_DEBUG || FUNCTION_TRACER
diff --git a/arch/sh/Makefile b/arch/sh/Makefile
deleted file mode 100644
index 5c8776482530c3..00000000000000
--- a/arch/sh/Makefile
+++ /dev/null
@@ -1,215 +0,0 @@
-#
-# arch/sh/Makefile
-#
-# Copyright (C) 1999  Kaz Kojima
-# Copyright (C) 2002 - 2008  Paul Mundt
-# Copyright (C) 2002  M. R. Brown
-#
-# This file is subject to the terms and conditions of the GNU General Public
-# License.  See the file "COPYING" in the main directory of this archive
-# for more details.
-#
-ifdef cross_compiling
-  ifeq ($(CROSS_COMPILE),)
-    CROSS_COMPILE := $(call cc-cross-prefix, sh-linux- sh-linux-gnu- sh-unknown-linux-gnu-)
-  endif
-endif
-
-KBUILD_DEFCONFIG	:= shx3_defconfig
-
-isa-y					:= any
-isa-$(CONFIG_SH_DSP)			:= sh
-isa-$(CONFIG_CPU_SH2)			:= sh2
-isa-$(CONFIG_CPU_SH2A)			:= sh2a
-isa-$(CONFIG_CPU_SH3)			:= sh3
-isa-$(CONFIG_CPU_SH4)			:= sh4
-isa-$(CONFIG_CPU_SH4A)			:= sh4a
-isa-$(CONFIG_CPU_SH4AL_DSP)		:= sh4al
-
-isa-$(CONFIG_SH_DSP)			:= $(isa-y)-dsp
-isa-y					:= $(isa-y)-up
-
-cflags-$(CONFIG_CPU_SH2)		:= $(call cc-option,-m2,)
-cflags-$(CONFIG_CPU_J2)			+= $(call cc-option,-mj2,)
-cflags-$(CONFIG_CPU_SH2A)		+= $(call cc-option,-m2a,) \
-					   $(call cc-option,-m2a-nofpu,) \
-					   $(call cc-option,-m4-nofpu,)
-cflags-$(CONFIG_CPU_SH3)		:= $(call cc-option,-m3,)
-cflags-$(CONFIG_CPU_SH4)		:= $(call cc-option,-m4,) \
-	$(call cc-option,-mno-implicit-fp,-m4-nofpu)
-cflags-$(CONFIG_CPU_SH4A)		+= $(call cc-option,-m4a,) \
-					   $(call cc-option,-m4a-nofpu,)
-cflags-$(CONFIG_CPU_SH4AL_DSP)		+= $(call cc-option,-m4al,)
-
-ifeq ($(cflags-y),)
-#
-# In the case where we are stuck with a compiler that has been uselessly
-# restricted to a particular ISA, a favourite default of newer GCCs when
-# extensive multilib targets are not provided, ensure we get the best fit
-# regarding FP generation. This is intentionally stupid (albeit many
-# orders of magnitude less than GCC's default behaviour), as anything
-# with a large number of multilib targets better have been built
-# correctly for the target in mind.
-#
-cflags-y	+= $(shell $(CC) $(KBUILD_CFLAGS) -print-multi-lib | \
-		     grep nofpu | sed q | sed -e 's/^/-/;s/;.*$$//')
-# At this point, anything goes.
-isaflags-y	:= $(call as-option,-Wa$(comma)-isa=any,)
-else
-#
-# -Wa,-isa= tuning implies -Wa,-dsp for the versions of binutils that
-# support it, while -Wa,-dsp by itself limits the range of usable opcodes
-# on certain CPU subtypes. Try the ISA variant first, and if that fails,
-# fall back on -Wa,-dsp for the old binutils versions. Even without DSP
-# opcodes, we always want the best ISA tuning the version of binutils
-# will provide.
-#
-isaflags-y	:= $(call as-option,-Wa$(comma)-isa=$(isa-y),)
-
-isaflags-$(CONFIG_SH_DSP)		:= \
-	$(call as-option,-Wa$(comma)-isa=$(isa-y),-Wa$(comma)-dsp)
-endif
-
-cflags-$(CONFIG_CPU_BIG_ENDIAN)		+= -mb
-cflags-$(CONFIG_CPU_LITTLE_ENDIAN)	+= -ml
-
-cflags-y	+= $(call cc-option,-mno-fdpic)
-cflags-y	+= $(isaflags-y) -ffreestanding
-
-OBJCOPYFLAGS	:= -O binary -R .note -R .note.gnu.build-id -R .comment \
-		   -R .stab -R .stabstr -S
-
-# Give the various platforms the opportunity to set default image types
-defaultimage-y					:= zImage
-defaultimage-$(CONFIG_SH_SH7785LCR)		:= uImage
-defaultimage-$(CONFIG_SH_RSK)			:= uImage
-defaultimage-$(CONFIG_SH_URQUELL)		:= uImage
-defaultimage-$(CONFIG_SH_MIGOR)			:= uImage
-defaultimage-$(CONFIG_SH_AP325RXA)		:= uImage
-defaultimage-$(CONFIG_SH_SH7757LCR)		:= uImage
-defaultimage-$(CONFIG_SH_7724_SOLUTION_ENGINE)	:= uImage
-defaultimage-$(CONFIG_SH_7206_SOLUTION_ENGINE)	:= vmlinux
-defaultimage-$(CONFIG_SH_7619_SOLUTION_ENGINE)	:= vmlinux
-
-# Set some sensible Kbuild defaults
-boot := arch/sh/boot
-KBUILD_IMAGE		:= $(boot)/$(defaultimage-y)
-
-#
-# Choosing incompatible machines durings configuration will result in
-# error messages during linking.
-#
-UTS_MACHINE		:= sh
-LDFLAGS_vmlinux		+= -e _stext
-
-ifdef CONFIG_CPU_LITTLE_ENDIAN
-ld-bfd			:= elf32-sh-linux
-LDFLAGS_vmlinux		+= --defsym jiffies=jiffies_64 --oformat $(ld-bfd)
-KBUILD_LDFLAGS		+= -EL
-else
-ld-bfd			:= elf32-shbig-linux
-LDFLAGS_vmlinux		+= --defsym jiffies=jiffies_64+4 --oformat $(ld-bfd)
-KBUILD_LDFLAGS		+= -EB
-endif
-
-export ld-bfd
-
-# Mach groups
-machdir-$(CONFIG_SOLUTION_ENGINE)		+= mach-se
-machdir-$(CONFIG_SH_HP6XX)			+= mach-hp6xx
-machdir-$(CONFIG_SH_DREAMCAST)			+= mach-dreamcast
-machdir-$(CONFIG_SH_SH03)			+= mach-sh03
-machdir-$(CONFIG_SH_RTS7751R2D)			+= mach-r2d
-machdir-$(CONFIG_SH_HIGHLANDER)			+= mach-highlander
-machdir-$(CONFIG_SH_MIGOR)			+= mach-migor
-machdir-$(CONFIG_SH_AP325RXA)			+= mach-ap325rxa
-machdir-$(CONFIG_SH_KFR2R09)			+= mach-kfr2r09
-machdir-$(CONFIG_SH_ECOVEC)			+= mach-ecovec24
-machdir-$(CONFIG_SH_SDK7780)			+= mach-sdk7780
-machdir-$(CONFIG_SH_SDK7786)			+= mach-sdk7786
-machdir-$(CONFIG_SH_X3PROTO)			+= mach-x3proto
-machdir-$(CONFIG_SH_SH7763RDP)			+= mach-sh7763rdp
-machdir-$(CONFIG_SH_SH4202_MICRODEV)		+= mach-microdev
-machdir-$(CONFIG_SH_LANDISK)			+= mach-landisk
-machdir-$(CONFIG_SH_LBOX_RE2)			+= mach-lboxre2
-machdir-$(CONFIG_SH_RSK)			+= mach-rsk
-
-ifneq ($(machdir-y),)
-core-y	+= $(addprefix arch/sh/boards/, \
-	     $(filter-out ., $(patsubst %,%/,$(machdir-y))))
-endif
-
-# Common machine type headers. Not part of the arch/sh/boards/ hierarchy.
-machdir-y	+= mach-common
-
-# Companion chips
-core-$(CONFIG_HD6446X_SERIES)	+= arch/sh/cchips/hd6446x/
-
-#
-# CPU header paths
-#
-# These are ordered by optimization level. A CPU family that is a subset
-# of another (ie, SH-2A / SH-2), is picked up first, with increasing
-# levels of genericness if nothing more suitable is situated in the
-# hierarchy.
-#
-# As an example, in order of preference, SH-2A > SH-2 > common definitions.
-#
-cpuincdir-$(CONFIG_CPU_SH2A)	+= cpu-sh2a
-cpuincdir-$(CONFIG_CPU_SH2)	+= cpu-sh2
-cpuincdir-$(CONFIG_CPU_SH3)	+= cpu-sh3
-cpuincdir-$(CONFIG_CPU_SH4A)	+= cpu-sh4a
-cpuincdir-$(CONFIG_CPU_SH4)	+= cpu-sh4
-cpuincdir-y			+= cpu-common	# Must be last
-
-drivers-y			+= arch/sh/drivers/
-
-cflags-y	+= $(foreach d, $(cpuincdir-y), -I $(srctree)/arch/sh/include/$(d)) \
-		   $(foreach d, $(machdir-y), -I $(srctree)/arch/sh/include/$(d))
-
-KBUILD_CFLAGS		+= -pipe $(cflags-y)
-KBUILD_CPPFLAGS		+= $(cflags-y)
-KBUILD_AFLAGS		+= $(cflags-y)
-
-ifeq ($(CONFIG_MCOUNT),y)
-  KBUILD_CFLAGS += -pg
-endif
-
-ifeq ($(CONFIG_DWARF_UNWINDER),y)
-  KBUILD_CFLAGS += -fasynchronous-unwind-tables
-endif
-
-libs-y			:= arch/sh/lib/	$(libs-y)
-
-BOOT_TARGETS = uImage uImage.bz2 uImage.gz uImage.lzma uImage.xz uImage.lzo \
-	       uImage.srec uImage.bin zImage vmlinux.bin vmlinux.srec \
-	       romImage
-PHONY += $(BOOT_TARGETS)
-
-all: $(notdir $(KBUILD_IMAGE))
-
-$(BOOT_TARGETS): vmlinux
-	$(Q)$(MAKE) $(build)=$(boot) $(boot)/$@
-
-compressed: zImage
-
-archprepare:
-	$(Q)$(MAKE) $(build)=arch/sh/tools include/generated/machtypes.h
-
-archheaders:
-	$(Q)$(MAKE) $(build)=arch/sh/kernel/syscalls all
-
-define archhelp
-	@echo '  zImage 	           - Compressed kernel image'
-	@echo '  romImage	           - Compressed ROM image, if supported'
-	@echo '  vmlinux.srec	           - Create an ELF S-record'
-	@echo '  vmlinux.bin	           - Create an uncompressed binary image'
-	@echo '* uImage  	           - Alias to bootable U-Boot image'
-	@echo '  uImage.srec	           - Create an S-record for U-Boot'
-	@echo '  uImage.bin	           - Kernel-only image for U-Boot (bin)'
-	@echo '* uImage.gz	           - Kernel-only image for U-Boot (gzip)'
-	@echo '  uImage.bz2	           - Kernel-only image for U-Boot (bzip2)'
-	@echo '  uImage.lzma	           - Kernel-only image for U-Boot (lzma)'
-	@echo '  uImage.xz	           - Kernel-only image for U-Boot (xz)'
-	@echo '  uImage.lzo	           - Kernel-only image for U-Boot (lzo)'
-endef
diff --git a/arch/sh/boards/Kconfig b/arch/sh/boards/Kconfig
deleted file mode 100644
index 83bcb6d2dacadd..00000000000000
--- a/arch/sh/boards/Kconfig
+++ /dev/null
@@ -1,400 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-menu "Board support"
-
-config SOLUTION_ENGINE
-	bool
-
-config SH_ALPHA_BOARD
-	bool
-
-config SH_CUSTOM_CLK
-	def_bool y
-	depends on !SH_DEVICE_TREE
-	select HAVE_LEGACY_CLK
-
-config SH_DEVICE_TREE
-	bool
-	select OF
-	select OF_EARLY_FLATTREE
-	select TIMER_OF
-	select COMMON_CLK
-	select GENERIC_CALIBRATE_DELAY
-
-config SH_JCORE_SOC
-	bool "J-Core SoC"
-	select SH_DEVICE_TREE
-	select CLKSRC_JCORE_PIT
-	select JCORE_AIC
-	depends on CPU_J2
-	help
-	  Select this option to include drivers core components of the
-	  J-Core SoC, including interrupt controllers and timers.
-
-config SH_SOLUTION_ENGINE
-	bool "SolutionEngine"
-	select SOLUTION_ENGINE
-	select CPU_HAS_IPR_IRQ
-	depends on CPU_SUBTYPE_SH7705 || CPU_SUBTYPE_SH7709 || CPU_SUBTYPE_SH7710 || \
-	  CPU_SUBTYPE_SH7712 || CPU_SUBTYPE_SH7750 || CPU_SUBTYPE_SH7750S || \
-	  CPU_SUBTYPE_SH7750R 
-	help
-	  Select SolutionEngine if configuring for a Hitachi SH7705, SH7709,
-	  SH7710, SH7712, SH7750, SH7750S or SH7750R evaluation board.
-
-config SH_7206_SOLUTION_ENGINE
-	bool "SolutionEngine7206"
-	select SOLUTION_ENGINE
-	depends on CPU_SUBTYPE_SH7206
-	help
-	  Select 7206 SolutionEngine if configuring for a Hitachi SH7206
-	  evaluation board.
-
-config SH_7619_SOLUTION_ENGINE
-	bool "SolutionEngine7619"
-	select SOLUTION_ENGINE
-	depends on CPU_SUBTYPE_SH7619
-	help
-	  Select 7619 SolutionEngine if configuring for a Hitachi SH7619
-	  evaluation board.
-	
-config SH_7721_SOLUTION_ENGINE
-	bool "SolutionEngine7721"
-	select SOLUTION_ENGINE
-	depends on CPU_SUBTYPE_SH7721
-	help
-	  Select 7721 SolutionEngine if configuring for a Hitachi SH7721
-	  evaluation board.
-
-config SH_7722_SOLUTION_ENGINE
-	bool "SolutionEngine7722"
-	select SOLUTION_ENGINE
-	select GENERIC_IRQ_CHIP
-	select IRQ_DOMAIN
-	depends on CPU_SUBTYPE_SH7722
-	help
-	  Select 7722 SolutionEngine if configuring for a Hitachi SH772
-	  evaluation board.
-
-config SH_7724_SOLUTION_ENGINE
-	bool "SolutionEngine7724"
-	select SOLUTION_ENGINE
-	depends on CPU_SUBTYPE_SH7724
-	select GPIOLIB
-	select SND_SOC_AK4642 if SND_SIMPLE_CARD
-	select REGULATOR_FIXED_VOLTAGE if REGULATOR
-	help
-	  Select 7724 SolutionEngine if configuring for a Hitachi SH7724
-	  evaluation board.
-
-config SH_7751_SOLUTION_ENGINE
-	bool "SolutionEngine7751"
-	select SOLUTION_ENGINE
-	select CPU_HAS_IPR_IRQ
-	depends on CPU_SUBTYPE_SH7751
-	help
-	  Select 7751 SolutionEngine if configuring for a Hitachi SH7751
-	  evaluation board.
-	  
-config SH_7780_SOLUTION_ENGINE
-	bool "SolutionEngine7780"
-	select SOLUTION_ENGINE
-	select HAVE_PCI
-	depends on CPU_SUBTYPE_SH7780
-	help
-	  Select 7780 SolutionEngine if configuring for a Renesas SH7780
-	  evaluation board.
-
-config SH_7343_SOLUTION_ENGINE
-	bool "SolutionEngine7343"
-	select SOLUTION_ENGINE
-	select GENERIC_IRQ_CHIP
-	select IRQ_DOMAIN
-	depends on CPU_SUBTYPE_SH7343
-	help
-	  Select 7343 SolutionEngine if configuring for a Hitachi
-	  SH7343 (SH-Mobile 3AS) evaluation board.
-
-config SH_HP6XX
-	bool "HP6XX"
-	select SYS_SUPPORTS_APM_EMULATION
-	select HD6446X_SERIES
-	depends on CPU_SUBTYPE_SH7709
-	help
-	  Select HP6XX if configuring for a HP jornada HP6xx.
-	  More information (hardware only) at
-	  <http://www.hp.com/jornada/>.
-
-config SH_DREAMCAST
-	bool "Dreamcast"
-	select HAVE_PCI
-	depends on CPU_SUBTYPE_SH7091
-	help
-	  Select Dreamcast if configuring for a SEGA Dreamcast.
-	  More information at <http://www.linux-sh.org>
-
-config SH_SH03
-	bool "Interface CTP/PCI-SH03"
-	depends on CPU_SUBTYPE_SH7751
-	select CPU_HAS_IPR_IRQ
-	select HAVE_PCI
-	help
-	  CTP/PCI-SH03 is a CPU module computer that is produced
-	  by Interface Corporation.
-	  More information at <http://www.interface.co.jp>
-
-config SH_SECUREEDGE5410
-	bool "SecureEdge5410"
-	depends on CPU_SUBTYPE_SH7751R
-	select CPU_HAS_IPR_IRQ
-	select HAVE_PCI
-	help
-	  Select SecureEdge5410 if configuring for a SnapGear SH board.
-	  This includes both the OEM SecureEdge products as well as the
-	  SME product line.
-
-config SH_RTS7751R2D
-	bool "RTS7751R2D"
-	depends on CPU_SUBTYPE_SH7751R
-	select HAVE_PCI
-	select IO_TRAPPED if MMU
-	help
-	  Select RTS7751R2D if configuring for a Renesas Technology
-	  Sales SH-Graphics board.
-
-config SH_RSK
-	bool "Renesas Starter Kit"
-	depends on CPU_SUBTYPE_SH7201 || CPU_SUBTYPE_SH7203 || \
-	  CPU_SUBTYPE_SH7264 || CPU_SUBTYPE_SH7269
-	select REGULATOR_FIXED_VOLTAGE if REGULATOR
-	help
-	 Select this option if configuring for any of the RSK+ MCU
-	 evaluation platforms.
-
-config SH_SDK7780
-	bool "SDK7780R3"
-	depends on CPU_SUBTYPE_SH7780
-	select HAVE_PCI
-	help
-	  Select SDK7780 if configuring for a Renesas SH7780 SDK7780R3
-	  evaluation board.
-
-config SH_SDK7786
-	bool "SDK7786"
-	depends on CPU_SUBTYPE_SH7786
-	select HAVE_PCI
-	select NO_IOPORT_MAP if !PCI
-	select HAVE_SRAM_POOL
-	select REGULATOR_FIXED_VOLTAGE if REGULATOR
-	help
-	  Select SDK7786 if configuring for a Renesas Technology Europe
-	  SH7786-65nm board.
-
-config SH_HIGHLANDER
-	bool "Highlander"
-	depends on CPU_SUBTYPE_SH7780 || CPU_SUBTYPE_SH7785
-	select HAVE_PCI
-	select IO_TRAPPED if MMU
-
-config SH_SH7757LCR
-	bool "SH7757LCR"
-	depends on CPU_SUBTYPE_SH7757
-	select GPIOLIB
-	select REGULATOR_FIXED_VOLTAGE if REGULATOR
-
-config SH_SH7785LCR
-	bool "SH7785LCR"
-	depends on CPU_SUBTYPE_SH7785
-	select HAVE_PCI
-
-config SH_SH7785LCR_29BIT_PHYSMAPS
-	bool "SH7785LCR 29bit physmaps"
-	depends on SH_SH7785LCR && 29BIT
-	default y
-	help
-	  This board has 2 physical memory maps. It can be changed with
-	  DIP switch(S2-5). If you set the DIP switch for S2-5 = ON,
-	  you can access all on-board device in 29bit address mode.
-
-config SH_SH7785LCR_PT
-	bool "SH7785LCR prototype board on 32-bit MMU mode"
-	depends on SH_SH7785LCR && 32BIT
-	default n
-	help
-	  If you use prototype board, this option is enabled.
-
-config SH_URQUELL
-	bool "Urquell"
-	depends on CPU_SUBTYPE_SH7786
-	select GPIOLIB
-	select HAVE_PCI
-	select NO_IOPORT_MAP if !PCI
-
-config SH_MIGOR
-	bool "Migo-R"
-	depends on CPU_SUBTYPE_SH7722
-	select GPIOLIB
-	select REGULATOR_FIXED_VOLTAGE if REGULATOR
-	help
-	  Select Migo-R if configuring for the SH7722 Migo-R platform
-          by Renesas System Solutions Asia Pte. Ltd.
-
-config SH_AP325RXA
-	bool "AP-325RXA"
-	depends on CPU_SUBTYPE_SH7723
-	select GPIOLIB
-	select REGULATOR_FIXED_VOLTAGE if REGULATOR
-	help
-	  Renesas "AP-325RXA" support.
-	  Compatible with ALGO SYSTEM CO.,LTD. "AP-320A"
-
-config SH_KFR2R09
-	bool "KFR2R09"
-	depends on CPU_SUBTYPE_SH7724
-	select GPIOLIB
-	select REGULATOR_FIXED_VOLTAGE if REGULATOR
-	help
-	  "Kit For R2R for 2009" support.
-
-config SH_ECOVEC
-	bool "EcoVec"
-	depends on CPU_SUBTYPE_SH7724
-	select GPIOLIB
-	select SND_SOC_DA7210 if SND_SIMPLE_CARD
-	select REGULATOR_FIXED_VOLTAGE if REGULATOR
-	help
-	  Renesas "R0P7724LC0011/21RL (EcoVec)" support.
-
-config SH_SH7763RDP
-	bool "SH7763RDP"
-	depends on CPU_SUBTYPE_SH7763
-	help
-	  Select SH7763RDP if configuring for a Renesas SH7763
-	  evaluation board.
-
-config SH_ESPT
-	bool "ESPT"
-	depends on CPU_SUBTYPE_SH7763
-	help
-	  Select ESPT if configuring for a Renesas SH7763
-	  with gigabit ether evaluation board.
-
-config SH_EDOSK7705
-	bool "EDOSK7705"
-	depends on CPU_SUBTYPE_SH7705
-
-config SH_EDOSK7760
-	bool "EDOSK7760"
-	depends on CPU_SUBTYPE_SH7760
-	help
-	  Select if configuring for a Renesas EDOSK7760
-	  evaluation board.
-
-config SH_SH4202_MICRODEV
-	bool "SH4-202 MicroDev"
-	depends on CPU_SUBTYPE_SH4_202
-	help
-	  Select SH4-202 MicroDev if configuring for a SuperH MicroDev board
-	  with an SH4-202 CPU.
-
-config SH_LANDISK
-	bool "LANDISK"
-	depends on CPU_SUBTYPE_SH7751R
-	select HAVE_PCI
-	help
-	  I-O DATA DEVICE, INC. "LANDISK Series" support.
-
-config SH_TITAN
-	bool "TITAN"
-	depends on CPU_SUBTYPE_SH7751R
-	select CPU_HAS_IPR_IRQ
-	select HAVE_PCI
-	help
-	  Select Titan if you are configuring for a Nimble Microsystems
-	  NetEngine NP51R.
-
-config SH_SHMIN
-	bool "SHMIN"
-	depends on CPU_SUBTYPE_SH7706
-	select CPU_HAS_IPR_IRQ
-	help
-	  Select SHMIN if configuring for the SHMIN board.
-
-config SH_LBOX_RE2
-	bool "L-BOX RE2"
-	depends on CPU_SUBTYPE_SH7751R
-	select HAVE_PCI
-	help
-	  Select L-BOX RE2 if configuring for the NTT COMWARE L-BOX RE2.
-
-config SH_X3PROTO
-	bool "SH-X3 Prototype board"
-	depends on CPU_SUBTYPE_SHX3
-	select NO_IOPORT_MAP if !PCI
-	select IRQ_DOMAIN
-
-config SH_MAGIC_PANEL_R2
-	bool "Magic Panel R2"
-	depends on CPU_SUBTYPE_SH7720
-	select GPIOLIB
-	select REGULATOR_FIXED_VOLTAGE if REGULATOR
-	help
-	  Select Magic Panel R2 if configuring for Magic Panel R2.
-
-config SH_POLARIS
-	bool "SMSC Polaris"
-	select CPU_HAS_IPR_IRQ
-	select REGULATOR_FIXED_VOLTAGE if REGULATOR
-	depends on CPU_SUBTYPE_SH7709
-	help
-	  Select if configuring for an SMSC Polaris development board
-
-config SH_SH2007
-	bool "SH-2007 board"
-	select NO_IOPORT_MAP
-	select REGULATOR_FIXED_VOLTAGE if REGULATOR
-	depends on CPU_SUBTYPE_SH7780
-	help
-	  SH-2007 is a single-board computer based around SH7780 chip
-	  intended for embedded applications.
-	  It has an Ethernet interface (SMC9118), direct connected
-	  Compact Flash socket, two serial ports and PC-104 bus.
-	  More information at <http://sh2000.sh-linux.org>.
-
-config SH_APSH4A3A
-	bool "AP-SH4A-3A"
-	select SH_ALPHA_BOARD
-	select REGULATOR_FIXED_VOLTAGE if REGULATOR
-	depends on CPU_SUBTYPE_SH7785
-	help
-	  Select AP-SH4A-3A if configuring for an ALPHAPROJECT AP-SH4A-3A.
-
-config SH_APSH4AD0A
-	bool "AP-SH4AD-0A"
-	select SH_ALPHA_BOARD
-	select HAVE_PCI
-	select REGULATOR_FIXED_VOLTAGE if REGULATOR
-	depends on CPU_SUBTYPE_SH7786
-	help
-	  Select AP-SH4AD-0A if configuring for an ALPHAPROJECT AP-SH4AD-0A.
-
-source "arch/sh/boards/mach-r2d/Kconfig"
-source "arch/sh/boards/mach-highlander/Kconfig"
-source "arch/sh/boards/mach-sdk7780/Kconfig"
-source "arch/sh/boards/mach-migor/Kconfig"
-source "arch/sh/boards/mach-rsk/Kconfig"
-
-if SH_MAGIC_PANEL_R2
-
-menu "Magic Panel R2 options"
-
-config SH_MAGIC_PANEL_R2_VERSION
-	int "Magic Panel R2 Version"
-	default "3"
-	help
-	  Set the version of the Magic Panel R2
-
-endmenu
-
-endif
-
-endmenu
diff --git a/arch/sh/boards/Makefile b/arch/sh/boards/Makefile
deleted file mode 100644
index 4002a22a7c409b..00000000000000
--- a/arch/sh/boards/Makefile
+++ /dev/null
@@ -1,20 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Specific board support, not covered by a mach group.
-#
-obj-$(CONFIG_SH_MAGIC_PANEL_R2)	+= board-magicpanelr2.o
-obj-$(CONFIG_SH_SECUREEDGE5410)	+= board-secureedge5410.o
-obj-$(CONFIG_SH_SH2007)		+= board-sh2007.o
-obj-$(CONFIG_SH_SH7785LCR)	+= board-sh7785lcr.o
-obj-$(CONFIG_SH_URQUELL)	+= board-urquell.o
-obj-$(CONFIG_SH_SHMIN)		+= board-shmin.o
-obj-$(CONFIG_SH_EDOSK7705)	+= board-edosk7705.o
-obj-$(CONFIG_SH_EDOSK7760)	+= board-edosk7760.o
-obj-$(CONFIG_SH_ESPT)		+= board-espt.o
-obj-$(CONFIG_SH_POLARIS)	+= board-polaris.o
-obj-$(CONFIG_SH_TITAN)		+= board-titan.o
-obj-$(CONFIG_SH_SH7757LCR)	+= board-sh7757lcr.o
-obj-$(CONFIG_SH_APSH4A3A)	+= board-apsh4a3a.o
-obj-$(CONFIG_SH_APSH4AD0A)	+= board-apsh4ad0a.o
-
-obj-$(CONFIG_SH_DEVICE_TREE)	+= of-generic.o
diff --git a/arch/sh/boards/board-apsh4a3a.c b/arch/sh/boards/board-apsh4a3a.c
deleted file mode 100644
index abf19a947df354..00000000000000
--- a/arch/sh/boards/board-apsh4a3a.c
+++ /dev/null
@@ -1,182 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * ALPHAPROJECT AP-SH4A-3A Support.
- *
- * Copyright (C) 2010 ALPHAPROJECT Co.,Ltd.
- * Copyright (C) 2008  Yoshihiro Shimoda
- * Copyright (C) 2009  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/io.h>
-#include <linux/mtd/physmap.h>
-#include <linux/regulator/fixed.h>
-#include <linux/regulator/machine.h>
-#include <linux/smsc911x.h>
-#include <linux/irq.h>
-#include <linux/clk.h>
-#include <asm/machvec.h>
-#include <linux/sizes.h>
-#include <asm/clock.h>
-
-static struct mtd_partition nor_flash_partitions[] = {
-	{
-		.name		= "loader",
-		.offset		= 0x00000000,
-		.size		= 512 * 1024,
-	},
-	{
-		.name		= "bootenv",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= 512 * 1024,
-	},
-	{
-		.name		= "kernel",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= 4 * 1024 * 1024,
-	},
-	{
-		.name		= "data",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= MTDPART_SIZ_FULL,
-	},
-};
-
-static struct physmap_flash_data nor_flash_data = {
-	.width		= 4,
-	.parts		= nor_flash_partitions,
-	.nr_parts	= ARRAY_SIZE(nor_flash_partitions),
-};
-
-static struct resource nor_flash_resources[] = {
-	[0]	= {
-		.start	= 0x00000000,
-		.end	= 0x01000000 - 1,
-		.flags	= IORESOURCE_MEM,
-	}
-};
-
-static struct platform_device nor_flash_device = {
-	.name		= "physmap-flash",
-	.dev		= {
-		.platform_data	= &nor_flash_data,
-	},
-	.num_resources	= ARRAY_SIZE(nor_flash_resources),
-	.resource	= nor_flash_resources,
-};
-
-/* Dummy supplies, where voltage doesn't matter */
-static struct regulator_consumer_supply dummy_supplies[] = {
-	REGULATOR_SUPPLY("vddvario", "smsc911x"),
-	REGULATOR_SUPPLY("vdd33a", "smsc911x"),
-};
-
-static struct resource smsc911x_resources[] = {
-	[0] = {
-		.name		= "smsc911x-memory",
-		.start		= 0xA4000000,
-		.end		= 0xA4000000 + SZ_256 - 1,
-		.flags		= IORESOURCE_MEM,
-	},
-	[1] = {
-		.name		= "smsc911x-irq",
-		.start		= evt2irq(0x200),
-		.end		= evt2irq(0x200),
-		.flags		= IORESOURCE_IRQ,
-	},
-};
-
-static struct smsc911x_platform_config smsc911x_config = {
-	.irq_polarity	= SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
-	.irq_type	= SMSC911X_IRQ_TYPE_OPEN_DRAIN,
-	.flags		= SMSC911X_USE_16BIT,
-	.phy_interface	= PHY_INTERFACE_MODE_MII,
-};
-
-static struct platform_device smsc911x_device = {
-	.name		= "smsc911x",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(smsc911x_resources),
-	.resource	= smsc911x_resources,
-	.dev = {
-		.platform_data = &smsc911x_config,
-	},
-};
-
-static struct platform_device *apsh4a3a_devices[] __initdata = {
-	&nor_flash_device,
-	&smsc911x_device,
-};
-
-static int __init apsh4a3a_devices_setup(void)
-{
-	regulator_register_fixed(0, dummy_supplies, ARRAY_SIZE(dummy_supplies));
-
-	return platform_add_devices(apsh4a3a_devices,
-				    ARRAY_SIZE(apsh4a3a_devices));
-}
-device_initcall(apsh4a3a_devices_setup);
-
-static int apsh4a3a_clk_init(void)
-{
-	struct clk *clk;
-	int ret;
-
-	clk = clk_get(NULL, "extal");
-	if (IS_ERR(clk))
-		return PTR_ERR(clk);
-	ret = clk_set_rate(clk, 33333000);
-	clk_put(clk);
-
-	return ret;
-}
-
-/* Initialize the board */
-static void __init apsh4a3a_setup(char **cmdline_p)
-{
-	printk(KERN_INFO "Alpha Project AP-SH4A-3A support:\n");
-}
-
-static void __init apsh4a3a_init_irq(void)
-{
-	plat_irq_setup_pins(IRQ_MODE_IRQ7654);
-}
-
-/* Return the board specific boot mode pin configuration */
-static int apsh4a3a_mode_pins(void)
-{
-	int value = 0;
-
-	/* These are the factory default settings of SW1 and SW2.
-	 * If you change these dip switches then you will need to
-	 * adjust the values below as well.
-	 */
-	value &= ~MODE_PIN0;  /* Clock Mode 16 */
-	value &= ~MODE_PIN1;
-	value &= ~MODE_PIN2;
-	value &= ~MODE_PIN3;
-	value |=  MODE_PIN4;
-	value &= ~MODE_PIN5;  /* 16-bit Area0 bus width */
-	value |=  MODE_PIN6;  /* Area 0 SRAM interface */
-	value |=  MODE_PIN7;
-	value |=  MODE_PIN8;  /* Little Endian */
-	value |=  MODE_PIN9;  /* Master Mode */
-	value |=  MODE_PIN10; /* Crystal resonator */
-	value |=  MODE_PIN11; /* Display Unit */
-	value |=  MODE_PIN12;
-	value &= ~MODE_PIN13; /* 29-bit address mode */
-	value |=  MODE_PIN14; /* No PLL step-up */
-
-	return value;
-}
-
-/*
- * The Machine Vector
- */
-static struct sh_machine_vector mv_apsh4a3a __initmv = {
-	.mv_name		= "AP-SH4A-3A",
-	.mv_setup		= apsh4a3a_setup,
-	.mv_clk_init		= apsh4a3a_clk_init,
-	.mv_init_irq		= apsh4a3a_init_irq,
-	.mv_mode_pins		= apsh4a3a_mode_pins,
-};
diff --git a/arch/sh/boards/board-apsh4ad0a.c b/arch/sh/boards/board-apsh4ad0a.c
deleted file mode 100644
index fa031a16c9b5c7..00000000000000
--- a/arch/sh/boards/board-apsh4ad0a.c
+++ /dev/null
@@ -1,132 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * ALPHAPROJECT AP-SH4AD-0A Support.
- *
- * Copyright (C) 2010 ALPHAPROJECT Co.,Ltd.
- * Copyright (C) 2010  Matt Fleming
- * Copyright (C) 2010  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/io.h>
-#include <linux/regulator/fixed.h>
-#include <linux/regulator/machine.h>
-#include <linux/smsc911x.h>
-#include <linux/irq.h>
-#include <linux/clk.h>
-#include <asm/machvec.h>
-#include <linux/sizes.h>
-
-/* Dummy supplies, where voltage doesn't matter */
-static struct regulator_consumer_supply dummy_supplies[] = {
-	REGULATOR_SUPPLY("vddvario", "smsc911x"),
-	REGULATOR_SUPPLY("vdd33a", "smsc911x"),
-};
-
-static struct resource smsc911x_resources[] = {
-	[0] = {
-		.name		= "smsc911x-memory",
-		.start		= 0xA4000000,
-		.end		= 0xA4000000 + SZ_256 - 1,
-		.flags		= IORESOURCE_MEM,
-	},
-	[1] = {
-		.name		= "smsc911x-irq",
-		.start		= evt2irq(0x200),
-		.end		= evt2irq(0x200),
-		.flags		= IORESOURCE_IRQ,
-	},
-};
-
-static struct smsc911x_platform_config smsc911x_config = {
-	.irq_polarity	= SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
-	.irq_type	= SMSC911X_IRQ_TYPE_OPEN_DRAIN,
-	.flags		= SMSC911X_USE_16BIT,
-	.phy_interface	= PHY_INTERFACE_MODE_MII,
-};
-
-static struct platform_device smsc911x_device = {
-	.name		= "smsc911x",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(smsc911x_resources),
-	.resource	= smsc911x_resources,
-	.dev = {
-		.platform_data = &smsc911x_config,
-	},
-};
-
-static struct platform_device *apsh4ad0a_devices[] __initdata = {
-	&smsc911x_device,
-};
-
-static int __init apsh4ad0a_devices_setup(void)
-{
-	regulator_register_fixed(0, dummy_supplies, ARRAY_SIZE(dummy_supplies));
-
-	return platform_add_devices(apsh4ad0a_devices,
-				    ARRAY_SIZE(apsh4ad0a_devices));
-}
-device_initcall(apsh4ad0a_devices_setup);
-
-static int apsh4ad0a_mode_pins(void)
-{
-	int value = 0;
-
-	/* These are the factory default settings of SW1 and SW2.
-	 * If you change these dip switches then you will need to
-	 * adjust the values below as well.
-	 */
-	value |=  MODE_PIN0;  /* Clock Mode 3 */
-	value |=  MODE_PIN1;
-	value &= ~MODE_PIN2;
-	value &= ~MODE_PIN3;
-	value &= ~MODE_PIN4;  /* 16-bit Area0 bus width  */
-	value |=  MODE_PIN5;
-	value |=  MODE_PIN6;
-	value |=  MODE_PIN7;  /* Normal mode */
-	value |=  MODE_PIN8;  /* Little Endian */
-	value |=  MODE_PIN9;  /* Crystal resonator */
-	value &= ~MODE_PIN10; /* 29-bit address mode */
-	value &= ~MODE_PIN11; /* PCI-E Root port */
-	value &= ~MODE_PIN12; /* 4 lane + 1 lane */
-	value |=  MODE_PIN13; /* AUD Enable */
-	value &= ~MODE_PIN14; /* Normal Operation */
-
-	return value;
-}
-
-static int apsh4ad0a_clk_init(void)
-{
-	struct clk *clk;
-	int ret;
-
-	clk = clk_get(NULL, "extal");
-	if (IS_ERR(clk))
-		return PTR_ERR(clk);
-	ret = clk_set_rate(clk, 33333000);
-	clk_put(clk);
-
-	return ret;
-}
-
-/* Initialize the board */
-static void __init apsh4ad0a_setup(char **cmdline_p)
-{
-	pr_info("Alpha Project AP-SH4AD-0A support:\n");
-}
-
-static void __init apsh4ad0a_init_irq(void)
-{
-	plat_irq_setup_pins(IRQ_MODE_IRQ3210);
-}
-
-/*
- * The Machine Vector
- */
-static struct sh_machine_vector mv_apsh4ad0a __initmv = {
-	.mv_name		= "AP-SH4AD-0A",
-	.mv_setup		= apsh4ad0a_setup,
-	.mv_mode_pins		= apsh4ad0a_mode_pins,
-	.mv_clk_init		= apsh4ad0a_clk_init,
-	.mv_init_irq		= apsh4ad0a_init_irq,
-};
diff --git a/arch/sh/boards/board-edosk7705.c b/arch/sh/boards/board-edosk7705.c
deleted file mode 100644
index 0de7d603da2d8c..00000000000000
--- a/arch/sh/boards/board-edosk7705.c
+++ /dev/null
@@ -1,79 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/boards/renesas/edosk7705/setup.c
- *
- * Copyright (C) 2000  Kazumoto Kojima
- *
- * Hitachi SolutionEngine Support.
- *
- * Modified for edosk7705 development
- * board by S. Dunn, 2003.
- */
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <linux/smc91x.h>
-#include <linux/sh_intc.h>
-#include <asm/machvec.h>
-#include <linux/sizes.h>
-
-#define SMC_IOBASE	0xA2000000
-#define SMC_IO_OFFSET	0x300
-#define SMC_IOADDR	(SMC_IOBASE + SMC_IO_OFFSET)
-
-#define ETHERNET_IRQ	evt2irq(0x320)
-
-static void __init sh_edosk7705_init_irq(void)
-{
-	make_imask_irq(ETHERNET_IRQ);
-}
-
-/* eth initialization functions */
-static struct smc91x_platdata smc91x_info = {
-	.flags = SMC91X_USE_16BIT | SMC91X_IO_SHIFT_1 | IORESOURCE_IRQ_LOWLEVEL,
-};
-
-static struct resource smc91x_res[] = {
-	[0] = {
-		.start	= SMC_IOADDR,
-		.end	= SMC_IOADDR + SZ_32 - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= ETHERNET_IRQ,
-		.end	= ETHERNET_IRQ,
-		.flags	= IORESOURCE_IRQ ,
-	}
-};
-
-static struct platform_device smc91x_dev = {
-	.name		= "smc91x",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(smc91x_res),
-	.resource	= smc91x_res,
-
-	.dev	= {
-		.platform_data	= &smc91x_info,
-	},
-};
-
-/* platform init code */
-static struct platform_device *edosk7705_devices[] __initdata = {
-	&smc91x_dev,
-};
-
-static int __init init_edosk7705_devices(void)
-{
-	return platform_add_devices(edosk7705_devices,
-				    ARRAY_SIZE(edosk7705_devices));
-}
-device_initcall(init_edosk7705_devices);
-
-/*
- * The Machine Vector
- */
-static struct sh_machine_vector mv_edosk7705 __initmv = {
-	.mv_name		= "EDOSK7705",
-	.mv_init_irq		= sh_edosk7705_init_irq,
-};
diff --git a/arch/sh/boards/board-edosk7760.c b/arch/sh/boards/board-edosk7760.c
deleted file mode 100644
index 7569d85c5ff5a8..00000000000000
--- a/arch/sh/boards/board-edosk7760.c
+++ /dev/null
@@ -1,178 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Renesas Europe EDOSK7760 Board Support
- *
- * Copyright (C) 2008 SPES Societa' Progettazione Elettronica e Software Ltd.
- * Author: Luca Santini <luca.santini@spesonline.com>
- */
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/platform_device.h>
-#include <linux/smc91x.h>
-#include <linux/interrupt.h>
-#include <linux/sh_intc.h>
-#include <linux/i2c.h>
-#include <linux/mtd/physmap.h>
-#include <asm/machvec.h>
-#include <asm/io.h>
-#include <asm/addrspace.h>
-#include <asm/delay.h>
-#include <asm/i2c-sh7760.h>
-#include <linux/sizes.h>
-
-/* Bus state controller registers for CS4 area */
-#define BSC_CS4BCR	0xA4FD0010
-#define BSC_CS4WCR	0xA4FD0030
-
-#define SMC_IOBASE	0xA2000000
-#define SMC_IO_OFFSET	0x300
-#define SMC_IOADDR	(SMC_IOBASE + SMC_IO_OFFSET)
-
-/* NOR flash */
-static struct mtd_partition edosk7760_nor_flash_partitions[] = {
-	{
-		.name = "bootloader",
-		.offset = 0,
-		.size = SZ_256K,
-		.mask_flags = MTD_WRITEABLE,	/* Read-only */
-	}, {
-		.name = "kernel",
-		.offset = MTDPART_OFS_APPEND,
-		.size = SZ_2M,
-	}, {
-		.name = "fs",
-		.offset = MTDPART_OFS_APPEND,
-		.size = (26 << 20),
-	}, {
-		.name = "other",
-		.offset = MTDPART_OFS_APPEND,
-		.size = MTDPART_SIZ_FULL,
-	},
-};
-
-static struct physmap_flash_data edosk7760_nor_flash_data = {
-	.width		= 4,
-	.parts		= edosk7760_nor_flash_partitions,
-	.nr_parts	= ARRAY_SIZE(edosk7760_nor_flash_partitions),
-};
-
-static struct resource edosk7760_nor_flash_resources[] = {
-	[0] = {
-		.name	= "NOR Flash",
-		.start	= 0x00000000,
-		.end	= 0x00000000 + SZ_32M - 1,
-		.flags	= IORESOURCE_MEM,
-	}
-};
-
-static struct platform_device edosk7760_nor_flash_device = {
-	.name		= "physmap-flash",
-	.resource	= edosk7760_nor_flash_resources,
-	.num_resources	= ARRAY_SIZE(edosk7760_nor_flash_resources),
-	.dev		= {
-		.platform_data = &edosk7760_nor_flash_data,
-	},
-};
-
-/* i2c initialization functions */
-static struct sh7760_i2c_platdata i2c_pd = {
-	.speed_khz	= 400,
-};
-
-static struct resource sh7760_i2c1_res[] = {
-	{
-		.start	= SH7760_I2C1_MMIO,
-		.end	= SH7760_I2C1_MMIOEND,
-		.flags	= IORESOURCE_MEM,
-	},{
-		.start	= evt2irq(0x9e0),
-		.end	= evt2irq(0x9e0),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device sh7760_i2c1_dev = {
-	.dev    = {
-		.platform_data	= &i2c_pd,
-	},
-
-	.name		= SH7760_I2C_DEVNAME,
-	.id		= 1,
-	.resource	= sh7760_i2c1_res,
-	.num_resources	= ARRAY_SIZE(sh7760_i2c1_res),
-};
-
-static struct resource sh7760_i2c0_res[] = {
-	{
-		.start	= SH7760_I2C0_MMIO,
-		.end	= SH7760_I2C0_MMIOEND,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.start	= evt2irq(0x9c0),
-		.end	= evt2irq(0x9c0),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device sh7760_i2c0_dev = {
-	.dev    = {
-		.platform_data	= &i2c_pd,
-	},
-	.name		= SH7760_I2C_DEVNAME,
-	.id		= 0,
-	.resource	= sh7760_i2c0_res,
-	.num_resources	= ARRAY_SIZE(sh7760_i2c0_res),
-};
-
-/* eth initialization functions */
-static struct smc91x_platdata smc91x_info = {
-	.flags = SMC91X_USE_16BIT | SMC91X_IO_SHIFT_1 | IORESOURCE_IRQ_LOWLEVEL,
-};
-
-static struct resource smc91x_res[] = {
-	[0] = {
-		.start	= SMC_IOADDR,
-		.end	= SMC_IOADDR + SZ_32 - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0x2a0),
-		.end	= evt2irq(0x2a0),
-		.flags	= IORESOURCE_IRQ ,
-	}
-};
-
-static struct platform_device smc91x_dev = {
-	.name		= "smc91x",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(smc91x_res),
-	.resource	= smc91x_res,
-
-	.dev	= {
-		.platform_data	= &smc91x_info,
-	},
-};
-
-/* platform init code */
-static struct platform_device *edosk7760_devices[] __initdata = {
-	&smc91x_dev,
-	&edosk7760_nor_flash_device,
-	&sh7760_i2c0_dev,
-	&sh7760_i2c1_dev,
-};
-
-static int __init init_edosk7760_devices(void)
-{
-	plat_irq_setup_pins(IRQ_MODE_IRQ);
-
-	return platform_add_devices(edosk7760_devices,
-				    ARRAY_SIZE(edosk7760_devices));
-}
-device_initcall(init_edosk7760_devices);
-
-/*
- * The Machine Vector
- */
-struct sh_machine_vector mv_edosk7760 __initmv = {
-	.mv_name	= "EDOSK7760",
-};
diff --git a/arch/sh/boards/board-espt.c b/arch/sh/boards/board-espt.c
deleted file mode 100644
index 6e784b5cf5a0b2..00000000000000
--- a/arch/sh/boards/board-espt.c
+++ /dev/null
@@ -1,105 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Data Technology Inc. ESPT-GIGA board support
- *
- * Copyright (C) 2008, 2009 Renesas Solutions Corp.
- * Copyright (C) 2008, 2009 Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
- */
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <linux/mtd/physmap.h>
-#include <linux/io.h>
-#include <linux/sh_eth.h>
-#include <linux/sh_intc.h>
-#include <asm/machvec.h>
-#include <linux/sizes.h>
-
-/* NOR Flash */
-static struct mtd_partition espt_nor_flash_partitions[] = {
-	{
-		.name = "U-Boot",
-		.offset = 0,
-		.size = (2 * SZ_128K),
-		.mask_flags = MTD_WRITEABLE,	/* Read-only */
-	}, {
-		.name = "Linux-Kernel",
-		.offset = MTDPART_OFS_APPEND,
-		.size = (20 * SZ_128K),
-	}, {
-		.name = "Root Filesystem",
-		.offset = MTDPART_OFS_APPEND,
-		.size = MTDPART_SIZ_FULL,
-	},
-};
-
-static struct physmap_flash_data espt_nor_flash_data = {
-	.width = 2,
-	.parts = espt_nor_flash_partitions,
-	.nr_parts = ARRAY_SIZE(espt_nor_flash_partitions),
-};
-
-static struct resource espt_nor_flash_resources[] = {
-	[0] = {
-		.name = "NOR Flash",
-		.start = 0,
-		.end = SZ_8M - 1,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device espt_nor_flash_device = {
-	.name = "physmap-flash",
-	.resource = espt_nor_flash_resources,
-	.num_resources = ARRAY_SIZE(espt_nor_flash_resources),
-	.dev = {
-		.platform_data = &espt_nor_flash_data,
-	},
-};
-
-/* SH-Ether */
-static struct resource sh_eth_resources[] = {
-	{
-		.start  = 0xFEE00800,   /* use eth1 */
-		.end    = 0xFEE00F7C - 1,
-		.flags  = IORESOURCE_MEM,
-	}, {
-		.start  = 0xFEE01800,   /* TSU */
-		.end    = 0xFEE01FFF,
-		.flags  = IORESOURCE_MEM,
-	}, {
-
-		.start  = evt2irq(0x920),   /* irq number */
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct sh_eth_plat_data sh7763_eth_pdata = {
-	.phy = 0,
-	.phy_interface = PHY_INTERFACE_MODE_MII,
-};
-
-static struct platform_device espt_eth_device = {
-	.name       = "sh7763-gether",
-	.resource   = sh_eth_resources,
-	.num_resources  = ARRAY_SIZE(sh_eth_resources),
-	.dev        = {
-		.platform_data = &sh7763_eth_pdata,
-	},
-};
-
-static struct platform_device *espt_devices[] __initdata = {
-	&espt_nor_flash_device,
-	&espt_eth_device,
-};
-
-static int __init espt_devices_setup(void)
-{
-	return platform_add_devices(espt_devices,
-				    ARRAY_SIZE(espt_devices));
-}
-device_initcall(espt_devices_setup);
-
-static struct sh_machine_vector mv_espt __initmv = {
-	.mv_name = "ESPT-GIGA",
-};
diff --git a/arch/sh/boards/board-magicpanelr2.c b/arch/sh/boards/board-magicpanelr2.c
deleted file mode 100644
index 56bd386ff3b043..00000000000000
--- a/arch/sh/boards/board-magicpanelr2.c
+++ /dev/null
@@ -1,390 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/magicpanel/setup.c
- *
- *  Copyright (C) 2007  Markus Brunner, Mark Jonas
- *
- *  Magic Panel Release 2 board setup
- */
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/regulator/fixed.h>
-#include <linux/regulator/machine.h>
-#include <linux/smsc911x.h>
-#include <linux/mtd/mtd.h>
-#include <linux/mtd/partitions.h>
-#include <linux/mtd/physmap.h>
-#include <linux/mtd/map.h>
-#include <linux/sh_intc.h>
-#include <mach/magicpanelr2.h>
-#include <asm/heartbeat.h>
-#include <cpu/sh7720.h>
-
-/* Dummy supplies, where voltage doesn't matter */
-static struct regulator_consumer_supply dummy_supplies[] = {
-	REGULATOR_SUPPLY("vddvario", "smsc911x"),
-	REGULATOR_SUPPLY("vdd33a", "smsc911x"),
-};
-
-#define LAN9115_READY	(__raw_readl(0xA8000084UL) & 0x00000001UL)
-
-/* Wait until reset finished. Timeout is 100ms. */
-static int __init ethernet_reset_finished(void)
-{
-	int i;
-
-	if (LAN9115_READY)
-		return 1;
-
-	for (i = 0; i < 10; ++i) {
-		mdelay(10);
-		if (LAN9115_READY)
-			return 1;
-	}
-
-	return 0;
-}
-
-static void __init reset_ethernet(void)
-{
-	/* PMDR: LAN_RESET=on */
-	CLRBITS_OUTB(0x10, PORT_PMDR);
-
-	udelay(200);
-
-	/* PMDR: LAN_RESET=off */
-	SETBITS_OUTB(0x10, PORT_PMDR);
-}
-
-static void __init setup_chip_select(void)
-{
-	/* CS2: LAN (0x08000000 - 0x0bffffff) */
-	/* no idle cycles, normal space, 8 bit data bus */
-	__raw_writel(0x36db0400, CS2BCR);
-	/* (SW:1.5 WR:3 HW:1.5), ext. wait */
-	__raw_writel(0x000003c0, CS2WCR);
-
-	/* CS4: CAN1 (0xb0000000 - 0xb3ffffff) */
-	/* no idle cycles, normal space, 8 bit data bus */
-	__raw_writel(0x00000200, CS4BCR);
-	/* (SW:1.5 WR:3 HW:1.5), ext. wait */
-	__raw_writel(0x00100981, CS4WCR);
-
-	/* CS5a: CAN2 (0xb4000000 - 0xb5ffffff) */
-	/* no idle cycles, normal space, 8 bit data bus */
-	__raw_writel(0x00000200, CS5ABCR);
-	/* (SW:1.5 WR:3 HW:1.5), ext. wait */
-	__raw_writel(0x00100981, CS5AWCR);
-
-	/* CS5b: CAN3 (0xb6000000 - 0xb7ffffff) */
-	/* no idle cycles, normal space, 8 bit data bus */
-	__raw_writel(0x00000200, CS5BBCR);
-	/* (SW:1.5 WR:3 HW:1.5), ext. wait */
-	__raw_writel(0x00100981, CS5BWCR);
-
-	/* CS6a: Rotary (0xb8000000 - 0xb9ffffff) */
-	/* no idle cycles, normal space, 8 bit data bus */
-	__raw_writel(0x00000200, CS6ABCR);
-	/* (SW:1.5 WR:3 HW:1.5), no ext. wait */
-	__raw_writel(0x001009C1, CS6AWCR);
-}
-
-static void __init setup_port_multiplexing(void)
-{
-	/* A7 GPO(LED8);     A6 GPO(LED7);     A5 GPO(LED6);	  A4 GPO(LED5);
-	 * A3 GPO(LED4);     A2 GPO(LED3);     A1 GPO(LED2);	  A0 GPO(LED1);
-	 */
-	__raw_writew(0x5555, PORT_PACR);	/* 01 01 01 01 01 01 01 01 */
-
-	/* B7 GPO(RST4);   B6 GPO(RST3);  B5 GPO(RST2);    B4 GPO(RST1);
-	 * B3 GPO(PB3);	   B2 GPO(PB2);	  B1 GPO(PB1);	   B0 GPO(PB0);
-	 */
-	__raw_writew(0x5555, PORT_PBCR);	/* 01 01 01 01 01 01 01 01 */
-
-	/* C7 GPO(PC7);	  C6 GPO(PC6);	  C5 GPO(PC5);	   C4 GPO(PC4);
-	 * C3 LCD_DATA3;  C2 LCD_DATA2;   C1 LCD_DATA1;	   C0 LCD_DATA0;
-	 */
-	__raw_writew(0x5500, PORT_PCCR);	/* 01 01 01 01 00 00 00 00 */
-
-	/* D7 GPO(PD7);	D6 GPO(PD6);	D5 GPO(PD5);	   D4 GPO(PD4);
-	 * D3 GPO(PD3);	D2 GPO(PD2);	D1 GPO(PD1);	   D0 GPO(PD0);
-	 */
-	__raw_writew(0x5555, PORT_PDCR);	/* 01 01 01 01 01 01 01 01 */
-
-	/* E7 (x);	  E6 GPI(nu);	 E5 GPI(nu);	  E4 LCD_M_DISP;
-	 * E3 LCD_CL1;	  E2 LCD_CL2;	 E1 LCD_DON;	  E0 LCD_FLM;
-	 */
-	__raw_writew(0x3C00, PORT_PECR);	/* 00 11 11 00 00 00 00 00 */
-
-	/* F7 (x);	     F6 DA1(VLCD);     F5 DA0(nc);	  F4 AN3;
-	 * F3 AN2(MID_AD);   F2 AN1(EARTH_AD); F1 AN0(TEMP);	  F0 GPI+(nc);
-	 */
-	__raw_writew(0x0002, PORT_PFCR);	/* 00 00 00 00 00 00 00 10 */
-
-	/* G7 (x);	  G6 IRQ5(TOUCH_BUSY); G5 IRQ4(TOUCH_IRQ); G4 GPI(KEY2);
-	 * G3 GPI(KEY1);  G2 GPO(LED11);	G1 GPO(LED10);     G0 GPO(LED9);
-	 */
-	__raw_writew(0x03D5, PORT_PGCR);	/* 00 00 00 11 11 01 01 01 */
-
-	/* H7 (x);	      H6 /RAS(BRAS);	  H5 /CAS(BCAS); H4 CKE(BCKE);
-	 * H3 GPO(EARTH_OFF); H2 GPO(EARTH_TEST); H1 USB2_PWR;	 H0 USB1_PWR;
-	 */
-	__raw_writew(0x0050, PORT_PHCR);	/* 00 00 00 00 01 01 00 00 */
-
-	/* J7 (x);	  J6 AUDCK;	   J5 ASEBRKAK;	    J4 AUDATA3;
-	 * J3 AUDATA2;	  J2 AUDATA1;	   J1 AUDATA0;	    J0 AUDSYNC;
-	 */
-	__raw_writew(0x0000, PORT_PJCR);	/* 00 00 00 00 00 00 00 00 */
-
-	/* K7 (x);	    K6 (x);	     K5 (x);	   K4 (x);
-	 * K3 PINT7(/PWR2); K2 PINT6(/PWR1); K1 PINT5(nu); K0 PINT4(FLASH_READY)
-	 */
-	__raw_writew(0x00FF, PORT_PKCR);	/* 00 00 00 00 11 11 11 11 */
-
-	/* L7 TRST;	   L6 TMS;	     L5 TDO;		  L4 TDI;
-	 * L3 TCK;	   L2 (x);	     L1 (x);		  L0 (x);
-	 */
-	__raw_writew(0x0000, PORT_PLCR);	/* 00 00 00 00 00 00 00 00 */
-
-	/* M7 GPO(CURRENT_SINK);    M6 GPO(PWR_SWITCH);     M5 GPO(LAN_SPEED);
-	 * M4 GPO(LAN_RESET);       M3 GPO(BUZZER);	    M2 GPO(LCD_BL);
-	 * M1 CS5B(CAN3_CS);	    M0 GPI+(nc);
-	 */
-	__raw_writew(0x5552, PORT_PMCR);	   /* 01 01 01 01 01 01 00 10 */
-
-	/* CURRENT_SINK=off,	PWR_SWITCH=off, LAN_SPEED=100MBit,
-	 * LAN_RESET=off,	BUZZER=off,	LCD_BL=off
-	 */
-#if CONFIG_SH_MAGIC_PANEL_R2_VERSION == 2
-	__raw_writeb(0x30, PORT_PMDR);
-#elif CONFIG_SH_MAGIC_PANEL_R2_VERSION == 3
-	__raw_writeb(0xF0, PORT_PMDR);
-#else
-#error Unknown revision of PLATFORM_MP_R2
-#endif
-
-	/* P7 (x);	       P6 (x);		  P5 (x);
-	 * P4 GPO(nu);	       P3 IRQ3(LAN_IRQ);  P2 IRQ2(CAN3_IRQ);
-	 * P1 IRQ1(CAN2_IRQ);  P0 IRQ0(CAN1_IRQ)
-	 */
-	__raw_writew(0x0100, PORT_PPCR);	/* 00 00 00 01 00 00 00 00 */
-	__raw_writeb(0x10, PORT_PPDR);
-
-	/* R7 A25;	     R6 A24;	     R5 A23;		  R4 A22;
-	 * R3 A21;	     R2 A20;	     R1 A19;		  R0 A0;
-	 */
-	gpio_request(GPIO_FN_A25, NULL);
-	gpio_request(GPIO_FN_A24, NULL);
-	gpio_request(GPIO_FN_A23, NULL);
-	gpio_request(GPIO_FN_A22, NULL);
-	gpio_request(GPIO_FN_A21, NULL);
-	gpio_request(GPIO_FN_A20, NULL);
-	gpio_request(GPIO_FN_A19, NULL);
-	gpio_request(GPIO_FN_A0, NULL);
-
-	/* S7 (x);		S6 (x);        S5 (x);	     S4 GPO(EEPROM_CS2);
-	 * S3 GPO(EEPROM_CS1);  S2 SIOF0_TXD;  S1 SIOF0_RXD; S0 SIOF0_SCK;
-	 */
-	__raw_writew(0x0140, PORT_PSCR);	/* 00 00 00 01 01 00 00 00 */
-
-	/* T7 (x);	   T6 (x);	  T5 (x);	  T4 COM1_CTS;
-	 * T3 COM1_RTS;	   T2 COM1_TXD;	  T1 COM1_RXD;	  T0 GPO(WDOG)
-	 */
-	__raw_writew(0x0001, PORT_PTCR);	/* 00 00 00 00 00 00 00 01 */
-
-	/* U7 (x);	     U6 (x);	   U5 (x);	  U4 GPI+(/AC_FAULT);
-	 * U3 GPO(TOUCH_CS); U2 TOUCH_TXD; U1 TOUCH_RXD;  U0 TOUCH_SCK;
-	 */
-	__raw_writew(0x0240, PORT_PUCR);	/* 00 00 00 10 01 00 00 00 */
-
-	/* V7 (x);	  V6 (x);	V5 (x);		  V4 GPO(MID2);
-	 * V3 GPO(MID1);  V2 CARD_TxD;	V1 CARD_RxD;	  V0 GPI+(/BAT_FAULT);
-	 */
-	__raw_writew(0x0142, PORT_PVCR);	/* 00 00 00 01 01 00 00 10 */
-}
-
-static void __init mpr2_setup(char **cmdline_p)
-{
-	/* set Pin Select Register A:
-	 * /PCC_CD1, /PCC_CD2,  PCC_BVD1, PCC_BVD2,
-	 * /IOIS16,  IRQ4,	IRQ5,	  USB1d_SUSPEND
-	 */
-	__raw_writew(0xAABC, PORT_PSELA);
-	/* set Pin Select Register B:
-	 * /SCIF0_RTS, /SCIF0_CTS, LCD_VCPWC,
-	 * LCD_VEPWC,  IIC_SDA,    IIC_SCL, Reserved
-	 */
-	__raw_writew(0x3C00, PORT_PSELB);
-	/* set Pin Select Register C:
-	 * SIOF1_SCK, SIOF1_RxD, SCIF1_RxD, SCIF1_TxD, Reserved
-	 */
-	__raw_writew(0x0000, PORT_PSELC);
-	/* set Pin Select Register D: Reserved, SIOF1_TxD, Reserved, SIOF1_MCLK,
-	 * Reserved, SIOF1_SYNC, Reserved, SCIF1_SCK, Reserved
-	 */
-	__raw_writew(0x0000, PORT_PSELD);
-	/* set USB TxRx Control: Reserved, DRV, Reserved, USB_TRANS, USB_SEL */
-	__raw_writew(0x0101, PORT_UTRCTL);
-	/* set USB Clock Control: USSCS, USSTB, Reserved (HighByte always A5) */
-	__raw_writew(0xA5C0, PORT_UCLKCR_W);
-
-	setup_chip_select();
-
-	setup_port_multiplexing();
-
-	reset_ethernet();
-
-	printk(KERN_INFO "Magic Panel Release 2 A.%i\n",
-				CONFIG_SH_MAGIC_PANEL_R2_VERSION);
-
-	if (ethernet_reset_finished() == 0)
-		printk(KERN_WARNING "Ethernet not ready\n");
-}
-
-static struct resource smsc911x_resources[] = {
-	[0] = {
-		.start		= 0xa8000000,
-		.end		= 0xabffffff,
-		.flags		= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start		= evt2irq(0x660),
-		.end		= evt2irq(0x660),
-		.flags		= IORESOURCE_IRQ,
-	},
-};
-
-static struct smsc911x_platform_config smsc911x_config = {
-	.phy_interface	= PHY_INTERFACE_MODE_MII,
-	.irq_polarity	= SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
-	.irq_type	= SMSC911X_IRQ_TYPE_OPEN_DRAIN,
-	.flags		= SMSC911X_USE_32BIT,
-};
-
-static struct platform_device smsc911x_device = {
-	.name		= "smsc911x",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(smsc911x_resources),
-	.resource	= smsc911x_resources,
-	.dev = {
-		.platform_data = &smsc911x_config,
-	},
-};
-
-static struct resource heartbeat_resources[] = {
-	[0] = {
-		.start	= PA_LED,
-		.end	= PA_LED,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct heartbeat_data heartbeat_data = {
-	.flags		= HEARTBEAT_INVERTED,
-};
-
-static struct platform_device heartbeat_device = {
-	.name		= "heartbeat",
-	.id		= -1,
-	.dev	= {
-		.platform_data	= &heartbeat_data,
-	},
-	.num_resources	= ARRAY_SIZE(heartbeat_resources),
-	.resource	= heartbeat_resources,
-};
-
-static struct mtd_partition mpr2_partitions[] = {
-	/* Reserved for bootloader, read-only */
-	{
-		.name = "Bootloader",
-		.offset = 0x00000000UL,
-		.size = MPR2_MTD_BOOTLOADER_SIZE,
-		.mask_flags = MTD_WRITEABLE,
-	},
-	/* Reserved for kernel image */
-	{
-		.name = "Kernel",
-		.offset = MTDPART_OFS_NXTBLK,
-		.size = MPR2_MTD_KERNEL_SIZE,
-	},
-	/* Rest is used for Flash FS */
-	{
-		.name = "Flash_FS",
-		.offset = MTDPART_OFS_NXTBLK,
-		.size = MTDPART_SIZ_FULL,
-	}
-};
-
-static struct physmap_flash_data flash_data = {
-	.parts		= mpr2_partitions,
-	.nr_parts	= ARRAY_SIZE(mpr2_partitions),
-	.width		= 2,
-};
-
-static struct resource flash_resource = {
-	.start		= 0x00000000,
-	.end		= 0x2000000UL,
-	.flags		= IORESOURCE_MEM,
-};
-
-static struct platform_device flash_device = {
-	.name		= "physmap-flash",
-	.id		= -1,
-	.resource	= &flash_resource,
-	.num_resources	= 1,
-	.dev		= {
-		.platform_data = &flash_data,
-	},
-};
-
-/*
- * Add all resources to the platform_device
- */
-
-static struct platform_device *mpr2_devices[] __initdata = {
-	&heartbeat_device,
-	&smsc911x_device,
-	&flash_device,
-};
-
-
-static int __init mpr2_devices_setup(void)
-{
-	regulator_register_fixed(0, dummy_supplies, ARRAY_SIZE(dummy_supplies));
-
-	return platform_add_devices(mpr2_devices, ARRAY_SIZE(mpr2_devices));
-}
-device_initcall(mpr2_devices_setup);
-
-/*
- * Initialize IRQ setting
- */
-static void __init init_mpr2_IRQ(void)
-{
-	plat_irq_setup_pins(IRQ_MODE_IRQ); /* install handlers for IRQ0-5 */
-
-	irq_set_irq_type(evt2irq(0x600), IRQ_TYPE_LEVEL_LOW);    /* IRQ0 CAN1 */
-	irq_set_irq_type(evt2irq(0x620), IRQ_TYPE_LEVEL_LOW);    /* IRQ1 CAN2 */
-	irq_set_irq_type(evt2irq(0x640), IRQ_TYPE_LEVEL_LOW);    /* IRQ2 CAN3 */
-	irq_set_irq_type(evt2irq(0x660), IRQ_TYPE_LEVEL_LOW);    /* IRQ3 SMSC9115 */
-	irq_set_irq_type(evt2irq(0x680), IRQ_TYPE_EDGE_RISING);  /* IRQ4 touchscreen */
-	irq_set_irq_type(evt2irq(0x6a0), IRQ_TYPE_EDGE_FALLING); /* IRQ5 touchscreen */
-
-	intc_set_priority(evt2irq(0x600), 13);		/* IRQ0 CAN1 */
-	intc_set_priority(evt2irq(0x620), 13);		/* IRQ0 CAN2 */
-	intc_set_priority(evt2irq(0x640), 13);		/* IRQ0 CAN3 */
-	intc_set_priority(evt2irq(0x660), 6);		/* IRQ3 SMSC9115 */
-}
-
-/*
- * The Machine Vector
- */
-
-static struct sh_machine_vector mv_mpr2 __initmv = {
-	.mv_name		= "mpr2",
-	.mv_setup		= mpr2_setup,
-	.mv_init_irq		= init_mpr2_IRQ,
-};
diff --git a/arch/sh/boards/board-polaris.c b/arch/sh/boards/board-polaris.c
deleted file mode 100644
index 3de7bac0190392..00000000000000
--- a/arch/sh/boards/board-polaris.c
+++ /dev/null
@@ -1,156 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * June 2006 Steve Glendinning <steve.glendinning@shawell.net>
- *
- * Polaris-specific resource declaration
- *
- */
-
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/platform_device.h>
-#include <linux/regulator/fixed.h>
-#include <linux/regulator/machine.h>
-#include <linux/smsc911x.h>
-#include <linux/io.h>
-#include <asm/irq.h>
-#include <asm/machvec.h>
-#include <asm/heartbeat.h>
-#include <cpu/gpio.h>
-#include <mach-se/mach/se.h>
-
-#define BCR2		(0xFFFFFF62)
-#define WCR2		(0xFFFFFF66)
-#define AREA5_WAIT_CTRL	(0x1C00)
-#define WAIT_STATES_10	(0x7)
-
-/* Dummy supplies, where voltage doesn't matter */
-static struct regulator_consumer_supply dummy_supplies[] = {
-	REGULATOR_SUPPLY("vddvario", "smsc911x.0"),
-	REGULATOR_SUPPLY("vdd33a", "smsc911x.0"),
-};
-
-static struct resource smsc911x_resources[] = {
-	[0] = {
-		.name		= "smsc911x-memory",
-		.start		= PA_EXT5,
-		.end		= PA_EXT5 + 0x1fff,
-		.flags		= IORESOURCE_MEM,
-	},
-	[1] = {
-		.name		= "smsc911x-irq",
-		.start		= IRQ0_IRQ,
-		.end		= IRQ0_IRQ,
-		.flags		= IORESOURCE_IRQ,
-	},
-};
-
-static struct smsc911x_platform_config smsc911x_config = {
-	.irq_polarity	= SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
-	.irq_type	= SMSC911X_IRQ_TYPE_OPEN_DRAIN,
-	.flags		= SMSC911X_USE_32BIT,
-	.phy_interface	= PHY_INTERFACE_MODE_MII,
-};
-
-static struct platform_device smsc911x_device = {
-	.name		= "smsc911x",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(smsc911x_resources),
-	.resource	= smsc911x_resources,
-	.dev = {
-		.platform_data = &smsc911x_config,
-	},
-};
-
-static unsigned char heartbeat_bit_pos[] = { 0, 1, 2, 3 };
-
-static struct heartbeat_data heartbeat_data = {
-	.bit_pos	= heartbeat_bit_pos,
-	.nr_bits	= ARRAY_SIZE(heartbeat_bit_pos),
-};
-
-static struct resource heartbeat_resource = {
-	.start	= PORT_PCDR,
-	.end	= PORT_PCDR,
-	.flags	= IORESOURCE_MEM | IORESOURCE_MEM_8BIT,
-};
-
-static struct platform_device heartbeat_device = {
-	.name		= "heartbeat",
-	.id		= -1,
-	.dev	= {
-		.platform_data	= &heartbeat_data,
-	},
-	.num_resources	= 1,
-	.resource	= &heartbeat_resource,
-};
-
-static struct platform_device *polaris_devices[] __initdata = {
-	&smsc911x_device,
-	&heartbeat_device,
-};
-
-static int __init polaris_initialise(void)
-{
-	u16 wcr, bcr_mask;
-
-	printk(KERN_INFO "Configuring Polaris external bus\n");
-
-	regulator_register_fixed(0, dummy_supplies, ARRAY_SIZE(dummy_supplies));
-
-	/* Configure area 5 with 2 wait states */
-	wcr = __raw_readw(WCR2);
-	wcr &= (~AREA5_WAIT_CTRL);
-	wcr |= (WAIT_STATES_10 << 10);
-	__raw_writew(wcr, WCR2);
-
-	/* Configure area 5 for 32-bit access */
-	bcr_mask = __raw_readw(BCR2);
-	bcr_mask |= 1 << 10;
-	__raw_writew(bcr_mask, BCR2);
-
-	return platform_add_devices(polaris_devices,
-				    ARRAY_SIZE(polaris_devices));
-}
-arch_initcall(polaris_initialise);
-
-static struct ipr_data ipr_irq_table[] = {
-	/* External IRQs */
-	{ IRQ0_IRQ, 0,  0,  1, },	/* IRQ0 */
-	{ IRQ1_IRQ, 0,  4,  1, },	/* IRQ1 */
-};
-
-static unsigned long ipr_offsets[] = {
-	INTC_IPRC
-};
-
-static struct ipr_desc ipr_irq_desc = {
-	.ipr_offsets	= ipr_offsets,
-	.nr_offsets	= ARRAY_SIZE(ipr_offsets),
-
-	.ipr_data	= ipr_irq_table,
-	.nr_irqs	= ARRAY_SIZE(ipr_irq_table),
-	.chip = {
-		.name	= "sh7709-ext",
-	},
-};
-
-static void __init init_polaris_irq(void)
-{
-	/* Disable all interrupts */
-	__raw_writew(0, BCR_ILCRA);
-	__raw_writew(0, BCR_ILCRB);
-	__raw_writew(0, BCR_ILCRC);
-	__raw_writew(0, BCR_ILCRD);
-	__raw_writew(0, BCR_ILCRE);
-	__raw_writew(0, BCR_ILCRF);
-	__raw_writew(0, BCR_ILCRG);
-
-	register_ipr_controller(&ipr_irq_desc);
-}
-
-static struct sh_machine_vector mv_polaris __initmv = {
-	.mv_name		= "Polaris",
-	.mv_init_irq		= init_polaris_irq,
-};
diff --git a/arch/sh/boards/board-secureedge5410.c b/arch/sh/boards/board-secureedge5410.c
deleted file mode 100644
index 603a82325c65f0..00000000000000
--- a/arch/sh/boards/board-secureedge5410.c
+++ /dev/null
@@ -1,75 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (C) 2002  David McCullough <davidm@snapgear.com>
- * Copyright (C) 2003  Paul Mundt <lethal@linux-sh.org>
- *
- * Based on files with the following comments:
- *
- *           Copyright (C) 2000  Kazumoto Kojima
- *
- *           Modified for 7751 Solution Engine by
- *           Ian da Silva and Jeremy Siegel, 2001.
- */
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <linux/timer.h>
-#include <linux/delay.h>
-#include <linux/sched.h>
-#include <asm/machvec.h>
-#include <mach/secureedge5410.h>
-#include <asm/irq.h>
-#include <asm/io.h>
-#include <cpu/timer.h>
-
-unsigned short secureedge5410_ioport;
-
-/*
- * EraseConfig handling functions
- */
-static irqreturn_t eraseconfig_interrupt(int irq, void *dev_id)
-{
-	printk("SnapGear: erase switch interrupt!\n");
-
-	return IRQ_HANDLED;
-}
-
-static int __init eraseconfig_init(void)
-{
-	unsigned int irq = evt2irq(0x240);
-
-	printk("SnapGear: EraseConfig init\n");
-
-	/* Setup "EraseConfig" switch on external IRQ 0 */
-	if (request_irq(irq, eraseconfig_interrupt, 0, "Erase Config", NULL))
-		printk("SnapGear: failed to register IRQ%d for Reset witch\n",
-				irq);
-	else
-		printk("SnapGear: registered EraseConfig switch on IRQ%d\n",
-				irq);
-	return 0;
-}
-device_initcall(eraseconfig_init);
-
-/*
- * Initialize IRQ setting
- *
- * IRL0 = erase switch
- * IRL1 = eth0
- * IRL2 = eth1
- * IRL3 = crypto
- */
-static void __init init_snapgear_IRQ(void)
-{
-	printk("Setup SnapGear IRQ/IPR ...\n");
-	/* enable individual interrupt mode for externals */
-	plat_irq_setup_pins(IRQ_MODE_IRQ);
-}
-
-/*
- * The Machine Vector
- */
-static struct sh_machine_vector mv_snapgear __initmv = {
-	.mv_name		= "SnapGear SecureEdge5410",
-	.mv_init_irq		= init_snapgear_IRQ,
-};
diff --git a/arch/sh/boards/board-sh2007.c b/arch/sh/boards/board-sh2007.c
deleted file mode 100644
index 6ea85e4808512f..00000000000000
--- a/arch/sh/boards/board-sh2007.c
+++ /dev/null
@@ -1,146 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH-2007 board support.
- *
- * Copyright (C) 2003, 2004  SUGIOKA Toshinobu
- * Copyright (C) 2010  Hitoshi Mitake <mitake@dcl.info.waseda.ac.jp>
- */
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/regulator/fixed.h>
-#include <linux/regulator/machine.h>
-#include <linux/smsc911x.h>
-#include <linux/platform_device.h>
-#include <linux/ata_platform.h>
-#include <linux/io.h>
-#include <asm/machvec.h>
-#include <mach/sh2007.h>
-
-/* Dummy supplies, where voltage doesn't matter */
-static struct regulator_consumer_supply dummy_supplies[] = {
-	REGULATOR_SUPPLY("vddvario", "smsc911x.0"),
-	REGULATOR_SUPPLY("vdd33a", "smsc911x.0"),
-	REGULATOR_SUPPLY("vddvario", "smsc911x.1"),
-	REGULATOR_SUPPLY("vdd33a", "smsc911x.1"),
-};
-
-struct smsc911x_platform_config smc911x_info = {
-	.flags		= SMSC911X_USE_32BIT,
-	.irq_polarity	= SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
-	.irq_type	= SMSC911X_IRQ_TYPE_PUSH_PULL,
-};
-
-static struct resource smsc9118_0_resources[] = {
-	[0] = {
-		.start	= SMC0_BASE,
-		.end	= SMC0_BASE + 0xff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0x240),
-		.end	= evt2irq(0x240),
-		.flags	= IORESOURCE_IRQ,
-	}
-};
-
-static struct resource smsc9118_1_resources[] = {
-	[0] = {
-		.start	= SMC1_BASE,
-		.end	= SMC1_BASE + 0xff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0x280),
-		.end	= evt2irq(0x280),
-		.flags	= IORESOURCE_IRQ,
-	}
-};
-
-static struct platform_device smsc9118_0_device = {
-	.name		= "smsc911x",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(smsc9118_0_resources),
-	.resource	= smsc9118_0_resources,
-	.dev = {
-		.platform_data = &smc911x_info,
-	},
-};
-
-static struct platform_device smsc9118_1_device = {
-	.name		= "smsc911x",
-	.id		= 1,
-	.num_resources	= ARRAY_SIZE(smsc9118_1_resources),
-	.resource	= smsc9118_1_resources,
-	.dev = {
-		.platform_data = &smc911x_info,
-	},
-};
-
-static struct resource cf_resources[] = {
-	[0] = {
-		.start	= CF_BASE + CF_OFFSET,
-		.end	= CF_BASE + CF_OFFSET + 0x0f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= CF_BASE + CF_OFFSET + 0x206,
-		.end	= CF_BASE + CF_OFFSET + 0x20f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[2] = {
-		.start	= evt2irq(0x2c0),
-		.end	= evt2irq(0x2c0),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device cf_device  = {
-	.name		= "pata_platform",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(cf_resources),
-	.resource	= cf_resources,
-};
-
-static struct platform_device *sh2007_devices[] __initdata = {
-	&smsc9118_0_device,
-	&smsc9118_1_device,
-	&cf_device,
-};
-
-static int __init sh2007_io_init(void)
-{
-	regulator_register_fixed(0, dummy_supplies, ARRAY_SIZE(dummy_supplies));
-
-	platform_add_devices(sh2007_devices, ARRAY_SIZE(sh2007_devices));
-	return 0;
-}
-subsys_initcall(sh2007_io_init);
-
-static void __init sh2007_init_irq(void)
-{
-	plat_irq_setup_pins(IRQ_MODE_IRQ);
-}
-
-/*
- * Initialize the board
- */
-static void __init sh2007_setup(char **cmdline_p)
-{
-	pr_info("SH-2007 Setup...");
-
-	/* setup wait control registers for area 5 */
-	__raw_writel(CS5BCR_D, CS5BCR);
-	__raw_writel(CS5WCR_D, CS5WCR);
-	__raw_writel(CS5PCR_D, CS5PCR);
-
-	pr_cont(" done.\n");
-}
-
-/*
- * The Machine Vector
- */
-struct sh_machine_vector mv_sh2007 __initmv = {
-	.mv_setup		= sh2007_setup,
-	.mv_name		= "sh2007",
-	.mv_init_irq		= sh2007_init_irq,
-};
diff --git a/arch/sh/boards/board-sh7757lcr.c b/arch/sh/boards/board-sh7757lcr.c
deleted file mode 100644
index f39c8196efdfd1..00000000000000
--- a/arch/sh/boards/board-sh7757lcr.c
+++ /dev/null
@@ -1,604 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Renesas R0P7757LC0012RL Support.
- *
- * Copyright (C) 2009 - 2010  Renesas Solutions Corp.
- */
-
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/gpio.h>
-#include <linux/irq.h>
-#include <linux/regulator/fixed.h>
-#include <linux/regulator/machine.h>
-#include <linux/spi/spi.h>
-#include <linux/spi/flash.h>
-#include <linux/io.h>
-#include <linux/mfd/tmio.h>
-#include <linux/mmc/host.h>
-#include <linux/platform_data/sh_mmcif.h>
-#include <linux/sh_eth.h>
-#include <linux/sh_intc.h>
-#include <linux/usb/renesas_usbhs.h>
-#include <cpu/sh7757.h>
-#include <asm/heartbeat.h>
-
-static struct resource heartbeat_resource = {
-	.start	= 0xffec005c,	/* PUDR */
-	.end	= 0xffec005c,
-	.flags	= IORESOURCE_MEM | IORESOURCE_MEM_8BIT,
-};
-
-static unsigned char heartbeat_bit_pos[] = { 0, 1, 2, 3 };
-
-static struct heartbeat_data heartbeat_data = {
-	.bit_pos	= heartbeat_bit_pos,
-	.nr_bits	= ARRAY_SIZE(heartbeat_bit_pos),
-	.flags		= HEARTBEAT_INVERTED,
-};
-
-static struct platform_device heartbeat_device = {
-	.name		= "heartbeat",
-	.id		= -1,
-	.dev	= {
-		.platform_data	= &heartbeat_data,
-	},
-	.num_resources	= 1,
-	.resource	= &heartbeat_resource,
-};
-
-/* Fast Ethernet */
-#define GBECONT		0xffc10100
-#define GBECONT_RMII1	BIT(17)
-#define GBECONT_RMII0	BIT(16)
-static void sh7757_eth_set_mdio_gate(void *addr)
-{
-	if (((unsigned long)addr & 0x00000fff) < 0x0800)
-		writel(readl(GBECONT) | GBECONT_RMII0, GBECONT);
-	else
-		writel(readl(GBECONT) | GBECONT_RMII1, GBECONT);
-}
-
-static struct resource sh_eth0_resources[] = {
-	{
-		.start  = 0xfef00000,
-		.end    = 0xfef001ff,
-		.flags  = IORESOURCE_MEM,
-	}, {
-		.start  = evt2irq(0xc80),
-		.end    = evt2irq(0xc80),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct sh_eth_plat_data sh7757_eth0_pdata = {
-	.phy = 1,
-	.set_mdio_gate = sh7757_eth_set_mdio_gate,
-};
-
-static struct platform_device sh7757_eth0_device = {
-	.name		= "sh7757-ether",
-	.resource	= sh_eth0_resources,
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(sh_eth0_resources),
-	.dev		= {
-		.platform_data = &sh7757_eth0_pdata,
-	},
-};
-
-static struct resource sh_eth1_resources[] = {
-	{
-		.start  = 0xfef00800,
-		.end    = 0xfef009ff,
-		.flags  = IORESOURCE_MEM,
-	}, {
-		.start  = evt2irq(0xc80),
-		.end    = evt2irq(0xc80),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct sh_eth_plat_data sh7757_eth1_pdata = {
-	.phy = 1,
-	.set_mdio_gate = sh7757_eth_set_mdio_gate,
-};
-
-static struct platform_device sh7757_eth1_device = {
-	.name		= "sh7757-ether",
-	.resource	= sh_eth1_resources,
-	.id		= 1,
-	.num_resources	= ARRAY_SIZE(sh_eth1_resources),
-	.dev		= {
-		.platform_data = &sh7757_eth1_pdata,
-	},
-};
-
-static void sh7757_eth_giga_set_mdio_gate(void *addr)
-{
-	if (((unsigned long)addr & 0x00000fff) < 0x0800) {
-		gpio_set_value(GPIO_PTT4, 1);
-		writel(readl(GBECONT) & ~GBECONT_RMII0, GBECONT);
-	} else {
-		gpio_set_value(GPIO_PTT4, 0);
-		writel(readl(GBECONT) & ~GBECONT_RMII1, GBECONT);
-	}
-}
-
-static struct resource sh_eth_giga0_resources[] = {
-	{
-		.start  = 0xfee00000,
-		.end    = 0xfee007ff,
-		.flags  = IORESOURCE_MEM,
-	}, {
-		/* TSU */
-		.start  = 0xfee01800,
-		.end    = 0xfee01fff,
-		.flags  = IORESOURCE_MEM,
-	}, {
-		.start  = evt2irq(0x2960),
-		.end    = evt2irq(0x2960),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct sh_eth_plat_data sh7757_eth_giga0_pdata = {
-	.phy = 18,
-	.set_mdio_gate = sh7757_eth_giga_set_mdio_gate,
-	.phy_interface = PHY_INTERFACE_MODE_RGMII_ID,
-};
-
-static struct platform_device sh7757_eth_giga0_device = {
-	.name		= "sh7757-gether",
-	.resource	= sh_eth_giga0_resources,
-	.id		= 2,
-	.num_resources	= ARRAY_SIZE(sh_eth_giga0_resources),
-	.dev		= {
-		.platform_data = &sh7757_eth_giga0_pdata,
-	},
-};
-
-static struct resource sh_eth_giga1_resources[] = {
-	{
-		.start  = 0xfee00800,
-		.end    = 0xfee00fff,
-		.flags  = IORESOURCE_MEM,
-	}, {
-		/* TSU */
-		.start  = 0xfee01800,
-		.end    = 0xfee01fff,
-		.flags  = IORESOURCE_MEM,
-	}, {
-		.start  = evt2irq(0x2980),
-		.end    = evt2irq(0x2980),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct sh_eth_plat_data sh7757_eth_giga1_pdata = {
-	.phy = 19,
-	.set_mdio_gate = sh7757_eth_giga_set_mdio_gate,
-	.phy_interface = PHY_INTERFACE_MODE_RGMII_ID,
-};
-
-static struct platform_device sh7757_eth_giga1_device = {
-	.name		= "sh7757-gether",
-	.resource	= sh_eth_giga1_resources,
-	.id		= 3,
-	.num_resources	= ARRAY_SIZE(sh_eth_giga1_resources),
-	.dev		= {
-		.platform_data = &sh7757_eth_giga1_pdata,
-	},
-};
-
-/* Fixed 3.3V regulator to be used by SDHI0, MMCIF */
-static struct regulator_consumer_supply fixed3v3_power_consumers[] =
-{
-	REGULATOR_SUPPLY("vmmc", "sh_mobile_sdhi.0"),
-	REGULATOR_SUPPLY("vqmmc", "sh_mobile_sdhi.0"),
-	REGULATOR_SUPPLY("vmmc", "sh_mmcif.0"),
-	REGULATOR_SUPPLY("vqmmc", "sh_mmcif.0"),
-};
-
-/* SH_MMCIF */
-static struct resource sh_mmcif_resources[] = {
-	[0] = {
-		.start	= 0xffcb0000,
-		.end	= 0xffcb00ff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0x1c60),
-		.flags	= IORESOURCE_IRQ,
-	},
-	[2] = {
-		.start	= evt2irq(0x1c80),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct sh_mmcif_plat_data sh_mmcif_plat = {
-	.sup_pclk	= 0x0f,
-	.caps		= MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA |
-			  MMC_CAP_NONREMOVABLE,
-	.ocr		= MMC_VDD_32_33 | MMC_VDD_33_34,
-	.slave_id_tx	= SHDMA_SLAVE_MMCIF_TX,
-	.slave_id_rx	= SHDMA_SLAVE_MMCIF_RX,
-};
-
-static struct platform_device sh_mmcif_device = {
-	.name		= "sh_mmcif",
-	.id		= 0,
-	.dev		= {
-		.platform_data		= &sh_mmcif_plat,
-	},
-	.num_resources	= ARRAY_SIZE(sh_mmcif_resources),
-	.resource	= sh_mmcif_resources,
-};
-
-/* SDHI0 */
-static struct tmio_mmc_data sdhi_info = {
-	.chan_priv_tx	= (void *)SHDMA_SLAVE_SDHI_TX,
-	.chan_priv_rx	= (void *)SHDMA_SLAVE_SDHI_RX,
-	.capabilities	= MMC_CAP_SD_HIGHSPEED,
-};
-
-static struct resource sdhi_resources[] = {
-	[0] = {
-		.start  = 0xffe50000,
-		.end    = 0xffe500ff,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0x480),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device sdhi_device = {
-	.name           = "sh_mobile_sdhi",
-	.num_resources  = ARRAY_SIZE(sdhi_resources),
-	.resource       = sdhi_resources,
-	.id             = 0,
-	.dev	= {
-		.platform_data	= &sdhi_info,
-	},
-};
-
-static int usbhs0_get_id(struct platform_device *pdev)
-{
-	return USBHS_GADGET;
-}
-
-static struct renesas_usbhs_platform_info usb0_data = {
-	.platform_callback = {
-		.get_id = usbhs0_get_id,
-	},
-	.driver_param = {
-		.buswait_bwait = 5,
-	}
-};
-
-static struct resource usb0_resources[] = {
-	[0] = {
-		.start	= 0xfe450000,
-		.end	= 0xfe4501ff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0x840),
-		.end	= evt2irq(0x840),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device usb0_device = {
-	.name		= "renesas_usbhs",
-	.id		= 0,
-	.dev = {
-		.platform_data		= &usb0_data,
-	},
-	.num_resources	= ARRAY_SIZE(usb0_resources),
-	.resource	= usb0_resources,
-};
-
-static struct platform_device *sh7757lcr_devices[] __initdata = {
-	&heartbeat_device,
-	&sh7757_eth0_device,
-	&sh7757_eth1_device,
-	&sh7757_eth_giga0_device,
-	&sh7757_eth_giga1_device,
-	&sh_mmcif_device,
-	&sdhi_device,
-	&usb0_device,
-};
-
-static struct flash_platform_data spi_flash_data = {
-	.name = "m25p80",
-	.type = "m25px64",
-};
-
-static struct spi_board_info spi_board_info[] = {
-	{
-		.modalias = "m25p80",
-		.max_speed_hz = 25000000,
-		.bus_num = 0,
-		.chip_select = 1,
-		.platform_data = &spi_flash_data,
-	},
-};
-
-static int __init sh7757lcr_devices_setup(void)
-{
-	regulator_register_always_on(0, "fixed-3.3V", fixed3v3_power_consumers,
-				     ARRAY_SIZE(fixed3v3_power_consumers), 3300000);
-
-	/* RGMII (PTA) */
-	gpio_request(GPIO_FN_ET0_MDC, NULL);
-	gpio_request(GPIO_FN_ET0_MDIO, NULL);
-	gpio_request(GPIO_FN_ET1_MDC, NULL);
-	gpio_request(GPIO_FN_ET1_MDIO, NULL);
-
-	/* ONFI (PTB, PTZ) */
-	gpio_request(GPIO_FN_ON_NRE, NULL);
-	gpio_request(GPIO_FN_ON_NWE, NULL);
-	gpio_request(GPIO_FN_ON_NWP, NULL);
-	gpio_request(GPIO_FN_ON_NCE0, NULL);
-	gpio_request(GPIO_FN_ON_R_B0, NULL);
-	gpio_request(GPIO_FN_ON_ALE, NULL);
-	gpio_request(GPIO_FN_ON_CLE, NULL);
-
-	gpio_request(GPIO_FN_ON_DQ7, NULL);
-	gpio_request(GPIO_FN_ON_DQ6, NULL);
-	gpio_request(GPIO_FN_ON_DQ5, NULL);
-	gpio_request(GPIO_FN_ON_DQ4, NULL);
-	gpio_request(GPIO_FN_ON_DQ3, NULL);
-	gpio_request(GPIO_FN_ON_DQ2, NULL);
-	gpio_request(GPIO_FN_ON_DQ1, NULL);
-	gpio_request(GPIO_FN_ON_DQ0, NULL);
-
-	/* IRQ8 to 0 (PTB, PTC) */
-	gpio_request(GPIO_FN_IRQ8, NULL);
-	gpio_request(GPIO_FN_IRQ7, NULL);
-	gpio_request(GPIO_FN_IRQ6, NULL);
-	gpio_request(GPIO_FN_IRQ5, NULL);
-	gpio_request(GPIO_FN_IRQ4, NULL);
-	gpio_request(GPIO_FN_IRQ3, NULL);
-	gpio_request(GPIO_FN_IRQ2, NULL);
-	gpio_request(GPIO_FN_IRQ1, NULL);
-	gpio_request(GPIO_FN_IRQ0, NULL);
-
-	/* SPI0 (PTD) */
-	gpio_request(GPIO_FN_SP0_MOSI, NULL);
-	gpio_request(GPIO_FN_SP0_MISO, NULL);
-	gpio_request(GPIO_FN_SP0_SCK, NULL);
-	gpio_request(GPIO_FN_SP0_SCK_FB, NULL);
-	gpio_request(GPIO_FN_SP0_SS0, NULL);
-	gpio_request(GPIO_FN_SP0_SS1, NULL);
-	gpio_request(GPIO_FN_SP0_SS2, NULL);
-	gpio_request(GPIO_FN_SP0_SS3, NULL);
-
-	/* RMII 0/1 (PTE, PTF) */
-	gpio_request(GPIO_FN_RMII0_CRS_DV, NULL);
-	gpio_request(GPIO_FN_RMII0_TXD1, NULL);
-	gpio_request(GPIO_FN_RMII0_TXD0, NULL);
-	gpio_request(GPIO_FN_RMII0_TXEN, NULL);
-	gpio_request(GPIO_FN_RMII0_REFCLK, NULL);
-	gpio_request(GPIO_FN_RMII0_RXD1, NULL);
-	gpio_request(GPIO_FN_RMII0_RXD0, NULL);
-	gpio_request(GPIO_FN_RMII0_RX_ER, NULL);
-	gpio_request(GPIO_FN_RMII1_CRS_DV, NULL);
-	gpio_request(GPIO_FN_RMII1_TXD1, NULL);
-	gpio_request(GPIO_FN_RMII1_TXD0, NULL);
-	gpio_request(GPIO_FN_RMII1_TXEN, NULL);
-	gpio_request(GPIO_FN_RMII1_REFCLK, NULL);
-	gpio_request(GPIO_FN_RMII1_RXD1, NULL);
-	gpio_request(GPIO_FN_RMII1_RXD0, NULL);
-	gpio_request(GPIO_FN_RMII1_RX_ER, NULL);
-
-	/* eMMC (PTG) */
-	gpio_request(GPIO_FN_MMCCLK, NULL);
-	gpio_request(GPIO_FN_MMCCMD, NULL);
-	gpio_request(GPIO_FN_MMCDAT7, NULL);
-	gpio_request(GPIO_FN_MMCDAT6, NULL);
-	gpio_request(GPIO_FN_MMCDAT5, NULL);
-	gpio_request(GPIO_FN_MMCDAT4, NULL);
-	gpio_request(GPIO_FN_MMCDAT3, NULL);
-	gpio_request(GPIO_FN_MMCDAT2, NULL);
-	gpio_request(GPIO_FN_MMCDAT1, NULL);
-	gpio_request(GPIO_FN_MMCDAT0, NULL);
-
-	/* LPC (PTG, PTH, PTQ, PTU) */
-	gpio_request(GPIO_FN_SERIRQ, NULL);
-	gpio_request(GPIO_FN_LPCPD, NULL);
-	gpio_request(GPIO_FN_LDRQ, NULL);
-	gpio_request(GPIO_FN_WP, NULL);
-	gpio_request(GPIO_FN_FMS0, NULL);
-	gpio_request(GPIO_FN_LAD3, NULL);
-	gpio_request(GPIO_FN_LAD2, NULL);
-	gpio_request(GPIO_FN_LAD1, NULL);
-	gpio_request(GPIO_FN_LAD0, NULL);
-	gpio_request(GPIO_FN_LFRAME, NULL);
-	gpio_request(GPIO_FN_LRESET, NULL);
-	gpio_request(GPIO_FN_LCLK, NULL);
-	gpio_request(GPIO_FN_LGPIO7, NULL);
-	gpio_request(GPIO_FN_LGPIO6, NULL);
-	gpio_request(GPIO_FN_LGPIO5, NULL);
-	gpio_request(GPIO_FN_LGPIO4, NULL);
-
-	/* SPI1 (PTH) */
-	gpio_request(GPIO_FN_SP1_MOSI, NULL);
-	gpio_request(GPIO_FN_SP1_MISO, NULL);
-	gpio_request(GPIO_FN_SP1_SCK, NULL);
-	gpio_request(GPIO_FN_SP1_SCK_FB, NULL);
-	gpio_request(GPIO_FN_SP1_SS0, NULL);
-	gpio_request(GPIO_FN_SP1_SS1, NULL);
-
-	/* SDHI (PTI) */
-	gpio_request(GPIO_FN_SD_WP, NULL);
-	gpio_request(GPIO_FN_SD_CD, NULL);
-	gpio_request(GPIO_FN_SD_CLK, NULL);
-	gpio_request(GPIO_FN_SD_CMD, NULL);
-	gpio_request(GPIO_FN_SD_D3, NULL);
-	gpio_request(GPIO_FN_SD_D2, NULL);
-	gpio_request(GPIO_FN_SD_D1, NULL);
-	gpio_request(GPIO_FN_SD_D0, NULL);
-
-	/* SCIF3/4 (PTJ, PTW) */
-	gpio_request(GPIO_FN_RTS3, NULL);
-	gpio_request(GPIO_FN_CTS3, NULL);
-	gpio_request(GPIO_FN_TXD3, NULL);
-	gpio_request(GPIO_FN_RXD3, NULL);
-	gpio_request(GPIO_FN_RTS4, NULL);
-	gpio_request(GPIO_FN_RXD4, NULL);
-	gpio_request(GPIO_FN_TXD4, NULL);
-	gpio_request(GPIO_FN_CTS4, NULL);
-
-	/* SERMUX (PTK, PTL, PTO, PTV) */
-	gpio_request(GPIO_FN_COM2_TXD, NULL);
-	gpio_request(GPIO_FN_COM2_RXD, NULL);
-	gpio_request(GPIO_FN_COM2_RTS, NULL);
-	gpio_request(GPIO_FN_COM2_CTS, NULL);
-	gpio_request(GPIO_FN_COM2_DTR, NULL);
-	gpio_request(GPIO_FN_COM2_DSR, NULL);
-	gpio_request(GPIO_FN_COM2_DCD, NULL);
-	gpio_request(GPIO_FN_COM2_RI, NULL);
-	gpio_request(GPIO_FN_RAC_RXD, NULL);
-	gpio_request(GPIO_FN_RAC_RTS, NULL);
-	gpio_request(GPIO_FN_RAC_CTS, NULL);
-	gpio_request(GPIO_FN_RAC_DTR, NULL);
-	gpio_request(GPIO_FN_RAC_DSR, NULL);
-	gpio_request(GPIO_FN_RAC_DCD, NULL);
-	gpio_request(GPIO_FN_RAC_TXD, NULL);
-	gpio_request(GPIO_FN_COM1_TXD, NULL);
-	gpio_request(GPIO_FN_COM1_RXD, NULL);
-	gpio_request(GPIO_FN_COM1_RTS, NULL);
-	gpio_request(GPIO_FN_COM1_CTS, NULL);
-
-	writeb(0x10, 0xfe470000);	/* SMR0: SerMux mode 0 */
-
-	/* IIC (PTM, PTR, PTS) */
-	gpio_request(GPIO_FN_SDA7, NULL);
-	gpio_request(GPIO_FN_SCL7, NULL);
-	gpio_request(GPIO_FN_SDA6, NULL);
-	gpio_request(GPIO_FN_SCL6, NULL);
-	gpio_request(GPIO_FN_SDA5, NULL);
-	gpio_request(GPIO_FN_SCL5, NULL);
-	gpio_request(GPIO_FN_SDA4, NULL);
-	gpio_request(GPIO_FN_SCL4, NULL);
-	gpio_request(GPIO_FN_SDA3, NULL);
-	gpio_request(GPIO_FN_SCL3, NULL);
-	gpio_request(GPIO_FN_SDA2, NULL);
-	gpio_request(GPIO_FN_SCL2, NULL);
-	gpio_request(GPIO_FN_SDA1, NULL);
-	gpio_request(GPIO_FN_SCL1, NULL);
-	gpio_request(GPIO_FN_SDA0, NULL);
-	gpio_request(GPIO_FN_SCL0, NULL);
-
-	/* USB (PTN) */
-	gpio_request(GPIO_FN_VBUS_EN, NULL);
-	gpio_request(GPIO_FN_VBUS_OC, NULL);
-
-	/* SGPIO1/0 (PTN, PTO) */
-	gpio_request(GPIO_FN_SGPIO1_CLK, NULL);
-	gpio_request(GPIO_FN_SGPIO1_LOAD, NULL);
-	gpio_request(GPIO_FN_SGPIO1_DI, NULL);
-	gpio_request(GPIO_FN_SGPIO1_DO, NULL);
-	gpio_request(GPIO_FN_SGPIO0_CLK, NULL);
-	gpio_request(GPIO_FN_SGPIO0_LOAD, NULL);
-	gpio_request(GPIO_FN_SGPIO0_DI, NULL);
-	gpio_request(GPIO_FN_SGPIO0_DO, NULL);
-
-	/* WDT (PTN) */
-	gpio_request(GPIO_FN_SUB_CLKIN, NULL);
-
-	/* System (PTT) */
-	gpio_request(GPIO_FN_STATUS1, NULL);
-	gpio_request(GPIO_FN_STATUS0, NULL);
-
-	/* PWMX (PTT) */
-	gpio_request(GPIO_FN_PWMX1, NULL);
-	gpio_request(GPIO_FN_PWMX0, NULL);
-
-	/* R-SPI (PTV) */
-	gpio_request(GPIO_FN_R_SPI_MOSI, NULL);
-	gpio_request(GPIO_FN_R_SPI_MISO, NULL);
-	gpio_request(GPIO_FN_R_SPI_RSPCK, NULL);
-	gpio_request(GPIO_FN_R_SPI_SSL0, NULL);
-	gpio_request(GPIO_FN_R_SPI_SSL1, NULL);
-
-	/* EVC (PTV, PTW) */
-	gpio_request(GPIO_FN_EVENT7, NULL);
-	gpio_request(GPIO_FN_EVENT6, NULL);
-	gpio_request(GPIO_FN_EVENT5, NULL);
-	gpio_request(GPIO_FN_EVENT4, NULL);
-	gpio_request(GPIO_FN_EVENT3, NULL);
-	gpio_request(GPIO_FN_EVENT2, NULL);
-	gpio_request(GPIO_FN_EVENT1, NULL);
-	gpio_request(GPIO_FN_EVENT0, NULL);
-
-	/* LED for heartbeat */
-	gpio_request(GPIO_PTU3, NULL);
-	gpio_direction_output(GPIO_PTU3, 1);
-	gpio_request(GPIO_PTU2, NULL);
-	gpio_direction_output(GPIO_PTU2, 1);
-	gpio_request(GPIO_PTU1, NULL);
-	gpio_direction_output(GPIO_PTU1, 1);
-	gpio_request(GPIO_PTU0, NULL);
-	gpio_direction_output(GPIO_PTU0, 1);
-
-	/* control for MDIO of Gigabit Ethernet */
-	gpio_request(GPIO_PTT4, NULL);
-	gpio_direction_output(GPIO_PTT4, 1);
-
-	/* control for eMMC */
-	gpio_request(GPIO_PTT7, NULL);		/* eMMC_RST# */
-	gpio_direction_output(GPIO_PTT7, 0);
-	gpio_request(GPIO_PTT6, NULL);		/* eMMC_INDEX# */
-	gpio_direction_output(GPIO_PTT6, 0);
-	gpio_request(GPIO_PTT5, NULL);		/* eMMC_PRST# */
-	gpio_direction_output(GPIO_PTT5, 1);
-
-	/* register SPI device information */
-	spi_register_board_info(spi_board_info,
-				ARRAY_SIZE(spi_board_info));
-
-	/* General platform */
-	return platform_add_devices(sh7757lcr_devices,
-				    ARRAY_SIZE(sh7757lcr_devices));
-}
-arch_initcall(sh7757lcr_devices_setup);
-
-/* Initialize IRQ setting */
-void __init init_sh7757lcr_IRQ(void)
-{
-	plat_irq_setup_pins(IRQ_MODE_IRQ7654);
-	plat_irq_setup_pins(IRQ_MODE_IRQ3210);
-}
-
-/* Initialize the board */
-static void __init sh7757lcr_setup(char **cmdline_p)
-{
-	printk(KERN_INFO "Renesas R0P7757LC0012RL support.\n");
-}
-
-static int sh7757lcr_mode_pins(void)
-{
-	int value = 0;
-
-	/* These are the factory default settings of S3 (Low active).
-	 * If you change these dip switches then you will need to
-	 * adjust the values below as well.
-	 */
-	value |= MODE_PIN0;	/* Clock Mode: 1 */
-
-	return value;
-}
-
-/* The Machine Vector */
-static struct sh_machine_vector mv_sh7757lcr __initmv = {
-	.mv_name		= "SH7757LCR",
-	.mv_setup		= sh7757lcr_setup,
-	.mv_init_irq		= init_sh7757lcr_IRQ,
-	.mv_mode_pins		= sh7757lcr_mode_pins,
-};
-
diff --git a/arch/sh/boards/board-sh7785lcr.c b/arch/sh/boards/board-sh7785lcr.c
deleted file mode 100644
index 77dad1e511b465..00000000000000
--- a/arch/sh/boards/board-sh7785lcr.c
+++ /dev/null
@@ -1,384 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Renesas Technology Corp. R0P7785LC0011RL Support.
- *
- * Copyright (C) 2008  Yoshihiro Shimoda
- * Copyright (C) 2009  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/sm501.h>
-#include <linux/sm501-regs.h>
-#include <linux/fb.h>
-#include <linux/mtd/physmap.h>
-#include <linux/delay.h>
-#include <linux/interrupt.h>
-#include <linux/i2c.h>
-#include <linux/platform_data/i2c-pca-platform.h>
-#include <linux/i2c-algo-pca.h>
-#include <linux/usb/r8a66597.h>
-#include <linux/sh_intc.h>
-#include <linux/irq.h>
-#include <linux/io.h>
-#include <linux/clk.h>
-#include <linux/errno.h>
-#include <linux/gpio/machine.h>
-#include <mach/sh7785lcr.h>
-#include <cpu/sh7785.h>
-#include <asm/heartbeat.h>
-#include <asm/clock.h>
-#include <asm/bl_bit.h>
-
-/*
- * NOTE: This board has 2 physical memory maps.
- *	 Please look at include/asm-sh/sh7785lcr.h or hardware manual.
- */
-static struct resource heartbeat_resource = {
-	.start	= PLD_LEDCR,
-	.end	= PLD_LEDCR,
-	.flags	= IORESOURCE_MEM | IORESOURCE_MEM_8BIT,
-};
-
-static struct platform_device heartbeat_device = {
-	.name		= "heartbeat",
-	.id		= -1,
-	.num_resources	= 1,
-	.resource	= &heartbeat_resource,
-};
-
-static struct mtd_partition nor_flash_partitions[] = {
-	{
-		.name		= "loader",
-		.offset		= 0x00000000,
-		.size		= 512 * 1024,
-	},
-	{
-		.name		= "bootenv",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= 512 * 1024,
-	},
-	{
-		.name		= "kernel",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= 4 * 1024 * 1024,
-	},
-	{
-		.name		= "data",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= MTDPART_SIZ_FULL,
-	},
-};
-
-static struct physmap_flash_data nor_flash_data = {
-	.width		= 4,
-	.parts		= nor_flash_partitions,
-	.nr_parts	= ARRAY_SIZE(nor_flash_partitions),
-};
-
-static struct resource nor_flash_resources[] = {
-	[0]	= {
-		.start	= NOR_FLASH_ADDR,
-		.end	= NOR_FLASH_ADDR + NOR_FLASH_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	}
-};
-
-static struct platform_device nor_flash_device = {
-	.name		= "physmap-flash",
-	.dev		= {
-		.platform_data	= &nor_flash_data,
-	},
-	.num_resources	= ARRAY_SIZE(nor_flash_resources),
-	.resource	= nor_flash_resources,
-};
-
-static struct r8a66597_platdata r8a66597_data = {
-	.xtal = R8A66597_PLATDATA_XTAL_12MHZ,
-	.vif = 1,
-};
-
-static struct resource r8a66597_usb_host_resources[] = {
-	[0] = {
-		.start	= R8A66597_ADDR,
-		.end	= R8A66597_ADDR + R8A66597_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0x240),
-		.end	= evt2irq(0x240),
-		.flags	= IORESOURCE_IRQ | IRQF_TRIGGER_LOW,
-	},
-};
-
-static struct platform_device r8a66597_usb_host_device = {
-	.name		= "r8a66597_hcd",
-	.id		= -1,
-	.dev = {
-		.dma_mask		= NULL,
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &r8a66597_data,
-	},
-	.num_resources	= ARRAY_SIZE(r8a66597_usb_host_resources),
-	.resource	= r8a66597_usb_host_resources,
-};
-
-static struct resource sm501_resources[] = {
-	[0]	= {
-		.start	= SM107_MEM_ADDR,
-		.end	= SM107_MEM_ADDR + SM107_MEM_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1]	= {
-		.start	= SM107_REG_ADDR,
-		.end	= SM107_REG_ADDR + SM107_REG_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[2]	= {
-		.start	= evt2irq(0x340),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct fb_videomode sm501_default_mode_crt = {
-	.pixclock	= 35714,	/* 28MHz */
-	.xres		= 640,
-	.yres		= 480,
-	.left_margin	= 105,
-	.right_margin	= 16,
-	.upper_margin	= 33,
-	.lower_margin	= 10,
-	.hsync_len	= 39,
-	.vsync_len	= 2,
-	.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-};
-
-static struct fb_videomode sm501_default_mode_pnl = {
-	.pixclock	= 40000,	/* 25MHz */
-	.xres		= 640,
-	.yres		= 480,
-	.left_margin	= 2,
-	.right_margin	= 16,
-	.upper_margin	= 33,
-	.lower_margin	= 10,
-	.hsync_len	= 39,
-	.vsync_len	= 2,
-	.sync		= 0,
-};
-
-static struct sm501_platdata_fbsub sm501_pdata_fbsub_pnl = {
-	.def_bpp	= 16,
-	.def_mode	= &sm501_default_mode_pnl,
-	.flags		= SM501FB_FLAG_USE_INIT_MODE |
-			  SM501FB_FLAG_USE_HWCURSOR |
-			  SM501FB_FLAG_USE_HWACCEL |
-			  SM501FB_FLAG_DISABLE_AT_EXIT |
-			  SM501FB_FLAG_PANEL_NO_VBIASEN,
-};
-
-static struct sm501_platdata_fbsub sm501_pdata_fbsub_crt = {
-	.def_bpp	= 16,
-	.def_mode	= &sm501_default_mode_crt,
-	.flags		= SM501FB_FLAG_USE_INIT_MODE |
-			  SM501FB_FLAG_USE_HWCURSOR |
-			  SM501FB_FLAG_USE_HWACCEL |
-			  SM501FB_FLAG_DISABLE_AT_EXIT,
-};
-
-static struct sm501_platdata_fb sm501_fb_pdata = {
-	.fb_route	= SM501_FB_OWN,
-	.fb_crt		= &sm501_pdata_fbsub_crt,
-	.fb_pnl		= &sm501_pdata_fbsub_pnl,
-};
-
-static struct sm501_initdata sm501_initdata = {
-	.gpio_high	= {
-		.set	= 0x00001fe0,
-		.mask	= 0x0,
-	},
-	.devices	= 0,
-	.mclk		= 84 * 1000000,
-	.m1xclk		= 112 * 1000000,
-};
-
-static struct sm501_platdata sm501_platform_data = {
-	.init		= &sm501_initdata,
-	.fb		= &sm501_fb_pdata,
-};
-
-static struct platform_device sm501_device = {
-	.name		= "sm501",
-	.id		= -1,
-	.dev		= {
-		.platform_data	= &sm501_platform_data,
-	},
-	.num_resources	= ARRAY_SIZE(sm501_resources),
-	.resource	= sm501_resources,
-};
-
-static struct resource i2c_proto_resources[] = {
-	[0] = {
-		.start	= PCA9564_PROTO_32BIT_ADDR,
-		.end	= PCA9564_PROTO_32BIT_ADDR + PCA9564_SIZE - 1,
-		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_8BIT,
-	},
-	[1] = {
-		.start	= evt2irq(0x380),
-		.end	= evt2irq(0x380),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct resource i2c_resources[] = {
-	[0] = {
-		.start	= PCA9564_ADDR,
-		.end	= PCA9564_ADDR + PCA9564_SIZE - 1,
-		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_8BIT,
-	},
-	[1] = {
-		.start	= evt2irq(0x380),
-		.end	= evt2irq(0x380),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct gpiod_lookup_table i2c_gpio_table = {
-	.dev_id = "i2c.0",
-	.table = {
-		GPIO_LOOKUP("pfc-sh7757", 0, "reset-gpios", GPIO_ACTIVE_LOW),
-		{ },
-	},
-};
-
-static struct i2c_pca9564_pf_platform_data i2c_platform_data = {
-	.i2c_clock_speed	= I2C_PCA_CON_330kHz,
-	.timeout		= HZ,
-};
-
-static struct platform_device i2c_device = {
-	.name		= "i2c-pca-platform",
-	.id		= -1,
-	.dev		= {
-		.platform_data	= &i2c_platform_data,
-	},
-	.num_resources	= ARRAY_SIZE(i2c_resources),
-	.resource	= i2c_resources,
-};
-
-static struct platform_device *sh7785lcr_devices[] __initdata = {
-	&heartbeat_device,
-	&nor_flash_device,
-	&r8a66597_usb_host_device,
-	&sm501_device,
-	&i2c_device,
-};
-
-static struct i2c_board_info __initdata sh7785lcr_i2c_devices[] = {
-	{
-		I2C_BOARD_INFO("r2025sd", 0x32),
-	},
-};
-
-static int __init sh7785lcr_devices_setup(void)
-{
-	i2c_register_board_info(0, sh7785lcr_i2c_devices,
-				ARRAY_SIZE(sh7785lcr_i2c_devices));
-
-	if (mach_is_sh7785lcr_pt()) {
-		i2c_device.resource = i2c_proto_resources;
-		i2c_device.num_resources = ARRAY_SIZE(i2c_proto_resources);
-	}
-
-	gpiod_add_lookup_table(&i2c_gpio_table);
-	return platform_add_devices(sh7785lcr_devices,
-				    ARRAY_SIZE(sh7785lcr_devices));
-}
-device_initcall(sh7785lcr_devices_setup);
-
-/* Initialize IRQ setting */
-void __init init_sh7785lcr_IRQ(void)
-{
-	plat_irq_setup_pins(IRQ_MODE_IRQ7654);
-	plat_irq_setup_pins(IRQ_MODE_IRQ3210);
-}
-
-static int sh7785lcr_clk_init(void)
-{
-	struct clk *clk;
-	int ret;
-
-	clk = clk_get(NULL, "extal");
-	if (IS_ERR(clk))
-		return PTR_ERR(clk);
-	ret = clk_set_rate(clk, 33333333);
-	clk_put(clk);
-
-	return ret;
-}
-
-static void sh7785lcr_power_off(void)
-{
-	unsigned char *p;
-
-	p = ioremap(PLD_POFCR, PLD_POFCR + 1);
-	if (!p) {
-		printk(KERN_ERR "%s: ioremap error.\n", __func__);
-		return;
-	}
-	*p = 0x01;
-	iounmap(p);
-	set_bl_bit();
-	while (1)
-		cpu_relax();
-}
-
-/* Initialize the board */
-static void __init sh7785lcr_setup(char **cmdline_p)
-{
-	void __iomem *sm501_reg;
-
-	printk(KERN_INFO "Renesas Technology Corp. R0P7785LC0011RL support.\n");
-
-	pm_power_off = sh7785lcr_power_off;
-
-	/* sm501 DRAM configuration */
-	sm501_reg = ioremap(SM107_REG_ADDR, SM501_DRAM_CONTROL);
-	if (!sm501_reg) {
-		printk(KERN_ERR "%s: ioremap error.\n", __func__);
-		return;
-	}
-
-	writel(0x000307c2, sm501_reg + SM501_DRAM_CONTROL);
-	iounmap(sm501_reg);
-}
-
-/* Return the board specific boot mode pin configuration */
-static int sh7785lcr_mode_pins(void)
-{
-	int value = 0;
-
-	/* These are the factory default settings of S1 and S2.
-	 * If you change these dip switches then you will need to
-	 * adjust the values below as well.
-	 */
-	value |= MODE_PIN4; /* Clock Mode 16 */
-	value |= MODE_PIN5; /* 32-bit Area0 bus width */
-	value |= MODE_PIN6; /* 32-bit Area0 bus width */
-	value |= MODE_PIN7; /* Area 0 SRAM interface [fixed] */
-	value |= MODE_PIN8; /* Little Endian */
-	value |= MODE_PIN9; /* Master Mode */
-	value |= MODE_PIN14; /* No PLL step-up */
-
-	return value;
-}
-
-/*
- * The Machine Vector
- */
-static struct sh_machine_vector mv_sh7785lcr __initmv = {
-	.mv_name		= "SH7785LCR",
-	.mv_setup		= sh7785lcr_setup,
-	.mv_clk_init		= sh7785lcr_clk_init,
-	.mv_init_irq		= init_sh7785lcr_IRQ,
-	.mv_mode_pins		= sh7785lcr_mode_pins,
-};
-
diff --git a/arch/sh/boards/board-shmin.c b/arch/sh/boards/board-shmin.c
deleted file mode 100644
index 83296c0b75c45d..00000000000000
--- a/arch/sh/boards/board-shmin.c
+++ /dev/null
@@ -1,35 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/boards/shmin/setup.c
- *
- * Copyright (C) 2006 Takashi YOSHII
- *
- * SHMIN Support.
- */
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <asm/machvec.h>
-#include <mach/shmin.h>
-#include <asm/clock.h>
-#include <asm/io.h>
-
-#define PFC_PHCR	0xa400010eUL
-#define INTC_ICR1	0xa4000010UL
-
-static void __init init_shmin_irq(void)
-{
-	__raw_writew(0x2a00, PFC_PHCR);	// IRQ0-3=IRQ
-	__raw_writew(0x0aaa, INTC_ICR1);	// IRQ0-3=IRQ-mode,Low-active.
-	plat_irq_setup_pins(IRQ_MODE_IRQ);
-}
-
-static void __init shmin_setup(char **cmdline_p)
-{
-	__set_io_port_base(SHMIN_IO_BASE);
-}
-
-static struct sh_machine_vector mv_shmin __initmv = {
-	.mv_name	= "SHMIN",
-	.mv_setup	= shmin_setup,
-	.mv_init_irq	= init_shmin_irq,
-};
diff --git a/arch/sh/boards/board-titan.c b/arch/sh/boards/board-titan.c
deleted file mode 100644
index 074a848d8b564d..00000000000000
--- a/arch/sh/boards/board-titan.c
+++ /dev/null
@@ -1,21 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/boards/titan/setup.c - Setup for Titan
- *
- *  Copyright (C) 2006  Jamie Lenehan
- */
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <mach/titan.h>
-#include <asm/io.h>
-
-static void __init init_titan_irq(void)
-{
-	/* enable individual interrupt mode for externals */
-	plat_irq_setup_pins(IRQ_MODE_IRQ);
-}
-
-static struct sh_machine_vector mv_titan __initmv = {
-	.mv_name	= "Titan",
-	.mv_init_irq	= init_titan_irq,
-};
diff --git a/arch/sh/boards/board-urquell.c b/arch/sh/boards/board-urquell.c
deleted file mode 100644
index dad2b3b40735cb..00000000000000
--- a/arch/sh/boards/board-urquell.c
+++ /dev/null
@@ -1,218 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Renesas Technology Corp. SH7786 Urquell Support.
- *
- * Copyright (C) 2008  Kuninori Morimoto <morimoto.kuninori@renesas.com>
- * Copyright (C) 2009, 2010  Paul Mundt
- *
- * Based on board-sh7785lcr.c
- * Copyright (C) 2008  Yoshihiro Shimoda
- */
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/fb.h>
-#include <linux/smc91x.h>
-#include <linux/mtd/physmap.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/irq.h>
-#include <linux/clk.h>
-#include <linux/sh_intc.h>
-#include <mach/urquell.h>
-#include <cpu/sh7786.h>
-#include <asm/heartbeat.h>
-#include <linux/sizes.h>
-#include <asm/smp-ops.h>
-
-/*
- * bit  1234 5678
- *----------------------------
- * SW1  0101 0010  -> Pck 33MHz version
- *     (1101 0010)    Pck 66MHz version
- * SW2  0x1x xxxx  -> little endian
- *                    29bit mode
- * SW47 0001 1000  -> CS0 : on-board flash
- *                    CS1 : SRAM, registers, LAN, PCMCIA
- *                    38400 bps for SCIF1
- *
- * Address
- * 0x00000000 - 0x04000000  (CS0)     Nor Flash
- * 0x04000000 - 0x04200000  (CS1)     SRAM
- * 0x05000000 - 0x05800000  (CS1)     on board register
- * 0x05800000 - 0x06000000  (CS1)     LAN91C111
- * 0x06000000 - 0x06400000  (CS1)     PCMCIA
- * 0x08000000 - 0x10000000  (CS2-CS3) DDR3
- * 0x10000000 - 0x14000000  (CS4)     PCIe
- * 0x14000000 - 0x14800000  (CS5)     Core0 LRAM/URAM
- * 0x14800000 - 0x15000000  (CS5)     Core1 LRAM/URAM
- * 0x18000000 - 0x1C000000  (CS6)     ATA/NAND-Flash
- * 0x1C000000 -             (CS7)     SH7786 Control register
- */
-
-/* HeartBeat */
-static struct resource heartbeat_resource = {
-	.start	= BOARDREG(SLEDR),
-	.end	= BOARDREG(SLEDR),
-	.flags	= IORESOURCE_MEM | IORESOURCE_MEM_16BIT,
-};
-
-static struct platform_device heartbeat_device = {
-	.name		= "heartbeat",
-	.id		= -1,
-	.num_resources	= 1,
-	.resource	= &heartbeat_resource,
-};
-
-/* LAN91C111 */
-static struct smc91x_platdata smc91x_info = {
-	.flags = SMC91X_USE_16BIT | SMC91X_NOWAIT,
-};
-
-static struct resource smc91x_eth_resources[] = {
-	[0] = {
-		.name   = "SMC91C111" ,
-		.start  = 0x05800300,
-		.end    = 0x0580030f,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0x360),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device smc91x_eth_device = {
-	.name           = "smc91x",
-	.num_resources  = ARRAY_SIZE(smc91x_eth_resources),
-	.resource       = smc91x_eth_resources,
-	.dev	= {
-		.platform_data	= &smc91x_info,
-	},
-};
-
-/* Nor Flash */
-static struct mtd_partition nor_flash_partitions[] = {
-	{
-		.name		= "loader",
-		.offset		= 0x00000000,
-		.size		= SZ_512K,
-		.mask_flags	= MTD_WRITEABLE,	/* Read-only */
-	},
-	{
-		.name		= "bootenv",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= SZ_512K,
-		.mask_flags	= MTD_WRITEABLE,	/* Read-only */
-	},
-	{
-		.name		= "kernel",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= SZ_4M,
-	},
-	{
-		.name		= "data",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= MTDPART_SIZ_FULL,
-	},
-};
-
-static struct physmap_flash_data nor_flash_data = {
-	.width		= 2,
-	.parts		= nor_flash_partitions,
-	.nr_parts	= ARRAY_SIZE(nor_flash_partitions),
-};
-
-static struct resource nor_flash_resources[] = {
-	[0] = {
-		.start	= NOR_FLASH_ADDR,
-		.end	= NOR_FLASH_ADDR + NOR_FLASH_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	}
-};
-
-static struct platform_device nor_flash_device = {
-	.name		= "physmap-flash",
-	.dev		= {
-		.platform_data	= &nor_flash_data,
-	},
-	.num_resources	= ARRAY_SIZE(nor_flash_resources),
-	.resource	= nor_flash_resources,
-};
-
-static struct platform_device *urquell_devices[] __initdata = {
-	&heartbeat_device,
-	&smc91x_eth_device,
-	&nor_flash_device,
-};
-
-static int __init urquell_devices_setup(void)
-{
-	/* USB */
-	gpio_request(GPIO_FN_USB_OVC0,  NULL);
-	gpio_request(GPIO_FN_USB_PENC0, NULL);
-
-	/* enable LAN */
-	__raw_writew(__raw_readw(UBOARDREG(IRL2MSKR)) & ~0x00000001,
-		  UBOARDREG(IRL2MSKR));
-
-	return platform_add_devices(urquell_devices,
-				    ARRAY_SIZE(urquell_devices));
-}
-device_initcall(urquell_devices_setup);
-
-static void urquell_power_off(void)
-{
-	__raw_writew(0xa5a5, UBOARDREG(SRSTR));
-}
-
-static void __init urquell_init_irq(void)
-{
-	plat_irq_setup_pins(IRQ_MODE_IRL3210_MASK);
-}
-
-static int urquell_mode_pins(void)
-{
-	return __raw_readw(UBOARDREG(MDSWMR));
-}
-
-static int urquell_clk_init(void)
-{
-	struct clk *clk;
-	int ret;
-
-	/*
-	 * Only handle the EXTAL case, anyone interfacing a crystal
-	 * resonator will need to provide their own input clock.
-	 */
-	if (test_mode_pin(MODE_PIN9))
-		return -EINVAL;
-
-	clk = clk_get(NULL, "extal");
-	if (IS_ERR(clk))
-		return PTR_ERR(clk);
-	ret = clk_set_rate(clk, 33333333);
-	clk_put(clk);
-
-	return ret;
-}
-
-/* Initialize the board */
-static void __init urquell_setup(char **cmdline_p)
-{
-	printk(KERN_INFO "Renesas Technology Corp. Urquell support.\n");
-
-	pm_power_off = urquell_power_off;
-
-	register_smp_ops(&shx3_smp_ops);
-}
-
-/*
- * The Machine Vector
- */
-static struct sh_machine_vector mv_urquell __initmv = {
-	.mv_name	= "Urquell",
-	.mv_setup	= urquell_setup,
-	.mv_init_irq	= urquell_init_irq,
-	.mv_mode_pins	= urquell_mode_pins,
-	.mv_clk_init	= urquell_clk_init,
-};
diff --git a/arch/sh/boards/mach-ap325rxa/Makefile b/arch/sh/boards/mach-ap325rxa/Makefile
deleted file mode 100644
index dba5d0c202615a..00000000000000
--- a/arch/sh/boards/mach-ap325rxa/Makefile
+++ /dev/null
@@ -1,3 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-obj-y	 := setup.o sdram.o
-
diff --git a/arch/sh/boards/mach-ap325rxa/sdram.S b/arch/sh/boards/mach-ap325rxa/sdram.S
deleted file mode 100644
index 541c82cc30b112..00000000000000
--- a/arch/sh/boards/mach-ap325rxa/sdram.S
+++ /dev/null
@@ -1,66 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * AP325RXA sdram self/auto-refresh setup code
- *
- *  Copyright (C) 2009 Magnus Damm
- */
-
-#include <linux/sys.h>
-#include <linux/errno.h>
-#include <linux/linkage.h>
-#include <asm/asm-offsets.h>
-#include <asm/suspend.h>
-#include <asm/romimage-macros.h>
-
-/* code to enter and leave self-refresh. must be self-contained.
- * this code will be copied to on-chip memory and executed from there.
- */
-	.balign 4
-ENTRY(ap325rxa_sdram_enter_start)
-
-	/* SBSC: disable power down and put in self-refresh mode */
-	mov.l	1f, r4
-	mov.l	2f, r1
-	mov.l	@r4, r2
-	or	r1, r2
-	mov.l   3f, r3
-	and	r3, r2
-	mov.l	r2, @r4
-
-	rts
-	 nop
-
-	.balign 4
-1:	.long	0xfe400008 /* SDCR0 */
-2:	.long	0x00000400
-3:	.long	0xffff7fff
-ENTRY(ap325rxa_sdram_enter_end)
-
-	.balign 4
-ENTRY(ap325rxa_sdram_leave_start)
-
-	/* SBSC: set auto-refresh mode */
-	mov.l	1f, r4
-	mov.l	@r4, r0
-	mov.l   4f, r1
-	and	r1, r0
-	mov.l	r0, @r4
-	mov.l	6f, r4
-	mov.l	8f, r0
-	mov.l	@r4, r1
-	mov	#-1, r4
-	add	r4, r1
-	or	r1, r0
-	mov.l	7f, r1
-	mov.l	r0, @r1
-
-	rts
-	 nop
-
-	.balign 4
-1:	.long	0xfe400008 /* SDCR0 */
-4:	.long	0xfffffbff
-6:	.long   0xfe40001c /* RTCOR */
-7:	.long   0xfe400018 /* RTCNT */
-8:	.long   0xa55a0000
-ENTRY(ap325rxa_sdram_leave_end)
diff --git a/arch/sh/boards/mach-ap325rxa/setup.c b/arch/sh/boards/mach-ap325rxa/setup.c
deleted file mode 100644
index c77b5f00a66a3d..00000000000000
--- a/arch/sh/boards/mach-ap325rxa/setup.c
+++ /dev/null
@@ -1,573 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Renesas - AP-325RXA
- * (Compatible with Algo System ., LTD. - AP-320A)
- *
- * Copyright (C) 2008 Renesas Solutions Corp.
- * Author : Yusuke Goda <goda.yuske@renesas.com>
- */
-
-#include <asm/clock.h>
-#include <asm/io.h>
-#include <asm/suspend.h>
-
-#include <cpu/sh7723.h>
-
-#include <linux/dma-map-ops.h>
-#include <linux/clkdev.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/gpio.h>
-#include <linux/gpio/machine.h>
-#include <linux/i2c.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/memblock.h>
-#include <linux/mfd/tmio.h>
-#include <linux/mmc/host.h>
-#include <linux/mtd/physmap.h>
-#include <linux/mtd/sh_flctl.h>
-#include <linux/platform_device.h>
-#include <linux/regulator/fixed.h>
-#include <linux/regulator/machine.h>
-#include <linux/sh_intc.h>
-#include <linux/smsc911x.h>
-#include <linux/videodev2.h>
-
-#include <media/drv-intf/renesas-ceu.h>
-#include <media/i2c/ov772x.h>
-
-#include <video/sh_mobile_lcdc.h>
-
-#define CEU_BUFFER_MEMORY_SIZE		(4 << 20)
-static phys_addr_t ceu_dma_membase;
-
-/* Dummy supplies, where voltage doesn't matter */
-static struct regulator_consumer_supply dummy_supplies[] = {
-	REGULATOR_SUPPLY("vddvario", "smsc911x"),
-	REGULATOR_SUPPLY("vdd33a", "smsc911x"),
-};
-
-static struct smsc911x_platform_config smsc911x_config = {
-	.phy_interface	= PHY_INTERFACE_MODE_MII,
-	.irq_polarity	= SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
-	.irq_type	= SMSC911X_IRQ_TYPE_OPEN_DRAIN,
-	.flags		= SMSC911X_USE_32BIT,
-};
-
-static struct resource smsc9118_resources[] = {
-	[0] = {
-		.start	= 0xb6080000,
-		.end	= 0xb60fffff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0x660),
-		.end	= evt2irq(0x660),
-		.flags	= IORESOURCE_IRQ,
-	}
-};
-
-static struct platform_device smsc9118_device = {
-	.name		= "smsc911x",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(smsc9118_resources),
-	.resource	= smsc9118_resources,
-	.dev		= {
-		.platform_data = &smsc911x_config,
-	},
-};
-
-/*
- * AP320 and AP325RXA has CPLD data in NOR Flash(0xA80000-0xABFFFF).
- * If this area erased, this board can not boot.
- */
-static struct mtd_partition ap325rxa_nor_flash_partitions[] = {
-	{
-		.name = "uboot",
-		.offset = 0,
-		.size = (1 * 1024 * 1024),
-		.mask_flags = MTD_WRITEABLE,	/* Read-only */
-	}, {
-		.name = "kernel",
-		.offset = MTDPART_OFS_APPEND,
-		.size = (2 * 1024 * 1024),
-	}, {
-		.name = "free-area0",
-		.offset = MTDPART_OFS_APPEND,
-		.size = ((7 * 1024 * 1024) + (512 * 1024)),
-	}, {
-		.name = "CPLD-Data",
-		.offset = MTDPART_OFS_APPEND,
-		.mask_flags = MTD_WRITEABLE,	/* Read-only */
-		.size = (1024 * 128 * 2),
-	}, {
-		.name = "free-area1",
-		.offset = MTDPART_OFS_APPEND,
-		.size = MTDPART_SIZ_FULL,
-	},
-};
-
-static struct physmap_flash_data ap325rxa_nor_flash_data = {
-	.width		= 2,
-	.parts		= ap325rxa_nor_flash_partitions,
-	.nr_parts	= ARRAY_SIZE(ap325rxa_nor_flash_partitions),
-};
-
-static struct resource ap325rxa_nor_flash_resources[] = {
-	[0] = {
-		.name	= "NOR Flash",
-		.start	= 0x00000000,
-		.end	= 0x00ffffff,
-		.flags	= IORESOURCE_MEM,
-	}
-};
-
-static struct platform_device ap325rxa_nor_flash_device = {
-	.name		= "physmap-flash",
-	.resource	= ap325rxa_nor_flash_resources,
-	.num_resources	= ARRAY_SIZE(ap325rxa_nor_flash_resources),
-	.dev		= {
-		.platform_data = &ap325rxa_nor_flash_data,
-	},
-};
-
-static struct mtd_partition nand_partition_info[] = {
-	{
-		.name	= "nand_data",
-		.offset	= 0,
-		.size	= MTDPART_SIZ_FULL,
-	},
-};
-
-static struct resource nand_flash_resources[] = {
-	[0] = {
-		.start	= 0xa4530000,
-		.end	= 0xa45300ff,
-		.flags	= IORESOURCE_MEM,
-	}
-};
-
-static struct sh_flctl_platform_data nand_flash_data = {
-	.parts		= nand_partition_info,
-	.nr_parts	= ARRAY_SIZE(nand_partition_info),
-	.flcmncr_val	= FCKSEL_E | TYPESEL_SET | NANWF_E,
-	.has_hwecc	= 1,
-};
-
-static struct platform_device nand_flash_device = {
-	.name		= "sh_flctl",
-	.resource	= nand_flash_resources,
-	.num_resources	= ARRAY_SIZE(nand_flash_resources),
-	.dev		= {
-		.platform_data = &nand_flash_data,
-	},
-};
-
-#define FPGA_LCDREG	0xB4100180
-#define FPGA_BKLREG	0xB4100212
-#define FPGA_LCDREG_VAL	0x0018
-#define PORT_MSELCRB	0xA4050182
-#define PORT_HIZCRC	0xA405015C
-#define PORT_DRVCRA	0xA405018A
-#define PORT_DRVCRB	0xA405018C
-
-static int ap320_wvga_set_brightness(int brightness)
-{
-	if (brightness) {
-		gpio_set_value(GPIO_PTS3, 0);
-		__raw_writew(0x100, FPGA_BKLREG);
-	} else {
-		__raw_writew(0, FPGA_BKLREG);
-		gpio_set_value(GPIO_PTS3, 1);
-	}
-
-	return 0;
-}
-
-static void ap320_wvga_power_on(void)
-{
-	msleep(100);
-
-	/* ASD AP-320/325 LCD ON */
-	__raw_writew(FPGA_LCDREG_VAL, FPGA_LCDREG);
-}
-
-static void ap320_wvga_power_off(void)
-{
-	/* ASD AP-320/325 LCD OFF */
-	__raw_writew(0, FPGA_LCDREG);
-}
-
-static const struct fb_videomode ap325rxa_lcdc_modes[] = {
-	{
-		.name = "LB070WV1",
-		.xres = 800,
-		.yres = 480,
-		.left_margin = 32,
-		.right_margin = 160,
-		.hsync_len = 8,
-		.upper_margin = 63,
-		.lower_margin = 80,
-		.vsync_len = 1,
-		.sync = 0, /* hsync and vsync are active low */
-	},
-};
-
-static struct sh_mobile_lcdc_info lcdc_info = {
-	.clock_source = LCDC_CLK_EXTERNAL,
-	.ch[0] = {
-		.chan = LCDC_CHAN_MAINLCD,
-		.fourcc = V4L2_PIX_FMT_RGB565,
-		.interface_type = RGB18,
-		.clock_divider = 1,
-		.lcd_modes = ap325rxa_lcdc_modes,
-		.num_modes = ARRAY_SIZE(ap325rxa_lcdc_modes),
-		.panel_cfg = {
-			.width = 152,	/* 7.0 inch */
-			.height = 91,
-			.display_on = ap320_wvga_power_on,
-			.display_off = ap320_wvga_power_off,
-		},
-		.bl_info = {
-			.name = "sh_mobile_lcdc_bl",
-			.max_brightness = 1,
-			.set_brightness = ap320_wvga_set_brightness,
-		},
-	}
-};
-
-static struct resource lcdc_resources[] = {
-	[0] = {
-		.name	= "LCDC",
-		.start	= 0xfe940000, /* P4-only space */
-		.end	= 0xfe942fff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0x580),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device lcdc_device = {
-	.name		= "sh_mobile_lcdc_fb",
-	.num_resources	= ARRAY_SIZE(lcdc_resources),
-	.resource	= lcdc_resources,
-	.dev		= {
-		.platform_data	= &lcdc_info,
-	},
-};
-
-/* Powerdown/reset gpios for CEU image sensors */
-static struct gpiod_lookup_table ov7725_gpios = {
-	.dev_id		= "0-0021",
-	.table		= {
-		GPIO_LOOKUP("sh7723_pfc", GPIO_PTZ5, "reset", GPIO_ACTIVE_LOW),
-	},
-};
-
-static struct ceu_platform_data ceu0_pdata = {
-	.num_subdevs			= 1,
-	.subdevs = {
-		{ /* [0] = ov7725  */
-			.flags		= 0,
-			.bus_width	= 8,
-			.bus_shift	= 0,
-			.i2c_adapter_id	= 0,
-			.i2c_address	= 0x21,
-		},
-	},
-};
-
-static struct resource ceu_resources[] = {
-	[0] = {
-		.name	= "CEU",
-		.start	= 0xfe910000,
-		.end	= 0xfe91009f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0x880),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device ap325rxa_ceu_device = {
-	.name		= "renesas-ceu",
-	.id             = 0, /* "ceu.0" clock */
-	.num_resources	= ARRAY_SIZE(ceu_resources),
-	.resource	= ceu_resources,
-	.dev		= {
-		.platform_data	= &ceu0_pdata,
-	},
-};
-
-/* Fixed 3.3V regulators to be used by SDHI0, SDHI1 */
-static struct regulator_consumer_supply fixed3v3_power_consumers[] =
-{
-	REGULATOR_SUPPLY("vmmc", "sh_mobile_sdhi.0"),
-	REGULATOR_SUPPLY("vqmmc", "sh_mobile_sdhi.0"),
-	REGULATOR_SUPPLY("vmmc", "sh_mobile_sdhi.1"),
-	REGULATOR_SUPPLY("vqmmc", "sh_mobile_sdhi.1"),
-};
-
-static struct resource sdhi0_cn3_resources[] = {
-	[0] = {
-		.name	= "SDHI0",
-		.start	= 0x04ce0000,
-		.end	= 0x04ce00ff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0xe80),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct tmio_mmc_data sdhi0_cn3_data = {
-	.capabilities	= MMC_CAP_SDIO_IRQ,
-};
-
-static struct platform_device sdhi0_cn3_device = {
-	.name		= "sh_mobile_sdhi",
-	.id             = 0, /* "sdhi0" clock */
-	.num_resources	= ARRAY_SIZE(sdhi0_cn3_resources),
-	.resource	= sdhi0_cn3_resources,
-	.dev = {
-		.platform_data = &sdhi0_cn3_data,
-	},
-};
-
-static struct resource sdhi1_cn7_resources[] = {
-	[0] = {
-		.name	= "SDHI1",
-		.start	= 0x04cf0000,
-		.end	= 0x04cf00ff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0x4e0),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct tmio_mmc_data sdhi1_cn7_data = {
-	.capabilities	= MMC_CAP_SDIO_IRQ,
-};
-
-static struct platform_device sdhi1_cn7_device = {
-	.name		= "sh_mobile_sdhi",
-	.id             = 1, /* "sdhi1" clock */
-	.num_resources	= ARRAY_SIZE(sdhi1_cn7_resources),
-	.resource	= sdhi1_cn7_resources,
-	.dev = {
-		.platform_data = &sdhi1_cn7_data,
-	},
-};
-
-static struct ov772x_camera_info ov7725_info = {
-	.flags		= OV772X_FLAG_VFLIP | OV772X_FLAG_HFLIP,
-	.edgectrl	= OV772X_AUTO_EDGECTRL(0xf, 0),
-};
-
-static struct i2c_board_info ap325rxa_i2c_devices[] __initdata = {
-	{
-		I2C_BOARD_INFO("pcf8563", 0x51),
-	},
-	{
-		I2C_BOARD_INFO("ov772x", 0x21),
-		.platform_data = &ov7725_info,
-	},
-};
-
-static struct platform_device *ap325rxa_devices[] __initdata = {
-	&smsc9118_device,
-	&ap325rxa_nor_flash_device,
-	&lcdc_device,
-	&nand_flash_device,
-	&sdhi0_cn3_device,
-	&sdhi1_cn7_device,
-};
-
-extern char ap325rxa_sdram_enter_start;
-extern char ap325rxa_sdram_enter_end;
-extern char ap325rxa_sdram_leave_start;
-extern char ap325rxa_sdram_leave_end;
-
-static int __init ap325rxa_devices_setup(void)
-{
-	/* register board specific self-refresh code */
-	sh_mobile_register_self_refresh(SUSP_SH_STANDBY | SUSP_SH_SF,
-					&ap325rxa_sdram_enter_start,
-					&ap325rxa_sdram_enter_end,
-					&ap325rxa_sdram_leave_start,
-					&ap325rxa_sdram_leave_end);
-
-	regulator_register_always_on(0, "fixed-3.3V", fixed3v3_power_consumers,
-				     ARRAY_SIZE(fixed3v3_power_consumers), 3300000);
-	regulator_register_fixed(1, dummy_supplies, ARRAY_SIZE(dummy_supplies));
-
-	/* LD3 and LD4 LEDs */
-	gpio_request(GPIO_PTX5, NULL); /* RUN */
-	gpio_direction_output(GPIO_PTX5, 1);
-	gpio_export(GPIO_PTX5, 0);
-
-	gpio_request(GPIO_PTX4, NULL); /* INDICATOR */
-	gpio_direction_output(GPIO_PTX4, 0);
-	gpio_export(GPIO_PTX4, 0);
-
-	/* SW1 input */
-	gpio_request(GPIO_PTF7, NULL); /* MODE */
-	gpio_direction_input(GPIO_PTF7);
-	gpio_export(GPIO_PTF7, 0);
-
-	/* LCDC */
-	gpio_request(GPIO_FN_LCDD15, NULL);
-	gpio_request(GPIO_FN_LCDD14, NULL);
-	gpio_request(GPIO_FN_LCDD13, NULL);
-	gpio_request(GPIO_FN_LCDD12, NULL);
-	gpio_request(GPIO_FN_LCDD11, NULL);
-	gpio_request(GPIO_FN_LCDD10, NULL);
-	gpio_request(GPIO_FN_LCDD9, NULL);
-	gpio_request(GPIO_FN_LCDD8, NULL);
-	gpio_request(GPIO_FN_LCDD7, NULL);
-	gpio_request(GPIO_FN_LCDD6, NULL);
-	gpio_request(GPIO_FN_LCDD5, NULL);
-	gpio_request(GPIO_FN_LCDD4, NULL);
-	gpio_request(GPIO_FN_LCDD3, NULL);
-	gpio_request(GPIO_FN_LCDD2, NULL);
-	gpio_request(GPIO_FN_LCDD1, NULL);
-	gpio_request(GPIO_FN_LCDD0, NULL);
-	gpio_request(GPIO_FN_LCDLCLK_PTR, NULL);
-	gpio_request(GPIO_FN_LCDDCK, NULL);
-	gpio_request(GPIO_FN_LCDVEPWC, NULL);
-	gpio_request(GPIO_FN_LCDVCPWC, NULL);
-	gpio_request(GPIO_FN_LCDVSYN, NULL);
-	gpio_request(GPIO_FN_LCDHSYN, NULL);
-	gpio_request(GPIO_FN_LCDDISP, NULL);
-	gpio_request(GPIO_FN_LCDDON, NULL);
-
-	/* LCD backlight */
-	gpio_request(GPIO_PTS3, NULL);
-	gpio_direction_output(GPIO_PTS3, 1);
-
-	/* CEU */
-	gpio_request(GPIO_FN_VIO_CLK2, NULL);
-	gpio_request(GPIO_FN_VIO_VD2, NULL);
-	gpio_request(GPIO_FN_VIO_HD2, NULL);
-	gpio_request(GPIO_FN_VIO_FLD, NULL);
-	gpio_request(GPIO_FN_VIO_CKO, NULL);
-	gpio_request(GPIO_FN_VIO_D15, NULL);
-	gpio_request(GPIO_FN_VIO_D14, NULL);
-	gpio_request(GPIO_FN_VIO_D13, NULL);
-	gpio_request(GPIO_FN_VIO_D12, NULL);
-	gpio_request(GPIO_FN_VIO_D11, NULL);
-	gpio_request(GPIO_FN_VIO_D10, NULL);
-	gpio_request(GPIO_FN_VIO_D9, NULL);
-	gpio_request(GPIO_FN_VIO_D8, NULL);
-
-	gpio_request(GPIO_PTZ7, NULL);
-	gpio_direction_output(GPIO_PTZ7, 0); /* OE_CAM */
-	gpio_request(GPIO_PTZ6, NULL);
-	gpio_direction_output(GPIO_PTZ6, 0); /* STBY_CAM */
-	gpio_request(GPIO_PTZ5, NULL);
-	gpio_direction_output(GPIO_PTZ5, 0); /* RST_CAM */
-	gpio_request(GPIO_PTZ4, NULL);
-	gpio_direction_output(GPIO_PTZ4, 0); /* SADDR */
-
-	__raw_writew(__raw_readw(PORT_MSELCRB) & ~0x0001, PORT_MSELCRB);
-
-	/* FLCTL */
-	gpio_request(GPIO_FN_FCE, NULL);
-	gpio_request(GPIO_FN_NAF7, NULL);
-	gpio_request(GPIO_FN_NAF6, NULL);
-	gpio_request(GPIO_FN_NAF5, NULL);
-	gpio_request(GPIO_FN_NAF4, NULL);
-	gpio_request(GPIO_FN_NAF3, NULL);
-	gpio_request(GPIO_FN_NAF2, NULL);
-	gpio_request(GPIO_FN_NAF1, NULL);
-	gpio_request(GPIO_FN_NAF0, NULL);
-	gpio_request(GPIO_FN_FCDE, NULL);
-	gpio_request(GPIO_FN_FOE, NULL);
-	gpio_request(GPIO_FN_FSC, NULL);
-	gpio_request(GPIO_FN_FWE, NULL);
-	gpio_request(GPIO_FN_FRB, NULL);
-
-	__raw_writew(0, PORT_HIZCRC);
-	__raw_writew(0xFFFF, PORT_DRVCRA);
-	__raw_writew(0xFFFF, PORT_DRVCRB);
-
-	/* SDHI0 - CN3 - SD CARD */
-	gpio_request(GPIO_FN_SDHI0CD_PTD, NULL);
-	gpio_request(GPIO_FN_SDHI0WP_PTD, NULL);
-	gpio_request(GPIO_FN_SDHI0D3_PTD, NULL);
-	gpio_request(GPIO_FN_SDHI0D2_PTD, NULL);
-	gpio_request(GPIO_FN_SDHI0D1_PTD, NULL);
-	gpio_request(GPIO_FN_SDHI0D0_PTD, NULL);
-	gpio_request(GPIO_FN_SDHI0CMD_PTD, NULL);
-	gpio_request(GPIO_FN_SDHI0CLK_PTD, NULL);
-
-	/* SDHI1 - CN7 - MICRO SD CARD */
-	gpio_request(GPIO_FN_SDHI1CD, NULL);
-	gpio_request(GPIO_FN_SDHI1D3, NULL);
-	gpio_request(GPIO_FN_SDHI1D2, NULL);
-	gpio_request(GPIO_FN_SDHI1D1, NULL);
-	gpio_request(GPIO_FN_SDHI1D0, NULL);
-	gpio_request(GPIO_FN_SDHI1CMD, NULL);
-	gpio_request(GPIO_FN_SDHI1CLK, NULL);
-
-	/* Add a clock alias for ov7725 xclk source. */
-	clk_add_alias(NULL, "0-0021", "video_clk", NULL);
-
-	/* Register RSTB gpio for ov7725 camera sensor. */
-	gpiod_add_lookup_table(&ov7725_gpios);
-
-	i2c_register_board_info(0, ap325rxa_i2c_devices,
-				ARRAY_SIZE(ap325rxa_i2c_devices));
-
-	/* Initialize CEU platform device separately to map memory first */
-	device_initialize(&ap325rxa_ceu_device.dev);
-	dma_declare_coherent_memory(&ap325rxa_ceu_device.dev,
-			ceu_dma_membase, ceu_dma_membase,
-			ceu_dma_membase + CEU_BUFFER_MEMORY_SIZE - 1);
-
-	platform_device_add(&ap325rxa_ceu_device);
-
-	return platform_add_devices(ap325rxa_devices,
-				ARRAY_SIZE(ap325rxa_devices));
-}
-arch_initcall(ap325rxa_devices_setup);
-
-/* Return the board specific boot mode pin configuration */
-static int ap325rxa_mode_pins(void)
-{
-	/* MD0=0, MD1=0, MD2=0: Clock Mode 0
-	 * MD3=0: 16-bit Area0 Bus Width
-	 * MD5=1: Little Endian
-	 * TSTMD=1, MD8=1: Test Mode Disabled
-	 */
-	return MODE_PIN5 | MODE_PIN8;
-}
-
-/* Reserve a portion of memory for CEU buffers */
-static void __init ap325rxa_mv_mem_reserve(void)
-{
-	phys_addr_t phys;
-	phys_addr_t size = CEU_BUFFER_MEMORY_SIZE;
-
-	phys = memblock_phys_alloc(size, PAGE_SIZE);
-	if (!phys)
-		panic("Failed to allocate CEU memory\n");
-
-	memblock_phys_free(phys, size);
-	memblock_remove(phys, size);
-
-	ceu_dma_membase = phys;
-}
-
-static struct sh_machine_vector mv_ap325rxa __initmv = {
-	.mv_name = "AP-325RXA",
-	.mv_mode_pins = ap325rxa_mode_pins,
-	.mv_mem_reserve	= ap325rxa_mv_mem_reserve,
-};
diff --git a/arch/sh/boards/mach-dreamcast/Makefile b/arch/sh/boards/mach-dreamcast/Makefile
deleted file mode 100644
index 37b2452206aa21..00000000000000
--- a/arch/sh/boards/mach-dreamcast/Makefile
+++ /dev/null
@@ -1,7 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the Sega Dreamcast specific parts of the kernel
-#
-
-obj-y	 := setup.o irq.o
-obj-$(CONFIG_RTC_DRV_GENERIC) += rtc.o
diff --git a/arch/sh/boards/mach-dreamcast/irq.c b/arch/sh/boards/mach-dreamcast/irq.c
deleted file mode 100644
index cc06e4cdb4cdf9..00000000000000
--- a/arch/sh/boards/mach-dreamcast/irq.c
+++ /dev/null
@@ -1,155 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/boards/dreamcast/irq.c
- *
- * Holly IRQ support for the Sega Dreamcast.
- *
- * Copyright (c) 2001, 2002 M. R. Brown <mrbrown@0xd6.org>
- *
- * This file is part of the LinuxDC project (www.linuxdc.org)
- */
-#include <linux/irq.h>
-#include <linux/io.h>
-#include <linux/export.h>
-#include <linux/err.h>
-#include <mach/sysasic.h>
-
-/*
- * Dreamcast System ASIC Hardware Events -
- *
- * The Dreamcast's System ASIC (a.k.a. Holly) is responsible for receiving
- * hardware events from system peripherals and triggering an SH7750 IRQ.
- * Hardware events can trigger IRQs 13, 11, or 9 depending on which bits are
- * set in the Event Mask Registers (EMRs).  When a hardware event is
- * triggered, its corresponding bit in the Event Status Registers (ESRs)
- * is set, and that bit should be rewritten to the ESR to acknowledge that
- * event.
- *
- * There are three 32-bit ESRs located at 0xa05f6900 - 0xa05f6908.  Event
- * types can be found in arch/sh/include/mach-dreamcast/mach/sysasic.h.
- * There are three groups of EMRs that parallel the ESRs.  Each EMR group
- * corresponds to an IRQ, so 0xa05f6910 - 0xa05f6918 triggers IRQ 13,
- * 0xa05f6920 - 0xa05f6928 triggers IRQ 11, and 0xa05f6930 - 0xa05f6938
- * triggers IRQ 9.
- *
- * In the kernel, these events are mapped to virtual IRQs so that drivers can
- * respond to them as they would a normal interrupt.  In order to keep this
- * mapping simple, the events are mapped as:
- *
- * 6900/6910 - Events  0-31, IRQ 13
- * 6904/6924 - Events 32-63, IRQ 11
- * 6908/6938 - Events 64-95, IRQ  9
- *
- */
-
-#define ESR_BASE 0x005f6900    /* Base event status register */
-#define EMR_BASE 0x005f6910    /* Base event mask register */
-
-/*
- * Helps us determine the EMR group that this event belongs to: 0 = 0x6910,
- * 1 = 0x6920, 2 = 0x6930; also determine the event offset.
- */
-#define LEVEL(event) (((event) - HW_EVENT_IRQ_BASE) / 32)
-
-/* Return the hardware event's bit position within the EMR/ESR */
-#define EVENT_BIT(event) (((event) - HW_EVENT_IRQ_BASE) & 31)
-
-/*
- * For each of these *_irq routines, the IRQ passed in is the virtual IRQ
- * (logically mapped to the corresponding bit for the hardware event).
- */
-
-/* Disable the hardware event by masking its bit in its EMR */
-static inline void disable_systemasic_irq(struct irq_data *data)
-{
-	unsigned int irq = data->irq;
-	__u32 emr = EMR_BASE + (LEVEL(irq) << 4) + (LEVEL(irq) << 2);
-	__u32 mask;
-
-	mask = inl(emr);
-	mask &= ~(1 << EVENT_BIT(irq));
-	outl(mask, emr);
-}
-
-/* Enable the hardware event by setting its bit in its EMR */
-static inline void enable_systemasic_irq(struct irq_data *data)
-{
-	unsigned int irq = data->irq;
-	__u32 emr = EMR_BASE + (LEVEL(irq) << 4) + (LEVEL(irq) << 2);
-	__u32 mask;
-
-	mask = inl(emr);
-	mask |= (1 << EVENT_BIT(irq));
-	outl(mask, emr);
-}
-
-/* Acknowledge a hardware event by writing its bit back to its ESR */
-static void mask_ack_systemasic_irq(struct irq_data *data)
-{
-	unsigned int irq = data->irq;
-	__u32 esr = ESR_BASE + (LEVEL(irq) << 2);
-	disable_systemasic_irq(data);
-	outl((1 << EVENT_BIT(irq)), esr);
-}
-
-struct irq_chip systemasic_int = {
-	.name		= "System ASIC",
-	.irq_mask	= disable_systemasic_irq,
-	.irq_mask_ack	= mask_ack_systemasic_irq,
-	.irq_unmask	= enable_systemasic_irq,
-};
-
-/*
- * Map the hardware event indicated by the processor IRQ to a virtual IRQ.
- */
-int systemasic_irq_demux(int irq)
-{
-	__u32 emr, esr, status, level;
-	__u32 j, bit;
-
-	switch (irq) {
-	case 13:
-		level = 0;
-		break;
-	case 11:
-		level = 1;
-		break;
-	case  9:
-		level = 2;
-		break;
-	default:
-		return irq;
-	}
-	emr = EMR_BASE + (level << 4) + (level << 2);
-	esr = ESR_BASE + (level << 2);
-
-	/* Mask the ESR to filter any spurious, unwanted interrupts */
-	status = inl(esr);
-	status &= inl(emr);
-
-	/* Now scan and find the first set bit as the event to map */
-	for (bit = 1, j = 0; j < 32; bit <<= 1, j++) {
-		if (status & bit) {
-			irq = HW_EVENT_IRQ_BASE + j + (level << 5);
-			return irq;
-		}
-	}
-
-	/* Not reached */
-	return irq;
-}
-
-void systemasic_irq_init(void)
-{
-	int irq_base, i;
-
-	irq_base = irq_alloc_descs(HW_EVENT_IRQ_BASE, HW_EVENT_IRQ_BASE,
-				   HW_EVENT_IRQ_MAX - HW_EVENT_IRQ_BASE, -1);
-	if (IS_ERR_VALUE(irq_base)) {
-		pr_err("%s: failed hooking irqs\n", __func__);
-		return;
-	}
-
-	for (i = HW_EVENT_IRQ_BASE; i < HW_EVENT_IRQ_MAX; i++)
-		irq_set_chip_and_handler(i, &systemasic_int, handle_level_irq);
-}
diff --git a/arch/sh/boards/mach-dreamcast/rtc.c b/arch/sh/boards/mach-dreamcast/rtc.c
deleted file mode 100644
index 7873cd27e4e008..00000000000000
--- a/arch/sh/boards/mach-dreamcast/rtc.c
+++ /dev/null
@@ -1,96 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/boards/dreamcast/rtc.c
- *
- * Dreamcast AICA RTC routines.
- *
- * Copyright (c) 2001, 2002 M. R. Brown <mrbrown@0xd6.org>
- * Copyright (c) 2002 Paul Mundt <lethal@chaoticdreams.org>
- */
-
-#include <linux/time.h>
-#include <linux/rtc.h>
-#include <linux/io.h>
-#include <linux/platform_device.h>
-
-/* The AICA RTC has an Epoch of 1/1/1950, so we must subtract 20 years (in
-   seconds) to get the standard Unix Epoch when getting the time, and add
-   20 years when setting the time. */
-#define TWENTY_YEARS ((20 * 365LU + 5) * 86400)
-
-/* The AICA RTC is represented by a 32-bit seconds counter stored in 2 16-bit
-   registers.*/
-#define AICA_RTC_SECS_H		0xa0710000
-#define AICA_RTC_SECS_L		0xa0710004
-
-/**
- * aica_rtc_gettimeofday - Get the time from the AICA RTC
- * @dev: the RTC device (ignored)
- * @tm: pointer to resulting RTC time structure
- *
- * Grabs the current RTC seconds counter and adjusts it to the Unix Epoch.
- */
-static int aica_rtc_gettimeofday(struct device *dev, struct rtc_time *tm)
-{
-	unsigned long val1, val2;
-	time64_t t;
-
-	do {
-		val1 = ((__raw_readl(AICA_RTC_SECS_H) & 0xffff) << 16) |
-			(__raw_readl(AICA_RTC_SECS_L) & 0xffff);
-
-		val2 = ((__raw_readl(AICA_RTC_SECS_H) & 0xffff) << 16) |
-			(__raw_readl(AICA_RTC_SECS_L) & 0xffff);
-	} while (val1 != val2);
-
-	/* normalize to 1970..2106 time range */
-	t = (u32)(val1 - TWENTY_YEARS);
-
-	rtc_time64_to_tm(t, tm);
-
-	return 0;
-}
-
-/**
- * aica_rtc_settimeofday - Set the AICA RTC to the current time
- * @dev: the RTC device (ignored)
- * @tm: pointer to new RTC time structure
- *
- * Adjusts the given @tv to the AICA Epoch and sets the RTC seconds counter.
- */
-static int aica_rtc_settimeofday(struct device *dev, struct rtc_time *tm)
-{
-	unsigned long val1, val2;
-	time64_t secs = rtc_tm_to_time64(tm);
-	u32 adj = secs + TWENTY_YEARS;
-
-	do {
-		__raw_writel((adj & 0xffff0000) >> 16, AICA_RTC_SECS_H);
-		__raw_writel((adj & 0xffff), AICA_RTC_SECS_L);
-
-		val1 = ((__raw_readl(AICA_RTC_SECS_H) & 0xffff) << 16) |
-			(__raw_readl(AICA_RTC_SECS_L) & 0xffff);
-
-		val2 = ((__raw_readl(AICA_RTC_SECS_H) & 0xffff) << 16) |
-			(__raw_readl(AICA_RTC_SECS_L) & 0xffff);
-	} while (val1 != val2);
-
-	return 0;
-}
-
-static const struct rtc_class_ops rtc_generic_ops = {
-	.read_time = aica_rtc_gettimeofday,
-	.set_time = aica_rtc_settimeofday,
-};
-
-static int __init aica_time_init(void)
-{
-	struct platform_device *pdev;
-
-	pdev = platform_device_register_data(NULL, "rtc-generic", -1,
-					     &rtc_generic_ops,
-					     sizeof(rtc_generic_ops));
-
-	return PTR_ERR_OR_ZERO(pdev);
-}
-arch_initcall(aica_time_init);
diff --git a/arch/sh/boards/mach-dreamcast/setup.c b/arch/sh/boards/mach-dreamcast/setup.c
deleted file mode 100644
index 2d966c1c2cc188..00000000000000
--- a/arch/sh/boards/mach-dreamcast/setup.c
+++ /dev/null
@@ -1,39 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/boards/dreamcast/setup.c
- *
- * Hardware support for the Sega Dreamcast.
- *
- * Copyright (c) 2001, 2002 M. R. Brown <mrbrown@linuxdc.org>
- * Copyright (c) 2002, 2003, 2004 Paul Mundt <lethal@linux-sh.org>
- *
- * This file is part of the LinuxDC project (www.linuxdc.org)
- *
- * This file originally bore the message (with enclosed-$):
- *	Id: setup_dc.c,v 1.5 2001/05/24 05:09:16 mrbrown Exp
- *	SEGA Dreamcast support
- */
-
-#include <linux/sched.h>
-#include <linux/kernel.h>
-#include <linux/param.h>
-#include <linux/interrupt.h>
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/device.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/rtc.h>
-#include <asm/machvec.h>
-#include <mach/sysasic.h>
-
-static void __init dreamcast_setup(char **cmdline_p)
-{
-}
-
-static struct sh_machine_vector mv_dreamcast __initmv = {
-	.mv_name		= "Sega Dreamcast",
-	.mv_setup		= dreamcast_setup,
-	.mv_irq_demux		= systemasic_irq_demux,
-	.mv_init_irq		= systemasic_irq_init,
-};
diff --git a/arch/sh/boards/mach-ecovec24/Makefile b/arch/sh/boards/mach-ecovec24/Makefile
deleted file mode 100644
index d78d4904ddee32..00000000000000
--- a/arch/sh/boards/mach-ecovec24/Makefile
+++ /dev/null
@@ -1,10 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the R0P7724LC0011/21RL (EcoVec)
-#
-# This file is subject to the terms and conditions of the GNU General Public
-# License.  See the file "COPYING" in the main directory of this archive
-# for more details.
-#
-
-obj-y	 := setup.o sdram.o
diff --git a/arch/sh/boards/mach-ecovec24/sdram.S b/arch/sh/boards/mach-ecovec24/sdram.S
deleted file mode 100644
index d2f269169abb94..00000000000000
--- a/arch/sh/boards/mach-ecovec24/sdram.S
+++ /dev/null
@@ -1,108 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * Ecovec24 sdram self/auto-refresh setup code
- *
- *  Copyright (C) 2009 Magnus Damm
- */
-
-#include <linux/sys.h>
-#include <linux/errno.h>
-#include <linux/linkage.h>
-#include <asm/asm-offsets.h>
-#include <asm/suspend.h>
-#include <asm/romimage-macros.h>
-
-/* code to enter and leave self-refresh. must be self-contained.
- * this code will be copied to on-chip memory and executed from there.
- */
-	.balign 4
-ENTRY(ecovec24_sdram_enter_start)
-
-	/* DBSC: put memory in self-refresh mode */
-
-	ED 0xFD000010, 0x00000000 /* DBEN */
-	ED 0xFD000040, 0x00000000 /* DBRFPDN0 */
-	ED 0xFD000014, 0x00000002 /* DBCMDCNT (PALL) */
-	ED 0xFD000014, 0x00000004 /* DBCMDCNT (REF) */
-	ED 0xFD000040, 0x00000001 /* DBRFPDN0 */
-
-	rts
-	 nop
-
-ENTRY(ecovec24_sdram_enter_end)
-
-	.balign 4
-ENTRY(ecovec24_sdram_leave_start)
-
-	mov.l	@(SH_SLEEP_MODE, r5), r0
-	tst	#SUSP_SH_RSTANDBY, r0
-	bf	resume_rstandby
-
-	/* DBSC: put memory in auto-refresh mode */
-
-	ED 0xFD000040, 0x00000000 /* DBRFPDN0 */
-	WAIT 1
-	ED 0xFD000014, 0x00000002 /* DBCMDCNT (PALL) */
-	ED 0xFD000014, 0x00000004 /* DBCMDCNT (REF) */
-	ED 0xFD000010, 0x00000001 /* DBEN */
-	ED 0xFD000040, 0x00010000 /* DBRFPDN0 */
-
-	rts
-	 nop
-
-resume_rstandby:
-
-	/* DBSC: re-initialize and put in auto-refresh */
-
-	ED 0xFD000108, 0x00000181 /* DBPDCNT0 */
-	ED 0xFD000020, 0x015B0002 /* DBCONF */
-	ED 0xFD000030, 0x03071502 /* DBTR0 */
-	ED 0xFD000034, 0x02020102 /* DBTR1 */
-	ED 0xFD000038, 0x01090405 /* DBTR2 */
-	ED 0xFD00003C, 0x00000002 /* DBTR3 */
-	ED 0xFD000008, 0x00000005 /* DBKIND */
-	ED 0xFD000040, 0x00000001 /* DBRFPDN0 */
-	ED 0xFD000040, 0x00000000 /* DBRFPDN0 */
-	ED 0xFD000018, 0x00000001 /* DBCKECNT */
-
-	mov	#100,r0
-WAIT_400NS:
-	dt	r0
-	bf	WAIT_400NS
-
-	ED 0xFD000014, 0x00000002 /* DBCMDCNT (PALL) */
-	ED 0xFD000060, 0x00020000 /* DBMRCNT (EMR2) */
-	ED 0xFD000060, 0x00030000 /* DBMRCNT (EMR3) */
-	ED 0xFD000060, 0x00010004 /* DBMRCNT (EMR) */
-	ED 0xFD000060, 0x00000532 /* DBMRCNT (MRS) */
-	ED 0xFD000014, 0x00000002 /* DBCMDCNT (PALL) */
-	ED 0xFD000014, 0x00000004 /* DBCMDCNT (REF) */
-	ED 0xFD000014, 0x00000004 /* DBCMDCNT (REF) */
-	ED 0xFD000060, 0x00000432 /* DBMRCNT (MRS) */
-	ED 0xFD000060, 0x000103c0 /* DBMRCNT (EMR) */
-	ED 0xFD000060, 0x00010040 /* DBMRCNT (EMR) */
-
-	mov	#100,r0
-WAIT_400NS_2:
-	dt	r0
-	bf	WAIT_400NS_2
-
-	ED 0xFD000010, 0x00000001 /* DBEN */
-	ED 0xFD000044, 0x0000050f /* DBRFPDN1 */
-	ED 0xFD000048, 0x236800e6 /* DBRFPDN2 */
-
-	mov.l	DUMMY,r0
-	mov.l	@r0, r1 /* force single dummy read */
-
-	ED 0xFD000014, 0x00000002 /* DBCMDCNT (PALL) */
-	ED 0xFD000014, 0x00000004 /* DBCMDCNT (REF) */
-	ED 0xFD000108, 0x00000080 /* DBPDCNT0 */
-	ED 0xFD000040, 0x00010000 /* DBRFPDN0 */
-
-	rts
-	 nop
-
-	.balign 4
-DUMMY:	.long	0xac400000
-
-ENTRY(ecovec24_sdram_leave_end)
diff --git a/arch/sh/boards/mach-ecovec24/setup.c b/arch/sh/boards/mach-ecovec24/setup.c
deleted file mode 100644
index 674da7ebd8b7f5..00000000000000
--- a/arch/sh/boards/mach-ecovec24/setup.c
+++ /dev/null
@@ -1,1521 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (C) 2009 Renesas Solutions Corp.
- *
- * Kuninori Morimoto <morimoto.kuninori@renesas.com>
- */
-#include <asm/clock.h>
-#include <asm/heartbeat.h>
-#include <asm/suspend.h>
-#include <cpu/sh7724.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/i2c.h>
-#include <linux/io.h>
-#include <linux/init.h>
-#include <linux/input.h>
-#include <linux/input/sh_keysc.h>
-#include <linux/interrupt.h>
-#include <linux/memblock.h>
-#include <linux/mfd/tmio.h>
-#include <linux/mmc/host.h>
-#include <linux/platform_data/sh_mmcif.h>
-#include <linux/mtd/physmap.h>
-#include <linux/gpio.h>
-#include <linux/gpio/machine.h>
-#include <linux/platform_data/gpio_backlight.h>
-#include <linux/platform_data/tsc2007.h>
-#include <linux/platform_device.h>
-#include <linux/regulator/fixed.h>
-#include <linux/regulator/machine.h>
-#include <linux/sh_eth.h>
-#include <linux/sh_intc.h>
-#include <linux/spi/mmc_spi.h>
-#include <linux/spi/sh_msiof.h>
-#include <linux/spi/spi.h>
-#include <linux/usb/r8a66597.h>
-#include <linux/usb/renesas_usbhs.h>
-#include <linux/videodev2.h>
-#include <linux/dma-map-ops.h>
-
-#include <media/drv-intf/renesas-ceu.h>
-#include <media/i2c/mt9t112.h>
-#include <media/i2c/tw9910.h>
-
-#include <sound/sh_fsi.h>
-#include <sound/simple_card.h>
-
-#include <video/sh_mobile_lcdc.h>
-
-/*
- *  Address      Interface        BusWidth
- *-----------------------------------------
- *  0x0000_0000  uboot            16bit
- *  0x0004_0000  Linux romImage   16bit
- *  0x0014_0000  MTD for Linux    16bit
- *  0x0400_0000  Internal I/O     16/32bit
- *  0x0800_0000  DRAM             32bit
- *  0x1800_0000  MFI              16bit
- */
-
-/* SWITCH
- *------------------------------
- * DS2[1] = FlashROM write protect  ON     : write protect
- *                                  OFF    : No write protect
- * DS2[2] = RMII / TS, SCIF         ON     : RMII
- *                                  OFF    : TS, SCIF3
- * DS2[3] = Camera / Video          ON     : Camera
- *                                  OFF    : NTSC/PAL (IN)
- * DS2[5] = NTSC_OUT Clock          ON     : On board OSC
- *                                  OFF    : SH7724 DV_CLK
- * DS2[6-7] = MMC / SD              ON-OFF : SD
- *                                  OFF-ON : MMC
- */
-
-/*
- * FSI - DA7210
- *
- * it needs amixer settings for playing
- *
- * amixer set 'HeadPhone' 80
- * amixer set 'Out Mixer Left DAC Left' on
- * amixer set 'Out Mixer Right DAC Right' on
- */
-
-#define CEU_BUFFER_MEMORY_SIZE		(4 << 20)
-static phys_addr_t ceu0_dma_membase;
-static phys_addr_t ceu1_dma_membase;
-
-/* Heartbeat */
-static unsigned char led_pos[] = { 0, 1, 2, 3 };
-
-static struct heartbeat_data heartbeat_data = {
-	.nr_bits = 4,
-	.bit_pos = led_pos,
-};
-
-static struct resource heartbeat_resource = {
-	.start  = 0xA405012C, /* PTG */
-	.end    = 0xA405012E - 1,
-	.flags  = IORESOURCE_MEM | IORESOURCE_MEM_8BIT,
-};
-
-static struct platform_device heartbeat_device = {
-	.name           = "heartbeat",
-	.id             = -1,
-	.dev = {
-		.platform_data = &heartbeat_data,
-	},
-	.num_resources  = 1,
-	.resource       = &heartbeat_resource,
-};
-
-/* MTD */
-static struct mtd_partition nor_flash_partitions[] = {
-	{
-		.name = "boot loader",
-		.offset = 0,
-		.size = (5 * 1024 * 1024),
-		.mask_flags = MTD_WRITEABLE,  /* force read-only */
-	}, {
-		.name = "free-area",
-		.offset = MTDPART_OFS_APPEND,
-		.size = MTDPART_SIZ_FULL,
-	},
-};
-
-static struct physmap_flash_data nor_flash_data = {
-	.width		= 2,
-	.parts		= nor_flash_partitions,
-	.nr_parts	= ARRAY_SIZE(nor_flash_partitions),
-};
-
-static struct resource nor_flash_resources[] = {
-	[0] = {
-		.name	= "NOR Flash",
-		.start	= 0x00000000,
-		.end	= 0x03ffffff,
-		.flags	= IORESOURCE_MEM,
-	}
-};
-
-static struct platform_device nor_flash_device = {
-	.name		= "physmap-flash",
-	.resource	= nor_flash_resources,
-	.num_resources	= ARRAY_SIZE(nor_flash_resources),
-	.dev		= {
-		.platform_data = &nor_flash_data,
-	},
-};
-
-/* SH Eth */
-#define SH_ETH_ADDR	(0xA4600000)
-static struct resource sh_eth_resources[] = {
-	[0] = {
-		.start = SH_ETH_ADDR,
-		.end   = SH_ETH_ADDR + 0x1FC,
-		.flags = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start = evt2irq(0xd60),
-		.flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
-	},
-};
-
-static struct sh_eth_plat_data sh_eth_plat = {
-	.phy = 0x1f, /* SMSC LAN8700 */
-	.phy_interface = PHY_INTERFACE_MODE_MII,
-	.ether_link_active_low = 1
-};
-
-static struct platform_device sh_eth_device = {
-	.name = "sh7724-ether",
-	.id = 0,
-	.dev = {
-		.platform_data = &sh_eth_plat,
-	},
-	.num_resources = ARRAY_SIZE(sh_eth_resources),
-	.resource = sh_eth_resources,
-};
-
-/* USB0 host */
-static void usb0_port_power(int port, int power)
-{
-	gpio_set_value(GPIO_PTB4, power);
-}
-
-static struct r8a66597_platdata usb0_host_data = {
-	.on_chip = 1,
-	.port_power = usb0_port_power,
-};
-
-static struct resource usb0_host_resources[] = {
-	[0] = {
-		.start	= 0xa4d80000,
-		.end	= 0xa4d80124 - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0xa20),
-		.end	= evt2irq(0xa20),
-		.flags	= IORESOURCE_IRQ | IRQF_TRIGGER_LOW,
-	},
-};
-
-static struct platform_device usb0_host_device = {
-	.name		= "r8a66597_hcd",
-	.id		= 0,
-	.dev = {
-		.dma_mask		= NULL,         /*  not use dma */
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &usb0_host_data,
-	},
-	.num_resources	= ARRAY_SIZE(usb0_host_resources),
-	.resource	= usb0_host_resources,
-};
-
-/* USB1 host/function */
-static void usb1_port_power(int port, int power)
-{
-	gpio_set_value(GPIO_PTB5, power);
-}
-
-static struct r8a66597_platdata usb1_common_data = {
-	.on_chip = 1,
-	.port_power = usb1_port_power,
-};
-
-static struct resource usb1_common_resources[] = {
-	[0] = {
-		.start	= 0xa4d90000,
-		.end	= 0xa4d90124 - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0xa40),
-		.end	= evt2irq(0xa40),
-		.flags	= IORESOURCE_IRQ | IRQF_TRIGGER_LOW,
-	},
-};
-
-static struct platform_device usb1_common_device = {
-	/* .name will be added in arch_setup */
-	.id		= 1,
-	.dev = {
-		.dma_mask		= NULL,         /*  not use dma */
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &usb1_common_data,
-	},
-	.num_resources	= ARRAY_SIZE(usb1_common_resources),
-	.resource	= usb1_common_resources,
-};
-
-/*
- * USBHS
- */
-static int usbhs_get_id(struct platform_device *pdev)
-{
-	return gpio_get_value(GPIO_PTB3);
-}
-
-static int usbhs_phy_reset(struct platform_device *pdev)
-{
-	/* enable vbus if HOST */
-	if (!gpio_get_value(GPIO_PTB3))
-		gpio_set_value(GPIO_PTB5, 1);
-
-	return 0;
-}
-
-static struct renesas_usbhs_platform_info usbhs_info = {
-	.platform_callback = {
-		.get_id		= usbhs_get_id,
-		.phy_reset	= usbhs_phy_reset,
-	},
-	.driver_param = {
-		.buswait_bwait		= 4,
-		.detection_delay	= 5,
-		.d0_tx_id = SHDMA_SLAVE_USB1D0_TX,
-		.d0_rx_id = SHDMA_SLAVE_USB1D0_RX,
-		.d1_tx_id = SHDMA_SLAVE_USB1D1_TX,
-		.d1_rx_id = SHDMA_SLAVE_USB1D1_RX,
-	},
-};
-
-static struct resource usbhs_resources[] = {
-	[0] = {
-		.start	= 0xa4d90000,
-		.end	= 0xa4d90124 - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0xa40),
-		.end	= evt2irq(0xa40),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device usbhs_device = {
-	.name	= "renesas_usbhs",
-	.id	= 1,
-	.dev = {
-		.dma_mask		= NULL,         /*  not use dma */
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &usbhs_info,
-	},
-	.num_resources	= ARRAY_SIZE(usbhs_resources),
-	.resource	= usbhs_resources,
-};
-
-/* LCDC and backlight */
-static const struct fb_videomode ecovec_lcd_modes[] = {
-	{
-		.name		= "Panel",
-		.xres		= 800,
-		.yres		= 480,
-		.left_margin	= 220,
-		.right_margin	= 110,
-		.hsync_len	= 70,
-		.upper_margin	= 20,
-		.lower_margin	= 5,
-		.vsync_len	= 5,
-		.sync		= 0, /* hsync and vsync are active low */
-	},
-};
-
-static const struct fb_videomode ecovec_dvi_modes[] = {
-	{
-		.name		= "DVI",
-		.xres		= 1280,
-		.yres		= 720,
-		.left_margin	= 220,
-		.right_margin	= 110,
-		.hsync_len	= 40,
-		.upper_margin	= 20,
-		.lower_margin	= 5,
-		.vsync_len	= 5,
-		.sync = 0, /* hsync and vsync are active low */
-	},
-};
-
-static struct sh_mobile_lcdc_info lcdc_info = {
-	.ch[0] = {
-		.interface_type = RGB18,
-		.chan = LCDC_CHAN_MAINLCD,
-		.fourcc = V4L2_PIX_FMT_RGB565,
-		.panel_cfg = { /* 7.0 inch */
-			.width = 152,
-			.height = 91,
-		},
-	}
-};
-
-static struct resource lcdc_resources[] = {
-	[0] = {
-		.name	= "LCDC",
-		.start	= 0xfe940000,
-		.end	= 0xfe942fff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0xf40),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device lcdc_device = {
-	.name		= "sh_mobile_lcdc_fb",
-	.num_resources	= ARRAY_SIZE(lcdc_resources),
-	.resource	= lcdc_resources,
-	.dev		= {
-		.platform_data	= &lcdc_info,
-	},
-};
-
-static struct gpiod_lookup_table gpio_backlight_lookup = {
-	.dev_id		= "gpio-backlight.0",
-	.table = {
-		GPIO_LOOKUP("sh7724_pfc", GPIO_PTR1, NULL, GPIO_ACTIVE_HIGH),
-		{ }
-	},
-};
-
-static struct property_entry gpio_backlight_props[] = {
-	PROPERTY_ENTRY_BOOL("default-on"),
-	{ }
-};
-
-static struct gpio_backlight_platform_data gpio_backlight_data = {
-	.fbdev = &lcdc_device.dev,
-};
-
-static const struct platform_device_info gpio_backlight_device_info = {
-	.name = "gpio-backlight",
-	.data = &gpio_backlight_data,
-	.size_data = sizeof(gpio_backlight_data),
-	.properties = gpio_backlight_props,
-};
-
-static struct platform_device *gpio_backlight_device;
-
-/* CEU0 */
-static struct ceu_platform_data ceu0_pdata = {
-	.num_subdevs			= 2,
-	.subdevs = {
-		{ /* [0] = mt9t112  */
-			.flags		= 0,
-			.bus_width	= 8,
-			.bus_shift	= 0,
-			.i2c_adapter_id	= 0,
-			.i2c_address	= 0x3c,
-		},
-		{ /* [1] = tw9910  */
-			.flags		= 0,
-			.bus_width	= 8,
-			.bus_shift	= 0,
-			.i2c_adapter_id	= 0,
-			.i2c_address	= 0x45,
-		},
-	},
-};
-
-static struct resource ceu0_resources[] = {
-	[0] = {
-		.name	= "CEU0",
-		.start	= 0xfe910000,
-		.end	= 0xfe91009f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0x880),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device ceu0_device = {
-	.name		= "renesas-ceu",
-	.id             = 0, /* ceu.0 */
-	.num_resources	= ARRAY_SIZE(ceu0_resources),
-	.resource	= ceu0_resources,
-	.dev	= {
-		.platform_data	= &ceu0_pdata,
-	},
-};
-
-/* CEU1 */
-static struct ceu_platform_data ceu1_pdata = {
-	.num_subdevs			= 1,
-	.subdevs = {
-		{ /* [0] = mt9t112  */
-			.flags		= 0,
-			.bus_width	= 8,
-			.bus_shift	= 0,
-			.i2c_adapter_id	= 1,
-			.i2c_address	= 0x3c,
-		},
-	},
-};
-
-static struct resource ceu1_resources[] = {
-	[0] = {
-		.name	= "CEU1",
-		.start	= 0xfe914000,
-		.end	= 0xfe91409f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0x9e0),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device ceu1_device = {
-	.name		= "renesas-ceu",
-	.id             = 1, /* ceu.1 */
-	.num_resources	= ARRAY_SIZE(ceu1_resources),
-	.resource	= ceu1_resources,
-	.dev	= {
-		.platform_data	= &ceu1_pdata,
-	},
-};
-
-/* Power up/down GPIOs for camera devices and video decoder */
-static struct gpiod_lookup_table tw9910_gpios = {
-	.dev_id		= "0-0045",
-	.table		= {
-		GPIO_LOOKUP("sh7724_pfc", GPIO_PTU2, "pdn", GPIO_ACTIVE_HIGH),
-	},
-};
-
-static struct gpiod_lookup_table mt9t112_0_gpios = {
-	.dev_id		= "0-003c",
-	.table		= {
-		GPIO_LOOKUP("sh7724_pfc", GPIO_PTA3, "standby",
-			    GPIO_ACTIVE_HIGH),
-	},
-};
-
-static struct gpiod_lookup_table mt9t112_1_gpios = {
-	.dev_id		= "1-003c",
-	.table		= {
-		GPIO_LOOKUP("sh7724_pfc", GPIO_PTA4, "standby",
-			    GPIO_ACTIVE_HIGH),
-	},
-};
-
-/* I2C device */
-static struct tw9910_video_info tw9910_info = {
-	.buswidth	= 8,
-	.mpout		= TW9910_MPO_FIELD,
-};
-
-static struct mt9t112_platform_data mt9t112_0_pdata = {
-	.flags = MT9T112_FLAG_PCLK_RISING_EDGE,
-	.divider = { 0x49, 0x6, 0, 6, 0, 9, 9, 6, 0 }, /* for 24MHz */
-};
-
-static struct mt9t112_platform_data mt9t112_1_pdata = {
-	.flags = MT9T112_FLAG_PCLK_RISING_EDGE,
-	.divider = { 0x49, 0x6, 0, 6, 0, 9, 9, 6, 0 }, /* for 24MHz */
-};
-
-static struct i2c_board_info i2c0_devices[] = {
-	{
-		I2C_BOARD_INFO("da7210", 0x1a),
-	},
-	{
-		I2C_BOARD_INFO("tw9910", 0x45),
-		.platform_data = &tw9910_info,
-	},
-	{
-		/* 1st camera */
-		I2C_BOARD_INFO("mt9t112", 0x3c),
-		.platform_data = &mt9t112_0_pdata,
-	},
-};
-
-static struct i2c_board_info i2c1_devices[] = {
-	{
-		I2C_BOARD_INFO("r2025sd", 0x32),
-	},
-	{
-		I2C_BOARD_INFO("lis3lv02d", 0x1c),
-		.irq = evt2irq(0x620),
-	},
-	{
-		/* 2nd camera */
-		I2C_BOARD_INFO("mt9t112", 0x3c),
-		.platform_data = &mt9t112_1_pdata,
-	},
-};
-
-/* KEYSC */
-static struct sh_keysc_info keysc_info = {
-	.mode		= SH_KEYSC_MODE_1,
-	.scan_timing	= 3,
-	.delay		= 50,
-	.kycr2_delay	= 100,
-	.keycodes	= { KEY_1, 0, 0, 0, 0,
-			    KEY_2, 0, 0, 0, 0,
-			    KEY_3, 0, 0, 0, 0,
-			    KEY_4, 0, 0, 0, 0,
-			    KEY_5, 0, 0, 0, 0,
-			    KEY_6, 0, 0, 0, 0, },
-};
-
-static struct resource keysc_resources[] = {
-	[0] = {
-		.name	= "KEYSC",
-		.start  = 0x044b0000,
-		.end    = 0x044b000f,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0xbe0),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device keysc_device = {
-	.name           = "sh_keysc",
-	.id             = 0, /* keysc0 clock */
-	.num_resources  = ARRAY_SIZE(keysc_resources),
-	.resource       = keysc_resources,
-	.dev	= {
-		.platform_data	= &keysc_info,
-	},
-};
-
-/* TouchScreen */
-#define IRQ0 evt2irq(0x600)
-
-static int ts_get_pendown_state(struct device *dev)
-{
-	int val = 0;
-	gpio_free(GPIO_FN_INTC_IRQ0);
-	gpio_request(GPIO_PTZ0, NULL);
-	gpio_direction_input(GPIO_PTZ0);
-
-	val = gpio_get_value(GPIO_PTZ0);
-
-	gpio_free(GPIO_PTZ0);
-	gpio_request(GPIO_FN_INTC_IRQ0, NULL);
-
-	return val ? 0 : 1;
-}
-
-static int ts_init(void)
-{
-	gpio_request(GPIO_FN_INTC_IRQ0, NULL);
-	return 0;
-}
-
-static struct tsc2007_platform_data tsc2007_info = {
-	.model			= 2007,
-	.x_plate_ohms		= 180,
-	.get_pendown_state	= ts_get_pendown_state,
-	.init_platform_hw	= ts_init,
-};
-
-static struct i2c_board_info ts_i2c_clients = {
-	I2C_BOARD_INFO("tsc2007", 0x48),
-	.type		= "tsc2007",
-	.platform_data	= &tsc2007_info,
-	.irq		= IRQ0,
-};
-
-static struct regulator_consumer_supply cn12_power_consumers[] =
-{
-	REGULATOR_SUPPLY("vmmc", "sh_mmcif.0"),
-	REGULATOR_SUPPLY("vqmmc", "sh_mmcif.0"),
-	REGULATOR_SUPPLY("vmmc", "sh_mobile_sdhi.1"),
-	REGULATOR_SUPPLY("vqmmc", "sh_mobile_sdhi.1"),
-};
-
-static struct regulator_init_data cn12_power_init_data = {
-	.constraints = {
-		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
-	},
-	.num_consumer_supplies  = ARRAY_SIZE(cn12_power_consumers),
-	.consumer_supplies      = cn12_power_consumers,
-};
-
-static struct fixed_voltage_config cn12_power_info = {
-	.supply_name = "CN12 SD/MMC Vdd",
-	.microvolts = 3300000,
-	.init_data = &cn12_power_init_data,
-};
-
-static struct platform_device cn12_power = {
-	.name = "reg-fixed-voltage",
-	.id   = 0,
-	.dev  = {
-		.platform_data = &cn12_power_info,
-	},
-};
-
-static struct gpiod_lookup_table cn12_power_gpiod_table = {
-	.dev_id = "reg-fixed-voltage.0",
-	.table = {
-		/* Offset 7 on port B */
-		GPIO_LOOKUP("sh7724_pfc", GPIO_PTB7,
-			    NULL, GPIO_ACTIVE_HIGH),
-		{ },
-	},
-};
-
-#if defined(CONFIG_MMC_SDHI) || defined(CONFIG_MMC_SDHI_MODULE)
-/* SDHI0 */
-static struct regulator_consumer_supply sdhi0_power_consumers[] =
-{
-	REGULATOR_SUPPLY("vmmc", "sh_mobile_sdhi.0"),
-	REGULATOR_SUPPLY("vqmmc", "sh_mobile_sdhi.0"),
-};
-
-static struct regulator_init_data sdhi0_power_init_data = {
-	.constraints = {
-		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
-	},
-	.num_consumer_supplies  = ARRAY_SIZE(sdhi0_power_consumers),
-	.consumer_supplies      = sdhi0_power_consumers,
-};
-
-static struct fixed_voltage_config sdhi0_power_info = {
-	.supply_name = "CN11 SD/MMC Vdd",
-	.microvolts = 3300000,
-	.init_data = &sdhi0_power_init_data,
-};
-
-static struct platform_device sdhi0_power = {
-	.name = "reg-fixed-voltage",
-	.id   = 1,
-	.dev  = {
-		.platform_data = &sdhi0_power_info,
-	},
-};
-
-static struct gpiod_lookup_table sdhi0_power_gpiod_table = {
-	.dev_id = "reg-fixed-voltage.1",
-	.table = {
-		/* Offset 6 on port B */
-		GPIO_LOOKUP("sh7724_pfc", GPIO_PTB6,
-			    NULL, GPIO_ACTIVE_HIGH),
-		{ },
-	},
-};
-
-static struct gpiod_lookup_table sdhi0_gpio_table = {
-	.dev_id = "sh_mobile_sdhi.0",
-	.table = {
-		/* Card detect */
-		GPIO_LOOKUP("sh7724_pfc", GPIO_PTY7, "cd", GPIO_ACTIVE_LOW),
-		{ },
-	},
-};
-
-static struct tmio_mmc_data sdhi0_info = {
-	.chan_priv_tx	= (void *)SHDMA_SLAVE_SDHI0_TX,
-	.chan_priv_rx	= (void *)SHDMA_SLAVE_SDHI0_RX,
-	.capabilities	= MMC_CAP_SDIO_IRQ | MMC_CAP_POWER_OFF_CARD |
-			  MMC_CAP_NEEDS_POLL,
-};
-
-static struct resource sdhi0_resources[] = {
-	[0] = {
-		.name	= "SDHI0",
-		.start  = 0x04ce0000,
-		.end    = 0x04ce00ff,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0xe80),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device sdhi0_device = {
-	.name           = "sh_mobile_sdhi",
-	.num_resources  = ARRAY_SIZE(sdhi0_resources),
-	.resource       = sdhi0_resources,
-	.id             = 0,
-	.dev	= {
-		.platform_data	= &sdhi0_info,
-	},
-};
-
-#if !defined(CONFIG_MMC_SH_MMCIF) && !defined(CONFIG_MMC_SH_MMCIF_MODULE)
-/* SDHI1 */
-static struct tmio_mmc_data sdhi1_info = {
-	.chan_priv_tx	= (void *)SHDMA_SLAVE_SDHI1_TX,
-	.chan_priv_rx	= (void *)SHDMA_SLAVE_SDHI1_RX,
-	.capabilities	= MMC_CAP_SDIO_IRQ | MMC_CAP_POWER_OFF_CARD |
-			  MMC_CAP_NEEDS_POLL,
-};
-
-static struct gpiod_lookup_table sdhi1_gpio_table = {
-	.dev_id = "sh_mobile_sdhi.1",
-	.table = {
-		/* Card detect */
-		GPIO_LOOKUP("sh7724_pfc", GPIO_PTW7, "cd", GPIO_ACTIVE_LOW),
-		{ },
-	},
-};
-
-static struct resource sdhi1_resources[] = {
-	[0] = {
-		.name	= "SDHI1",
-		.start  = 0x04cf0000,
-		.end    = 0x04cf00ff,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0x4e0),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device sdhi1_device = {
-	.name           = "sh_mobile_sdhi",
-	.num_resources  = ARRAY_SIZE(sdhi1_resources),
-	.resource       = sdhi1_resources,
-	.id             = 1,
-	.dev	= {
-		.platform_data	= &sdhi1_info,
-	},
-};
-#endif /* CONFIG_MMC_SH_MMCIF */
-
-#else
-
-/* MMC SPI */
-static void mmc_spi_setpower(struct device *dev, unsigned int maskval)
-{
-	gpio_set_value(GPIO_PTB6, maskval ? 1 : 0);
-}
-
-static struct mmc_spi_platform_data mmc_spi_info = {
-	.caps = MMC_CAP_NEEDS_POLL,
-	.caps2 = MMC_CAP2_RO_ACTIVE_HIGH,
-	.ocr_mask = MMC_VDD_32_33 | MMC_VDD_33_34, /* 3.3V only */
-	.setpower = mmc_spi_setpower,
-};
-
-static struct gpiod_lookup_table mmc_spi_gpio_table = {
-	.dev_id = "mmc_spi.0", /* device "mmc_spi" @ CS0 */
-	.table = {
-		/* Card detect */
-		GPIO_LOOKUP_IDX("sh7724_pfc", GPIO_PTY7, NULL, 0,
-				GPIO_ACTIVE_LOW),
-		/* Write protect */
-		GPIO_LOOKUP_IDX("sh7724_pfc", GPIO_PTY6, NULL, 1,
-				GPIO_ACTIVE_HIGH),
-		{ },
-	},
-};
-
-static struct spi_board_info spi_bus[] = {
-	{
-		.modalias	= "mmc_spi",
-		.platform_data	= &mmc_spi_info,
-		.max_speed_hz	= 5000000,
-		.mode		= SPI_MODE_0,
-	},
-};
-
-/* MSIOF0 */
-static struct sh_msiof_spi_info msiof0_data = {
-	.num_chipselect = 1,
-};
-
-static struct resource msiof0_resources[] = {
-	[0] = {
-		.name	= "MSIOF0",
-		.start	= 0xa4c40000,
-		.end	= 0xa4c40063,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0xc80),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device msiof0_device = {
-	.name		= "spi_sh_msiof",
-	.id		= 0, /* MSIOF0 */
-	.dev = {
-		.platform_data = &msiof0_data,
-	},
-	.num_resources	= ARRAY_SIZE(msiof0_resources),
-	.resource	= msiof0_resources,
-};
-
-static struct gpiod_lookup_table msiof_gpio_table = {
-	.dev_id = "spi_sh_msiof.0",
-	.table = {
-		GPIO_LOOKUP("sh7724_pfc", GPIO_PTM4, "cs", GPIO_ACTIVE_HIGH),
-		{ },
-	},
-};
-
-#endif
-
-/* FSI */
-static struct resource fsi_resources[] = {
-	[0] = {
-		.name	= "FSI",
-		.start	= 0xFE3C0000,
-		.end	= 0xFE3C021d,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0xf80),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device fsi_device = {
-	.name		= "sh_fsi",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(fsi_resources),
-	.resource	= fsi_resources,
-};
-
-static struct asoc_simple_card_info fsi_da7210_info = {
-	.name		= "DA7210",
-	.card		= "FSIB-DA7210",
-	.codec		= "da7210.0-001a",
-	.platform	= "sh_fsi.0",
-	.daifmt		= SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBP_CFP,
-	.cpu_dai = {
-		.name	= "fsib-dai",
-	},
-	.codec_dai = {
-		.name	= "da7210-hifi",
-	},
-};
-
-static struct platform_device fsi_da7210_device = {
-	.name	= "asoc-simple-card",
-	.dev	= {
-		.platform_data	= &fsi_da7210_info,
-		.coherent_dma_mask = DMA_BIT_MASK(32),
-		.dma_mask = &fsi_da7210_device.dev.coherent_dma_mask,
-	},
-};
-
-
-/* IrDA */
-static struct resource irda_resources[] = {
-	[0] = {
-		.name	= "IrDA",
-		.start  = 0xA45D0000,
-		.end    = 0xA45D0049,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0x480),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device irda_device = {
-	.name           = "sh_sir",
-	.num_resources  = ARRAY_SIZE(irda_resources),
-	.resource       = irda_resources,
-};
-
-#include <media/i2c/ak881x.h>
-#include <media/drv-intf/sh_vou.h>
-
-static struct ak881x_pdata ak881x_pdata = {
-	.flags = AK881X_IF_MODE_SLAVE,
-};
-
-static struct i2c_board_info ak8813 = {
-	I2C_BOARD_INFO("ak8813", 0x20),
-	.platform_data = &ak881x_pdata,
-};
-
-static struct sh_vou_pdata sh_vou_pdata = {
-	.bus_fmt	= SH_VOU_BUS_8BIT,
-	.flags		= SH_VOU_HSYNC_LOW | SH_VOU_VSYNC_LOW,
-	.board_info	= &ak8813,
-	.i2c_adap	= 0,
-};
-
-static struct resource sh_vou_resources[] = {
-	[0] = {
-		.start  = 0xfe960000,
-		.end    = 0xfe962043,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0x8e0),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device vou_device = {
-	.name           = "sh-vou",
-	.id		= -1,
-	.num_resources  = ARRAY_SIZE(sh_vou_resources),
-	.resource       = sh_vou_resources,
-	.dev		= {
-		.platform_data	= &sh_vou_pdata,
-	},
-};
-
-#if defined(CONFIG_MMC_SH_MMCIF) || defined(CONFIG_MMC_SH_MMCIF_MODULE)
-/* SH_MMCIF */
-static struct resource sh_mmcif_resources[] = {
-	[0] = {
-		.name	= "SH_MMCIF",
-		.start	= 0xA4CA0000,
-		.end	= 0xA4CA00FF,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* MMC2I */
-		.start	= evt2irq(0x5a0),
-		.flags	= IORESOURCE_IRQ,
-	},
-	[2] = {
-		/* MMC3I */
-		.start	= evt2irq(0x5c0),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct sh_mmcif_plat_data sh_mmcif_plat = {
-	.sup_pclk	= 0, /* SH7724: Max Pclk/2 */
-	.caps		= MMC_CAP_4_BIT_DATA |
-			  MMC_CAP_8_BIT_DATA |
-			  MMC_CAP_NEEDS_POLL,
-	.ocr		= MMC_VDD_32_33 | MMC_VDD_33_34,
-};
-
-static struct platform_device sh_mmcif_device = {
-	.name		= "sh_mmcif",
-	.id		= 0,
-	.dev		= {
-		.platform_data		= &sh_mmcif_plat,
-	},
-	.num_resources	= ARRAY_SIZE(sh_mmcif_resources),
-	.resource	= sh_mmcif_resources,
-};
-#endif
-
-static struct platform_device *ecovec_ceu_devices[] __initdata = {
-	&ceu0_device,
-	&ceu1_device,
-};
-
-static struct platform_device *ecovec_devices[] __initdata = {
-	&heartbeat_device,
-	&nor_flash_device,
-	&sh_eth_device,
-	&usb0_host_device,
-	&usb1_common_device,
-	&usbhs_device,
-	&lcdc_device,
-	&keysc_device,
-	&cn12_power,
-#if defined(CONFIG_MMC_SDHI) || defined(CONFIG_MMC_SDHI_MODULE)
-	&sdhi0_power,
-	&sdhi0_device,
-#if !defined(CONFIG_MMC_SH_MMCIF) && !defined(CONFIG_MMC_SH_MMCIF_MODULE)
-	&sdhi1_device,
-#endif
-#else
-	&msiof0_device,
-#endif
-	&fsi_device,
-	&fsi_da7210_device,
-	&irda_device,
-	&vou_device,
-#if defined(CONFIG_MMC_SH_MMCIF) || defined(CONFIG_MMC_SH_MMCIF_MODULE)
-	&sh_mmcif_device,
-#endif
-};
-
-#ifdef CONFIG_I2C
-#define EEPROM_ADDR 0x50
-static u8 mac_read(struct i2c_adapter *a, u8 command)
-{
-	struct i2c_msg msg[2];
-	u8 buf;
-	int ret;
-
-	msg[0].addr  = EEPROM_ADDR;
-	msg[0].flags = 0;
-	msg[0].len   = 1;
-	msg[0].buf   = &command;
-
-	msg[1].addr  = EEPROM_ADDR;
-	msg[1].flags = I2C_M_RD;
-	msg[1].len   = 1;
-	msg[1].buf   = &buf;
-
-	ret = i2c_transfer(a, msg, 2);
-	if (ret < 0) {
-		printk(KERN_ERR "error %d\n", ret);
-		buf = 0xff;
-	}
-
-	return buf;
-}
-
-static void __init sh_eth_init(struct sh_eth_plat_data *pd)
-{
-	struct i2c_adapter *a = i2c_get_adapter(1);
-	int i;
-
-	if (!a) {
-		pr_err("can not get I2C 1\n");
-		return;
-	}
-
-	/* read MAC address from EEPROM */
-	for (i = 0; i < sizeof(pd->mac_addr); i++) {
-		pd->mac_addr[i] = mac_read(a, 0x10 + i);
-		msleep(10);
-	}
-
-	i2c_put_adapter(a);
-}
-#else
-static void __init sh_eth_init(struct sh_eth_plat_data *pd)
-{
-	pr_err("unable to read sh_eth MAC address\n");
-}
-#endif
-
-#define PORT_HIZA 0xA4050158
-#define IODRIVEA  0xA405018A
-
-extern char ecovec24_sdram_enter_start;
-extern char ecovec24_sdram_enter_end;
-extern char ecovec24_sdram_leave_start;
-extern char ecovec24_sdram_leave_end;
-
-static int __init arch_setup(void)
-{
-	struct clk *clk;
-	bool cn12_enabled = false;
-
-	/* register board specific self-refresh code */
-	sh_mobile_register_self_refresh(SUSP_SH_STANDBY | SUSP_SH_SF |
-					SUSP_SH_RSTANDBY,
-					&ecovec24_sdram_enter_start,
-					&ecovec24_sdram_enter_end,
-					&ecovec24_sdram_leave_start,
-					&ecovec24_sdram_leave_end);
-
-	/* enable STATUS0, STATUS2 and PDSTATUS */
-	gpio_request(GPIO_FN_STATUS0, NULL);
-	gpio_request(GPIO_FN_STATUS2, NULL);
-	gpio_request(GPIO_FN_PDSTATUS, NULL);
-
-	/* enable SCIFA0 */
-	gpio_request(GPIO_FN_SCIF0_TXD, NULL);
-	gpio_request(GPIO_FN_SCIF0_RXD, NULL);
-
-	/* enable debug LED */
-	gpio_request(GPIO_PTG0, NULL);
-	gpio_request(GPIO_PTG1, NULL);
-	gpio_request(GPIO_PTG2, NULL);
-	gpio_request(GPIO_PTG3, NULL);
-	gpio_direction_output(GPIO_PTG0, 0);
-	gpio_direction_output(GPIO_PTG1, 0);
-	gpio_direction_output(GPIO_PTG2, 0);
-	gpio_direction_output(GPIO_PTG3, 0);
-	__raw_writew((__raw_readw(PORT_HIZA) & ~(0x1 << 1)) , PORT_HIZA);
-
-	/* enable SH-Eth */
-	gpio_request(GPIO_PTA1, NULL);
-	gpio_direction_output(GPIO_PTA1, 1);
-	mdelay(20);
-
-	gpio_request(GPIO_FN_RMII_RXD0,    NULL);
-	gpio_request(GPIO_FN_RMII_RXD1,    NULL);
-	gpio_request(GPIO_FN_RMII_TXD0,    NULL);
-	gpio_request(GPIO_FN_RMII_TXD1,    NULL);
-	gpio_request(GPIO_FN_RMII_REF_CLK, NULL);
-	gpio_request(GPIO_FN_RMII_TX_EN,   NULL);
-	gpio_request(GPIO_FN_RMII_RX_ER,   NULL);
-	gpio_request(GPIO_FN_RMII_CRS_DV,  NULL);
-	gpio_request(GPIO_FN_MDIO,         NULL);
-	gpio_request(GPIO_FN_MDC,          NULL);
-	gpio_request(GPIO_FN_LNKSTA,       NULL);
-
-	/* enable USB */
-	__raw_writew(0x0000, 0xA4D80000);
-	__raw_writew(0x0000, 0xA4D90000);
-	gpio_request(GPIO_PTB3,  NULL);
-	gpio_request(GPIO_PTB4,  NULL);
-	gpio_request(GPIO_PTB5,  NULL);
-	gpio_direction_input(GPIO_PTB3);
-	gpio_direction_output(GPIO_PTB4, 0);
-	gpio_direction_output(GPIO_PTB5, 0);
-	__raw_writew(0x0600, 0xa40501d4);
-	__raw_writew(0x0600, 0xa4050192);
-
-	if (gpio_get_value(GPIO_PTB3)) {
-		printk(KERN_INFO "USB1 function is selected\n");
-		usb1_common_device.name = "r8a66597_udc";
-	} else {
-		printk(KERN_INFO "USB1 host is selected\n");
-		usb1_common_device.name = "r8a66597_hcd";
-	}
-
-	/* enable LCDC */
-	gpio_request(GPIO_FN_LCDD23,   NULL);
-	gpio_request(GPIO_FN_LCDD22,   NULL);
-	gpio_request(GPIO_FN_LCDD21,   NULL);
-	gpio_request(GPIO_FN_LCDD20,   NULL);
-	gpio_request(GPIO_FN_LCDD19,   NULL);
-	gpio_request(GPIO_FN_LCDD18,   NULL);
-	gpio_request(GPIO_FN_LCDD17,   NULL);
-	gpio_request(GPIO_FN_LCDD16,   NULL);
-	gpio_request(GPIO_FN_LCDD15,   NULL);
-	gpio_request(GPIO_FN_LCDD14,   NULL);
-	gpio_request(GPIO_FN_LCDD13,   NULL);
-	gpio_request(GPIO_FN_LCDD12,   NULL);
-	gpio_request(GPIO_FN_LCDD11,   NULL);
-	gpio_request(GPIO_FN_LCDD10,   NULL);
-	gpio_request(GPIO_FN_LCDD9,    NULL);
-	gpio_request(GPIO_FN_LCDD8,    NULL);
-	gpio_request(GPIO_FN_LCDD7,    NULL);
-	gpio_request(GPIO_FN_LCDD6,    NULL);
-	gpio_request(GPIO_FN_LCDD5,    NULL);
-	gpio_request(GPIO_FN_LCDD4,    NULL);
-	gpio_request(GPIO_FN_LCDD3,    NULL);
-	gpio_request(GPIO_FN_LCDD2,    NULL);
-	gpio_request(GPIO_FN_LCDD1,    NULL);
-	gpio_request(GPIO_FN_LCDD0,    NULL);
-	gpio_request(GPIO_FN_LCDDISP,  NULL);
-	gpio_request(GPIO_FN_LCDHSYN,  NULL);
-	gpio_request(GPIO_FN_LCDDCK,   NULL);
-	gpio_request(GPIO_FN_LCDVSYN,  NULL);
-	gpio_request(GPIO_FN_LCDDON,   NULL);
-	gpio_request(GPIO_FN_LCDLCLK,  NULL);
-	__raw_writew((__raw_readw(PORT_HIZA) & ~0x0001), PORT_HIZA);
-
-	gpio_request(GPIO_PTE6, NULL);
-	gpio_request(GPIO_PTU1, NULL);
-	gpio_request(GPIO_PTA2, NULL);
-	gpio_direction_input(GPIO_PTE6);
-	gpio_direction_output(GPIO_PTU1, 0);
-	gpio_direction_output(GPIO_PTA2, 0);
-
-	/* I/O buffer drive ability is high */
-	__raw_writew((__raw_readw(IODRIVEA) & ~0x00c0) | 0x0080 , IODRIVEA);
-
-	if (gpio_get_value(GPIO_PTE6)) {
-		/* DVI */
-		lcdc_info.clock_source			= LCDC_CLK_EXTERNAL;
-		lcdc_info.ch[0].clock_divider		= 1;
-		lcdc_info.ch[0].lcd_modes		= ecovec_dvi_modes;
-		lcdc_info.ch[0].num_modes		= ARRAY_SIZE(ecovec_dvi_modes);
-
-		/* No backlight */
-		gpio_backlight_data.fbdev = NULL;
-
-		gpio_set_value(GPIO_PTA2, 1);
-		gpio_set_value(GPIO_PTU1, 1);
-	} else {
-		/* Panel */
-		lcdc_info.clock_source			= LCDC_CLK_PERIPHERAL;
-		lcdc_info.ch[0].clock_divider		= 2;
-		lcdc_info.ch[0].lcd_modes		= ecovec_lcd_modes;
-		lcdc_info.ch[0].num_modes		= ARRAY_SIZE(ecovec_lcd_modes);
-
-		/* FIXME
-		 *
-		 * LCDDON control is needed for Panel,
-		 * but current sh_mobile_lcdc driver doesn't control it.
-		 * It is temporary correspondence
-		 */
-		gpio_request(GPIO_PTF4, NULL);
-		gpio_direction_output(GPIO_PTF4, 1);
-
-		/* enable TouchScreen */
-		i2c_register_board_info(0, &ts_i2c_clients, 1);
-		irq_set_irq_type(IRQ0, IRQ_TYPE_LEVEL_LOW);
-	}
-
-	/* enable CEU0 */
-	gpio_request(GPIO_FN_VIO0_D15, NULL);
-	gpio_request(GPIO_FN_VIO0_D14, NULL);
-	gpio_request(GPIO_FN_VIO0_D13, NULL);
-	gpio_request(GPIO_FN_VIO0_D12, NULL);
-	gpio_request(GPIO_FN_VIO0_D11, NULL);
-	gpio_request(GPIO_FN_VIO0_D10, NULL);
-	gpio_request(GPIO_FN_VIO0_D9,  NULL);
-	gpio_request(GPIO_FN_VIO0_D8,  NULL);
-	gpio_request(GPIO_FN_VIO0_D7,  NULL);
-	gpio_request(GPIO_FN_VIO0_D6,  NULL);
-	gpio_request(GPIO_FN_VIO0_D5,  NULL);
-	gpio_request(GPIO_FN_VIO0_D4,  NULL);
-	gpio_request(GPIO_FN_VIO0_D3,  NULL);
-	gpio_request(GPIO_FN_VIO0_D2,  NULL);
-	gpio_request(GPIO_FN_VIO0_D1,  NULL);
-	gpio_request(GPIO_FN_VIO0_D0,  NULL);
-	gpio_request(GPIO_FN_VIO0_VD,  NULL);
-	gpio_request(GPIO_FN_VIO0_CLK, NULL);
-	gpio_request(GPIO_FN_VIO0_FLD, NULL);
-	gpio_request(GPIO_FN_VIO0_HD,  NULL);
-
-	/* enable CEU1 */
-	gpio_request(GPIO_FN_VIO1_D7,  NULL);
-	gpio_request(GPIO_FN_VIO1_D6,  NULL);
-	gpio_request(GPIO_FN_VIO1_D5,  NULL);
-	gpio_request(GPIO_FN_VIO1_D4,  NULL);
-	gpio_request(GPIO_FN_VIO1_D3,  NULL);
-	gpio_request(GPIO_FN_VIO1_D2,  NULL);
-	gpio_request(GPIO_FN_VIO1_D1,  NULL);
-	gpio_request(GPIO_FN_VIO1_D0,  NULL);
-	gpio_request(GPIO_FN_VIO1_FLD, NULL);
-	gpio_request(GPIO_FN_VIO1_HD,  NULL);
-	gpio_request(GPIO_FN_VIO1_VD,  NULL);
-	gpio_request(GPIO_FN_VIO1_CLK, NULL);
-
-	/* enable KEYSC */
-	gpio_request(GPIO_FN_KEYOUT5_IN5, NULL);
-	gpio_request(GPIO_FN_KEYOUT4_IN6, NULL);
-	gpio_request(GPIO_FN_KEYOUT3,     NULL);
-	gpio_request(GPIO_FN_KEYOUT2,     NULL);
-	gpio_request(GPIO_FN_KEYOUT1,     NULL);
-	gpio_request(GPIO_FN_KEYOUT0,     NULL);
-	gpio_request(GPIO_FN_KEYIN0,      NULL);
-
-	/* enable user debug switch */
-	gpio_request(GPIO_PTR0, NULL);
-	gpio_request(GPIO_PTR4, NULL);
-	gpio_request(GPIO_PTR5, NULL);
-	gpio_request(GPIO_PTR6, NULL);
-	gpio_direction_input(GPIO_PTR0);
-	gpio_direction_input(GPIO_PTR4);
-	gpio_direction_input(GPIO_PTR5);
-	gpio_direction_input(GPIO_PTR6);
-
-	/* SD-card slot CN11 */
-#if defined(CONFIG_MMC_SDHI) || defined(CONFIG_MMC_SDHI_MODULE)
-	/* enable SDHI0 on CN11 (needs DS2.4 set to ON) */
-	gpio_request(GPIO_FN_SDHI0WP,  NULL);
-	gpio_request(GPIO_FN_SDHI0CMD, NULL);
-	gpio_request(GPIO_FN_SDHI0CLK, NULL);
-	gpio_request(GPIO_FN_SDHI0D3,  NULL);
-	gpio_request(GPIO_FN_SDHI0D2,  NULL);
-	gpio_request(GPIO_FN_SDHI0D1,  NULL);
-	gpio_request(GPIO_FN_SDHI0D0,  NULL);
-#else
-	/* enable MSIOF0 on CN11 (needs DS2.4 set to OFF) */
-	gpio_request(GPIO_FN_MSIOF0_TXD, NULL);
-	gpio_request(GPIO_FN_MSIOF0_RXD, NULL);
-	gpio_request(GPIO_FN_MSIOF0_TSCK, NULL);
-	gpio_request(GPIO_PTB6, NULL); /* 3.3V power control */
-	gpio_direction_output(GPIO_PTB6, 0); /* disable power by default */
-
-	gpiod_add_lookup_table(&mmc_spi_gpio_table);
-	gpiod_add_lookup_table(&msiof_gpio_table);
-	spi_register_board_info(spi_bus, ARRAY_SIZE(spi_bus));
-#endif
-
-	/* MMC/SD-card slot CN12 */
-#if defined(CONFIG_MMC_SH_MMCIF) || defined(CONFIG_MMC_SH_MMCIF_MODULE)
-	/* enable MMCIF (needs DS2.6,7 set to OFF,ON) */
-	gpio_request(GPIO_FN_MMC_D7, NULL);
-	gpio_request(GPIO_FN_MMC_D6, NULL);
-	gpio_request(GPIO_FN_MMC_D5, NULL);
-	gpio_request(GPIO_FN_MMC_D4, NULL);
-	gpio_request(GPIO_FN_MMC_D3, NULL);
-	gpio_request(GPIO_FN_MMC_D2, NULL);
-	gpio_request(GPIO_FN_MMC_D1, NULL);
-	gpio_request(GPIO_FN_MMC_D0, NULL);
-	gpio_request(GPIO_FN_MMC_CLK, NULL);
-	gpio_request(GPIO_FN_MMC_CMD, NULL);
-
-	cn12_enabled = true;
-#elif defined(CONFIG_MMC_SDHI) || defined(CONFIG_MMC_SDHI_MODULE)
-	/* enable SDHI1 on CN12 (needs DS2.6,7 set to ON,OFF) */
-	gpio_request(GPIO_FN_SDHI1WP,  NULL);
-	gpio_request(GPIO_FN_SDHI1CMD, NULL);
-	gpio_request(GPIO_FN_SDHI1CLK, NULL);
-	gpio_request(GPIO_FN_SDHI1D3,  NULL);
-	gpio_request(GPIO_FN_SDHI1D2,  NULL);
-	gpio_request(GPIO_FN_SDHI1D1,  NULL);
-	gpio_request(GPIO_FN_SDHI1D0,  NULL);
-
-	cn12_enabled = true;
-#endif
-
-	if (cn12_enabled)
-		/* I/O buffer drive ability is high for CN12 */
-		__raw_writew((__raw_readw(IODRIVEA) & ~0x3000) | 0x2000,
-			     IODRIVEA);
-
-	/* enable FSI */
-	gpio_request(GPIO_FN_FSIMCKB,    NULL);
-	gpio_request(GPIO_FN_FSIIBSD,    NULL);
-	gpio_request(GPIO_FN_FSIOBSD,    NULL);
-	gpio_request(GPIO_FN_FSIIBBCK,   NULL);
-	gpio_request(GPIO_FN_FSIIBLRCK,  NULL);
-	gpio_request(GPIO_FN_FSIOBBCK,   NULL);
-	gpio_request(GPIO_FN_FSIOBLRCK,  NULL);
-	gpio_request(GPIO_FN_CLKAUDIOBO, NULL);
-
-	/* set SPU2 clock to 83.4 MHz */
-	clk = clk_get(NULL, "spu_clk");
-	if (!IS_ERR(clk)) {
-		clk_set_rate(clk, clk_round_rate(clk, 83333333));
-		clk_put(clk);
-	}
-
-	/* change parent of FSI B */
-	clk = clk_get(NULL, "fsib_clk");
-	if (!IS_ERR(clk)) {
-		/* 48kHz dummy clock was used to make sure 1/1 divide */
-		clk_set_rate(&sh7724_fsimckb_clk, 48000);
-		clk_set_parent(clk, &sh7724_fsimckb_clk);
-		clk_set_rate(clk, 48000);
-		clk_put(clk);
-	}
-
-	gpio_request(GPIO_PTU0, NULL);
-	gpio_direction_output(GPIO_PTU0, 0);
-	mdelay(20);
-
-	/* enable motion sensor */
-	gpio_request(GPIO_FN_INTC_IRQ1, NULL);
-	gpio_direction_input(GPIO_FN_INTC_IRQ1);
-
-	/* set VPU clock to 166 MHz */
-	clk = clk_get(NULL, "vpu_clk");
-	if (!IS_ERR(clk)) {
-		clk_set_rate(clk, clk_round_rate(clk, 166000000));
-		clk_put(clk);
-	}
-
-	/* enable IrDA */
-	gpio_request(GPIO_FN_IRDA_OUT, NULL);
-	gpio_request(GPIO_FN_IRDA_IN,  NULL);
-	gpio_request(GPIO_PTU5, NULL);
-	gpio_direction_output(GPIO_PTU5, 0);
-
-	/* Register gpio lookup tables for cameras and video decoder */
-	gpiod_add_lookup_table(&tw9910_gpios);
-	gpiod_add_lookup_table(&mt9t112_0_gpios);
-	gpiod_add_lookup_table(&mt9t112_1_gpios);
-
-	/* enable I2C device */
-	i2c_register_board_info(0, i2c0_devices,
-				ARRAY_SIZE(i2c0_devices));
-
-	i2c_register_board_info(1, i2c1_devices,
-				ARRAY_SIZE(i2c1_devices));
-
-#if defined(CONFIG_VIDEO_SH_VOU) || defined(CONFIG_VIDEO_SH_VOU_MODULE)
-	/* VOU */
-	gpio_request(GPIO_FN_DV_D15, NULL);
-	gpio_request(GPIO_FN_DV_D14, NULL);
-	gpio_request(GPIO_FN_DV_D13, NULL);
-	gpio_request(GPIO_FN_DV_D12, NULL);
-	gpio_request(GPIO_FN_DV_D11, NULL);
-	gpio_request(GPIO_FN_DV_D10, NULL);
-	gpio_request(GPIO_FN_DV_D9, NULL);
-	gpio_request(GPIO_FN_DV_D8, NULL);
-	gpio_request(GPIO_FN_DV_CLKI, NULL);
-	gpio_request(GPIO_FN_DV_CLK, NULL);
-	gpio_request(GPIO_FN_DV_VSYNC, NULL);
-	gpio_request(GPIO_FN_DV_HSYNC, NULL);
-
-	/* AK8813 power / reset sequence */
-	gpio_request(GPIO_PTG4, NULL);
-	gpio_request(GPIO_PTU3, NULL);
-	/* Reset */
-	gpio_direction_output(GPIO_PTG4, 0);
-	/* Power down */
-	gpio_direction_output(GPIO_PTU3, 1);
-
-	udelay(10);
-
-	/* Power up, reset */
-	gpio_set_value(GPIO_PTU3, 0);
-
-	udelay(10);
-
-	/* Remove reset */
-	gpio_set_value(GPIO_PTG4, 1);
-#endif
-
-	/* Initialize CEU platform devices separately to map memory first */
-	device_initialize(&ecovec_ceu_devices[0]->dev);
-	dma_declare_coherent_memory(&ecovec_ceu_devices[0]->dev,
-				    ceu0_dma_membase, ceu0_dma_membase,
-				    ceu0_dma_membase +
-				    CEU_BUFFER_MEMORY_SIZE - 1);
-	platform_device_add(ecovec_ceu_devices[0]);
-
-	device_initialize(&ecovec_ceu_devices[1]->dev);
-	dma_declare_coherent_memory(&ecovec_ceu_devices[1]->dev,
-				    ceu1_dma_membase, ceu1_dma_membase,
-				    ceu1_dma_membase +
-				    CEU_BUFFER_MEMORY_SIZE - 1);
-	platform_device_add(ecovec_ceu_devices[1]);
-
-	gpiod_add_lookup_table(&cn12_power_gpiod_table);
-#if defined(CONFIG_MMC_SDHI) || defined(CONFIG_MMC_SDHI_MODULE)
-	gpiod_add_lookup_table(&sdhi0_power_gpiod_table);
-	gpiod_add_lookup_table(&sdhi0_gpio_table);
-#if !defined(CONFIG_MMC_SH_MMCIF) && !defined(CONFIG_MMC_SH_MMCIF_MODULE)
-	gpiod_add_lookup_table(&sdhi1_gpio_table);
-#endif
-#endif
-
-	gpiod_add_lookup_table(&gpio_backlight_lookup);
-	gpio_backlight_device = platform_device_register_full(
-					&gpio_backlight_device_info);
-	if (IS_ERR(gpio_backlight_device))
-		return PTR_ERR(gpio_backlight_device);
-
-	return platform_add_devices(ecovec_devices,
-				    ARRAY_SIZE(ecovec_devices));
-}
-arch_initcall(arch_setup);
-
-static int __init devices_setup(void)
-{
-	sh_eth_init(&sh_eth_plat);
-	return 0;
-}
-device_initcall(devices_setup);
-
-/* Reserve a portion of memory for CEU 0 and CEU 1 buffers */
-static void __init ecovec_mv_mem_reserve(void)
-{
-	phys_addr_t phys;
-	phys_addr_t size = CEU_BUFFER_MEMORY_SIZE;
-
-	phys = memblock_phys_alloc(size, PAGE_SIZE);
-	if (!phys)
-		panic("Failed to allocate CEU0 memory\n");
-
-	memblock_phys_free(phys, size);
-	memblock_remove(phys, size);
-	ceu0_dma_membase = phys;
-
-	phys = memblock_phys_alloc(size, PAGE_SIZE);
-	if (!phys)
-		panic("Failed to allocate CEU1 memory\n");
-
-	memblock_phys_free(phys, size);
-	memblock_remove(phys, size);
-	ceu1_dma_membase = phys;
-}
-
-static struct sh_machine_vector mv_ecovec __initmv = {
-	.mv_name	= "R0P7724 (EcoVec)",
-	.mv_mem_reserve	= ecovec_mv_mem_reserve,
-};
diff --git a/arch/sh/boards/mach-highlander/Kconfig b/arch/sh/boards/mach-highlander/Kconfig
deleted file mode 100644
index b0abd03cac4e57..00000000000000
--- a/arch/sh/boards/mach-highlander/Kconfig
+++ /dev/null
@@ -1,26 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-if SH_HIGHLANDER
-
-choice
-	prompt "Highlander options"
-	default SH_R7780MP
-
-config SH_R7780RP
-	bool "R7780RP-1 board support"
-	depends on CPU_SUBTYPE_SH7780
-
-config SH_R7780MP
-	bool "R7780MP board support"
-	depends on CPU_SUBTYPE_SH7780
-	help
-	  Selecting this option will enable support for the mass-production
-	  version of the R7780RP. If in doubt, say Y.
-
-config SH_R7785RP
-	bool "R7785RP board support"
-	depends on CPU_SUBTYPE_SH7785
-	select GPIOLIB
-
-endchoice
-
-endif
diff --git a/arch/sh/boards/mach-highlander/Makefile b/arch/sh/boards/mach-highlander/Makefile
deleted file mode 100644
index 880ed68138b00f..00000000000000
--- a/arch/sh/boards/mach-highlander/Makefile
+++ /dev/null
@@ -1,12 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the Highlander specific parts of the kernel
-#
-obj-y				:= setup.o
-obj-$(CONFIG_SH_R7780RP)	+= irq-r7780rp.o
-obj-$(CONFIG_SH_R7780MP)	+= irq-r7780mp.o
-obj-$(CONFIG_SH_R7785RP)	+= irq-r7785rp.o pinmux-r7785rp.o
-
-ifneq ($(CONFIG_SH_R7785RP),y)
-obj-$(CONFIG_PUSH_SWITCH)	+= psw.o
-endif
diff --git a/arch/sh/boards/mach-highlander/irq-r7780mp.c b/arch/sh/boards/mach-highlander/irq-r7780mp.c
deleted file mode 100644
index f46637377b6a18..00000000000000
--- a/arch/sh/boards/mach-highlander/irq-r7780mp.c
+++ /dev/null
@@ -1,71 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Renesas Solutions Highlander R7780MP Support.
- *
- * Copyright (C) 2002  Atom Create Engineering Co., Ltd.
- * Copyright (C) 2006  Paul Mundt
- * Copyright (C) 2007  Magnus Damm
- */
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/io.h>
-#include <mach/highlander.h>
-
-enum {
-	UNUSED = 0,
-
-	/* board specific interrupt sources */
-	CF,		/* Compact Flash */
-	TP,		/* Touch panel */
-	SCIF1,		/* FPGA SCIF1 */
-	SCIF0,		/* FPGA SCIF0 */
-	SMBUS,		/* SMBUS */
-	RTC,		/* RTC Alarm */
-	AX88796,	/* Ethernet controller */
-	PSW,		/* Push Switch */
-
-	/* external bus connector */
-	EXT1, EXT2, EXT4, EXT5, EXT6,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_IRQ(CF, IRQ_CF),
-	INTC_IRQ(TP, IRQ_TP),
-	INTC_IRQ(SCIF1, IRQ_SCIF1),
-	INTC_IRQ(SCIF0, IRQ_SCIF0),
-	INTC_IRQ(SMBUS, IRQ_SMBUS),
-	INTC_IRQ(RTC, IRQ_RTC),
-	INTC_IRQ(AX88796, IRQ_AX88796),
-	INTC_IRQ(PSW, IRQ_PSW),
-
-	INTC_IRQ(EXT1, IRQ_EXT1), INTC_IRQ(EXT2, IRQ_EXT2),
-	INTC_IRQ(EXT4, IRQ_EXT4), INTC_IRQ(EXT5, IRQ_EXT5),
-	INTC_IRQ(EXT6, IRQ_EXT6),
-};
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xa4000000, 0, 16, /* IRLMSK */
-	  { SCIF0, SCIF1, RTC, 0, CF, 0, TP, SMBUS,
-	    0, EXT6, EXT5, EXT4, EXT2, EXT1, PSW, AX88796 } },
-};
-
-static unsigned char irl2irq[HL_NR_IRL] __initdata = {
-	0, IRQ_CF, IRQ_TP, IRQ_SCIF1,
-	IRQ_SCIF0, IRQ_SMBUS, IRQ_RTC, IRQ_EXT6,
-	IRQ_EXT5, IRQ_EXT4, IRQ_EXT2, IRQ_EXT1,
-	0, IRQ_AX88796, IRQ_PSW,
-};
-
-static DECLARE_INTC_DESC(intc_desc, "r7780mp", vectors,
-			 NULL, mask_registers, NULL, NULL);
-
-unsigned char * __init highlander_plat_irq_setup(void)
-{
-	if ((__raw_readw(0xa4000700) & 0xf000) == 0x2000) {
-		printk(KERN_INFO "Using r7780mp interrupt controller.\n");
-		register_intc_controller(&intc_desc);
-		return irl2irq;
-	}
-
-	return NULL;
-}
diff --git a/arch/sh/boards/mach-highlander/irq-r7780rp.c b/arch/sh/boards/mach-highlander/irq-r7780rp.c
deleted file mode 100644
index c61177e8724ba7..00000000000000
--- a/arch/sh/boards/mach-highlander/irq-r7780rp.c
+++ /dev/null
@@ -1,64 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Renesas Solutions Highlander R7780RP-1 Support.
- *
- * Copyright (C) 2002  Atom Create Engineering Co., Ltd.
- * Copyright (C) 2006  Paul Mundt
- * Copyright (C) 2008  Magnus Damm
- */
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/io.h>
-#include <mach/highlander.h>
-
-enum {
-	UNUSED = 0,
-
-	/* board specific interrupt sources */
-
-	AX88796,          /* Ethernet controller */
-	PSW,              /* Push Switch */
-	CF,               /* Compact Flash */
-
-	PCI_A,
-	PCI_B,
-	PCI_C,
-	PCI_D,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_IRQ(PCI_A, 65), /* dirty: overwrite cpu vectors for pci */
-	INTC_IRQ(PCI_B, 66),
-	INTC_IRQ(PCI_C, 67),
-	INTC_IRQ(PCI_D, 68),
-	INTC_IRQ(CF, IRQ_CF),
-	INTC_IRQ(PSW, IRQ_PSW),
-	INTC_IRQ(AX88796, IRQ_AX88796),
-};
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xa5000000, 0, 16, /* IRLMSK */
-	  { PCI_A, PCI_B, PCI_C, PCI_D, CF, 0, 0, 0,
-	    0, 0, 0, 0, 0, 0, PSW, AX88796 } },
-};
-
-static unsigned char irl2irq[HL_NR_IRL] __initdata = {
-	65, 66, 67, 68,
-	IRQ_CF, 0, 0, 0,
-	0, 0, 0, 0,
-	IRQ_AX88796, IRQ_PSW
-};
-
-static DECLARE_INTC_DESC(intc_desc, "r7780rp", vectors,
-			 NULL, mask_registers, NULL, NULL);
-
-unsigned char * __init highlander_plat_irq_setup(void)
-{
-	if (__raw_readw(0xa5000600)) {
-		printk(KERN_INFO "Using r7780rp interrupt controller.\n");
-		register_intc_controller(&intc_desc);
-		return irl2irq;
-	}
-
-	return NULL;
-}
diff --git a/arch/sh/boards/mach-highlander/irq-r7785rp.c b/arch/sh/boards/mach-highlander/irq-r7785rp.c
deleted file mode 100644
index 0ebebbed0d63fb..00000000000000
--- a/arch/sh/boards/mach-highlander/irq-r7785rp.c
+++ /dev/null
@@ -1,83 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Renesas Solutions Highlander R7785RP Support.
- *
- * Copyright (C) 2002  Atom Create Engineering Co., Ltd.
- * Copyright (C) 2006 - 2008  Paul Mundt
- * Copyright (C) 2007  Magnus Damm
- */
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/io.h>
-#include <mach/highlander.h>
-
-enum {
-	UNUSED = 0,
-
-	/* FPGA specific interrupt sources */
-	CF,		/* Compact Flash */
-	SMBUS,		/* SMBUS */
-	TP,		/* Touch panel */
-	RTC,		/* RTC Alarm */
-	TH_ALERT,	/* Temperature sensor */
-	AX88796,	/* Ethernet controller */
-
-	/* external bus connector */
-	EXT0, EXT1, EXT2, EXT3, EXT4, EXT5, EXT6, EXT7,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_IRQ(CF, IRQ_CF),
-	INTC_IRQ(SMBUS, IRQ_SMBUS),
-	INTC_IRQ(TP, IRQ_TP),
-	INTC_IRQ(RTC, IRQ_RTC),
-	INTC_IRQ(TH_ALERT, IRQ_TH_ALERT),
-
-	INTC_IRQ(EXT0, IRQ_EXT0), INTC_IRQ(EXT1, IRQ_EXT1),
-	INTC_IRQ(EXT2, IRQ_EXT2), INTC_IRQ(EXT3, IRQ_EXT3),
-
-	INTC_IRQ(EXT4, IRQ_EXT4), INTC_IRQ(EXT5, IRQ_EXT5),
-	INTC_IRQ(EXT6, IRQ_EXT6), INTC_IRQ(EXT7, IRQ_EXT7),
-
-	INTC_IRQ(AX88796, IRQ_AX88796),
-};
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xa4000010, 0, 16, /* IRLMCR1 */
-	  { 0, 0, 0, 0, CF, AX88796, SMBUS, TP,
-	    RTC, 0, TH_ALERT, 0, 0, 0, 0, 0 } },
-	{ 0xa4000012, 0, 16, /* IRLMCR2 */
-	  { 0, 0, 0, 0, 0, 0, 0, 0,
-	    EXT7, EXT6, EXT5, EXT4, EXT3, EXT2, EXT1, EXT0 } },
-};
-
-static unsigned char irl2irq[HL_NR_IRL] __initdata = {
-	0, IRQ_CF, IRQ_EXT4, IRQ_EXT5,
-	IRQ_EXT6, IRQ_EXT7, IRQ_SMBUS, IRQ_TP,
-	IRQ_RTC, IRQ_TH_ALERT, IRQ_AX88796, IRQ_EXT0,
-	IRQ_EXT1, IRQ_EXT2, IRQ_EXT3,
-};
-
-static DECLARE_INTC_DESC(intc_desc, "r7785rp", vectors,
-			 NULL, mask_registers, NULL, NULL);
-
-unsigned char * __init highlander_plat_irq_setup(void)
-{
-	if ((__raw_readw(0xa4000158) & 0xf000) != 0x1000)
-		return NULL;
-
-	printk(KERN_INFO "Using r7785rp interrupt controller.\n");
-
-	__raw_writew(0x0000, PA_IRLSSR1);	/* FPGA IRLSSR1(CF_CD clear) */
-
-	/* Setup the FPGA IRL */
-	__raw_writew(0x0000, PA_IRLPRA);	/* FPGA IRLA */
-	__raw_writew(0xe598, PA_IRLPRB);	/* FPGA IRLB */
-	__raw_writew(0x7060, PA_IRLPRC);	/* FPGA IRLC */
-	__raw_writew(0x0000, PA_IRLPRD);	/* FPGA IRLD */
-	__raw_writew(0x4321, PA_IRLPRE);	/* FPGA IRLE */
-	__raw_writew(0xdcba, PA_IRLPRF);	/* FPGA IRLF */
-
-	register_intc_controller(&intc_desc);
-	return irl2irq;
-}
diff --git a/arch/sh/boards/mach-highlander/pinmux-r7785rp.c b/arch/sh/boards/mach-highlander/pinmux-r7785rp.c
deleted file mode 100644
index 703179faf652b2..00000000000000
--- a/arch/sh/boards/mach-highlander/pinmux-r7785rp.c
+++ /dev/null
@@ -1,17 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (C) 2008 Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/gpio.h>
-#include <cpu/sh7785.h>
-
-void __init highlander_plat_pinmux_setup(void)
-{
-	/* SCIF0 */
-	gpio_request(GPIO_FN_SCIF0_CTS, NULL);
-	gpio_request(GPIO_FN_SCIF0_RTS, NULL);
-	gpio_request(GPIO_FN_SCIF0_SCK, NULL);
-	gpio_request(GPIO_FN_SCIF0_RXD, NULL);
-	gpio_request(GPIO_FN_SCIF0_TXD, NULL);
-}
diff --git a/arch/sh/boards/mach-highlander/psw.c b/arch/sh/boards/mach-highlander/psw.c
deleted file mode 100644
index d445c54f74e440..00000000000000
--- a/arch/sh/boards/mach-highlander/psw.c
+++ /dev/null
@@ -1,119 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/boards/renesas/r7780rp/psw.c
- *
- * push switch support for RDBRP-1/RDBREVRP-1 debug boards.
- *
- * Copyright (C) 2006  Paul Mundt
- */
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <mach/highlander.h>
-#include <asm/push-switch.h>
-
-static irqreturn_t psw_irq_handler(int irq, void *arg)
-{
-	struct platform_device *pdev = arg;
-	struct push_switch *psw = platform_get_drvdata(pdev);
-	struct push_switch_platform_info *psw_info = pdev->dev.platform_data;
-	unsigned int l, mask;
-	int ret = 0;
-
-	l = __raw_readw(PA_DBSW);
-
-	/* Nothing to do if there's no state change */
-	if (psw->state) {
-		ret = 1;
-		goto out;
-	}
-
-	mask = l & 0x70;
-	/* Figure out who raised it */
-	if (mask & (1 << psw_info->bit)) {
-		psw->state = !!(mask & (1 << psw_info->bit));
-		if (psw->state)	/* debounce */
-			mod_timer(&psw->debounce, jiffies + 50);
-
-		ret = 1;
-	}
-
-out:
-	/* Clear the switch IRQs */
-	l |= (0x7 << 12);
-	__raw_writew(l, PA_DBSW);
-
-	return IRQ_RETVAL(ret);
-}
-
-static struct resource psw_resources[] = {
-	[0] = {
-		.start	= IRQ_PSW,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct push_switch_platform_info s2_platform_data = {
-	.name		= "s2",
-	.bit		= 6,
-	.irq_flags	= IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |
-			  IRQF_SHARED,
-	.irq_handler	= psw_irq_handler,
-};
-
-static struct platform_device s2_switch_device = {
-	.name		= "push-switch",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(psw_resources),
-	.resource	= psw_resources,
-	.dev		= {
-		.platform_data = &s2_platform_data,
-	},
-};
-
-static struct push_switch_platform_info s3_platform_data = {
-	.name		= "s3",
-	.bit		= 5,
-	.irq_flags	= IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |
-			  IRQF_SHARED,
-	.irq_handler	= psw_irq_handler,
-};
-
-static struct platform_device s3_switch_device = {
-	.name		= "push-switch",
-	.id		= 1,
-	.num_resources	= ARRAY_SIZE(psw_resources),
-	.resource	= psw_resources,
-	.dev		= {
-		.platform_data = &s3_platform_data,
-	},
-};
-
-static struct push_switch_platform_info s4_platform_data = {
-	.name		= "s4",
-	.bit		= 4,
-	.irq_flags	= IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |
-			  IRQF_SHARED,
-	.irq_handler	= psw_irq_handler,
-};
-
-static struct platform_device s4_switch_device = {
-	.name		= "push-switch",
-	.id		= 2,
-	.num_resources	= ARRAY_SIZE(psw_resources),
-	.resource	= psw_resources,
-	.dev		= {
-		.platform_data = &s4_platform_data,
-	},
-};
-
-static struct platform_device *psw_devices[] = {
-	&s2_switch_device, &s3_switch_device, &s4_switch_device,
-};
-
-static int __init psw_init(void)
-{
-	return platform_add_devices(psw_devices, ARRAY_SIZE(psw_devices));
-}
-module_init(psw_init);
diff --git a/arch/sh/boards/mach-highlander/setup.c b/arch/sh/boards/mach-highlander/setup.c
deleted file mode 100644
index 533393d779c2b9..00000000000000
--- a/arch/sh/boards/mach-highlander/setup.c
+++ /dev/null
@@ -1,416 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/boards/renesas/r7780rp/setup.c
- *
- * Renesas Solutions Highlander Support.
- *
- * Copyright (C) 2002 Atom Create Engineering Co., Ltd.
- * Copyright (C) 2005 - 2008 Paul Mundt
- *
- * This contains support for the R7780RP-1, R7780MP, and R7785RP
- * Highlander modules.
- */
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/platform_device.h>
-#include <linux/ata_platform.h>
-#include <linux/types.h>
-#include <linux/mtd/physmap.h>
-#include <linux/i2c.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <linux/usb/r8a66597.h>
-#include <linux/usb/m66592.h>
-#include <linux/clkdev.h>
-#include <net/ax88796.h>
-#include <asm/machvec.h>
-#include <mach/highlander.h>
-#include <asm/clock.h>
-#include <asm/heartbeat.h>
-#include <asm/io.h>
-#include <asm/io_trapped.h>
-
-static struct r8a66597_platdata r8a66597_data = {
-	.xtal = R8A66597_PLATDATA_XTAL_12MHZ,
-	.vif = 1,
-};
-
-static struct resource r8a66597_usb_host_resources[] = {
-	[0] = {
-		.start	= 0xA4200000,
-		.end	= 0xA42000FF,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_EXT1,		/* irq number */
-		.end	= IRQ_EXT1,
-		.flags	= IORESOURCE_IRQ | IRQF_TRIGGER_LOW,
-	},
-};
-
-static struct platform_device r8a66597_usb_host_device = {
-	.name		= "r8a66597_hcd",
-	.id		= -1,
-	.dev = {
-		.dma_mask		= NULL,		/* don't use dma */
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &r8a66597_data,
-	},
-	.num_resources	= ARRAY_SIZE(r8a66597_usb_host_resources),
-	.resource	= r8a66597_usb_host_resources,
-};
-
-static struct m66592_platdata usbf_platdata = {
-	.xtal = M66592_PLATDATA_XTAL_24MHZ,
-	.vif = 1,
-};
-
-static struct resource m66592_usb_peripheral_resources[] = {
-	[0] = {
-		.name	= "m66592_udc",
-		.start	= 0xb0000000,
-		.end	= 0xb00000FF,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.name	= "m66592_udc",
-		.start	= IRQ_EXT4,		/* irq number */
-		.end	= IRQ_EXT4,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device m66592_usb_peripheral_device = {
-	.name		= "m66592_udc",
-	.id		= -1,
-	.dev = {
-		.dma_mask		= NULL,		/* don't use dma */
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &usbf_platdata,
-	},
-	.num_resources	= ARRAY_SIZE(m66592_usb_peripheral_resources),
-	.resource	= m66592_usb_peripheral_resources,
-};
-
-static struct resource cf_ide_resources[] = {
-	[0] = {
-		.start	= PA_AREA5_IO + 0x1000,
-		.end	= PA_AREA5_IO + 0x1000 + 0x08 - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= PA_AREA5_IO + 0x80c,
-		.end	= PA_AREA5_IO + 0x80c + 0x16 - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[2] = {
-		.start	= IRQ_CF,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct pata_platform_info pata_info = {
-	.ioport_shift	= 1,
-};
-
-static struct platform_device cf_ide_device  = {
-	.name		= "pata_platform",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(cf_ide_resources),
-	.resource	= cf_ide_resources,
-	.dev	= {
-		.platform_data	= &pata_info,
-	},
-};
-
-static struct resource heartbeat_resources[] = {
-	[0] = {
-		.start	= PA_OBLED,
-		.end	= PA_OBLED,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-#ifndef CONFIG_SH_R7785RP
-static unsigned char heartbeat_bit_pos[] = { 2, 1, 0, 3, 6, 5, 4, 7 };
-
-static struct heartbeat_data heartbeat_data = {
-	.bit_pos	= heartbeat_bit_pos,
-	.nr_bits	= ARRAY_SIZE(heartbeat_bit_pos),
-};
-#endif
-
-static struct platform_device heartbeat_device = {
-	.name		= "heartbeat",
-	.id		= -1,
-
-	/* R7785RP has a slightly more sensible FPGA.. */
-#ifndef CONFIG_SH_R7785RP
-	.dev	= {
-		.platform_data	= &heartbeat_data,
-	},
-#endif
-	.num_resources	= ARRAY_SIZE(heartbeat_resources),
-	.resource	= heartbeat_resources,
-};
-
-static struct ax_plat_data ax88796_platdata = {
-	.flags          = AXFLG_HAS_93CX6,
-	.wordlength     = 2,
-	.dcr_val        = 0x1,
-	.rcr_val        = 0x40,
-};
-
-static struct resource ax88796_resources[] = {
-	{
-#ifdef CONFIG_SH_R7780RP
-		.start  = 0xa5800400,
-		.end    = 0xa5800400 + (0x20 * 0x2) - 1,
-#else
-		.start  = 0xa4100400,
-		.end    = 0xa4100400 + (0x20 * 0x2) - 1,
-#endif
-		.flags  = IORESOURCE_MEM,
-	},
-	{
-		.start  = IRQ_AX88796,
-		.end    = IRQ_AX88796,
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device ax88796_device = {
-	.name           = "ax88796",
-	.id             = 0,
-
-	.dev    = {
-		.platform_data = &ax88796_platdata,
-	},
-
-	.num_resources  = ARRAY_SIZE(ax88796_resources),
-	.resource       = ax88796_resources,
-};
-
-static struct mtd_partition nor_flash_partitions[] = {
-	{
-		.name		= "loader",
-		.offset		= 0x00000000,
-		.size		= 512 * 1024,
-	},
-	{
-		.name		= "bootenv",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= 512 * 1024,
-	},
-	{
-		.name		= "kernel",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= 4 * 1024 * 1024,
-	},
-	{
-		.name		= "data",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= MTDPART_SIZ_FULL,
-	},
-};
-
-static struct physmap_flash_data nor_flash_data = {
-	.width		= 4,
-	.parts		= nor_flash_partitions,
-	.nr_parts	= ARRAY_SIZE(nor_flash_partitions),
-};
-
-/* This config is flash board for mass production. */
-static struct resource nor_flash_resources[] = {
-	[0]	= {
-		.start	= PA_NORFLASH_ADDR,
-		.end	= PA_NORFLASH_ADDR + PA_NORFLASH_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	}
-};
-
-static struct platform_device nor_flash_device = {
-	.name		= "physmap-flash",
-	.dev		= {
-		.platform_data	= &nor_flash_data,
-	},
-	.num_resources	= ARRAY_SIZE(nor_flash_resources),
-	.resource	= nor_flash_resources,
-};
-
-static struct resource smbus_resources[] = {
-	[0] = {
-		.start	= PA_SMCR,
-		.end	= PA_SMCR + 0x100 - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= IRQ_SMBUS,
-		.end	= IRQ_SMBUS,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device smbus_device = {
-	.name		= "i2c-highlander",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(smbus_resources),
-	.resource	= smbus_resources,
-};
-
-static struct i2c_board_info __initdata highlander_i2c_devices[] = {
-	{
-		I2C_BOARD_INFO("r2025sd", 0x32),
-	},
-};
-
-static struct platform_device *r7780rp_devices[] __initdata = {
-	&r8a66597_usb_host_device,
-	&m66592_usb_peripheral_device,
-	&heartbeat_device,
-	&smbus_device,
-	&nor_flash_device,
-#ifndef CONFIG_SH_R7780RP
-	&ax88796_device,
-#endif
-};
-
-/*
- * The CF is connected using a 16-bit bus where 8-bit operations are
- * unsupported. The linux ata driver is however using 8-bit operations, so
- * insert a trapped io filter to convert 8-bit operations into 16-bit.
- */
-static struct trapped_io cf_trapped_io = {
-	.resource		= cf_ide_resources,
-	.num_resources		= 2,
-	.minimum_bus_width	= 16,
-};
-
-static int __init r7780rp_devices_setup(void)
-{
-	int ret = 0;
-
-#ifndef CONFIG_SH_R7780RP
-	if (register_trapped_io(&cf_trapped_io) == 0)
-		ret |= platform_device_register(&cf_ide_device);
-#endif
-
-	ret |= platform_add_devices(r7780rp_devices,
-				    ARRAY_SIZE(r7780rp_devices));
-
-	ret |= i2c_register_board_info(0, highlander_i2c_devices,
-				       ARRAY_SIZE(highlander_i2c_devices));
-
-	return ret;
-}
-device_initcall(r7780rp_devices_setup);
-
-/*
- * Platform specific clocks
- */
-static int ivdr_clk_enable(struct clk *clk)
-{
-	__raw_writew(__raw_readw(PA_IVDRCTL) | (1 << IVDR_CK_ON), PA_IVDRCTL);
-	return 0;
-}
-
-static void ivdr_clk_disable(struct clk *clk)
-{
-	__raw_writew(__raw_readw(PA_IVDRCTL) & ~(1 << IVDR_CK_ON), PA_IVDRCTL);
-}
-
-static struct sh_clk_ops ivdr_clk_ops = {
-	.enable		= ivdr_clk_enable,
-	.disable	= ivdr_clk_disable,
-};
-
-static struct clk ivdr_clk = {
-	.ops		= &ivdr_clk_ops,
-};
-
-static struct clk *r7780rp_clocks[] = {
-	&ivdr_clk,
-};
-
-static struct clk_lookup lookups[] = {
-	/* main clocks */
-	CLKDEV_CON_ID("ivdr_clk", &ivdr_clk),
-};
-
-static void r7780rp_power_off(void)
-{
-	if (mach_is_r7780mp() || mach_is_r7785rp())
-		__raw_writew(0x0001, PA_POFF);
-}
-
-/*
- * Initialize the board
- */
-static void __init highlander_setup(char **cmdline_p)
-{
-	u16 ver = __raw_readw(PA_VERREG);
-	int i;
-
-	printk(KERN_INFO "Renesas Solutions Highlander %s support.\n",
-			 mach_is_r7780rp() ? "R7780RP-1" :
-			 mach_is_r7780mp() ? "R7780MP"	 :
-					     "R7785RP");
-
-	printk(KERN_INFO "Board version: %d (revision %d), "
-			 "FPGA version: %d (revision %d)\n",
-			 (ver >> 12) & 0xf, (ver >> 8) & 0xf,
-			 (ver >>  4) & 0xf, ver & 0xf);
-
-	highlander_plat_pinmux_setup();
-
-	/*
-	 * Enable the important clocks right away..
-	 */
-	for (i = 0; i < ARRAY_SIZE(r7780rp_clocks); i++) {
-		struct clk *clk = r7780rp_clocks[i];
-
-		clk_register(clk);
-		clk_enable(clk);
-	}
-
-	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
-
-	__raw_writew(0x0000, PA_OBLED);	/* Clear LED. */
-
-	if (mach_is_r7780rp())
-		__raw_writew(0x0001, PA_SDPOW);	/* SD Power ON */
-
-	__raw_writew(__raw_readw(PA_IVDRCTL) | 0x01, PA_IVDRCTL);	/* Si13112 */
-
-	pm_power_off = r7780rp_power_off;
-}
-
-static unsigned char irl2irq[HL_NR_IRL];
-
-static int highlander_irq_demux(int irq)
-{
-	if (irq >= HL_NR_IRL || irq < 0 || !irl2irq[irq])
-		return irq;
-
-	return irl2irq[irq];
-}
-
-static void __init highlander_init_irq(void)
-{
-	unsigned char *ucp = highlander_plat_irq_setup();
-
-	if (ucp) {
-		plat_irq_setup_pins(IRQ_MODE_IRL3210);
-		memcpy(irl2irq, ucp, HL_NR_IRL);
-	}
-}
-
-/*
- * The Machine Vector
- */
-static struct sh_machine_vector mv_highlander __initmv = {
-	.mv_name		= "Highlander",
-	.mv_setup		= highlander_setup,
-	.mv_init_irq		= highlander_init_irq,
-	.mv_irq_demux		= highlander_irq_demux,
-};
diff --git a/arch/sh/boards/mach-hp6xx/Makefile b/arch/sh/boards/mach-hp6xx/Makefile
deleted file mode 100644
index 4b0fe29e5612eb..00000000000000
--- a/arch/sh/boards/mach-hp6xx/Makefile
+++ /dev/null
@@ -1,8 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the HP6xx specific parts of the kernel
-#
-
-obj-y			:= setup.o
-obj-$(CONFIG_PM)	+= pm.o pm_wakeup.o
-obj-$(CONFIG_APM_EMULATION)	+= hp6xx_apm.o
diff --git a/arch/sh/boards/mach-hp6xx/hp6xx_apm.c b/arch/sh/boards/mach-hp6xx/hp6xx_apm.c
deleted file mode 100644
index e5c4c7d34139ea..00000000000000
--- a/arch/sh/boards/mach-hp6xx/hp6xx_apm.c
+++ /dev/null
@@ -1,109 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * bios-less APM driver for hp680
- *
- * Copyright 2005 (c) Andriy Skulysh <askulysh@gmail.com>
- * Copyright 2008 (c) Kristoffer Ericson <kristoffer.ericson@gmail.com>
- */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/apm-emulation.h>
-#include <linux/io.h>
-#include <asm/adc.h>
-#include <mach/hp6xx.h>
-
-/* percentage values */
-#define APM_CRITICAL			10
-#define APM_LOW				30
-
-/* resonably sane values */
-#define HP680_BATTERY_MAX		898
-#define HP680_BATTERY_MIN		486
-#define HP680_BATTERY_AC_ON		1023
-
-#define MODNAME "hp6x0_apm"
-
-#define PGDR	0xa400012c
-
-static void hp6x0_apm_get_power_status(struct apm_power_info *info)
-{
-	int battery, backup, charging, percentage;
-	u8 pgdr;
-
-	battery		= adc_single(ADC_CHANNEL_BATTERY);
-	backup		= adc_single(ADC_CHANNEL_BACKUP);
-	charging	= adc_single(ADC_CHANNEL_CHARGE);
-
-	percentage = 100 * (battery - HP680_BATTERY_MIN) /
-			   (HP680_BATTERY_MAX - HP680_BATTERY_MIN);
-
-	/* % of full battery */
-	info->battery_life = percentage;
-
-	/* We want our estimates in minutes */
-	info->units = 0;
-
-	/* Extremely(!!) rough estimate, we will replace this with a datalist later on */
-	info->time = (2 * battery);
-
-	info->ac_line_status = (battery > HP680_BATTERY_AC_ON) ?
-			 APM_AC_ONLINE : APM_AC_OFFLINE;
-
-	pgdr = __raw_readb(PGDR);
-	if (pgdr & PGDR_MAIN_BATTERY_OUT) {
-		info->battery_status	= APM_BATTERY_STATUS_NOT_PRESENT;
-		info->battery_flag	= 0x80;
-	} else if (charging < 8) {
-		info->battery_status	= APM_BATTERY_STATUS_CHARGING;
-		info->battery_flag	= 0x08;
-		info->ac_line_status	= 0x01;
-	} else if (percentage <= APM_CRITICAL) {
-		info->battery_status	= APM_BATTERY_STATUS_CRITICAL;
-		info->battery_flag	= 0x04;
-	} else if (percentage <= APM_LOW) {
-		info->battery_status	= APM_BATTERY_STATUS_LOW;
-		info->battery_flag	= 0x02;
-	} else {
-		info->battery_status	= APM_BATTERY_STATUS_HIGH;
-		info->battery_flag	= 0x01;
-	}
-}
-
-static irqreturn_t hp6x0_apm_interrupt(int irq, void *dev)
-{
-	if (!APM_DISABLED)
-		apm_queue_event(APM_USER_SUSPEND);
-
-	return IRQ_HANDLED;
-}
-
-static int __init hp6x0_apm_init(void)
-{
-	int ret;
-
-	ret = request_irq(HP680_BTN_IRQ, hp6x0_apm_interrupt,
-			  0, MODNAME, NULL);
-	if (unlikely(ret < 0)) {
-		printk(KERN_ERR MODNAME ": IRQ %d request failed\n",
-		       HP680_BTN_IRQ);
-		return ret;
-	}
-
-	apm_get_power_status = hp6x0_apm_get_power_status;
-
-	return ret;
-}
-
-static void __exit hp6x0_apm_exit(void)
-{
-	free_irq(HP680_BTN_IRQ, 0);
-}
-
-module_init(hp6x0_apm_init);
-module_exit(hp6x0_apm_exit);
-
-MODULE_AUTHOR("Adriy Skulysh");
-MODULE_DESCRIPTION("hp6xx Advanced Power Management");
-MODULE_LICENSE("GPL");
diff --git a/arch/sh/boards/mach-hp6xx/pm.c b/arch/sh/boards/mach-hp6xx/pm.c
deleted file mode 100644
index fe505ec168d021..00000000000000
--- a/arch/sh/boards/mach-hp6xx/pm.c
+++ /dev/null
@@ -1,156 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * hp6x0 Power Management Routines
- *
- * Copyright (c) 2006 Andriy Skulysh <askulsyh@gmail.com>
- */
-#include <linux/init.h>
-#include <linux/suspend.h>
-#include <linux/errno.h>
-#include <linux/time.h>
-#include <linux/delay.h>
-#include <linux/gfp.h>
-#include <asm/io.h>
-#include <asm/hd64461.h>
-#include <asm/bl_bit.h>
-#include <mach/hp6xx.h>
-#include <cpu/dac.h>
-#include <asm/freq.h>
-#include <asm/watchdog.h>
-
-#define INTR_OFFSET	0x600
-
-#define STBCR		0xffffff82
-#define STBCR2		0xffffff88
-
-#define STBCR_STBY	0x80
-#define STBCR_MSTP2	0x04
-
-#define MCR		0xffffff68
-#define RTCNT		0xffffff70
-
-#define MCR_RMODE	2
-#define MCR_RFSH	4
-
-extern u8 wakeup_start;
-extern u8 wakeup_end;
-
-static void pm_enter(void)
-{
-	u8 stbcr, csr;
-	u16 frqcr, mcr;
-	u32 vbr_new, vbr_old;
-
-	set_bl_bit();
-
-	/* set wdt */
-	csr = sh_wdt_read_csr();
-	csr &= ~WTCSR_TME;
-	csr |= WTCSR_CKS_4096;
-	sh_wdt_write_csr(csr);
-	csr = sh_wdt_read_csr();
-	sh_wdt_write_cnt(0);
-
-	/* disable PLL1 */
-	frqcr = __raw_readw(FRQCR);
-	frqcr &= ~(FRQCR_PLLEN | FRQCR_PSTBY);
-	__raw_writew(frqcr, FRQCR);
-
-	/* enable standby */
-	stbcr = __raw_readb(STBCR);
-	__raw_writeb(stbcr | STBCR_STBY | STBCR_MSTP2, STBCR);
-
-	/* set self-refresh */
-	mcr = __raw_readw(MCR);
-	__raw_writew(mcr & ~MCR_RFSH, MCR);
-
-	/* set interrupt handler */
-	asm volatile("stc vbr, %0" : "=r" (vbr_old));
-	vbr_new = get_zeroed_page(GFP_ATOMIC);
-	udelay(50);
-	memcpy((void*)(vbr_new + INTR_OFFSET),
-	       &wakeup_start, &wakeup_end - &wakeup_start);
-	asm volatile("ldc %0, vbr" : : "r" (vbr_new));
-
-	__raw_writew(0, RTCNT);
-	__raw_writew(mcr | MCR_RFSH | MCR_RMODE, MCR);
-
-	cpu_sleep();
-
-	asm volatile("ldc %0, vbr" : : "r" (vbr_old));
-
-	free_page(vbr_new);
-
-	/* enable PLL1 */
-	frqcr = __raw_readw(FRQCR);
-	frqcr |= FRQCR_PSTBY;
-	__raw_writew(frqcr, FRQCR);
-	udelay(50);
-	frqcr |= FRQCR_PLLEN;
-	__raw_writew(frqcr, FRQCR);
-
-	__raw_writeb(stbcr, STBCR);
-
-	clear_bl_bit();
-}
-
-static int hp6x0_pm_enter(suspend_state_t state)
-{
-	u8 stbcr, stbcr2;
-#ifdef CONFIG_HD64461_ENABLER
-	u8 scr;
-	u16 hd64461_stbcr;
-#endif
-
-#ifdef CONFIG_HD64461_ENABLER
-	outb(0, HD64461_PCC1CSCIER);
-
-	scr = inb(HD64461_PCC1SCR);
-	scr |= HD64461_PCCSCR_VCC1;
-	outb(scr, HD64461_PCC1SCR);
-
-	hd64461_stbcr = inw(HD64461_STBCR);
-	hd64461_stbcr |= HD64461_STBCR_SPC1ST;
-	outw(hd64461_stbcr, HD64461_STBCR);
-#endif
-
-	__raw_writeb(0x1f, DACR);
-
-	stbcr = __raw_readb(STBCR);
-	__raw_writeb(0x01, STBCR);
-
-	stbcr2 = __raw_readb(STBCR2);
-	__raw_writeb(0x7f , STBCR2);
-
-	outw(0xf07f, HD64461_SCPUCR);
-
-	pm_enter();
-
-	outw(0, HD64461_SCPUCR);
-	__raw_writeb(stbcr, STBCR);
-	__raw_writeb(stbcr2, STBCR2);
-
-#ifdef CONFIG_HD64461_ENABLER
-	hd64461_stbcr = inw(HD64461_STBCR);
-	hd64461_stbcr &= ~HD64461_STBCR_SPC1ST;
-	outw(hd64461_stbcr, HD64461_STBCR);
-
-	outb(0x4c, HD64461_PCC1CSCIER);
-	outb(0x00, HD64461_PCC1CSCR);
-#endif
-
-	return 0;
-}
-
-static const struct platform_suspend_ops hp6x0_pm_ops = {
-	.enter		= hp6x0_pm_enter,
-	.valid		= suspend_valid_only_mem,
-};
-
-static int __init hp6x0_pm_init(void)
-{
-	suspend_set_ops(&hp6x0_pm_ops);
-	return 0;
-}
-
-late_initcall(hp6x0_pm_init);
diff --git a/arch/sh/boards/mach-hp6xx/pm_wakeup.S b/arch/sh/boards/mach-hp6xx/pm_wakeup.S
deleted file mode 100644
index 0fd43301f083d0..00000000000000
--- a/arch/sh/boards/mach-hp6xx/pm_wakeup.S
+++ /dev/null
@@ -1,39 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * Copyright (c) 2006 Andriy Skulysh <askulsyh@gmail.com>
- */
-
-#include <linux/linkage.h>
-#include <cpu/mmu_context.h>
-
-/*
- * Kernel mode register usage:
- *	k0	scratch
- *	k1	scratch
- * For more details, please have a look at entry.S
- */
-
-#define k0	r0
-#define k1	r1
-
-ENTRY(wakeup_start)
-! clear STBY bit
-	mov	#-126, k1
-   	and	#127, k0
-	mov.b	k0, @k1
-! enable refresh
-	mov.l	5f, k1
-	mov.w	6f, k0
-  	mov.w	k0, @k1
-! jump to handler
-	mov.l	4f, k1
-	jmp	@k1
-	 nop
-
-	.align	2
-4:	.long	handle_interrupt
-5:	.long	0xffffff68
-6:	.word	0x0524
-
-ENTRY(wakeup_end)
-	nop
diff --git a/arch/sh/boards/mach-hp6xx/setup.c b/arch/sh/boards/mach-hp6xx/setup.c
deleted file mode 100644
index 2ceead68d7bf82..00000000000000
--- a/arch/sh/boards/mach-hp6xx/setup.c
+++ /dev/null
@@ -1,172 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/hp6xx/setup.c
- *
- * Copyright (C) 2002 Andriy Skulysh
- * Copyright (C) 2007 Kristoffer Ericson <Kristoffer_e1@hotmail.com>
- *
- * Setup code for HP620/HP660/HP680/HP690 (internal peripherials only)
- */
-#include <linux/types.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/irq.h>
-#include <linux/sh_intc.h>
-#include <sound/sh_dac_audio.h>
-#include <asm/hd64461.h>
-#include <asm/io.h>
-#include <mach/hp6xx.h>
-#include <cpu/dac.h>
-
-#define	SCPCR	0xa4000116
-#define	SCPDR	0xa4000136
-
-/* CF Slot */
-static struct resource cf_ide_resources[] = {
-	[0] = {
-		.start = 0x15000000 + 0x1f0,
-		.end   = 0x15000000 + 0x1f0 + 0x08 - 0x01,
-		.flags = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start = 0x15000000 + 0x1fe,
-		.end   = 0x15000000 + 0x1fe + 0x01,
-		.flags = IORESOURCE_MEM,
-	},
-	[2] = {
-		.start = evt2irq(0xba0),
-		.flags = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device cf_ide_device = {
-	.name		=  "pata_platform",
-	.id		=  -1,
-	.num_resources	= ARRAY_SIZE(cf_ide_resources),
-	.resource	= cf_ide_resources,
-};
-
-static struct platform_device jornadakbd_device = {
-	.name		= "jornada680_kbd",
-	.id		= -1,
-};
-
-static void dac_audio_start(struct dac_audio_pdata *pdata)
-{
-	u16 v;
-	u8 v8;
-
-	/* HP Jornada 680/690 speaker on */
-	v = inw(HD64461_GPADR);
-	v &= ~HD64461_GPADR_SPEAKER;
-	outw(v, HD64461_GPADR);
-
-	/* HP Palmtop 620lx/660lx speaker on */
-	v8 = inb(PKDR);
-	v8 &= ~PKDR_SPEAKER;
-	outb(v8, PKDR);
-
-	sh_dac_enable(pdata->channel);
-}
-
-static void dac_audio_stop(struct dac_audio_pdata *pdata)
-{
-	u16 v;
-	u8 v8;
-
-	/* HP Jornada 680/690 speaker off */
-	v = inw(HD64461_GPADR);
-	v |= HD64461_GPADR_SPEAKER;
-	outw(v, HD64461_GPADR);
-
-	/* HP Palmtop 620lx/660lx speaker off */
-	v8 = inb(PKDR);
-	v8 |= PKDR_SPEAKER;
-	outb(v8, PKDR);
-
-	sh_dac_output(0, pdata->channel);
-	sh_dac_disable(pdata->channel);
-}
-
-static struct dac_audio_pdata dac_audio_platform_data = {
-	.buffer_size		= 64000,
-	.channel		= 1,
-	.start			= dac_audio_start,
-	.stop			= dac_audio_stop,
-};
-
-static struct platform_device dac_audio_device = {
-	.name		= "dac_audio",
-	.id		= -1,
-	.dev		= {
-		.platform_data	= &dac_audio_platform_data,
-	}
-
-};
-
-static struct platform_device *hp6xx_devices[] __initdata = {
-	&cf_ide_device,
-	&jornadakbd_device,
-	&dac_audio_device,
-};
-
-static void __init hp6xx_init_irq(void)
-{
-	/* Gets touchscreen and powerbutton IRQ working */
-	plat_irq_setup_pins(IRQ_MODE_IRQ);
-}
-
-static int __init hp6xx_devices_setup(void)
-{
-	return platform_add_devices(hp6xx_devices, ARRAY_SIZE(hp6xx_devices));
-}
-
-static void __init hp6xx_setup(char **cmdline_p)
-{
-	u8 v8;
-	u16 v;
-
-	v = inw(HD64461_STBCR);
-	v |=	HD64461_STBCR_SURTST | HD64461_STBCR_SIRST	|
-		HD64461_STBCR_STM1ST | HD64461_STBCR_STM0ST	|
-		HD64461_STBCR_SAFEST | HD64461_STBCR_SPC0ST	|
-		HD64461_STBCR_SMIAST | HD64461_STBCR_SAFECKE_OST|
-		HD64461_STBCR_SAFECKE_IST;
-#ifndef CONFIG_HD64461_ENABLER
-	v |= HD64461_STBCR_SPC1ST;
-#endif
-	outw(v, HD64461_STBCR);
-	v = inw(HD64461_GPADR);
-	v |= HD64461_GPADR_SPEAKER | HD64461_GPADR_PCMCIA0;
-	outw(v, HD64461_GPADR);
-
-	outw(HD64461_PCCGCR_VCC0 | HD64461_PCCSCR_VCC1, HD64461_PCC0GCR);
-
-#ifndef CONFIG_HD64461_ENABLER
-	outw(HD64461_PCCGCR_VCC0 | HD64461_PCCSCR_VCC1, HD64461_PCC1GCR);
-#endif
-
-	sh_dac_output(0, DAC_SPEAKER_VOLUME);
-	sh_dac_disable(DAC_SPEAKER_VOLUME);
-	v8 = __raw_readb(DACR);
-	v8 &= ~DACR_DAE;
-	__raw_writeb(v8,DACR);
-
-	v8 = __raw_readb(SCPDR);
-	v8 |= SCPDR_TS_SCAN_X | SCPDR_TS_SCAN_Y;
-	v8 &= ~SCPDR_TS_SCAN_ENABLE;
-	__raw_writeb(v8, SCPDR);
-
-	v = __raw_readw(SCPCR);
-	v &= ~SCPCR_TS_MASK;
-	v |= SCPCR_TS_ENABLE;
-	__raw_writew(v, SCPCR);
-}
-device_initcall(hp6xx_devices_setup);
-
-static struct sh_machine_vector mv_hp6xx __initmv = {
-	.mv_name = "hp6xx",
-	.mv_setup = hp6xx_setup,
-	/* Enable IRQ0 -> IRQ3 in IRQ_MODE */
-	.mv_init_irq = hp6xx_init_irq,
-};
diff --git a/arch/sh/boards/mach-kfr2r09/Makefile b/arch/sh/boards/mach-kfr2r09/Makefile
deleted file mode 100644
index 4a4a35ad7ba07c..00000000000000
--- a/arch/sh/boards/mach-kfr2r09/Makefile
+++ /dev/null
@@ -1,5 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-obj-y	:= setup.o sdram.o
-ifneq ($(CONFIG_FB_SH_MOBILE_LCDC),)
-obj-y	+=  lcd_wqvga.o
-endif
diff --git a/arch/sh/boards/mach-kfr2r09/lcd_wqvga.c b/arch/sh/boards/mach-kfr2r09/lcd_wqvga.c
deleted file mode 100644
index f6bbac106d1328..00000000000000
--- a/arch/sh/boards/mach-kfr2r09/lcd_wqvga.c
+++ /dev/null
@@ -1,275 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * KFR2R09 LCD panel support
- *
- * Copyright (C) 2009 Magnus Damm
- *
- * Register settings based on the out-of-tree t33fb.c driver
- * Copyright (C) 2008 Lineo Solutions, Inc.
- */
-
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/fb.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/gpio.h>
-#include <video/sh_mobile_lcdc.h>
-#include <mach/kfr2r09.h>
-#include <cpu/sh7724.h>
-
-/* The on-board LCD module is a Hitachi TX07D34VM0AAA. This module is made
- * up of a 240x400 LCD hooked up to a R61517 driver IC. The driver IC is
- * communicating with the main port of the LCDC using an 18-bit SYS interface.
- *
- * The device code for this LCD module is 0x01221517.
- */
-
-static const unsigned char data_frame_if[] = {
-	0x02, /* WEMODE: 1=cont, 0=one-shot */
-	0x00, 0x00,
-	0x00, /* EPF, DFM */
-	0x02, /* RIM[1] : 1 (18bpp) */
-};
-
-static const unsigned char data_panel[] = {
-	0x0b,
-	0x63, /* 400 lines */
-	0x04, 0x00, 0x00, 0x04, 0x11, 0x00, 0x00,
-};
-
-static const unsigned char data_timing[] = {
-	0x00, 0x00, 0x13, 0x08, 0x08,
-};
-
-static const unsigned char data_timing_src[] = {
-	0x11, 0x01, 0x00, 0x01,
-};
-
-static const unsigned char data_gamma[] = {
-	0x01, 0x02, 0x08, 0x23,	0x03, 0x0c, 0x00, 0x06,	0x00, 0x00,
-	0x01, 0x00, 0x0c, 0x23, 0x03, 0x08, 0x02, 0x06, 0x00, 0x00,
-};
-
-static const unsigned char data_power[] = {
-	0x07, 0xc5, 0xdc, 0x02,	0x33, 0x0a,
-};
-
-static unsigned long read_reg(void *sohandle,
-			      struct sh_mobile_lcdc_sys_bus_ops *so)
-{
-	return so->read_data(sohandle);
-}
-
-static void write_reg(void *sohandle,
-		      struct sh_mobile_lcdc_sys_bus_ops *so,
-		      int i, unsigned long v)
-{
-	if (i)
-		so->write_data(sohandle, v); /* PTH4/LCDRS High [param, 17:0] */
-	else
-		so->write_index(sohandle, v); /* PTH4/LCDRS Low [cmd, 7:0] */
-}
-
-static void write_data(void *sohandle,
-		       struct sh_mobile_lcdc_sys_bus_ops *so,
-		       unsigned char const *data, int no_data)
-{
-	int i;
-
-	for (i = 0; i < no_data; i++)
-		write_reg(sohandle, so, 1, data[i]);
-}
-
-static unsigned long read_device_code(void *sohandle,
-				      struct sh_mobile_lcdc_sys_bus_ops *so)
-{
-	unsigned long device_code;
-
-	/* access protect OFF */
-	write_reg(sohandle, so, 0, 0xb0);
-	write_reg(sohandle, so, 1, 0x00);
-
-	/* deep standby OFF */
-	write_reg(sohandle, so, 0, 0xb1);
-	write_reg(sohandle, so, 1, 0x00);
-
-	/* device code command */
-	write_reg(sohandle, so, 0, 0xbf);
-	mdelay(50);
-
-	/* dummy read */
-	read_reg(sohandle, so);
-
-	/* read device code */
-	device_code = ((read_reg(sohandle, so) & 0xff) << 24);
-	device_code |= ((read_reg(sohandle, so) & 0xff) << 16);
-	device_code |= ((read_reg(sohandle, so) & 0xff) << 8);
-	device_code |= (read_reg(sohandle, so) & 0xff);
-
-	return device_code;
-}
-
-static void write_memory_start(void *sohandle,
-			       struct sh_mobile_lcdc_sys_bus_ops *so)
-{
-	write_reg(sohandle, so, 0, 0x2c);
-}
-
-static void clear_memory(void *sohandle,
-			 struct sh_mobile_lcdc_sys_bus_ops *so)
-{
-	int i;
-
-	/* write start */
-	write_memory_start(sohandle, so);
-
-	/* paint it black */
-	for (i = 0; i < (240 * 400); i++)
-		write_reg(sohandle, so, 1, 0x00);
-}
-
-static void display_on(void *sohandle,
-		       struct sh_mobile_lcdc_sys_bus_ops *so)
-{
-	/* access protect off */
-	write_reg(sohandle, so, 0, 0xb0);
-	write_reg(sohandle, so, 1, 0x00);
-
-	/* exit deep standby mode */
-	write_reg(sohandle, so, 0, 0xb1);
-	write_reg(sohandle, so, 1, 0x00);
-
-	/* frame memory I/F */
-	write_reg(sohandle, so, 0, 0xb3);
-	write_data(sohandle, so, data_frame_if, ARRAY_SIZE(data_frame_if));
-
-	/* display mode and frame memory write mode */
-	write_reg(sohandle, so, 0, 0xb4);
-	write_reg(sohandle, so, 1, 0x00); /* DBI, internal clock */
-
-	/* panel */
-	write_reg(sohandle, so, 0, 0xc0);
-	write_data(sohandle, so, data_panel, ARRAY_SIZE(data_panel));
-
-	/* timing (normal) */
-	write_reg(sohandle, so, 0, 0xc1);
-	write_data(sohandle, so, data_timing, ARRAY_SIZE(data_timing));
-
-	/* timing (partial) */
-	write_reg(sohandle, so, 0, 0xc2);
-	write_data(sohandle, so, data_timing, ARRAY_SIZE(data_timing));
-
-	/* timing (idle) */
-	write_reg(sohandle, so, 0, 0xc3);
-	write_data(sohandle, so, data_timing, ARRAY_SIZE(data_timing));
-
-	/* timing (source/VCOM/gate driving) */
-	write_reg(sohandle, so, 0, 0xc4);
-	write_data(sohandle, so, data_timing_src, ARRAY_SIZE(data_timing_src));
-
-	/* gamma (red) */
-	write_reg(sohandle, so, 0, 0xc8);
-	write_data(sohandle, so, data_gamma, ARRAY_SIZE(data_gamma));
-
-	/* gamma (green) */
-	write_reg(sohandle, so, 0, 0xc9);
-	write_data(sohandle, so, data_gamma, ARRAY_SIZE(data_gamma));
-
-	/* gamma (blue) */
-	write_reg(sohandle, so, 0, 0xca);
-	write_data(sohandle, so, data_gamma, ARRAY_SIZE(data_gamma));
-
-	/* power (common) */
-	write_reg(sohandle, so, 0, 0xd0);
-	write_data(sohandle, so, data_power, ARRAY_SIZE(data_power));
-
-	/* VCOM */
-	write_reg(sohandle, so, 0, 0xd1);
-	write_reg(sohandle, so, 1, 0x00);
-	write_reg(sohandle, so, 1, 0x0f);
-	write_reg(sohandle, so, 1, 0x02);
-
-	/* power (normal) */
-	write_reg(sohandle, so, 0, 0xd2);
-	write_reg(sohandle, so, 1, 0x63);
-	write_reg(sohandle, so, 1, 0x24);
-
-	/* power (partial) */
-	write_reg(sohandle, so, 0, 0xd3);
-	write_reg(sohandle, so, 1, 0x63);
-	write_reg(sohandle, so, 1, 0x24);
-
-	/* power (idle) */
-	write_reg(sohandle, so, 0, 0xd4);
-	write_reg(sohandle, so, 1, 0x63);
-	write_reg(sohandle, so, 1, 0x24);
-
-	write_reg(sohandle, so, 0, 0xd8);
-	write_reg(sohandle, so, 1, 0x77);
-	write_reg(sohandle, so, 1, 0x77);
-
-	/* TE signal */
-	write_reg(sohandle, so, 0, 0x35);
-	write_reg(sohandle, so, 1, 0x00);
-
-	/* TE signal line */
-	write_reg(sohandle, so, 0, 0x44);
-	write_reg(sohandle, so, 1, 0x00);
-	write_reg(sohandle, so, 1, 0x00);
-
-	/* column address */
-	write_reg(sohandle, so, 0, 0x2a);
-	write_reg(sohandle, so, 1, 0x00);
-	write_reg(sohandle, so, 1, 0x00);
-	write_reg(sohandle, so, 1, 0x00);
-	write_reg(sohandle, so, 1, 0xef);
-
-	/* page address */
-	write_reg(sohandle, so, 0, 0x2b);
-	write_reg(sohandle, so, 1, 0x00);
-	write_reg(sohandle, so, 1, 0x00);
-	write_reg(sohandle, so, 1, 0x01);
-	write_reg(sohandle, so, 1, 0x8f);
-
-	/* exit sleep mode */
-	write_reg(sohandle, so, 0, 0x11);
-
-	mdelay(120);
-
-	/* clear vram */
-	clear_memory(sohandle, so);
-
-	/* display ON */
-	write_reg(sohandle, so, 0, 0x29);
-	mdelay(1);
-
-	write_memory_start(sohandle, so);
-}
-
-int kfr2r09_lcd_setup(void *sohandle, struct sh_mobile_lcdc_sys_bus_ops *so)
-{
-	/* power on */
-	gpio_set_value(GPIO_PTF4, 0);  /* PROTECT/ -> L */
-	gpio_set_value(GPIO_PTE4, 0);  /* LCD_RST/ -> L */
-	gpio_set_value(GPIO_PTF4, 1);  /* PROTECT/ -> H */
-	udelay(1100);
-	gpio_set_value(GPIO_PTE4, 1);  /* LCD_RST/ -> H */
-	udelay(10);
-	gpio_set_value(GPIO_PTF4, 0);  /* PROTECT/ -> L */
-	mdelay(20);
-
-	if (read_device_code(sohandle, so) != 0x01221517)
-		return -ENODEV;
-
-	pr_info("KFR2R09 WQVGA LCD Module detected.\n");
-
-	display_on(sohandle, so);
-	return 0;
-}
-
-void kfr2r09_lcd_start(void *sohandle, struct sh_mobile_lcdc_sys_bus_ops *so)
-{
-	write_memory_start(sohandle, so);
-}
diff --git a/arch/sh/boards/mach-kfr2r09/sdram.S b/arch/sh/boards/mach-kfr2r09/sdram.S
deleted file mode 100644
index f1b8985cb9223c..00000000000000
--- a/arch/sh/boards/mach-kfr2r09/sdram.S
+++ /dev/null
@@ -1,77 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * KFR2R09 sdram self/auto-refresh setup code
- *
- *  Copyright (C) 2009 Magnus Damm
- */
-
-#include <linux/sys.h>
-#include <linux/errno.h>
-#include <linux/linkage.h>
-#include <asm/asm-offsets.h>
-#include <asm/suspend.h>
-#include <asm/romimage-macros.h>
-
-/* code to enter and leave self-refresh. must be self-contained.
- * this code will be copied to on-chip memory and executed from there.
- */
-	.balign 4
-ENTRY(kfr2r09_sdram_enter_start)
-
-	/* DBSC: put memory in self-refresh mode */
-
-	ED 0xFD000010, 0x00000000 /* DBEN */
-	ED 0xFD000040, 0x00000000 /* DBRFPDN0 */
-	ED 0xFD000014, 0x00000002 /* DBCMDCNT (PALL) */
-	ED 0xFD000014, 0x00000004 /* DBCMDCNT (REF) */
-	ED 0xFD000040, 0x00000001 /* DBRFPDN0 */
-
-	rts
-	 nop
-
-ENTRY(kfr2r09_sdram_enter_end)
-
-	.balign 4
-ENTRY(kfr2r09_sdram_leave_start)
-
-	/* DBSC: put memory in auto-refresh mode */
-
-	mov.l	@(SH_SLEEP_MODE, r5), r0
-	tst	#SUSP_SH_RSTANDBY, r0
-	bf	resume_rstandby
-
-	ED 0xFD000040, 0x00000000 /* DBRFPDN0 */
-	WAIT 1
-	ED 0xFD000014, 0x00000002 /* DBCMDCNT (PALL) */
-	ED 0xFD000014, 0x00000004 /* DBCMDCNT (REF) */
-	ED 0xFD000010, 0x00000001 /* DBEN */
-	ED 0xFD000040, 0x00010000 /* DBRFPDN0 */
-
-	rts
-	 nop
-
-resume_rstandby:
-
-	/* DBSC: re-initialize and put in auto-refresh */
-
-	ED 0xFD000108, 0x40000301 /* DBPDCNT0 */
-	ED 0xFD000020, 0x011B0002 /* DBCONF */
-	ED 0xFD000030, 0x03060E02 /* DBTR0 */
-	ED 0xFD000034, 0x01020102 /* DBTR1 */
-	ED 0xFD000038, 0x01090406 /* DBTR2 */
-	ED 0xFD000008, 0x00000004 /* DBKIND */
-	ED 0xFD000040, 0x00000001 /* DBRFPDN0 */
-	ED 0xFD000040, 0x00000000 /* DBRFPDN0 */
-	ED 0xFD000018, 0x00000001 /* DBCKECNT */
-	WAIT 1
-	ED 0xFD000010, 0x00000001 /* DBEN */
-	ED 0xFD000044, 0x000004AF /* DBRFPDN1 */
-	ED 0xFD000048, 0x20CF0037 /* DBRFPDN2 */
-	ED 0xFD000014, 0x00000004 /* DBCMDCNT (REF) */
-	ED 0xFD000108, 0x40000300 /* DBPDCNT0 */
-	ED 0xFD000040, 0x00010000 /* DBRFPDN0 */
-
-	rts
-	 nop
-
-ENTRY(kfr2r09_sdram_leave_end)
diff --git a/arch/sh/boards/mach-kfr2r09/setup.c b/arch/sh/boards/mach-kfr2r09/setup.c
deleted file mode 100644
index 20f4db778ed6ae..00000000000000
--- a/arch/sh/boards/mach-kfr2r09/setup.c
+++ /dev/null
@@ -1,649 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * KFR2R09 board support code
- *
- * Copyright (C) 2009 Magnus Damm
- */
-
-#include <asm/clock.h>
-#include <asm/io.h>
-#include <asm/machvec.h>
-#include <asm/suspend.h>
-
-#include <cpu/sh7724.h>
-
-#include <linux/clkdev.h>
-#include <linux/delay.h>
-#include <linux/gpio.h>
-#include <linux/gpio/machine.h>
-#include <linux/i2c.h>
-#include <linux/init.h>
-#include <linux/input.h>
-#include <linux/input/sh_keysc.h>
-#include <linux/interrupt.h>
-#include <linux/memblock.h>
-#include <linux/mfd/tmio.h>
-#include <linux/mmc/host.h>
-#include <linux/mtd/physmap.h>
-#include <linux/platform_data/lv5207lp.h>
-#include <linux/platform_device.h>
-#include <linux/regulator/fixed.h>
-#include <linux/regulator/machine.h>
-#include <linux/sh_intc.h>
-#include <linux/usb/r8a66597.h>
-#include <linux/videodev2.h>
-#include <linux/dma-map-ops.h>
-
-#include <mach/kfr2r09.h>
-
-#include <media/drv-intf/renesas-ceu.h>
-#include <media/i2c/rj54n1cb0c.h>
-
-#include <video/sh_mobile_lcdc.h>
-
-#define CEU_BUFFER_MEMORY_SIZE		(4 << 20)
-static phys_addr_t ceu_dma_membase;
-
-/* set VIO_CKO clock to 25MHz */
-#define CEU_MCLK_FREQ			25000000
-#define DRVCRB				0xA405018C
-
-static struct mtd_partition kfr2r09_nor_flash_partitions[] =
-{
-	{
-		.name = "boot",
-		.offset = 0,
-		.size = (4 * 1024 * 1024),
-		.mask_flags = MTD_WRITEABLE,	/* Read-only */
-	},
-	{
-		.name = "other",
-		.offset = MTDPART_OFS_APPEND,
-		.size = MTDPART_SIZ_FULL,
-	},
-};
-
-static struct physmap_flash_data kfr2r09_nor_flash_data = {
-	.width		= 2,
-	.parts		= kfr2r09_nor_flash_partitions,
-	.nr_parts	= ARRAY_SIZE(kfr2r09_nor_flash_partitions),
-};
-
-static struct resource kfr2r09_nor_flash_resources[] = {
-	[0] = {
-		.name		= "NOR Flash",
-		.start		= 0x00000000,
-		.end		= 0x03ffffff,
-		.flags		= IORESOURCE_MEM,
-	}
-};
-
-static struct platform_device kfr2r09_nor_flash_device = {
-	.name		= "physmap-flash",
-	.resource	= kfr2r09_nor_flash_resources,
-	.num_resources	= ARRAY_SIZE(kfr2r09_nor_flash_resources),
-	.dev		= {
-		.platform_data = &kfr2r09_nor_flash_data,
-	},
-};
-
-static struct resource kfr2r09_nand_flash_resources[] = {
-	[0] = {
-		.name		= "NAND Flash",
-		.start		= 0x10000000,
-		.end		= 0x1001ffff,
-		.flags		= IORESOURCE_MEM,
-	}
-};
-
-static struct platform_device kfr2r09_nand_flash_device = {
-	.name		= "onenand-flash",
-	.resource	= kfr2r09_nand_flash_resources,
-	.num_resources	= ARRAY_SIZE(kfr2r09_nand_flash_resources),
-};
-
-static struct sh_keysc_info kfr2r09_sh_keysc_info = {
-	.mode = SH_KEYSC_MODE_1, /* KEYOUT0->4, KEYIN0->4 */
-	.scan_timing = 3,
-	.delay = 10,
-	.keycodes = {
-		KEY_PHONE, KEY_CLEAR, KEY_MAIL, KEY_WWW, KEY_ENTER,
-		KEY_1, KEY_2, KEY_3, 0, KEY_UP,
-		KEY_4, KEY_5, KEY_6, 0, KEY_LEFT,
-		KEY_7, KEY_8, KEY_9, KEY_PROG1, KEY_RIGHT,
-		KEY_S, KEY_0, KEY_P, KEY_PROG2, KEY_DOWN,
-		0, 0, 0, 0, 0
-	},
-};
-
-static struct resource kfr2r09_sh_keysc_resources[] = {
-	[0] = {
-		.name	= "KEYSC",
-		.start  = 0x044b0000,
-		.end    = 0x044b000f,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0xbe0),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device kfr2r09_sh_keysc_device = {
-	.name           = "sh_keysc",
-	.id             = 0, /* "keysc0" clock */
-	.num_resources  = ARRAY_SIZE(kfr2r09_sh_keysc_resources),
-	.resource       = kfr2r09_sh_keysc_resources,
-	.dev	= {
-		.platform_data	= &kfr2r09_sh_keysc_info,
-	},
-};
-
-static const struct fb_videomode kfr2r09_lcdc_modes[] = {
-	{
-		.name = "TX07D34VM0AAA",
-		.xres = 240,
-		.yres = 400,
-		.left_margin = 0,
-		.right_margin = 16,
-		.hsync_len = 8,
-		.upper_margin = 0,
-		.lower_margin = 1,
-		.vsync_len = 1,
-		.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-	},
-};
-
-static struct sh_mobile_lcdc_info kfr2r09_sh_lcdc_info = {
-	.clock_source = LCDC_CLK_BUS,
-	.ch[0] = {
-		.chan = LCDC_CHAN_MAINLCD,
-		.fourcc = V4L2_PIX_FMT_RGB565,
-		.interface_type = SYS18,
-		.clock_divider = 6,
-		.flags = LCDC_FLAGS_DWPOL,
-		.lcd_modes = kfr2r09_lcdc_modes,
-		.num_modes = ARRAY_SIZE(kfr2r09_lcdc_modes),
-		.panel_cfg = {
-			.width = 35,
-			.height = 58,
-			.setup_sys = kfr2r09_lcd_setup,
-			.start_transfer = kfr2r09_lcd_start,
-		},
-		.sys_bus_cfg = {
-			.ldmt2r = 0x07010904,
-			.ldmt3r = 0x14012914,
-			/* set 1s delay to encourage fsync() */
-			.deferred_io_msec = 1000,
-		},
-	}
-};
-
-static struct resource kfr2r09_sh_lcdc_resources[] = {
-	[0] = {
-		.name	= "LCDC",
-		.start	= 0xfe940000, /* P4-only space */
-		.end	= 0xfe942fff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0xf40),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device kfr2r09_sh_lcdc_device = {
-	.name		= "sh_mobile_lcdc_fb",
-	.num_resources	= ARRAY_SIZE(kfr2r09_sh_lcdc_resources),
-	.resource	= kfr2r09_sh_lcdc_resources,
-	.dev	= {
-		.platform_data	= &kfr2r09_sh_lcdc_info,
-	},
-};
-
-static struct lv5207lp_platform_data kfr2r09_backlight_data = {
-	.fbdev = &kfr2r09_sh_lcdc_device.dev,
-	.def_value = 13,
-	.max_value = 13,
-};
-
-static struct i2c_board_info kfr2r09_backlight_board_info = {
-	I2C_BOARD_INFO("lv5207lp", 0x75),
-	.platform_data = &kfr2r09_backlight_data,
-};
-
-static struct r8a66597_platdata kfr2r09_usb0_gadget_data = {
-	.on_chip = 1,
-};
-
-static struct resource kfr2r09_usb0_gadget_resources[] = {
-	[0] = {
-		.start	= 0x04d80000,
-		.end	= 0x04d80123,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0xa20),
-		.end	= evt2irq(0xa20),
-		.flags	= IORESOURCE_IRQ | IRQF_TRIGGER_LOW,
-	},
-};
-
-static struct platform_device kfr2r09_usb0_gadget_device = {
-	.name		= "r8a66597_udc",
-	.id		= 0,
-	.dev = {
-		.dma_mask		= NULL,         /*  not use dma */
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data	= &kfr2r09_usb0_gadget_data,
-	},
-	.num_resources	= ARRAY_SIZE(kfr2r09_usb0_gadget_resources),
-	.resource	= kfr2r09_usb0_gadget_resources,
-};
-
-static struct ceu_platform_data ceu_pdata = {
-	.num_subdevs			= 1,
-	.subdevs = {
-		{ /* [0] = rj54n1cb0c */
-			.flags		= 0,
-			.bus_width	= 8,
-			.bus_shift	= 0,
-			.i2c_adapter_id	= 1,
-			.i2c_address	= 0x50,
-		},
-	},
-};
-
-static struct resource kfr2r09_ceu_resources[] = {
-	[0] = {
-		.name	= "CEU",
-		.start	= 0xfe910000,
-		.end	= 0xfe91009f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0x880),
-		.end	= evt2irq(0x880),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device kfr2r09_ceu_device = {
-	.name		= "renesas-ceu",
-	.id             = 0, /* "ceu0" clock */
-	.num_resources	= ARRAY_SIZE(kfr2r09_ceu_resources),
-	.resource	= kfr2r09_ceu_resources,
-	.dev	= {
-		.platform_data	= &ceu_pdata,
-	},
-};
-
-static struct rj54n1_pdata rj54n1_priv = {
-	.mclk_freq	= CEU_MCLK_FREQ,
-	.ioctl_high	= false,
-};
-
-static struct i2c_board_info kfr2r09_i2c_camera = {
-	I2C_BOARD_INFO("rj54n1cb0c", 0x50),
-	.platform_data = &rj54n1_priv,
-};
-
-static struct gpiod_lookup_table rj54n1_gpios = {
-	.dev_id		= "1-0050",
-	.table		= {
-		GPIO_LOOKUP("sh7724_pfc", GPIO_PTB4, "poweron",
-			    GPIO_ACTIVE_HIGH),
-		GPIO_LOOKUP("sh7724_pfc", GPIO_PTB7, "enable",
-			    GPIO_ACTIVE_HIGH),
-	},
-};
-
-/* Fixed 3.3V regulator to be used by SDHI0 */
-static struct regulator_consumer_supply fixed3v3_power_consumers[] =
-{
-	REGULATOR_SUPPLY("vmmc", "sh_mobile_sdhi.0"),
-	REGULATOR_SUPPLY("vqmmc", "sh_mobile_sdhi.0"),
-};
-
-static struct resource kfr2r09_sh_sdhi0_resources[] = {
-	[0] = {
-		.name	= "SDHI0",
-		.start  = 0x04ce0000,
-		.end    = 0x04ce00ff,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0xe80),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct tmio_mmc_data sh7724_sdhi0_data = {
-	.chan_priv_tx	= (void *)SHDMA_SLAVE_SDHI0_TX,
-	.chan_priv_rx	= (void *)SHDMA_SLAVE_SDHI0_RX,
-	.capabilities	= MMC_CAP_SDIO_IRQ,
-	.capabilities2	= MMC_CAP2_NO_WRITE_PROTECT,
-};
-
-static struct platform_device kfr2r09_sh_sdhi0_device = {
-	.name           = "sh_mobile_sdhi",
-	.num_resources  = ARRAY_SIZE(kfr2r09_sh_sdhi0_resources),
-	.resource       = kfr2r09_sh_sdhi0_resources,
-	.dev = {
-		.platform_data	= &sh7724_sdhi0_data,
-	},
-};
-
-static struct platform_device *kfr2r09_devices[] __initdata = {
-	&kfr2r09_nor_flash_device,
-	&kfr2r09_nand_flash_device,
-	&kfr2r09_sh_keysc_device,
-	&kfr2r09_sh_lcdc_device,
-	&kfr2r09_sh_sdhi0_device,
-};
-
-#define BSC_CS0BCR 0xfec10004
-#define BSC_CS0WCR 0xfec10024
-#define BSC_CS4BCR 0xfec10010
-#define BSC_CS4WCR 0xfec10030
-#define PORT_MSELCRB 0xa4050182
-
-#ifdef CONFIG_I2C
-static int kfr2r09_usb0_gadget_i2c_setup(void)
-{
-	struct i2c_adapter *a;
-	struct i2c_msg msg;
-	unsigned char buf[2];
-	int ret;
-
-	a = i2c_get_adapter(0);
-	if (!a)
-		return -ENODEV;
-
-	/* set bit 1 (the second bit) of chip at 0x09, register 0x13 */
-	buf[0] = 0x13;
-	msg.addr = 0x09;
-	msg.buf = buf;
-	msg.len = 1;
-	msg.flags = 0;
-	ret = i2c_transfer(a, &msg, 1);
-	if (ret != 1)
-		return -ENODEV;
-
-	buf[0] = 0;
-	msg.addr = 0x09;
-	msg.buf = buf;
-	msg.len = 1;
-	msg.flags = I2C_M_RD;
-	ret = i2c_transfer(a, &msg, 1);
-	if (ret != 1)
-		return -ENODEV;
-
-	buf[1] = buf[0] | (1 << 1);
-	buf[0] = 0x13;
-	msg.addr = 0x09;
-	msg.buf = buf;
-	msg.len = 2;
-	msg.flags = 0;
-	ret = i2c_transfer(a, &msg, 1);
-	if (ret != 1)
-		return -ENODEV;
-
-	return 0;
-}
-
-static int kfr2r09_serial_i2c_setup(void)
-{
-	struct i2c_adapter *a;
-	struct i2c_msg msg;
-	unsigned char buf[2];
-	int ret;
-
-	a = i2c_get_adapter(0);
-	if (!a)
-		return -ENODEV;
-
-	/* set bit 6 (the 7th bit) of chip at 0x09, register 0x13 */
-	buf[0] = 0x13;
-	msg.addr = 0x09;
-	msg.buf = buf;
-	msg.len = 1;
-	msg.flags = 0;
-	ret = i2c_transfer(a, &msg, 1);
-	if (ret != 1)
-		return -ENODEV;
-
-	buf[0] = 0;
-	msg.addr = 0x09;
-	msg.buf = buf;
-	msg.len = 1;
-	msg.flags = I2C_M_RD;
-	ret = i2c_transfer(a, &msg, 1);
-	if (ret != 1)
-		return -ENODEV;
-
-	buf[1] = buf[0] | (1 << 6);
-	buf[0] = 0x13;
-	msg.addr = 0x09;
-	msg.buf = buf;
-	msg.len = 2;
-	msg.flags = 0;
-	ret = i2c_transfer(a, &msg, 1);
-	if (ret != 1)
-		return -ENODEV;
-
-	return 0;
-}
-#else
-static int kfr2r09_usb0_gadget_i2c_setup(void)
-{
-	return -ENODEV;
-}
-
-static int kfr2r09_serial_i2c_setup(void)
-{
-	return -ENODEV;
-}
-#endif
-
-static int kfr2r09_usb0_gadget_setup(void)
-{
-	int plugged_in;
-
-	gpio_request(GPIO_PTN4, NULL); /* USB_DET */
-	gpio_direction_input(GPIO_PTN4);
-	plugged_in = gpio_get_value(GPIO_PTN4);
-	if (!plugged_in)
-		return -ENODEV; /* no cable plugged in */
-
-	if (kfr2r09_usb0_gadget_i2c_setup() != 0)
-		return -ENODEV; /* unable to configure using i2c */
-
-	__raw_writew((__raw_readw(PORT_MSELCRB) & ~0xc000) | 0x8000, PORT_MSELCRB);
-	gpio_request(GPIO_FN_PDSTATUS, NULL); /* R-standby disables USB clock */
-	gpio_request(GPIO_PTV6, NULL); /* USBCLK_ON */
-	gpio_direction_output(GPIO_PTV6, 1); /* USBCLK_ON = H */
-	msleep(20); /* wait 20ms to let the clock settle */
-	clk_enable(clk_get(NULL, "usb0"));
-	__raw_writew(0x0600, 0xa40501d4);
-
-	return 0;
-}
-
-extern char kfr2r09_sdram_enter_start;
-extern char kfr2r09_sdram_enter_end;
-extern char kfr2r09_sdram_leave_start;
-extern char kfr2r09_sdram_leave_end;
-
-static int __init kfr2r09_devices_setup(void)
-{
-	struct clk *camera_clk;
-
-	/* register board specific self-refresh code */
-	sh_mobile_register_self_refresh(SUSP_SH_STANDBY | SUSP_SH_SF |
-					SUSP_SH_RSTANDBY,
-					&kfr2r09_sdram_enter_start,
-					&kfr2r09_sdram_enter_end,
-					&kfr2r09_sdram_leave_start,
-					&kfr2r09_sdram_leave_end);
-
-	regulator_register_always_on(0, "fixed-3.3V", fixed3v3_power_consumers,
-				     ARRAY_SIZE(fixed3v3_power_consumers), 3300000);
-
-	/* enable SCIF1 serial port for YC401 console support */
-	gpio_request(GPIO_FN_SCIF1_RXD, NULL);
-	gpio_request(GPIO_FN_SCIF1_TXD, NULL);
-	kfr2r09_serial_i2c_setup(); /* ECONTMSK(bit6=L10ONEN) set 1 */
-	gpio_request(GPIO_PTG3, NULL); /* HPON_ON */
-	gpio_direction_output(GPIO_PTG3, 1); /* HPON_ON = H */
-
-	/* setup NOR flash at CS0 */
-	__raw_writel(0x36db0400, BSC_CS0BCR);
-	__raw_writel(0x00000500, BSC_CS0WCR);
-
-	/* setup NAND flash at CS4 */
-	__raw_writel(0x36db0400, BSC_CS4BCR);
-	__raw_writel(0x00000500, BSC_CS4WCR);
-
-	/* setup KEYSC pins */
-	gpio_request(GPIO_FN_KEYOUT0, NULL);
-	gpio_request(GPIO_FN_KEYOUT1, NULL);
-	gpio_request(GPIO_FN_KEYOUT2, NULL);
-	gpio_request(GPIO_FN_KEYOUT3, NULL);
-	gpio_request(GPIO_FN_KEYOUT4_IN6, NULL);
-	gpio_request(GPIO_FN_KEYIN0, NULL);
-	gpio_request(GPIO_FN_KEYIN1, NULL);
-	gpio_request(GPIO_FN_KEYIN2, NULL);
-	gpio_request(GPIO_FN_KEYIN3, NULL);
-	gpio_request(GPIO_FN_KEYIN4, NULL);
-	gpio_request(GPIO_FN_KEYOUT5_IN5, NULL);
-
-	/* setup LCDC pins for SYS panel */
-	gpio_request(GPIO_FN_LCDD17, NULL);
-	gpio_request(GPIO_FN_LCDD16, NULL);
-	gpio_request(GPIO_FN_LCDD15, NULL);
-	gpio_request(GPIO_FN_LCDD14, NULL);
-	gpio_request(GPIO_FN_LCDD13, NULL);
-	gpio_request(GPIO_FN_LCDD12, NULL);
-	gpio_request(GPIO_FN_LCDD11, NULL);
-	gpio_request(GPIO_FN_LCDD10, NULL);
-	gpio_request(GPIO_FN_LCDD9, NULL);
-	gpio_request(GPIO_FN_LCDD8, NULL);
-	gpio_request(GPIO_FN_LCDD7, NULL);
-	gpio_request(GPIO_FN_LCDD6, NULL);
-	gpio_request(GPIO_FN_LCDD5, NULL);
-	gpio_request(GPIO_FN_LCDD4, NULL);
-	gpio_request(GPIO_FN_LCDD3, NULL);
-	gpio_request(GPIO_FN_LCDD2, NULL);
-	gpio_request(GPIO_FN_LCDD1, NULL);
-	gpio_request(GPIO_FN_LCDD0, NULL);
-	gpio_request(GPIO_FN_LCDRS, NULL); /* LCD_RS */
-	gpio_request(GPIO_FN_LCDCS, NULL); /* LCD_CS/ */
-	gpio_request(GPIO_FN_LCDRD, NULL); /* LCD_RD/ */
-	gpio_request(GPIO_FN_LCDWR, NULL); /* LCD_WR/ */
-	gpio_request(GPIO_FN_LCDVSYN, NULL); /* LCD_VSYNC */
-	gpio_request(GPIO_PTE4, NULL); /* LCD_RST/ */
-	gpio_direction_output(GPIO_PTE4, 1);
-	gpio_request(GPIO_PTF4, NULL); /* PROTECT/ */
-	gpio_direction_output(GPIO_PTF4, 1);
-	gpio_request(GPIO_PTU0, NULL); /* LEDSTDBY/ */
-	gpio_direction_output(GPIO_PTU0, 1);
-
-	/* setup USB function */
-	if (kfr2r09_usb0_gadget_setup() == 0)
-		platform_device_register(&kfr2r09_usb0_gadget_device);
-
-	/* CEU */
-	gpio_request(GPIO_FN_VIO_CKO, NULL);
-	gpio_request(GPIO_FN_VIO0_CLK, NULL);
-	gpio_request(GPIO_FN_VIO0_VD, NULL);
-	gpio_request(GPIO_FN_VIO0_HD, NULL);
-	gpio_request(GPIO_FN_VIO0_FLD, NULL);
-	gpio_request(GPIO_FN_VIO0_D7, NULL);
-	gpio_request(GPIO_FN_VIO0_D6, NULL);
-	gpio_request(GPIO_FN_VIO0_D5, NULL);
-	gpio_request(GPIO_FN_VIO0_D4, NULL);
-	gpio_request(GPIO_FN_VIO0_D3, NULL);
-	gpio_request(GPIO_FN_VIO0_D2, NULL);
-	gpio_request(GPIO_FN_VIO0_D1, NULL);
-	gpio_request(GPIO_FN_VIO0_D0, NULL);
-
-	/* SDHI0 connected to yc304 */
-	gpio_request(GPIO_FN_SDHI0CD, NULL);
-	gpio_request(GPIO_FN_SDHI0D3, NULL);
-	gpio_request(GPIO_FN_SDHI0D2, NULL);
-	gpio_request(GPIO_FN_SDHI0D1, NULL);
-	gpio_request(GPIO_FN_SDHI0D0, NULL);
-	gpio_request(GPIO_FN_SDHI0CMD, NULL);
-	gpio_request(GPIO_FN_SDHI0CLK, NULL);
-
-	i2c_register_board_info(0, &kfr2r09_backlight_board_info, 1);
-
-	/* Set camera clock frequency and register and alias for rj54n1. */
-	camera_clk = clk_get(NULL, "video_clk");
-	if (!IS_ERR(camera_clk)) {
-		clk_set_rate(camera_clk,
-			     clk_round_rate(camera_clk, CEU_MCLK_FREQ));
-		clk_put(camera_clk);
-	}
-	clk_add_alias(NULL, "1-0050", "video_clk", NULL);
-
-	/* set DRVCRB
-	 *
-	 * use 1.8 V for VccQ_VIO
-	 * use 2.85V for VccQ_SR
-	 */
-	__raw_writew((__raw_readw(DRVCRB) & ~0x0003) | 0x0001, DRVCRB);
-
-	gpiod_add_lookup_table(&rj54n1_gpios);
-
-	i2c_register_board_info(1, &kfr2r09_i2c_camera, 1);
-
-	/* Initialize CEU platform device separately to map memory first */
-	device_initialize(&kfr2r09_ceu_device.dev);
-	dma_declare_coherent_memory(&kfr2r09_ceu_device.dev,
-			ceu_dma_membase, ceu_dma_membase,
-			ceu_dma_membase + CEU_BUFFER_MEMORY_SIZE - 1);
-
-	platform_device_add(&kfr2r09_ceu_device);
-
-	return platform_add_devices(kfr2r09_devices,
-				    ARRAY_SIZE(kfr2r09_devices));
-}
-device_initcall(kfr2r09_devices_setup);
-
-/* Return the board specific boot mode pin configuration */
-static int kfr2r09_mode_pins(void)
-{
-	/* MD0=1, MD1=1, MD2=0: Clock Mode 3
-	 * MD3=0: 16-bit Area0 Bus Width
-	 * MD5=1: Little Endian
-	 * MD8=1: Test Mode Disabled
-	 */
-	return MODE_PIN0 | MODE_PIN1 | MODE_PIN5 | MODE_PIN8;
-}
-
-/* Reserve a portion of memory for CEU buffers */
-static void __init kfr2r09_mv_mem_reserve(void)
-{
-	phys_addr_t phys;
-	phys_addr_t size = CEU_BUFFER_MEMORY_SIZE;
-
-	phys = memblock_phys_alloc(size, PAGE_SIZE);
-	if (!phys)
-		panic("Failed to allocate CEU memory\n");
-
-	memblock_phys_free(phys, size);
-	memblock_remove(phys, size);
-
-	ceu_dma_membase = phys;
-}
-
-/*
- * The Machine Vector
- */
-static struct sh_machine_vector mv_kfr2r09 __initmv = {
-	.mv_name		= "kfr2r09",
-	.mv_mode_pins		= kfr2r09_mode_pins,
-	.mv_mem_reserve         = kfr2r09_mv_mem_reserve,
-};
diff --git a/arch/sh/boards/mach-landisk/Makefile b/arch/sh/boards/mach-landisk/Makefile
deleted file mode 100644
index 6cba041fffe0f3..00000000000000
--- a/arch/sh/boards/mach-landisk/Makefile
+++ /dev/null
@@ -1,6 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for I-O DATA DEVICE, INC. "LANDISK Series"
-#
-
-obj-y	 := setup.o irq.o psw.o gio.o
diff --git a/arch/sh/boards/mach-landisk/gio.c b/arch/sh/boards/mach-landisk/gio.c
deleted file mode 100644
index ff2200fec29a76..00000000000000
--- a/arch/sh/boards/mach-landisk/gio.c
+++ /dev/null
@@ -1,164 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/boards/landisk/gio.c - driver for landisk
- *
- * This driver will also support the I-O DATA Device, Inc. LANDISK Board.
- * LANDISK and USL-5P Button, LED and GIO driver drive function.
- *
- *   Copylight (C) 2006 kogiidena
- *   Copylight (C) 2002 Atom Create Engineering Co., Ltd. *
- */
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/kdev_t.h>
-#include <linux/cdev.h>
-#include <linux/fs.h>
-#include <asm/io.h>
-#include <linux/uaccess.h>
-#include <mach-landisk/mach/gio.h>
-#include <mach-landisk/mach/iodata_landisk.h>
-
-#define DEVCOUNT                4
-#define GIO_MINOR	        2	/* GIO minor no. */
-
-static dev_t dev;
-static struct cdev *cdev_p;
-static int openCnt;
-
-static int gio_open(struct inode *inode, struct file *filp)
-{
-	int minor = iminor(inode);
-	int ret = -ENOENT;
-
-	preempt_disable();
-	if (minor < DEVCOUNT) {
-		if (openCnt > 0) {
-			ret = -EALREADY;
-		} else {
-			openCnt++;
-			ret = 0;
-		}
-	}
-	preempt_enable();
-	return ret;
-}
-
-static int gio_close(struct inode *inode, struct file *filp)
-{
-	int minor = iminor(inode);
-
-	if (minor < DEVCOUNT) {
-		openCnt--;
-	}
-	return 0;
-}
-
-static long gio_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
-{
-	unsigned int data;
-	static unsigned int addr = 0;
-
-	if (cmd & 0x01) {	/* write */
-		if (copy_from_user(&data, (int *)arg, sizeof(int))) {
-			return -EFAULT;
-		}
-	}
-
-	switch (cmd) {
-	case GIODRV_IOCSGIOSETADDR:	/* address set */
-		addr = data;
-		break;
-
-	case GIODRV_IOCSGIODATA1:	/* write byte */
-		__raw_writeb((unsigned char)(0x0ff & data), addr);
-		break;
-
-	case GIODRV_IOCSGIODATA2:	/* write word */
-		if (addr & 0x01) {
-			return -EFAULT;
-		}
-		__raw_writew((unsigned short int)(0x0ffff & data), addr);
-		break;
-
-	case GIODRV_IOCSGIODATA4:	/* write long */
-		if (addr & 0x03) {
-			return -EFAULT;
-		}
-		__raw_writel(data, addr);
-		break;
-
-	case GIODRV_IOCGGIODATA1:	/* read byte */
-		data = __raw_readb(addr);
-		break;
-
-	case GIODRV_IOCGGIODATA2:	/* read word */
-		if (addr & 0x01) {
-			return -EFAULT;
-		}
-		data = __raw_readw(addr);
-		break;
-
-	case GIODRV_IOCGGIODATA4:	/* read long */
-		if (addr & 0x03) {
-			return -EFAULT;
-		}
-		data = __raw_readl(addr);
-		break;
-	default:
-		return -EFAULT;
-		break;
-	}
-
-	if ((cmd & 0x01) == 0) {	/* read */
-		if (copy_to_user((int *)arg, &data, sizeof(int))) {
-			return -EFAULT;
-		}
-	}
-	return 0;
-}
-
-static const struct file_operations gio_fops = {
-	.owner = THIS_MODULE,
-	.open = gio_open,	/* open */
-	.release = gio_close,	/* release */
-	.unlocked_ioctl = gio_ioctl,
-	.llseek = noop_llseek,
-};
-
-static int __init gio_init(void)
-{
-	int error;
-
-	printk(KERN_INFO "gio: driver initialized\n");
-
-	openCnt = 0;
-
-	if ((error = alloc_chrdev_region(&dev, 0, DEVCOUNT, "gio")) < 0) {
-		printk(KERN_ERR
-		       "gio: Couldn't alloc_chrdev_region, error=%d\n",
-		       error);
-		return 1;
-	}
-
-	cdev_p = cdev_alloc();
-	cdev_p->ops = &gio_fops;
-	error = cdev_add(cdev_p, dev, DEVCOUNT);
-	if (error) {
-		printk(KERN_ERR
-		       "gio: Couldn't cdev_add, error=%d\n", error);
-		return 1;
-	}
-
-	return 0;
-}
-
-static void __exit gio_exit(void)
-{
-	cdev_del(cdev_p);
-	unregister_chrdev_region(dev, DEVCOUNT);
-}
-
-module_init(gio_init);
-module_exit(gio_exit);
-
-MODULE_LICENSE("GPL");
diff --git a/arch/sh/boards/mach-landisk/irq.c b/arch/sh/boards/mach-landisk/irq.c
deleted file mode 100644
index 0b672b80c56179..00000000000000
--- a/arch/sh/boards/mach-landisk/irq.c
+++ /dev/null
@@ -1,63 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/boards/mach-landisk/irq.c
- *
- * I-O DATA Device, Inc. LANDISK Support
- *
- * Copyright (C) 2005-2007 kogiidena
- * Copyright (C) 2011 Nobuhiro Iwamatsu
- *
- * Copyright (C) 2001  Ian da Silva, Jeremy Siegel
- * Based largely on io_se.c.
- */
-
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <linux/io.h>
-#include <mach-landisk/mach/iodata_landisk.h>
-
-enum {
-	UNUSED = 0,
-
-	PCI_INTA, /* PCI int A */
-	PCI_INTB, /* PCI int B */
-	PCI_INTC, /* PCI int C */
-	PCI_INTD, /* PCI int D */
-	ATA,	  /* ATA */
-	FATA,	  /* CF */
-	POWER,	  /* Power switch */
-	BUTTON,	  /* Button switch */
-};
-
-/* Vectors for LANDISK */
-static struct intc_vect vectors_landisk[] __initdata = {
-	INTC_IRQ(PCI_INTA, IRQ_PCIINTA),
-	INTC_IRQ(PCI_INTB, IRQ_PCIINTB),
-	INTC_IRQ(PCI_INTC, IRQ_PCIINTC),
-	INTC_IRQ(PCI_INTD, IRQ_PCIINTD),
-	INTC_IRQ(ATA, IRQ_ATA),
-	INTC_IRQ(FATA, IRQ_FATA),
-	INTC_IRQ(POWER, IRQ_POWER),
-	INTC_IRQ(BUTTON, IRQ_BUTTON),
-};
-
-/* IRLMSK mask register layout for LANDISK */
-static struct intc_mask_reg mask_registers_landisk[] __initdata = {
-	{ PA_IMASK, 0, 8, /* IRLMSK */
-	  {  BUTTON, POWER, FATA, ATA,
-	     PCI_INTD, PCI_INTC, PCI_INTB, PCI_INTA,
-	  }
-	},
-};
-
-static DECLARE_INTC_DESC(intc_desc_landisk, "landisk", vectors_landisk, NULL,
-			mask_registers_landisk, NULL, NULL);
-/*
- * Initialize IRQ setting
- */
-void __init init_landisk_IRQ(void)
-{
-	register_intc_controller(&intc_desc_landisk);
-	__raw_writeb(0x00, PA_PWRINT_CLR);
-}
diff --git a/arch/sh/boards/mach-landisk/psw.c b/arch/sh/boards/mach-landisk/psw.c
deleted file mode 100644
index e171d9af48f3df..00000000000000
--- a/arch/sh/boards/mach-landisk/psw.c
+++ /dev/null
@@ -1,140 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/boards/landisk/psw.c
- *
- * push switch support for LANDISK and USL-5P
- *
- * Copyright (C) 2006-2007  Paul Mundt
- * Copyright (C) 2007  kogiidena
- */
-#include <linux/io.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <mach-landisk/mach/iodata_landisk.h>
-#include <asm/push-switch.h>
-
-static irqreturn_t psw_irq_handler(int irq, void *arg)
-{
-	struct platform_device *pdev = arg;
-	struct push_switch *psw = platform_get_drvdata(pdev);
-	struct push_switch_platform_info *psw_info = pdev->dev.platform_data;
-	unsigned int sw_value;
-	int ret = 0;
-
-	sw_value = (0x0ff & (~__raw_readb(PA_STATUS)));
-
-	/* Nothing to do if there's no state change */
-	if (psw->state) {
-		ret = 1;
-		goto out;
-	}
-
-	/* Figure out who raised it */
-	if (sw_value & (1 << psw_info->bit)) {
-		psw->state = 1;
-		mod_timer(&psw->debounce, jiffies + 50);
-		ret = 1;
-	}
-
-out:
-	/* Clear the switch IRQs */
-	__raw_writeb(0x00, PA_PWRINT_CLR);
-
-	return IRQ_RETVAL(ret);
-}
-
-static struct resource psw_power_resources[] = {
-	[0] = {
-		.start = IRQ_POWER,
-		.flags = IORESOURCE_IRQ,
-       },
-};
-
-static struct resource psw_usl5p_resources[] = {
-	[0] = {
-		.start = IRQ_BUTTON,
-		.flags = IORESOURCE_IRQ,
-	},
-};
-
-static struct push_switch_platform_info psw_power_platform_data = {
-	.name		= "psw_power",
-	.bit		= 4,
-	.irq_flags	= IRQF_SHARED,
-	.irq_handler	= psw_irq_handler,
-};
-
-static struct push_switch_platform_info psw1_platform_data = {
-	.name		= "psw1",
-	.bit		= 0,
-	.irq_flags	= IRQF_SHARED,
-	.irq_handler	= psw_irq_handler,
-};
-
-static struct push_switch_platform_info psw2_platform_data = {
-	.name		= "psw2",
-	.bit		= 2,
-	.irq_flags	= IRQF_SHARED,
-	.irq_handler	= psw_irq_handler,
-};
-
-static struct push_switch_platform_info psw3_platform_data = {
-	.name		= "psw3",
-	.bit		= 1,
-	.irq_flags	= IRQF_SHARED,
-	.irq_handler	= psw_irq_handler,
-};
-
-static struct platform_device psw_power_switch_device = {
-	.name		= "push-switch",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(psw_power_resources),
-	.resource	= psw_power_resources,
-	.dev		= {
-		.platform_data = &psw_power_platform_data,
-	},
-};
-
-static struct platform_device psw1_switch_device = {
-	.name		= "push-switch",
-	.id		= 1,
-	.num_resources	= ARRAY_SIZE(psw_usl5p_resources),
-	.resource	= psw_usl5p_resources,
-	.dev		= {
-		.platform_data = &psw1_platform_data,
-	},
-};
-
-static struct platform_device psw2_switch_device = {
-	.name		= "push-switch",
-	.id		= 2,
-	.num_resources	= ARRAY_SIZE(psw_usl5p_resources),
-	.resource	= psw_usl5p_resources,
-	.dev		= {
-		.platform_data = &psw2_platform_data,
-	},
-};
-
-static struct platform_device psw3_switch_device = {
-	.name		= "push-switch",
-	.id		= 3,
-	.num_resources	= ARRAY_SIZE(psw_usl5p_resources),
-	.resource	= psw_usl5p_resources,
-	.dev = {
-		.platform_data = &psw3_platform_data,
-	},
-};
-
-static struct platform_device *psw_devices[] = {
-	&psw_power_switch_device,
-	&psw1_switch_device,
-	&psw2_switch_device,
-	&psw3_switch_device,
-};
-
-static int __init psw_init(void)
-{
-	return platform_add_devices(psw_devices, ARRAY_SIZE(psw_devices));
-}
-device_initcall(psw_init);
diff --git a/arch/sh/boards/mach-landisk/setup.c b/arch/sh/boards/mach-landisk/setup.c
deleted file mode 100644
index 2c44b94f82fb27..00000000000000
--- a/arch/sh/boards/mach-landisk/setup.c
+++ /dev/null
@@ -1,102 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/boards/landisk/setup.c
- *
- * I-O DATA Device, Inc. LANDISK Support.
- *
- * Copyright (C) 2000 Kazumoto Kojima
- * Copyright (C) 2002 Paul Mundt
- * Copylight (C) 2002 Atom Create Engineering Co., Ltd.
- * Copyright (C) 2005-2007 kogiidena
- */
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/ata_platform.h>
-#include <linux/pm.h>
-#include <linux/mm.h>
-#include <asm/machvec.h>
-#include <mach-landisk/mach/iodata_landisk.h>
-#include <asm/io.h>
-
-static void landisk_power_off(void)
-{
-	__raw_writeb(0x01, PA_SHUTDOWN);
-}
-
-static struct resource cf_ide_resources[3];
-
-static struct pata_platform_info pata_info = {
-	.ioport_shift	= 1,
-};
-
-static struct platform_device cf_ide_device = {
-	.name		= "pata_platform",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(cf_ide_resources),
-	.resource	= cf_ide_resources,
-	.dev		= {
-		.platform_data = &pata_info,
-	},
-};
-
-static struct platform_device rtc_device = {
-	.name		= "rs5c313",
-	.id		= -1,
-};
-
-static struct platform_device *landisk_devices[] __initdata = {
-	&cf_ide_device,
-	&rtc_device,
-};
-
-static int __init landisk_devices_setup(void)
-{
-	pgprot_t prot;
-	unsigned long paddrbase;
-	void *cf_ide_base;
-
-	/* open I/O area window */
-	paddrbase = virt_to_phys((void *)PA_AREA5_IO);
-	prot = PAGE_KERNEL_PCC(1, _PAGE_PCC_IO16);
-	cf_ide_base = ioremap_prot(paddrbase, PAGE_SIZE, pgprot_val(prot));
-	if (!cf_ide_base) {
-		printk("allocate_cf_area : can't open CF I/O window!\n");
-		return -ENOMEM;
-	}
-
-	/* IDE cmd address : 0x1f0-0x1f7 and 0x3f6 */
-	cf_ide_resources[0].start = (unsigned long)cf_ide_base + 0x40;
-	cf_ide_resources[0].end   = (unsigned long)cf_ide_base + 0x40 + 0x0f;
-	cf_ide_resources[0].flags = IORESOURCE_IO;
-	cf_ide_resources[1].start = (unsigned long)cf_ide_base + 0x2c;
-	cf_ide_resources[1].end   = (unsigned long)cf_ide_base + 0x2c + 0x03;
-	cf_ide_resources[1].flags = IORESOURCE_IO;
-	cf_ide_resources[2].start = IRQ_FATA;
-	cf_ide_resources[2].flags = IORESOURCE_IRQ;
-
-	return platform_add_devices(landisk_devices,
-				    ARRAY_SIZE(landisk_devices));
-}
-
-device_initcall(landisk_devices_setup);
-
-static void __init landisk_setup(char **cmdline_p)
-{
-	/* I/O port identity mapping */
-	__set_io_port_base(0);
-
-	/* LED ON */
-	__raw_writeb(__raw_readb(PA_LED) | 0x03, PA_LED);
-
-	printk(KERN_INFO "I-O DATA DEVICE, INC. \"LANDISK Series\" support.\n");
-	pm_power_off = landisk_power_off;
-}
-
-/*
- * The Machine Vector
- */
-static struct sh_machine_vector mv_landisk __initmv = {
-	.mv_name = "LANDISK",
-	.mv_setup = landisk_setup,
-	.mv_init_irq = init_landisk_IRQ,
-};
diff --git a/arch/sh/boards/mach-lboxre2/Makefile b/arch/sh/boards/mach-lboxre2/Makefile
deleted file mode 100644
index 0fbd0822911a49..00000000000000
--- a/arch/sh/boards/mach-lboxre2/Makefile
+++ /dev/null
@@ -1,6 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the L-BOX RE2 specific parts of the kernel
-# Copyright (c) 2007 Nobuhiro Iwamatsu
-
-obj-y	 := setup.o irq.o
diff --git a/arch/sh/boards/mach-lboxre2/irq.c b/arch/sh/boards/mach-lboxre2/irq.c
deleted file mode 100644
index a250e3b9019de1..00000000000000
--- a/arch/sh/boards/mach-lboxre2/irq.c
+++ /dev/null
@@ -1,27 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/lboxre2/irq.c
- *
- * Copyright (C) 2007 Nobuhiro Iwamatsu
- *
- * NTT COMWARE L-BOX RE2 Support.
- */
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <asm/irq.h>
-#include <asm/io.h>
-#include <mach/lboxre2.h>
-
-/*
- * Initialize IRQ setting
- */
-void __init init_lboxre2_IRQ(void)
-{
-	make_imask_irq(IRQ_CF1);
-	make_imask_irq(IRQ_CF0);
-	make_imask_irq(IRQ_INTD);
-	make_imask_irq(IRQ_ETH1);
-	make_imask_irq(IRQ_ETH0);
-	make_imask_irq(IRQ_INTA);
-}
diff --git a/arch/sh/boards/mach-lboxre2/setup.c b/arch/sh/boards/mach-lboxre2/setup.c
deleted file mode 100644
index 20d01b430f2a81..00000000000000
--- a/arch/sh/boards/mach-lboxre2/setup.c
+++ /dev/null
@@ -1,79 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/lbox/setup.c
- *
- * Copyright (C) 2007 Nobuhiro Iwamatsu
- *
- * NTT COMWARE L-BOX RE2 Support
- */
-
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/ata_platform.h>
-#include <asm/machvec.h>
-#include <asm/addrspace.h>
-#include <mach/lboxre2.h>
-#include <asm/io.h>
-
-static struct resource cf_ide_resources[] = {
-	[0] = {
-		.start  = 0x1f0,
-		.end    = 0x1f0 + 8 ,
-		.flags  = IORESOURCE_IO,
-	},
-	[1] = {
-		.start  = 0x1f0 + 0x206,
-		.end    = 0x1f0 +8 + 0x206 + 8,
-		.flags  = IORESOURCE_IO,
-	},
-	[2] = {
-		.start  = IRQ_CF0,
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device cf_ide_device  = {
-	.name           = "pata_platform",
-	.id             = -1,
-	.num_resources  = ARRAY_SIZE(cf_ide_resources),
-	.resource       = cf_ide_resources,
-};
-
-static struct platform_device *lboxre2_devices[] __initdata = {
-       &cf_ide_device,
-};
-
-static int __init lboxre2_devices_setup(void)
-{
-	u32 cf0_io_base;	/* Boot CF base address */
-	pgprot_t prot;
-	unsigned long paddrbase, psize;
-
-	/* open I/O area window */
-	paddrbase = virt_to_phys((void*)PA_AREA5_IO);
-	psize = PAGE_SIZE;
-	prot = PAGE_KERNEL_PCC(1, _PAGE_PCC_IO16);
-	cf0_io_base = (u32)ioremap_prot(paddrbase, psize, pgprot_val(prot));
-	if (!cf0_io_base) {
-		printk(KERN_ERR "%s : can't open CF I/O window!\n" , __func__ );
-		return -ENOMEM;
-	}
-
-	cf_ide_resources[0].start += cf0_io_base ;
-	cf_ide_resources[0].end   += cf0_io_base ;
-	cf_ide_resources[1].start += cf0_io_base ;
-	cf_ide_resources[1].end   += cf0_io_base ;
-
-	return platform_add_devices(lboxre2_devices,
-			ARRAY_SIZE(lboxre2_devices));
-
-}
-device_initcall(lboxre2_devices_setup);
-
-/*
- * The Machine Vector
- */
-static struct sh_machine_vector mv_lboxre2 __initmv = {
-	.mv_name		= "L-BOX RE2",
-	.mv_init_irq		= init_lboxre2_IRQ,
-};
diff --git a/arch/sh/boards/mach-microdev/Makefile b/arch/sh/boards/mach-microdev/Makefile
deleted file mode 100644
index 05c5698dcad025..00000000000000
--- a/arch/sh/boards/mach-microdev/Makefile
+++ /dev/null
@@ -1,6 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the SuperH MicroDev specific parts of the kernel
-#
-
-obj-y	 := setup.o irq.o io.o fdc37c93xapm.o
diff --git a/arch/sh/boards/mach-microdev/fdc37c93xapm.c b/arch/sh/boards/mach-microdev/fdc37c93xapm.c
deleted file mode 100644
index 2a04f72dd14577..00000000000000
--- a/arch/sh/boards/mach-microdev/fdc37c93xapm.c
+++ /dev/null
@@ -1,157 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Setup for the SMSC FDC37C93xAPM
- *
- * Copyright (C) 2003 Sean McGoogan (Sean.McGoogan@superh.com)
- * Copyright (C) 2003, 2004 SuperH, Inc.
- * Copyright (C) 2004, 2005 Paul Mundt
- *
- * SuperH SH4-202 MicroDev board support.
- */
-#include <linux/init.h>
-#include <linux/ioport.h>
-#include <linux/io.h>
-#include <linux/err.h>
-#include <mach/microdev.h>
-
-#define SMSC_CONFIG_PORT_ADDR	 (0x3F0)
-#define SMSC_INDEX_PORT_ADDR	 SMSC_CONFIG_PORT_ADDR
-#define SMSC_DATA_PORT_ADDR	 (SMSC_INDEX_PORT_ADDR + 1)
-
-#define SMSC_ENTER_CONFIG_KEY	 0x55
-#define SMSC_EXIT_CONFIG_KEY	 0xaa
-
-#define SMCS_LOGICAL_DEV_INDEX	 0x07	/* Logical Device Number */
-#define SMSC_DEVICE_ID_INDEX	 0x20	/* Device ID */
-#define SMSC_DEVICE_REV_INDEX	 0x21	/* Device Revision */
-#define SMSC_ACTIVATE_INDEX	 0x30	/* Activate */
-#define SMSC_PRIMARY_BASE_INDEX	 0x60	/* Primary Base Address */
-#define SMSC_SECONDARY_BASE_INDEX 0x62	/* Secondary Base Address */
-#define SMSC_PRIMARY_INT_INDEX	 0x70	/* Primary Interrupt Select */
-#define SMSC_SECONDARY_INT_INDEX 0x72	/* Secondary Interrupt Select */
-#define SMSC_HDCS0_INDEX	 0xf0	/* HDCS0 Address Decoder */
-#define SMSC_HDCS1_INDEX	 0xf1	/* HDCS1 Address Decoder */
-
-#define SMSC_IDE1_DEVICE	1	/* IDE #1 logical device */
-#define SMSC_IDE2_DEVICE	2	/* IDE #2 logical device */
-#define SMSC_PARALLEL_DEVICE	3	/* Parallel Port logical device */
-#define SMSC_SERIAL1_DEVICE	4	/* Serial #1 logical device */
-#define SMSC_SERIAL2_DEVICE	5	/* Serial #2 logical device */
-#define SMSC_KEYBOARD_DEVICE	7	/* Keyboard logical device */
-#define SMSC_CONFIG_REGISTERS	8	/* Configuration Registers (Aux I/O) */
-
-#define SMSC_READ_INDEXED(index) ({ \
-	outb((index), SMSC_INDEX_PORT_ADDR); \
-	inb(SMSC_DATA_PORT_ADDR); })
-#define SMSC_WRITE_INDEXED(val, index) ({ \
-	outb((index), SMSC_INDEX_PORT_ADDR); \
-	outb((val),   SMSC_DATA_PORT_ADDR); })
-
-#define	IDE1_PRIMARY_BASE	0x01f0	/* Task File Registe base for IDE #1 */
-#define	IDE1_SECONDARY_BASE	0x03f6	/* Miscellaneous AT registers for IDE #1 */
-#define	IDE2_PRIMARY_BASE	0x0170	/* Task File Registe base for IDE #2 */
-#define	IDE2_SECONDARY_BASE	0x0376	/* Miscellaneous AT registers for IDE #2 */
-
-#define SERIAL1_PRIMARY_BASE	0x03f8
-#define SERIAL2_PRIMARY_BASE	0x02f8
-
-#define	MSB(x)		( (x) >> 8 )
-#define	LSB(x)		( (x) & 0xff )
-
-	/* General-Purpose base address on CPU-board FPGA */
-#define	MICRODEV_FPGA_GP_BASE		0xa6100000ul
-
-static int __init smsc_superio_setup(void)
-{
-
-	unsigned char devid, devrev;
-
-		/* Initially the chip is in run state */
-		/* Put it into configuration state */
-	outb(SMSC_ENTER_CONFIG_KEY, SMSC_CONFIG_PORT_ADDR);
-
-		/* Read device ID info */
-	devid  = SMSC_READ_INDEXED(SMSC_DEVICE_ID_INDEX);
-	devrev = SMSC_READ_INDEXED(SMSC_DEVICE_REV_INDEX);
-
-	if ((devid == 0x30) && (devrev == 0x01))
-		printk("SMSC FDC37C93xAPM SuperIO device detected\n");
-	else
-		return -ENODEV;
-
-		/* Select the keyboard device */
-	SMSC_WRITE_INDEXED(SMSC_KEYBOARD_DEVICE, SMCS_LOGICAL_DEV_INDEX);
-		/* enable it */
-	SMSC_WRITE_INDEXED(1, SMSC_ACTIVATE_INDEX);
-		/* enable the interrupts */
-	SMSC_WRITE_INDEXED(MICRODEV_FPGA_IRQ_KEYBOARD, SMSC_PRIMARY_INT_INDEX);
-	SMSC_WRITE_INDEXED(MICRODEV_FPGA_IRQ_MOUSE, SMSC_SECONDARY_INT_INDEX);
-
-		/* Select the Serial #1 device */
-	SMSC_WRITE_INDEXED(SMSC_SERIAL1_DEVICE, SMCS_LOGICAL_DEV_INDEX);
-		/* enable it */
-	SMSC_WRITE_INDEXED(1, SMSC_ACTIVATE_INDEX);
-		/* program with port addresses */
-	SMSC_WRITE_INDEXED(MSB(SERIAL1_PRIMARY_BASE), SMSC_PRIMARY_BASE_INDEX+0);
-	SMSC_WRITE_INDEXED(LSB(SERIAL1_PRIMARY_BASE), SMSC_PRIMARY_BASE_INDEX+1);
-	SMSC_WRITE_INDEXED(0x00, SMSC_HDCS0_INDEX);
-		/* enable the interrupts */
-	SMSC_WRITE_INDEXED(MICRODEV_FPGA_IRQ_SERIAL1, SMSC_PRIMARY_INT_INDEX);
-
-		/* Select the Serial #2 device */
-	SMSC_WRITE_INDEXED(SMSC_SERIAL2_DEVICE, SMCS_LOGICAL_DEV_INDEX);
-		/* enable it */
-	SMSC_WRITE_INDEXED(1, SMSC_ACTIVATE_INDEX);
-		/* program with port addresses */
-	SMSC_WRITE_INDEXED(MSB(SERIAL2_PRIMARY_BASE), SMSC_PRIMARY_BASE_INDEX+0);
-	SMSC_WRITE_INDEXED(LSB(SERIAL2_PRIMARY_BASE), SMSC_PRIMARY_BASE_INDEX+1);
-	SMSC_WRITE_INDEXED(0x00, SMSC_HDCS0_INDEX);
-		/* enable the interrupts */
-	SMSC_WRITE_INDEXED(MICRODEV_FPGA_IRQ_SERIAL2, SMSC_PRIMARY_INT_INDEX);
-
-		/* Select the IDE#1 device */
-	SMSC_WRITE_INDEXED(SMSC_IDE1_DEVICE, SMCS_LOGICAL_DEV_INDEX);
-		/* enable it */
-	SMSC_WRITE_INDEXED(1, SMSC_ACTIVATE_INDEX);
-		/* program with port addresses */
-	SMSC_WRITE_INDEXED(MSB(IDE1_PRIMARY_BASE), SMSC_PRIMARY_BASE_INDEX+0);
-	SMSC_WRITE_INDEXED(LSB(IDE1_PRIMARY_BASE), SMSC_PRIMARY_BASE_INDEX+1);
-	SMSC_WRITE_INDEXED(MSB(IDE1_SECONDARY_BASE), SMSC_SECONDARY_BASE_INDEX+0);
-	SMSC_WRITE_INDEXED(LSB(IDE1_SECONDARY_BASE), SMSC_SECONDARY_BASE_INDEX+1);
-	SMSC_WRITE_INDEXED(0x0c, SMSC_HDCS0_INDEX);
-	SMSC_WRITE_INDEXED(0x00, SMSC_HDCS1_INDEX);
-		/* select the interrupt */
-	SMSC_WRITE_INDEXED(MICRODEV_FPGA_IRQ_IDE1, SMSC_PRIMARY_INT_INDEX);
-
-		/* Select the IDE#2 device */
-	SMSC_WRITE_INDEXED(SMSC_IDE2_DEVICE, SMCS_LOGICAL_DEV_INDEX);
-		/* enable it */
-	SMSC_WRITE_INDEXED(1, SMSC_ACTIVATE_INDEX);
-		/* program with port addresses */
-	SMSC_WRITE_INDEXED(MSB(IDE2_PRIMARY_BASE), SMSC_PRIMARY_BASE_INDEX+0);
-	SMSC_WRITE_INDEXED(LSB(IDE2_PRIMARY_BASE), SMSC_PRIMARY_BASE_INDEX+1);
-	SMSC_WRITE_INDEXED(MSB(IDE2_SECONDARY_BASE), SMSC_SECONDARY_BASE_INDEX+0);
-	SMSC_WRITE_INDEXED(LSB(IDE2_SECONDARY_BASE), SMSC_SECONDARY_BASE_INDEX+1);
-		/* select the interrupt */
-	SMSC_WRITE_INDEXED(MICRODEV_FPGA_IRQ_IDE2, SMSC_PRIMARY_INT_INDEX);
-
-		/* Select the configuration registers */
-	SMSC_WRITE_INDEXED(SMSC_CONFIG_REGISTERS, SMCS_LOGICAL_DEV_INDEX);
-		/* enable the appropriate GPIO pins for IDE functionality:
-		 * bit[0]   In/Out		1==input;  0==output
-		 * bit[1]   Polarity		1==invert; 0==no invert
-		 * bit[2]   Int Enb #1		1==Enable Combined IRQ #1; 0==disable
-		 * bit[3:4] Function Select	00==original; 01==Alternate Function #1
-		 */
-	SMSC_WRITE_INDEXED(0x00, 0xc2);	/* GP42 = nIDE1_OE */
-	SMSC_WRITE_INDEXED(0x01, 0xc5);	/* GP45 = IDE1_IRQ */
-	SMSC_WRITE_INDEXED(0x00, 0xc6);	/* GP46 = nIOROP */
-	SMSC_WRITE_INDEXED(0x00, 0xc7);	/* GP47 = nIOWOP */
-	SMSC_WRITE_INDEXED(0x08, 0xe8);	/* GP20 = nIDE2_OE */
-
-		/* Exit the configuration state */
-	outb(SMSC_EXIT_CONFIG_KEY, SMSC_CONFIG_PORT_ADDR);
-
-	return 0;
-}
-device_initcall(smsc_superio_setup);
diff --git a/arch/sh/boards/mach-microdev/io.c b/arch/sh/boards/mach-microdev/io.c
deleted file mode 100644
index a76c12721e63dc..00000000000000
--- a/arch/sh/boards/mach-microdev/io.c
+++ /dev/null
@@ -1,123 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/superh/microdev/io.c
- *
- * Copyright (C) 2003 Sean McGoogan (Sean.McGoogan@superh.com)
- * Copyright (C) 2003, 2004 SuperH, Inc.
- * Copyright (C) 2004 Paul Mundt
- *
- * SuperH SH4-202 MicroDev board support.
- */
-
-#include <linux/init.h>
-#include <linux/pci.h>
-#include <linux/wait.h>
-#include <asm/io.h>
-#include <mach/microdev.h>
-
-	/*
-	 *	we need to have a 'safe' address to re-direct all I/O requests
-	 *	that we do not explicitly wish to handle. This safe address
-	 *	must have the following properies:
-	 *
-	 *		* writes are ignored (no exception)
-	 *		* reads are benign (no side-effects)
-	 *		* accesses of width 1, 2 and 4-bytes are all valid.
-	 *
-	 *	The Processor Version Register (PVR) has these properties.
-	 */
-#define	PVR	0xff000030	/* Processor Version Register */
-
-
-#define	IO_IDE2_BASE		0x170ul	/* I/O base for SMSC FDC37C93xAPM IDE #2 */
-#define	IO_IDE1_BASE		0x1f0ul	/* I/O base for SMSC FDC37C93xAPM IDE #1 */
-#define IO_ISP1161_BASE		0x290ul /* I/O port for Philips ISP1161x USB chip */
-#define IO_SERIAL2_BASE		0x2f8ul /* I/O base for SMSC FDC37C93xAPM Serial #2 */
-#define	IO_LAN91C111_BASE	0x300ul	/* I/O base for SMSC LAN91C111 Ethernet chip */
-#define	IO_IDE2_MISC		0x376ul	/* I/O misc for SMSC FDC37C93xAPM IDE #2 */
-#define IO_SUPERIO_BASE		0x3f0ul /* I/O base for SMSC FDC37C93xAPM SuperIO chip */
-#define	IO_IDE1_MISC		0x3f6ul	/* I/O misc for SMSC FDC37C93xAPM IDE #1 */
-#define IO_SERIAL1_BASE		0x3f8ul /* I/O base for SMSC FDC37C93xAPM Serial #1 */
-
-#define	IO_ISP1161_EXTENT	0x04ul	/* I/O extent for Philips ISP1161x USB chip */
-#define	IO_LAN91C111_EXTENT	0x10ul	/* I/O extent for SMSC LAN91C111 Ethernet chip */
-#define	IO_SUPERIO_EXTENT	0x02ul	/* I/O extent for SMSC FDC37C93xAPM SuperIO chip */
-#define	IO_IDE_EXTENT		0x08ul	/* I/O extent for IDE Task Register set */
-#define IO_SERIAL_EXTENT	0x10ul
-
-#define	IO_LAN91C111_PHYS	0xa7500000ul	/* Physical address of SMSC LAN91C111 Ethernet chip */
-#define	IO_ISP1161_PHYS		0xa7700000ul	/* Physical address of Philips ISP1161x USB chip */
-#define	IO_SUPERIO_PHYS		0xa7800000ul	/* Physical address of SMSC FDC37C93xAPM SuperIO chip */
-
-/*
- * map I/O ports to memory-mapped addresses
- */
-void __iomem *microdev_ioport_map(unsigned long offset, unsigned int len)
-{
-	unsigned long result;
-
-	if ((offset >= IO_LAN91C111_BASE) &&
-	    (offset <  IO_LAN91C111_BASE + IO_LAN91C111_EXTENT)) {
-			/*
-			 *	SMSC LAN91C111 Ethernet chip
-			 */
-		result = IO_LAN91C111_PHYS + offset - IO_LAN91C111_BASE;
-	} else if ((offset >= IO_SUPERIO_BASE) &&
-		   (offset <  IO_SUPERIO_BASE + IO_SUPERIO_EXTENT)) {
-			/*
-			 *	SMSC FDC37C93xAPM SuperIO chip
-			 *
-			 *	Configuration Registers
-			 */
-		result = IO_SUPERIO_PHYS + (offset << 1);
-	} else if (((offset >= IO_IDE1_BASE) &&
-		    (offset <  IO_IDE1_BASE + IO_IDE_EXTENT)) ||
-		    (offset == IO_IDE1_MISC)) {
-			/*
-			 *	SMSC FDC37C93xAPM SuperIO chip
-			 *
-			 *	IDE #1
-			 */
-	        result = IO_SUPERIO_PHYS + (offset << 1);
-	} else if (((offset >= IO_IDE2_BASE) &&
-		    (offset <  IO_IDE2_BASE + IO_IDE_EXTENT)) ||
-		    (offset == IO_IDE2_MISC)) {
-			/*
-			 *	SMSC FDC37C93xAPM SuperIO chip
-			 *
-			 *	IDE #2
-			 */
-	        result = IO_SUPERIO_PHYS + (offset << 1);
-	} else if ((offset >= IO_SERIAL1_BASE) &&
-		   (offset <  IO_SERIAL1_BASE + IO_SERIAL_EXTENT)) {
-			/*
-			 *	SMSC FDC37C93xAPM SuperIO chip
-			 *
-			 *	Serial #1
-			 */
-		result = IO_SUPERIO_PHYS + (offset << 1);
-	} else if ((offset >= IO_SERIAL2_BASE) &&
-		   (offset <  IO_SERIAL2_BASE + IO_SERIAL_EXTENT)) {
-			/*
-			 *	SMSC FDC37C93xAPM SuperIO chip
-			 *
-			 *	Serial #2
-			 */
-		result = IO_SUPERIO_PHYS + (offset << 1);
-	} else if ((offset >= IO_ISP1161_BASE) &&
-		   (offset < IO_ISP1161_BASE + IO_ISP1161_EXTENT)) {
-			/*
-			 *	Philips USB ISP1161x chip
-			 */
-		result = IO_ISP1161_PHYS + offset - IO_ISP1161_BASE;
-	} else {
-			/*
-			 *	safe default.
-			 */
-		printk("Warning: unexpected port in %s( offset = 0x%lx )\n",
-		       __func__, offset);
-		result = PVR;
-	}
-
-	return (void __iomem *)result;
-}
diff --git a/arch/sh/boards/mach-microdev/irq.c b/arch/sh/boards/mach-microdev/irq.c
deleted file mode 100644
index dc27492c83d765..00000000000000
--- a/arch/sh/boards/mach-microdev/irq.c
+++ /dev/null
@@ -1,150 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/boards/superh/microdev/irq.c
- *
- * Copyright (C) 2003 Sean McGoogan (Sean.McGoogan@superh.com)
- *
- * SuperH SH4-202 MicroDev board support.
- */
-
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <asm/io.h>
-#include <mach/microdev.h>
-
-#define NUM_EXTERNAL_IRQS 16	/* IRL0 .. IRL15 */
-
-static const struct {
-	unsigned char fpgaIrq;
-	unsigned char mapped;
-	const char *name;
-} fpgaIrqTable[NUM_EXTERNAL_IRQS] = {
-	{ 0,				0,	"unused"   },		/* IRQ #0	IRL=15	0x200  */
-	{ MICRODEV_FPGA_IRQ_KEYBOARD,	1,	"keyboard" },		/* IRQ #1	IRL=14	0x220  */
-	{ MICRODEV_FPGA_IRQ_SERIAL1,	1,	"Serial #1"},		/* IRQ #2	IRL=13	0x240  */
-	{ MICRODEV_FPGA_IRQ_ETHERNET,	1,	"Ethernet" },		/* IRQ #3	IRL=12	0x260  */
-	{ MICRODEV_FPGA_IRQ_SERIAL2,	0,	"Serial #2"},		/* IRQ #4	IRL=11	0x280  */
-	{ 0,				0,	"unused"   },		/* IRQ #5	IRL=10	0x2a0  */
-	{ 0,				0,	"unused"   },		/* IRQ #6	IRL=9	0x2c0  */
-	{ MICRODEV_FPGA_IRQ_USB_HC,	1,	"USB"	   },		/* IRQ #7	IRL=8	0x2e0  */
-	{ MICRODEV_IRQ_PCI_INTA,	1,	"PCI INTA" },		/* IRQ #8	IRL=7	0x300  */
-	{ MICRODEV_IRQ_PCI_INTB,	1,	"PCI INTB" },		/* IRQ #9	IRL=6	0x320  */
-	{ MICRODEV_IRQ_PCI_INTC,	1,	"PCI INTC" },		/* IRQ #10	IRL=5	0x340  */
-	{ MICRODEV_IRQ_PCI_INTD,	1,	"PCI INTD" },		/* IRQ #11	IRL=4	0x360  */
-	{ MICRODEV_FPGA_IRQ_MOUSE,	1,	"mouse"    },		/* IRQ #12	IRL=3	0x380  */
-	{ MICRODEV_FPGA_IRQ_IDE2,	1,	"IDE #2"   },		/* IRQ #13	IRL=2	0x3a0  */
-	{ MICRODEV_FPGA_IRQ_IDE1,	1,	"IDE #1"   },		/* IRQ #14	IRL=1	0x3c0  */
-	{ 0,				0,	"unused"   },		/* IRQ #15	IRL=0	0x3e0  */
-};
-
-#if (MICRODEV_LINUX_IRQ_KEYBOARD != 1)
-#  error Inconsistancy in defining the IRQ# for Keyboard!
-#endif
-
-#if (MICRODEV_LINUX_IRQ_ETHERNET != 3)
-#  error Inconsistancy in defining the IRQ# for Ethernet!
-#endif
-
-#if (MICRODEV_LINUX_IRQ_USB_HC != 7)
-#  error Inconsistancy in defining the IRQ# for USB!
-#endif
-
-#if (MICRODEV_LINUX_IRQ_MOUSE != 12)
-#  error Inconsistancy in defining the IRQ# for PS/2 Mouse!
-#endif
-
-#if (MICRODEV_LINUX_IRQ_IDE2 != 13)
-#  error Inconsistancy in defining the IRQ# for secondary IDE!
-#endif
-
-#if (MICRODEV_LINUX_IRQ_IDE1 != 14)
-#  error Inconsistancy in defining the IRQ# for primary IDE!
-#endif
-
-static void disable_microdev_irq(struct irq_data *data)
-{
-	unsigned int irq = data->irq;
-	unsigned int fpgaIrq;
-
-	if (irq >= NUM_EXTERNAL_IRQS)
-		return;
-	if (!fpgaIrqTable[irq].mapped)
-		return;
-
-	fpgaIrq = fpgaIrqTable[irq].fpgaIrq;
-
-	/* disable interrupts on the FPGA INTC register */
-	__raw_writel(MICRODEV_FPGA_INTC_MASK(fpgaIrq), MICRODEV_FPGA_INTDSB_REG);
-}
-
-static void enable_microdev_irq(struct irq_data *data)
-{
-	unsigned int irq = data->irq;
-	unsigned long priorityReg, priorities, pri;
-	unsigned int fpgaIrq;
-
-	if (unlikely(irq >= NUM_EXTERNAL_IRQS))
-		return;
-	if (unlikely(!fpgaIrqTable[irq].mapped))
-		return;
-
-	pri = 15 - irq;
-
-	fpgaIrq = fpgaIrqTable[irq].fpgaIrq;
-	priorityReg = MICRODEV_FPGA_INTPRI_REG(fpgaIrq);
-
-	/* set priority for the interrupt */
-	priorities = __raw_readl(priorityReg);
-	priorities &= ~MICRODEV_FPGA_INTPRI_MASK(fpgaIrq);
-	priorities |= MICRODEV_FPGA_INTPRI_LEVEL(fpgaIrq, pri);
-	__raw_writel(priorities, priorityReg);
-
-	/* enable interrupts on the FPGA INTC register */
-	__raw_writel(MICRODEV_FPGA_INTC_MASK(fpgaIrq), MICRODEV_FPGA_INTENB_REG);
-}
-
-static struct irq_chip microdev_irq_type = {
-	.name = "MicroDev-IRQ",
-	.irq_unmask = enable_microdev_irq,
-	.irq_mask = disable_microdev_irq,
-};
-
-/* This function sets the desired irq handler to be a MicroDev type */
-static void __init make_microdev_irq(unsigned int irq)
-{
-	disable_irq_nosync(irq);
-	irq_set_chip_and_handler(irq, &microdev_irq_type, handle_level_irq);
-	disable_microdev_irq(irq_get_irq_data(irq));
-}
-
-extern void __init init_microdev_irq(void)
-{
-	int i;
-
-	/* disable interrupts on the FPGA INTC register */
-	__raw_writel(~0ul, MICRODEV_FPGA_INTDSB_REG);
-
-	for (i = 0; i < NUM_EXTERNAL_IRQS; i++)
-		make_microdev_irq(i);
-}
-
-extern void microdev_print_fpga_intc_status(void)
-{
-	volatile unsigned int * const intenb = (unsigned int*)MICRODEV_FPGA_INTENB_REG;
-	volatile unsigned int * const intdsb = (unsigned int*)MICRODEV_FPGA_INTDSB_REG;
-	volatile unsigned int * const intpria = (unsigned int*)MICRODEV_FPGA_INTPRI_REG(0);
-	volatile unsigned int * const intprib = (unsigned int*)MICRODEV_FPGA_INTPRI_REG(8);
-	volatile unsigned int * const intpric = (unsigned int*)MICRODEV_FPGA_INTPRI_REG(16);
-	volatile unsigned int * const intprid = (unsigned int*)MICRODEV_FPGA_INTPRI_REG(24);
-	volatile unsigned int * const intsrc = (unsigned int*)MICRODEV_FPGA_INTSRC_REG;
-	volatile unsigned int * const intreq = (unsigned int*)MICRODEV_FPGA_INTREQ_REG;
-
-	printk("-------------------------- microdev_print_fpga_intc_status() ------------------\n");
-	printk("FPGA_INTENB = 0x%08x\n", *intenb);
-	printk("FPGA_INTDSB = 0x%08x\n", *intdsb);
-	printk("FPGA_INTSRC = 0x%08x\n", *intsrc);
-	printk("FPGA_INTREQ = 0x%08x\n", *intreq);
-	printk("FPGA_INTPRI[3..0] = %08x:%08x:%08x:%08x\n", *intprid, *intpric, *intprib, *intpria);
-	printk("-------------------------------------------------------------------------------\n");
-}
diff --git a/arch/sh/boards/mach-microdev/setup.c b/arch/sh/boards/mach-microdev/setup.c
deleted file mode 100644
index f4a777fe2d0121..00000000000000
--- a/arch/sh/boards/mach-microdev/setup.c
+++ /dev/null
@@ -1,197 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/boards/superh/microdev/setup.c
- *
- * Copyright (C) 2003 Sean McGoogan (Sean.McGoogan@superh.com)
- * Copyright (C) 2003, 2004 SuperH, Inc.
- * Copyright (C) 2004, 2005 Paul Mundt
- *
- * SuperH SH4-202 MicroDev board support.
- */
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/ioport.h>
-#include <video/s1d13xxxfb.h>
-#include <mach/microdev.h>
-#include <asm/io.h>
-#include <asm/machvec.h>
-#include <linux/sizes.h>
-
-static struct resource smc91x_resources[] = {
-	[0] = {
-		.start		= 0x300,
-		.end		= 0x300 + SZ_4K - 1,
-		.flags		= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start		= MICRODEV_LINUX_IRQ_ETHERNET,
-		.end		= MICRODEV_LINUX_IRQ_ETHERNET,
-		.flags		= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device smc91x_device = {
-	.name		= "smc91x",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(smc91x_resources),
-	.resource	= smc91x_resources,
-};
-
-static struct s1d13xxxfb_regval s1d13806_initregs[] = {
-	{ S1DREG_MISC,			0x00 },
-	{ S1DREG_COM_DISP_MODE,		0x00 },
-	{ S1DREG_GPIO_CNF0,		0x00 },
-	{ S1DREG_GPIO_CNF1,		0x00 },
-	{ S1DREG_GPIO_CTL0,		0x00 },
-	{ S1DREG_GPIO_CTL1,		0x00 },
-	{ S1DREG_CLK_CNF,		0x02 },
-	{ S1DREG_LCD_CLK_CNF,		0x01 },
-	{ S1DREG_CRT_CLK_CNF,		0x03 },
-	{ S1DREG_MPLUG_CLK_CNF,		0x03 },
-	{ S1DREG_CPU2MEM_WST_SEL,	0x02 },
-	{ S1DREG_SDRAM_REF_RATE,	0x03 },
-	{ S1DREG_SDRAM_TC0,		0x00 },
-	{ S1DREG_SDRAM_TC1,		0x01 },
-	{ S1DREG_MEM_CNF,		0x80 },
-	{ S1DREG_PANEL_TYPE,		0x25 },
-	{ S1DREG_MOD_RATE,		0x00 },
-	{ S1DREG_LCD_DISP_HWIDTH,	0x63 },
-	{ S1DREG_LCD_NDISP_HPER,	0x1e },
-	{ S1DREG_TFT_FPLINE_START,	0x06 },
-	{ S1DREG_TFT_FPLINE_PWIDTH,	0x03 },
-	{ S1DREG_LCD_DISP_VHEIGHT0,	0x57 },
-	{ S1DREG_LCD_DISP_VHEIGHT1,	0x02 },
-	{ S1DREG_LCD_NDISP_VPER,	0x00 },
-	{ S1DREG_TFT_FPFRAME_START,	0x0a },
-	{ S1DREG_TFT_FPFRAME_PWIDTH,	0x81 },
-	{ S1DREG_LCD_DISP_MODE,		0x03 },
-	{ S1DREG_LCD_MISC,		0x00 },
-	{ S1DREG_LCD_DISP_START0,	0x00 },
-	{ S1DREG_LCD_DISP_START1,	0x00 },
-	{ S1DREG_LCD_DISP_START2,	0x00 },
-	{ S1DREG_LCD_MEM_OFF0,		0x90 },
-	{ S1DREG_LCD_MEM_OFF1,		0x01 },
-	{ S1DREG_LCD_PIX_PAN,		0x00 },
-	{ S1DREG_LCD_DISP_FIFO_HTC,	0x00 },
-	{ S1DREG_LCD_DISP_FIFO_LTC,	0x00 },
-	{ S1DREG_CRT_DISP_HWIDTH,	0x63 },
-	{ S1DREG_CRT_NDISP_HPER,	0x1f },
-	{ S1DREG_CRT_HRTC_START,	0x04 },
-	{ S1DREG_CRT_HRTC_PWIDTH,	0x8f },
-	{ S1DREG_CRT_DISP_VHEIGHT0,	0x57 },
-	{ S1DREG_CRT_DISP_VHEIGHT1,	0x02 },
-	{ S1DREG_CRT_NDISP_VPER,	0x1b },
-	{ S1DREG_CRT_VRTC_START,	0x00 },
-	{ S1DREG_CRT_VRTC_PWIDTH,	0x83 },
-	{ S1DREG_TV_OUT_CTL,		0x10 },
-	{ S1DREG_CRT_DISP_MODE,		0x05 },
-	{ S1DREG_CRT_DISP_START0,	0x00 },
-	{ S1DREG_CRT_DISP_START1,	0x00 },
-	{ S1DREG_CRT_DISP_START2,	0x00 },
-	{ S1DREG_CRT_MEM_OFF0,		0x20 },
-	{ S1DREG_CRT_MEM_OFF1,		0x03 },
-	{ S1DREG_CRT_PIX_PAN,		0x00 },
-	{ S1DREG_CRT_DISP_FIFO_HTC,	0x00 },
-	{ S1DREG_CRT_DISP_FIFO_LTC,	0x00 },
-	{ S1DREG_LCD_CUR_CTL,		0x00 },
-	{ S1DREG_LCD_CUR_START,		0x01 },
-	{ S1DREG_LCD_CUR_XPOS0,		0x00 },
-	{ S1DREG_LCD_CUR_XPOS1,		0x00 },
-	{ S1DREG_LCD_CUR_YPOS0,		0x00 },
-	{ S1DREG_LCD_CUR_YPOS1,		0x00 },
-	{ S1DREG_LCD_CUR_BCTL0,		0x00 },
-	{ S1DREG_LCD_CUR_GCTL0,		0x00 },
-	{ S1DREG_LCD_CUR_RCTL0,		0x00 },
-	{ S1DREG_LCD_CUR_BCTL1,		0x1f },
-	{ S1DREG_LCD_CUR_GCTL1,		0x3f },
-	{ S1DREG_LCD_CUR_RCTL1,		0x1f },
-	{ S1DREG_LCD_CUR_FIFO_HTC,	0x00 },
-	{ S1DREG_CRT_CUR_CTL,		0x00 },
-	{ S1DREG_CRT_CUR_START,		0x01 },
-	{ S1DREG_CRT_CUR_XPOS0,		0x00 },
-	{ S1DREG_CRT_CUR_XPOS1,		0x00 },
-	{ S1DREG_CRT_CUR_YPOS0,		0x00 },
-	{ S1DREG_CRT_CUR_YPOS1,		0x00 },
-	{ S1DREG_CRT_CUR_BCTL0,		0x00 },
-	{ S1DREG_CRT_CUR_GCTL0,		0x00 },
-	{ S1DREG_CRT_CUR_RCTL0,		0x00 },
-	{ S1DREG_CRT_CUR_BCTL1,		0x1f },
-	{ S1DREG_CRT_CUR_GCTL1,		0x3f },
-	{ S1DREG_CRT_CUR_RCTL1,		0x1f },
-	{ S1DREG_CRT_CUR_FIFO_HTC,	0x00 },
-	{ S1DREG_BBLT_CTL0,		0x00 },
-	{ S1DREG_BBLT_CTL1,		0x00 },
-	{ S1DREG_BBLT_CC_EXP,		0x00 },
-	{ S1DREG_BBLT_OP,		0x00 },
-	{ S1DREG_BBLT_SRC_START0,	0x00 },
-	{ S1DREG_BBLT_SRC_START1,	0x00 },
-	{ S1DREG_BBLT_SRC_START2,	0x00 },
-	{ S1DREG_BBLT_DST_START0,	0x00 },
-	{ S1DREG_BBLT_DST_START1,	0x00 },
-	{ S1DREG_BBLT_DST_START2,	0x00 },
-	{ S1DREG_BBLT_MEM_OFF0,		0x00 },
-	{ S1DREG_BBLT_MEM_OFF1,		0x00 },
-	{ S1DREG_BBLT_WIDTH0,		0x00 },
-	{ S1DREG_BBLT_WIDTH1,		0x00 },
-	{ S1DREG_BBLT_HEIGHT0,		0x00 },
-	{ S1DREG_BBLT_HEIGHT1,		0x00 },
-	{ S1DREG_BBLT_BGC0,		0x00 },
-	{ S1DREG_BBLT_BGC1,		0x00 },
-	{ S1DREG_BBLT_FGC0,		0x00 },
-	{ S1DREG_BBLT_FGC1,		0x00 },
-	{ S1DREG_LKUP_MODE,		0x00 },
-	{ S1DREG_LKUP_ADDR,		0x00 },
-	{ S1DREG_PS_CNF,		0x10 },
-	{ S1DREG_PS_STATUS,		0x00 },
-	{ S1DREG_CPU2MEM_WDOGT,		0x00 },
-	{ S1DREG_COM_DISP_MODE,		0x02 },
-};
-
-static struct s1d13xxxfb_pdata s1d13806_platform_data = {
-	.initregs	= s1d13806_initregs,
-	.initregssize	= ARRAY_SIZE(s1d13806_initregs),
-};
-
-static struct resource s1d13806_resources[] = {
-	[0] = {
-		.start		= 0x07200000,
-		.end		= 0x07200000 + SZ_2M - 1,
-		.flags		= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start		= 0x07000000,
-		.end		= 0x07000000 + SZ_2M - 1,
-		.flags		= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device s1d13806_device = {
-	.name		= "s1d13806fb",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(s1d13806_resources),
-	.resource	= s1d13806_resources,
-
-	.dev = {
-		.platform_data	= &s1d13806_platform_data,
-	},
-};
-
-static struct platform_device *microdev_devices[] __initdata = {
-	&smc91x_device,
-	&s1d13806_device,
-};
-
-static int __init microdev_devices_setup(void)
-{
-	return platform_add_devices(microdev_devices, ARRAY_SIZE(microdev_devices));
-}
-device_initcall(microdev_devices_setup);
-
-/*
- * The Machine Vector
- */
-static struct sh_machine_vector mv_sh4202_microdev __initmv = {
-	.mv_name		= "SH4-202 MicroDev",
-	.mv_ioport_map		= microdev_ioport_map,
-	.mv_init_irq		= init_microdev_irq,
-};
diff --git a/arch/sh/boards/mach-migor/Kconfig b/arch/sh/boards/mach-migor/Kconfig
deleted file mode 100644
index fb64a10e217065..00000000000000
--- a/arch/sh/boards/mach-migor/Kconfig
+++ /dev/null
@@ -1,16 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-if SH_MIGOR
-
-choice
-	prompt "Migo-R LCD Panel Board Selection"
-	default SH_MIGOR_QVGA
-
-config SH_MIGOR_QVGA
-	bool "QVGA (320x240)"
-
-config SH_MIGOR_RTA_WVGA
-	bool "RTA WVGA (800x480)"
-
-endchoice
-
-endif
diff --git a/arch/sh/boards/mach-migor/Makefile b/arch/sh/boards/mach-migor/Makefile
deleted file mode 100644
index c223d759fcb1ee..00000000000000
--- a/arch/sh/boards/mach-migor/Makefile
+++ /dev/null
@@ -1,3 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-obj-y	 := setup.o sdram.o
-obj-$(CONFIG_SH_MIGOR_QVGA)	+=  lcd_qvga.o
diff --git a/arch/sh/boards/mach-migor/lcd_qvga.c b/arch/sh/boards/mach-migor/lcd_qvga.c
deleted file mode 100644
index 4ebf130510bc6e..00000000000000
--- a/arch/sh/boards/mach-migor/lcd_qvga.c
+++ /dev/null
@@ -1,163 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Support for SuperH MigoR Quarter VGA LCD Panel
- *
- * Copyright (C) 2008 Magnus Damm
- *
- * Based on lcd_powertip.c from Kenati Technologies Pvt Ltd.
- * Copyright (c) 2007 Ujjwal Pande <ujjwal@kenati.com>,
- */
-
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/fb.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/gpio.h>
-#include <video/sh_mobile_lcdc.h>
-#include <cpu/sh7722.h>
-#include <mach/migor.h>
-
-/* LCD Module is a PH240320T according to board schematics. This module
- * is made up of a 240x320 LCD hooked up to a R61505U (or HX8347-A01?)
- * Driver IC. This IC is connected to the SH7722 built-in LCDC using a
- * SYS-80 interface configured in 16 bit mode.
- *
- * Index 0: "Device Code Read" returns 0x1505.
- */
-
-static void reset_lcd_module(void)
-{
-	gpio_set_value(GPIO_PTH2, 0);
-	mdelay(2);
-	gpio_set_value(GPIO_PTH2, 1);
-	mdelay(1);
-}
-
-/* DB0-DB7 are connected to D1-D8, and DB8-DB15 to D10-D17 */
-
-static unsigned long adjust_reg18(unsigned short data)
-{
-	unsigned long tmp1, tmp2;
-
-	tmp1 = (data<<1 | 0x00000001) & 0x000001FF;
-	tmp2 = (data<<2 | 0x00000200) & 0x0003FE00;
-	return tmp1 | tmp2;
-}
-
-static void write_reg(void *sys_ops_handle,
-		       struct sh_mobile_lcdc_sys_bus_ops *sys_ops,
-		       unsigned short reg, unsigned short data)
-{
-	sys_ops->write_index(sys_ops_handle, adjust_reg18(reg << 8 | data));
-}
-
-static void write_reg16(void *sys_ops_handle,
-			struct sh_mobile_lcdc_sys_bus_ops *sys_ops,
-			unsigned short reg, unsigned short data)
-{
-	sys_ops->write_index(sys_ops_handle, adjust_reg18(reg));
-	sys_ops->write_data(sys_ops_handle, adjust_reg18(data));
-}
-
-static unsigned long read_reg16(void *sys_ops_handle,
-				struct sh_mobile_lcdc_sys_bus_ops *sys_ops,
-				unsigned short reg)
-{
-	unsigned long data;
-
-	sys_ops->write_index(sys_ops_handle, adjust_reg18(reg));
-	data = sys_ops->read_data(sys_ops_handle);
-	return ((data >> 1) & 0xff) | ((data >> 2) & 0xff00);
-}
-
-static void migor_lcd_qvga_seq(void *sys_ops_handle,
-			       struct sh_mobile_lcdc_sys_bus_ops *sys_ops,
-			       unsigned short const *data, int no_data)
-{
-	int i;
-
-	for (i = 0; i < no_data; i += 2)
-		write_reg16(sys_ops_handle, sys_ops, data[i], data[i + 1]);
-}
-
-static const unsigned short sync_data[] = {
-	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
-};
-
-static const unsigned short magic0_data[] = {
-	0x0060, 0x2700, 0x0008, 0x0808, 0x0090, 0x001A, 0x0007, 0x0001,
-	0x0017, 0x0001, 0x0019, 0x0000, 0x0010, 0x17B0, 0x0011, 0x0116,
-	0x0012, 0x0198, 0x0013, 0x1400, 0x0029, 0x000C, 0x0012, 0x01B8,
-};
-
-static const unsigned short magic1_data[] = {
-	0x0030, 0x0307, 0x0031, 0x0303, 0x0032, 0x0603, 0x0033, 0x0202,
-	0x0034, 0x0202, 0x0035, 0x0202, 0x0036, 0x1F1F, 0x0037, 0x0303,
-	0x0038, 0x0303, 0x0039, 0x0603, 0x003A, 0x0202, 0x003B, 0x0102,
-	0x003C, 0x0204, 0x003D, 0x0000, 0x0001, 0x0100, 0x0002, 0x0300,
-	0x0003, 0x5028, 0x0020, 0x00ef, 0x0021, 0x0000, 0x0004, 0x0000,
-	0x0009, 0x0000, 0x000A, 0x0008, 0x000C, 0x0000, 0x000D, 0x0000,
-	0x0015, 0x8000,
-};
-
-static const unsigned short magic2_data[] = {
-	0x0061, 0x0001, 0x0092, 0x0100, 0x0093, 0x0001, 0x0007, 0x0021,
-};
-
-static const unsigned short magic3_data[] = {
-	0x0010, 0x16B0, 0x0011, 0x0111, 0x0007, 0x0061,
-};
-
-int migor_lcd_qvga_setup(void *sohandle, struct sh_mobile_lcdc_sys_bus_ops *so)
-{
-	unsigned long xres = 320;
-	unsigned long yres = 240;
-	int k;
-
-	reset_lcd_module();
-	migor_lcd_qvga_seq(sohandle, so, sync_data, ARRAY_SIZE(sync_data));
-
-	if (read_reg16(sohandle, so, 0) != 0x1505)
-		return -ENODEV;
-
-	pr_info("Migo-R QVGA LCD Module detected.\n");
-
-	migor_lcd_qvga_seq(sohandle, so, sync_data, ARRAY_SIZE(sync_data));
-	write_reg16(sohandle, so, 0x00A4, 0x0001);
-	mdelay(10);
-
-	migor_lcd_qvga_seq(sohandle, so, magic0_data, ARRAY_SIZE(magic0_data));
-	mdelay(100);
-
-	migor_lcd_qvga_seq(sohandle, so, magic1_data, ARRAY_SIZE(magic1_data));
-	write_reg16(sohandle, so, 0x0050, 0xef - (yres - 1));
-	write_reg16(sohandle, so, 0x0051, 0x00ef);
-	write_reg16(sohandle, so, 0x0052, 0x0000);
-	write_reg16(sohandle, so, 0x0053, xres - 1);
-
-	migor_lcd_qvga_seq(sohandle, so, magic2_data, ARRAY_SIZE(magic2_data));
-	mdelay(10);
-
-	migor_lcd_qvga_seq(sohandle, so, magic3_data, ARRAY_SIZE(magic3_data));
-	mdelay(40);
-
-	/* clear GRAM to avoid displaying garbage */
-
-	write_reg16(sohandle, so, 0x0020, 0x0000); /* horiz addr */
-	write_reg16(sohandle, so, 0x0021, 0x0000); /* vert addr */
-
-	for (k = 0; k < (xres * 256); k++) /* yes, 256 words per line */
-		write_reg16(sohandle, so, 0x0022, 0x0000);
-
-	write_reg16(sohandle, so, 0x0020, 0x0000); /* reset horiz addr */
-	write_reg16(sohandle, so, 0x0021, 0x0000); /* reset vert addr */
-	write_reg16(sohandle, so, 0x0007, 0x0173);
-	mdelay(40);
-
-	/* enable display */
-	write_reg(sohandle, so, 0x00, 0x22);
-	mdelay(100);
-	return 0;
-}
diff --git a/arch/sh/boards/mach-migor/sdram.S b/arch/sh/boards/mach-migor/sdram.S
deleted file mode 100644
index 3a6bee1270aaf7..00000000000000
--- a/arch/sh/boards/mach-migor/sdram.S
+++ /dev/null
@@ -1,66 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * Migo-R sdram self/auto-refresh setup code
- *
- *  Copyright (C) 2009 Magnus Damm
- */
-
-#include <linux/sys.h>
-#include <linux/errno.h>
-#include <linux/linkage.h>
-#include <asm/asm-offsets.h>
-#include <asm/suspend.h>
-#include <asm/romimage-macros.h>
-
-/* code to enter and leave self-refresh. must be self-contained.
- * this code will be copied to on-chip memory and executed from there.
- */
-	.balign 4
-ENTRY(migor_sdram_enter_start)
-
-	/* SBSC: disable power down and put in self-refresh mode */
-	mov.l	1f, r4
-	mov.l	2f, r1
-	mov.l	@r4, r2
-	or	r1, r2
-	mov.l   3f, r3
-	and	r3, r2
-	mov.l	r2, @r4
-
-	rts
-	 nop
-
-	.balign 4
-1:	.long	0xfe400008 /* SDCR0 */
-2:	.long	0x00000400
-3:	.long	0xffff7fff
-ENTRY(migor_sdram_enter_end)
-
-	.balign 4
-ENTRY(migor_sdram_leave_start)
-
-	/* SBSC: set auto-refresh mode */
-	mov.l	1f, r4
-	mov.l	@r4, r0
-	mov.l   4f, r1
-	and	r1, r0
-	mov.l	r0, @r4
-	mov.l	6f, r4
-	mov.l	8f, r0
-	mov.l	@r4, r1
-	mov	#-1, r4
-	add	r4, r1
-	or	r1, r0
-	mov.l	7f, r1
-	mov.l	r0, @r1
-
-	rts
-	 nop
-
-	.balign 4
-1:	.long	0xfe400008 /* SDCR0 */
-4:	.long	0xfffffbff
-6:	.long   0xfe40001c /* RTCOR */
-7:	.long   0xfe400018 /* RTCNT */
-8:	.long   0xa55a0000
-ENTRY(migor_sdram_leave_end)
diff --git a/arch/sh/boards/mach-migor/setup.c b/arch/sh/boards/mach-migor/setup.c
deleted file mode 100644
index f60061283c4827..00000000000000
--- a/arch/sh/boards/mach-migor/setup.c
+++ /dev/null
@@ -1,649 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Renesas System Solutions Asia Pte. Ltd - Migo-R
- *
- * Copyright (C) 2008 Magnus Damm
- */
-#include <linux/clkdev.h>
-#include <linux/dma-map-ops.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <linux/input.h>
-#include <linux/input/sh_keysc.h>
-#include <linux/memblock.h>
-#include <linux/mmc/host.h>
-#include <linux/mtd/physmap.h>
-#include <linux/mfd/tmio.h>
-#include <linux/mtd/platnand.h>
-#include <linux/i2c.h>
-#include <linux/regulator/fixed.h>
-#include <linux/regulator/machine.h>
-#include <linux/smc91x.h>
-#include <linux/delay.h>
-#include <linux/clk.h>
-#include <linux/gpio.h>
-#include <linux/gpio/machine.h>
-#include <linux/videodev2.h>
-#include <linux/sh_intc.h>
-#include <video/sh_mobile_lcdc.h>
-#include <media/drv-intf/renesas-ceu.h>
-#include <media/i2c/ov772x.h>
-#include <media/i2c/tw9910.h>
-#include <asm/clock.h>
-#include <asm/machvec.h>
-#include <asm/io.h>
-#include <asm/suspend.h>
-#include <mach/migor.h>
-#include <cpu/sh7722.h>
-
-/* Address     IRQ  Size  Bus  Description
- * 0x00000000       64MB  16   NOR Flash (SP29PL256N)
- * 0x0c000000       64MB  64   SDRAM (2xK4M563233G)
- * 0x10000000  IRQ0       16   Ethernet (SMC91C111)
- * 0x14000000  IRQ4       16   USB 2.0 Host Controller (M66596)
- * 0x18000000       8GB    8   NAND Flash (K9K8G08U0A)
- */
-
-#define CEU_BUFFER_MEMORY_SIZE		(4 << 20)
-static phys_addr_t ceu_dma_membase;
-
-static struct smc91x_platdata smc91x_info = {
-	.flags = SMC91X_USE_16BIT | SMC91X_NOWAIT,
-};
-
-static struct resource smc91x_eth_resources[] = {
-	[0] = {
-		.name   = "SMC91C111" ,
-		.start  = 0x10000300,
-		.end    = 0x1000030f,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0x600), /* IRQ0 */
-		.flags  = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
-	},
-};
-
-static struct platform_device smc91x_eth_device = {
-	.name           = "smc91x",
-	.num_resources  = ARRAY_SIZE(smc91x_eth_resources),
-	.resource       = smc91x_eth_resources,
-	.dev	= {
-		.platform_data	= &smc91x_info,
-	},
-};
-
-static struct sh_keysc_info sh_keysc_info = {
-	.mode = SH_KEYSC_MODE_2, /* KEYOUT0->4, KEYIN1->5 */
-	.scan_timing = 3,
-	.delay = 5,
-	.keycodes = {
-		0, KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT, KEY_ENTER,
-		0, KEY_F, KEY_C, KEY_D,	KEY_H, KEY_1,
-		0, KEY_2, KEY_3, KEY_4,	KEY_5, KEY_6,
-		0, KEY_7, KEY_8, KEY_9, KEY_S, KEY_0,
-		0, KEY_P, KEY_STOP, KEY_REWIND, KEY_PLAY, KEY_FASTFORWARD,
-	},
-};
-
-static struct resource sh_keysc_resources[] = {
-	[0] = {
-		.start  = 0x044b0000,
-		.end    = 0x044b000f,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0xbe0),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device sh_keysc_device = {
-	.name           = "sh_keysc",
-	.id             = 0, /* "keysc0" clock */
-	.num_resources  = ARRAY_SIZE(sh_keysc_resources),
-	.resource       = sh_keysc_resources,
-	.dev	= {
-		.platform_data	= &sh_keysc_info,
-	},
-};
-
-static struct mtd_partition migor_nor_flash_partitions[] =
-{
-	{
-		.name = "uboot",
-		.offset = 0,
-		.size = (1 * 1024 * 1024),
-		.mask_flags = MTD_WRITEABLE,	/* Read-only */
-	},
-	{
-		.name = "rootfs",
-		.offset = MTDPART_OFS_APPEND,
-		.size = (15 * 1024 * 1024),
-	},
-	{
-		.name = "other",
-		.offset = MTDPART_OFS_APPEND,
-		.size = MTDPART_SIZ_FULL,
-	},
-};
-
-static struct physmap_flash_data migor_nor_flash_data = {
-	.width		= 2,
-	.parts		= migor_nor_flash_partitions,
-	.nr_parts	= ARRAY_SIZE(migor_nor_flash_partitions),
-};
-
-static struct resource migor_nor_flash_resources[] = {
-	[0] = {
-		.name		= "NOR Flash",
-		.start		= 0x00000000,
-		.end		= 0x03ffffff,
-		.flags		= IORESOURCE_MEM,
-	}
-};
-
-static struct platform_device migor_nor_flash_device = {
-	.name		= "physmap-flash",
-	.resource	= migor_nor_flash_resources,
-	.num_resources	= ARRAY_SIZE(migor_nor_flash_resources),
-	.dev		= {
-		.platform_data = &migor_nor_flash_data,
-	},
-};
-
-static struct mtd_partition migor_nand_flash_partitions[] = {
-	{
-		.name		= "nanddata1",
-		.offset		= 0x0,
-		.size		= 512 * 1024 * 1024,
-	},
-	{
-		.name		= "nanddata2",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= 512 * 1024 * 1024,
-	},
-};
-
-static void migor_nand_flash_cmd_ctl(struct nand_chip *chip, int cmd,
-				     unsigned int ctrl)
-{
-	if (cmd == NAND_CMD_NONE)
-		return;
-
-	if (ctrl & NAND_CLE)
-		writeb(cmd, chip->legacy.IO_ADDR_W + 0x00400000);
-	else if (ctrl & NAND_ALE)
-		writeb(cmd, chip->legacy.IO_ADDR_W + 0x00800000);
-	else
-		writeb(cmd, chip->legacy.IO_ADDR_W);
-}
-
-static int migor_nand_flash_ready(struct nand_chip *chip)
-{
-	return gpio_get_value(GPIO_PTA1); /* NAND_RBn */
-}
-
-static struct platform_nand_data migor_nand_flash_data = {
-	.chip = {
-		.nr_chips = 1,
-		.partitions = migor_nand_flash_partitions,
-		.nr_partitions = ARRAY_SIZE(migor_nand_flash_partitions),
-		.chip_delay = 20,
-	},
-	.ctrl = {
-		.dev_ready = migor_nand_flash_ready,
-		.cmd_ctrl = migor_nand_flash_cmd_ctl,
-	},
-};
-
-static struct resource migor_nand_flash_resources[] = {
-	[0] = {
-		.name		= "NAND Flash",
-		.start		= 0x18000000,
-		.end		= 0x18ffffff,
-		.flags		= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device migor_nand_flash_device = {
-	.name		= "gen_nand",
-	.resource	= migor_nand_flash_resources,
-	.num_resources	= ARRAY_SIZE(migor_nand_flash_resources),
-	.dev		= {
-		.platform_data = &migor_nand_flash_data,
-	}
-};
-
-static const struct fb_videomode migor_lcd_modes[] = {
-	{
-#if defined(CONFIG_SH_MIGOR_RTA_WVGA)
-		.name = "LB070WV1",
-		.xres = 800,
-		.yres = 480,
-		.left_margin = 64,
-		.right_margin = 16,
-		.hsync_len = 120,
-		.sync = 0,
-#elif defined(CONFIG_SH_MIGOR_QVGA)
-		.name = "PH240320T",
-		.xres = 320,
-		.yres = 240,
-		.left_margin = 0,
-		.right_margin = 16,
-		.hsync_len = 8,
-		.sync = FB_SYNC_HOR_HIGH_ACT,
-#endif
-		.upper_margin = 1,
-		.lower_margin = 17,
-		.vsync_len = 2,
-	},
-};
-
-static struct sh_mobile_lcdc_info sh_mobile_lcdc_info = {
-#if defined(CONFIG_SH_MIGOR_RTA_WVGA)
-	.clock_source = LCDC_CLK_BUS,
-	.ch[0] = {
-		.chan = LCDC_CHAN_MAINLCD,
-		.fourcc = V4L2_PIX_FMT_RGB565,
-		.interface_type = RGB16,
-		.clock_divider = 2,
-		.lcd_modes = migor_lcd_modes,
-		.num_modes = ARRAY_SIZE(migor_lcd_modes),
-		.panel_cfg = { /* 7.0 inch */
-			.width = 152,
-			.height = 91,
-		},
-	}
-#elif defined(CONFIG_SH_MIGOR_QVGA)
-	.clock_source = LCDC_CLK_PERIPHERAL,
-	.ch[0] = {
-		.chan = LCDC_CHAN_MAINLCD,
-		.fourcc = V4L2_PIX_FMT_RGB565,
-		.interface_type = SYS16A,
-		.clock_divider = 10,
-		.lcd_modes = migor_lcd_modes,
-		.num_modes = ARRAY_SIZE(migor_lcd_modes),
-		.panel_cfg = {
-			.width = 49,	/* 2.4 inch */
-			.height = 37,
-			.setup_sys = migor_lcd_qvga_setup,
-		},
-		.sys_bus_cfg = {
-			.ldmt2r = 0x06000a09,
-			.ldmt3r = 0x180e3418,
-			/* set 1s delay to encourage fsync() */
-			.deferred_io_msec = 1000,
-		},
-	}
-#endif
-};
-
-static struct resource migor_lcdc_resources[] = {
-	[0] = {
-		.name	= "LCDC",
-		.start	= 0xfe940000, /* P4-only space */
-		.end	= 0xfe942fff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0x580),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device migor_lcdc_device = {
-	.name		= "sh_mobile_lcdc_fb",
-	.num_resources	= ARRAY_SIZE(migor_lcdc_resources),
-	.resource	= migor_lcdc_resources,
-	.dev	= {
-		.platform_data	= &sh_mobile_lcdc_info,
-	},
-};
-
-static struct ceu_platform_data ceu_pdata = {
-	.num_subdevs			= 2,
-	.subdevs = {
-		{ /* [0] = ov772x */
-			.flags		= 0,
-			.bus_width	= 8,
-			.bus_shift	= 0,
-			.i2c_adapter_id	= 0,
-			.i2c_address	= 0x21,
-		},
-		{ /* [1] = tw9910 */
-			.flags		= 0,
-			.bus_width	= 8,
-			.bus_shift	= 0,
-			.i2c_adapter_id	= 0,
-			.i2c_address	= 0x45,
-		},
-	},
-};
-
-static struct resource migor_ceu_resources[] = {
-	[0] = {
-		.name	= "CEU",
-		.start	= 0xfe910000,
-		.end	= 0xfe91009f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0x880),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device migor_ceu_device = {
-	.name		= "renesas-ceu",
-	.id             = 0, /* ceu.0 */
-	.num_resources	= ARRAY_SIZE(migor_ceu_resources),
-	.resource	= migor_ceu_resources,
-	.dev	= {
-		.platform_data	= &ceu_pdata,
-	},
-};
-
-/* Powerdown/reset gpios for CEU image sensors */
-static struct gpiod_lookup_table ov7725_gpios = {
-	.dev_id		= "0-0021",
-	.table		= {
-		GPIO_LOOKUP("sh7722_pfc", GPIO_PTT0, "powerdown",
-			    GPIO_ACTIVE_HIGH),
-		GPIO_LOOKUP("sh7722_pfc", GPIO_PTT3, "reset", GPIO_ACTIVE_LOW),
-	},
-};
-
-static struct gpiod_lookup_table tw9910_gpios = {
-	.dev_id		= "0-0045",
-	.table		= {
-		GPIO_LOOKUP("sh7722_pfc", GPIO_PTT2, "pdn", GPIO_ACTIVE_LOW),
-		GPIO_LOOKUP("sh7722_pfc", GPIO_PTT3, "rstb", GPIO_ACTIVE_LOW),
-	},
-};
-
-/* Fixed 3.3V regulator to be used by SDHI0 */
-static struct regulator_consumer_supply fixed3v3_power_consumers[] =
-{
-	REGULATOR_SUPPLY("vmmc", "sh_mobile_sdhi.0"),
-	REGULATOR_SUPPLY("vqmmc", "sh_mobile_sdhi.0"),
-};
-
-static struct resource sdhi_cn9_resources[] = {
-	[0] = {
-		.name	= "SDHI",
-		.start	= 0x04ce0000,
-		.end	= 0x04ce00ff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0xe80),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct tmio_mmc_data sh7724_sdhi_data = {
-	.chan_priv_tx	= (void *)SHDMA_SLAVE_SDHI0_TX,
-	.chan_priv_rx	= (void *)SHDMA_SLAVE_SDHI0_RX,
-	.capabilities	= MMC_CAP_SDIO_IRQ,
-};
-
-static struct platform_device sdhi_cn9_device = {
-	.name		= "sh_mobile_sdhi",
-	.num_resources	= ARRAY_SIZE(sdhi_cn9_resources),
-	.resource	= sdhi_cn9_resources,
-	.dev = {
-		.platform_data	= &sh7724_sdhi_data,
-	},
-};
-
-static struct ov772x_camera_info ov7725_info = {
-	.flags		= 0,
-};
-
-static struct tw9910_video_info tw9910_info = {
-	.buswidth       = 8,
-	.mpout          = TW9910_MPO_FIELD,
-};
-
-static struct i2c_board_info migor_i2c_devices[] = {
-	{
-		I2C_BOARD_INFO("rs5c372b", 0x32),
-	},
-	{
-		I2C_BOARD_INFO("migor_ts", 0x51),
-		.irq = evt2irq(0x6c0), /* IRQ6 */
-	},
-	{
-		I2C_BOARD_INFO("wm8978", 0x1a),
-	},
-	{
-		I2C_BOARD_INFO("ov772x", 0x21),
-		.platform_data = &ov7725_info,
-	},
-	{
-		I2C_BOARD_INFO("tw9910", 0x45),
-		.platform_data = &tw9910_info,
-	},
-};
-
-static struct platform_device *migor_devices[] __initdata = {
-	&smc91x_eth_device,
-	&sh_keysc_device,
-	&migor_lcdc_device,
-	&migor_nor_flash_device,
-	&migor_nand_flash_device,
-	&sdhi_cn9_device,
-};
-
-extern char migor_sdram_enter_start;
-extern char migor_sdram_enter_end;
-extern char migor_sdram_leave_start;
-extern char migor_sdram_leave_end;
-
-static int __init migor_devices_setup(void)
-{
-	struct clk *video_clk;
-
-	/* register board specific self-refresh code */
-	sh_mobile_register_self_refresh(SUSP_SH_STANDBY | SUSP_SH_SF,
-					&migor_sdram_enter_start,
-					&migor_sdram_enter_end,
-					&migor_sdram_leave_start,
-					&migor_sdram_leave_end);
-
-	regulator_register_always_on(0, "fixed-3.3V", fixed3v3_power_consumers,
-				     ARRAY_SIZE(fixed3v3_power_consumers), 3300000);
-
-	/* Let D11 LED show STATUS0 */
-	gpio_request(GPIO_FN_STATUS0, NULL);
-
-	/* Lit D12 LED show PDSTATUS */
-	gpio_request(GPIO_FN_PDSTATUS, NULL);
-
-	/* SMC91C111 - Enable IRQ0, Setup CS4 for 16-bit fast access */
-	gpio_request(GPIO_FN_IRQ0, NULL);
-	__raw_writel(0x00003400, BSC_CS4BCR);
-	__raw_writel(0x00110080, BSC_CS4WCR);
-
-	/* KEYSC */
-	gpio_request(GPIO_FN_KEYOUT0, NULL);
-	gpio_request(GPIO_FN_KEYOUT1, NULL);
-	gpio_request(GPIO_FN_KEYOUT2, NULL);
-	gpio_request(GPIO_FN_KEYOUT3, NULL);
-	gpio_request(GPIO_FN_KEYOUT4_IN6, NULL);
-	gpio_request(GPIO_FN_KEYIN1, NULL);
-	gpio_request(GPIO_FN_KEYIN2, NULL);
-	gpio_request(GPIO_FN_KEYIN3, NULL);
-	gpio_request(GPIO_FN_KEYIN4, NULL);
-	gpio_request(GPIO_FN_KEYOUT5_IN5, NULL);
-
-	/* NAND Flash */
-	gpio_request(GPIO_FN_CS6A_CE2B, NULL);
-	__raw_writel((__raw_readl(BSC_CS6ABCR) & ~0x0600) | 0x0200, BSC_CS6ABCR);
-	gpio_request(GPIO_PTA1, NULL);
-	gpio_direction_input(GPIO_PTA1);
-
-	/* SDHI */
-	gpio_request(GPIO_FN_SDHICD, NULL);
-	gpio_request(GPIO_FN_SDHIWP, NULL);
-	gpio_request(GPIO_FN_SDHID3, NULL);
-	gpio_request(GPIO_FN_SDHID2, NULL);
-	gpio_request(GPIO_FN_SDHID1, NULL);
-	gpio_request(GPIO_FN_SDHID0, NULL);
-	gpio_request(GPIO_FN_SDHICMD, NULL);
-	gpio_request(GPIO_FN_SDHICLK, NULL);
-
-	/* Touch Panel */
-	gpio_request(GPIO_FN_IRQ6, NULL);
-
-	/* LCD Panel */
-#ifdef CONFIG_SH_MIGOR_QVGA /* LCDC - QVGA - Enable SYS Interface signals */
-	gpio_request(GPIO_FN_LCDD17, NULL);
-	gpio_request(GPIO_FN_LCDD16, NULL);
-	gpio_request(GPIO_FN_LCDD15, NULL);
-	gpio_request(GPIO_FN_LCDD14, NULL);
-	gpio_request(GPIO_FN_LCDD13, NULL);
-	gpio_request(GPIO_FN_LCDD12, NULL);
-	gpio_request(GPIO_FN_LCDD11, NULL);
-	gpio_request(GPIO_FN_LCDD10, NULL);
-	gpio_request(GPIO_FN_LCDD8, NULL);
-	gpio_request(GPIO_FN_LCDD7, NULL);
-	gpio_request(GPIO_FN_LCDD6, NULL);
-	gpio_request(GPIO_FN_LCDD5, NULL);
-	gpio_request(GPIO_FN_LCDD4, NULL);
-	gpio_request(GPIO_FN_LCDD3, NULL);
-	gpio_request(GPIO_FN_LCDD2, NULL);
-	gpio_request(GPIO_FN_LCDD1, NULL);
-	gpio_request(GPIO_FN_LCDRS, NULL);
-	gpio_request(GPIO_FN_LCDCS, NULL);
-	gpio_request(GPIO_FN_LCDRD, NULL);
-	gpio_request(GPIO_FN_LCDWR, NULL);
-	gpio_request(GPIO_PTH2, NULL); /* LCD_DON */
-	gpio_direction_output(GPIO_PTH2, 1);
-#endif
-#ifdef CONFIG_SH_MIGOR_RTA_WVGA /* LCDC - WVGA - Enable RGB Interface signals */
-	gpio_request(GPIO_FN_LCDD15, NULL);
-	gpio_request(GPIO_FN_LCDD14, NULL);
-	gpio_request(GPIO_FN_LCDD13, NULL);
-	gpio_request(GPIO_FN_LCDD12, NULL);
-	gpio_request(GPIO_FN_LCDD11, NULL);
-	gpio_request(GPIO_FN_LCDD10, NULL);
-	gpio_request(GPIO_FN_LCDD9, NULL);
-	gpio_request(GPIO_FN_LCDD8, NULL);
-	gpio_request(GPIO_FN_LCDD7, NULL);
-	gpio_request(GPIO_FN_LCDD6, NULL);
-	gpio_request(GPIO_FN_LCDD5, NULL);
-	gpio_request(GPIO_FN_LCDD4, NULL);
-	gpio_request(GPIO_FN_LCDD3, NULL);
-	gpio_request(GPIO_FN_LCDD2, NULL);
-	gpio_request(GPIO_FN_LCDD1, NULL);
-	gpio_request(GPIO_FN_LCDD0, NULL);
-	gpio_request(GPIO_FN_LCDLCLK, NULL);
-	gpio_request(GPIO_FN_LCDDCK, NULL);
-	gpio_request(GPIO_FN_LCDVEPWC, NULL);
-	gpio_request(GPIO_FN_LCDVCPWC, NULL);
-	gpio_request(GPIO_FN_LCDVSYN, NULL);
-	gpio_request(GPIO_FN_LCDHSYN, NULL);
-	gpio_request(GPIO_FN_LCDDISP, NULL);
-	gpio_request(GPIO_FN_LCDDON, NULL);
-#endif
-
-	/* CEU */
-	gpio_request(GPIO_FN_VIO_CLK2, NULL);
-	gpio_request(GPIO_FN_VIO_VD2, NULL);
-	gpio_request(GPIO_FN_VIO_HD2, NULL);
-	gpio_request(GPIO_FN_VIO_FLD, NULL);
-	gpio_request(GPIO_FN_VIO_CKO, NULL);
-	gpio_request(GPIO_FN_VIO_D15, NULL);
-	gpio_request(GPIO_FN_VIO_D14, NULL);
-	gpio_request(GPIO_FN_VIO_D13, NULL);
-	gpio_request(GPIO_FN_VIO_D12, NULL);
-	gpio_request(GPIO_FN_VIO_D11, NULL);
-	gpio_request(GPIO_FN_VIO_D10, NULL);
-	gpio_request(GPIO_FN_VIO_D9, NULL);
-	gpio_request(GPIO_FN_VIO_D8, NULL);
-
-	__raw_writew(__raw_readw(PORT_MSELCRB) | 0x2000, PORT_MSELCRB); /* D15->D8 */
-
-	/* SIU: Port B */
-	gpio_request(GPIO_FN_SIUBOLR, NULL);
-	gpio_request(GPIO_FN_SIUBOBT, NULL);
-	gpio_request(GPIO_FN_SIUBISLD, NULL);
-	gpio_request(GPIO_FN_SIUBOSLD, NULL);
-	gpio_request(GPIO_FN_SIUMCKB, NULL);
-
-	/*
-	 * The original driver sets SIUB OLR/OBT, ILR/IBT, and SIUA OLR/OBT to
-	 * output. Need only SIUB, set to output for master mode (table 34.2)
-	 */
-	__raw_writew(__raw_readw(PORT_MSELCRA) | 1, PORT_MSELCRA);
-
-	 /*
-	  * Use 10 MHz VIO_CKO instead of 24 MHz to work around signal quality
-	  * issues on Panel Board V2.1.
-	  */
-	video_clk = clk_get(NULL, "video_clk");
-	if (!IS_ERR(video_clk)) {
-		clk_set_rate(video_clk, clk_round_rate(video_clk, 10000000));
-		clk_put(video_clk);
-	}
-
-	/* Add a clock alias for ov7725 xclk source. */
-	clk_add_alias(NULL, "0-0021", "video_clk", NULL);
-
-	/* Register GPIOs for video sources. */
-	gpiod_add_lookup_table(&ov7725_gpios);
-	gpiod_add_lookup_table(&tw9910_gpios);
-
-	i2c_register_board_info(0, migor_i2c_devices,
-				ARRAY_SIZE(migor_i2c_devices));
-
-	/* Initialize CEU platform device separately to map memory first */
-	device_initialize(&migor_ceu_device.dev);
-	dma_declare_coherent_memory(&migor_ceu_device.dev,
-			ceu_dma_membase, ceu_dma_membase,
-			ceu_dma_membase + CEU_BUFFER_MEMORY_SIZE - 1);
-
-	platform_device_add(&migor_ceu_device);
-
-	return platform_add_devices(migor_devices, ARRAY_SIZE(migor_devices));
-}
-arch_initcall(migor_devices_setup);
-
-/* Return the board specific boot mode pin configuration */
-static int migor_mode_pins(void)
-{
-	/* MD0=1, MD1=1, MD2=0: Clock Mode 3
-	 * MD3=0: 16-bit Area0 Bus Width
-	 * MD5=1: Little Endian
-	 * TSTMD=1, MD8=0: Test Mode Disabled
-	 */
-	return MODE_PIN0 | MODE_PIN1 | MODE_PIN5;
-}
-
-/* Reserve a portion of memory for CEU buffers */
-static void __init migor_mv_mem_reserve(void)
-{
-	phys_addr_t phys;
-	phys_addr_t size = CEU_BUFFER_MEMORY_SIZE;
-
-	phys = memblock_phys_alloc(size, PAGE_SIZE);
-	if (!phys)
-		panic("Failed to allocate CEU memory\n");
-
-	memblock_phys_free(phys, size);
-	memblock_remove(phys, size);
-
-	ceu_dma_membase = phys;
-}
-
-/*
- * The Machine Vector
- */
-static struct sh_machine_vector mv_migor __initmv = {
-	.mv_name		= "Migo-R",
-	.mv_mode_pins		= migor_mode_pins,
-	.mv_mem_reserve		= migor_mv_mem_reserve,
-};
diff --git a/arch/sh/boards/mach-r2d/Kconfig b/arch/sh/boards/mach-r2d/Kconfig
deleted file mode 100644
index 21770e668de283..00000000000000
--- a/arch/sh/boards/mach-r2d/Kconfig
+++ /dev/null
@@ -1,24 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-if SH_RTS7751R2D
-
-menu "RTS7751R2D Board Revision"
-
-config RTS7751R2D_PLUS
-	bool "R2D-PLUS"
-	help
-	  Selecting this option will configure the kernel for R2D-PLUS.
-
-	  R2D-PLUS is the smaller of the two R2D board versions, equipped
-	  with a single PCI slot.
-
-config RTS7751R2D_1
-	bool "R2D-1"
-	help
-	  Selecting this option will configure the kernel for R2D-1.
-
-	  R2D-1 is the larger of the two R2D board versions, equipped
-	  with two PCI slots.
-endmenu
-
-endif
-
diff --git a/arch/sh/boards/mach-r2d/Makefile b/arch/sh/boards/mach-r2d/Makefile
deleted file mode 100644
index 7e7ac5e0566211..00000000000000
--- a/arch/sh/boards/mach-r2d/Makefile
+++ /dev/null
@@ -1,6 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the RTS7751R2D specific parts of the kernel
-#
-
-obj-y	 := setup.o irq.o
diff --git a/arch/sh/boards/mach-r2d/irq.c b/arch/sh/boards/mach-r2d/irq.c
deleted file mode 100644
index e34f81e9ae813b..00000000000000
--- a/arch/sh/boards/mach-r2d/irq.c
+++ /dev/null
@@ -1,156 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/renesas/rts7751r2d/irq.c
- *
- * Copyright (C) 2007  Magnus Damm
- * Copyright (C) 2000  Kazumoto Kojima
- *
- * Renesas Technology Sales RTS7751R2D Support, R2D-PLUS and R2D-1.
- *
- * Modified for RTS7751R2D by
- * Atom Create Engineering Co., Ltd. 2002.
- */
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <linux/io.h>
-#include <mach/r2d.h>
-
-#define R2D_NR_IRL 13
-
-enum {
-	UNUSED = 0,
-
-	/* board specific interrupt sources (R2D-1 and R2D-PLUS) */
-	EXT,              /* EXT_INT0-3 */
-	RTC_T, RTC_A,     /* Real Time Clock */
-	AX88796,          /* Ethernet controller (R2D-1 board) */
-	KEY,              /* Key input (R2D-PLUS board) */
-	SDCARD,           /* SD Card */
-	CF_CD, CF_IDE,    /* CF Card Detect + CF IDE */
-	SM501,            /* SM501 aka Voyager */
-	PCI_INTD_RTL8139, /* Ethernet controller */
-	PCI_INTC_PCI1520, /* Cardbus/PCMCIA bridge */
-	PCI_INTB_RTL8139, /* Ethernet controller with HUB (R2D-PLUS board) */
-	PCI_INTB_SLOT,    /* PCI Slot 3.3v (R2D-1 board) */
-	PCI_INTA_SLOT,    /* PCI Slot 3.3v */
-	TP,               /* Touch Panel */
-};
-
-#ifdef CONFIG_RTS7751R2D_1
-
-/* Vectors for R2D-1 */
-static struct intc_vect vectors_r2d_1[] __initdata = {
-	INTC_IRQ(EXT, IRQ_EXT),
-	INTC_IRQ(RTC_T, IRQ_RTC_T), INTC_IRQ(RTC_A, IRQ_RTC_A),
-	INTC_IRQ(AX88796, IRQ_AX88796), INTC_IRQ(SDCARD, IRQ_SDCARD),
-	INTC_IRQ(CF_CD, IRQ_CF_CD), INTC_IRQ(CF_IDE, IRQ_CF_IDE), /* ng */
-	INTC_IRQ(SM501, IRQ_VOYAGER),
-	INTC_IRQ(PCI_INTD_RTL8139, IRQ_PCI_INTD),
-	INTC_IRQ(PCI_INTC_PCI1520, IRQ_PCI_INTC),
-	INTC_IRQ(PCI_INTB_SLOT, IRQ_PCI_INTB),
-	INTC_IRQ(PCI_INTA_SLOT, IRQ_PCI_INTA),
-	INTC_IRQ(TP, IRQ_TP),
-};
-
-/* IRLMSK mask register layout for R2D-1 */
-static struct intc_mask_reg mask_registers_r2d_1[] __initdata = {
-	{ 0xa4000000, 0, 16, /* IRLMSK */
-	  { TP, PCI_INTA_SLOT, PCI_INTB_SLOT,
-	    PCI_INTC_PCI1520, PCI_INTD_RTL8139,
-	    SM501, CF_IDE, CF_CD, SDCARD, AX88796,
-	    RTC_A, RTC_T, 0, 0, 0, EXT } },
-};
-
-/* IRLn to IRQ table for R2D-1 */
-static unsigned char irl2irq_r2d_1[R2D_NR_IRL] __initdata = {
-	IRQ_PCI_INTD, IRQ_CF_IDE, IRQ_CF_CD, IRQ_PCI_INTC,
-	IRQ_VOYAGER, IRQ_AX88796, IRQ_RTC_A, IRQ_RTC_T,
-	IRQ_SDCARD, IRQ_PCI_INTA, IRQ_PCI_INTB, IRQ_EXT,
-	IRQ_TP,
-};
-
-static DECLARE_INTC_DESC(intc_desc_r2d_1, "r2d-1", vectors_r2d_1,
-			 NULL, mask_registers_r2d_1, NULL, NULL);
-
-#endif /* CONFIG_RTS7751R2D_1 */
-
-#ifdef CONFIG_RTS7751R2D_PLUS
-
-/* Vectors for R2D-PLUS */
-static struct intc_vect vectors_r2d_plus[] __initdata = {
-	INTC_IRQ(EXT, IRQ_EXT),
-	INTC_IRQ(RTC_T, IRQ_RTC_T), INTC_IRQ(RTC_A, IRQ_RTC_A),
-	INTC_IRQ(KEY, IRQ_KEY), INTC_IRQ(SDCARD, IRQ_SDCARD),
-	INTC_IRQ(CF_CD, IRQ_CF_CD), INTC_IRQ(CF_IDE, IRQ_CF_IDE),
-	INTC_IRQ(SM501, IRQ_VOYAGER),
-	INTC_IRQ(PCI_INTD_RTL8139, IRQ_PCI_INTD),
-	INTC_IRQ(PCI_INTC_PCI1520, IRQ_PCI_INTC),
-	INTC_IRQ(PCI_INTB_RTL8139, IRQ_PCI_INTB),
-	INTC_IRQ(PCI_INTA_SLOT, IRQ_PCI_INTA),
-	INTC_IRQ(TP, IRQ_TP),
-};
-
-/* IRLMSK mask register layout for R2D-PLUS */
-static struct intc_mask_reg mask_registers_r2d_plus[] __initdata = {
-	{ 0xa4000000, 0, 16, /* IRLMSK */
-	  { TP, PCI_INTA_SLOT, PCI_INTB_RTL8139,
-	    PCI_INTC_PCI1520, PCI_INTD_RTL8139,
-	    SM501, CF_IDE, CF_CD, SDCARD, KEY,
-	    RTC_A, RTC_T, 0, 0, 0, EXT } },
-};
-
-/* IRLn to IRQ table for R2D-PLUS */
-static unsigned char irl2irq_r2d_plus[R2D_NR_IRL] __initdata = {
-	IRQ_PCI_INTD, IRQ_CF_IDE, IRQ_CF_CD, IRQ_PCI_INTC,
-	IRQ_VOYAGER, IRQ_KEY, IRQ_RTC_A, IRQ_RTC_T,
-	IRQ_SDCARD, IRQ_PCI_INTA, IRQ_PCI_INTB, IRQ_EXT,
-	IRQ_TP,
-};
-
-static DECLARE_INTC_DESC(intc_desc_r2d_plus, "r2d-plus", vectors_r2d_plus,
-			 NULL, mask_registers_r2d_plus, NULL, NULL);
-
-#endif /* CONFIG_RTS7751R2D_PLUS */
-
-static unsigned char irl2irq[R2D_NR_IRL];
-
-int rts7751r2d_irq_demux(int irq)
-{
-	if (irq >= R2D_NR_IRL || irq < 0 || !irl2irq[irq])
-		return irq;
-
-	return irl2irq[irq];
-}
-
-/*
- * Initialize IRQ setting
- */
-void __init init_rts7751r2d_IRQ(void)
-{
-	struct intc_desc *d;
-
-	switch (__raw_readw(PA_VERREG) & 0xf0) {
-#ifdef CONFIG_RTS7751R2D_PLUS
-	case 0x10:
-		printk(KERN_INFO "Using R2D-PLUS interrupt controller.\n");
-		d = &intc_desc_r2d_plus;
-		memcpy(irl2irq, irl2irq_r2d_plus, R2D_NR_IRL);
-		break;
-#endif
-#ifdef CONFIG_RTS7751R2D_1
-	case 0x00: /* according to manual */
-	case 0x30: /* in reality */
-		printk(KERN_INFO "Using R2D-1 interrupt controller.\n");
-		d = &intc_desc_r2d_1;
-		memcpy(irl2irq, irl2irq_r2d_1, R2D_NR_IRL);
-		break;
-#endif
-	default:
-		printk(KERN_INFO "Unknown R2D interrupt controller 0x%04x\n",
-		       __raw_readw(PA_VERREG));
-		return;
-	}
-
-	register_intc_controller(d);
-}
diff --git a/arch/sh/boards/mach-r2d/setup.c b/arch/sh/boards/mach-r2d/setup.c
deleted file mode 100644
index 3bc52f651d9611..00000000000000
--- a/arch/sh/boards/mach-r2d/setup.c
+++ /dev/null
@@ -1,305 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Renesas Technology Sales RTS7751R2D Support.
- *
- * Copyright (C) 2002 - 2006 Atom Create Engineering Co., Ltd.
- * Copyright (C) 2004 - 2007 Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/mtd/mtd.h>
-#include <linux/mtd/partitions.h>
-#include <linux/mtd/physmap.h>
-#include <linux/ata_platform.h>
-#include <linux/sm501.h>
-#include <linux/sm501-regs.h>
-#include <linux/pm.h>
-#include <linux/fb.h>
-#include <linux/spi/spi.h>
-#include <linux/spi/spi_bitbang.h>
-#include <asm/machvec.h>
-#include <mach/r2d.h>
-#include <asm/io.h>
-#include <asm/io_trapped.h>
-#include <asm/spi.h>
-
-static struct resource cf_ide_resources[] = {
-	[0] = {
-		.start	= PA_AREA5_IO + 0x1000,
-		.end	= PA_AREA5_IO + 0x1000 + 0x10 - 0x2,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= PA_AREA5_IO + 0x80c,
-		.end	= PA_AREA5_IO + 0x80c,
-		.flags	= IORESOURCE_MEM,
-	},
-#ifndef CONFIG_RTS7751R2D_1 /* For R2D-1 polling is preferred */
-	[2] = {
-		.start	= IRQ_CF_IDE,
-		.flags	= IORESOURCE_IRQ,
-	},
-#endif
-};
-
-static struct pata_platform_info pata_info = {
-	.ioport_shift	= 1,
-};
-
-static struct platform_device cf_ide_device  = {
-	.name		= "pata_platform",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(cf_ide_resources),
-	.resource	= cf_ide_resources,
-	.dev	= {
-		.platform_data	= &pata_info,
-	},
-};
-
-static struct spi_board_info spi_bus[] = {
-	{
-		.modalias	= "rtc-r9701",
-		.max_speed_hz	= 1000000,
-		.mode		= SPI_MODE_3,
-	},
-};
-
-static void r2d_chip_select(struct sh_spi_info *spi, int cs, int state)
-{
-	BUG_ON(cs != 0);  /* Single Epson RTC-9701JE attached on CS0 */
-	__raw_writew(state == BITBANG_CS_ACTIVE, PA_RTCCE);
-}
-
-static struct sh_spi_info spi_info = {
-	.num_chipselect = 1,
-	.chip_select = r2d_chip_select,
-};
-
-static struct resource spi_sh_sci_resources[] = {
-	{
-		.start	= 0xffe00000,
-		.end	= 0xffe0001f,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device spi_sh_sci_device  = {
-	.name		= "spi_sh_sci",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(spi_sh_sci_resources),
-	.resource	= spi_sh_sci_resources,
-	.dev	= {
-		.platform_data	= &spi_info,
-	},
-};
-
-static struct resource heartbeat_resources[] = {
-	[0] = {
-		.start	= PA_OUTPORT,
-		.end	= PA_OUTPORT,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device heartbeat_device = {
-	.name		= "heartbeat",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(heartbeat_resources),
-	.resource	= heartbeat_resources,
-};
-
-static struct resource sm501_resources[] = {
-	[0]	= {
-		.start	= 0x10000000,
-		.end	= 0x13e00000 - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1]	= {
-		.start	= 0x13e00000,
-		.end	= 0x13ffffff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[2]	= {
-		.start	= IRQ_VOYAGER,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct fb_videomode sm501_default_mode = {
-	.pixclock	= 35714,
-	.xres		= 640,
-	.yres		= 480,
-	.left_margin	= 105,
-	.right_margin	= 50,
-	.upper_margin	= 35,
-	.lower_margin	= 0,
-	.hsync_len	= 96,
-	.vsync_len	= 2,
-	.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-};
-
-static struct sm501_platdata_fbsub sm501_pdata_fbsub_pnl = {
-	.def_bpp	= 16,
-	.def_mode	= &sm501_default_mode,
-	.flags		= SM501FB_FLAG_USE_INIT_MODE |
-			  SM501FB_FLAG_USE_HWCURSOR |
-			  SM501FB_FLAG_USE_HWACCEL |
-			  SM501FB_FLAG_DISABLE_AT_EXIT,
-};
-
-static struct sm501_platdata_fbsub sm501_pdata_fbsub_crt = {
-	.flags		= (SM501FB_FLAG_USE_INIT_MODE |
-			   SM501FB_FLAG_USE_HWCURSOR |
-			   SM501FB_FLAG_USE_HWACCEL |
-			   SM501FB_FLAG_DISABLE_AT_EXIT),
-
-};
-
-static struct sm501_platdata_fb sm501_fb_pdata = {
-	.fb_route	= SM501_FB_OWN,
-	.fb_crt		= &sm501_pdata_fbsub_crt,
-	.fb_pnl		= &sm501_pdata_fbsub_pnl,
-	.flags		= SM501_FBPD_SWAP_FB_ENDIAN,
-};
-
-static struct sm501_initdata sm501_initdata = {
-	.devices	= SM501_USE_USB_HOST | SM501_USE_UART0,
-};
-
-static struct sm501_platdata sm501_platform_data = {
-	.init		= &sm501_initdata,
-	.fb		= &sm501_fb_pdata,
-};
-
-static struct platform_device sm501_device = {
-	.name		= "sm501",
-	.id		= -1,
-	.dev		= {
-		.platform_data	= &sm501_platform_data,
-	},
-	.num_resources	= ARRAY_SIZE(sm501_resources),
-	.resource	= sm501_resources,
-};
-
-static struct mtd_partition r2d_partitions[] = {
-	{
-		.name		= "U-Boot",
-		.offset		= 0x00000000,
-		.size		= 0x00040000,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "Environment",
-		.offset		= MTDPART_OFS_NXTBLK,
-		.size		= 0x00040000,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "Kernel",
-		.offset		= MTDPART_OFS_NXTBLK,
-		.size		= 0x001c0000,
-	}, {
-		.name		= "Flash_FS",
-		.offset		= MTDPART_OFS_NXTBLK,
-		.size		= MTDPART_SIZ_FULL,
-	}
-};
-
-static struct physmap_flash_data flash_data = {
-	.width		= 2,
-	.nr_parts	= ARRAY_SIZE(r2d_partitions),
-	.parts		= r2d_partitions,
-};
-
-static struct resource flash_resource = {
-	.start		= 0x00000000,
-	.end		= 0x02000000,
-	.flags		= IORESOURCE_MEM,
-};
-
-static struct platform_device flash_device = {
-	.name		= "physmap-flash",
-	.id		= -1,
-	.resource	= &flash_resource,
-	.num_resources	= 1,
-	.dev		= {
-		.platform_data = &flash_data,
-	},
-};
-
-static struct platform_device *rts7751r2d_devices[] __initdata = {
-	&sm501_device,
-	&heartbeat_device,
-	&spi_sh_sci_device,
-};
-
-/*
- * The CF is connected with a 16-bit bus where 8-bit operations are
- * unsupported. The linux ata driver is however using 8-bit operations, so
- * insert a trapped io filter to convert 8-bit operations into 16-bit.
- */
-static struct trapped_io cf_trapped_io = {
-	.resource		= cf_ide_resources,
-	.num_resources		= 2,
-	.minimum_bus_width	= 16,
-};
-
-static int __init rts7751r2d_devices_setup(void)
-{
-	if (register_trapped_io(&cf_trapped_io) == 0)
-		platform_device_register(&cf_ide_device);
-
-	if (mach_is_r2d_plus())
-		platform_device_register(&flash_device);
-
-	spi_register_board_info(spi_bus, ARRAY_SIZE(spi_bus));
-
-	return platform_add_devices(rts7751r2d_devices,
-				    ARRAY_SIZE(rts7751r2d_devices));
-}
-device_initcall(rts7751r2d_devices_setup);
-
-static void rts7751r2d_power_off(void)
-{
-	__raw_writew(0x0001, PA_POWOFF);
-}
-
-/*
- * Initialize the board
- */
-static void __init rts7751r2d_setup(char **cmdline_p)
-{
-	void __iomem *sm501_reg;
-	u16 ver = __raw_readw(PA_VERREG);
-
-	printk(KERN_INFO "Renesas Technology Sales RTS7751R2D support.\n");
-
-	printk(KERN_INFO "FPGA version:%d (revision:%d)\n",
-					(ver >> 4) & 0xf, ver & 0xf);
-
-	__raw_writew(0x0000, PA_OUTPORT);
-	pm_power_off = rts7751r2d_power_off;
-
-	/* sm501 dram configuration:
-	 * ColSizeX = 11 - External Memory Column Size: 256 words.
-	 * APX = 1 - External Memory Active to Pre-Charge Delay: 7 clocks.
-	 * RstX = 1 - External Memory Reset: Normal.
-	 * Rfsh = 1 - Local Memory Refresh to Command Delay: 12 clocks.
-	 * BwC =  1 - Local Memory Block Write Cycle Time: 2 clocks.
-	 * BwP =  1 - Local Memory Block Write to Pre-Charge Delay: 1 clock.
-	 * AP = 1 - Internal Memory Active to Pre-Charge Delay: 7 clocks.
-	 * Rst = 1 - Internal Memory Reset: Normal.
-	 * RA = 1 - Internal Memory Remain in Active State: Do not remain.
-	 */
-
-	sm501_reg = (void __iomem *)0xb3e00000 + SM501_DRAM_CONTROL;
-	writel(readl(sm501_reg) | 0x00f107c0, sm501_reg);
-}
-
-/*
- * The Machine Vector
- */
-static struct sh_machine_vector mv_rts7751r2d __initmv = {
-	.mv_name		= "RTS7751R2D",
-	.mv_setup		= rts7751r2d_setup,
-	.mv_init_irq		= init_rts7751r2d_IRQ,
-	.mv_irq_demux		= rts7751r2d_irq_demux,
-};
diff --git a/arch/sh/boards/mach-rsk/Kconfig b/arch/sh/boards/mach-rsk/Kconfig
deleted file mode 100644
index f0299bc4416f80..00000000000000
--- a/arch/sh/boards/mach-rsk/Kconfig
+++ /dev/null
@@ -1,29 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-if SH_RSK
-
-choice
-	prompt "RSK+ options"
-	default SH_RSK7203
-
-config SH_RSK7201
-	bool "RSK7201"
-	depends on CPU_SUBTYPE_SH7201
-
-config SH_RSK7203
-	bool "RSK7203"
-	select GPIOLIB
-	depends on CPU_SUBTYPE_SH7203
-
-config SH_RSK7264
-	bool "RSK2+SH7264"
-	select GPIOLIB
-	depends on CPU_SUBTYPE_SH7264
-
-config SH_RSK7269
-	bool "RSK2+SH7269"
-	select GPIOLIB
-	depends on CPU_SUBTYPE_SH7269
-
-endchoice
-
-endif
diff --git a/arch/sh/boards/mach-rsk/Makefile b/arch/sh/boards/mach-rsk/Makefile
deleted file mode 100644
index 43cca39a9fe612..00000000000000
--- a/arch/sh/boards/mach-rsk/Makefile
+++ /dev/null
@@ -1,5 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-obj-y				:= setup.o
-obj-$(CONFIG_SH_RSK7203)	+= devices-rsk7203.o
-obj-$(CONFIG_SH_RSK7264)	+= devices-rsk7264.o
-obj-$(CONFIG_SH_RSK7269)	+= devices-rsk7269.o
diff --git a/arch/sh/boards/mach-rsk/devices-rsk7203.c b/arch/sh/boards/mach-rsk/devices-rsk7203.c
deleted file mode 100644
index e6b05d4588b7b9..00000000000000
--- a/arch/sh/boards/mach-rsk/devices-rsk7203.c
+++ /dev/null
@@ -1,137 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Renesas Technology Europe RSK+ 7203 Support.
- *
- * Copyright (C) 2008 - 2010  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <linux/smsc911x.h>
-#include <linux/input.h>
-#include <linux/gpio.h>
-#include <linux/gpio_keys.h>
-#include <linux/leds.h>
-#include <asm/machvec.h>
-#include <asm/io.h>
-#include <cpu/sh7203.h>
-
-static struct smsc911x_platform_config smsc911x_config = {
-	.phy_interface	= PHY_INTERFACE_MODE_MII,
-	.irq_polarity	= SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
-	.irq_type	= SMSC911X_IRQ_TYPE_OPEN_DRAIN,
-	.flags		= SMSC911X_USE_32BIT | SMSC911X_SWAP_FIFO,
-};
-
-static struct resource smsc911x_resources[] = {
-	[0] = {
-		.start		= 0x24000000,
-		.end		= 0x240000ff,
-		.flags		= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start		= 64,
-		.end		= 64,
-		.flags		= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device smsc911x_device = {
-	.name		= "smsc911x",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(smsc911x_resources),
-	.resource	= smsc911x_resources,
-	.dev		= {
-		.platform_data = &smsc911x_config,
-	},
-};
-
-static struct gpio_led rsk7203_gpio_leds[] = {
-	{
-		.name			= "green",
-		.gpio			= GPIO_PE10,
-		.active_low		= 1,
-	}, {
-		.name			= "orange",
-		.default_trigger	= "nand-disk",
-		.gpio			= GPIO_PE12,
-		.active_low		= 1,
-	}, {
-		.name			= "red:timer",
-		.default_trigger	= "timer",
-		.gpio			= GPIO_PC14,
-		.active_low		= 1,
-	}, {
-		.name			= "red:heartbeat",
-		.default_trigger	= "heartbeat",
-		.gpio			= GPIO_PE11,
-		.active_low		= 1,
-	},
-};
-
-static struct gpio_led_platform_data rsk7203_gpio_leds_info = {
-	.leds		= rsk7203_gpio_leds,
-	.num_leds	= ARRAY_SIZE(rsk7203_gpio_leds),
-};
-
-static struct platform_device led_device = {
-	.name		= "leds-gpio",
-	.id		= -1,
-	.dev		= {
-		.platform_data	= &rsk7203_gpio_leds_info,
-	},
-};
-
-static struct gpio_keys_button rsk7203_gpio_keys_table[] = {
-	{
-		.code		= BTN_0,
-		.gpio		= GPIO_PB0,
-		.active_low	= 1,
-		.desc		= "SW1",
-	}, {
-		.code		= BTN_1,
-		.gpio		= GPIO_PB1,
-		.active_low	= 1,
-		.desc		= "SW2",
-	}, {
-		.code		= BTN_2,
-		.gpio		= GPIO_PB2,
-		.active_low	= 1,
-		.desc		= "SW3",
-	},
-};
-
-static struct gpio_keys_platform_data rsk7203_gpio_keys_info = {
-	.buttons	= rsk7203_gpio_keys_table,
-	.nbuttons	= ARRAY_SIZE(rsk7203_gpio_keys_table),
-	.poll_interval	= 50, /* default to 50ms */
-};
-
-static struct platform_device keys_device = {
-	.name		= "gpio-keys-polled",
-	.dev		= {
-		.platform_data	= &rsk7203_gpio_keys_info,
-	},
-};
-
-static struct platform_device *rsk7203_devices[] __initdata = {
-	&smsc911x_device,
-	&led_device,
-	&keys_device,
-};
-
-static int __init rsk7203_devices_setup(void)
-{
-	/* Select pins for SCIF0 */
-	gpio_request(GPIO_FN_TXD0, NULL);
-	gpio_request(GPIO_FN_RXD0, NULL);
-
-	/* Setup LAN9118: CS1 in 16-bit Big Endian Mode, IRQ0 at Port B */
-	__raw_writel(0x36db0400, 0xfffc0008); /* CS1BCR */
-	gpio_request(GPIO_FN_IRQ0_PB, NULL);
-
-	return platform_add_devices(rsk7203_devices,
-				    ARRAY_SIZE(rsk7203_devices));
-}
-device_initcall(rsk7203_devices_setup);
diff --git a/arch/sh/boards/mach-rsk/devices-rsk7264.c b/arch/sh/boards/mach-rsk/devices-rsk7264.c
deleted file mode 100644
index eaf700a20b833e..00000000000000
--- a/arch/sh/boards/mach-rsk/devices-rsk7264.c
+++ /dev/null
@@ -1,55 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * RSK+SH7264 Support.
- *
- * Copyright (C) 2012 Renesas Electronics Europe
- */
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <linux/input.h>
-#include <linux/smsc911x.h>
-#include <asm/machvec.h>
-#include <asm/io.h>
-
-static struct smsc911x_platform_config smsc911x_config = {
-	.phy_interface	= PHY_INTERFACE_MODE_MII,
-	.irq_polarity	= SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
-	.irq_type	= SMSC911X_IRQ_TYPE_OPEN_DRAIN,
-	.flags		= SMSC911X_USE_16BIT | SMSC911X_SWAP_FIFO,
-};
-
-static struct resource smsc911x_resources[] = {
-	[0] = {
-		.start		= 0x28000000,
-		.end		= 0x280000ff,
-		.flags		= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start		= 65,
-		.end		= 65,
-		.flags		= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device smsc911x_device = {
-	.name		= "smsc911x",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(smsc911x_resources),
-	.resource	= smsc911x_resources,
-	.dev		= {
-		.platform_data = &smsc911x_config,
-	},
-};
-
-static struct platform_device *rsk7264_devices[] __initdata = {
-	&smsc911x_device,
-};
-
-static int __init rsk7264_devices_setup(void)
-{
-	return platform_add_devices(rsk7264_devices,
-				    ARRAY_SIZE(rsk7264_devices));
-}
-device_initcall(rsk7264_devices_setup);
diff --git a/arch/sh/boards/mach-rsk/devices-rsk7269.c b/arch/sh/boards/mach-rsk/devices-rsk7269.c
deleted file mode 100644
index 4b1e386b51dd64..00000000000000
--- a/arch/sh/boards/mach-rsk/devices-rsk7269.c
+++ /dev/null
@@ -1,57 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * RSK+SH7269 Support
- *
- * Copyright (C) 2012  Renesas Electronics Europe Ltd
- * Copyright (C) 2012  Phil Edworthy
- */
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <linux/input.h>
-#include <linux/smsc911x.h>
-#include <linux/gpio.h>
-#include <asm/machvec.h>
-#include <asm/io.h>
-
-static struct smsc911x_platform_config smsc911x_config = {
-	.phy_interface	= PHY_INTERFACE_MODE_MII,
-	.irq_polarity	= SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
-	.irq_type	= SMSC911X_IRQ_TYPE_PUSH_PULL,
-	.flags		= SMSC911X_USE_16BIT | SMSC911X_SWAP_FIFO,
-};
-
-static struct resource smsc911x_resources[] = {
-	[0] = {
-		.start		= 0x24000000,
-		.end		= 0x240000ff,
-		.flags		= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start		= 85,
-		.end		= 85,
-		.flags		= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device smsc911x_device = {
-	.name		= "smsc911x",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(smsc911x_resources),
-	.resource	= smsc911x_resources,
-	.dev		= {
-		.platform_data = &smsc911x_config,
-	},
-};
-
-static struct platform_device *rsk7269_devices[] __initdata = {
-	&smsc911x_device,
-};
-
-static int __init rsk7269_devices_setup(void)
-{
-	return platform_add_devices(rsk7269_devices,
-				    ARRAY_SIZE(rsk7269_devices));
-}
-device_initcall(rsk7269_devices_setup);
diff --git a/arch/sh/boards/mach-rsk/setup.c b/arch/sh/boards/mach-rsk/setup.c
deleted file mode 100644
index 9370c4fdc41e13..00000000000000
--- a/arch/sh/boards/mach-rsk/setup.c
+++ /dev/null
@@ -1,84 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Renesas Technology Europe RSK+ Support.
- *
- * Copyright (C) 2008 Paul Mundt
- * Copyright (C) 2008 Peter Griffin <pgriffin@mpc-data.co.uk>
- */
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <linux/mtd/mtd.h>
-#include <linux/mtd/partitions.h>
-#include <linux/mtd/physmap.h>
-#include <linux/mtd/map.h>
-#include <linux/regulator/fixed.h>
-#include <linux/regulator/machine.h>
-#include <asm/machvec.h>
-#include <asm/io.h>
-
-/* Dummy supplies, where voltage doesn't matter */
-static struct regulator_consumer_supply dummy_supplies[] = {
-	REGULATOR_SUPPLY("vddvario", "smsc911x"),
-	REGULATOR_SUPPLY("vdd33a", "smsc911x"),
-};
-
-static struct mtd_partition rsk_partitions[] = {
-	{
-		.name		= "Bootloader",
-		.offset		= 0x00000000,
-		.size		= 0x00040000,
-		.mask_flags	= MTD_WRITEABLE,
-	}, {
-		.name		= "Kernel",
-		.offset		= MTDPART_OFS_NXTBLK,
-		.size		= 0x001c0000,
-	}, {
-		.name		= "Flash_FS",
-		.offset		= MTDPART_OFS_NXTBLK,
-		.size		= MTDPART_SIZ_FULL,
-	}
-};
-
-static struct physmap_flash_data flash_data = {
-	.parts			= rsk_partitions,
-	.nr_parts		= ARRAY_SIZE(rsk_partitions),
-	.width			= 2,
-};
-
-static struct resource flash_resource = {
-	.start		= 0x20000000,
-	.end		= 0x20400000,
-	.flags		= IORESOURCE_MEM,
-};
-
-static struct platform_device flash_device = {
-	.name		= "physmap-flash",
-	.id		= -1,
-	.resource	= &flash_resource,
-	.num_resources	= 1,
-	.dev		= {
-		.platform_data = &flash_data,
-	},
-};
-
-static struct platform_device *rsk_devices[] __initdata = {
-	&flash_device,
-};
-
-static int __init rsk_devices_setup(void)
-{
-	regulator_register_fixed(0, dummy_supplies, ARRAY_SIZE(dummy_supplies));
-
-	return platform_add_devices(rsk_devices,
-				    ARRAY_SIZE(rsk_devices));
-}
-device_initcall(rsk_devices_setup);
-
-/*
- * The Machine Vector
- */
-static struct sh_machine_vector mv_rsk __initmv = {
-	.mv_name        = "RSK+",
-};
diff --git a/arch/sh/boards/mach-sdk7780/Kconfig b/arch/sh/boards/mach-sdk7780/Kconfig
deleted file mode 100644
index d4392efd2f74db..00000000000000
--- a/arch/sh/boards/mach-sdk7780/Kconfig
+++ /dev/null
@@ -1,17 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-if SH_SDK7780
-
-choice
-	prompt "SDK7780 options"
-	default SH_SDK7780_BASE
-
-config SH_SDK7780_BASE
-	bool "SDK7780 with base-board support"
-	depends on CPU_SUBTYPE_SH7780
-	help
-	  Selecting this option will enable support for the expansion
-	  baseboard devices. If in doubt, say Y.
-
-endchoice
-
-endif
diff --git a/arch/sh/boards/mach-sdk7780/Makefile b/arch/sh/boards/mach-sdk7780/Makefile
deleted file mode 100644
index 37e857f9a55a26..00000000000000
--- a/arch/sh/boards/mach-sdk7780/Makefile
+++ /dev/null
@@ -1,6 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the SDK7780 specific parts of the kernel
-#
-obj-y	 := setup.o irq.o
-
diff --git a/arch/sh/boards/mach-sdk7780/irq.c b/arch/sh/boards/mach-sdk7780/irq.c
deleted file mode 100644
index fa392f3dce266b..00000000000000
--- a/arch/sh/boards/mach-sdk7780/irq.c
+++ /dev/null
@@ -1,43 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/renesas/sdk7780/irq.c
- *
- * Renesas Technology Europe SDK7780 Support.
- *
- * Copyright (C) 2008  Nicholas Beck <nbeck@mpc-data.co.uk>
- */
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/io.h>
-#include <mach/sdk7780.h>
-
-enum {
-	UNUSED = 0,
-	/* board specific interrupt sources */
-	SMC91C111,	/* Ethernet controller */
-};
-
-static struct intc_vect fpga_vectors[] __initdata = {
-	INTC_IRQ(SMC91C111, IRQ_ETHERNET),
-};
-
-static struct intc_mask_reg fpga_mask_registers[] __initdata = {
-	{ 0, FPGA_IRQ0MR, 16,
-	  { 0, 0, 0, 0, 0, 0, 0, 0,
-	    0, 0, 0, SMC91C111, 0, 0, 0, 0 } },
-};
-
-static DECLARE_INTC_DESC(fpga_intc_desc, "sdk7780-irq", fpga_vectors,
-			 NULL, fpga_mask_registers, NULL, NULL);
-
-void __init init_sdk7780_IRQ(void)
-{
-	printk(KERN_INFO "Using SDK7780 interrupt controller.\n");
-
-	__raw_writew(0xFFFF, FPGA_IRQ0MR);
-	/* Setup IRL 0-3 */
-	__raw_writew(0x0003, FPGA_IMSR);
-	plat_irq_setup_pins(IRQ_MODE_IRL3210);
-
-	register_intc_controller(&fpga_intc_desc);
-}
diff --git a/arch/sh/boards/mach-sdk7780/setup.c b/arch/sh/boards/mach-sdk7780/setup.c
deleted file mode 100644
index 482761b780e406..00000000000000
--- a/arch/sh/boards/mach-sdk7780/setup.c
+++ /dev/null
@@ -1,96 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/boards/renesas/sdk7780/setup.c
- *
- * Renesas Solutions SH7780 SDK Support
- * Copyright (C) 2008 Nicholas Beck <nbeck@mpc-data.co.uk>
- */
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/platform_device.h>
-#include <linux/ata_platform.h>
-#include <asm/machvec.h>
-#include <mach/sdk7780.h>
-#include <asm/heartbeat.h>
-#include <asm/io.h>
-#include <asm/addrspace.h>
-
-#define GPIO_PECR        0xFFEA0008
-
-/* Heartbeat */
-static struct resource heartbeat_resource = {
-	.start  = PA_LED,
-	.end    = PA_LED,
-	.flags  = IORESOURCE_MEM | IORESOURCE_MEM_16BIT,
-};
-
-static struct platform_device heartbeat_device = {
-	.name           = "heartbeat",
-	.id             = -1,
-	.num_resources  = 1,
-	.resource       = &heartbeat_resource,
-};
-
-/* SMC91x */
-static struct resource smc91x_eth_resources[] = {
-	[0] = {
-		.name   = "smc91x-regs" ,
-		.start  = PA_LAN + 0x300,
-		.end    = PA_LAN + 0x300 + 0x10 ,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = IRQ_ETHERNET,
-		.end    = IRQ_ETHERNET,
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device smc91x_eth_device = {
-	.name           = "smc91x",
-	.id             = 0,
-	.dev = {
-		.dma_mask               = NULL,         /* don't use dma */
-		.coherent_dma_mask      = 0xffffffff,
-	},
-	.num_resources  = ARRAY_SIZE(smc91x_eth_resources),
-	.resource       = smc91x_eth_resources,
-};
-
-static struct platform_device *sdk7780_devices[] __initdata = {
-	&heartbeat_device,
-	&smc91x_eth_device,
-};
-
-static int __init sdk7780_devices_setup(void)
-{
-	return platform_add_devices(sdk7780_devices,
-		ARRAY_SIZE(sdk7780_devices));
-}
-device_initcall(sdk7780_devices_setup);
-
-static void __init sdk7780_setup(char **cmdline_p)
-{
-	u16 ver = __raw_readw(FPGA_FPVERR);
-	u16 dateStamp = __raw_readw(FPGA_FPDATER);
-
-	printk(KERN_INFO "Renesas Technology Europe SDK7780 support.\n");
-	printk(KERN_INFO "Board version: %d (revision %d), "
-			 "FPGA version: %d (revision %d), datestamp : %d\n",
-			 (ver >> 12) & 0xf, (ver >> 8) & 0xf,
-			 (ver >>  4) & 0xf, ver & 0xf,
-			 dateStamp);
-
-	/* Setup pin mux'ing for PCIC */
-	__raw_writew(0x0000, GPIO_PECR);
-}
-
-/*
- * The Machine Vector
- */
-static struct sh_machine_vector mv_se7780 __initmv = {
-	.mv_name        = "Renesas SDK7780-R3" ,
-	.mv_setup		= sdk7780_setup,
-	.mv_init_irq	= init_sdk7780_IRQ,
-};
-
diff --git a/arch/sh/boards/mach-sdk7786/Makefile b/arch/sh/boards/mach-sdk7786/Makefile
deleted file mode 100644
index 731a87c694b3bc..00000000000000
--- a/arch/sh/boards/mach-sdk7786/Makefile
+++ /dev/null
@@ -1,5 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-obj-y	:= fpga.o irq.o nmi.o setup.o
-
-obj-$(CONFIG_GPIOLIB)		+= gpio.o
-obj-$(CONFIG_HAVE_SRAM_POOL)	+= sram.o
diff --git a/arch/sh/boards/mach-sdk7786/fpga.c b/arch/sh/boards/mach-sdk7786/fpga.c
deleted file mode 100644
index a37e1e88c6b1f2..00000000000000
--- a/arch/sh/boards/mach-sdk7786/fpga.c
+++ /dev/null
@@ -1,69 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SDK7786 FPGA Support.
- *
- * Copyright (C) 2010  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/bcd.h>
-#include <mach/fpga.h>
-#include <linux/sizes.h>
-
-#define FPGA_REGS_OFFSET	0x03fff800
-#define FPGA_REGS_SIZE		0x490
-
-/*
- * The FPGA can be mapped in any of the generally available areas,
- * so we attempt to scan for it using the fixed SRSTR read magic.
- *
- * Once the FPGA is located, the rest of the mapping data for the other
- * components can be determined dynamically from its section mapping
- * registers.
- */
-static void __iomem *sdk7786_fpga_probe(void)
-{
-	unsigned long area;
-	void __iomem *base;
-
-	/*
-	 * Iterate over all of the areas where the FPGA could be mapped.
-	 * The possible range is anywhere from area 0 through 6, area 7
-	 * is reserved.
-	 */
-	for (area = PA_AREA0; area < PA_AREA7; area += SZ_64M) {
-		base = ioremap(area + FPGA_REGS_OFFSET, FPGA_REGS_SIZE);
-		if (!base) {
-			/* Failed to remap this area, move along. */
-			continue;
-		}
-
-		if (ioread16(base + SRSTR) == SRSTR_MAGIC)
-			return base;	/* Found it! */
-
-		iounmap(base);
-	}
-
-	return NULL;
-}
-
-void __iomem *sdk7786_fpga_base;
-
-void __init sdk7786_fpga_init(void)
-{
-	u16 version, date;
-
-	sdk7786_fpga_base = sdk7786_fpga_probe();
-	if (unlikely(!sdk7786_fpga_base)) {
-		panic("FPGA detection failed.\n");
-		return;
-	}
-
-	version = fpga_read_reg(FPGAVR);
-	date = fpga_read_reg(FPGADR);
-
-	pr_info("\tFPGA version:\t%d.%d (built on %d/%d/%d)\n",
-		bcd2bin(version >> 8) & 0xf, bcd2bin(version & 0xf),
-		((date >> 12) & 0xf) + 2000,
-		(date >> 8) & 0xf, bcd2bin(date & 0xff));
-}
diff --git a/arch/sh/boards/mach-sdk7786/gpio.c b/arch/sh/boards/mach-sdk7786/gpio.c
deleted file mode 100644
index c4587d1013e611..00000000000000
--- a/arch/sh/boards/mach-sdk7786/gpio.c
+++ /dev/null
@@ -1,46 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SDK7786 FPGA USRGPIR Support.
- *
- * Copyright (C) 2010  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/gpio/driver.h>
-#include <linux/irq.h>
-#include <linux/kernel.h>
-#include <linux/spinlock.h>
-#include <linux/io.h>
-#include <mach/fpga.h>
-
-#define NR_FPGA_GPIOS	8
-
-static const char *usrgpir_gpio_names[NR_FPGA_GPIOS] = {
-	"in0", "in1", "in2", "in3", "in4", "in5", "in6", "in7",
-};
-
-static int usrgpir_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)
-{
-	/* always in */
-	return 0;
-}
-
-static int usrgpir_gpio_get(struct gpio_chip *chip, unsigned gpio)
-{
-	return !!(fpga_read_reg(USRGPIR) & (1 << gpio));
-}
-
-static struct gpio_chip usrgpir_gpio_chip = {
-	.label			= "sdk7786-fpga",
-	.names			= usrgpir_gpio_names,
-	.direction_input	= usrgpir_gpio_direction_input,
-	.get			= usrgpir_gpio_get,
-	.base			= -1, /* don't care */
-	.ngpio			= NR_FPGA_GPIOS,
-};
-
-static int __init usrgpir_gpio_setup(void)
-{
-	return gpiochip_add_data(&usrgpir_gpio_chip, NULL);
-}
-device_initcall(usrgpir_gpio_setup);
diff --git a/arch/sh/boards/mach-sdk7786/irq.c b/arch/sh/boards/mach-sdk7786/irq.c
deleted file mode 100644
index 340c306ea95239..00000000000000
--- a/arch/sh/boards/mach-sdk7786/irq.c
+++ /dev/null
@@ -1,45 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SDK7786 FPGA IRQ Controller Support.
- *
- * Copyright (C) 2010  Matt Fleming
- * Copyright (C) 2010  Paul Mundt
- */
-#include <linux/irq.h>
-#include <mach/fpga.h>
-#include <mach/irq.h>
-
-enum {
-	ATA_IRQ_BIT		= 1,
-	SPI_BUSY_BIT		= 2,
-	LIRQ5_BIT		= 3,
-	LIRQ6_BIT		= 4,
-	LIRQ7_BIT		= 5,
-	LIRQ8_BIT		= 6,
-	KEY_IRQ_BIT		= 7,
-	PEN_IRQ_BIT		= 8,
-	ETH_IRQ_BIT		= 9,
-	RTC_ALARM_BIT		= 10,
-	CRYSTAL_FAIL_BIT	= 12,
-	ETH_PME_BIT		= 14,
-};
-
-void __init sdk7786_init_irq(void)
-{
-	unsigned int tmp;
-
-	/* Enable priority encoding for all IRLs */
-	fpga_write_reg(fpga_read_reg(INTMSR) | 0x0303, INTMSR);
-
-	/* Clear FPGA interrupt status registers */
-	fpga_write_reg(0x0000, INTASR);
-	fpga_write_reg(0x0000, INTBSR);
-
-	/* Unmask FPGA interrupts */
-	tmp = fpga_read_reg(INTAMR);
-	tmp &= ~(1 << ETH_IRQ_BIT);
-	fpga_write_reg(tmp, INTAMR);
-
-	plat_irq_setup_pins(IRQ_MODE_IRL7654_MASK);
-	plat_irq_setup_pins(IRQ_MODE_IRL3210_MASK);
-}
diff --git a/arch/sh/boards/mach-sdk7786/nmi.c b/arch/sh/boards/mach-sdk7786/nmi.c
deleted file mode 100644
index afba49679a1219..00000000000000
--- a/arch/sh/boards/mach-sdk7786/nmi.c
+++ /dev/null
@@ -1,80 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SDK7786 FPGA NMI Support.
- *
- * Copyright (C) 2010  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/string.h>
-#include <mach/fpga.h>
-
-enum {
-	NMI_MODE_MANUAL,
-	NMI_MODE_AUX,
-	NMI_MODE_MASKED,
-	NMI_MODE_ANY,
-	NMI_MODE_UNKNOWN,
-};
-
-/*
- * Default to the manual NMI switch.
- */
-static unsigned int __initdata nmi_mode = NMI_MODE_ANY;
-
-static int __init nmi_mode_setup(char *str)
-{
-	if (!str)
-		return 0;
-
-	if (strcmp(str, "manual") == 0)
-		nmi_mode = NMI_MODE_MANUAL;
-	else if (strcmp(str, "aux") == 0)
-		nmi_mode = NMI_MODE_AUX;
-	else if (strcmp(str, "masked") == 0)
-		nmi_mode = NMI_MODE_MASKED;
-	else if (strcmp(str, "any") == 0)
-		nmi_mode = NMI_MODE_ANY;
-	else {
-		nmi_mode = NMI_MODE_UNKNOWN;
-		pr_warn("Unknown NMI mode %s\n", str);
-	}
-
-	printk("Set NMI mode to %d\n", nmi_mode);
-	return 0;
-}
-early_param("nmi_mode", nmi_mode_setup);
-
-void __init sdk7786_nmi_init(void)
-{
-	unsigned int source, mask, tmp;
-
-	switch (nmi_mode) {
-	case NMI_MODE_MANUAL:
-		source = NMISR_MAN_NMI;
-		mask = NMIMR_MAN_NMIM;
-		break;
-	case NMI_MODE_AUX:
-		source = NMISR_AUX_NMI;
-		mask = NMIMR_AUX_NMIM;
-		break;
-	case NMI_MODE_ANY:
-		source = NMISR_MAN_NMI | NMISR_AUX_NMI;
-		mask = NMIMR_MAN_NMIM | NMIMR_AUX_NMIM;
-		break;
-	case NMI_MODE_MASKED:
-	case NMI_MODE_UNKNOWN:
-	default:
-		source = mask = 0;
-		break;
-	}
-
-	/* Set the NMI source */
-	tmp = fpga_read_reg(NMISR);
-	tmp &= ~NMISR_MASK;
-	tmp |= source;
-	fpga_write_reg(tmp, NMISR);
-
-	/* And the IRQ masking */
-	fpga_write_reg(NMIMR_MASK ^ mask, NMIMR);
-}
diff --git a/arch/sh/boards/mach-sdk7786/setup.c b/arch/sh/boards/mach-sdk7786/setup.c
deleted file mode 100644
index d183026dbeb19a..00000000000000
--- a/arch/sh/boards/mach-sdk7786/setup.c
+++ /dev/null
@@ -1,266 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Renesas Technology Europe SDK7786 Support.
- *
- * Copyright (C) 2010  Matt Fleming
- * Copyright (C) 2010  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/io.h>
-#include <linux/regulator/fixed.h>
-#include <linux/regulator/machine.h>
-#include <linux/smsc911x.h>
-#include <linux/i2c.h>
-#include <linux/irq.h>
-#include <linux/clk.h>
-#include <linux/clkdev.h>
-#include <mach/fpga.h>
-#include <mach/irq.h>
-#include <asm/machvec.h>
-#include <asm/heartbeat.h>
-#include <linux/sizes.h>
-#include <asm/clock.h>
-#include <asm/reboot.h>
-#include <asm/smp-ops.h>
-
-static struct resource heartbeat_resource = {
-	.start		= 0x07fff8b0,
-	.end		= 0x07fff8b0 + sizeof(u16) - 1,
-	.flags		= IORESOURCE_MEM | IORESOURCE_MEM_16BIT,
-};
-
-static struct platform_device heartbeat_device = {
-	.name		= "heartbeat",
-	.id		= -1,
-	.num_resources	= 1,
-	.resource	= &heartbeat_resource,
-};
-
-/* Dummy supplies, where voltage doesn't matter */
-static struct regulator_consumer_supply dummy_supplies[] = {
-	REGULATOR_SUPPLY("vddvario", "smsc911x"),
-	REGULATOR_SUPPLY("vdd33a", "smsc911x"),
-};
-
-static struct resource smsc911x_resources[] = {
-	[0] = {
-		.name		= "smsc911x-memory",
-		.start		= 0x07ffff00,
-		.end		= 0x07ffff00 + SZ_256 - 1,
-		.flags		= IORESOURCE_MEM,
-	},
-	[1] = {
-		.name		= "smsc911x-irq",
-		.start		= evt2irq(0x2c0),
-		.end		= evt2irq(0x2c0),
-		.flags		= IORESOURCE_IRQ,
-	},
-};
-
-static struct smsc911x_platform_config smsc911x_config = {
-	.irq_polarity	= SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
-	.irq_type	= SMSC911X_IRQ_TYPE_OPEN_DRAIN,
-	.flags		= SMSC911X_USE_32BIT,
-	.phy_interface	= PHY_INTERFACE_MODE_MII,
-};
-
-static struct platform_device smsc911x_device = {
-	.name		= "smsc911x",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(smsc911x_resources),
-	.resource	= smsc911x_resources,
-	.dev = {
-		.platform_data = &smsc911x_config,
-	},
-};
-
-static struct resource smbus_fpga_resource = {
-	.start		= 0x07fff9e0,
-	.end		= 0x07fff9e0 + SZ_32 - 1,
-	.flags		= IORESOURCE_MEM,
-};
-
-static struct platform_device smbus_fpga_device = {
-	.name		= "i2c-sdk7786",
-	.id		= 0,
-	.num_resources	= 1,
-	.resource	= &smbus_fpga_resource,
-};
-
-static struct resource smbus_pcie_resource = {
-	.start		= 0x07fffc30,
-	.end		= 0x07fffc30 + SZ_32 - 1,
-	.flags		= IORESOURCE_MEM,
-};
-
-static struct platform_device smbus_pcie_device = {
-	.name		= "i2c-sdk7786",
-	.id		= 1,
-	.num_resources	= 1,
-	.resource	= &smbus_pcie_resource,
-};
-
-static struct i2c_board_info __initdata sdk7786_i2c_devices[] = {
-	{
-		I2C_BOARD_INFO("max6900", 0x68),
-	},
-};
-
-static struct platform_device *sh7786_devices[] __initdata = {
-	&heartbeat_device,
-	&smsc911x_device,
-	&smbus_fpga_device,
-	&smbus_pcie_device,
-};
-
-static int sdk7786_i2c_setup(void)
-{
-	unsigned int tmp;
-
-	/*
-	 * Hand over I2C control to the FPGA.
-	 */
-	tmp = fpga_read_reg(SBCR);
-	tmp &= ~SCBR_I2CCEN;
-	tmp |= SCBR_I2CMEN;
-	fpga_write_reg(tmp, SBCR);
-
-	return i2c_register_board_info(0, sdk7786_i2c_devices,
-				       ARRAY_SIZE(sdk7786_i2c_devices));
-}
-
-static int __init sdk7786_devices_setup(void)
-{
-	int ret;
-
-	ret = platform_add_devices(sh7786_devices, ARRAY_SIZE(sh7786_devices));
-	if (unlikely(ret != 0))
-		return ret;
-
-	return sdk7786_i2c_setup();
-}
-device_initcall(sdk7786_devices_setup);
-
-static int sdk7786_mode_pins(void)
-{
-	return fpga_read_reg(MODSWR);
-}
-
-/*
- * FPGA-driven PCIe clocks
- *
- * Historically these include the oscillator, clock B (slots 2/3/4) and
- * clock A (slot 1 and the CPU clock). Newer revs of the PCB shove
- * everything under a single PCIe clocks enable bit that happens to map
- * to the same bit position as the oscillator bit for earlier FPGA
- * versions.
- *
- * Given that the legacy clocks have the side-effect of shutting the CPU
- * off through the FPGA along with the PCI slots, we simply leave them in
- * their initial state and don't bother registering them with the clock
- * framework.
- */
-static int sdk7786_pcie_clk_enable(struct clk *clk)
-{
-	fpga_write_reg(fpga_read_reg(PCIECR) | PCIECR_CLKEN, PCIECR);
-	return 0;
-}
-
-static void sdk7786_pcie_clk_disable(struct clk *clk)
-{
-	fpga_write_reg(fpga_read_reg(PCIECR) & ~PCIECR_CLKEN, PCIECR);
-}
-
-static struct sh_clk_ops sdk7786_pcie_clk_ops = {
-	.enable		= sdk7786_pcie_clk_enable,
-	.disable	= sdk7786_pcie_clk_disable,
-};
-
-static struct clk sdk7786_pcie_clk = {
-	.ops		= &sdk7786_pcie_clk_ops,
-};
-
-static struct clk_lookup sdk7786_pcie_cl = {
-	.con_id		= "pcie_plat_clk",
-	.clk		= &sdk7786_pcie_clk,
-};
-
-static int sdk7786_clk_init(void)
-{
-	struct clk *clk;
-	int ret;
-
-	/*
-	 * Only handle the EXTAL case, anyone interfacing a crystal
-	 * resonator will need to provide their own input clock.
-	 */
-	if (test_mode_pin(MODE_PIN9))
-		return -EINVAL;
-
-	clk = clk_get(NULL, "extal");
-	if (IS_ERR(clk))
-		return PTR_ERR(clk);
-	ret = clk_set_rate(clk, 33333333);
-	clk_put(clk);
-
-	/*
-	 * Setup the FPGA clocks.
-	 */
-	ret = clk_register(&sdk7786_pcie_clk);
-	if (unlikely(ret)) {
-		pr_err("FPGA clock registration failed\n");
-		return ret;
-	}
-
-	clkdev_add(&sdk7786_pcie_cl);
-
-	return 0;
-}
-
-static void sdk7786_restart(char *cmd)
-{
-	fpga_write_reg(0xa5a5, SRSTR);
-}
-
-static void sdk7786_power_off(void)
-{
-	fpga_write_reg(fpga_read_reg(PWRCR) | PWRCR_PDWNREQ, PWRCR);
-
-	/*
-	 * It can take up to 20us for the R8C to do its job, back off and
-	 * wait a bit until we've been shut off. Even though newer FPGA
-	 * versions don't set the ACK bit, the latency issue remains.
-	 */
-	while ((fpga_read_reg(PWRCR) & PWRCR_PDWNACK) == 0)
-		cpu_sleep();
-}
-
-/* Initialize the board */
-static void __init sdk7786_setup(char **cmdline_p)
-{
-	pr_info("Renesas Technology Europe SDK7786 support:\n");
-
-	regulator_register_fixed(0, dummy_supplies, ARRAY_SIZE(dummy_supplies));
-
-	sdk7786_fpga_init();
-	sdk7786_nmi_init();
-
-	pr_info("\tPCB revision:\t%d\n", fpga_read_reg(PCBRR) & 0xf);
-
-	machine_ops.restart = sdk7786_restart;
-	pm_power_off = sdk7786_power_off;
-
-	register_smp_ops(&shx3_smp_ops);
-}
-
-/*
- * The Machine Vector
- */
-static struct sh_machine_vector mv_sdk7786 __initmv = {
-	.mv_name		= "SDK7786",
-	.mv_setup		= sdk7786_setup,
-	.mv_mode_pins		= sdk7786_mode_pins,
-	.mv_clk_init		= sdk7786_clk_init,
-	.mv_init_irq		= sdk7786_init_irq,
-};
diff --git a/arch/sh/boards/mach-sdk7786/sram.c b/arch/sh/boards/mach-sdk7786/sram.c
deleted file mode 100644
index 7c6ca976f332fe..00000000000000
--- a/arch/sh/boards/mach-sdk7786/sram.c
+++ /dev/null
@@ -1,69 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SDK7786 FPGA SRAM Support.
- *
- * Copyright (C) 2010  Paul Mundt
- */
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/io.h>
-#include <linux/string.h>
-#include <mach/fpga.h>
-#include <asm/sram.h>
-#include <linux/sizes.h>
-
-static int __init fpga_sram_init(void)
-{
-	unsigned long phys;
-	unsigned int area;
-	void __iomem *vaddr;
-	int ret;
-	u16 data;
-
-	/* Enable FPGA SRAM */
-	data = fpga_read_reg(LCLASR);
-	data |= LCLASR_FRAMEN;
-	fpga_write_reg(data, LCLASR);
-
-	/*
-	 * FPGA_SEL determines the area mapping
-	 */
-	area = (data & LCLASR_FPGA_SEL_MASK) >> LCLASR_FPGA_SEL_SHIFT;
-	if (unlikely(area == LCLASR_AREA_MASK)) {
-		pr_err("FPGA memory unmapped.\n");
-		return -ENXIO;
-	}
-
-	/*
-	 * The memory itself occupies a 2KiB range at the top of the area
-	 * immediately below the system registers.
-	 */
-	phys = (area << 26) + SZ_64M - SZ_4K;
-
-	/*
-	 * The FPGA SRAM resides in translatable physical space, so set
-	 * up a mapping prior to inserting it in to the pool.
-	 */
-	vaddr = ioremap(phys, SZ_2K);
-	if (unlikely(!vaddr)) {
-		pr_err("Failed remapping FPGA memory.\n");
-		return -ENXIO;
-	}
-
-	pr_info("Adding %dKiB of FPGA memory at 0x%08lx-0x%08lx "
-		"(area %d) to pool.\n",
-		SZ_2K >> 10, phys, phys + SZ_2K - 1, area);
-
-	ret = gen_pool_add(sram_pool, (unsigned long)vaddr, SZ_2K, -1);
-	if (unlikely(ret < 0)) {
-		pr_err("Failed adding memory\n");
-		iounmap(vaddr);
-		return ret;
-	}
-
-	return 0;
-}
-postcore_initcall(fpga_sram_init);
diff --git a/arch/sh/boards/mach-se/7206/Makefile b/arch/sh/boards/mach-se/7206/Makefile
deleted file mode 100644
index b40b30853ce376..00000000000000
--- a/arch/sh/boards/mach-se/7206/Makefile
+++ /dev/null
@@ -1,6 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the 7206 SolutionEngine specific parts of the kernel
-#
-
-obj-y	 := setup.o irq.o
diff --git a/arch/sh/boards/mach-se/7206/irq.c b/arch/sh/boards/mach-se/7206/irq.c
deleted file mode 100644
index 2b15370829aef3..00000000000000
--- a/arch/sh/boards/mach-se/7206/irq.c
+++ /dev/null
@@ -1,151 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/se/7206/irq.c
- *
- * Copyright (C) 2005,2006 Yoshinori Sato
- *
- * Hitachi SolutionEngine Support.
- *
- */
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/io.h>
-#include <linux/interrupt.h>
-#include <mach-se/mach/se7206.h>
-
-#define INTSTS0 0x31800000
-#define INTSTS1 0x31800002
-#define INTMSK0 0x31800004
-#define INTMSK1 0x31800006
-#define INTSEL  0x31800008
-
-#define IRQ0_IRQ 64
-#define IRQ1_IRQ 65
-#define IRQ3_IRQ 67
-
-#define INTC_IPR01 0xfffe0818
-#define INTC_ICR1  0xfffe0802
-
-static void disable_se7206_irq(struct irq_data *data)
-{
-	unsigned int irq = data->irq;
-	unsigned short val;
-	unsigned short mask = 0xffff ^ (0x0f << 4 * (3 - (IRQ0_IRQ - irq)));
-	unsigned short msk0,msk1;
-
-	/* Set the priority in IPR to 0 */
-	val = __raw_readw(INTC_IPR01);
-	val &= mask;
-	__raw_writew(val, INTC_IPR01);
-	/* FPGA mask set */
-	msk0 = __raw_readw(INTMSK0);
-	msk1 = __raw_readw(INTMSK1);
-
-	switch (irq) {
-	case IRQ0_IRQ:
-		msk0 |= 0x0010;
-		break;
-	case IRQ1_IRQ:
-		msk0 |= 0x000f;
-		break;
-	case IRQ3_IRQ:
-		msk0 |= 0x0f00;
-		msk1 |= 0x00ff;
-		break;
-	}
-	__raw_writew(msk0, INTMSK0);
-	__raw_writew(msk1, INTMSK1);
-}
-
-static void enable_se7206_irq(struct irq_data *data)
-{
-	unsigned int irq = data->irq;
-	unsigned short val;
-	unsigned short value = (0x0001 << 4 * (3 - (IRQ0_IRQ - irq)));
-	unsigned short msk0,msk1;
-
-	/* Set priority in IPR back to original value */
-	val = __raw_readw(INTC_IPR01);
-	val |= value;
-	__raw_writew(val, INTC_IPR01);
-
-	/* FPGA mask reset */
-	msk0 = __raw_readw(INTMSK0);
-	msk1 = __raw_readw(INTMSK1);
-
-	switch (irq) {
-	case IRQ0_IRQ:
-		msk0 &= ~0x0010;
-		break;
-	case IRQ1_IRQ:
-		msk0 &= ~0x000f;
-		break;
-	case IRQ3_IRQ:
-		msk0 &= ~0x0f00;
-		msk1 &= ~0x00ff;
-		break;
-	}
-	__raw_writew(msk0, INTMSK0);
-	__raw_writew(msk1, INTMSK1);
-}
-
-static void eoi_se7206_irq(struct irq_data *data)
-{
-	unsigned short sts0,sts1;
-	unsigned int irq = data->irq;
-
-	if (!irqd_irq_disabled(data) && !irqd_irq_inprogress(data))
-		enable_se7206_irq(data);
-	/* FPGA isr clear */
-	sts0 = __raw_readw(INTSTS0);
-	sts1 = __raw_readw(INTSTS1);
-
-	switch (irq) {
-	case IRQ0_IRQ:
-		sts0 &= ~0x0010;
-		break;
-	case IRQ1_IRQ:
-		sts0 &= ~0x000f;
-		break;
-	case IRQ3_IRQ:
-		sts0 &= ~0x0f00;
-		sts1 &= ~0x00ff;
-		break;
-	}
-	__raw_writew(sts0, INTSTS0);
-	__raw_writew(sts1, INTSTS1);
-}
-
-static struct irq_chip se7206_irq_chip __read_mostly = {
-	.name		= "SE7206-FPGA",
-	.irq_mask	= disable_se7206_irq,
-	.irq_unmask	= enable_se7206_irq,
-	.irq_eoi	= eoi_se7206_irq,
-};
-
-static void make_se7206_irq(unsigned int irq)
-{
-	disable_irq_nosync(irq);
-	irq_set_chip_and_handler_name(irq, &se7206_irq_chip,
-				      handle_level_irq, "level");
-	disable_se7206_irq(irq_get_irq_data(irq));
-}
-
-/*
- * Initialize IRQ setting
- */
-void __init init_se7206_IRQ(void)
-{
-	make_se7206_irq(IRQ0_IRQ); /* SMC91C111 */
-	make_se7206_irq(IRQ1_IRQ); /* ATA */
-	make_se7206_irq(IRQ3_IRQ); /* SLOT / PCM */
-
-	__raw_writew(__raw_readw(INTC_ICR1) | 0x000b, INTC_ICR1); /* ICR1 */
-
-	/* FPGA System register setup*/
-	__raw_writew(0x0000,INTSTS0); /* Clear INTSTS0 */
-	__raw_writew(0x0000,INTSTS1); /* Clear INTSTS1 */
-
-	/* IRQ0=LAN, IRQ1=ATA, IRQ3=SLT,PCM */
-	__raw_writew(0x0001,INTSEL);
-}
diff --git a/arch/sh/boards/mach-se/7206/setup.c b/arch/sh/boards/mach-se/7206/setup.c
deleted file mode 100644
index dc55d3a69665ee..00000000000000
--- a/arch/sh/boards/mach-se/7206/setup.c
+++ /dev/null
@@ -1,96 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- *
- * linux/arch/sh/boards/se/7206/setup.c
- *
- * Copyright (C) 2006  Yoshinori Sato
- * Copyright (C) 2007 - 2008  Paul Mundt
- *
- * Hitachi 7206 SolutionEngine Support.
- */
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/smc91x.h>
-#include <mach-se/mach/se7206.h>
-#include <asm/io.h>
-#include <asm/machvec.h>
-#include <asm/heartbeat.h>
-
-static struct resource smc91x_resources[] = {
-	[0] = {
-		.name		= "smc91x-regs",
-		.start		= PA_SMSC + 0x300,
-		.end		= PA_SMSC + 0x300 + 0x020 - 1,
-		.flags		= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start		= 64,
-		.end		= 64,
-		.flags		= IORESOURCE_IRQ,
-	},
-};
-
-static struct smc91x_platdata smc91x_info = {
-	.flags	= SMC91X_USE_16BIT,
-};
-
-static struct platform_device smc91x_device = {
-	.name		= "smc91x",
-	.id		= -1,
-	.dev		= {
-		.dma_mask		= NULL,
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &smc91x_info,
-	},
-	.num_resources	= ARRAY_SIZE(smc91x_resources),
-	.resource	= smc91x_resources,
-};
-
-static unsigned char heartbeat_bit_pos[] = { 8, 9, 10, 11, 12, 13, 14, 15 };
-
-static struct heartbeat_data heartbeat_data = {
-	.bit_pos	= heartbeat_bit_pos,
-	.nr_bits	= ARRAY_SIZE(heartbeat_bit_pos),
-};
-
-static struct resource heartbeat_resource = {
-	.start	= PA_LED,
-	.end	= PA_LED,
-	.flags	= IORESOURCE_MEM | IORESOURCE_MEM_32BIT,
-};
-
-static struct platform_device heartbeat_device = {
-	.name		= "heartbeat",
-	.id		= -1,
-	.dev	= {
-		.platform_data	= &heartbeat_data,
-	},
-	.num_resources	= 1,
-	.resource	= &heartbeat_resource,
-};
-
-static struct platform_device *se7206_devices[] __initdata = {
-	&smc91x_device,
-	&heartbeat_device,
-};
-
-static int __init se7206_devices_setup(void)
-{
-	return platform_add_devices(se7206_devices, ARRAY_SIZE(se7206_devices));
-}
-device_initcall(se7206_devices_setup);
-
-static int se7206_mode_pins(void)
-{
-	return MODE_PIN1 | MODE_PIN2;
-}
-
-/*
- * The Machine Vector
- */
-
-static struct sh_machine_vector mv_se __initmv = {
-	.mv_name		= "SolutionEngine",
-	.mv_init_irq		= init_se7206_IRQ,
-	.mv_mode_pins		= se7206_mode_pins,
-};
diff --git a/arch/sh/boards/mach-se/7343/Makefile b/arch/sh/boards/mach-se/7343/Makefile
deleted file mode 100644
index e058661091a26f..00000000000000
--- a/arch/sh/boards/mach-se/7343/Makefile
+++ /dev/null
@@ -1,6 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the 7343 SolutionEngine specific parts of the kernel
-#
-
-obj-y	 := setup.o irq.o
diff --git a/arch/sh/boards/mach-se/7343/irq.c b/arch/sh/boards/mach-se/7343/irq.c
deleted file mode 100644
index f9f3b14f70d574..00000000000000
--- a/arch/sh/boards/mach-se/7343/irq.c
+++ /dev/null
@@ -1,123 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Hitachi UL SolutionEngine 7343 FPGA IRQ Support.
- *
- * Copyright (C) 2008  Yoshihiro Shimoda
- * Copyright (C) 2012  Paul Mundt
- *
- * Based on linux/arch/sh/boards/se/7343/irq.c
- * Copyright (C) 2007  Nobuhiro Iwamatsu
- */
-#define DRV_NAME "SE7343-FPGA"
-#define pr_fmt(fmt) DRV_NAME ": " fmt
-
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <linux/irqdomain.h>
-#include <linux/io.h>
-#include <linux/sizes.h>
-#include <mach-se/mach/se7343.h>
-
-#define PA_CPLD_BASE_ADDR	0x11400000
-#define PA_CPLD_ST_REG		0x08	/* CPLD Interrupt status register */
-#define PA_CPLD_IMSK_REG	0x0a	/* CPLD Interrupt mask register */
-
-static void __iomem *se7343_irq_regs;
-struct irq_domain *se7343_irq_domain;
-
-static void se7343_irq_demux(struct irq_desc *desc)
-{
-	struct irq_data *data = irq_desc_get_irq_data(desc);
-	struct irq_chip *chip = irq_data_get_irq_chip(data);
-	unsigned long mask;
-	int bit;
-
-	chip->irq_mask_ack(data);
-
-	mask = ioread16(se7343_irq_regs + PA_CPLD_ST_REG);
-
-	for_each_set_bit(bit, &mask, SE7343_FPGA_IRQ_NR)
-		generic_handle_domain_irq(se7343_irq_domain, bit);
-
-	chip->irq_unmask(data);
-}
-
-static void __init se7343_domain_init(void)
-{
-	int i;
-
-	se7343_irq_domain = irq_domain_add_linear(NULL, SE7343_FPGA_IRQ_NR,
-						  &irq_domain_simple_ops, NULL);
-	if (unlikely(!se7343_irq_domain)) {
-		printk("Failed to get IRQ domain\n");
-		return;
-	}
-
-	for (i = 0; i < SE7343_FPGA_IRQ_NR; i++) {
-		int irq = irq_create_mapping(se7343_irq_domain, i);
-
-		if (unlikely(irq == 0)) {
-			printk("Failed to allocate IRQ %d\n", i);
-			return;
-		}
-	}
-}
-
-static void __init se7343_gc_init(void)
-{
-	struct irq_chip_generic *gc;
-	struct irq_chip_type *ct;
-	unsigned int irq_base;
-
-	irq_base = irq_linear_revmap(se7343_irq_domain, 0);
-
-	gc = irq_alloc_generic_chip(DRV_NAME, 1, irq_base, se7343_irq_regs,
-				    handle_level_irq);
-	if (unlikely(!gc))
-		return;
-
-	ct = gc->chip_types;
-	ct->chip.irq_mask = irq_gc_mask_set_bit;
-	ct->chip.irq_unmask = irq_gc_mask_clr_bit;
-
-	ct->regs.mask = PA_CPLD_IMSK_REG;
-
-	irq_setup_generic_chip(gc, IRQ_MSK(SE7343_FPGA_IRQ_NR),
-			       IRQ_GC_INIT_MASK_CACHE,
-			       IRQ_NOREQUEST | IRQ_NOPROBE, 0);
-
-	irq_set_chained_handler(IRQ0_IRQ, se7343_irq_demux);
-	irq_set_irq_type(IRQ0_IRQ, IRQ_TYPE_LEVEL_LOW);
-
-	irq_set_chained_handler(IRQ1_IRQ, se7343_irq_demux);
-	irq_set_irq_type(IRQ1_IRQ, IRQ_TYPE_LEVEL_LOW);
-
-	irq_set_chained_handler(IRQ4_IRQ, se7343_irq_demux);
-	irq_set_irq_type(IRQ4_IRQ, IRQ_TYPE_LEVEL_LOW);
-
-	irq_set_chained_handler(IRQ5_IRQ, se7343_irq_demux);
-	irq_set_irq_type(IRQ5_IRQ, IRQ_TYPE_LEVEL_LOW);
-}
-
-/*
- * Initialize IRQ setting
- */
-void __init init_7343se_IRQ(void)
-{
-	se7343_irq_regs = ioremap(PA_CPLD_BASE_ADDR, SZ_16);
-	if (unlikely(!se7343_irq_regs)) {
-		pr_err("Failed to remap CPLD\n");
-		return;
-	}
-
-	/*
-	 * All FPGA IRQs disabled by default
-	 */
-	iowrite16(0, se7343_irq_regs + PA_CPLD_IMSK_REG);
-
-	__raw_writew(0x2000, 0xb03fffec);	/* mrshpc irq enable */
-
-	se7343_domain_init();
-	se7343_gc_init();
-}
diff --git a/arch/sh/boards/mach-se/7343/setup.c b/arch/sh/boards/mach-se/7343/setup.c
deleted file mode 100644
index fe0e550601a2e2..00000000000000
--- a/arch/sh/boards/mach-se/7343/setup.c
+++ /dev/null
@@ -1,182 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/mtd/physmap.h>
-#include <linux/serial_8250.h>
-#include <linux/serial_reg.h>
-#include <linux/usb/isp116x.h>
-#include <linux/delay.h>
-#include <linux/irqdomain.h>
-#include <asm/machvec.h>
-#include <mach-se/mach/se7343.h>
-#include <asm/heartbeat.h>
-#include <asm/irq.h>
-#include <asm/io.h>
-
-static struct resource heartbeat_resource = {
-	.start	= PA_LED,
-	.end	= PA_LED,
-	.flags	= IORESOURCE_MEM | IORESOURCE_MEM_16BIT,
-};
-
-static struct platform_device heartbeat_device = {
-	.name		= "heartbeat",
-	.id		= -1,
-	.num_resources	= 1,
-	.resource	= &heartbeat_resource,
-};
-
-static struct mtd_partition nor_flash_partitions[] = {
-	{
-		.name		= "loader",
-		.offset		= 0x00000000,
-		.size		= 128 * 1024,
-	},
-	{
-		.name		= "rootfs",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= 31 * 1024 * 1024,
-	},
-	{
-		.name		= "data",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= MTDPART_SIZ_FULL,
-	},
-};
-
-static struct physmap_flash_data nor_flash_data = {
-	.width		= 2,
-	.parts		= nor_flash_partitions,
-	.nr_parts	= ARRAY_SIZE(nor_flash_partitions),
-};
-
-static struct resource nor_flash_resources[] = {
-	[0]	= {
-		.start	= 0x00000000,
-		.end	= 0x01ffffff,
-		.flags	= IORESOURCE_MEM,
-	}
-};
-
-static struct platform_device nor_flash_device = {
-	.name		= "physmap-flash",
-	.dev		= {
-		.platform_data	= &nor_flash_data,
-	},
-	.num_resources	= ARRAY_SIZE(nor_flash_resources),
-	.resource	= nor_flash_resources,
-};
-
-#define ST16C2550C_FLAGS (UPF_BOOT_AUTOCONF | UPF_IOREMAP)
-
-static struct plat_serial8250_port serial_platform_data[] = {
-	[0] = {
-		.iotype		= UPIO_MEM,
-		.mapbase	= 0x16000000,
-		.regshift	= 1,
-		.flags		= ST16C2550C_FLAGS,
-		.uartclk	= 7372800,
-	},
-	[1] = {
-		.iotype		= UPIO_MEM,
-		.mapbase	= 0x17000000,
-		.regshift	= 1,
-		.flags		= ST16C2550C_FLAGS,
-		.uartclk	= 7372800,
-	},
-	{ },
-};
-
-static struct platform_device uart_device = {
-	.name			= "serial8250",
-	.id			= PLAT8250_DEV_PLATFORM,
-	.dev			= {
-		.platform_data	= serial_platform_data,
-	},
-};
-
-static void isp116x_delay(struct device *dev, int delay)
-{
-	ndelay(delay);
-}
-
-static struct resource usb_resources[] = {
-	[0] = {
-		.start  = 0x11800000,
-		.end    = 0x11800001,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = 0x11800002,
-		.end    = 0x11800003,
-		.flags  = IORESOURCE_MEM,
-	},
-	[2] = {
-		/* Filled in later */
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct isp116x_platform_data usb_platform_data = {
-	.sel15Kres		= 1,
-	.oc_enable		= 1,
-	.int_act_high		= 0,
-	.int_edge_triggered	= 0,
-	.remote_wakeup_enable	= 0,
-	.delay			= isp116x_delay,
-};
-
-static struct platform_device usb_device = {
-	.name			= "isp116x-hcd",
-	.id			= -1,
-	.num_resources		= ARRAY_SIZE(usb_resources),
-	.resource		= usb_resources,
-	.dev			= {
-		.platform_data	= &usb_platform_data,
-	},
-
-};
-
-static struct platform_device *sh7343se_platform_devices[] __initdata = {
-	&heartbeat_device,
-	&nor_flash_device,
-	&uart_device,
-	&usb_device,
-};
-
-static int __init sh7343se_devices_setup(void)
-{
-	/* Wire-up dynamic vectors */
-	serial_platform_data[0].irq = irq_find_mapping(se7343_irq_domain,
-						       SE7343_FPGA_IRQ_UARTA);
-	serial_platform_data[1].irq = irq_find_mapping(se7343_irq_domain,
-						       SE7343_FPGA_IRQ_UARTB);
-	usb_resources[2].start = usb_resources[2].end =
-		irq_find_mapping(se7343_irq_domain, SE7343_FPGA_IRQ_USB);
-
-	return platform_add_devices(sh7343se_platform_devices,
-				    ARRAY_SIZE(sh7343se_platform_devices));
-}
-device_initcall(sh7343se_devices_setup);
-
-/*
- * Initialize the board
- */
-static void __init sh7343se_setup(char **cmdline_p)
-{
-	__raw_writew(0xf900, FPGA_OUT);	/* FPGA */
-
-	__raw_writew(0x0002, PORT_PECR);	/* PORT E 1 = IRQ5 */
-	__raw_writew(0x0020, PORT_PSELD);
-
-	printk(KERN_INFO "MS7343CP01 Setup...done\n");
-}
-
-/*
- * The Machine Vector
- */
-static struct sh_machine_vector mv_7343se __initmv = {
-	.mv_name = "SolutionEngine 7343",
-	.mv_setup = sh7343se_setup,
-	.mv_init_irq = init_7343se_IRQ,
-};
diff --git a/arch/sh/boards/mach-se/770x/Makefile b/arch/sh/boards/mach-se/770x/Makefile
deleted file mode 100644
index 900d93cfb6a531..00000000000000
--- a/arch/sh/boards/mach-se/770x/Makefile
+++ /dev/null
@@ -1,6 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the 770x SolutionEngine specific parts of the kernel
-#
-
-obj-y	 := setup.o irq.o
diff --git a/arch/sh/boards/mach-se/770x/irq.c b/arch/sh/boards/mach-se/770x/irq.c
deleted file mode 100644
index 66e2c8aa0b69f3..00000000000000
--- a/arch/sh/boards/mach-se/770x/irq.c
+++ /dev/null
@@ -1,109 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/se/770x/irq.c
- *
- * Copyright (C) 2000  Kazumoto Kojima
- * Copyright (C) 2006  Nobuhiro Iwamatsu
- *
- * Hitachi SolutionEngine Support.
- *
- */
-
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <asm/irq.h>
-#include <asm/io.h>
-#include <mach-se/mach/se.h>
-
-static struct ipr_data ipr_irq_table[] = {
-	/*
-	* Super I/O (Just mimic PC):
-	*  1: keyboard
-	*  3: serial 0
-	*  4: serial 1
-	*  5: printer
-	*  6: floppy
-	*  8: rtc
-	* 12: mouse
-	* 14: ide0
-	*/
-#if defined(CONFIG_CPU_SUBTYPE_SH7705)
-	/* This is default value */
-	{ 13, 0, 8,  0x0f-13, },
-	{ 5 , 0, 4,  0x0f- 5, },
-	{ 10, 1, 0,  0x0f-10, },
-	{ 7 , 2, 4,  0x0f- 7, },
-	{ 3 , 2, 0,  0x0f- 3, },
-	{ 1 , 3, 12, 0x0f- 1, },
-	{ 12, 3, 4,  0x0f-12, }, /* LAN */
-	{ 2 , 4, 8,  0x0f- 2, }, /* PCIRQ2 */
-	{ 6 , 4, 4,  0x0f- 6, }, /* PCIRQ1 */
-	{ 14, 4, 0,  0x0f-14, }, /* PCIRQ0 */
-	{ 0 , 5, 12, 0x0f   , }, 
-	{ 4 , 5, 4,  0x0f- 4, },
-	{ 8 , 6, 12, 0x0f- 8, },
-	{ 9 , 6, 8,  0x0f- 9, },
-	{ 11, 6, 4,  0x0f-11, },
-#else
-	{ 14, 0,  8, 0x0f-14, },
-	{ 12, 0,  4, 0x0f-12, },
-	{  8, 1,  4, 0x0f- 8, },
-	{  6, 2, 12, 0x0f- 6, },
-	{  5, 2,  8, 0x0f- 5, },
-	{  4, 2,  4, 0x0f- 4, },
-	{  3, 2,  0, 0x0f- 3, },
-	{  1, 3, 12, 0x0f- 1, },
-#if defined(CONFIG_STNIC)
-	/* ST NIC */
-	{ 10, 3,  4, 0x0f-10, }, 	/* LAN */
-#endif
-	/* MRSHPC IRQs setting */
-	{  0, 4, 12, 0x0f- 0, },	/* PCIRQ3 */
-	{ 11, 4,  8, 0x0f-11, }, 	/* PCIRQ2 */
-	{  9, 4,  4, 0x0f- 9, }, 	/* PCIRQ1 */
-	{  7, 4,  0, 0x0f- 7, }, 	/* PCIRQ0 */
-	/* #2, #13 are allocated for SLOT IRQ #1 and #2 (for now) */
-	/* NOTE: #2 and #13 are not used on PC */
-	{ 13, 6,  4, 0x0f-13, }, 	/* SLOTIRQ2 */
-	{  2, 6,  0, 0x0f- 2, }, 	/* SLOTIRQ1 */
-#endif
-};
-
-static unsigned long ipr_offsets[] = {
-	BCR_ILCRA,
-	BCR_ILCRB,
-	BCR_ILCRC,
-	BCR_ILCRD,
-	BCR_ILCRE,
-	BCR_ILCRF,
-	BCR_ILCRG,
-};
-
-static struct ipr_desc ipr_irq_desc = {
-	.ipr_offsets	= ipr_offsets,
-	.nr_offsets	= ARRAY_SIZE(ipr_offsets),
-
-	.ipr_data	= ipr_irq_table,
-	.nr_irqs	= ARRAY_SIZE(ipr_irq_table),
-	.chip = {
-		.name	= "IPR-se770x",
-	},
-};
-
-/*
- * Initialize IRQ setting
- */
-void __init init_se_IRQ(void)
-{
-	/* Disable all interrupts */
-	__raw_writew(0, BCR_ILCRA);
-	__raw_writew(0, BCR_ILCRB);
-	__raw_writew(0, BCR_ILCRC);
-	__raw_writew(0, BCR_ILCRD);
-	__raw_writew(0, BCR_ILCRE);
-	__raw_writew(0, BCR_ILCRF);
-	__raw_writew(0, BCR_ILCRG);
-
-	register_ipr_controller(&ipr_irq_desc);
-}
diff --git a/arch/sh/boards/mach-se/770x/setup.c b/arch/sh/boards/mach-se/770x/setup.c
deleted file mode 100644
index 412326d59e6fce..00000000000000
--- a/arch/sh/boards/mach-se/770x/setup.c
+++ /dev/null
@@ -1,205 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/se/770x/setup.c
- *
- * Copyright (C) 2000  Kazumoto Kojima
- *
- * Hitachi SolutionEngine Support.
- *
- */
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/sh_eth.h>
-#include <mach-se/mach/se.h>
-#include <mach-se/mach/mrshpc.h>
-#include <asm/machvec.h>
-#include <asm/io.h>
-#include <asm/smc37c93x.h>
-#include <asm/heartbeat.h>
-
-/*
- * Configure the Super I/O chip
- */
-static void __init smsc_config(int index, int data)
-{
-	outb_p(index, INDEX_PORT);
-	outb_p(data, DATA_PORT);
-}
-
-/* XXX: Another candidate for a more generic cchip machine vector */
-static void __init smsc_setup(char **cmdline_p)
-{
-	outb_p(CONFIG_ENTER, CONFIG_PORT);
-	outb_p(CONFIG_ENTER, CONFIG_PORT);
-
-	/* FDC */
-	smsc_config(CURRENT_LDN_INDEX, LDN_FDC);
-	smsc_config(ACTIVATE_INDEX, 0x01);
-	smsc_config(IRQ_SELECT_INDEX, 6); /* IRQ6 */
-
-	/* AUXIO (GPIO): to use IDE1 */
-	smsc_config(CURRENT_LDN_INDEX, LDN_AUXIO);
-	smsc_config(GPIO46_INDEX, 0x00); /* nIOROP */
-	smsc_config(GPIO47_INDEX, 0x00); /* nIOWOP */
-
-	/* COM1 */
-	smsc_config(CURRENT_LDN_INDEX, LDN_COM1);
-	smsc_config(ACTIVATE_INDEX, 0x01);
-	smsc_config(IO_BASE_HI_INDEX, 0x03);
-	smsc_config(IO_BASE_LO_INDEX, 0xf8);
-	smsc_config(IRQ_SELECT_INDEX, 4); /* IRQ4 */
-
-	/* COM2 */
-	smsc_config(CURRENT_LDN_INDEX, LDN_COM2);
-	smsc_config(ACTIVATE_INDEX, 0x01);
-	smsc_config(IO_BASE_HI_INDEX, 0x02);
-	smsc_config(IO_BASE_LO_INDEX, 0xf8);
-	smsc_config(IRQ_SELECT_INDEX, 3); /* IRQ3 */
-
-	/* RTC */
-	smsc_config(CURRENT_LDN_INDEX, LDN_RTC);
-	smsc_config(ACTIVATE_INDEX, 0x01);
-	smsc_config(IRQ_SELECT_INDEX, 8); /* IRQ8 */
-
-	/* XXX: PARPORT, KBD, and MOUSE will come here... */
-	outb_p(CONFIG_EXIT, CONFIG_PORT);
-}
-
-
-static struct resource cf_ide_resources[] = {
-	[0] = {
-		.start  = PA_MRSHPC_IO + 0x1f0,
-		.end    = PA_MRSHPC_IO + 0x1f0 + 8,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = PA_MRSHPC_IO + 0x1f0 + 0x206,
-		.end    = PA_MRSHPC_IO + 0x1f0 + 8 + 0x206 + 8,
-		.flags  = IORESOURCE_MEM,
-	},
-	[2] = {
-		.start  = IRQ_CFCARD,
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device cf_ide_device  = {
-	.name           = "pata_platform",
-	.id             = -1,
-	.num_resources  = ARRAY_SIZE(cf_ide_resources),
-	.resource       = cf_ide_resources,
-};
-
-static unsigned char heartbeat_bit_pos[] = { 8, 9, 10, 11, 12, 13, 14, 15 };
-
-static struct heartbeat_data heartbeat_data = {
-	.bit_pos	= heartbeat_bit_pos,
-	.nr_bits	= ARRAY_SIZE(heartbeat_bit_pos),
-};
-
-static struct resource heartbeat_resource = {
-	.start	= PA_LED,
-	.end	= PA_LED,
-	.flags	= IORESOURCE_MEM | IORESOURCE_MEM_16BIT,
-};
-
-static struct platform_device heartbeat_device = {
-	.name		= "heartbeat",
-	.id		= -1,
-	.dev	= {
-		.platform_data	= &heartbeat_data,
-	},
-	.num_resources	= 1,
-	.resource	= &heartbeat_resource,
-};
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7710) ||\
-	defined(CONFIG_CPU_SUBTYPE_SH7712)
-/* SH771X Ethernet driver */
-static struct sh_eth_plat_data sh_eth_plat = {
-	.phy = PHY_ID,
-	.phy_interface = PHY_INTERFACE_MODE_MII,
-};
-
-static struct resource sh_eth0_resources[] = {
-	[0] = {
-		.start = SH_ETH0_BASE,
-		.end = SH_ETH0_BASE + 0x1B8 - 1,
-		.flags = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start = SH_TSU_BASE,
-		.end = SH_TSU_BASE + 0x200 - 1,
-		.flags = IORESOURCE_MEM,
-	},
-	[2] = {
-		.start = SH_ETH0_IRQ,
-		.end = SH_ETH0_IRQ,
-		.flags = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device sh_eth0_device = {
-	.name = "sh771x-ether",
-	.id = 0,
-	.dev = {
-		.platform_data = &sh_eth_plat,
-	},
-	.num_resources = ARRAY_SIZE(sh_eth0_resources),
-	.resource = sh_eth0_resources,
-};
-
-static struct resource sh_eth1_resources[] = {
-	[0] = {
-		.start = SH_ETH1_BASE,
-		.end = SH_ETH1_BASE + 0x1B8 - 1,
-		.flags = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start = SH_TSU_BASE,
-		.end = SH_TSU_BASE + 0x200 - 1,
-		.flags = IORESOURCE_MEM,
-	},
-	[2] = {
-		.start = SH_ETH1_IRQ,
-		.end = SH_ETH1_IRQ,
-		.flags = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device sh_eth1_device = {
-	.name = "sh771x-ether",
-	.id = 1,
-	.dev = {
-		.platform_data = &sh_eth_plat,
-	},
-	.num_resources = ARRAY_SIZE(sh_eth1_resources),
-	.resource = sh_eth1_resources,
-};
-#endif
-
-static struct platform_device *se_devices[] __initdata = {
-	&heartbeat_device,
-	&cf_ide_device,
-#if defined(CONFIG_CPU_SUBTYPE_SH7710) ||\
-	defined(CONFIG_CPU_SUBTYPE_SH7712)
-	&sh_eth0_device,
-	&sh_eth1_device,
-#endif
-};
-
-static int __init se_devices_setup(void)
-{
-	mrshpc_setup_windows();
-	return platform_add_devices(se_devices, ARRAY_SIZE(se_devices));
-}
-device_initcall(se_devices_setup);
-
-/*
- * The Machine Vector
- */
-static struct sh_machine_vector mv_se __initmv = {
-	.mv_name		= "SolutionEngine",
-	.mv_setup		= smsc_setup,
-	.mv_init_irq		= init_se_IRQ,
-};
diff --git a/arch/sh/boards/mach-se/7721/Makefile b/arch/sh/boards/mach-se/7721/Makefile
deleted file mode 100644
index 09436f10ddf198..00000000000000
--- a/arch/sh/boards/mach-se/7721/Makefile
+++ /dev/null
@@ -1,2 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-obj-y	 := setup.o irq.o
diff --git a/arch/sh/boards/mach-se/7721/irq.c b/arch/sh/boards/mach-se/7721/irq.c
deleted file mode 100644
index e6ef2a2655c37c..00000000000000
--- a/arch/sh/boards/mach-se/7721/irq.c
+++ /dev/null
@@ -1,42 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/se/7721/irq.c
- *
- * Copyright (C) 2008  Renesas Solutions Corp.
- */
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <linux/io.h>
-#include <mach-se/mach/se7721.h>
-
-enum {
-	UNUSED = 0,
-
-	/* board specific interrupt sources */
-	MRSHPC,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_IRQ(MRSHPC, MRSHPC_IRQ0),
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ FPGA_ILSR6, 0, 8, 4, /* IRLMSK */
-	  { 0, MRSHPC } },
-};
-
-static DECLARE_INTC_DESC(intc_desc, "SE7721", vectors,
-			 NULL, NULL, prio_registers, NULL);
-
-/*
- * Initialize IRQ setting
- */
-void __init init_se7721_IRQ(void)
-{
-	/* PPCR */
-	__raw_writew(__raw_readw(0xa4050118) & ~0x00ff, 0xa4050118);
-
-	register_intc_controller(&intc_desc);
-	intc_set_priority(MRSHPC_IRQ0, 0xf - MRSHPC_IRQ0);
-}
diff --git a/arch/sh/boards/mach-se/7721/setup.c b/arch/sh/boards/mach-se/7721/setup.c
deleted file mode 100644
index 3af724dc4ba44a..00000000000000
--- a/arch/sh/boards/mach-se/7721/setup.c
+++ /dev/null
@@ -1,92 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/se/7721/setup.c
- *
- * Copyright (C) 2008 Renesas Solutions Corp.
- *
- * Hitachi UL SolutionEngine 7721 Support.
- */
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <mach-se/mach/se7721.h>
-#include <mach-se/mach/mrshpc.h>
-#include <asm/machvec.h>
-#include <asm/io.h>
-#include <asm/heartbeat.h>
-
-static unsigned char heartbeat_bit_pos[] = { 8, 9, 10, 11, 12, 13, 14, 15 };
-
-static struct heartbeat_data heartbeat_data = {
-	.bit_pos	= heartbeat_bit_pos,
-	.nr_bits	= ARRAY_SIZE(heartbeat_bit_pos),
-};
-
-static struct resource heartbeat_resource = {
-	.start	= PA_LED,
-	.end	= PA_LED,
-	.flags	= IORESOURCE_MEM | IORESOURCE_MEM_16BIT,
-};
-
-static struct platform_device heartbeat_device = {
-	.name		= "heartbeat",
-	.id		= -1,
-	.dev	= {
-		.platform_data	= &heartbeat_data,
-	},
-	.num_resources	= 1,
-	.resource	= &heartbeat_resource,
-};
-
-static struct resource cf_ide_resources[] = {
-	[0] = {
-		.start	= PA_MRSHPC_IO + 0x1f0,
-		.end	= PA_MRSHPC_IO + 0x1f0 + 8 ,
-		.flags	= IORESOURCE_IO,
-	},
-	[1] = {
-		.start	= PA_MRSHPC_IO + 0x1f0 + 0x206,
-		.end	= PA_MRSHPC_IO + 0x1f0 + 8 + 0x206 + 8,
-		.flags	= IORESOURCE_IO,
-	},
-	[2] = {
-		.start  = MRSHPC_IRQ0,
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device cf_ide_device = {
-	.name		= "pata_platform",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(cf_ide_resources),
-	.resource	= cf_ide_resources,
-};
-
-static struct platform_device *se7721_devices[] __initdata = {
-	&cf_ide_device,
-	&heartbeat_device
-};
-
-static int __init se7721_devices_setup(void)
-{
-	mrshpc_setup_windows();
-	return platform_add_devices(se7721_devices, ARRAY_SIZE(se7721_devices));
-}
-device_initcall(se7721_devices_setup);
-
-static void __init se7721_setup(char **cmdline_p)
-{
-	/* for USB */
-	__raw_writew(0x0000, 0xA405010C);	/* PGCR */
-	__raw_writew(0x0000, 0xA405010E);	/* PHCR */
-	__raw_writew(0x00AA, 0xA4050118);	/* PPCR */
-	__raw_writew(0x0000, 0xA4050124);	/* PSELA */
-}
-
-/*
- * The Machine Vector
- */
-struct sh_machine_vector mv_se7721 __initmv = {
-	.mv_name		= "Solution Engine 7721",
-	.mv_setup		= se7721_setup,
-	.mv_init_irq		= init_se7721_IRQ,
-};
diff --git a/arch/sh/boards/mach-se/7722/Makefile b/arch/sh/boards/mach-se/7722/Makefile
deleted file mode 100644
index a5e89c0c6bb2d4..00000000000000
--- a/arch/sh/boards/mach-se/7722/Makefile
+++ /dev/null
@@ -1,11 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the HITACHI UL SolutionEngine 7722 specific parts of the kernel
-#
-# This file is subject to the terms and conditions of the GNU General Public
-# License.  See the file "COPYING" in the main directory of this archive
-# for more details.
-#
-#
-
-obj-y	 := setup.o irq.o
diff --git a/arch/sh/boards/mach-se/7722/irq.c b/arch/sh/boards/mach-se/7722/irq.c
deleted file mode 100644
index efa96edd47dc5f..00000000000000
--- a/arch/sh/boards/mach-se/7722/irq.c
+++ /dev/null
@@ -1,116 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Hitachi UL SolutionEngine 7722 FPGA IRQ Support.
- *
- * Copyright (C) 2007  Nobuhiro Iwamatsu
- * Copyright (C) 2012  Paul Mundt
- */
-#define DRV_NAME "SE7722-FPGA"
-#define pr_fmt(fmt) DRV_NAME ": " fmt
-
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <linux/irqdomain.h>
-#include <linux/io.h>
-#include <linux/err.h>
-#include <linux/sizes.h>
-#include <mach-se/mach/se7722.h>
-
-#define IRQ01_BASE_ADDR	0x11800000
-#define IRQ01_MODE_REG	0
-#define IRQ01_STS_REG	4
-#define IRQ01_MASK_REG	8
-
-static void __iomem *se7722_irq_regs;
-struct irq_domain *se7722_irq_domain;
-
-static void se7722_irq_demux(struct irq_desc *desc)
-{
-	struct irq_data *data = irq_desc_get_irq_data(desc);
-	struct irq_chip *chip = irq_data_get_irq_chip(data);
-	unsigned long mask;
-	int bit;
-
-	chip->irq_mask_ack(data);
-
-	mask = ioread16(se7722_irq_regs + IRQ01_STS_REG);
-
-	for_each_set_bit(bit, &mask, SE7722_FPGA_IRQ_NR)
-		generic_handle_domain_irq(se7722_irq_domain, bit);
-
-	chip->irq_unmask(data);
-}
-
-static void __init se7722_domain_init(void)
-{
-	int i;
-
-	se7722_irq_domain = irq_domain_add_linear(NULL, SE7722_FPGA_IRQ_NR,
-						  &irq_domain_simple_ops, NULL);
-	if (unlikely(!se7722_irq_domain)) {
-		printk("Failed to get IRQ domain\n");
-		return;
-	}
-
-	for (i = 0; i < SE7722_FPGA_IRQ_NR; i++) {
-		int irq = irq_create_mapping(se7722_irq_domain, i);
-
-		if (unlikely(irq == 0)) {
-			printk("Failed to allocate IRQ %d\n", i);
-			return;
-		}
-	}
-}
-
-static void __init se7722_gc_init(void)
-{
-	struct irq_chip_generic *gc;
-	struct irq_chip_type *ct;
-	unsigned int irq_base;
-
-	irq_base = irq_linear_revmap(se7722_irq_domain, 0);
-
-	gc = irq_alloc_generic_chip(DRV_NAME, 1, irq_base, se7722_irq_regs,
-				    handle_level_irq);
-	if (unlikely(!gc))
-		return;
-
-	ct = gc->chip_types;
-	ct->chip.irq_mask = irq_gc_mask_set_bit;
-	ct->chip.irq_unmask = irq_gc_mask_clr_bit;
-
-	ct->regs.mask = IRQ01_MASK_REG;
-
-	irq_setup_generic_chip(gc, IRQ_MSK(SE7722_FPGA_IRQ_NR),
-			       IRQ_GC_INIT_MASK_CACHE,
-			       IRQ_NOREQUEST | IRQ_NOPROBE, 0);
-
-	irq_set_chained_handler(IRQ0_IRQ, se7722_irq_demux);
-	irq_set_irq_type(IRQ0_IRQ, IRQ_TYPE_LEVEL_LOW);
-
-	irq_set_chained_handler(IRQ1_IRQ, se7722_irq_demux);
-	irq_set_irq_type(IRQ1_IRQ, IRQ_TYPE_LEVEL_LOW);
-}
-
-/*
- * Initialize FPGA IRQs
- */
-void __init init_se7722_IRQ(void)
-{
-	se7722_irq_regs = ioremap(IRQ01_BASE_ADDR, SZ_16);
-	if (unlikely(!se7722_irq_regs)) {
-		printk("Failed to remap IRQ01 regs\n");
-		return;
-	}
-
-	/*
-	 * All FPGA IRQs disabled by default
-	 */
-	iowrite16(0, se7722_irq_regs + IRQ01_MASK_REG);
-
-	__raw_writew(0x2000, 0xb03fffec);  /* mrshpc irq enable */
-
-	se7722_domain_init();
-	se7722_gc_init();
-}
diff --git a/arch/sh/boards/mach-se/7722/setup.c b/arch/sh/boards/mach-se/7722/setup.c
deleted file mode 100644
index 2cd4a2e84b930c..00000000000000
--- a/arch/sh/boards/mach-se/7722/setup.c
+++ /dev/null
@@ -1,190 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/se/7722/setup.c
- *
- * Copyright (C) 2007 Nobuhiro Iwamatsu
- * Copyright (C) 2012 Paul Mundt
- *
- * Hitachi UL SolutionEngine 7722 Support.
- */
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/ata_platform.h>
-#include <linux/input.h>
-#include <linux/input/sh_keysc.h>
-#include <linux/irqdomain.h>
-#include <linux/smc91x.h>
-#include <linux/sh_intc.h>
-#include <mach-se/mach/se7722.h>
-#include <mach-se/mach/mrshpc.h>
-#include <asm/machvec.h>
-#include <asm/clock.h>
-#include <asm/io.h>
-#include <asm/heartbeat.h>
-#include <cpu/sh7722.h>
-
-/* Heartbeat */
-static struct resource heartbeat_resource = {
-	.start  = PA_LED,
-	.end    = PA_LED,
-	.flags  = IORESOURCE_MEM | IORESOURCE_MEM_16BIT,
-};
-
-static struct platform_device heartbeat_device = {
-	.name           = "heartbeat",
-	.id             = -1,
-	.num_resources  = 1,
-	.resource       = &heartbeat_resource,
-};
-
-/* SMC91x */
-static struct smc91x_platdata smc91x_info = {
-	.flags = SMC91X_USE_16BIT,
-};
-
-static struct resource smc91x_eth_resources[] = {
-	[0] = {
-		.name   = "smc91x-regs" ,
-		.start  = PA_LAN + 0x300,
-		.end    = PA_LAN + 0x300 + 0x10 ,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		/* Filled in later */
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device smc91x_eth_device = {
-	.name           = "smc91x",
-	.id             = 0,
-	.dev = {
-		.dma_mask               = NULL,         /* don't use dma */
-		.coherent_dma_mask      = 0xffffffff,
-		.platform_data	= &smc91x_info,
-	},
-	.num_resources  = ARRAY_SIZE(smc91x_eth_resources),
-	.resource       = smc91x_eth_resources,
-};
-
-static struct resource cf_ide_resources[] = {
-	[0] = {
-		.start  = PA_MRSHPC_IO + 0x1f0,
-		.end    = PA_MRSHPC_IO + 0x1f0 + 8 ,
-		.flags  = IORESOURCE_IO,
-	},
-	[1] = {
-		.start  = PA_MRSHPC_IO + 0x1f0 + 0x206,
-		.end    = PA_MRSHPC_IO + 0x1f0 +8 + 0x206 + 8,
-		.flags  = IORESOURCE_IO,
-	},
-	[2] = {
-		/* Filled in later */
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device cf_ide_device  = {
-	.name           = "pata_platform",
-	.id             = -1,
-	.num_resources  = ARRAY_SIZE(cf_ide_resources),
-	.resource       = cf_ide_resources,
-};
-
-static struct sh_keysc_info sh_keysc_info = {
-	.mode = SH_KEYSC_MODE_1, /* KEYOUT0->5, KEYIN0->4 */
-	.scan_timing = 3,
-	.delay = 5,
-	.keycodes = { /* SW1 -> SW30 */
-		KEY_A, KEY_B, KEY_C, KEY_D, KEY_E,
-		KEY_F, KEY_G, KEY_H, KEY_I, KEY_J,
-		KEY_K, KEY_L, KEY_M, KEY_N, KEY_O,
-		KEY_P, KEY_Q, KEY_R, KEY_S, KEY_T,
-		KEY_U, KEY_V, KEY_W, KEY_X, KEY_Y,
-		KEY_Z,
-		KEY_HOME, KEY_SLEEP, KEY_WAKEUP, KEY_COFFEE, /* life */
-	},
-};
-
-static struct resource sh_keysc_resources[] = {
-	[0] = {
-		.start  = 0x044b0000,
-		.end    = 0x044b000f,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0xbe0),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device sh_keysc_device = {
-	.name           = "sh_keysc",
-	.id             = 0, /* "keysc0" clock */
-	.num_resources  = ARRAY_SIZE(sh_keysc_resources),
-	.resource       = sh_keysc_resources,
-	.dev	= {
-		.platform_data	= &sh_keysc_info,
-	},
-};
-
-static struct platform_device *se7722_devices[] __initdata = {
-	&heartbeat_device,
-	&smc91x_eth_device,
-	&cf_ide_device,
-	&sh_keysc_device,
-};
-
-static int __init se7722_devices_setup(void)
-{
-	mrshpc_setup_windows();
-
-	/* Wire-up dynamic vectors */
-	cf_ide_resources[2].start = cf_ide_resources[2].end =
-		irq_find_mapping(se7722_irq_domain, SE7722_FPGA_IRQ_MRSHPC0);
-
-	smc91x_eth_resources[1].start = smc91x_eth_resources[1].end =
-		irq_find_mapping(se7722_irq_domain, SE7722_FPGA_IRQ_SMC);
-
-	return platform_add_devices(se7722_devices, ARRAY_SIZE(se7722_devices));
-}
-device_initcall(se7722_devices_setup);
-
-static void __init se7722_setup(char **cmdline_p)
-{
-	__raw_writew(0x010D, FPGA_OUT);    /* FPGA */
-
-	__raw_writew(0x0000, PORT_PECR);   /* PORT E 1 = IRQ5 ,E 0 = BS */
-	__raw_writew(0x1000, PORT_PJCR);   /* PORT J 1 = IRQ1,J 0 =IRQ0 */
-
-	/* LCDC I/O */
-	__raw_writew(0x0020, PORT_PSELD);
-
-	/* SIOF1*/
-	__raw_writew(0x0003, PORT_PSELB);
-	__raw_writew(0xe000, PORT_PSELC);
-	__raw_writew(0x0000, PORT_PKCR);
-
-	/* LCDC */
-	__raw_writew(0x4020, PORT_PHCR);
-	__raw_writew(0x0000, PORT_PLCR);
-	__raw_writew(0x0000, PORT_PMCR);
-	__raw_writew(0x0002, PORT_PRCR);
-	__raw_writew(0x0000, PORT_PXCR);   /* LCDC,CS6A */
-
-	/* KEYSC */
-	__raw_writew(0x0A10, PORT_PSELA); /* BS,SHHID2 */
-	__raw_writew(0x0000, PORT_PYCR);
-	__raw_writew(0x0000, PORT_PZCR);
-	__raw_writew(__raw_readw(PORT_HIZCRA) & ~0x4000, PORT_HIZCRA);
-	__raw_writew(__raw_readw(PORT_HIZCRC) & ~0xc000, PORT_HIZCRC);
-}
-
-/*
- * The Machine Vector
- */
-static struct sh_machine_vector mv_se7722 __initmv = {
-	.mv_name                = "Solution Engine 7722" ,
-	.mv_setup               = se7722_setup ,
-	.mv_init_irq		= init_se7722_IRQ,
-};
diff --git a/arch/sh/boards/mach-se/7724/Makefile b/arch/sh/boards/mach-se/7724/Makefile
deleted file mode 100644
index 6c6112b24617d0..00000000000000
--- a/arch/sh/boards/mach-se/7724/Makefile
+++ /dev/null
@@ -1,11 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the HITACHI UL SolutionEngine 7724 specific parts of the kernel
-#
-# This file is subject to the terms and conditions of the GNU General Public
-# License.  See the file "COPYING" in the main directory of this archive
-# for more details.
-#
-#
-
-obj-y	 := setup.o irq.o sdram.o
diff --git a/arch/sh/boards/mach-se/7724/irq.c b/arch/sh/boards/mach-se/7724/irq.c
deleted file mode 100644
index 14ce3024738f3b..00000000000000
--- a/arch/sh/boards/mach-se/7724/irq.c
+++ /dev/null
@@ -1,143 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/se/7724/irq.c
- *
- * Copyright (C) 2009 Renesas Solutions Corp.
- *
- * Kuninori Morimoto <morimoto.kuninori@renesas.com>
- *
- * Based on  linux/arch/sh/boards/se/7722/irq.c
- * Copyright (C) 2007  Nobuhiro Iwamatsu
- *
- * Hitachi UL SolutionEngine 7724 Support.
- */
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <linux/export.h>
-#include <linux/topology.h>
-#include <linux/io.h>
-#include <linux/err.h>
-#include <mach-se/mach/se7724.h>
-
-struct fpga_irq {
-	unsigned long  sraddr;
-	unsigned long  mraddr;
-	unsigned short mask;
-	unsigned int   base;
-};
-
-static unsigned int fpga2irq(unsigned int irq)
-{
-	if (irq >= IRQ0_BASE &&
-	    irq <= IRQ0_END)
-		return IRQ0_IRQ;
-	else if (irq >= IRQ1_BASE &&
-		 irq <= IRQ1_END)
-		return IRQ1_IRQ;
-	else
-		return IRQ2_IRQ;
-}
-
-static struct fpga_irq get_fpga_irq(unsigned int irq)
-{
-	struct fpga_irq set;
-
-	switch (irq) {
-	case IRQ0_IRQ:
-		set.sraddr = IRQ0_SR;
-		set.mraddr = IRQ0_MR;
-		set.mask   = IRQ0_MASK;
-		set.base   = IRQ0_BASE;
-		break;
-	case IRQ1_IRQ:
-		set.sraddr = IRQ1_SR;
-		set.mraddr = IRQ1_MR;
-		set.mask   = IRQ1_MASK;
-		set.base   = IRQ1_BASE;
-		break;
-	default:
-		set.sraddr = IRQ2_SR;
-		set.mraddr = IRQ2_MR;
-		set.mask   = IRQ2_MASK;
-		set.base   = IRQ2_BASE;
-		break;
-	}
-
-	return set;
-}
-
-static void disable_se7724_irq(struct irq_data *data)
-{
-	unsigned int irq = data->irq;
-	struct fpga_irq set = get_fpga_irq(fpga2irq(irq));
-	unsigned int bit = irq - set.base;
-	__raw_writew(__raw_readw(set.mraddr) | 0x0001 << bit, set.mraddr);
-}
-
-static void enable_se7724_irq(struct irq_data *data)
-{
-	unsigned int irq = data->irq;
-	struct fpga_irq set = get_fpga_irq(fpga2irq(irq));
-	unsigned int bit = irq - set.base;
-	__raw_writew(__raw_readw(set.mraddr) & ~(0x0001 << bit), set.mraddr);
-}
-
-static struct irq_chip se7724_irq_chip __read_mostly = {
-	.name		= "SE7724-FPGA",
-	.irq_mask	= disable_se7724_irq,
-	.irq_unmask	= enable_se7724_irq,
-};
-
-static void se7724_irq_demux(struct irq_desc *desc)
-{
-	unsigned int irq = irq_desc_get_irq(desc);
-	struct fpga_irq set = get_fpga_irq(irq);
-	unsigned short intv = __raw_readw(set.sraddr);
-	unsigned int ext_irq = set.base;
-
-	intv &= set.mask;
-
-	for (; intv; intv >>= 1, ext_irq++) {
-		if (!(intv & 1))
-			continue;
-
-		generic_handle_irq(ext_irq);
-	}
-}
-
-/*
- * Initialize IRQ setting
- */
-void __init init_se7724_IRQ(void)
-{
-	int irq_base, i;
-
-	__raw_writew(0xffff, IRQ0_MR);  /* mask all */
-	__raw_writew(0xffff, IRQ1_MR);  /* mask all */
-	__raw_writew(0xffff, IRQ2_MR);  /* mask all */
-	__raw_writew(0x0000, IRQ0_SR);  /* clear irq */
-	__raw_writew(0x0000, IRQ1_SR);  /* clear irq */
-	__raw_writew(0x0000, IRQ2_SR);  /* clear irq */
-	__raw_writew(0x002a, IRQ_MODE); /* set irq type */
-
-	irq_base = irq_alloc_descs(SE7724_FPGA_IRQ_BASE, SE7724_FPGA_IRQ_BASE,
-				   SE7724_FPGA_IRQ_NR, numa_node_id());
-	if (IS_ERR_VALUE(irq_base)) {
-		pr_err("%s: failed hooking irqs for FPGA\n", __func__);
-		return;
-	}
-
-	for (i = 0; i < SE7724_FPGA_IRQ_NR; i++)
-		irq_set_chip_and_handler_name(irq_base + i, &se7724_irq_chip,
-					      handle_level_irq, "level");
-
-	irq_set_chained_handler(IRQ0_IRQ, se7724_irq_demux);
-	irq_set_irq_type(IRQ0_IRQ, IRQ_TYPE_LEVEL_LOW);
-
-	irq_set_chained_handler(IRQ1_IRQ, se7724_irq_demux);
-	irq_set_irq_type(IRQ1_IRQ, IRQ_TYPE_LEVEL_LOW);
-
-	irq_set_chained_handler(IRQ2_IRQ, se7724_irq_demux);
-	irq_set_irq_type(IRQ2_IRQ, IRQ_TYPE_LEVEL_LOW);
-}
diff --git a/arch/sh/boards/mach-se/7724/sdram.S b/arch/sh/boards/mach-se/7724/sdram.S
deleted file mode 100644
index 61c1fe78d71a05..00000000000000
--- a/arch/sh/boards/mach-se/7724/sdram.S
+++ /dev/null
@@ -1,128 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * MS7724SE sdram self/auto-refresh setup code
- *
- *  Copyright (C) 2009 Magnus Damm
- */
-
-#include <linux/sys.h>
-#include <linux/errno.h>
-#include <linux/linkage.h>
-#include <asm/asm-offsets.h>
-#include <asm/suspend.h>
-#include <asm/romimage-macros.h>
-
-/* code to enter and leave self-refresh. must be self-contained.
- * this code will be copied to on-chip memory and executed from there.
- */
-	.balign 4
-ENTRY(ms7724se_sdram_enter_start)
-
-	/* DBSC: put memory in self-refresh mode */
-
-	ED 0xFD000010, 0x00000000 /* DBEN */
-	ED 0xFD000040, 0x00000000 /* DBRFPDN0 */
-	ED 0xFD000014, 0x00000002 /* DBCMDCNT (PALL) */
-	ED 0xFD000014, 0x00000004 /* DBCMDCNT (REF) */
-	ED 0xFD000040, 0x00000001 /* DBRFPDN0 */
-
-	rts
-	 nop
-
-ENTRY(ms7724se_sdram_enter_end)
-
-	.balign 4
-ENTRY(ms7724se_sdram_leave_start)
-
-	/* DBSC: put memory in auto-refresh mode */
-
-	mov.l	@(SH_SLEEP_MODE, r5), r0
-	tst	#SUSP_SH_RSTANDBY, r0
-	bf	resume_rstandby
-
-	ED 0xFD000040, 0x00000000 /* DBRFPDN0 */
-	WAIT 1
-	ED 0xFD000014, 0x00000002 /* DBCMDCNT (PALL) */
-	ED 0xFD000014, 0x00000004 /* DBCMDCNT (REF) */
-	ED 0xFD000010, 0x00000001 /* DBEN */
-	ED 0xFD000040, 0x00010000 /* DBRFPDN0 */
-
-	rts
-	 nop
-
-resume_rstandby:
-
-	/* CPG: setup clocks before restarting external memory */
-
-	ED 0xA4150024, 0x00004000 /* PLLCR */
-
-	mov.l	FRQCRA,r0
-	mov.l	@r0,r3
-	mov.l	KICK,r1
-	or	r1, r3
-	mov.l	r3, @r0
-
-	mov.l	LSTATS,r0
-	mov	#1,r1
-WAIT_LSTATS:
-	mov.l	@r0,r3
-	tst	r1,r3
-	bf	WAIT_LSTATS
-
-	/* DBSC: re-initialize and put in auto-refresh */
-
-	ED 0xFD000108, 0x00000181 /* DBPDCNT0 */
-	ED 0xFD000020, 0x015B0002 /* DBCONF */
-	ED 0xFD000030, 0x03071502 /* DBTR0 */
-	ED 0xFD000034, 0x02020102 /* DBTR1 */
-	ED 0xFD000038, 0x01090405 /* DBTR2 */
-	ED 0xFD00003C, 0x00000002 /* DBTR3 */
-	ED 0xFD000008, 0x00000005 /* DBKIND */
-	ED 0xFD000040, 0x00000001 /* DBRFPDN0 */
-	ED 0xFD000040, 0x00000000 /* DBRFPDN0 */
-	ED 0xFD000018, 0x00000001 /* DBCKECNT */
-
-	mov	#100,r0
-WAIT_400NS:
-	dt	r0
-	bf	WAIT_400NS
-
-	ED 0xFD000014, 0x00000002 /* DBCMDCNT (PALL) */
-	ED 0xFD000060, 0x00020000 /* DBMRCNT (EMR2) */
-	ED 0xFD000060, 0x00030000 /* DBMRCNT (EMR3) */
-	ED 0xFD000060, 0x00010004 /* DBMRCNT (EMR) */
-	ED 0xFD000060, 0x00000532 /* DBMRCNT (MRS) */
-	ED 0xFD000014, 0x00000002 /* DBCMDCNT (PALL) */
-	ED 0xFD000014, 0x00000004 /* DBCMDCNT (REF) */
-	ED 0xFD000014, 0x00000004 /* DBCMDCNT (REF) */
-	ED 0xFD000060, 0x00000432 /* DBMRCNT (MRS) */
-	ED 0xFD000060, 0x000103c0 /* DBMRCNT (EMR) */
-	ED 0xFD000060, 0x00010040 /* DBMRCNT (EMR) */
-
-	mov	#100,r0
-WAIT_400NS_2:
-	dt	r0
-	bf	WAIT_400NS_2
-
-	ED 0xFD000010, 0x00000001 /* DBEN */
-	ED 0xFD000044, 0x0000050f /* DBRFPDN1 */
-	ED 0xFD000048, 0x236800e6 /* DBRFPDN2 */
-
-	mov.l	DUMMY,r0
-	mov.l	@r0, r1 /* force single dummy read */
-
-	ED 0xFD000014, 0x00000002 /* DBCMDCNT (PALL) */
-	ED 0xFD000014, 0x00000004 /* DBCMDCNT (REF) */
-	ED 0xFD000108, 0x00000080 /* DBPDCNT0 */
-	ED 0xFD000040, 0x00010000 /* DBRFPDN0 */
-
-	rts
-	 nop
-
-	.balign 4
-DUMMY:	.long	0xac400000
-FRQCRA:	.long	0xa4150000
-KICK:	.long	0x80000000
-LSTATS:	.long	0xa4150060
-
-ENTRY(ms7724se_sdram_leave_end)
diff --git a/arch/sh/boards/mach-se/7724/setup.c b/arch/sh/boards/mach-se/7724/setup.c
deleted file mode 100644
index b60a2626e18b27..00000000000000
--- a/arch/sh/boards/mach-se/7724/setup.c
+++ /dev/null
@@ -1,986 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/se/7724/setup.c
- *
- * Copyright (C) 2009 Renesas Solutions Corp.
- *
- * Kuninori Morimoto <morimoto.kuninori@renesas.com>
- */
-#include <asm/clock.h>
-#include <asm/heartbeat.h>
-#include <asm/io.h>
-#include <asm/suspend.h>
-
-#include <cpu/sh7724.h>
-
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/gpio.h>
-#include <linux/init.h>
-#include <linux/input.h>
-#include <linux/input/sh_keysc.h>
-#include <linux/interrupt.h>
-#include <linux/memblock.h>
-#include <linux/mfd/tmio.h>
-#include <linux/mmc/host.h>
-#include <linux/mtd/physmap.h>
-#include <linux/platform_device.h>
-#include <linux/regulator/fixed.h>
-#include <linux/regulator/machine.h>
-#include <linux/sh_eth.h>
-#include <linux/sh_intc.h>
-#include <linux/smc91x.h>
-#include <linux/usb/r8a66597.h>
-#include <linux/videodev2.h>
-#include <linux/dma-map-ops.h>
-
-#include <mach-se/mach/se7724.h>
-#include <media/drv-intf/renesas-ceu.h>
-
-#include <sound/sh_fsi.h>
-#include <sound/simple_card.h>
-
-#include <video/sh_mobile_lcdc.h>
-
-#define CEU_BUFFER_MEMORY_SIZE		(4 << 20)
-static phys_addr_t ceu0_dma_membase;
-static phys_addr_t ceu1_dma_membase;
-
-/*
- * SWx    1234 5678
- * ------------------------------------
- * SW31 : 1001 1100    : default
- * SW32 : 0111 1111    : use on board flash
- *
- * SW41 : abxx xxxx  -> a = 0 : Analog  monitor
- *                          1 : Digital monitor
- *                      b = 0 : VGA
- *                          1 : 720p
- */
-
-/*
- * about 720p
- *
- * When you use 1280 x 720 lcdc output,
- * you should change OSC6 lcdc clock from 25.175MHz to 74.25MHz,
- * and change SW41 to use 720p
- */
-
-/*
- * about sound
- *
- * This setup.c supports FSI slave mode.
- * Please change J20, J21, J22 pin to 1-2 connection.
- */
-
-/* Heartbeat */
-static struct resource heartbeat_resource = {
-	.start  = PA_LED,
-	.end    = PA_LED,
-	.flags  = IORESOURCE_MEM | IORESOURCE_MEM_16BIT,
-};
-
-static struct platform_device heartbeat_device = {
-	.name           = "heartbeat",
-	.id             = -1,
-	.num_resources  = 1,
-	.resource       = &heartbeat_resource,
-};
-
-/* LAN91C111 */
-static struct smc91x_platdata smc91x_info = {
-	.flags = SMC91X_USE_16BIT | SMC91X_NOWAIT,
-};
-
-static struct resource smc91x_eth_resources[] = {
-	[0] = {
-		.name   = "SMC91C111" ,
-		.start  = 0x1a300300,
-		.end    = 0x1a30030f,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = IRQ0_SMC,
-		.flags  = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
-	},
-};
-
-static struct platform_device smc91x_eth_device = {
-	.name	= "smc91x",
-	.num_resources  = ARRAY_SIZE(smc91x_eth_resources),
-	.resource       = smc91x_eth_resources,
-	.dev	= {
-		.platform_data	= &smc91x_info,
-	},
-};
-
-/* MTD */
-static struct mtd_partition nor_flash_partitions[] = {
-	{
-		.name = "uboot",
-		.offset = 0,
-		.size = (1 * 1024 * 1024),
-		.mask_flags = MTD_WRITEABLE,	/* Read-only */
-	}, {
-		.name = "kernel",
-		.offset = MTDPART_OFS_APPEND,
-		.size = (2 * 1024 * 1024),
-	}, {
-		.name = "free-area",
-		.offset = MTDPART_OFS_APPEND,
-		.size = MTDPART_SIZ_FULL,
-	},
-};
-
-static struct physmap_flash_data nor_flash_data = {
-	.width		= 2,
-	.parts		= nor_flash_partitions,
-	.nr_parts	= ARRAY_SIZE(nor_flash_partitions),
-};
-
-static struct resource nor_flash_resources[] = {
-	[0] = {
-		.name	= "NOR Flash",
-		.start	= 0x00000000,
-		.end	= 0x01ffffff,
-		.flags	= IORESOURCE_MEM,
-	}
-};
-
-static struct platform_device nor_flash_device = {
-	.name		= "physmap-flash",
-	.resource	= nor_flash_resources,
-	.num_resources	= ARRAY_SIZE(nor_flash_resources),
-	.dev		= {
-		.platform_data = &nor_flash_data,
-	},
-};
-
-/* LCDC */
-static const struct fb_videomode lcdc_720p_modes[] = {
-	{
-		.name		= "LB070WV1",
-		.sync		= 0, /* hsync and vsync are active low */
-		.xres		= 1280,
-		.yres		= 720,
-		.left_margin	= 220,
-		.right_margin	= 110,
-		.hsync_len	= 40,
-		.upper_margin	= 20,
-		.lower_margin	= 5,
-		.vsync_len	= 5,
-	},
-};
-
-static const struct fb_videomode lcdc_vga_modes[] = {
-	{
-		.name		= "LB070WV1",
-		.sync		= 0, /* hsync and vsync are active low */
-		.xres		= 640,
-		.yres		= 480,
-		.left_margin	= 105,
-		.right_margin	= 50,
-		.hsync_len	= 96,
-		.upper_margin	= 33,
-		.lower_margin	= 10,
-		.vsync_len	= 2,
-	},
-};
-
-static struct sh_mobile_lcdc_info lcdc_info = {
-	.clock_source = LCDC_CLK_EXTERNAL,
-	.ch[0] = {
-		.chan = LCDC_CHAN_MAINLCD,
-		.fourcc = V4L2_PIX_FMT_RGB565,
-		.clock_divider = 1,
-		.panel_cfg = { /* 7.0 inch */
-			.width = 152,
-			.height = 91,
-		},
-	}
-};
-
-static struct resource lcdc_resources[] = {
-	[0] = {
-		.name	= "LCDC",
-		.start	= 0xfe940000,
-		.end	= 0xfe942fff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0xf40),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device lcdc_device = {
-	.name		= "sh_mobile_lcdc_fb",
-	.num_resources	= ARRAY_SIZE(lcdc_resources),
-	.resource	= lcdc_resources,
-	.dev		= {
-		.platform_data	= &lcdc_info,
-	},
-};
-
-/* CEU0 */
-static struct ceu_platform_data ceu0_pdata = {
-	.num_subdevs = 0,
-};
-
-static struct resource ceu0_resources[] = {
-	[0] = {
-		.name	= "CEU0",
-		.start	= 0xfe910000,
-		.end	= 0xfe91009f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0x880),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device ceu0_device = {
-	.name		= "renesas-ceu",
-	.id             = 0, /* "ceu.0" clock */
-	.num_resources	= ARRAY_SIZE(ceu0_resources),
-	.resource	= ceu0_resources,
-	.dev	= {
-		.platform_data	= &ceu0_pdata,
-	},
-};
-
-/* CEU1 */
-static struct ceu_platform_data ceu1_pdata = {
-	.num_subdevs = 0,
-};
-
-static struct resource ceu1_resources[] = {
-	[0] = {
-		.name	= "CEU1",
-		.start	= 0xfe914000,
-		.end	= 0xfe91409f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0x9e0),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device ceu1_device = {
-	.name		= "renesas-ceu",
-	.id             = 1, /* "ceu.1" clock */
-	.num_resources	= ARRAY_SIZE(ceu1_resources),
-	.resource	= ceu1_resources,
-	.dev	= {
-		.platform_data	= &ceu1_pdata,
-	},
-};
-
-/* FSI */
-/* change J20, J21, J22 pin to 1-2 connection to use slave mode */
-static struct resource fsi_resources[] = {
-	[0] = {
-		.name	= "FSI",
-		.start	= 0xFE3C0000,
-		.end	= 0xFE3C021d,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0xf80),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device fsi_device = {
-	.name		= "sh_fsi",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(fsi_resources),
-	.resource	= fsi_resources,
-};
-
-static struct asoc_simple_card_info fsi_ak4642_info = {
-	.name		= "AK4642",
-	.card		= "FSIA-AK4642",
-	.codec		= "ak4642-codec.0-0012",
-	.platform	= "sh_fsi.0",
-	.daifmt		= SND_SOC_DAIFMT_LEFT_J | SND_SOC_DAIFMT_CBP_CFP,
-	.cpu_dai = {
-		.name	= "fsia-dai",
-	},
-	.codec_dai = {
-		.name	= "ak4642-hifi",
-		.sysclk	= 11289600,
-	},
-};
-
-static struct platform_device fsi_ak4642_device = {
-	.name	= "asoc-simple-card",
-	.dev	= {
-		.platform_data	= &fsi_ak4642_info,
-	},
-};
-
-/* KEYSC in SoC (Needs SW33-2 set to ON) */
-static struct sh_keysc_info keysc_info = {
-	.mode = SH_KEYSC_MODE_1,
-	.scan_timing = 3,
-	.delay = 50,
-	.keycodes = {
-		KEY_1, KEY_2, KEY_3, KEY_4, KEY_5,
-		KEY_6, KEY_7, KEY_8, KEY_9, KEY_A,
-		KEY_B, KEY_C, KEY_D, KEY_E, KEY_F,
-		KEY_G, KEY_H, KEY_I, KEY_K, KEY_L,
-		KEY_M, KEY_N, KEY_O, KEY_P, KEY_Q,
-		KEY_R, KEY_S, KEY_T, KEY_U, KEY_V,
-	},
-};
-
-static struct resource keysc_resources[] = {
-	[0] = {
-		.name	= "KEYSC",
-		.start  = 0x044b0000,
-		.end    = 0x044b000f,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0xbe0),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device keysc_device = {
-	.name           = "sh_keysc",
-	.id             = 0, /* "keysc0" clock */
-	.num_resources  = ARRAY_SIZE(keysc_resources),
-	.resource       = keysc_resources,
-	.dev	= {
-		.platform_data	= &keysc_info,
-	},
-};
-
-/* SH Eth */
-static struct resource sh_eth_resources[] = {
-	[0] = {
-		.start = SH_ETH_ADDR,
-		.end   = SH_ETH_ADDR + 0x1FC - 1,
-		.flags = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start = evt2irq(0xd60),
-		.flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
-	},
-};
-
-static struct sh_eth_plat_data sh_eth_plat = {
-	.phy = 0x1f, /* SMSC LAN8187 */
-	.phy_interface = PHY_INTERFACE_MODE_MII,
-};
-
-static struct platform_device sh_eth_device = {
-	.name = "sh7724-ether",
-	.id = 0,
-	.dev = {
-		.platform_data = &sh_eth_plat,
-	},
-	.num_resources = ARRAY_SIZE(sh_eth_resources),
-	.resource = sh_eth_resources,
-};
-
-static struct r8a66597_platdata sh7724_usb0_host_data = {
-	.on_chip = 1,
-};
-
-static struct resource sh7724_usb0_host_resources[] = {
-	[0] = {
-		.start	= 0xa4d80000,
-		.end	= 0xa4d80124 - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0xa20),
-		.end	= evt2irq(0xa20),
-		.flags	= IORESOURCE_IRQ | IRQF_TRIGGER_LOW,
-	},
-};
-
-static struct platform_device sh7724_usb0_host_device = {
-	.name		= "r8a66597_hcd",
-	.id		= 0,
-	.dev = {
-		.dma_mask		= NULL,         /*  not use dma */
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &sh7724_usb0_host_data,
-	},
-	.num_resources	= ARRAY_SIZE(sh7724_usb0_host_resources),
-	.resource	= sh7724_usb0_host_resources,
-};
-
-static struct r8a66597_platdata sh7724_usb1_gadget_data = {
-	.on_chip = 1,
-};
-
-static struct resource sh7724_usb1_gadget_resources[] = {
-	[0] = {
-		.start	= 0xa4d90000,
-		.end	= 0xa4d90123,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0xa40),
-		.end	= evt2irq(0xa40),
-		.flags	= IORESOURCE_IRQ | IRQF_TRIGGER_LOW,
-	},
-};
-
-static struct platform_device sh7724_usb1_gadget_device = {
-	.name		= "r8a66597_udc",
-	.id		= 1, /* USB1 */
-	.dev = {
-		.dma_mask		= NULL,         /*  not use dma */
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &sh7724_usb1_gadget_data,
-	},
-	.num_resources	= ARRAY_SIZE(sh7724_usb1_gadget_resources),
-	.resource	= sh7724_usb1_gadget_resources,
-};
-
-/* Fixed 3.3V regulator to be used by SDHI0, SDHI1 */
-static struct regulator_consumer_supply fixed3v3_power_consumers[] =
-{
-	REGULATOR_SUPPLY("vmmc", "sh_mobile_sdhi.0"),
-	REGULATOR_SUPPLY("vqmmc", "sh_mobile_sdhi.0"),
-	REGULATOR_SUPPLY("vmmc", "sh_mobile_sdhi.1"),
-	REGULATOR_SUPPLY("vqmmc", "sh_mobile_sdhi.1"),
-};
-
-static struct resource sdhi0_cn7_resources[] = {
-	[0] = {
-		.name	= "SDHI0",
-		.start  = 0x04ce0000,
-		.end    = 0x04ce00ff,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0xe80),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct tmio_mmc_data sh7724_sdhi0_data = {
-	.chan_priv_tx	= (void *)SHDMA_SLAVE_SDHI0_TX,
-	.chan_priv_rx	= (void *)SHDMA_SLAVE_SDHI0_RX,
-	.capabilities	= MMC_CAP_SDIO_IRQ,
-};
-
-static struct platform_device sdhi0_cn7_device = {
-	.name           = "sh_mobile_sdhi",
-	.id		= 0,
-	.num_resources  = ARRAY_SIZE(sdhi0_cn7_resources),
-	.resource       = sdhi0_cn7_resources,
-	.dev = {
-		.platform_data	= &sh7724_sdhi0_data,
-	},
-};
-
-static struct resource sdhi1_cn8_resources[] = {
-	[0] = {
-		.name	= "SDHI1",
-		.start  = 0x04cf0000,
-		.end    = 0x04cf00ff,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0x4e0),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct tmio_mmc_data sh7724_sdhi1_data = {
-	.chan_priv_tx	= (void *)SHDMA_SLAVE_SDHI1_TX,
-	.chan_priv_rx	= (void *)SHDMA_SLAVE_SDHI1_RX,
-	.capabilities	= MMC_CAP_SDIO_IRQ,
-};
-
-static struct platform_device sdhi1_cn8_device = {
-	.name           = "sh_mobile_sdhi",
-	.id		= 1,
-	.num_resources  = ARRAY_SIZE(sdhi1_cn8_resources),
-	.resource       = sdhi1_cn8_resources,
-	.dev = {
-		.platform_data	= &sh7724_sdhi1_data,
-	},
-};
-
-/* IrDA */
-static struct resource irda_resources[] = {
-	[0] = {
-		.name	= "IrDA",
-		.start  = 0xA45D0000,
-		.end    = 0xA45D0049,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0x480),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device irda_device = {
-	.name           = "sh_sir",
-	.num_resources  = ARRAY_SIZE(irda_resources),
-	.resource       = irda_resources,
-};
-
-#include <media/i2c/ak881x.h>
-#include <media/drv-intf/sh_vou.h>
-
-static struct ak881x_pdata ak881x_pdata = {
-	.flags = AK881X_IF_MODE_SLAVE,
-};
-
-static struct i2c_board_info ak8813 = {
-	/* With open J18 jumper address is 0x21 */
-	I2C_BOARD_INFO("ak8813", 0x20),
-	.platform_data = &ak881x_pdata,
-};
-
-static struct sh_vou_pdata sh_vou_pdata = {
-	.bus_fmt	= SH_VOU_BUS_8BIT,
-	.flags		= SH_VOU_HSYNC_LOW | SH_VOU_VSYNC_LOW,
-	.board_info	= &ak8813,
-	.i2c_adap	= 0,
-};
-
-static struct resource sh_vou_resources[] = {
-	[0] = {
-		.start  = 0xfe960000,
-		.end    = 0xfe962043,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0x8e0),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device vou_device = {
-	.name           = "sh-vou",
-	.id		= -1,
-	.num_resources  = ARRAY_SIZE(sh_vou_resources),
-	.resource       = sh_vou_resources,
-	.dev		= {
-		.platform_data	= &sh_vou_pdata,
-	},
-};
-
-static struct platform_device *ms7724se_ceu_devices[] __initdata = {
-	&ceu0_device,
-	&ceu1_device,
-};
-
-static struct platform_device *ms7724se_devices[] __initdata = {
-	&heartbeat_device,
-	&smc91x_eth_device,
-	&lcdc_device,
-	&nor_flash_device,
-	&keysc_device,
-	&sh_eth_device,
-	&sh7724_usb0_host_device,
-	&sh7724_usb1_gadget_device,
-	&fsi_device,
-	&fsi_ak4642_device,
-	&sdhi0_cn7_device,
-	&sdhi1_cn8_device,
-	&irda_device,
-	&vou_device,
-};
-
-/* I2C device */
-static struct i2c_board_info i2c0_devices[] = {
-	{
-		I2C_BOARD_INFO("ak4642", 0x12),
-	},
-};
-
-#define EEPROM_OP   0xBA206000
-#define EEPROM_ADR  0xBA206004
-#define EEPROM_DATA 0xBA20600C
-#define EEPROM_STAT 0xBA206010
-#define EEPROM_STRT 0xBA206014
-
-static int __init sh_eth_is_eeprom_ready(void)
-{
-	int t = 10000;
-
-	while (t--) {
-		if (!__raw_readw(EEPROM_STAT))
-			return 1;
-		udelay(1);
-	}
-
-	printk(KERN_ERR "ms7724se can not access to eeprom\n");
-	return 0;
-}
-
-static void __init sh_eth_init(void)
-{
-	int i;
-	u16 mac;
-
-	/* check EEPROM status */
-	if (!sh_eth_is_eeprom_ready())
-		return;
-
-	/* read MAC addr from EEPROM */
-	for (i = 0 ; i < 3 ; i++) {
-		__raw_writew(0x0, EEPROM_OP); /* read */
-		__raw_writew(i*2, EEPROM_ADR);
-		__raw_writew(0x1, EEPROM_STRT);
-		if (!sh_eth_is_eeprom_ready())
-			return;
-
-		mac = __raw_readw(EEPROM_DATA);
-		sh_eth_plat.mac_addr[i << 1] = mac & 0xff;
-		sh_eth_plat.mac_addr[(i << 1) + 1] = mac >> 8;
-	}
-}
-
-#define SW4140    0xBA201000
-#define FPGA_OUT  0xBA200400
-#define PORT_HIZA 0xA4050158
-#define PORT_MSELCRB 0xA4050182
-
-#define SW41_A    0x0100
-#define SW41_B    0x0200
-#define SW41_C    0x0400
-#define SW41_D    0x0800
-#define SW41_E    0x1000
-#define SW41_F    0x2000
-#define SW41_G    0x4000
-#define SW41_H    0x8000
-
-extern char ms7724se_sdram_enter_start;
-extern char ms7724se_sdram_enter_end;
-extern char ms7724se_sdram_leave_start;
-extern char ms7724se_sdram_leave_end;
-
-static int __init arch_setup(void)
-{
-	/* enable I2C device */
-	i2c_register_board_info(0, i2c0_devices,
-				ARRAY_SIZE(i2c0_devices));
-	return 0;
-}
-arch_initcall(arch_setup);
-
-static int __init devices_setup(void)
-{
-	u16 sw = __raw_readw(SW4140); /* select camera, monitor */
-	struct clk *clk;
-	u16 fpga_out;
-
-	/* register board specific self-refresh code */
-	sh_mobile_register_self_refresh(SUSP_SH_STANDBY | SUSP_SH_SF |
-					SUSP_SH_RSTANDBY,
-					&ms7724se_sdram_enter_start,
-					&ms7724se_sdram_enter_end,
-					&ms7724se_sdram_leave_start,
-					&ms7724se_sdram_leave_end);
-
-	regulator_register_always_on(0, "fixed-3.3V", fixed3v3_power_consumers,
-				     ARRAY_SIZE(fixed3v3_power_consumers), 3300000);
-
-	/* Reset Release */
-	fpga_out = __raw_readw(FPGA_OUT);
-	/* bit4: NTSC_PDN, bit5: NTSC_RESET */
-	fpga_out &= ~((1 << 1)  | /* LAN */
-		      (1 << 4)  | /* AK8813 PDN */
-		      (1 << 5)  | /* AK8813 RESET */
-		      (1 << 6)  | /* VIDEO DAC */
-		      (1 << 7)  | /* AK4643 */
-		      (1 << 8)  | /* IrDA */
-		      (1 << 12) | /* USB0 */
-		      (1 << 14)); /* RMII */
-	__raw_writew(fpga_out | (1 << 4), FPGA_OUT);
-
-	udelay(10);
-
-	/* AK8813 RESET */
-	__raw_writew(fpga_out | (1 << 5), FPGA_OUT);
-
-	udelay(10);
-
-	__raw_writew(fpga_out, FPGA_OUT);
-
-	/* turn on USB clocks, use external clock */
-	__raw_writew((__raw_readw(PORT_MSELCRB) & ~0xc000) | 0x8000, PORT_MSELCRB);
-
-	/* Let LED9 show STATUS2 */
-	gpio_request(GPIO_FN_STATUS2, NULL);
-
-	/* Lit LED10 show STATUS0 */
-	gpio_request(GPIO_FN_STATUS0, NULL);
-
-	/* Lit LED11 show PDSTATUS */
-	gpio_request(GPIO_FN_PDSTATUS, NULL);
-
-	/* enable USB0 port */
-	__raw_writew(0x0600, 0xa40501d4);
-
-	/* enable USB1 port */
-	__raw_writew(0x0600, 0xa4050192);
-
-	/* enable IRQ 0,1,2 */
-	gpio_request(GPIO_FN_INTC_IRQ0, NULL);
-	gpio_request(GPIO_FN_INTC_IRQ1, NULL);
-	gpio_request(GPIO_FN_INTC_IRQ2, NULL);
-
-	/* enable SCIFA3 */
-	gpio_request(GPIO_FN_SCIF3_I_SCK, NULL);
-	gpio_request(GPIO_FN_SCIF3_I_RXD, NULL);
-	gpio_request(GPIO_FN_SCIF3_I_TXD, NULL);
-	gpio_request(GPIO_FN_SCIF3_I_CTS, NULL);
-	gpio_request(GPIO_FN_SCIF3_I_RTS, NULL);
-
-	/* enable LCDC */
-	gpio_request(GPIO_FN_LCDD23,   NULL);
-	gpio_request(GPIO_FN_LCDD22,   NULL);
-	gpio_request(GPIO_FN_LCDD21,   NULL);
-	gpio_request(GPIO_FN_LCDD20,   NULL);
-	gpio_request(GPIO_FN_LCDD19,   NULL);
-	gpio_request(GPIO_FN_LCDD18,   NULL);
-	gpio_request(GPIO_FN_LCDD17,   NULL);
-	gpio_request(GPIO_FN_LCDD16,   NULL);
-	gpio_request(GPIO_FN_LCDD15,   NULL);
-	gpio_request(GPIO_FN_LCDD14,   NULL);
-	gpio_request(GPIO_FN_LCDD13,   NULL);
-	gpio_request(GPIO_FN_LCDD12,   NULL);
-	gpio_request(GPIO_FN_LCDD11,   NULL);
-	gpio_request(GPIO_FN_LCDD10,   NULL);
-	gpio_request(GPIO_FN_LCDD9,    NULL);
-	gpio_request(GPIO_FN_LCDD8,    NULL);
-	gpio_request(GPIO_FN_LCDD7,    NULL);
-	gpio_request(GPIO_FN_LCDD6,    NULL);
-	gpio_request(GPIO_FN_LCDD5,    NULL);
-	gpio_request(GPIO_FN_LCDD4,    NULL);
-	gpio_request(GPIO_FN_LCDD3,    NULL);
-	gpio_request(GPIO_FN_LCDD2,    NULL);
-	gpio_request(GPIO_FN_LCDD1,    NULL);
-	gpio_request(GPIO_FN_LCDD0,    NULL);
-	gpio_request(GPIO_FN_LCDDISP,  NULL);
-	gpio_request(GPIO_FN_LCDHSYN,  NULL);
-	gpio_request(GPIO_FN_LCDDCK,   NULL);
-	gpio_request(GPIO_FN_LCDVSYN,  NULL);
-	gpio_request(GPIO_FN_LCDDON,   NULL);
-	gpio_request(GPIO_FN_LCDVEPWC, NULL);
-	gpio_request(GPIO_FN_LCDVCPWC, NULL);
-	gpio_request(GPIO_FN_LCDRD,    NULL);
-	gpio_request(GPIO_FN_LCDLCLK,  NULL);
-	__raw_writew((__raw_readw(PORT_HIZA) & ~0x0001), PORT_HIZA);
-
-	/* enable CEU0 */
-	gpio_request(GPIO_FN_VIO0_D15, NULL);
-	gpio_request(GPIO_FN_VIO0_D14, NULL);
-	gpio_request(GPIO_FN_VIO0_D13, NULL);
-	gpio_request(GPIO_FN_VIO0_D12, NULL);
-	gpio_request(GPIO_FN_VIO0_D11, NULL);
-	gpio_request(GPIO_FN_VIO0_D10, NULL);
-	gpio_request(GPIO_FN_VIO0_D9,  NULL);
-	gpio_request(GPIO_FN_VIO0_D8,  NULL);
-	gpio_request(GPIO_FN_VIO0_D7,  NULL);
-	gpio_request(GPIO_FN_VIO0_D6,  NULL);
-	gpio_request(GPIO_FN_VIO0_D5,  NULL);
-	gpio_request(GPIO_FN_VIO0_D4,  NULL);
-	gpio_request(GPIO_FN_VIO0_D3,  NULL);
-	gpio_request(GPIO_FN_VIO0_D2,  NULL);
-	gpio_request(GPIO_FN_VIO0_D1,  NULL);
-	gpio_request(GPIO_FN_VIO0_D0,  NULL);
-	gpio_request(GPIO_FN_VIO0_VD,  NULL);
-	gpio_request(GPIO_FN_VIO0_CLK, NULL);
-	gpio_request(GPIO_FN_VIO0_FLD, NULL);
-	gpio_request(GPIO_FN_VIO0_HD,  NULL);
-
-	/* enable CEU1 */
-	gpio_request(GPIO_FN_VIO1_D7,  NULL);
-	gpio_request(GPIO_FN_VIO1_D6,  NULL);
-	gpio_request(GPIO_FN_VIO1_D5,  NULL);
-	gpio_request(GPIO_FN_VIO1_D4,  NULL);
-	gpio_request(GPIO_FN_VIO1_D3,  NULL);
-	gpio_request(GPIO_FN_VIO1_D2,  NULL);
-	gpio_request(GPIO_FN_VIO1_D1,  NULL);
-	gpio_request(GPIO_FN_VIO1_D0,  NULL);
-	gpio_request(GPIO_FN_VIO1_FLD, NULL);
-	gpio_request(GPIO_FN_VIO1_HD,  NULL);
-	gpio_request(GPIO_FN_VIO1_VD,  NULL);
-	gpio_request(GPIO_FN_VIO1_CLK, NULL);
-
-	/* KEYSC */
-	gpio_request(GPIO_FN_KEYOUT5_IN5, NULL);
-	gpio_request(GPIO_FN_KEYOUT4_IN6, NULL);
-	gpio_request(GPIO_FN_KEYIN4,      NULL);
-	gpio_request(GPIO_FN_KEYIN3,      NULL);
-	gpio_request(GPIO_FN_KEYIN2,      NULL);
-	gpio_request(GPIO_FN_KEYIN1,      NULL);
-	gpio_request(GPIO_FN_KEYIN0,      NULL);
-	gpio_request(GPIO_FN_KEYOUT3,     NULL);
-	gpio_request(GPIO_FN_KEYOUT2,     NULL);
-	gpio_request(GPIO_FN_KEYOUT1,     NULL);
-	gpio_request(GPIO_FN_KEYOUT0,     NULL);
-
-	/* enable FSI */
-	gpio_request(GPIO_FN_FSIMCKA,    NULL);
-	gpio_request(GPIO_FN_FSIIASD,    NULL);
-	gpio_request(GPIO_FN_FSIOASD,    NULL);
-	gpio_request(GPIO_FN_FSIIABCK,   NULL);
-	gpio_request(GPIO_FN_FSIIALRCK,  NULL);
-	gpio_request(GPIO_FN_FSIOABCK,   NULL);
-	gpio_request(GPIO_FN_FSIOALRCK,  NULL);
-	gpio_request(GPIO_FN_CLKAUDIOAO, NULL);
-
-	/* set SPU2 clock to 83.4 MHz */
-	clk = clk_get(NULL, "spu_clk");
-	if (!IS_ERR(clk)) {
-		clk_set_rate(clk, clk_round_rate(clk, 83333333));
-		clk_put(clk);
-	}
-
-	/* change parent of FSI A */
-	clk = clk_get(NULL, "fsia_clk");
-	if (!IS_ERR(clk)) {
-		/* 48kHz dummy clock was used to make sure 1/1 divide */
-		clk_set_rate(&sh7724_fsimcka_clk, 48000);
-		clk_set_parent(clk, &sh7724_fsimcka_clk);
-		clk_set_rate(clk, 48000);
-		clk_put(clk);
-	}
-
-	/* SDHI0 connected to cn7 */
-	gpio_request(GPIO_FN_SDHI0CD, NULL);
-	gpio_request(GPIO_FN_SDHI0WP, NULL);
-	gpio_request(GPIO_FN_SDHI0D3, NULL);
-	gpio_request(GPIO_FN_SDHI0D2, NULL);
-	gpio_request(GPIO_FN_SDHI0D1, NULL);
-	gpio_request(GPIO_FN_SDHI0D0, NULL);
-	gpio_request(GPIO_FN_SDHI0CMD, NULL);
-	gpio_request(GPIO_FN_SDHI0CLK, NULL);
-
-	/* SDHI1 connected to cn8 */
-	gpio_request(GPIO_FN_SDHI1CD, NULL);
-	gpio_request(GPIO_FN_SDHI1WP, NULL);
-	gpio_request(GPIO_FN_SDHI1D3, NULL);
-	gpio_request(GPIO_FN_SDHI1D2, NULL);
-	gpio_request(GPIO_FN_SDHI1D1, NULL);
-	gpio_request(GPIO_FN_SDHI1D0, NULL);
-	gpio_request(GPIO_FN_SDHI1CMD, NULL);
-	gpio_request(GPIO_FN_SDHI1CLK, NULL);
-
-	/* enable IrDA */
-	gpio_request(GPIO_FN_IRDA_OUT, NULL);
-	gpio_request(GPIO_FN_IRDA_IN,  NULL);
-
-	/*
-	 * enable SH-Eth
-	 *
-	 * please remove J33 pin from your board !!
-	 *
-	 * ms7724 board should not use GPIO_FN_LNKSTA pin
-	 * So, This time PTX5 is set to input pin
-	 */
-	gpio_request(GPIO_FN_RMII_RXD0,    NULL);
-	gpio_request(GPIO_FN_RMII_RXD1,    NULL);
-	gpio_request(GPIO_FN_RMII_TXD0,    NULL);
-	gpio_request(GPIO_FN_RMII_TXD1,    NULL);
-	gpio_request(GPIO_FN_RMII_REF_CLK, NULL);
-	gpio_request(GPIO_FN_RMII_TX_EN,   NULL);
-	gpio_request(GPIO_FN_RMII_RX_ER,   NULL);
-	gpio_request(GPIO_FN_RMII_CRS_DV,  NULL);
-	gpio_request(GPIO_FN_MDIO,         NULL);
-	gpio_request(GPIO_FN_MDC,          NULL);
-	gpio_request(GPIO_PTX5, NULL);
-	gpio_direction_input(GPIO_PTX5);
-	sh_eth_init();
-
-	if (sw & SW41_B) {
-		/* 720p */
-		lcdc_info.ch[0].lcd_modes = lcdc_720p_modes;
-		lcdc_info.ch[0].num_modes = ARRAY_SIZE(lcdc_720p_modes);
-	} else {
-		/* VGA */
-		lcdc_info.ch[0].lcd_modes = lcdc_vga_modes;
-		lcdc_info.ch[0].num_modes = ARRAY_SIZE(lcdc_vga_modes);
-	}
-
-	if (sw & SW41_A) {
-		/* Digital monitor */
-		lcdc_info.ch[0].interface_type = RGB18;
-		lcdc_info.ch[0].flags          = 0;
-	} else {
-		/* Analog monitor */
-		lcdc_info.ch[0].interface_type = RGB24;
-		lcdc_info.ch[0].flags          = LCDC_FLAGS_DWPOL;
-	}
-
-	/* VOU */
-	gpio_request(GPIO_FN_DV_D15, NULL);
-	gpio_request(GPIO_FN_DV_D14, NULL);
-	gpio_request(GPIO_FN_DV_D13, NULL);
-	gpio_request(GPIO_FN_DV_D12, NULL);
-	gpio_request(GPIO_FN_DV_D11, NULL);
-	gpio_request(GPIO_FN_DV_D10, NULL);
-	gpio_request(GPIO_FN_DV_D9, NULL);
-	gpio_request(GPIO_FN_DV_D8, NULL);
-	gpio_request(GPIO_FN_DV_CLKI, NULL);
-	gpio_request(GPIO_FN_DV_CLK, NULL);
-	gpio_request(GPIO_FN_DV_VSYNC, NULL);
-	gpio_request(GPIO_FN_DV_HSYNC, NULL);
-
-	/* Initialize CEU platform devices separately to map memory first */
-	device_initialize(&ms7724se_ceu_devices[0]->dev);
-	dma_declare_coherent_memory(&ms7724se_ceu_devices[0]->dev,
-				    ceu0_dma_membase, ceu0_dma_membase,
-				    ceu0_dma_membase +
-				    CEU_BUFFER_MEMORY_SIZE - 1);
-	platform_device_add(ms7724se_ceu_devices[0]);
-
-	device_initialize(&ms7724se_ceu_devices[1]->dev);
-	dma_declare_coherent_memory(&ms7724se_ceu_devices[1]->dev,
-				    ceu1_dma_membase, ceu1_dma_membase,
-				    ceu1_dma_membase +
-				    CEU_BUFFER_MEMORY_SIZE - 1);
-	platform_device_add(ms7724se_ceu_devices[1]);
-
-	return platform_add_devices(ms7724se_devices,
-				    ARRAY_SIZE(ms7724se_devices));
-}
-device_initcall(devices_setup);
-
-/* Reserve a portion of memory for CEU 0 and CEU 1 buffers */
-static void __init ms7724se_mv_mem_reserve(void)
-{
-	phys_addr_t phys;
-	phys_addr_t size = CEU_BUFFER_MEMORY_SIZE;
-
-	phys = memblock_phys_alloc(size, PAGE_SIZE);
-	if (!phys)
-		panic("Failed to allocate CEU0 memory\n");
-
-	memblock_phys_free(phys, size);
-	memblock_remove(phys, size);
-	ceu0_dma_membase = phys;
-
-	phys = memblock_phys_alloc(size, PAGE_SIZE);
-	if (!phys)
-		panic("Failed to allocate CEU1 memory\n");
-
-	memblock_phys_free(phys, size);
-	memblock_remove(phys, size);
-	ceu1_dma_membase = phys;
-}
-
-static struct sh_machine_vector mv_ms7724se __initmv = {
-	.mv_name	= "ms7724se",
-	.mv_init_irq	= init_se7724_IRQ,
-	.mv_mem_reserve	= ms7724se_mv_mem_reserve,
-};
diff --git a/arch/sh/boards/mach-se/7751/Makefile b/arch/sh/boards/mach-se/7751/Makefile
deleted file mode 100644
index 2406d3e353524b..00000000000000
--- a/arch/sh/boards/mach-se/7751/Makefile
+++ /dev/null
@@ -1,6 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the 7751 SolutionEngine specific parts of the kernel
-#
-
-obj-y	 := setup.o irq.o
diff --git a/arch/sh/boards/mach-se/7751/irq.c b/arch/sh/boards/mach-se/7751/irq.c
deleted file mode 100644
index dcefe58d87534b..00000000000000
--- a/arch/sh/boards/mach-se/7751/irq.c
+++ /dev/null
@@ -1,51 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/se/7751/irq.c
- *
- * Copyright (C) 2000  Kazumoto Kojima
- *
- * Hitachi SolutionEngine Support.
- *
- * Modified for 7751 Solution Engine by
- * Ian da Silva and Jeremy Siegel, 2001.
- */
-
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <asm/irq.h>
-#include <mach-se/mach/se7751.h>
-
-static struct ipr_data ipr_irq_table[] = {
-	{ 13, 3, 3, 2 },
-	/* Add additional entries here as drivers are added and tested. */
-};
-
-static unsigned long ipr_offsets[] = {
-	BCR_ILCRA,
-	BCR_ILCRB,
-	BCR_ILCRC,
-	BCR_ILCRD,
-	BCR_ILCRE,
-	BCR_ILCRF,
-	BCR_ILCRG,
-};
-
-static struct ipr_desc ipr_irq_desc = {
-	.ipr_offsets	= ipr_offsets,
-	.nr_offsets	= ARRAY_SIZE(ipr_offsets),
-
-	.ipr_data	= ipr_irq_table,
-	.nr_irqs	= ARRAY_SIZE(ipr_irq_table),
-
-	.chip = {
-		.name	= "IPR-se7751",
-	},
-};
-
-/*
- * Initialize IRQ setting
- */
-void __init init_7751se_IRQ(void)
-{
-	register_ipr_controller(&ipr_irq_desc);
-}
diff --git a/arch/sh/boards/mach-se/7751/setup.c b/arch/sh/boards/mach-se/7751/setup.c
deleted file mode 100644
index 4c480605557f46..00000000000000
--- a/arch/sh/boards/mach-se/7751/setup.c
+++ /dev/null
@@ -1,60 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/se/7751/setup.c
- *
- * Copyright (C) 2000  Kazumoto Kojima
- *
- * Hitachi SolutionEngine Support.
- *
- * Modified for 7751 Solution Engine by
- * Ian da Silva and Jeremy Siegel, 2001.
- */
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <asm/machvec.h>
-#include <mach-se/mach/se7751.h>
-#include <asm/io.h>
-#include <asm/heartbeat.h>
-
-static unsigned char heartbeat_bit_pos[] = { 8, 9, 10, 11, 12, 13, 14, 15 };
-
-static struct heartbeat_data heartbeat_data = {
-	.bit_pos	= heartbeat_bit_pos,
-	.nr_bits	= ARRAY_SIZE(heartbeat_bit_pos),
-};
-
-static struct resource heartbeat_resources[] = {
-	[0] = {
-		.start	= PA_LED,
-		.end	= PA_LED,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device heartbeat_device = {
-	.name		= "heartbeat",
-	.id		= -1,
-	.dev	= {
-		.platform_data	= &heartbeat_data,
-	},
-	.num_resources	= ARRAY_SIZE(heartbeat_resources),
-	.resource	= heartbeat_resources,
-};
-
-static struct platform_device *se7751_devices[] __initdata = {
-	&heartbeat_device,
-};
-
-static int __init se7751_devices_setup(void)
-{
-	return platform_add_devices(se7751_devices, ARRAY_SIZE(se7751_devices));
-}
-device_initcall(se7751_devices_setup);
-
-/*
- * The Machine Vector
- */
-static struct sh_machine_vector mv_7751se __initmv = {
-	.mv_name		= "7751 SolutionEngine",
-	.mv_init_irq		= init_7751se_IRQ,
-};
diff --git a/arch/sh/boards/mach-se/7780/Makefile b/arch/sh/boards/mach-se/7780/Makefile
deleted file mode 100644
index 1f6669ab1bc0db..00000000000000
--- a/arch/sh/boards/mach-se/7780/Makefile
+++ /dev/null
@@ -1,11 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the HITACHI UL SolutionEngine 7780 specific parts of the kernel
-#
-# This file is subject to the terms and conditions of the GNU General Public
-# License.  See the file "COPYING" in the main directory of this archive
-# for more details.
-#
-#
-
-obj-y	 := setup.o irq.o
diff --git a/arch/sh/boards/mach-se/7780/irq.c b/arch/sh/boards/mach-se/7780/irq.c
deleted file mode 100644
index d427dfd711f171..00000000000000
--- a/arch/sh/boards/mach-se/7780/irq.c
+++ /dev/null
@@ -1,65 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/se/7780/irq.c
- *
- * Copyright (C) 2006,2007  Nobuhiro Iwamatsu
- *
- * Hitachi UL SolutionEngine 7780 Support.
- */
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <linux/io.h>
-#include <mach-se/mach/se7780.h>
-
-#define INTC_BASE	0xffd00000
-#define INTC_ICR1	(INTC_BASE+0x1c)
-
-/*
- * Initialize IRQ setting
- */
-void __init init_se7780_IRQ(void)
-{
-	/* enable all interrupt at FPGA */
-	__raw_writew(0, FPGA_INTMSK1);
-	/* mask SM501 interrupt */
-	__raw_writew((__raw_readw(FPGA_INTMSK1) | 0x0002), FPGA_INTMSK1);
-	/* enable all interrupt at FPGA */
-	__raw_writew(0, FPGA_INTMSK2);
-
-	/* set FPGA INTSEL register */
-	/* FPGA + 0x06 */
-	__raw_writew( ((IRQPIN_SM501 << IRQPOS_SM501) |
-		(IRQPIN_SMC91CX << IRQPOS_SMC91CX)), FPGA_INTSEL1);
-
-	/* FPGA + 0x08 */
-	__raw_writew(((IRQPIN_EXTINT4 << IRQPOS_EXTINT4) |
-		(IRQPIN_EXTINT3 << IRQPOS_EXTINT3) |
-		(IRQPIN_EXTINT2 << IRQPOS_EXTINT2) |
-		(IRQPIN_EXTINT1 << IRQPOS_EXTINT1)), FPGA_INTSEL2);
-
-	/* FPGA + 0x0A */
-	__raw_writew((IRQPIN_PCCPW << IRQPOS_PCCPW), FPGA_INTSEL3);
-
-	plat_irq_setup_pins(IRQ_MODE_IRQ); /* install handlers for IRQ0-7 */
-
-	/* ICR1: detect low level(for 2ndcut) */
-	__raw_writel(0xAAAA0000, INTC_ICR1);
-
-	/*
-	 * FPGA PCISEL register initialize
-	 *
-	 *  CPU  || SLOT1 | SLOT2 | S-ATA | USB
-	 *  -------------------------------------
-	 *  INTA || INTA  | INTD  |  --   | INTB
-	 *  -------------------------------------
-	 *  INTB || INTB  | INTA  |  --   | INTC
-	 *  -------------------------------------
-	 *  INTC || INTC  | INTB  | INTA  |  --
-	 *  -------------------------------------
-	 *  INTD || INTD  | INTC  |  --   | INTA
-	 *  -------------------------------------
-	 */
-	__raw_writew(0x0013, FPGA_PCI_INTSEL1);
-	__raw_writew(0xE402, FPGA_PCI_INTSEL2);
-}
diff --git a/arch/sh/boards/mach-se/7780/setup.c b/arch/sh/boards/mach-se/7780/setup.c
deleted file mode 100644
index 309f2681381b08..00000000000000
--- a/arch/sh/boards/mach-se/7780/setup.c
+++ /dev/null
@@ -1,111 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/se/7780/setup.c
- *
- * Copyright (C) 2006,2007  Nobuhiro Iwamatsu
- *
- * Hitachi UL SolutionEngine 7780 Support.
- */
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <asm/machvec.h>
-#include <mach-se/mach/se7780.h>
-#include <asm/io.h>
-#include <asm/heartbeat.h>
-
-/* Heartbeat */
-static struct resource heartbeat_resource = {
-	.start  = PA_LED,
-	.end    = PA_LED,
-	.flags  = IORESOURCE_MEM | IORESOURCE_MEM_16BIT,
-};
-
-static struct platform_device heartbeat_device = {
-	.name           = "heartbeat",
-	.id             = -1,
-	.num_resources  = 1,
-	.resource       = &heartbeat_resource,
-};
-
-/* SMC91x */
-static struct resource smc91x_eth_resources[] = {
-	[0] = {
-		.name   = "smc91x-regs" ,
-		.start  = PA_LAN + 0x300,
-		.end    = PA_LAN + 0x300 + 0x10 ,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = SMC_IRQ,
-		.end    = SMC_IRQ,
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device smc91x_eth_device = {
-	.name           = "smc91x",
-	.id             = 0,
-	.dev = {
-		.dma_mask               = NULL,         /* don't use dma */
-		.coherent_dma_mask      = 0xffffffff,
-	},
-	.num_resources  = ARRAY_SIZE(smc91x_eth_resources),
-	.resource       = smc91x_eth_resources,
-};
-
-static struct platform_device *se7780_devices[] __initdata = {
-	&heartbeat_device,
-	&smc91x_eth_device,
-};
-
-static int __init se7780_devices_setup(void)
-{
-	return platform_add_devices(se7780_devices,
-		ARRAY_SIZE(se7780_devices));
-}
-device_initcall(se7780_devices_setup);
-
-#define GPIO_PHCR        0xFFEA000E
-#define GPIO_PMSELR      0xFFEA0080
-#define GPIO_PECR        0xFFEA0008
-
-static void __init se7780_setup(char **cmdline_p)
-{
-	/* "SH-Linux" on LED Display */
-	__raw_writew( 'S' , PA_LED_DISP + (DISP_SEL0_ADDR << 1) );
-	__raw_writew( 'H' , PA_LED_DISP + (DISP_SEL1_ADDR << 1) );
-	__raw_writew( '-' , PA_LED_DISP + (DISP_SEL2_ADDR << 1) );
-	__raw_writew( 'L' , PA_LED_DISP + (DISP_SEL3_ADDR << 1) );
-	__raw_writew( 'i' , PA_LED_DISP + (DISP_SEL4_ADDR << 1) );
-	__raw_writew( 'n' , PA_LED_DISP + (DISP_SEL5_ADDR << 1) );
-	__raw_writew( 'u' , PA_LED_DISP + (DISP_SEL6_ADDR << 1) );
-	__raw_writew( 'x' , PA_LED_DISP + (DISP_SEL7_ADDR << 1) );
-
-	printk(KERN_INFO "Hitachi UL Solutions Engine 7780SE03 support.\n");
-
-	/*
-	 * PCI REQ/GNT setting
-	 *   REQ0/GNT0 -> USB
-	 *   REQ1/GNT1 -> PC Card
-	 *   REQ2/GNT2 -> Serial ATA
-	 *   REQ3/GNT3 -> PCI slot
-	 */
-	__raw_writew(0x0213, FPGA_REQSEL);
-
-	/* GPIO setting */
-	__raw_writew(0x0000, GPIO_PECR);
-	__raw_writew(__raw_readw(GPIO_PHCR)&0xfff3, GPIO_PHCR);
-	__raw_writew(0x0c00, GPIO_PMSELR);
-
-	/* iVDR Power ON */
-	__raw_writew(0x0001, FPGA_IVDRPW);
-}
-
-/*
- * The Machine Vector
- */
-static struct sh_machine_vector mv_se7780 __initmv = {
-	.mv_name                = "Solution Engine 7780" ,
-	.mv_setup               = se7780_setup ,
-	.mv_init_irq		= init_se7780_IRQ,
-};
diff --git a/arch/sh/boards/mach-se/Makefile b/arch/sh/boards/mach-se/Makefile
deleted file mode 100644
index 8f69fc147c733d..00000000000000
--- a/arch/sh/boards/mach-se/Makefile
+++ /dev/null
@@ -1,11 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-obj-$(CONFIG_SH_7619_SOLUTION_ENGINE)	+= board-se7619.o
-
-obj-$(CONFIG_SH_SOLUTION_ENGINE)	+= 770x/
-obj-$(CONFIG_SH_7206_SOLUTION_ENGINE)	+= 7206/
-obj-$(CONFIG_SH_7722_SOLUTION_ENGINE)	+= 7722/
-obj-$(CONFIG_SH_7751_SOLUTION_ENGINE)	+= 7751/
-obj-$(CONFIG_SH_7780_SOLUTION_ENGINE)	+= 7780/
-obj-$(CONFIG_SH_7343_SOLUTION_ENGINE)	+= 7343/
-obj-$(CONFIG_SH_7721_SOLUTION_ENGINE)	+= 7721/
-obj-$(CONFIG_SH_7724_SOLUTION_ENGINE)	+= 7724/
diff --git a/arch/sh/boards/mach-se/board-se7619.c b/arch/sh/boards/mach-se/board-se7619.c
deleted file mode 100644
index 4431da64a56f6a..00000000000000
--- a/arch/sh/boards/mach-se/board-se7619.c
+++ /dev/null
@@ -1,27 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/boards/se/7619/setup.c
- *
- * Copyright (C) 2006 Yoshinori Sato
- *
- * Hitachi SH7619 SolutionEngine Support.
- */
-
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <asm/io.h>
-#include <asm/machvec.h>
-
-static int se7619_mode_pins(void)
-{
-	return MODE_PIN2 | MODE_PIN0;
-}
-
-/*
- * The Machine Vector
- */
-
-static struct sh_machine_vector mv_se __initmv = {
-	.mv_name		= "SolutionEngine",
-	.mv_mode_pins		= se7619_mode_pins,
-};
diff --git a/arch/sh/boards/mach-sh03/Makefile b/arch/sh/boards/mach-sh03/Makefile
deleted file mode 100644
index f89c25c6a39c8a..00000000000000
--- a/arch/sh/boards/mach-sh03/Makefile
+++ /dev/null
@@ -1,7 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the Interface (CTP/PCI-SH03) specific parts of the kernel
-#
-
-obj-y	 := setup.o
-obj-$(CONFIG_RTC_DRV_GENERIC) += rtc.o
diff --git a/arch/sh/boards/mach-sh03/rtc.c b/arch/sh/boards/mach-sh03/rtc.c
deleted file mode 100644
index 7fb474844a2d1d..00000000000000
--- a/arch/sh/boards/mach-sh03/rtc.c
+++ /dev/null
@@ -1,143 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/sh03/rtc.c -- CTP/PCI-SH03 on-chip RTC support
- *
- *  Copyright (C) 2004  Saito.K & Jeanne(ksaito@interface.co.jp)
- *
- */
-
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/time.h>
-#include <linux/bcd.h>
-#include <linux/spinlock.h>
-#include <linux/io.h>
-#include <linux/rtc.h>
-#include <linux/platform_device.h>
-
-#define RTC_BASE	0xb0000000
-#define RTC_SEC1	(RTC_BASE + 0)
-#define RTC_SEC10	(RTC_BASE + 1)
-#define RTC_MIN1	(RTC_BASE + 2)
-#define RTC_MIN10	(RTC_BASE + 3)
-#define RTC_HOU1	(RTC_BASE + 4)
-#define RTC_HOU10	(RTC_BASE + 5)
-#define RTC_WEE1	(RTC_BASE + 6)
-#define RTC_DAY1	(RTC_BASE + 7)
-#define RTC_DAY10	(RTC_BASE + 8)
-#define RTC_MON1	(RTC_BASE + 9)
-#define RTC_MON10	(RTC_BASE + 10)
-#define RTC_YEA1	(RTC_BASE + 11)
-#define RTC_YEA10	(RTC_BASE + 12)
-#define RTC_YEA100	(RTC_BASE + 13)
-#define RTC_YEA1000	(RTC_BASE + 14)
-#define RTC_CTL		(RTC_BASE + 15)
-#define RTC_BUSY	1
-#define RTC_STOP	2
-
-static DEFINE_SPINLOCK(sh03_rtc_lock);
-
-static int sh03_rtc_gettimeofday(struct device *dev, struct rtc_time *tm)
-{
-	unsigned int year, mon, day, hour, min, sec;
-
-	spin_lock(&sh03_rtc_lock);
- again:
-	do {
-		sec  = (__raw_readb(RTC_SEC1) & 0xf) + (__raw_readb(RTC_SEC10) & 0x7) * 10;
-		min  = (__raw_readb(RTC_MIN1) & 0xf) + (__raw_readb(RTC_MIN10) & 0xf) * 10;
-		hour = (__raw_readb(RTC_HOU1) & 0xf) + (__raw_readb(RTC_HOU10) & 0xf) * 10;
-		day  = (__raw_readb(RTC_DAY1) & 0xf) + (__raw_readb(RTC_DAY10) & 0xf) * 10;
-		mon  = (__raw_readb(RTC_MON1) & 0xf) + (__raw_readb(RTC_MON10) & 0xf) * 10;
-		year = (__raw_readb(RTC_YEA1) & 0xf) + (__raw_readb(RTC_YEA10) & 0xf) * 10
-		     + (__raw_readb(RTC_YEA100 ) & 0xf) * 100
-		     + (__raw_readb(RTC_YEA1000) & 0xf) * 1000;
-	} while (sec != (__raw_readb(RTC_SEC1) & 0xf) + (__raw_readb(RTC_SEC10) & 0x7) * 10);
-	if (year == 0 || mon < 1 || mon > 12 || day > 31 || day < 1 ||
-	    hour > 23 || min > 59 || sec > 59) {
-		printk(KERN_ERR
-		       "SH-03 RTC: invalid value, resetting to 1 Jan 2000\n");
-		printk("year=%d, mon=%d, day=%d, hour=%d, min=%d, sec=%d\n",
-		       year, mon, day, hour, min, sec);
-
-		__raw_writeb(0, RTC_SEC1); __raw_writeb(0, RTC_SEC10);
-		__raw_writeb(0, RTC_MIN1); __raw_writeb(0, RTC_MIN10);
-		__raw_writeb(0, RTC_HOU1); __raw_writeb(0, RTC_HOU10);
-		__raw_writeb(6, RTC_WEE1);
-		__raw_writeb(1, RTC_DAY1); __raw_writeb(0, RTC_DAY10);
-		__raw_writeb(1, RTC_MON1); __raw_writeb(0, RTC_MON10);
-		__raw_writeb(0, RTC_YEA1); __raw_writeb(0, RTC_YEA10);
-		__raw_writeb(0, RTC_YEA100);
-		__raw_writeb(2, RTC_YEA1000);
-		__raw_writeb(0, RTC_CTL);
-		goto again;
-	}
-
-	spin_unlock(&sh03_rtc_lock);
-
-	tm->tm_sec  = sec;
-	tm->tm_min  = min;
-	tm->tm_hour = hour;
-	tm->tm_mday = day;
-	tm->tm_mon  = mon;
-	tm->tm_year = year - 1900;
-
-	return 0;
-}
-
-static int set_rtc_mmss(struct rtc_time *tm)
-{
-	int retval = 0;
-	int real_seconds, real_minutes, cmos_minutes;
-	int i;
-
-	/* gets recalled with irq locally disabled */
-	spin_lock(&sh03_rtc_lock);
-	for (i = 0 ; i < 1000000 ; i++)	/* may take up to 1 second... */
-		if (!(__raw_readb(RTC_CTL) & RTC_BUSY))
-			break;
-	cmos_minutes = (__raw_readb(RTC_MIN1) & 0xf) + (__raw_readb(RTC_MIN10) & 0xf) * 10;
-	real_seconds = tm->tm_sec;
-	real_minutes = tm->tm_min;
-	if (((abs(real_minutes - cmos_minutes) + 15)/30) & 1)
-		real_minutes += 30;		/* correct for half hour time zone */
-	real_minutes %= 60;
-
-	if (abs(real_minutes - cmos_minutes) < 30) {
-		__raw_writeb(real_seconds % 10, RTC_SEC1);
-		__raw_writeb(real_seconds / 10, RTC_SEC10);
-		__raw_writeb(real_minutes % 10, RTC_MIN1);
-		__raw_writeb(real_minutes / 10, RTC_MIN10);
-	} else {
-		printk_once(KERN_NOTICE
-		       "set_rtc_mmss: can't update from %d to %d\n",
-		       cmos_minutes, real_minutes);
-		retval = -EINVAL;
-	}
-	spin_unlock(&sh03_rtc_lock);
-
-	return retval;
-}
-
-int sh03_rtc_settimeofday(struct device *dev, struct rtc_time *tm)
-{
-	return set_rtc_mmss(tm);
-}
-
-static const struct rtc_class_ops rtc_generic_ops = {
-	.read_time = sh03_rtc_gettimeofday,
-	.set_time = sh03_rtc_settimeofday,
-};
-
-static int __init sh03_time_init(void)
-{
-	struct platform_device *pdev;
-
-	pdev = platform_device_register_data(NULL, "rtc-generic", -1,
-					     &rtc_generic_ops,
-					     sizeof(rtc_generic_ops));
-
-	return PTR_ERR_OR_ZERO(pdev);
-}
-arch_initcall(sh03_time_init);
diff --git a/arch/sh/boards/mach-sh03/setup.c b/arch/sh/boards/mach-sh03/setup.c
deleted file mode 100644
index 3901b6031ad565..00000000000000
--- a/arch/sh/boards/mach-sh03/setup.c
+++ /dev/null
@@ -1,97 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/sh03/setup.c
- *
- * Copyright (C) 2004  Interface Co.,Ltd. Saito.K
- *
- */
-
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/pci.h>
-#include <linux/platform_device.h>
-#include <linux/ata_platform.h>
-#include <asm/io.h>
-#include <asm/rtc.h>
-#include <mach-sh03/mach/io.h>
-#include <mach-sh03/mach/sh03.h>
-#include <asm/addrspace.h>
-
-static void __init init_sh03_IRQ(void)
-{
-	plat_irq_setup_pins(IRQ_MODE_IRQ);
-}
-
-static struct resource cf_ide_resources[] = {
-	[0] = {
-		.start  = 0x1f0,
-		.end    = 0x1f0 + 8,
-		.flags  = IORESOURCE_IO,
-	},
-	[1] = {
-		.start  = 0x1f0 + 0x206,
-		.end    = 0x1f0 +8 + 0x206 + 8,
-		.flags  = IORESOURCE_IO,
-	},
-	[2] = {
-		.start  = IRL2_IRQ,
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device cf_ide_device = {
-	.name		= "pata_platform",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(cf_ide_resources),
-	.resource	= cf_ide_resources,
-};
-
-static struct resource heartbeat_resources[] = {
-	[0] = {
-		.start	= 0xa0800000,
-		.end	= 0xa0800000,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device heartbeat_device = {
-	.name		= "heartbeat",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(heartbeat_resources),
-	.resource	= heartbeat_resources,
-};
-
-static struct platform_device *sh03_devices[] __initdata = {
-	&heartbeat_device,
-	&cf_ide_device,
-};
-
-static int __init sh03_devices_setup(void)
-{
-	pgprot_t prot;
-	unsigned long paddrbase;
-	void *cf_ide_base;
-
-	/* open I/O area window */
-	paddrbase = virt_to_phys((void *)PA_AREA5_IO);
-	prot = PAGE_KERNEL_PCC(1, _PAGE_PCC_IO16);
-	cf_ide_base = ioremap_prot(paddrbase, PAGE_SIZE, pgprot_val(prot));
-	if (!cf_ide_base) {
-		printk("allocate_cf_area : can't open CF I/O window!\n");
-		return -ENOMEM;
-	}
-
-	/* IDE cmd address : 0x1f0-0x1f7 and 0x3f6 */
-	cf_ide_resources[0].start += (unsigned long)cf_ide_base;
-	cf_ide_resources[0].end   += (unsigned long)cf_ide_base;
-	cf_ide_resources[1].start += (unsigned long)cf_ide_base;
-	cf_ide_resources[1].end   += (unsigned long)cf_ide_base;
-
-	return platform_add_devices(sh03_devices, ARRAY_SIZE(sh03_devices));
-}
-device_initcall(sh03_devices_setup);
-
-static struct sh_machine_vector mv_sh03 __initmv = {
-	.mv_name		= "Interface (CTP/PCI-SH03)",
-	.mv_init_irq		= init_sh03_IRQ,
-};
diff --git a/arch/sh/boards/mach-sh7763rdp/Makefile b/arch/sh/boards/mach-sh7763rdp/Makefile
deleted file mode 100644
index d6341310444a51..00000000000000
--- a/arch/sh/boards/mach-sh7763rdp/Makefile
+++ /dev/null
@@ -1,2 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-obj-y    := setup.o irq.o
diff --git a/arch/sh/boards/mach-sh7763rdp/irq.c b/arch/sh/boards/mach-sh7763rdp/irq.c
deleted file mode 100644
index efd382b7dad403..00000000000000
--- a/arch/sh/boards/mach-sh7763rdp/irq.c
+++ /dev/null
@@ -1,42 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/renesas/sh7763rdp/irq.c
- *
- * Renesas Solutions SH7763RDP Support.
- *
- * Copyright (C) 2008 Renesas Solutions Corp.
- * Copyright (C) 2008  Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
- */
-
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <mach/sh7763rdp.h>
-
-#define INTC_BASE		(0xFFD00000)
-#define INTC_INT2PRI7   (INTC_BASE+0x4001C)
-#define INTC_INT2MSKCR	(INTC_BASE+0x4003C)
-#define INTC_INT2MSKCR1	(INTC_BASE+0x400D4)
-
-/*
- * Initialize IRQ setting
- */
-void __init init_sh7763rdp_IRQ(void)
-{
-	/* GPIO enabled */
-	__raw_writel(1 << 25, INTC_INT2MSKCR);
-
-	/* enable GPIO interrupts */
-	__raw_writel((__raw_readl(INTC_INT2PRI7) & 0xFF00FFFF) | 0x000F0000,
-		  INTC_INT2PRI7);
-
-	/* USBH enabled */
-	__raw_writel(1 << 17, INTC_INT2MSKCR1);
-
-	/* GETHER enabled */
-	__raw_writel(1 << 16, INTC_INT2MSKCR1);
-
-	/* DMAC enabled */
-	__raw_writel(1 << 8, INTC_INT2MSKCR);
-}
diff --git a/arch/sh/boards/mach-sh7763rdp/setup.c b/arch/sh/boards/mach-sh7763rdp/setup.c
deleted file mode 100644
index 97e715e4e9b33c..00000000000000
--- a/arch/sh/boards/mach-sh7763rdp/setup.c
+++ /dev/null
@@ -1,213 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/boards/renesas/sh7763rdp/setup.c
- *
- * Renesas Solutions sh7763rdp board
- *
- * Copyright (C) 2008 Renesas Solutions Corp.
- * Copyright (C) 2008 Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
- */
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <linux/input.h>
-#include <linux/mtd/physmap.h>
-#include <linux/fb.h>
-#include <linux/io.h>
-#include <linux/sh_eth.h>
-#include <linux/sh_intc.h>
-#include <mach/sh7763rdp.h>
-#include <asm/sh7760fb.h>
-
-/* NOR Flash */
-static struct mtd_partition sh7763rdp_nor_flash_partitions[] = {
-	{
-		.name = "U-Boot",
-		.offset = 0,
-		.size = (2 * 128 * 1024),
-		.mask_flags = MTD_WRITEABLE,	/* Read-only */
-	}, {
-		.name = "Linux-Kernel",
-		.offset = MTDPART_OFS_APPEND,
-		.size = (20 * 128 * 1024),
-	}, {
-		.name = "Root Filesystem",
-		.offset = MTDPART_OFS_APPEND,
-		.size = MTDPART_SIZ_FULL,
-	},
-};
-
-static struct physmap_flash_data sh7763rdp_nor_flash_data = {
-	.width = 2,
-	.parts = sh7763rdp_nor_flash_partitions,
-	.nr_parts = ARRAY_SIZE(sh7763rdp_nor_flash_partitions),
-};
-
-static struct resource sh7763rdp_nor_flash_resources[] = {
-	[0] = {
-		.name = "NOR Flash",
-		.start = 0,
-		.end = (64 * 1024 * 1024),
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device sh7763rdp_nor_flash_device = {
-	.name = "physmap-flash",
-	.resource = sh7763rdp_nor_flash_resources,
-	.num_resources = ARRAY_SIZE(sh7763rdp_nor_flash_resources),
-	.dev = {
-		.platform_data = &sh7763rdp_nor_flash_data,
-	},
-};
-
-/*
- * SH-Ether
- *
- * SH Ether of SH7763 has multi IRQ handling.
- * (0x920,0x940,0x960 -> 0x920)
- */
-static struct resource sh_eth_resources[] = {
-	{
-		.start  = 0xFEE00800,   /* use eth1 */
-		.end    = 0xFEE00F7C - 1,
-		.flags  = IORESOURCE_MEM,
-	}, {
-		.start  = 0xFEE01800,   /* TSU */
-		.end    = 0xFEE01FFF,
-		.flags  = IORESOURCE_MEM,
-	}, {
-		.start  = evt2irq(0x920),   /* irq number */
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct sh_eth_plat_data sh7763_eth_pdata = {
-	.phy = 1,
-	.phy_interface = PHY_INTERFACE_MODE_MII,
-};
-
-static struct platform_device sh7763rdp_eth_device = {
-	.name       = "sh7763-gether",
-	.resource   = sh_eth_resources,
-	.num_resources  = ARRAY_SIZE(sh_eth_resources),
-	.dev        = {
-		.platform_data = &sh7763_eth_pdata,
-	},
-};
-
-/* SH7763 LCDC */
-static struct resource sh7763rdp_fb_resources[] = {
-	{
-		.start  = 0xFFE80000,
-		.end    = 0xFFE80442 - 1,
-		.flags  = IORESOURCE_MEM,
-	},
-};
-
-static struct fb_videomode sh7763fb_videomode = {
-	.refresh = 60,
-	.name = "VGA Monitor",
-	.xres = 640,
-	.yres = 480,
-	.pixclock = 10000,
-	.left_margin = 80,
-	.right_margin = 24,
-	.upper_margin = 30,
-	.lower_margin = 1,
-	.hsync_len = 96,
-	.vsync_len = 1,
-	.sync = 0,
-	.vmode = FB_VMODE_NONINTERLACED,
-	.flag = FBINFO_FLAG_DEFAULT,
-};
-
-static struct sh7760fb_platdata sh7763fb_def_pdata = {
-	.def_mode = &sh7763fb_videomode,
-	.ldmtr = (LDMTR_TFT_COLOR_16|LDMTR_MCNT),
-	.lddfr = LDDFR_16BPP_RGB565,
-	.ldpmmr = 0x0000,
-	.ldpspr = 0xFFFF,
-	.ldaclnr = 0x0001,
-	.ldickr = 0x1102,
-	.rotate = 0,
-	.novsync = 0,
-	.blank = NULL,
-};
-
-static struct platform_device sh7763rdp_fb_device = {
-	.name		= "sh7760-lcdc",
-	.resource	= sh7763rdp_fb_resources,
-	.num_resources = ARRAY_SIZE(sh7763rdp_fb_resources),
-	.dev = {
-		.platform_data = &sh7763fb_def_pdata,
-	},
-};
-
-static struct platform_device *sh7763rdp_devices[] __initdata = {
-	&sh7763rdp_nor_flash_device,
-	&sh7763rdp_eth_device,
-	&sh7763rdp_fb_device,
-};
-
-static int __init sh7763rdp_devices_setup(void)
-{
-	return platform_add_devices(sh7763rdp_devices,
-				    ARRAY_SIZE(sh7763rdp_devices));
-}
-device_initcall(sh7763rdp_devices_setup);
-
-static void __init sh7763rdp_setup(char **cmdline_p)
-{
-	/* Board version check */
-	if (__raw_readw(CPLD_BOARD_ID_ERV_REG) == 0xECB1)
-		printk(KERN_INFO "RTE Standard Configuration\n");
-	else
-		printk(KERN_INFO "RTA Standard Configuration\n");
-
-	/* USB pin select bits (clear bit 5-2 to 0) */
-	__raw_writew((__raw_readw(PORT_PSEL2) & 0xFFC3), PORT_PSEL2);
-	/* USBH setup port I controls to other (clear bits 4-9 to 0) */
-	__raw_writew(__raw_readw(PORT_PICR) & 0xFC0F, PORT_PICR);
-
-	/* Select USB Host controller */
-	__raw_writew(0x00, USB_USBHSC);
-
-	/* For LCD */
-	/* set PTJ7-1, bits 15-2 of PJCR to 0 */
-	__raw_writew(__raw_readw(PORT_PJCR) & 0x0003, PORT_PJCR);
-	/* set PTI5, bits 11-10 of PICR to 0 */
-	__raw_writew(__raw_readw(PORT_PICR) & 0xF3FF, PORT_PICR);
-	__raw_writew(0, PORT_PKCR);
-	__raw_writew(0, PORT_PLCR);
-	/* set PSEL2 bits 14-8, 5-4, of PSEL2 to 0 */
-	__raw_writew((__raw_readw(PORT_PSEL2) & 0x00C0), PORT_PSEL2);
-	/* set PSEL3 bits 14-12, 6-4, 2-0 of PSEL3 to 0 */
-	__raw_writew((__raw_readw(PORT_PSEL3) & 0x0700), PORT_PSEL3);
-
-	/* For HAC */
-	/* bit3-0  0100:HAC & SSI1 enable */
-	__raw_writew((__raw_readw(PORT_PSEL1) & 0xFFF0) | 0x0004, PORT_PSEL1);
-	/* bit14      1:SSI_HAC_CLK enable */
-	__raw_writew(__raw_readw(PORT_PSEL4) | 0x4000, PORT_PSEL4);
-
-	/* SH-Ether */
-	__raw_writew((__raw_readw(PORT_PSEL1) & ~0xff00) | 0x2400, PORT_PSEL1);
-	__raw_writew(0x0, PORT_PFCR);
-	__raw_writew(0x0, PORT_PFCR);
-	__raw_writew(0x0, PORT_PFCR);
-
-	/* MMC */
-	/*selects SCIF and MMC other functions */
-	__raw_writew(0x0001, PORT_PSEL0);
-	/* MMC clock operates */
-	__raw_writel(__raw_readl(MSTPCR1) & ~0x8, MSTPCR1);
-	__raw_writew(__raw_readw(PORT_PACR) & ~0x3000, PORT_PACR);
-	__raw_writew(__raw_readw(PORT_PCCR) & ~0xCFC3, PORT_PCCR);
-}
-
-static struct sh_machine_vector mv_sh7763rdp __initmv = {
-	.mv_name = "sh7763drp",
-	.mv_setup = sh7763rdp_setup,
-	.mv_init_irq = init_sh7763rdp_IRQ,
-};
diff --git a/arch/sh/boards/mach-x3proto/Makefile b/arch/sh/boards/mach-x3proto/Makefile
deleted file mode 100644
index 6caefa1145980d..00000000000000
--- a/arch/sh/boards/mach-x3proto/Makefile
+++ /dev/null
@@ -1,4 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-obj-y += setup.o ilsel.o
-
-obj-$(CONFIG_GPIOLIB)		+= gpio.o
diff --git a/arch/sh/boards/mach-x3proto/gpio.c b/arch/sh/boards/mach-x3proto/gpio.c
deleted file mode 100644
index f82d3a6a844a58..00000000000000
--- a/arch/sh/boards/mach-x3proto/gpio.c
+++ /dev/null
@@ -1,136 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/boards/mach-x3proto/gpio.c
- *
- * Renesas SH-X3 Prototype Baseboard GPIO Support.
- *
- * Copyright (C) 2010 - 2012  Paul Mundt
- */
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/gpio/driver.h>
-#include <linux/irq.h>
-#include <linux/kernel.h>
-#include <linux/spinlock.h>
-#include <linux/irqdomain.h>
-#include <linux/io.h>
-#include <mach/ilsel.h>
-#include <mach/hardware.h>
-
-#define KEYCTLR	0xb81c0000
-#define KEYOUTR	0xb81c0002
-#define KEYDETR 0xb81c0004
-
-static DEFINE_SPINLOCK(x3proto_gpio_lock);
-static struct irq_domain *x3proto_irq_domain;
-
-static int x3proto_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)
-{
-	unsigned long flags;
-	unsigned int data;
-
-	spin_lock_irqsave(&x3proto_gpio_lock, flags);
-	data = __raw_readw(KEYCTLR);
-	data |= (1 << gpio);
-	__raw_writew(data, KEYCTLR);
-	spin_unlock_irqrestore(&x3proto_gpio_lock, flags);
-
-	return 0;
-}
-
-static int x3proto_gpio_get(struct gpio_chip *chip, unsigned gpio)
-{
-	return !!(__raw_readw(KEYDETR) & (1 << gpio));
-}
-
-static int x3proto_gpio_to_irq(struct gpio_chip *chip, unsigned gpio)
-{
-	int virq;
-
-	if (gpio < chip->ngpio)
-		virq = irq_create_mapping(x3proto_irq_domain, gpio);
-	else
-		virq = -ENXIO;
-
-	return virq;
-}
-
-static void x3proto_gpio_irq_handler(struct irq_desc *desc)
-{
-	struct irq_data *data = irq_desc_get_irq_data(desc);
-	struct irq_chip *chip = irq_data_get_irq_chip(data);
-	unsigned long mask;
-	int pin;
-
-	chip->irq_mask_ack(data);
-
-	mask = __raw_readw(KEYDETR);
-	for_each_set_bit(pin, &mask, NR_BASEBOARD_GPIOS)
-		generic_handle_domain_irq(x3proto_irq_domain, pin);
-
-	chip->irq_unmask(data);
-}
-
-struct gpio_chip x3proto_gpio_chip = {
-	.label			= "x3proto-gpio",
-	.direction_input	= x3proto_gpio_direction_input,
-	.get			= x3proto_gpio_get,
-	.to_irq			= x3proto_gpio_to_irq,
-	.base			= -1,
-	.ngpio			= NR_BASEBOARD_GPIOS,
-};
-
-static int x3proto_gpio_irq_map(struct irq_domain *domain, unsigned int virq,
-				irq_hw_number_t hwirq)
-{
-	irq_set_chip_and_handler_name(virq, &dummy_irq_chip, handle_simple_irq,
-				      "gpio");
-
-	return 0;
-}
-
-static struct irq_domain_ops x3proto_gpio_irq_ops = {
-	.map	= x3proto_gpio_irq_map,
-	.xlate	= irq_domain_xlate_twocell,
-};
-
-int __init x3proto_gpio_setup(void)
-{
-	int ilsel, ret;
-
-	ilsel = ilsel_enable(ILSEL_KEY);
-	if (unlikely(ilsel < 0))
-		return ilsel;
-
-	ret = gpiochip_add_data(&x3proto_gpio_chip, NULL);
-	if (unlikely(ret))
-		goto err_gpio;
-
-	x3proto_irq_domain = irq_domain_add_linear(NULL, NR_BASEBOARD_GPIOS,
-						   &x3proto_gpio_irq_ops, NULL);
-	if (unlikely(!x3proto_irq_domain))
-		goto err_irq;
-
-	pr_info("registering '%s' support, handling GPIOs %u -> %u, "
-		"bound to IRQ %u\n",
-		x3proto_gpio_chip.label, x3proto_gpio_chip.base,
-		x3proto_gpio_chip.base + x3proto_gpio_chip.ngpio,
-		ilsel);
-
-	irq_set_chained_handler(ilsel, x3proto_gpio_irq_handler);
-	irq_set_irq_wake(ilsel, 1);
-
-	return 0;
-
-err_irq:
-	gpiochip_remove(&x3proto_gpio_chip);
-	ret = 0;
-err_gpio:
-	synchronize_irq(ilsel);
-
-	ilsel_disable(ILSEL_KEY);
-
-	return ret;
-}
diff --git a/arch/sh/boards/mach-x3proto/ilsel.c b/arch/sh/boards/mach-x3proto/ilsel.c
deleted file mode 100644
index f0d5eb41521a49..00000000000000
--- a/arch/sh/boards/mach-x3proto/ilsel.c
+++ /dev/null
@@ -1,156 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/boards/mach-x3proto/ilsel.c
- *
- * Helper routines for SH-X3 proto board ILSEL.
- *
- * Copyright (C) 2007 - 2010  Paul Mundt
- */
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/bitmap.h>
-#include <linux/io.h>
-#include <mach/ilsel.h>
-
-/*
- * ILSEL is split across:
- *
- *	ILSEL0 - 0xb8100004 [ Levels  1 -  4 ]
- *	ILSEL1 - 0xb8100006 [ Levels  5 -  8 ]
- *	ILSEL2 - 0xb8100008 [ Levels  9 - 12 ]
- *	ILSEL3 - 0xb810000a [ Levels 13 - 15 ]
- *
- * With each level being relative to an ilsel_source_t.
- */
-#define ILSEL_BASE	0xb8100004
-#define ILSEL_LEVELS	15
-
-/*
- * ILSEL level map, in descending order from the highest level down.
- *
- * Supported levels are 1 - 15 spread across ILSEL0 - ILSEL4, mapping
- * directly to IRLs. As the IRQs are numbered in reverse order relative
- * to the interrupt level, the level map is carefully managed to ensure a
- * 1:1 mapping between the bit position and the IRQ number.
- *
- * This careful constructions allows ilsel_enable*() to be referenced
- * directly for hooking up an ILSEL set and getting back an IRQ which can
- * subsequently be used for internal accounting in the (optional) disable
- * path.
- */
-static unsigned long ilsel_level_map;
-
-static inline unsigned int ilsel_offset(unsigned int bit)
-{
-	return ILSEL_LEVELS - bit - 1;
-}
-
-static inline unsigned long mk_ilsel_addr(unsigned int bit)
-{
-	return ILSEL_BASE + ((ilsel_offset(bit) >> 1) & ~0x1);
-}
-
-static inline unsigned int mk_ilsel_shift(unsigned int bit)
-{
-	return (ilsel_offset(bit) & 0x3) << 2;
-}
-
-static void __ilsel_enable(ilsel_source_t set, unsigned int bit)
-{
-	unsigned int tmp, shift;
-	unsigned long addr;
-
-	pr_notice("enabling ILSEL set %d\n", set);
-
-	addr = mk_ilsel_addr(bit);
-	shift = mk_ilsel_shift(bit);
-
-	pr_debug("%s: bit#%d: addr - 0x%08lx (shift %d, set %d)\n",
-		 __func__, bit, addr, shift, set);
-
-	tmp = __raw_readw(addr);
-	tmp &= ~(0xf << shift);
-	tmp |= set << shift;
-	__raw_writew(tmp, addr);
-}
-
-/**
- * ilsel_enable - Enable an ILSEL set.
- * @set: ILSEL source (see ilsel_source_t enum in include/asm-sh/ilsel.h).
- *
- * Enables a given non-aliased ILSEL source (<= ILSEL_KEY) at the highest
- * available interrupt level. Callers should take care to order callsites
- * noting descending interrupt levels. Aliasing FPGA and external board
- * IRQs need to use ilsel_enable_fixed().
- *
- * The return value is an IRQ number that can later be taken down with
- * ilsel_disable().
- */
-int ilsel_enable(ilsel_source_t set)
-{
-	unsigned int bit;
-
-	if (unlikely(set > ILSEL_KEY)) {
-		pr_err("Aliased sources must use ilsel_enable_fixed()\n");
-		return -EINVAL;
-	}
-
-	do {
-		bit = find_first_zero_bit(&ilsel_level_map, ILSEL_LEVELS);
-	} while (test_and_set_bit(bit, &ilsel_level_map));
-
-	__ilsel_enable(set, bit);
-
-	return bit;
-}
-EXPORT_SYMBOL_GPL(ilsel_enable);
-
-/**
- * ilsel_enable_fixed - Enable an ILSEL set at a fixed interrupt level
- * @set: ILSEL source (see ilsel_source_t enum in include/asm-sh/ilsel.h).
- * @level: Interrupt level (1 - 15)
- *
- * Enables a given ILSEL source at a fixed interrupt level. Necessary
- * both for level reservation as well as for aliased sources that only
- * exist on special ILSEL#s.
- *
- * Returns an IRQ number (as ilsel_enable()).
- */
-int ilsel_enable_fixed(ilsel_source_t set, unsigned int level)
-{
-	unsigned int bit = ilsel_offset(level - 1);
-
-	if (test_and_set_bit(bit, &ilsel_level_map))
-		return -EBUSY;
-
-	__ilsel_enable(set, bit);
-
-	return bit;
-}
-EXPORT_SYMBOL_GPL(ilsel_enable_fixed);
-
-/**
- * ilsel_disable - Disable an ILSEL set
- * @irq: Bit position for ILSEL set value (retval from enable routines)
- *
- * Disable a previously enabled ILSEL set.
- */
-void ilsel_disable(unsigned int irq)
-{
-	unsigned long addr;
-	unsigned int tmp;
-
-	pr_notice("disabling ILSEL set %d\n", irq);
-
-	addr = mk_ilsel_addr(irq);
-
-	tmp = __raw_readw(addr);
-	tmp &= ~(0xf << mk_ilsel_shift(irq));
-	__raw_writew(tmp, addr);
-
-	clear_bit(irq, &ilsel_level_map);
-}
-EXPORT_SYMBOL_GPL(ilsel_disable);
diff --git a/arch/sh/boards/mach-x3proto/setup.c b/arch/sh/boards/mach-x3proto/setup.c
deleted file mode 100644
index 95b85f2e13dda7..00000000000000
--- a/arch/sh/boards/mach-x3proto/setup.c
+++ /dev/null
@@ -1,270 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/boards/mach-x3proto/setup.c
- *
- * Renesas SH-X3 Prototype Board Support.
- *
- * Copyright (C) 2007 - 2010  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/smc91x.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <linux/input.h>
-#include <linux/usb/r8a66597.h>
-#include <linux/usb/m66592.h>
-#include <linux/gpio.h>
-#include <linux/gpio_keys.h>
-#include <mach/ilsel.h>
-#include <mach/hardware.h>
-#include <asm/smp-ops.h>
-
-static struct resource heartbeat_resources[] = {
-	[0] = {
-		.start	= 0xb8140020,
-		.end	= 0xb8140020,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device heartbeat_device = {
-	.name		= "heartbeat",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(heartbeat_resources),
-	.resource	= heartbeat_resources,
-};
-
-static struct smc91x_platdata smc91x_info = {
-	.flags	= SMC91X_USE_16BIT | SMC91X_NOWAIT,
-};
-
-static struct resource smc91x_resources[] = {
-	[0] = {
-		.start		= 0x18000300,
-		.end		= 0x18000300 + 0x10 - 1,
-		.flags		= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* Filled in by ilsel */
-		.flags		= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device smc91x_device = {
-	.name		= "smc91x",
-	.id		= -1,
-	.resource	= smc91x_resources,
-	.num_resources	= ARRAY_SIZE(smc91x_resources),
-	.dev	= {
-		.platform_data = &smc91x_info,
-	},
-};
-
-static struct r8a66597_platdata r8a66597_data = {
-	.xtal = R8A66597_PLATDATA_XTAL_12MHZ,
-	.vif = 1,
-};
-
-static struct resource r8a66597_usb_host_resources[] = {
-	[0] = {
-		.start	= 0x18040000,
-		.end	= 0x18080000 - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* Filled in by ilsel */
-		.flags	= IORESOURCE_IRQ | IRQF_TRIGGER_LOW,
-	},
-};
-
-static struct platform_device r8a66597_usb_host_device = {
-	.name		= "r8a66597_hcd",
-	.id		= -1,
-	.dev = {
-		.dma_mask		= NULL,		/* don't use dma */
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &r8a66597_data,
-	},
-	.num_resources	= ARRAY_SIZE(r8a66597_usb_host_resources),
-	.resource	= r8a66597_usb_host_resources,
-};
-
-static struct m66592_platdata usbf_platdata = {
-	.xtal = M66592_PLATDATA_XTAL_24MHZ,
-	.vif = 1,
-};
-
-static struct resource m66592_usb_peripheral_resources[] = {
-	[0] = {
-		.name	= "m66592_udc",
-		.start	= 0x18080000,
-		.end	= 0x180c0000 - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.name	= "m66592_udc",
-		/* Filled in by ilsel */
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device m66592_usb_peripheral_device = {
-	.name		= "m66592_udc",
-	.id		= -1,
-	.dev = {
-		.dma_mask		= NULL,		/* don't use dma */
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &usbf_platdata,
-	},
-	.num_resources	= ARRAY_SIZE(m66592_usb_peripheral_resources),
-	.resource	= m66592_usb_peripheral_resources,
-};
-
-static struct gpio_keys_button baseboard_buttons[NR_BASEBOARD_GPIOS] = {
-	{
-		.desc		= "key44",
-		.code		= KEY_POWER,
-		.active_low	= 1,
-		.wakeup		= 1,
-	}, {
-		.desc		= "key43",
-		.code		= KEY_SUSPEND,
-		.active_low	= 1,
-		.wakeup		= 1,
-	}, {
-		.desc		= "key42",
-		.code		= KEY_KATAKANAHIRAGANA,
-		.active_low	= 1,
-	}, {
-		.desc		= "key41",
-		.code		= KEY_SWITCHVIDEOMODE,
-		.active_low	= 1,
-	}, {
-		.desc		= "key34",
-		.code		= KEY_F12,
-		.active_low	= 1,
-	}, {
-		.desc		= "key33",
-		.code		= KEY_F11,
-		.active_low	= 1,
-	}, {
-		.desc		= "key32",
-		.code		= KEY_F10,
-		.active_low	= 1,
-	}, {
-		.desc		= "key31",
-		.code		= KEY_F9,
-		.active_low	= 1,
-	}, {
-		.desc		= "key24",
-		.code		= KEY_F8,
-		.active_low	= 1,
-	}, {
-		.desc		= "key23",
-		.code		= KEY_F7,
-		.active_low	= 1,
-	}, {
-		.desc		= "key22",
-		.code		= KEY_F6,
-		.active_low	= 1,
-	}, {
-		.desc		= "key21",
-		.code		= KEY_F5,
-		.active_low	= 1,
-	}, {
-		.desc		= "key14",
-		.code		= KEY_F4,
-		.active_low	= 1,
-	}, {
-		.desc		= "key13",
-		.code		= KEY_F3,
-		.active_low	= 1,
-	}, {
-		.desc		= "key12",
-		.code		= KEY_F2,
-		.active_low	= 1,
-	}, {
-		.desc		= "key11",
-		.code		= KEY_F1,
-		.active_low	= 1,
-	},
-};
-
-static struct gpio_keys_platform_data baseboard_buttons_data = {
-	.buttons	= baseboard_buttons,
-	.nbuttons	= ARRAY_SIZE(baseboard_buttons),
-};
-
-static struct platform_device baseboard_buttons_device = {
-	.name		= "gpio-keys",
-	.id		= -1,
-	.dev		= {
-		.platform_data	= &baseboard_buttons_data,
-	},
-};
-
-static struct platform_device *x3proto_devices[] __initdata = {
-	&heartbeat_device,
-	&smc91x_device,
-	&r8a66597_usb_host_device,
-	&m66592_usb_peripheral_device,
-	&baseboard_buttons_device,
-};
-
-static void __init x3proto_init_irq(void)
-{
-	plat_irq_setup_pins(IRQ_MODE_IRL3210);
-
-	/* Set ICR0.LVLMODE */
-	__raw_writel(__raw_readl(0xfe410000) | (1 << 21), 0xfe410000);
-}
-
-static int __init x3proto_devices_setup(void)
-{
-	int ret, i;
-
-	/*
-	 * IRLs are only needed for ILSEL mappings, so flip over the INTC
-	 * pins at a later point to enable the GPIOs to settle.
-	 */
-	x3proto_init_irq();
-
-	/*
-	 * Now that ILSELs are available, set up the baseboard GPIOs.
-	 */
-	ret = x3proto_gpio_setup();
-	if (unlikely(ret))
-		return ret;
-
-	/*
-	 * Propagate dynamic GPIOs for the baseboard button device.
-	 */
-	for (i = 0; i < ARRAY_SIZE(baseboard_buttons); i++)
-		baseboard_buttons[i].gpio = x3proto_gpio_chip.base + i;
-
-	r8a66597_usb_host_resources[1].start =
-		r8a66597_usb_host_resources[1].end = ilsel_enable(ILSEL_USBH_I);
-
-	m66592_usb_peripheral_resources[1].start =
-		m66592_usb_peripheral_resources[1].end = ilsel_enable(ILSEL_USBP_I);
-
-	smc91x_resources[1].start =
-		smc91x_resources[1].end = ilsel_enable(ILSEL_LAN);
-
-	return platform_add_devices(x3proto_devices,
-				    ARRAY_SIZE(x3proto_devices));
-}
-device_initcall(x3proto_devices_setup);
-
-static void __init x3proto_setup(char **cmdline_p)
-{
-	register_smp_ops(&shx3_smp_ops);
-}
-
-static struct sh_machine_vector mv_x3proto __initmv = {
-	.mv_name		= "x3proto",
-	.mv_setup		= x3proto_setup,
-};
diff --git a/arch/sh/boards/of-generic.c b/arch/sh/boards/of-generic.c
deleted file mode 100644
index f7f3e618e85b6a..00000000000000
--- a/arch/sh/boards/of-generic.c
+++ /dev/null
@@ -1,172 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH generic board support, using device tree
- *
- * Copyright (C) 2015-2016 Smart Energy Instruments, Inc.
- */
-
-#include <linux/of.h>
-#include <linux/of_clk.h>
-#include <linux/of_fdt.h>
-#include <linux/clocksource.h>
-#include <linux/irqchip.h>
-#include <asm/machvec.h>
-#include <asm/rtc.h>
-
-#ifdef CONFIG_SMP
-
-static void dummy_smp_setup(void)
-{
-}
-
-static void dummy_prepare_cpus(unsigned int max_cpus)
-{
-}
-
-static void dummy_start_cpu(unsigned int cpu, unsigned long entry_point)
-{
-}
-
-static unsigned int dummy_smp_processor_id(void)
-{
-	return 0;
-}
-
-static void dummy_send_ipi(unsigned int cpu, unsigned int message)
-{
-}
-
-static struct plat_smp_ops dummy_smp_ops = {
-	.smp_setup		= dummy_smp_setup,
-	.prepare_cpus		= dummy_prepare_cpus,
-	.start_cpu		= dummy_start_cpu,
-	.smp_processor_id	= dummy_smp_processor_id,
-	.send_ipi		= dummy_send_ipi,
-	.cpu_die		= native_cpu_die,
-	.cpu_disable		= native_cpu_disable,
-	.play_dead		= native_play_dead,
-};
-
-extern const struct of_cpu_method __cpu_method_of_table[];
-const struct of_cpu_method __cpu_method_of_table_sentinel
-	__section("__cpu_method_of_table_end");
-
-static void sh_of_smp_probe(void)
-{
-	struct device_node *np;
-	const char *method = NULL;
-	const struct of_cpu_method *m = __cpu_method_of_table;
-
-	pr_info("SH generic board support: scanning for cpus\n");
-
-	init_cpu_possible(cpumask_of(0));
-
-	for_each_of_cpu_node(np) {
-		u64 id = of_get_cpu_hwid(np, 0);
-
-		if (id < NR_CPUS) {
-			if (!method)
-				of_property_read_string(np, "enable-method", &method);
-			set_cpu_possible(id, true);
-			set_cpu_present(id, true);
-			__cpu_number_map[id] = id;
-			__cpu_logical_map[id] = id;
-		}
-	}
-	if (!method) {
-		np = of_find_node_by_name(NULL, "cpus");
-		of_property_read_string(np, "enable-method", &method);
-		of_node_put(np);
-	}
-
-	pr_info("CPU enable method: %s\n", method);
-	if (method)
-		for (; m->method; m++)
-			if (!strcmp(m->method, method)) {
-				register_smp_ops(m->ops);
-				return;
-			}
-
-	register_smp_ops(&dummy_smp_ops);
-}
-
-#else
-
-static void sh_of_smp_probe(void)
-{
-}
-
-#endif
-
-static void noop(void)
-{
-}
-
-static int noopi(void)
-{
-	return 0;
-}
-
-static void __init sh_of_mem_reserve(void)
-{
-	early_init_fdt_reserve_self();
-	early_init_fdt_scan_reserved_mem();
-}
-
-static void __init sh_of_setup(char **cmdline_p)
-{
-	struct device_node *root;
-
-	sh_mv.mv_name = "Unknown SH model";
-	root = of_find_node_by_path("/");
-	if (root) {
-		of_property_read_string(root, "model", &sh_mv.mv_name);
-		of_node_put(root);
-	}
-
-	sh_of_smp_probe();
-}
-
-static int sh_of_irq_demux(int irq)
-{
-	/* FIXME: eventually this should not be used at all;
-	 * the interrupt controller should set_handle_irq(). */
-	return irq;
-}
-
-static void __init sh_of_init_irq(void)
-{
-	pr_info("SH generic board support: scanning for interrupt controllers\n");
-	irqchip_init();
-}
-
-static int __init sh_of_clk_init(void)
-{
-#ifdef CONFIG_COMMON_CLK
-	/* Disabled pending move to COMMON_CLK framework. */
-	pr_info("SH generic board support: scanning for clk providers\n");
-	of_clk_init(NULL);
-#endif
-	return 0;
-}
-
-static struct sh_machine_vector __initmv sh_of_generic_mv = {
-	.mv_setup	= sh_of_setup,
-	.mv_name	= "devicetree", /* replaced by DT root's model */
-	.mv_irq_demux	= sh_of_irq_demux,
-	.mv_init_irq	= sh_of_init_irq,
-	.mv_clk_init	= sh_of_clk_init,
-	.mv_mode_pins	= noopi,
-	.mv_mem_init	= noop,
-	.mv_mem_reserve	= sh_of_mem_reserve,
-};
-
-struct sh_clk_ops;
-
-void __init __weak arch_init_clk_ops(struct sh_clk_ops **ops, int idx)
-{
-}
-
-void __init __weak plat_irq_setup(void)
-{
-}
diff --git a/arch/sh/boot/.gitignore b/arch/sh/boot/.gitignore
deleted file mode 100644
index 6603bbbc917d64..00000000000000
--- a/arch/sh/boot/.gitignore
+++ /dev/null
@@ -1,5 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-only
-zImage
-vmlinux*
-uImage*
-!vmlinux.scr
diff --git a/arch/sh/boot/Makefile b/arch/sh/boot/Makefile
deleted file mode 100644
index 1f5d2df3c7e060..00000000000000
--- a/arch/sh/boot/Makefile
+++ /dev/null
@@ -1,115 +0,0 @@
-#
-# arch/sh/boot/Makefile
-#
-# This file is subject to the terms and conditions of the GNU General Public
-# License.  See the file "COPYING" in the main directory of this archive
-# for more details.
-#
-# Copyright (C) 1999 Stuart Menefy
-#
-
-#
-# Assign safe dummy values if these variables are not defined,
-# in order to suppress error message.
-#
-CONFIG_PAGE_OFFSET	?= 0x80000000
-CONFIG_MEMORY_START	?= 0x0c000000
-CONFIG_BOOT_LINK_OFFSET	?= 0x00800000
-CONFIG_ZERO_PAGE_OFFSET	?= 0x00001000
-CONFIG_ENTRY_OFFSET	?= 0x00001000
-CONFIG_PHYSICAL_START	?= $(CONFIG_MEMORY_START)
-
-suffix_y := bin
-suffix_$(CONFIG_KERNEL_GZIP)	:= gz
-suffix_$(CONFIG_KERNEL_BZIP2)	:= bz2
-suffix_$(CONFIG_KERNEL_LZMA)	:= lzma
-suffix_$(CONFIG_KERNEL_XZ)	:= xz
-suffix_$(CONFIG_KERNEL_LZO)	:= lzo
-
-targets := zImage vmlinux.srec romImage uImage uImage.srec uImage.gz \
-	   uImage.bz2 uImage.lzma uImage.xz uImage.lzo uImage.bin \
-	   vmlinux.bin vmlinux.bin.gz vmlinux.bin.bz2 vmlinux.bin.lzma \
-	   vmlinux.bin.xz vmlinux.bin.lzo
-subdir- := compressed romimage
-
-$(obj)/zImage: $(obj)/compressed/vmlinux FORCE
-	$(call if_changed,objcopy)
-	@echo '  Kernel: $@ is ready'
-
-$(obj)/compressed/vmlinux: FORCE
-	$(Q)$(MAKE) $(build)=$(obj)/compressed $@
-
-$(obj)/romImage: $(obj)/romimage/vmlinux FORCE
-	$(call if_changed,objcopy)
-	@echo '  Kernel: $@ is ready'
-
-$(obj)/romimage/vmlinux: $(obj)/zImage FORCE
-	$(Q)$(MAKE) $(build)=$(obj)/romimage $@
-
-KERNEL_MEMORY	:= $(shell /bin/bash -c 'printf "0x%08x" \
-		     $$[$(CONFIG_PHYSICAL_START) & 0x1fffffff]')
-
-KERNEL_LOAD	:= $(shell /bin/bash -c 'printf "0x%08x" \
-		     $$[$(CONFIG_PAGE_OFFSET)  + \
-			$(KERNEL_MEMORY) + \
-			$(CONFIG_ZERO_PAGE_OFFSET)]')
-
-KERNEL_ENTRY	:= $(shell /bin/bash -c 'printf "0x%08x" \
-		     $$[$(CONFIG_PAGE_OFFSET)  + \
-			$(KERNEL_MEMORY) + \
-			$(CONFIG_ZERO_PAGE_OFFSET) + $(CONFIG_ENTRY_OFFSET)]')
-
-UIMAGE_LOADADDR = $(KERNEL_LOAD)
-UIMAGE_ENTRYADDR = $(KERNEL_ENTRY)
-
-$(obj)/vmlinux.bin: vmlinux FORCE
-	$(call if_changed,objcopy)
-
-$(obj)/vmlinux.bin.gz: $(obj)/vmlinux.bin FORCE
-	$(call if_changed,gzip)
-
-$(obj)/vmlinux.bin.bz2: $(obj)/vmlinux.bin FORCE
-	$(call if_changed,bzip2)
-
-$(obj)/vmlinux.bin.lzma: $(obj)/vmlinux.bin FORCE
-	$(call if_changed,lzma)
-
-$(obj)/vmlinux.bin.xz: $(obj)/vmlinux.bin FORCE
-	$(call if_changed,xzkern)
-
-$(obj)/vmlinux.bin.lzo: $(obj)/vmlinux.bin FORCE
-	$(call if_changed,lzo)
-
-$(obj)/uImage.bz2: $(obj)/vmlinux.bin.bz2 FORCE
-	$(call if_changed,uimage,bzip2)
-
-$(obj)/uImage.gz: $(obj)/vmlinux.bin.gz FORCE
-	$(call if_changed,uimage,gzip)
-
-$(obj)/uImage.lzma: $(obj)/vmlinux.bin.lzma FORCE
-	$(call if_changed,uimage,lzma)
-
-$(obj)/uImage.xz: $(obj)/vmlinux.bin.xz FORCE
-	$(call if_changed,uimage,xz)
-
-$(obj)/uImage.lzo: $(obj)/vmlinux.bin.lzo FORCE
-	$(call if_changed,uimage,lzo)
-
-$(obj)/uImage.bin: $(obj)/vmlinux.bin FORCE
-	$(call if_changed,uimage,none)
-
-OBJCOPYFLAGS_vmlinux.srec := -I binary -O srec
-$(obj)/vmlinux.srec: $(obj)/compressed/vmlinux FORCE
-	$(call if_changed,objcopy)
-
-OBJCOPYFLAGS_uImage.srec := -I binary -O srec
-$(obj)/uImage.srec: $(obj)/uImage FORCE
-	$(call if_changed,objcopy)
-
-$(obj)/uImage: $(obj)/uImage.$(suffix_y)
-	@ln -sf $(notdir $<) $@
-	@echo '  Image $@ is ready'
-
-export CONFIG_PAGE_OFFSET CONFIG_MEMORY_START CONFIG_BOOT_LINK_OFFSET \
-       CONFIG_PHYSICAL_START CONFIG_ZERO_PAGE_OFFSET CONFIG_ENTRY_OFFSET \
-       KERNEL_MEMORY suffix_y
diff --git a/arch/sh/boot/compressed/.gitignore b/arch/sh/boot/compressed/.gitignore
deleted file mode 100644
index cd16663bc7c84c..00000000000000
--- a/arch/sh/boot/compressed/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-only
-vmlinux.bin.*
diff --git a/arch/sh/boot/compressed/Makefile b/arch/sh/boot/compressed/Makefile
deleted file mode 100644
index 591125c42d49df..00000000000000
--- a/arch/sh/boot/compressed/Makefile
+++ /dev/null
@@ -1,66 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# linux/arch/sh/boot/compressed/Makefile
-#
-# create a compressed vmlinux image from the original vmlinux
-#
-
-OBJECTS := head_32.o misc.o cache.o piggy.o \
-           ashiftrt.o ashldi3.o ashrsi3.o ashlsi3.o lshrsi3.o
-
-# These were previously generated files. When you are building the kernel
-# with O=, make sure to remove the stale files in the output tree. Otherwise,
-# the build system wrongly compiles the stale ones.
-ifdef building_out_of_srctree
-$(shell rm -f $(addprefix $(obj)/, ashiftrt.S ashldi3.c ashrsi3.S ashlsi3.S lshrsi3.S))
-endif
-
-targets := vmlinux vmlinux.bin vmlinux.bin.gz vmlinux.bin.bz2 \
-           vmlinux.bin.lzma vmlinux.bin.xz vmlinux.bin.lzo $(OBJECTS)
-
-GCOV_PROFILE := n
-
-#
-# IMAGE_OFFSET is the load offset of the compression loader
-#
-ifeq ($(CONFIG_32BIT),y)
-IMAGE_OFFSET	:= $(shell /bin/bash -c 'printf "0x%08x" \
-		     $$[$(CONFIG_MEMORY_START)  + \
-			$(CONFIG_BOOT_LINK_OFFSET)]')
-else
-IMAGE_OFFSET	:= $(shell /bin/bash -c 'printf "0x%08x" \
-		     $$[$(CONFIG_PAGE_OFFSET)  + \
-			$(KERNEL_MEMORY) + \
-			$(CONFIG_BOOT_LINK_OFFSET)]')
-endif
-
-ccflags-remove-$(CONFIG_MCOUNT) += -pg
-
-LDFLAGS_vmlinux := --oformat $(ld-bfd) -Ttext $(IMAGE_OFFSET) -e startup \
-		   -T $(obj)/../../kernel/vmlinux.lds
-
-KBUILD_CFLAGS += -DDISABLE_BRANCH_PROFILING
-
-$(obj)/vmlinux: $(addprefix $(obj)/, $(OBJECTS)) FORCE
-	$(call if_changed,ld)
-
-$(obj)/vmlinux.bin: vmlinux FORCE
-	$(call if_changed,objcopy)
-
-$(obj)/vmlinux.bin.gz: $(obj)/vmlinux.bin FORCE
-	$(call if_changed,gzip)
-$(obj)/vmlinux.bin.bz2: $(obj)/vmlinux.bin FORCE
-	$(call if_changed,bzip2_with_size)
-$(obj)/vmlinux.bin.lzma: $(obj)/vmlinux.bin FORCE
-	$(call if_changed,lzma_with_size)
-$(obj)/vmlinux.bin.xz: $(obj)/vmlinux.bin FORCE
-	$(call if_changed,xzkern_with_size)
-$(obj)/vmlinux.bin.lzo: $(obj)/vmlinux.bin FORCE
-	$(call if_changed,lzo_with_size)
-
-OBJCOPYFLAGS += -R .empty_zero_page
-
-LDFLAGS_piggy.o := -r --format binary --oformat $(ld-bfd) -T
-
-$(obj)/piggy.o: $(obj)/vmlinux.scr $(obj)/vmlinux.bin.$(suffix_y) FORCE
-	$(call if_changed,ld)
diff --git a/arch/sh/boot/compressed/ashiftrt.S b/arch/sh/boot/compressed/ashiftrt.S
deleted file mode 100644
index 0f3b291a3f4bca..00000000000000
--- a/arch/sh/boot/compressed/ashiftrt.S
+++ /dev/null
@@ -1,2 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-#include "../../lib/ashiftrt.S"
diff --git a/arch/sh/boot/compressed/ashldi3.c b/arch/sh/boot/compressed/ashldi3.c
deleted file mode 100644
index 7cebd646df839b..00000000000000
--- a/arch/sh/boot/compressed/ashldi3.c
+++ /dev/null
@@ -1,2 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-#include "../../lib/ashldi3.c"
diff --git a/arch/sh/boot/compressed/ashlsi3.S b/arch/sh/boot/compressed/ashlsi3.S
deleted file mode 100644
index e354262b275f4d..00000000000000
--- a/arch/sh/boot/compressed/ashlsi3.S
+++ /dev/null
@@ -1,2 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-#include "../../lib/ashlsi3.S"
diff --git a/arch/sh/boot/compressed/ashrsi3.S b/arch/sh/boot/compressed/ashrsi3.S
deleted file mode 100644
index e564be9a4dcd89..00000000000000
--- a/arch/sh/boot/compressed/ashrsi3.S
+++ /dev/null
@@ -1,2 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-#include "../../lib/ashrsi3.S"
diff --git a/arch/sh/boot/compressed/cache.c b/arch/sh/boot/compressed/cache.c
deleted file mode 100644
index 31e04ff4841ed0..00000000000000
--- a/arch/sh/boot/compressed/cache.c
+++ /dev/null
@@ -1,13 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-int cache_control(unsigned int command)
-{
-	volatile unsigned int *p = (volatile unsigned int *) 0x80000000;
-	int i;
-
-	for (i = 0; i < (32 * 1024); i += 32) {
-		(void)*p;
-		p += (32 / sizeof(int));
-	}
-
-	return 0;
-}
diff --git a/arch/sh/boot/compressed/head_32.S b/arch/sh/boot/compressed/head_32.S
deleted file mode 100644
index 7bb168133dbbf8..00000000000000
--- a/arch/sh/boot/compressed/head_32.S
+++ /dev/null
@@ -1,126 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- *  linux/arch/sh/boot/compressed/head.S
- *
- *  Copyright (C) 1999 Stuart Menefy
- *  Copyright (C) 2003 SUGIOKA Toshinobu
- */
-
-.text
-
-#include <asm/page.h>
-
-	.global	startup
-startup:
-	/* Load initial status register */
-	mov.l   init_sr, r1
-	ldc     r1, sr
-
-	/* Move myself to proper location if necessary */
-	mova	1f, r0
-	mov.l	1f, r2
-	cmp/eq	r2, r0
-	bt	clear_bss
-	sub	r0, r2
-	mov.l	bss_start_addr, r0
-	mov	#0xffffffe0, r1
-	and	r1, r0			! align cache line
-	mov.l	text_start_addr, r3
-	mov	r0, r1
-	sub	r2, r1
-3:
-	mov.l	@r1, r4
-	mov.l	@(4,r1), r5
-	mov.l	@(8,r1), r6
-	mov.l	@(12,r1), r7
-	mov.l	@(16,r1), r8
-	mov.l	@(20,r1), r9
-	mov.l	@(24,r1), r10
-	mov.l	@(28,r1), r11
-	mov.l	r4, @r0
-	mov.l	r5, @(4,r0)
-	mov.l	r6, @(8,r0)
-	mov.l	r7, @(12,r0)
-	mov.l	r8, @(16,r0)
-	mov.l	r9, @(20,r0)
-	mov.l	r10, @(24,r0)
-	mov.l	r11, @(28,r0)
-#ifdef CONFIG_CPU_SH4
-	ocbwb	@r0
-#endif
-	cmp/hi	r3, r0
-	add	#-32, r0
-	bt/s	3b
-	 add	#-32, r1
-	mov.l	2f, r0
-	jmp	@r0
-	 nop
-
-	.align 2
-1:	.long	1b
-2:	.long	clear_bss
-text_start_addr:
-	.long	startup
-
-	/* Clear BSS */
-clear_bss:
-	mov.l	end_addr, r1
-	mov.l	bss_start_addr, r2
-	mov	#0, r0
-l1:
-	mov.l	r0, @-r1
-	cmp/eq	r1,r2
-	bf	l1
-
-	/* Set the initial pointer. */
-	mov.l	init_stack_addr, r0
-	mov.l	@r0, r15
-
-	/* Decompress the kernel */
-	mov.l	decompress_kernel_addr, r0
-	jsr	@r0
-	nop
-
-	/* Jump to the start of the decompressed kernel */
-	mov.l	kernel_start_addr, r0
-	jmp	@r0
-	nop
-	
-	.align	2
-bss_start_addr:
-	.long	__bss_start
-end_addr:
-	.long	_end
-init_sr:
-	.long	0x500000F0	/* Privileged mode, Bank=0, Block=1, IMASK=0xF */
-kexec_magic:
-	.long	0x400000F0	/* magic used by kexec to parse zImage format */
-init_stack_addr:
-	.long	stack_start
-decompress_kernel_addr:
-	.long	decompress_kernel
-kernel_start_addr:
-#ifdef CONFIG_32BIT
-	.long	___pa(_text+PAGE_SIZE)
-#else
-	.long	_text+PAGE_SIZE
-#endif
-
-	.align	9
-fake_headers_as_bzImage:
-	.word	0
-	.ascii	"HdrS"		! header signature
-	.word	0x0202		! header version number (>= 0x0105)
-				! or else old loadlin-1.5 will fail)
-	.word	0		! default_switch
-	.word	0		! SETUPSEG
-	.word	0x1000
-	.word	0		! pointing to kernel version string
-	.byte	0		! = 0, old one (LILO, Loadlin,
-				! 0xTV: T=0 for LILO
-				!       V = version
-	.byte	1		! Load flags bzImage=1
-	.word	0x8000		! size to move, when setup is not
-	.long	0x100000	! 0x100000 = default for big kernel
-	.long	0		! address of loaded ramdisk image
-	.long	0		# its size in bytes
diff --git a/arch/sh/boot/compressed/head_64.S b/arch/sh/boot/compressed/head_64.S
deleted file mode 100644
index 9993113c671386..00000000000000
--- a/arch/sh/boot/compressed/head_64.S
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * arch/shmedia/boot/compressed/head.S
- *
- * Copied from
- *   arch/shmedia/kernel/head.S
- * which carried the copyright:
- *   Copyright (C) 2000, 2001  Paolo Alberelli
- *
- * Modification for compressed loader:
- *   Copyright (C) 2002 Stuart Menefy (stuart.menefy@st.com)
- */
-#include <asm/cache.h>
-#include <asm/tlb.h>
-#include <cpu/mmu_context.h>
-#include <cpu/registers.h>
-
-/*
- * Fixed TLB entries to identity map the beginning of RAM
- */
-#define MMUIR_TEXT_H	0x0000000000000003 | CONFIG_MEMORY_START
-			/* Enabled, Shared, ASID 0, Eff. Add. 0xA0000000 */
-#define MMUIR_TEXT_L	0x000000000000009a | CONFIG_MEMORY_START
-			/* 512 Mb, Cacheable (Write-back), execute, Not User, Ph. Add. */
-
-#define MMUDR_CACHED_H	0x0000000000000003 | CONFIG_MEMORY_START
-			/* Enabled, Shared, ASID 0, Eff. Add. 0xA0000000 */
-#define MMUDR_CACHED_L	0x000000000000015a | CONFIG_MEMORY_START
-			/* 512 Mb, Cacheable (Write-back), read/write, Not User, Ph. Add. */
-
-#define	ICCR0_INIT_VAL	ICCR0_ON | ICCR0_ICI		/* ICE + ICI */
-#define	ICCR1_INIT_VAL	ICCR1_NOLOCK			/* No locking */
-
-#define	OCCR0_INIT_VAL	OCCR0_ON | OCCR0_OCI | OCCR0_WB	/* OCE + OCI + WB */
-#define	OCCR1_INIT_VAL	OCCR1_NOLOCK			/* No locking */
-
-	.text
-
-	.global	startup
-startup:
-	/*
-	 * Prevent speculative fetch on device memory due to
-	 * uninitialized target registers.
-	 * This must be executed before the first branch.
-	 */
-	ptabs/u	r63, tr0
-	ptabs/u	r63, tr1
-	ptabs/u	r63, tr2
-	ptabs/u	r63, tr3
-	ptabs/u	r63, tr4
-	ptabs/u	r63, tr5
-	ptabs/u	r63, tr6
-	ptabs/u	r63, tr7
-	synci
-
-	/*
-	 * Set initial TLB entries for cached and uncached regions.
-	 * Note: PTA/BLINK is PIC code, PTABS/BLINK isn't !
-	 */
-	/* Clear ITLBs */
-	pta	1f, tr1
-	movi	ITLB_FIXED, r21
-	movi	ITLB_LAST_VAR_UNRESTRICTED+TLB_STEP, r22
-1:	putcfg	r21, 0, r63		/* Clear MMUIR[n].PTEH.V */
-	addi	r21, TLB_STEP, r21
-        bne	r21, r22, tr1
-
-	/* Clear DTLBs */
-	pta	1f, tr1
-	movi	DTLB_FIXED, r21
-	movi	DTLB_LAST_VAR_UNRESTRICTED+TLB_STEP, r22
-1:	putcfg	r21, 0, r63		/* Clear MMUDR[n].PTEH.V */
-	addi	r21, TLB_STEP, r21
-        bne	r21, r22, tr1
-
-	/* Map one big (512Mb) page for ITLB */
-	movi	ITLB_FIXED, r21
-	movi	MMUIR_TEXT_L, r22	/* PTEL first */
-	putcfg	r21, 1, r22		/* Set MMUIR[0].PTEL */
-	movi	MMUIR_TEXT_H, r22	/* PTEH last */
-	putcfg	r21, 0, r22		/* Set MMUIR[0].PTEH */
-
-	/* Map one big CACHED (512Mb) page for DTLB */
-	movi	DTLB_FIXED, r21
-	movi	MMUDR_CACHED_L, r22	/* PTEL first */
-	putcfg	r21, 1, r22		/* Set MMUDR[0].PTEL */
-	movi	MMUDR_CACHED_H, r22	/* PTEH last */
-	putcfg	r21, 0, r22		/* Set MMUDR[0].PTEH */
-
-	/* ICache */
-	movi	ICCR_BASE, r21
-	movi	ICCR0_INIT_VAL, r22
-	movi	ICCR1_INIT_VAL, r23
-	putcfg	r21, ICCR_REG0, r22
-	putcfg	r21, ICCR_REG1, r23
-	synci
-
-	/* OCache */
-	movi	OCCR_BASE, r21
-	movi	OCCR0_INIT_VAL, r22
-	movi	OCCR1_INIT_VAL, r23
-	putcfg	r21, OCCR_REG0, r22
-	putcfg	r21, OCCR_REG1, r23
-	synco
-
-	/*
-	 * Enable the MMU.
-	 * From here-on code can be non-PIC.
-	 */
-	movi	SR_HARMLESS | SR_ENABLE_MMU, r22
-	putcon	r22, SSR
-	movi	1f, r22
-	putcon	r22, SPC
-	synco
-	rte				/* And now go into the hyperspace ... */
-1:					/* ... that's the next instruction ! */
-
-	/* Set initial stack pointer */
-	movi	datalabel stack_start, r0
-	ld.l	r0, 0, r15
-
-	/*
-	 * Clear bss
-	 */
-	pt	1f, tr1
-	movi	datalabel __bss_start, r22
-	movi	datalabel _end, r23
-1:	st.l	r22, 0, r63
-	addi	r22, 4, r22
-	bne	r22, r23, tr1
-
-	/*
-	 * Decompress the kernel.
-	 */
-	pt	decompress_kernel, tr0
-	blink	tr0, r18
-
-	/*
-	 * Disable the MMU.
-	 */
-	movi	SR_HARMLESS, r22
-	putcon	r22, SSR
-	movi	1f, r22
-	putcon	r22, SPC
-	synco
-	rte				/* And now go into the hyperspace ... */
-1:					/* ... that's the next instruction ! */
-
-	/* Jump into the decompressed kernel */
-	movi	datalabel (CONFIG_MEMORY_START + 0x2000)+1, r19
-	ptabs	r19, tr0
-	blink	tr0, r18
-
-	/* Shouldn't return here, but just in case, loop forever */
-	pt	1f, tr0
-1:	blink	tr0, r63
diff --git a/arch/sh/boot/compressed/lshrsi3.S b/arch/sh/boot/compressed/lshrsi3.S
deleted file mode 100644
index 5a8281b7e5161b..00000000000000
--- a/arch/sh/boot/compressed/lshrsi3.S
+++ /dev/null
@@ -1,2 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-#include "../../lib/lshrsi3.S"
diff --git a/arch/sh/boot/compressed/misc.c b/arch/sh/boot/compressed/misc.c
deleted file mode 100644
index ca05c99a3d5b48..00000000000000
--- a/arch/sh/boot/compressed/misc.c
+++ /dev/null
@@ -1,146 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/boot/compressed/misc.c
- *
- * This is a collection of several routines from gzip-1.0.3
- * adapted for Linux.
- *
- * malloc by Hannu Savolainen 1993 and Matthias Urlichs 1994
- *
- * Adapted for SH by Stuart Menefy, Aug 1999
- *
- * Modified to use standard LinuxSH BIOS by Greg Banks 7Jul2000
- */
-
-#include <linux/uaccess.h>
-#include <asm/addrspace.h>
-#include <asm/page.h>
-
-/*
- * gzip declarations
- */
-
-#define STATIC static
-
-#undef memset
-#undef memcpy
-#define memzero(s, n)     memset ((s), 0, (n))
-
-/* cache.c */
-#define CACHE_ENABLE      0
-#define CACHE_DISABLE     1
-int cache_control(unsigned int command);
-
-extern char input_data[];
-extern int input_len;
-static unsigned char *output;
-
-static void error(char *m);
-
-int puts(const char *);
-
-extern int _text;		/* Defined in vmlinux.lds.S */
-extern int _end;
-static unsigned long free_mem_ptr;
-static unsigned long free_mem_end_ptr;
-
-#ifdef CONFIG_HAVE_KERNEL_BZIP2
-#define HEAP_SIZE	0x400000
-#else
-#define HEAP_SIZE	0x10000
-#endif
-
-#ifdef CONFIG_KERNEL_GZIP
-#include "../../../../lib/decompress_inflate.c"
-#endif
-
-#ifdef CONFIG_KERNEL_BZIP2
-#include "../../../../lib/decompress_bunzip2.c"
-#endif
-
-#ifdef CONFIG_KERNEL_LZMA
-#include "../../../../lib/decompress_unlzma.c"
-#endif
-
-#ifdef CONFIG_KERNEL_XZ
-#include "../../../../lib/decompress_unxz.c"
-#endif
-
-#ifdef CONFIG_KERNEL_LZO
-#include "../../../../lib/decompress_unlzo.c"
-#endif
-
-int puts(const char *s)
-{
-	/* This should be updated to use the sh-sci routines */
-	return 0;
-}
-
-void* memset(void* s, int c, size_t n)
-{
-	int i;
-	char *ss = (char*)s;
-
-	for (i=0;i<n;i++) ss[i] = c;
-	return s;
-}
-
-void* memcpy(void* __dest, __const void* __src,
-			    size_t __n)
-{
-	int i;
-	char *d = (char *)__dest, *s = (char *)__src;
-
-	for (i=0;i<__n;i++) d[i] = s[i];
-	return __dest;
-}
-
-static void error(char *x)
-{
-	puts("\n\n");
-	puts(x);
-	puts("\n\n -- System halted");
-
-	while(1);	/* Halt */
-}
-
-const unsigned long __stack_chk_guard = 0x000a0dff;
-
-void __stack_chk_fail(void)
-{
-	error("stack-protector: Kernel stack is corrupted\n");
-}
-
-/* Needed because vmlinux.lds.h references this */
-void ftrace_stub(void)
-{
-}
-void arch_ftrace_ops_list_func(void)
-{
-}
-
-#define stackalign	4
-
-#define STACK_SIZE (4096)
-long __attribute__ ((aligned(stackalign))) user_stack[STACK_SIZE];
-long *stack_start = &user_stack[STACK_SIZE];
-
-void decompress_kernel(void)
-{
-	unsigned long output_addr;
-
-	output_addr = __pa((unsigned long)&_text+PAGE_SIZE);
-#if defined(CONFIG_29BIT)
-	output_addr |= P2SEG;
-#endif
-
-	output = (unsigned char *)output_addr;
-	free_mem_ptr = (unsigned long)&_end;
-	free_mem_end_ptr = free_mem_ptr + HEAP_SIZE;
-
-	puts("Uncompressing Linux... ");
-	cache_control(CACHE_ENABLE);
-	__decompress(input_data, input_len, NULL, NULL, output, 0, NULL, error);
-	cache_control(CACHE_DISABLE);
-	puts("Ok, booting the kernel.\n");
-}
diff --git a/arch/sh/boot/compressed/vmlinux.scr b/arch/sh/boot/compressed/vmlinux.scr
deleted file mode 100644
index dd292b4b9082b5..00000000000000
--- a/arch/sh/boot/compressed/vmlinux.scr
+++ /dev/null
@@ -1,10 +0,0 @@
-SECTIONS
-{
-  .rodata..compressed : ALIGN(8) {
-	input_len = .;
-	LONG(input_data_end - input_data) input_data = .;
-	*(.data)
-	output_len = . - 4;
-	input_data_end = .;
-	}
-}
diff --git a/arch/sh/boot/dts/Makefile b/arch/sh/boot/dts/Makefile
deleted file mode 100644
index 4a6dec9714a9e2..00000000000000
--- a/arch/sh/boot/dts/Makefile
+++ /dev/null
@@ -1,2 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-only
-obj-$(CONFIG_USE_BUILTIN_DTB) += $(addsuffix .dtb.o, $(CONFIG_BUILTIN_DTB_SOURCE))
diff --git a/arch/sh/boot/dts/j2_mimas_v2.dts b/arch/sh/boot/dts/j2_mimas_v2.dts
deleted file mode 100644
index fa9562f78d532c..00000000000000
--- a/arch/sh/boot/dts/j2_mimas_v2.dts
+++ /dev/null
@@ -1,99 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/dts-v1/;
-
-/ {
-	compatible = "jcore,j2-soc";
-	model = "J2 FPGA SoC on Mimas v2 board";
-
-	#address-cells = <1>;
-	#size-cells = <1>;
-
-	interrupt-parent = <&aic>;
-
-	cpus {
-		#address-cells = <1>;
-		#size-cells = <0>;
-
-		cpu@0 {
-			device_type = "cpu";
-			compatible = "jcore,j2";
-			reg = <0>;
-			clock-frequency = <50000000>;
-			d-cache-size = <8192>;
-			i-cache-size = <8192>;
-			d-cache-block-size = <16>;
-			i-cache-block-size = <16>;
-		};
-	};
-
-	memory@10000000 {
-		device_type = "memory";
-		reg = <0x10000000 0x4000000>;
-	};
-
-	aliases {
-		serial0 = &uart0;
-		spi0 = &spi0;
-	};
-
-	chosen {
-		stdout-path = "serial0";
-	};
-
-	soc@abcd0000 {
-		compatible = "simple-bus";
-		ranges = <0 0xabcd0000 0x100000>;
-
-		#address-cells = <1>;
-		#size-cells = <1>;
-
-		aic: interrupt-controller@200 {
-			compatible = "jcore,aic1";
-			reg = <0x200 0x10>;
-			interrupt-controller;
-			#interrupt-cells = <1>;
-		};
-
-		cache-controller@c0 {
-			compatible = "jcore,cache";
-			reg = <0xc0 4>;
-		};
-
-		timer@200 {
-			compatible = "jcore,pit";
-			reg = <0x200 0x30>;
-			interrupts = <0x48>;
-		};
-
-		spi0: spi@40 {
-			compatible = "jcore,spi2";
-
-			#address-cells = <1>;
-			#size-cells = <0>;
-
-			spi-max-frequency = <25000000>;
-
-			reg = <0x40 0x8>;
-
-			sdcard@0 {
-				compatible = "mmc-spi-slot";
-				reg = <0>;
-				spi-max-frequency = <25000000>;
-				voltage-ranges = <3200 3400>;
-				mode = <0>;
-			};
-		};
-
-		uart0: serial@100 {
-			clock-frequency = <125000000>;
-			compatible = "xlnx,xps-uartlite-1.00.a";
-			current-speed = <19200>;
-			xlnx,use-parity = <0>;
-			xlnx,data-bits = <8>;
-			device_type = "serial";
-			interrupts = <0x12>;
-			port-number = <0>;
-			reg = <0x100 0x10>;
-		};
-	};
-};
diff --git a/arch/sh/boot/romimage/Makefile b/arch/sh/boot/romimage/Makefile
deleted file mode 100644
index c7c8be58400cd9..00000000000000
--- a/arch/sh/boot/romimage/Makefile
+++ /dev/null
@@ -1,30 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# linux/arch/sh/boot/romimage/Makefile
-#
-# create an romImage file suitable for burning to flash/mmc from zImage
-#
-
-targets		:= vmlinux head.o zeropage.bin piggy.o
-load-y		:= 0
-
-mmcif-load-$(CONFIG_CPU_SUBTYPE_SH7724)	:= 0xe5200000 # ILRAM
-mmcif-obj-$(CONFIG_CPU_SUBTYPE_SH7724)	:= $(obj)/mmcif-sh7724.o
-load-$(CONFIG_ROMIMAGE_MMCIF)		:= $(mmcif-load-y)
-obj-$(CONFIG_ROMIMAGE_MMCIF)		:= $(mmcif-obj-y)
-
-LDFLAGS_vmlinux := --oformat $(ld-bfd) -Ttext $(load-y) -e romstart \
-		   -T $(obj)/../../kernel/vmlinux.lds
-
-$(obj)/vmlinux: $(obj)/head.o $(obj-y) $(obj)/piggy.o FORCE
-	$(call if_changed,ld)
-
-OBJCOPYFLAGS += -j .empty_zero_page
-
-$(obj)/zeropage.bin: vmlinux FORCE
-	$(call if_changed,objcopy)
-
-LDFLAGS_piggy.o := -r --format binary --oformat $(ld-bfd) -T
-
-$(obj)/piggy.o: $(obj)/vmlinux.scr $(obj)/zeropage.bin arch/sh/boot/zImage FORCE
-	$(call if_changed,ld)
diff --git a/arch/sh/boot/romimage/head.S b/arch/sh/boot/romimage/head.S
deleted file mode 100644
index 81a0652a3dff4b..00000000000000
--- a/arch/sh/boot/romimage/head.S
+++ /dev/null
@@ -1,85 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- *  linux/arch/sh/boot/romimage/head.S
- *
- * Board specific setup code, executed before zImage loader
- */
-
-.text
-	#include <asm/page.h>
-
-	.global	romstart
-romstart:
-	/* include board specific setup code */
-#include <mach/romimage.h>
-
-#ifdef CONFIG_ROMIMAGE_MMCIF
-	/* load the romImage to above the empty zero page */
-	mov.l	empty_zero_page_dst, r4
-	mov.l	empty_zero_page_dst_adj, r5
-	add	r5, r4
-	mov.l	bytes_to_load, r5
-	mov.l	loader_function, r7
-	jsr	@r7
-	 mov	r4, r15
-
-	mov.l	empty_zero_page_dst, r4
-	mov.l	empty_zero_page_dst_adj, r5
-	add	r5, r4
-	mov.l	loaded_code_offs, r5
-	add	r5, r4
-	jmp	@r4
-	 nop
-
-	.balign 4
-empty_zero_page_dst_adj:
-	.long	PAGE_SIZE
-bytes_to_load:
-	.long	end_data - romstart
-loader_function:
-	.long	mmcif_loader
-loaded_code_offs:
-	.long	loaded_code - romstart
-loaded_code:
-#endif /* CONFIG_ROMIMAGE_MMCIF */
-
-	/* copy the empty_zero_page contents to where vmlinux expects it */
-	mova	extra_data_pos, r0
-	mov.l	extra_data_size, r1
-	add	r1, r0
-	mov.l	empty_zero_page_dst, r1
-	mov	#(PAGE_SHIFT - 4), r4
-	mov	#1, r3
-	shld	r4, r3 /* r3 = PAGE_SIZE / 16 */
-
-1:
-	mov.l	@r0, r4
-	mov.l	@(4, r0), r5
-	mov.l	@(8, r0), r6
-	mov.l	@(12, r0), r7
-	add	#16,r0
-	mov.l	r4, @r1
-	mov.l	r5, @(4, r1)
-	mov.l	r6, @(8, r1)
-	mov.l	r7, @(12, r1)
-	dt	r3
-	add	#16,r1
-	bf	1b
-
-	/* jump to the zImage entry point located after the zero page data */
-	mov	#PAGE_SHIFT, r4
-	mov	#1, r1
-	shld	r4, r1
-	mova	extra_data_pos, r0
-	add	r1, r0
-	mov.l	extra_data_size, r1
-	add	r1, r0
-	jmp	@r0
-	 nop
-
-	.align 2
-empty_zero_page_dst:
-	.long	_text
-extra_data_pos:
-extra_data_size:
-	.long	zero_page_pos - extra_data_pos
diff --git a/arch/sh/boot/romimage/mmcif-sh7724.c b/arch/sh/boot/romimage/mmcif-sh7724.c
deleted file mode 100644
index d30123d859e054..00000000000000
--- a/arch/sh/boot/romimage/mmcif-sh7724.c
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * sh7724 MMCIF loader
- *
- * Copyright (C) 2010 Magnus Damm
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- */
-
-#include <linux/platform_data/sh_mmcif.h>
-#include <mach/romimage.h>
-
-#define MMCIF_BASE      (void __iomem *)0xa4ca0000
-
-#define MSTPCR2		0xa4150038
-#define PTWCR		0xa4050146
-#define PTXCR		0xa4050148
-#define PSELA		0xa405014e
-#define PSELE		0xa4050156
-#define HIZCRC		0xa405015c
-#define DRVCRA		0xa405018a
-
-enum {
-	MMCIF_PROGRESS_ENTER,
-	MMCIF_PROGRESS_INIT,
-	MMCIF_PROGRESS_LOAD,
-	MMCIF_PROGRESS_DONE
-};
-
-/* SH7724 specific MMCIF loader
- *
- * loads the romImage from an MMC card starting from block 512
- * use the following line to write the romImage to an MMC card
- * # dd if=arch/sh/boot/romImage of=/dev/sdx bs=512 seek=512
- */
-asmlinkage void mmcif_loader(unsigned char *buf, unsigned long no_bytes)
-{
-	mmcif_update_progress(MMCIF_PROGRESS_ENTER);
-
-	/* enable clock to the MMCIF hardware block */
-	__raw_writel(__raw_readl(MSTPCR2) & ~0x20000000, MSTPCR2);
-
-	/* setup pins D7-D0 */
-	__raw_writew(0x0000, PTWCR);
-
-	/* setup pins MMC_CLK, MMC_CMD */
-	__raw_writew(__raw_readw(PTXCR) & ~0x000f, PTXCR);
-
-	/* select D3-D0 pin function */
-	__raw_writew(__raw_readw(PSELA) & ~0x2000, PSELA);
-
-	/* select D7-D4 pin function */
-	__raw_writew(__raw_readw(PSELE) & ~0x3000, PSELE);
-
-	/* disable Hi-Z for the MMC pins */
-	__raw_writew(__raw_readw(HIZCRC) & ~0x0620, HIZCRC);
-
-	/* high drive capability for MMC pins */
-	__raw_writew(__raw_readw(DRVCRA) | 0x3000, DRVCRA);
-
-	mmcif_update_progress(MMCIF_PROGRESS_INIT);
-
-	/* setup MMCIF hardware */
-	sh_mmcif_boot_init(MMCIF_BASE);
-
-	mmcif_update_progress(MMCIF_PROGRESS_LOAD);
-
-	/* load kernel via MMCIF interface */
-	sh_mmcif_boot_do_read(MMCIF_BASE, 512,
-	                      (no_bytes + SH_MMCIF_BBS - 1) / SH_MMCIF_BBS,
-			      buf);
-
-	/* disable clock to the MMCIF hardware block */
-	__raw_writel(__raw_readl(MSTPCR2) | 0x20000000, MSTPCR2);
-
-	mmcif_update_progress(MMCIF_PROGRESS_DONE);
-}
diff --git a/arch/sh/boot/romimage/vmlinux.scr b/arch/sh/boot/romimage/vmlinux.scr
deleted file mode 100644
index 590394e2f5f2e4..00000000000000
--- a/arch/sh/boot/romimage/vmlinux.scr
+++ /dev/null
@@ -1,8 +0,0 @@
-SECTIONS
-{
-  .text : {
-	zero_page_pos = .;
-	*(.data)
-	end_data = .;
-	}
-}
diff --git a/arch/sh/cchips/Kconfig b/arch/sh/cchips/Kconfig
deleted file mode 100644
index efde2edb562780..00000000000000
--- a/arch/sh/cchips/Kconfig
+++ /dev/null
@@ -1,46 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-menu "Companion Chips"
-
-config HD6446X_SERIES
-	bool
-
-choice
-	prompt "HD6446x options"
-	depends on HD6446X_SERIES
-	default HD64461
-
-config HD64461
-	bool "Hitachi HD64461 companion chip support"
-	help
-	  The Hitachi HD64461 provides an interface for
-	  the SH7709 CPU, supporting a LCD controller,
-	  CRT color controller, IrDA up to 4 Mbps, and a
-	  PCMCIA controller supporting 2 slots.
-
-	  More information is available at
-	  <http://semiconductor.hitachi.com/windowsce/superh/sld013.htm>.
-
-	  Say Y if you want support for the HD64461.
-	  Otherwise, say N.
-
-endchoice
-
-# These will also be split into the Kconfig's below
-config HD64461_IRQ
-	int "HD64461 IRQ"
-	depends on HD64461
-	default "36"
-	help
-	  The default setting of the HD64461 IRQ is 36.
-
-	  Do not change this unless you know what you are doing.
-
-config HD64461_ENABLER
-	bool "HD64461 PCMCIA enabler"
-	depends on HD64461
-	help
-	  Say Y here if you want to enable PCMCIA support
-	  via the HD64461 companion chip.
-	  Otherwise, say N.
-
-endmenu
diff --git a/arch/sh/cchips/hd6446x/Makefile b/arch/sh/cchips/hd6446x/Makefile
deleted file mode 100644
index 6673e0abef2ed8..00000000000000
--- a/arch/sh/cchips/hd6446x/Makefile
+++ /dev/null
@@ -1,4 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-only
-obj-$(CONFIG_HD64461)	+= hd64461.o
-
-ccflags-y := -Werror
diff --git a/arch/sh/cchips/hd6446x/hd64461.c b/arch/sh/cchips/hd6446x/hd64461.c
deleted file mode 100644
index f3fba967445aca..00000000000000
--- a/arch/sh/cchips/hd6446x/hd64461.c
+++ /dev/null
@@ -1,112 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- *	Copyright (C) 2000 YAEGASHI Takeshi
- *	Hitachi HD64461 companion chip support
- */
-
-#include <linux/sched.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/param.h>
-#include <linux/interrupt.h>
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/io.h>
-#include <asm/irq.h>
-#include <asm/hd64461.h>
-
-/* This belongs in cpu specific */
-#define INTC_ICR1 0xA4140010UL
-
-static void hd64461_mask_irq(struct irq_data *data)
-{
-	unsigned int irq = data->irq;
-	unsigned short nimr;
-	unsigned short mask = 1 << (irq - HD64461_IRQBASE);
-
-	nimr = __raw_readw(HD64461_NIMR);
-	nimr |= mask;
-	__raw_writew(nimr, HD64461_NIMR);
-}
-
-static void hd64461_unmask_irq(struct irq_data *data)
-{
-	unsigned int irq = data->irq;
-	unsigned short nimr;
-	unsigned short mask = 1 << (irq - HD64461_IRQBASE);
-
-	nimr = __raw_readw(HD64461_NIMR);
-	nimr &= ~mask;
-	__raw_writew(nimr, HD64461_NIMR);
-}
-
-static void hd64461_mask_and_ack_irq(struct irq_data *data)
-{
-	hd64461_mask_irq(data);
-
-#ifdef CONFIG_HD64461_ENABLER
-	if (data->irq == HD64461_IRQBASE + 13)
-		__raw_writeb(0x00, HD64461_PCC1CSCR);
-#endif
-}
-
-static struct irq_chip hd64461_irq_chip = {
-	.name		= "HD64461-IRQ",
-	.irq_mask	= hd64461_mask_irq,
-	.irq_mask_ack	= hd64461_mask_and_ack_irq,
-	.irq_unmask	= hd64461_unmask_irq,
-};
-
-static void hd64461_irq_demux(struct irq_desc *desc)
-{
-	unsigned short intv = __raw_readw(HD64461_NIRR);
-	unsigned int ext_irq = HD64461_IRQBASE;
-
-	intv &= (1 << HD64461_IRQ_NUM) - 1;
-
-	for (; intv; intv >>= 1, ext_irq++) {
-		if (!(intv & 1))
-			continue;
-
-		generic_handle_irq(ext_irq);
-	}
-}
-
-int __init setup_hd64461(void)
-{
-	int irq_base, i;
-
-	printk(KERN_INFO
-	       "HD64461 configured at 0x%x on irq %d(mapped into %d to %d)\n",
-	       HD64461_IOBASE, CONFIG_HD64461_IRQ, HD64461_IRQBASE,
-	       HD64461_IRQBASE + 15);
-
-/* Should be at processor specific part.. */
-#if defined(CONFIG_CPU_SUBTYPE_SH7709)
-	__raw_writew(0x2240, INTC_ICR1);
-#endif
-	__raw_writew(0xffff, HD64461_NIMR);
-
-	irq_base = irq_alloc_descs(HD64461_IRQBASE, HD64461_IRQBASE, 16, -1);
-	if (IS_ERR_VALUE(irq_base)) {
-		pr_err("%s: failed hooking irqs for HD64461\n", __func__);
-		return irq_base;
-	}
-
-	for (i = 0; i < 16; i++)
-		irq_set_chip_and_handler(irq_base + i, &hd64461_irq_chip,
-					 handle_level_irq);
-
-	irq_set_chained_handler(CONFIG_HD64461_IRQ, hd64461_irq_demux);
-	irq_set_irq_type(CONFIG_HD64461_IRQ, IRQ_TYPE_LEVEL_LOW);
-
-#ifdef CONFIG_HD64461_ENABLER
-	printk(KERN_INFO "HD64461: enabling PCMCIA devices\n");
-	__raw_writeb(0x4c, HD64461_PCC1CSCIER);
-	__raw_writeb(0x00, HD64461_PCC1CSCR);
-#endif
-
-	return 0;
-}
-
-module_init(setup_hd64461);
diff --git a/arch/sh/configs/ap325rxa_defconfig b/arch/sh/configs/ap325rxa_defconfig
deleted file mode 100644
index 4d83576b89c665..00000000000000
--- a/arch/sh/configs/ap325rxa_defconfig
+++ /dev/null
@@ -1,103 +0,0 @@
-# CONFIG_LOCALVERSION_AUTO is not set
-CONFIG_SYSVIPC=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_KALLSYMS is not set
-CONFIG_SLAB=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7723=y
-CONFIG_MEMORY_SIZE=0x08000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_AP325RXA=y
-# CONFIG_SH_TIMER_CMT is not set
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_SECCOMP=y
-CONFIG_PREEMPT=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=tty1 console=ttySC5,38400 root=/dev/nfs ip=dhcp"
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_IPV6 is not set
-CONFIG_MTD=y
-CONFIG_MTD_CMDLINE_PARTS=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_PHYSMAP=y
-CONFIG_MTD_RAW_NAND=y
-CONFIG_MTD_NAND_SH_FLCTL=y
-CONFIG_MTD_UBI=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_COUNT=4
-CONFIG_SCSI=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_NETDEVICES=y
-CONFIG_SMSC_PHY=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SMSC911X=y
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_VT_HW_CONSOLE_BINDING=y
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=6
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_HW_RANDOM=y
-CONFIG_I2C=y
-CONFIG_I2C_CHARDEV=y
-CONFIG_I2C_SH_MOBILE=y
-CONFIG_SPI=y
-CONFIG_SPI_GPIO=y
-# CONFIG_HWMON is not set
-CONFIG_MEDIA_SUPPORT=y
-CONFIG_VIDEO_DEV=y
-# CONFIG_VIDEO_ALLOW_V4L1 is not set
-# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
-CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
-CONFIG_VIDEO_SH_MOBILE_CEU=y
-# CONFIG_RADIO_ADAPTERS is not set
-CONFIG_FB=y
-CONFIG_FB_SH_MOBILE_LCDC=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_LOGO=y
-# CONFIG_USB_SUPPORT is not set
-CONFIG_MMC=y
-CONFIG_MMC_SPI=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_PCF8563=y
-CONFIG_UIO=y
-CONFIG_UIO_PDRV_GENIRQ=y
-CONFIG_EXT2_FS=y
-CONFIG_EXT2_FS_XATTR=y
-CONFIG_EXT2_FS_POSIX_ACL=y
-CONFIG_EXT2_FS_SECURITY=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_EXT3_FS_POSIX_ACL=y
-CONFIG_EXT3_FS_SECURITY=y
-CONFIG_VFAT_FS=y
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_ROOT_NFS=y
-CONFIG_NFSD=y
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_CODEPAGE_932=y
-CONFIG_NLS_ISO8859_1=y
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_CRYPTO=y
-CONFIG_CRYPTO_CBC=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRC_T10DIF=y
diff --git a/arch/sh/configs/apsh4a3a_defconfig b/arch/sh/configs/apsh4a3a_defconfig
deleted file mode 100644
index 99931a13a74da9..00000000000000
--- a/arch/sh/configs/apsh4a3a_defconfig
+++ /dev/null
@@ -1,91 +0,0 @@
-CONFIG_SYSVIPC=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_SLAB=y
-CONFIG_PROFILING=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7785=y
-CONFIG_MEMORY_START=0x0C000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_STORE_QUEUES=y
-CONFIG_SH_APSH4A3A=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_KEXEC=y
-CONFIG_PREEMPT=y
-# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_IPV6 is not set
-# CONFIG_WIRELESS is not set
-# CONFIG_FW_LOADER is not set
-CONFIG_MTD=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_PHYSMAP=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_SIZE=16384
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SMSC911X=y
-# CONFIG_WLAN is not set
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_VT_HW_CONSOLE_BINDING=y
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=6
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_HW_RANDOM=y
-# CONFIG_HWMON is not set
-CONFIG_FB=y
-CONFIG_FB_SH7785FB=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_FONTS=y
-CONFIG_FONT_8x8=y
-CONFIG_FONT_8x16=y
-CONFIG_LOGO=y
-# CONFIG_USB_SUPPORT is not set
-CONFIG_EXT2_FS=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_MSDOS_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_NTFS_FS=y
-CONFIG_NTFS_RW=y
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_JFFS2_FS=y
-CONFIG_CRAMFS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_NFS_V4=y
-CONFIG_CIFS=y
-CONFIG_NLS_DEFAULT="utf8"
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_CODEPAGE_932=y
-CONFIG_NLS_ASCII=y
-CONFIG_NLS_ISO8859_1=y
-CONFIG_NLS_UTF8=y
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_DEBUG_FS=y
-CONFIG_DEBUG_KERNEL=y
-# CONFIG_DEBUG_PREEMPT is not set
-# CONFIG_DEBUG_BUGVERBOSE is not set
-CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
-# CONFIG_FTRACE is not set
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-# CONFIG_CRYPTO_HW is not set
diff --git a/arch/sh/configs/apsh4ad0a_defconfig b/arch/sh/configs/apsh4ad0a_defconfig
deleted file mode 100644
index d9fb124bf015a2..00000000000000
--- a/arch/sh/configs/apsh4ad0a_defconfig
+++ /dev/null
@@ -1,122 +0,0 @@
-CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_RCU_TRACE=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_CGROUPS=y
-CONFIG_CGROUP_FREEZER=y
-CONFIG_CGROUP_DEVICE=y
-CONFIG_CGROUP_CPUACCT=y
-CONFIG_CGROUP_MEMCG=y
-CONFIG_BLK_CGROUP=y
-CONFIG_NAMESPACES=y
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_KALLSYMS_ALL=y
-# CONFIG_COMPAT_BRK is not set
-CONFIG_SLAB=y
-CONFIG_PROFILING=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_IOSCHED_BFQ=y
-CONFIG_BFQ_GROUP_IOSCHED=y
-CONFIG_CPU_SUBTYPE_SH7786=y
-CONFIG_MEMORY_SIZE=0x10000000
-CONFIG_HUGETLB_PAGE_SIZE_1MB=y
-CONFIG_MEMORY_HOTPLUG=y
-CONFIG_MEMORY_HOTREMOVE=y
-CONFIG_KSM=y
-CONFIG_SH_STORE_QUEUES=y
-CONFIG_SH_APSH4AD0A=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_GOV_POWERSAVE=m
-CONFIG_CPU_FREQ_GOV_USERSPACE=m
-CONFIG_CPU_FREQ_GOV_ONDEMAND=m
-CONFIG_CPU_FREQ_GOV_CONSERVATIVE=m
-CONFIG_SH_CPU_FREQ=y
-CONFIG_KEXEC=y
-CONFIG_SECCOMP=y
-CONFIG_PREEMPT=y
-# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
-CONFIG_BINFMT_MISC=y
-CONFIG_PM=y
-CONFIG_PM_DEBUG=y
-CONFIG_PM=y
-CONFIG_CPU_IDLE=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-# CONFIG_IPV6 is not set
-# CONFIG_WIRELESS is not set
-# CONFIG_FW_LOADER is not set
-CONFIG_MTD=y
-CONFIG_MTD_CFI=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_SIZE=16384
-CONFIG_SCSI=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_SCSI_MULTI_LUN=y
-# CONFIG_SCSI_LOWLEVEL is not set
-CONFIG_NETDEVICES=y
-CONFIG_MDIO_BITBANG=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SMSC911X=y
-# CONFIG_WLAN is not set
-CONFIG_INPUT_EVDEV=y
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=6
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_HWMON is not set
-CONFIG_FB=y
-CONFIG_FB_SH7785FB=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_FONTS=y
-CONFIG_FONT_8x8=y
-CONFIG_FONT_8x16=y
-CONFIG_LOGO=y
-CONFIG_USB=y
-CONFIG_USB_MON=y
-CONFIG_USB_OHCI_HCD=y
-CONFIG_USB_STORAGE=y
-CONFIG_EXT2_FS=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_MSDOS_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_NTFS_FS=y
-CONFIG_NTFS_RW=y
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_HUGETLBFS=y
-CONFIG_JFFS2_FS=y
-CONFIG_CRAMFS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_NFS_V4=y
-CONFIG_CIFS=y
-CONFIG_NLS_DEFAULT="utf8"
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_CODEPAGE_932=y
-CONFIG_NLS_ASCII=y
-CONFIG_NLS_ISO8859_1=y
-CONFIG_NLS_UTF8=y
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_MAGIC_SYSRQ=y
-CONFIG_DEBUG_KERNEL=y
-CONFIG_DEBUG_SHIRQ=y
-CONFIG_DETECT_HUNG_TASK=y
-CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
-CONFIG_DEBUG_VM=y
-CONFIG_DWARF_UNWINDER=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
diff --git a/arch/sh/configs/dreamcast_defconfig b/arch/sh/configs/dreamcast_defconfig
deleted file mode 100644
index 6a82c7b8ff32b8..00000000000000
--- a/arch/sh/configs/dreamcast_defconfig
+++ /dev/null
@@ -1,72 +0,0 @@
-CONFIG_SYSVIPC=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_SLAB=y
-CONFIG_PROFILING=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7091=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_MEMORY_SIZE=0x01000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_STORE_QUEUES=y
-CONFIG_SH_DREAMCAST=y
-CONFIG_SH_PCLK_FREQ=49876504
-CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_GOV_POWERSAVE=y
-CONFIG_CPU_FREQ_GOV_USERSPACE=y
-CONFIG_SH_DMA=y
-CONFIG_SH_DMA_API=y
-CONFIG_NR_DMA_CHANNELS_BOOL=y
-CONFIG_NR_DMA_CHANNELS=9
-CONFIG_SECCOMP=y
-CONFIG_PREEMPT=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC1,115200 panic=3"
-CONFIG_MAPLE=y
-CONFIG_PCI=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-# CONFIG_IPV6 is not set
-# CONFIG_STANDALONE is not set
-# CONFIG_FW_LOADER is not set
-CONFIG_GDROM=y
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_NET_PCI=y
-CONFIG_8139TOO=y
-# CONFIG_8139TOO_PIO is not set
-# CONFIG_KEYBOARD_ATKBD is not set
-CONFIG_KEYBOARD_MAPLE=y
-# CONFIG_MOUSE_PS2 is not set
-# CONFIG_SERIO_SERPORT is not set
-CONFIG_SERIO_LIBPS2=y
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_HW_RANDOM=y
-# CONFIG_HWMON is not set
-CONFIG_WATCHDOG=y
-CONFIG_SH_WDT=y
-CONFIG_FB=y
-CONFIG_FIRMWARE_EDID=y
-CONFIG_FB_PVR2=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_FONTS=y
-CONFIG_FONT_8x8=y
-CONFIG_FONT_8x16=y
-CONFIG_LOGO=y
-# CONFIG_LOGO_LINUX_MONO is not set
-# CONFIG_LOGO_LINUX_VGA16 is not set
-# CONFIG_LOGO_LINUX_CLUT224 is not set
-# CONFIG_LOGO_SUPERH_MONO is not set
-# CONFIG_LOGO_SUPERH_VGA16 is not set
-# CONFIG_DNOTIFY is not set
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_HUGETLBFS=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_GENERIC=y
diff --git a/arch/sh/configs/ecovec24-romimage_defconfig b/arch/sh/configs/ecovec24-romimage_defconfig
deleted file mode 100644
index 5c60e71d839e05..00000000000000
--- a/arch/sh/configs/ecovec24-romimage_defconfig
+++ /dev/null
@@ -1,58 +0,0 @@
-# CONFIG_LOCALVERSION_AUTO is not set
-CONFIG_SYSVIPC=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_KALLSYMS is not set
-CONFIG_SLAB=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7724=y
-CONFIG_MEMORY_SIZE=0x10000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_ECOVEC=y
-# CONFIG_SH_TIMER_TMU is not set
-CONFIG_KEXEC=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC0,115200"
-# CONFIG_SUSPEND is not set
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_IPV6 is not set
-CONFIG_SCSI=y
-CONFIG_BLK_DEV_SD=y
-# CONFIG_SCSI_LOWLEVEL is not set
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SH_ETH=y
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_VT_HW_CONSOLE_BINDING=y
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=6
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_I2C=y
-CONFIG_I2C_SH_MOBILE=y
-CONFIG_GPIO_SYSFS=y
-# CONFIG_HWMON is not set
-CONFIG_USB=y
-CONFIG_USB_R8A66597_HCD=y
-CONFIG_USB_STORAGE=y
-CONFIG_EXT2_FS=y
-# CONFIG_DNOTIFY is not set
-# CONFIG_INOTIFY_USER is not set
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-# CONFIG_MISC_FILESYSTEMS is not set
-# CONFIG_NETWORK_FILESYSTEMS is not set
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_DEBUG_FS=y
diff --git a/arch/sh/configs/ecovec24_defconfig b/arch/sh/configs/ecovec24_defconfig
deleted file mode 100644
index b52e14ccb450d4..00000000000000
--- a/arch/sh/configs/ecovec24_defconfig
+++ /dev/null
@@ -1,132 +0,0 @@
-# CONFIG_LOCALVERSION_AUTO is not set
-CONFIG_SYSVIPC=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_KALLSYMS is not set
-CONFIG_SLAB=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7724=y
-CONFIG_ARCH_FORCE_MAX_ORDER=12
-CONFIG_MEMORY_SIZE=0x10000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_ECOVEC=y
-# CONFIG_SH_TIMER_CMT is not set
-CONFIG_HEARTBEAT=y
-CONFIG_SECCOMP=y
-CONFIG_PREEMPT=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=tty0, console=ttySC0,115200 root=/dev/nfs ip=dhcp mem=248M memchunk.vpu=8m memchunk.veu0=4m"
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_IPV6 is not set
-CONFIG_MTD=y
-CONFIG_MTD_CMDLINE_PARTS=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_PHYSMAP=y
-CONFIG_MTD_RAW_NAND=y
-CONFIG_MTD_UBI=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_COUNT=4
-CONFIG_SCSI=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_NETDEVICES=y
-CONFIG_SMSC_PHY=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SH_ETH=y
-# CONFIG_INPUT_MOUSEDEV is not set
-CONFIG_INPUT_EVDEV=y
-# CONFIG_KEYBOARD_ATKBD is not set
-CONFIG_KEYBOARD_SH_KEYSC=y
-# CONFIG_INPUT_MOUSE is not set
-CONFIG_INPUT_TOUCHSCREEN=y
-CONFIG_TOUCHSCREEN_TSC2007=y
-# CONFIG_SERIO is not set
-CONFIG_VT_HW_CONSOLE_BINDING=y
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=6
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_LEGACY_PTYS is not set
-CONFIG_HW_RANDOM=y
-CONFIG_I2C=y
-CONFIG_I2C_CHARDEV=y
-CONFIG_I2C_SH_MOBILE=y
-CONFIG_SPI=y
-CONFIG_SPI_BITBANG=y
-# CONFIG_HWMON is not set
-CONFIG_MFD_SH_MOBILE_SDHI=y
-CONFIG_MEDIA_SUPPORT=y
-CONFIG_VIDEO_DEV=y
-# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
-CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
-CONFIG_VIDEO_SH_MOBILE_CEU=y
-# CONFIG_V4L_USB_DRIVERS is not set
-CONFIG_FB=y
-CONFIG_FB_SH_MOBILE_LCDC=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_LOGO=y
-# CONFIG_LOGO_LINUX_MONO is not set
-# CONFIG_LOGO_LINUX_VGA16 is not set
-# CONFIG_LOGO_LINUX_CLUT224 is not set
-# CONFIG_LOGO_SUPERH_MONO is not set
-# CONFIG_LOGO_SUPERH_VGA16 is not set
-CONFIG_SOUND=y
-CONFIG_SND=y
-CONFIG_SND_SEQUENCER=y
-CONFIG_SND_SEQ_DUMMY=y
-CONFIG_SND_MIXER_OSS=y
-CONFIG_SND_PCM_OSS=y
-# CONFIG_SND_DRIVERS is not set
-# CONFIG_SND_SPI is not set
-# CONFIG_SND_USB is not set
-CONFIG_SND_SOC=y
-CONFIG_SND_SOC_SH4_FSI=y
-CONFIG_SND_FSI_DA7210=y
-CONFIG_USB=y
-CONFIG_USB_MON=y
-CONFIG_USB_R8A66597_HCD=y
-CONFIG_USB_STORAGE=y
-CONFIG_USB_GADGET=y
-CONFIG_USB_MASS_STORAGE=m
-CONFIG_MMC=y
-CONFIG_MMC_SPI=y
-CONFIG_MMC_SDHI=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_RS5C372=y
-CONFIG_UIO=y
-CONFIG_UIO_PDRV_GENIRQ=y
-CONFIG_EXT2_FS=y
-CONFIG_EXT2_FS_XATTR=y
-CONFIG_EXT2_FS_POSIX_ACL=y
-CONFIG_EXT2_FS_SECURITY=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_EXT3_FS_POSIX_ACL=y
-CONFIG_EXT3_FS_SECURITY=y
-CONFIG_VFAT_FS=y
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_ROOT_NFS=y
-CONFIG_NFSD=y
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_CODEPAGE_932=y
-CONFIG_NLS_ISO8859_1=y
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_DEBUG_FS=y
-CONFIG_CRYPTO=y
-CONFIG_CRYPTO_CBC=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRC_T10DIF=y
diff --git a/arch/sh/configs/edosk7705_defconfig b/arch/sh/configs/edosk7705_defconfig
deleted file mode 100644
index 9ee35269bee260..00000000000000
--- a/arch/sh/configs/edosk7705_defconfig
+++ /dev/null
@@ -1,35 +0,0 @@
-# CONFIG_LOCALVERSION_AUTO is not set
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-# CONFIG_UID16 is not set
-# CONFIG_KALLSYMS is not set
-# CONFIG_HOTPLUG is not set
-# CONFIG_PRINTK is not set
-# CONFIG_BUG is not set
-# CONFIG_ELF_CORE is not set
-# CONFIG_BASE_FULL is not set
-# CONFIG_FUTEX is not set
-# CONFIG_EPOLL is not set
-# CONFIG_SIGNALFD is not set
-# CONFIG_TIMERFD is not set
-# CONFIG_EVENTFD is not set
-# CONFIG_AIO is not set
-# CONFIG_VM_EVENT_COUNTERS is not set
-# CONFIG_COMPAT_BRK is not set
-# CONFIG_BLOCK is not set
-CONFIG_CPU_SUBTYPE_SH7705=y
-CONFIG_SH_EDOSK7705=y
-CONFIG_SH_PCLK_FREQ=31250000
-# CONFIG_PREVENT_FIRMWARE_BUILD is not set
-# CONFIG_INPUT is not set
-# CONFIG_SERIO is not set
-# CONFIG_VT is not set
-# CONFIG_UNIX98_PTYS is not set
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_HWMON is not set
-# CONFIG_USB_SUPPORT is not set
-# CONFIG_DNOTIFY is not set
-# CONFIG_PROC_FS is not set
-# CONFIG_SYSFS is not set
-# CONFIG_ENABLE_MUST_CHECK is not set
-# CONFIG_CRC32 is not set
diff --git a/arch/sh/configs/edosk7760_defconfig b/arch/sh/configs/edosk7760_defconfig
deleted file mode 100644
index f427a95bcd21e5..00000000000000
--- a/arch/sh/configs/edosk7760_defconfig
+++ /dev/null
@@ -1,114 +0,0 @@
-CONFIG_LOCALVERSION="_edosk7760"
-CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_KALLSYMS_ALL=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7760=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_STORE_QUEUES=y
-CONFIG_SH_EDOSK7760=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_SH_DMA=y
-CONFIG_SH_DMA_API=y
-CONFIG_PREEMPT=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="mem=64M console=ttySC2,115200 root=/dev/nfs rw nfsroot=192.168.0.3:/scripts/filesys ip=192.168.0.4"
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_IPV6 is not set
-# CONFIG_FW_LOADER is not set
-CONFIG_DEBUG_DRIVER=y
-CONFIG_DEBUG_DEVRES=y
-CONFIG_MTD=y
-CONFIG_MTD_DEBUG=y
-CONFIG_MTD_CMDLINE_PARTS=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_JEDECPROBE=y
-CONFIG_MTD_CFI_ADV_OPTIONS=y
-CONFIG_MTD_CFI_GEOMETRY=y
-CONFIG_MTD_MAP_BANK_WIDTH_8=y
-CONFIG_MTD_MAP_BANK_WIDTH_16=y
-CONFIG_MTD_MAP_BANK_WIDTH_32=y
-CONFIG_MTD_CFI_I4=y
-CONFIG_MTD_CFI_I8=y
-CONFIG_MTD_CFI_INTELEXT=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_CFI_STAA=y
-CONFIG_MTD_RAM=y
-CONFIG_MTD_ROM=y
-CONFIG_MTD_ABSENT=y
-CONFIG_MTD_PHYSMAP=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_SIZE=26000
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SMC91X=y
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=3
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_HW_RANDOM=y
-CONFIG_I2C=y
-CONFIG_I2C_CHARDEV=y
-CONFIG_I2C_SH7760=y
-CONFIG_I2C_DEBUG_CORE=y
-CONFIG_I2C_DEBUG_ALGO=y
-CONFIG_I2C_DEBUG_BUS=y
-# CONFIG_HWMON is not set
-CONFIG_FB=m
-CONFIG_FB_TILEBLITTING=y
-CONFIG_FB_SH_MOBILE_LCDC=m
-CONFIG_SOUND=y
-CONFIG_SND=y
-# CONFIG_SND_SUPPORT_OLD_API is not set
-# CONFIG_SND_VERBOSE_PROCFS is not set
-CONFIG_SND_VERBOSE_PRINTK=y
-CONFIG_SND_SOC=y
-# CONFIG_USB_SUPPORT is not set
-CONFIG_EXT2_FS=y
-CONFIG_EXT2_FS_XATTR=y
-CONFIG_EXT2_FS_XIP=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_TMPFS=y
-CONFIG_TMPFS_POSIX_ACL=y
-CONFIG_NFS_FS=y
-CONFIG_ROOT_NFS=y
-CONFIG_NLS=y
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_ASCII=y
-CONFIG_NLS_ISO8859_1=y
-CONFIG_NLS_ISO8859_15=y
-CONFIG_NLS_UTF8=y
-CONFIG_PRINTK_TIME=y
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_MAGIC_SYSRQ=y
-CONFIG_DEBUG_KERNEL=y
-CONFIG_DEBUG_SHIRQ=y
-CONFIG_DETECT_HUNG_TASK=y
-# CONFIG_SCHED_DEBUG is not set
-CONFIG_TIMER_STATS=y
-CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
-CONFIG_CRYPTO=y
-CONFIG_CRYPTO_MD5=y
-CONFIG_CRYPTO_DES=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
diff --git a/arch/sh/configs/espt_defconfig b/arch/sh/configs/espt_defconfig
deleted file mode 100644
index 2804cb760a7615..00000000000000
--- a/arch/sh/configs/espt_defconfig
+++ /dev/null
@@ -1,114 +0,0 @@
-CONFIG_SYSVIPC=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_NAMESPACES=y
-CONFIG_UTS_NS=y
-CONFIG_IPC_NS=y
-CONFIG_SLAB=y
-CONFIG_PROFILING=y
-CONFIG_MODULES=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7763=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_SH_ESPT=y
-CONFIG_SH_PCLK_FREQ=66666666
-CONFIG_SECCOMP=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC0,115200 root=/dev/nfs ip=bootp"
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IPV6 is not set
-CONFIG_MTD=y
-CONFIG_MTD_CMDLINE_PARTS=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_JEDECPROBE=y
-CONFIG_MTD_CFI_ADV_OPTIONS=y
-CONFIG_MTD_CFI_GEOMETRY=y
-# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_COMPLEX_MAPPINGS=y
-CONFIG_MTD_PHYSMAP=y
-CONFIG_SCSI=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SH_ETH=y
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=3
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_HW_RANDOM=y
-# CONFIG_HWMON is not set
-CONFIG_FB=y
-CONFIG_FB_FOREIGN_ENDIAN=y
-CONFIG_FB_SH7760=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_LOGO=y
-CONFIG_USB=y
-CONFIG_USB_MON=y
-CONFIG_USB_OHCI_HCD=y
-CONFIG_USB_STORAGE=y
-CONFIG_EXT2_FS=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_AUTOFS4_FS=y
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_TMPFS_POSIX_ACL=y
-CONFIG_CRAMFS=y
-CONFIG_ROMFS_FS=y
-CONFIG_NFS_FS=y
-CONFIG_ROOT_NFS=y
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_CODEPAGE_737=y
-CONFIG_NLS_CODEPAGE_775=y
-CONFIG_NLS_CODEPAGE_850=y
-CONFIG_NLS_CODEPAGE_852=y
-CONFIG_NLS_CODEPAGE_855=y
-CONFIG_NLS_CODEPAGE_857=y
-CONFIG_NLS_CODEPAGE_860=y
-CONFIG_NLS_CODEPAGE_861=y
-CONFIG_NLS_CODEPAGE_862=y
-CONFIG_NLS_CODEPAGE_863=y
-CONFIG_NLS_CODEPAGE_864=y
-CONFIG_NLS_CODEPAGE_865=y
-CONFIG_NLS_CODEPAGE_866=y
-CONFIG_NLS_CODEPAGE_869=y
-CONFIG_NLS_CODEPAGE_936=y
-CONFIG_NLS_CODEPAGE_950=y
-CONFIG_NLS_CODEPAGE_932=y
-CONFIG_NLS_CODEPAGE_949=y
-CONFIG_NLS_CODEPAGE_874=y
-CONFIG_NLS_ISO8859_8=y
-CONFIG_NLS_CODEPAGE_1250=y
-CONFIG_NLS_CODEPAGE_1251=y
-CONFIG_NLS_ASCII=y
-CONFIG_NLS_ISO8859_1=y
-CONFIG_NLS_ISO8859_2=y
-CONFIG_NLS_ISO8859_3=y
-CONFIG_NLS_ISO8859_4=y
-CONFIG_NLS_ISO8859_5=y
-CONFIG_NLS_ISO8859_6=y
-CONFIG_NLS_ISO8859_7=y
-CONFIG_NLS_ISO8859_9=y
-CONFIG_NLS_ISO8859_13=y
-CONFIG_NLS_ISO8859_14=y
-CONFIG_NLS_ISO8859_15=y
-CONFIG_NLS_KOI8_R=y
-CONFIG_NLS_KOI8_U=y
-CONFIG_NLS_UTF8=y
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_DEBUG_FS=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRC_T10DIF=y
diff --git a/arch/sh/configs/hp6xx_defconfig b/arch/sh/configs/hp6xx_defconfig
deleted file mode 100644
index 70e6605d7f7ef7..00000000000000
--- a/arch/sh/configs/hp6xx_defconfig
+++ /dev/null
@@ -1,60 +0,0 @@
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-CONFIG_SLAB=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7709=y
-CONFIG_MEMORY_START=0x0d000000
-CONFIG_MEMORY_SIZE=0x00400000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_HP6XX=y
-CONFIG_SH_PCLK_FREQ=22110000
-CONFIG_SH_DMA=y
-CONFIG_SH_DMA_API=y
-CONFIG_HD64461_ENABLER=y
-CONFIG_PCCARD=y
-CONFIG_PM=y
-CONFIG_APM_EMULATION=y
-# CONFIG_STANDALONE is not set
-CONFIG_BLK_DEV_SD=y
-CONFIG_ATA=y
-CONFIG_PATA_PLATFORM=y
-# CONFIG_INPUT_MOUSEDEV is not set
-CONFIG_INPUT_EVDEV=y
-# CONFIG_KEYBOARD_ATKBD is not set
-CONFIG_KEYBOARD_HP6XX=y
-# CONFIG_INPUT_MOUSE is not set
-CONFIG_INPUT_TOUCHSCREEN=y
-CONFIG_TOUCHSCREEN_HP600=y
-# CONFIG_SERIO_SERPORT is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=3
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_LEGACY_PTY_COUNT=64
-# CONFIG_HWMON is not set
-CONFIG_FB=y
-CONFIG_FIRMWARE_EDID=y
-CONFIG_FB_HIT=y
-CONFIG_FB_SH_MOBILE_LCDC=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_FONTS=y
-CONFIG_FONT_PEARL_8x8=y
-# CONFIG_USB_SUPPORT is not set
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_SH=y
-CONFIG_EXT2_FS=y
-CONFIG_MSDOS_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_PROC_KCORE=y
-CONFIG_NLS_CODEPAGE_850=y
-CONFIG_CRYPTO=y
-CONFIG_CRYPTO_CBC=y
-CONFIG_CRYPTO_ECB=y
-CONFIG_CRYPTO_PCBC=y
-CONFIG_CRYPTO_MD5=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-# CONFIG_CRYPTO_HW is not set
-CONFIG_CRC16=y
-CONFIG_CRC_T10DIF=y
diff --git a/arch/sh/configs/j2_defconfig b/arch/sh/configs/j2_defconfig
deleted file mode 100644
index 2eb81ebe3888bf..00000000000000
--- a/arch/sh/configs/j2_defconfig
+++ /dev/null
@@ -1,42 +0,0 @@
-CONFIG_SMP=y
-CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_CPU_SUBTYPE_J2=y
-CONFIG_MEMORY_START=0x10000000
-CONFIG_MEMORY_SIZE=0x04000000
-CONFIG_CPU_BIG_ENDIAN=y
-CONFIG_SH_DEVICE_TREE=y
-CONFIG_SH_JCORE_SOC=y
-CONFIG_HZ_100=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttyUL0 earlycon"
-CONFIG_BINFMT_ELF_FDPIC=y
-CONFIG_BINFMT_FLAT=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_DEVTMPFS=y
-CONFIG_DEVTMPFS_MOUNT=y
-CONFIG_NETDEVICES=y
-CONFIG_SERIAL_EARLYCON=y
-CONFIG_SERIAL_UARTLITE=y
-CONFIG_SERIAL_UARTLITE_CONSOLE=y
-CONFIG_I2C=y
-CONFIG_SPI=y
-CONFIG_SPI_JCORE=y
-CONFIG_WATCHDOG=y
-CONFIG_MMC=y
-CONFIG_MMC_SPI=y
-CONFIG_CLKSRC_JCORE_PIT=y
-CONFIG_JCORE_AIC=y
-CONFIG_EXT4_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_FAT_DEFAULT_IOCHARSET="ascii"
-CONFIG_FAT_DEFAULT_UTF8=y
-CONFIG_NLS_DEFAULT="utf8"
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_ASCII=y
-CONFIG_NLS_UTF8=y
diff --git a/arch/sh/configs/kfr2r09-romimage_defconfig b/arch/sh/configs/kfr2r09-romimage_defconfig
deleted file mode 100644
index 04436b4fbd7695..00000000000000
--- a/arch/sh/configs/kfr2r09-romimage_defconfig
+++ /dev/null
@@ -1,53 +0,0 @@
-# CONFIG_LOCALVERSION_AUTO is not set
-CONFIG_SYSVIPC=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_KALLSYMS is not set
-CONFIG_SLAB=y
-# CONFIG_BLOCK is not set
-CONFIG_CPU_SUBTYPE_SH7724=y
-CONFIG_MEMORY_SIZE=0x08000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_KFR2R09=y
-# CONFIG_SH_TIMER_TMU is not set
-CONFIG_HZ_100=y
-CONFIG_KEXEC=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC1,115200 quiet"
-# CONFIG_SUSPEND is not set
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_IPV6 is not set
-# CONFIG_WIRELESS is not set
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_VT_HW_CONSOLE_BINDING=y
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=6
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_I2C=y
-CONFIG_I2C_SH_MOBILE=y
-CONFIG_GPIO_SYSFS=y
-# CONFIG_HWMON is not set
-CONFIG_USB_GADGET=y
-CONFIG_USB_CDC_COMPOSITE=y
-# CONFIG_DNOTIFY is not set
-# CONFIG_INOTIFY_USER is not set
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-# CONFIG_MISC_FILESYSTEMS is not set
-# CONFIG_NETWORK_FILESYSTEMS is not set
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_DEBUG_FS=y
-# CONFIG_CRC32 is not set
diff --git a/arch/sh/configs/kfr2r09_defconfig b/arch/sh/configs/kfr2r09_defconfig
deleted file mode 100644
index 833404490cfeea..00000000000000
--- a/arch/sh/configs/kfr2r09_defconfig
+++ /dev/null
@@ -1,84 +0,0 @@
-# CONFIG_LOCALVERSION_AUTO is not set
-CONFIG_SYSVIPC=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_KALLSYMS is not set
-CONFIG_SLAB=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7724=y
-CONFIG_MEMORY_SIZE=0x08000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_KFR2R09=y
-# CONFIG_SH_TIMER_TMU is not set
-CONFIG_NO_HZ=y
-CONFIG_HZ_1000=y
-CONFIG_KEXEC=y
-CONFIG_PREEMPT=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=tty0 console=ttySC1,115200"
-# CONFIG_SUSPEND is not set
-CONFIG_CPU_IDLE=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_IPV6 is not set
-# CONFIG_WIRELESS is not set
-CONFIG_MTD=y
-CONFIG_MTD_CMDLINE_PARTS=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_INTELEXT=y
-CONFIG_MTD_PHYSMAP=y
-CONFIG_MTD_ONENAND=y
-CONFIG_MTD_ONENAND_GENERIC=y
-CONFIG_MTD_UBI=y
-# CONFIG_INPUT_MOUSEDEV is not set
-CONFIG_INPUT_EVDEV=y
-# CONFIG_KEYBOARD_ATKBD is not set
-CONFIG_KEYBOARD_SH_KEYSC=y
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_VT_HW_CONSOLE_BINDING=y
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=6
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_HW_RANDOM=y
-CONFIG_I2C=y
-CONFIG_I2C_SH_MOBILE=y
-CONFIG_GPIO_SYSFS=y
-# CONFIG_HWMON is not set
-CONFIG_FB=y
-CONFIG_FB_SH_MOBILE_LCDC=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
-CONFIG_FONTS=y
-CONFIG_FONT_MINI_4x6=y
-CONFIG_LOGO=y
-# CONFIG_LOGO_LINUX_MONO is not set
-# CONFIG_LOGO_LINUX_VGA16 is not set
-# CONFIG_LOGO_LINUX_CLUT224 is not set
-# CONFIG_LOGO_SUPERH_MONO is not set
-# CONFIG_LOGO_SUPERH_CLUT224 is not set
-CONFIG_USB_GADGET=y
-CONFIG_USB_CDC_COMPOSITE=m
-CONFIG_MMC=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_SH=y
-CONFIG_UIO=y
-CONFIG_UIO_PDRV_GENIRQ=y
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-# CONFIG_MISC_FILESYSTEMS is not set
-# CONFIG_NETWORK_FILESYSTEMS is not set
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_DEBUG_FS=y
diff --git a/arch/sh/configs/landisk_defconfig b/arch/sh/configs/landisk_defconfig
deleted file mode 100644
index 7037320b654ad6..00000000000000
--- a/arch/sh/configs/landisk_defconfig
+++ /dev/null
@@ -1,115 +0,0 @@
-CONFIG_SYSVIPC=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_KALLSYMS_EXTRA_PASS=y
-CONFIG_SLAB=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7751R=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_LANDISK=y
-CONFIG_SH_PCLK_FREQ=33333333
-CONFIG_HEARTBEAT=y
-CONFIG_KEXEC=y
-CONFIG_PCI=y
-CONFIG_PCCARD=y
-CONFIG_YENTA=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_PNP=y
-# CONFIG_IPV6 is not set
-CONFIG_NETFILTER=y
-CONFIG_ATALK=m
-CONFIG_BLK_DEV_LOOP=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_ATA=y
-CONFIG_ATA_GENERIC=y
-CONFIG_PATA_ATP867X=y
-CONFIG_SCSI=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_BLK_DEV_SR=y
-CONFIG_SCSI_MULTI_LUN=y
-CONFIG_MD=y
-CONFIG_BLK_DEV_MD=m
-CONFIG_MD_LINEAR=m
-CONFIG_MD_RAID0=m
-CONFIG_MD_RAID1=m
-CONFIG_NETDEVICES=y
-CONFIG_TUN=m
-CONFIG_NET_ETHERNET=y
-CONFIG_NET_PCI=y
-CONFIG_8139CP=y
-CONFIG_USB_PEGASUS=m
-CONFIG_USB_RTL8150=m
-CONFIG_INPUT_FF_MEMLESS=m
-# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_HW_RANDOM=y
-CONFIG_SOUND=m
-CONFIG_SOUND_PRIME=m
-CONFIG_USB_HID=m
-CONFIG_HID_A4TECH=m
-CONFIG_HID_APPLE=m
-CONFIG_HID_BELKIN=m
-CONFIG_HID_CHERRY=m
-CONFIG_HID_CHICONY=m
-CONFIG_HID_CYPRESS=m
-CONFIG_HID_EZKEY=m
-CONFIG_HID_GYRATION=m
-CONFIG_HID_LOGITECH=m
-CONFIG_HID_MICROSOFT=m
-CONFIG_HID_MONTEREY=m
-CONFIG_HID_PANTHERLORD=m
-CONFIG_HID_PETALYNX=m
-CONFIG_HID_SAMSUNG=m
-CONFIG_HID_SONY=m
-CONFIG_HID_SUNPLUS=m
-CONFIG_USB=y
-CONFIG_USB_MON=y
-CONFIG_USB_EHCI_HCD=y
-# CONFIG_USB_EHCI_TT_NEWSCHED is not set
-CONFIG_USB_OHCI_HCD=y
-CONFIG_USB_PRINTER=m
-CONFIG_USB_STORAGE=m
-CONFIG_USB_STORAGE_DATAFAB=m
-CONFIG_USB_STORAGE_FREECOM=m
-CONFIG_USB_STORAGE_ISD200=m
-CONFIG_USB_STORAGE_SDDR09=m
-CONFIG_USB_STORAGE_SDDR55=m
-CONFIG_USB_STORAGE_JUMPSHOT=m
-CONFIG_USB_SERIAL=m
-CONFIG_USB_SERIAL_FTDI_SIO=m
-CONFIG_USB_SERIAL_PL2303=m
-CONFIG_USB_EMI62=m
-CONFIG_USB_EMI26=m
-CONFIG_USB_SISUSBVGA=m
-CONFIG_EXT2_FS=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_REISERFS_FS=y
-CONFIG_ISO9660_FS=m
-CONFIG_MSDOS_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_NTFS_FS=m
-CONFIG_NTFS_RW=y
-CONFIG_TMPFS=y
-CONFIG_ROMFS_FS=y
-CONFIG_UFS_FS=m
-CONFIG_NFS_FS=m
-CONFIG_NFS_V3=y
-CONFIG_NFSD=m
-CONFIG_SMB_FS=m
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_CODEPAGE_932=y
-CONFIG_SH_STANDARD_BIOS=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRC_T10DIF=y
diff --git a/arch/sh/configs/lboxre2_defconfig b/arch/sh/configs/lboxre2_defconfig
deleted file mode 100644
index 05e4ac6fed5f9c..00000000000000
--- a/arch/sh/configs/lboxre2_defconfig
+++ /dev/null
@@ -1,62 +0,0 @@
-CONFIG_SYSVIPC=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_KALLSYMS_EXTRA_PASS=y
-CONFIG_SLAB=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7751R=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_LBOX_RE2=y
-CONFIG_SH_PCLK_FREQ=40000000
-CONFIG_KEXEC=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC1,115200 root=/dev/sda1"
-CONFIG_PCI=y
-CONFIG_PCCARD=y
-CONFIG_YENTA=y
-# CONFIG_YENTA_RICOH is not set
-# CONFIG_YENTA_TI is not set
-# CONFIG_YENTA_TOSHIBA is not set
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_PNP=y
-# CONFIG_IPV6 is not set
-CONFIG_NETFILTER=y
-CONFIG_BLK_DEV_LOOP=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_ATA=y
-CONFIG_PATA_PLATFORM=y
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_NET_PCI=y
-CONFIG_NE2K_PCI=y
-CONFIG_8139TOO=y
-CONFIG_8139TOO_TUNE_TWISTER=y
-CONFIG_NET_PCMCIA=y
-CONFIG_PCMCIA_PCNET=y
-# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_HW_RANDOM=y
-CONFIG_RTC_CLASS=y
-CONFIG_EXT2_FS=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_MSDOS_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_TMPFS=y
-CONFIG_ROMFS_FS=y
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_SH_STANDARD_BIOS=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRC_T10DIF=y
diff --git a/arch/sh/configs/magicpanelr2_defconfig b/arch/sh/configs/magicpanelr2_defconfig
deleted file mode 100644
index ef1d98e35c91f7..00000000000000
--- a/arch/sh/configs/magicpanelr2_defconfig
+++ /dev/null
@@ -1,90 +0,0 @@
-# CONFIG_LOCALVERSION_AUTO is not set
-CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_BSD_PROCESS_ACCT_V3=y
-CONFIG_AUDIT=y
-CONFIG_RELAY=y
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-CONFIG_KALLSYMS_ALL=y
-CONFIG_SLAB=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODVERSIONS=y
-CONFIG_MODULE_SRCVERSION_ALL=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7720=y
-CONFIG_MEMORY_START=0x0C000000
-CONFIG_MEMORY_SIZE=0x03F00000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_MAGIC_PANEL_R2=y
-CONFIG_SH_PCLK_FREQ=24000000
-CONFIG_SH_DMA=y
-CONFIG_SH_DMA_API=y
-CONFIG_HEARTBEAT=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_IPV6 is not set
-# CONFIG_STANDALONE is not set
-# CONFIG_PREVENT_FIRMWARE_BUILD is not set
-CONFIG_MTD=y
-CONFIG_MTD_REDBOOT_PARTS=y
-CONFIG_MTD_CMDLINE_PARTS=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_PHYSMAP=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_SIZE=65536
-CONFIG_NETDEVICES=y
-CONFIG_SMSC_PHY=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SMSC911X=y
-CONFIG_INPUT_EVDEV=y
-# CONFIG_MOUSE_PS2 is not set
-CONFIG_SERIAL_8250=y
-CONFIG_SERIAL_8250_CONSOLE=y
-CONFIG_SERIAL_8250_NR_UARTS=48
-CONFIG_SERIAL_8250_EXTENDED=y
-CONFIG_SERIAL_8250_SHARE_IRQ=y
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_HW_RANDOM is not set
-# CONFIG_HWMON is not set
-# CONFIG_USB_SUPPORT is not set
-CONFIG_RTC_CLASS=y
-# CONFIG_RTC_HCTOSYS is not set
-CONFIG_RTC_DRV_SH=y
-CONFIG_EXT2_FS=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-# CONFIG_EXT3_FS_XATTR is not set
-# CONFIG_DNOTIFY is not set
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_JFFS2_FS=y
-# CONFIG_JFFS2_FS_WRITEBUFFER is not set
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_ROOT_NFS=y
-CONFIG_NLS=y
-CONFIG_NLS_DEFAULT="cp437"
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_CODEPAGE_850=y
-CONFIG_NLS_ISO8859_1=y
-CONFIG_MAGIC_SYSRQ=y
-CONFIG_DEBUG_KERNEL=y
-# CONFIG_SCHED_DEBUG is not set
-CONFIG_DEBUG_KOBJECT=y
-CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
-CONFIG_FRAME_POINTER=y
-CONFIG_CRC_CCITT=m
-CONFIG_CRC16=m
diff --git a/arch/sh/configs/microdev_defconfig b/arch/sh/configs/microdev_defconfig
deleted file mode 100644
index e9825196dd66af..00000000000000
--- a/arch/sh/configs/microdev_defconfig
+++ /dev/null
@@ -1,43 +0,0 @@
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-CONFIG_SLAB=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH4_202=y
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_SH4202_MICRODEV=y
-CONFIG_SH_DMA=y
-CONFIG_SH_DMA_API=y
-CONFIG_HEARTBEAT=y
-CONFIG_PREEMPT=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC0,115200 root=/dev/hda1"
-CONFIG_SUPERHYWAY=y
-CONFIG_NET=y
-CONFIG_INET=y
-CONFIG_IP_PNP=y
-# CONFIG_IPV6 is not set
-# CONFIG_FW_LOADER is not set
-CONFIG_BLK_DEV_RAM=y
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SMC91X=y
-# CONFIG_INPUT is not set
-# CONFIG_SERIO is not set
-# CONFIG_VT is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_EXT2_FS=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_VFAT_FS=y
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_HUGETLBFS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_NFS_V4=y
-CONFIG_ROOT_NFS=y
-CONFIG_CRYPTO_ECB=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
diff --git a/arch/sh/configs/migor_defconfig b/arch/sh/configs/migor_defconfig
deleted file mode 100644
index 4859cd30cfc4c6..00000000000000
--- a/arch/sh/configs/migor_defconfig
+++ /dev/null
@@ -1,94 +0,0 @@
-CONFIG_SYSVIPC=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-CONFIG_SLAB=y
-CONFIG_PROFILING=y
-CONFIG_MODULES=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7722=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_NUMA=y
-# CONFIG_MIGRATION is not set
-CONFIG_SH_MIGOR=y
-# CONFIG_SH_TIMER_CMT is not set
-CONFIG_SECCOMP=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=tty0 console=ttySC0,115200 earlyprintk=serial ip=on root=/dev/nfs ip=dhcp"
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_IPV6 is not set
-CONFIG_FW_LOADER=m
-CONFIG_MTD=y
-CONFIG_MTD_CMDLINE_PARTS=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_PHYSMAP=y
-CONFIG_MTD_RAW_NAND=y
-CONFIG_MTD_NAND_PLATFORM=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_SCSI=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SMC91X=y
-# CONFIG_INPUT_MOUSEDEV is not set
-CONFIG_INPUT_EVDEV=y
-# CONFIG_KEYBOARD_ATKBD is not set
-CONFIG_KEYBOARD_SH_KEYSC=y
-# CONFIG_INPUT_MOUSE is not set
-CONFIG_INPUT_TOUCHSCREEN=y
-CONFIG_TOUCHSCREEN_MIGOR=y
-# CONFIG_SERIO is not set
-CONFIG_VT_HW_CONSOLE_BINDING=y
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=3
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_HW_RANDOM=y
-CONFIG_I2C=y
-CONFIG_I2C_SH_MOBILE=y
-# CONFIG_HWMON is not set
-CONFIG_MEDIA_SUPPORT=y
-CONFIG_VIDEO_DEV=y
-# CONFIG_VIDEO_ALLOW_V4L1 is not set
-# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
-CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
-CONFIG_VIDEO_SH_MOBILE_CEU=y
-# CONFIG_RADIO_ADAPTERS is not set
-CONFIG_FB=y
-CONFIG_FB_SH_MOBILE_LCDC=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
-CONFIG_FONTS=y
-CONFIG_FONT_MINI_4x6=y
-CONFIG_LOGO=y
-# CONFIG_LOGO_LINUX_MONO is not set
-# CONFIG_LOGO_LINUX_VGA16 is not set
-# CONFIG_LOGO_LINUX_CLUT224 is not set
-# CONFIG_LOGO_SUPERH_MONO is not set
-# CONFIG_LOGO_SUPERH_CLUT224 is not set
-CONFIG_USB_GADGET=y
-CONFIG_USB_GADGET_M66592=y
-CONFIG_USB_G_SERIAL=m
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_RS5C372=y
-CONFIG_RTC_DRV_SH=y
-CONFIG_UIO=y
-CONFIG_UIO_PDRV_GENIRQ=y
-# CONFIG_DNOTIFY is not set
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_NFS_FS=y
-CONFIG_ROOT_NFS=y
-CONFIG_DEBUG_FS=y
-CONFIG_CRYPTO_MANAGER=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-# CONFIG_CRYPTO_HW is not set
-CONFIG_CRC_T10DIF=y
diff --git a/arch/sh/configs/polaris_defconfig b/arch/sh/configs/polaris_defconfig
deleted file mode 100644
index f42e4867ddc1a7..00000000000000
--- a/arch/sh/configs/polaris_defconfig
+++ /dev/null
@@ -1,83 +0,0 @@
-# CONFIG_LOCALVERSION_AUTO is not set
-# CONFIG_SWAP is not set
-CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_BSD_PROCESS_ACCT_V3=y
-CONFIG_AUDIT=y
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-CONFIG_SLAB=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODVERSIONS=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7709=y
-CONFIG_MEMORY_START=0x0C000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_FPU_EMU=y
-CONFIG_SH_POLARIS=y
-CONFIG_SH_PCLK_FREQ=33000000
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_SH_DMA=y
-CONFIG_SH_DMA_API=y
-CONFIG_HEARTBEAT=y
-CONFIG_HZ_100=y
-CONFIG_PREEMPT=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC1,115200 root=/dev/mtdblock2 rootfstype=jffs2 mem=63M mtdparts=physmap-flash.0:0x00100000(bootloader)ro,0x00500000(Kernel)ro,0x00A00000(Filesystem)"
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_IPV6 is not set
-CONFIG_MTD=y
-CONFIG_MTD_CMDLINE_PARTS=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_ADV_OPTIONS=y
-CONFIG_MTD_CFI_INTELEXT=y
-CONFIG_MTD_PHYSMAP=y
-CONFIG_MTD_PHYSMAP_COMPAT=y
-CONFIG_MTD_PHYSMAP_START=0x00000000
-CONFIG_MTD_PHYSMAP_LEN=0x01000000
-CONFIG_NETDEVICES=y
-CONFIG_SMSC_PHY=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SMSC911X=y
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_VT_HW_CONSOLE_BINDING=y
-CONFIG_SERIAL_NONSTANDARD=y
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=3
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_HWMON is not set
-# CONFIG_USB_SUPPORT is not set
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_SH=y
-# CONFIG_DNOTIFY is not set
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_JFFS2_FS=y
-# CONFIG_JFFS2_FS_WRITEBUFFER is not set
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_DEBUG_KERNEL=y
-CONFIG_DEBUG_SHIRQ=y
-CONFIG_DETECT_HUNG_TASK=y
-# CONFIG_SCHED_DEBUG is not set
-CONFIG_DEBUG_RT_MUTEXES=y
-CONFIG_DEBUG_LOCK_ALLOC=y
-CONFIG_DEBUG_SPINLOCK_SLEEP=y
-CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
-CONFIG_DEBUG_SG=y
diff --git a/arch/sh/configs/r7780mp_defconfig b/arch/sh/configs/r7780mp_defconfig
deleted file mode 100644
index e527cd60a19105..00000000000000
--- a/arch/sh/configs/r7780mp_defconfig
+++ /dev/null
@@ -1,109 +0,0 @@
-CONFIG_SYSVIPC=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_FUTEX is not set
-# CONFIG_EPOLL is not set
-CONFIG_SLAB=y
-CONFIG_PROFILING=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7780=y
-CONFIG_MEMORY_SIZE=0x08000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_STORE_QUEUES=y
-CONFIG_SPECULATIVE_EXECUTION=y
-CONFIG_SH_HIGHLANDER=y
-CONFIG_SH_PCLK_FREQ=33333333
-CONFIG_PUSH_SWITCH=y
-CONFIG_KEXEC=y
-CONFIG_PREEMPT=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC0,115200 root=/dev/sda1"
-CONFIG_PCI=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_IPV6 is not set
-CONFIG_BRIDGE=m
-CONFIG_FW_LOADER=m
-CONFIG_MTD=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_COMPLEX_MAPPINGS=y
-CONFIG_MTD_PHYSMAP=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_CHR_DEV_SG=m
-CONFIG_ATA=y
-CONFIG_SATA_SIL=y
-CONFIG_PATA_PLATFORM=y
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_AX88796=y
-CONFIG_AX88796_93CX6=y
-CONFIG_NET_PCI=y
-CONFIG_PCNET32=m
-CONFIG_8139CP=m
-CONFIG_8139TOO=m
-# CONFIG_8139TOO_PIO is not set
-CONFIG_8139TOO_8129=y
-CONFIG_VIA_RHINE=m
-CONFIG_VIA_RHINE_MMIO=y
-CONFIG_E1000=m
-CONFIG_R8169=y
-# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO_SERPORT is not set
-# CONFIG_VT is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_HW_RANDOM=y
-CONFIG_I2C=y
-CONFIG_I2C_CHARDEV=y
-CONFIG_I2C_HIGHLANDER=y
-CONFIG_THERMAL=y
-CONFIG_SOUND=m
-CONFIG_SOUND_PRIME=m
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_RS5C372=y
-CONFIG_RTC_DRV_SH=y
-CONFIG_EXT2_FS=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_FUSE_FS=m
-CONFIG_MSDOS_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_NTFS_FS=y
-CONFIG_NTFS_RW=y
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_HUGETLBFS=y
-CONFIG_CONFIGFS_FS=m
-CONFIG_MINIX_FS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_NFS_V4=y
-CONFIG_ROOT_NFS=y
-CONFIG_NFSD=y
-CONFIG_NFSD_V4=y
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_CODEPAGE_932=y
-CONFIG_NLS_ISO8859_1=y
-CONFIG_MAGIC_SYSRQ=y
-CONFIG_DEBUG_FS=y
-CONFIG_DEBUG_KERNEL=y
-CONFIG_DETECT_HUNG_TASK=y
-# CONFIG_DEBUG_PREEMPT is not set
-CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
-CONFIG_CRYPTO_ECB=m
-CONFIG_CRYPTO_PCBC=m
-CONFIG_CRYPTO_HMAC=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRC_T10DIF=y
diff --git a/arch/sh/configs/r7785rp_defconfig b/arch/sh/configs/r7785rp_defconfig
deleted file mode 100644
index a3f952a83d970f..00000000000000
--- a/arch/sh/configs/r7785rp_defconfig
+++ /dev/null
@@ -1,107 +0,0 @@
-CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_AUDIT=y
-CONFIG_AUDITSYSCALL=y
-CONFIG_RCU_TRACE=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_SLAB=y
-CONFIG_PROFILING=y
-CONFIG_KPROBES=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7785=y
-CONFIG_MEMORY_SIZE=0x08000000
-CONFIG_HUGETLB_PAGE_SIZE_1MB=y
-CONFIG_SH_STORE_QUEUES=y
-CONFIG_SH_HIGHLANDER=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_CPU_FREQ=y
-CONFIG_SH_CPU_FREQ=y
-CONFIG_HEARTBEAT=y
-CONFIG_PUSH_SWITCH=y
-CONFIG_KEXEC=y
-CONFIG_PREEMPT=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC0,115200 root=/dev/sda1"
-CONFIG_PCI=y
-CONFIG_BINFMT_MISC=m
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_IPV6 is not set
-CONFIG_BRIDGE=m
-CONFIG_FW_LOADER=m
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_CHR_DEV_SG=m
-CONFIG_ATA=y
-CONFIG_SATA_SIL=y
-CONFIG_PATA_PLATFORM=y
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_AX88796=y
-CONFIG_AX88796_93CX6=y
-CONFIG_R8169=y
-# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO_SERPORT is not set
-# CONFIG_VT is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=6
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_HW_RANDOM=y
-CONFIG_I2C=y
-CONFIG_I2C_CHARDEV=y
-CONFIG_I2C_HIGHLANDER=y
-CONFIG_FB=y
-CONFIG_FB_SH_MOBILE_LCDC=m
-CONFIG_SOUND=m
-CONFIG_SOUND_PRIME=m
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_RS5C372=y
-CONFIG_RTC_DRV_SH=y
-CONFIG_EXT2_FS=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_FUSE_FS=m
-CONFIG_MSDOS_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_NTFS_FS=y
-CONFIG_NTFS_RW=y
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_HUGETLBFS=y
-CONFIG_CONFIGFS_FS=m
-CONFIG_MINIX_FS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_NFS_V4=y
-CONFIG_ROOT_NFS=y
-CONFIG_NFSD=y
-CONFIG_NFSD_V4=y
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_CODEPAGE_932=y
-CONFIG_NLS_ISO8859_1=y
-CONFIG_MAGIC_SYSRQ=y
-CONFIG_DEBUG_KERNEL=y
-# CONFIG_DEBUG_PREEMPT is not set
-CONFIG_DEBUG_LOCK_ALLOC=y
-CONFIG_DEBUG_LOCKING_API_SELFTESTS=y
-CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
-CONFIG_SH_STANDARD_BIOS=y
-CONFIG_DEBUG_STACK_USAGE=y
-CONFIG_4KSTACKS=y
-CONFIG_CRYPTO_ECB=m
-CONFIG_CRYPTO_PCBC=m
-CONFIG_CRYPTO_HMAC=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRC_T10DIF=y
diff --git a/arch/sh/configs/rsk7201_defconfig b/arch/sh/configs/rsk7201_defconfig
deleted file mode 100644
index 376e95fa77bc68..00000000000000
--- a/arch/sh/configs/rsk7201_defconfig
+++ /dev/null
@@ -1,63 +0,0 @@
-# CONFIG_LOCALVERSION_AUTO is not set
-CONFIG_SYSVIPC=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_IKCONFIG=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_NAMESPACES=y
-CONFIG_UTS_NS=y
-CONFIG_IPC_NS=y
-CONFIG_USER_NS=y
-CONFIG_PID_NS=y
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_AIO is not set
-CONFIG_SLUB=y
-CONFIG_SLUB_TINY=y
-CONFIG_PROFILING=y
-CONFIG_MODULES=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7201=y
-CONFIG_MEMORY_SIZE=0x01000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_CPU_BIG_ENDIAN=y
-CONFIG_SH_RSK=y
-CONFIG_SH_PCLK_FREQ=40000000
-CONFIG_HZ_1000=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC0,115200 earlyprintk=serial ignore_loglevel"
-CONFIG_BINFMT_FLAT=y
-CONFIG_BINFMT_ZFLAT=y
-CONFIG_PM=y
-CONFIG_CPU_IDLE=y
-# CONFIG_STANDALONE is not set
-# CONFIG_PREVENT_FIRMWARE_BUILD is not set
-# CONFIG_FW_LOADER is not set
-CONFIG_MTD=y
-CONFIG_MTD_REDBOOT_PARTS=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_PHYSMAP=y
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-# CONFIG_VT is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=8
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_UNIX98_PTYS is not set
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_HWMON is not set
-CONFIG_THERMAL=y
-# CONFIG_USB_SUPPORT is not set
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_SH=y
-CONFIG_EXT2_FS=y
-# CONFIG_FILE_LOCKING is not set
-# CONFIG_DNOTIFY is not set
-CONFIG_JFFS2_FS=y
-CONFIG_ROMFS_FS=y
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_MAGIC_SYSRQ=y
-CONFIG_DEBUG_FS=y
diff --git a/arch/sh/configs/rsk7203_defconfig b/arch/sh/configs/rsk7203_defconfig
deleted file mode 100644
index 1d5fd67a3949b4..00000000000000
--- a/arch/sh/configs/rsk7203_defconfig
+++ /dev/null
@@ -1,121 +0,0 @@
-# CONFIG_LOCALVERSION_AUTO is not set
-CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_IKCONFIG=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_NAMESPACES=y
-CONFIG_UTS_NS=y
-CONFIG_IPC_NS=y
-CONFIG_USER_NS=y
-CONFIG_PID_NS=y
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_KALLSYMS_ALL=y
-CONFIG_SLUB=y
-CONFIG_SLUB_TINY=y
-CONFIG_PROFILING=y
-CONFIG_MODULES=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7203=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_MEMORY_SIZE=0x01000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_CPU_BIG_ENDIAN=y
-CONFIG_SH_RSK=y
-CONFIG_SH_PCLK_FREQ=16670800
-CONFIG_CPU_FREQ=y
-CONFIG_SH_CPU_FREQ=y
-CONFIG_HEARTBEAT=y
-CONFIG_HZ_1000=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC0,115200 earlyprintk=serial ignore_loglevel"
-CONFIG_BINFMT_FLAT=y
-CONFIG_BINFMT_ZFLAT=y
-CONFIG_PM=y
-CONFIG_CPU_IDLE=y
-CONFIG_NET=y
-CONFIG_INET=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_IPV6 is not set
-# CONFIG_STANDALONE is not set
-# CONFIG_PREVENT_FIRMWARE_BUILD is not set
-# CONFIG_FW_LOADER is not set
-CONFIG_MTD=y
-CONFIG_MTD_REDBOOT_PARTS=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_PHYSMAP=y
-CONFIG_NETDEVICES=y
-CONFIG_SMSC_PHY=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SMSC911X=y
-CONFIG_INPUT_FF_MEMLESS=m
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-# CONFIG_VT is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=4
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_UNIX98_PTYS is not set
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_HWMON is not set
-CONFIG_THERMAL=y
-CONFIG_REGULATOR=y
-CONFIG_HID_A4TECH=y
-CONFIG_HID_APPLE=y
-CONFIG_HID_BELKIN=y
-CONFIG_HID_CHERRY=y
-CONFIG_HID_CHICONY=y
-CONFIG_HID_CYPRESS=y
-CONFIG_HID_EZKEY=y
-CONFIG_HID_GYRATION=y
-CONFIG_HID_LOGITECH=y
-CONFIG_HID_MICROSOFT=y
-CONFIG_HID_MONTEREY=y
-CONFIG_HID_PANTHERLORD=y
-CONFIG_HID_PETALYNX=y
-CONFIG_HID_SAMSUNG=y
-CONFIG_HID_SONY=y
-CONFIG_HID_SUNPLUS=y
-CONFIG_USB=y
-CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
-CONFIG_USB_MON=y
-CONFIG_USB_R8A66597_HCD=y
-CONFIG_NEW_LEDS=y
-CONFIG_LEDS_CLASS=y
-CONFIG_LEDS_GPIO=y
-CONFIG_LEDS_TRIGGERS=y
-CONFIG_LEDS_TRIGGER_TIMER=y
-CONFIG_LEDS_TRIGGER_HEARTBEAT=y
-CONFIG_LEDS_TRIGGER_BACKLIGHT=y
-CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_SH=y
-# CONFIG_DNOTIFY is not set
-CONFIG_ROMFS_FS=y
-CONFIG_NFS_FS=y
-CONFIG_ROOT_NFS=y
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_MAGIC_SYSRQ=y
-CONFIG_DEBUG_FS=y
-CONFIG_DEBUG_KERNEL=y
-CONFIG_DEBUG_SHIRQ=y
-CONFIG_DETECT_HUNG_TASK=y
-CONFIG_DEBUG_OBJECTS=y
-CONFIG_DEBUG_MUTEXES=y
-CONFIG_DEBUG_SPINLOCK_SLEEP=y
-CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
-CONFIG_DEBUG_VM=y
-CONFIG_DEBUG_LIST=y
-CONFIG_DEBUG_SG=y
-CONFIG_FRAME_POINTER=y
-CONFIG_DEBUG_STACK_USAGE=y
diff --git a/arch/sh/configs/rsk7264_defconfig b/arch/sh/configs/rsk7264_defconfig
deleted file mode 100644
index f7b9c528c6df87..00000000000000
--- a/arch/sh/configs/rsk7264_defconfig
+++ /dev/null
@@ -1,71 +0,0 @@
-CONFIG_LOCALVERSION="uClinux RSK2+SH7264"
-# CONFIG_LOCALVERSION_AUTO is not set
-CONFIG_SYSVIPC=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_IKCONFIG=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_NAMESPACES=y
-CONFIG_SYSFS_DEPRECATED=y
-CONFIG_SYSFS_DEPRECATED_V2=y
-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
-CONFIG_KALLSYMS_ALL=y
-CONFIG_EMBEDDED=y
-CONFIG_PERF_COUNTERS=y
-# CONFIG_VM_EVENT_COUNTERS is not set
-CONFIG_SLAB=y
-CONFIG_MMAP_ALLOW_UNINITIALIZED=y
-CONFIG_PROFILING=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_PARTITION_ADVANCED=y
-CONFIG_CPU_SUBTYPE_SH7264=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_CPU_BIG_ENDIAN=y
-CONFIG_SH_RSK=y
-# CONFIG_SH_TIMER_MTU2 is not set
-CONFIG_BINFMT_FLAT=y
-CONFIG_NET=y
-CONFIG_INET=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_IPV6 is not set
-# CONFIG_PREVENT_FIRMWARE_BUILD is not set
-# CONFIG_FW_LOADER is not set
-CONFIG_BLK_DEV_LOOP=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_COUNT=4
-CONFIG_SCSI=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_NETDEVICES=y
-CONFIG_SMSC911X=y
-CONFIG_SMSC_PHY=y
-CONFIG_INPUT_FF_MEMLESS=y
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_VT_HW_CONSOLE_BINDING=y
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=8
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_HWMON is not set
-CONFIG_USB=y
-CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
-CONFIG_USB_R8A66597_HCD=y
-CONFIG_USB_STORAGE=y
-CONFIG_USB_STORAGE_DEBUG=y
-CONFIG_EXT2_FS=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_VFAT_FS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_ROOT_NFS=y
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_ISO8859_1=y
-# CONFIG_ENABLE_MUST_CHECK is not set
-# CONFIG_FTRACE is not set
diff --git a/arch/sh/configs/rsk7269_defconfig b/arch/sh/configs/rsk7269_defconfig
deleted file mode 100644
index 4bff14fb185dbb..00000000000000
--- a/arch/sh/configs/rsk7269_defconfig
+++ /dev/null
@@ -1,56 +0,0 @@
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
-CONFIG_EMBEDDED=y
-# CONFIG_VM_EVENT_COUNTERS is not set
-CONFIG_SLAB=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_SWAP_IO_SPACE=y
-CONFIG_CPU_SUBTYPE_SH7269=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_MEMORY_SIZE=0x02000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_CPU_BIG_ENDIAN=y
-CONFIG_SH_RSK=y
-# CONFIG_SH_TIMER_MTU2 is not set
-CONFIG_SH_PCLK_FREQ=66700000
-CONFIG_BINFMT_FLAT=y
-CONFIG_NET=y
-CONFIG_INET=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_IPV6 is not set
-# CONFIG_FW_LOADER is not set
-CONFIG_SCSI=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_NETDEVICES=y
-CONFIG_SMSC911X=y
-CONFIG_SMSC_PHY=y
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=8
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_HWMON is not set
-CONFIG_USB=y
-CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
-CONFIG_USB_R8A66597_HCD=y
-CONFIG_USB_STORAGE=y
-CONFIG_USB_STORAGE_DEBUG=y
-CONFIG_EXT2_FS=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_VFAT_FS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_ROOT_NFS=y
-CONFIG_PARTITION_ADVANCED=y
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_ISO8859_1=y
-# CONFIG_ENABLE_MUST_CHECK is not set
-# CONFIG_FTRACE is not set
diff --git a/arch/sh/configs/rts7751r2d1_defconfig b/arch/sh/configs/rts7751r2d1_defconfig
deleted file mode 100644
index 96263a4912b726..00000000000000
--- a/arch/sh/configs/rts7751r2d1_defconfig
+++ /dev/null
@@ -1,91 +0,0 @@
-CONFIG_SYSVIPC=y
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-CONFIG_SLAB=y
-CONFIG_PROFILING=y
-CONFIG_MODULES=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7751R=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_RTS7751R2D=y
-CONFIG_RTS7751R2D_1=y
-CONFIG_HEARTBEAT=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=tty0 console=ttySC1,115200 root=/dev/sda1"
-CONFIG_PCI=y
-CONFIG_HOTPLUG_PCI=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-# CONFIG_IPV6 is not set
-CONFIG_FW_LOADER=m
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_ATA=y
-CONFIG_PATA_PLATFORM=y
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_NET_PCI=y
-CONFIG_8139TOO=y
-# CONFIG_8139TOO_PIO is not set
-CONFIG_INPUT_FF_MEMLESS=m
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_VT_HW_CONSOLE_BINDING=y
-CONFIG_SERIAL_8250=y
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_HW_RANDOM=y
-CONFIG_SPI=y
-CONFIG_SPI_SH_SCI=y
-CONFIG_MFD_SM501=y
-CONFIG_FB=y
-CONFIG_FB_SH_MOBILE_LCDC=m
-CONFIG_FB_SM501=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_LOGO=y
-# CONFIG_LOGO_LINUX_MONO is not set
-# CONFIG_LOGO_LINUX_VGA16 is not set
-# CONFIG_LOGO_LINUX_CLUT224 is not set
-# CONFIG_LOGO_SUPERH_MONO is not set
-# CONFIG_LOGO_SUPERH_VGA16 is not set
-CONFIG_SOUND=y
-CONFIG_SND=m
-CONFIG_SND_YMFPCI=m
-CONFIG_SOUND_PRIME=m
-CONFIG_HID_A4TECH=y
-CONFIG_HID_APPLE=y
-CONFIG_HID_BELKIN=y
-CONFIG_HID_CHERRY=y
-CONFIG_HID_CHICONY=y
-CONFIG_HID_CYPRESS=y
-CONFIG_HID_EZKEY=y
-CONFIG_HID_GYRATION=y
-CONFIG_HID_LOGITECH=y
-CONFIG_HID_MICROSOFT=y
-CONFIG_HID_MONTEREY=y
-CONFIG_HID_PANTHERLORD=y
-CONFIG_HID_PETALYNX=y
-CONFIG_HID_SAMSUNG=y
-CONFIG_HID_SONY=y
-CONFIG_HID_SUNPLUS=y
-CONFIG_USB=y
-CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
-CONFIG_USB_OHCI_HCD=y
-CONFIG_USB_STORAGE=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_R9701=y
-CONFIG_EXT2_FS=y
-CONFIG_MSDOS_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_MINIX_FS=y
-CONFIG_NLS_CODEPAGE_932=y
-CONFIG_DEBUG_FS=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRC_T10DIF=y
diff --git a/arch/sh/configs/rts7751r2dplus_defconfig b/arch/sh/configs/rts7751r2dplus_defconfig
deleted file mode 100644
index 92e586e6c97432..00000000000000
--- a/arch/sh/configs/rts7751r2dplus_defconfig
+++ /dev/null
@@ -1,96 +0,0 @@
-CONFIG_SYSVIPC=y
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-CONFIG_SLAB=y
-CONFIG_PROFILING=y
-CONFIG_MODULES=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7751R=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_RTS7751R2D=y
-CONFIG_RTS7751R2D_PLUS=y
-CONFIG_HEARTBEAT=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=tty0 console=ttySC1,115200 root=/dev/sda1"
-CONFIG_PCI=y
-CONFIG_HOTPLUG_PCI=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-# CONFIG_IPV6 is not set
-CONFIG_FW_LOADER=m
-CONFIG_MTD=y
-CONFIG_MTD_CMDLINE_PARTS=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_PHYSMAP=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_ATA=y
-CONFIG_PATA_PLATFORM=y
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_NET_PCI=y
-CONFIG_8139TOO=y
-# CONFIG_8139TOO_PIO is not set
-CONFIG_INPUT_FF_MEMLESS=m
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_VT_HW_CONSOLE_BINDING=y
-CONFIG_SERIAL_8250=y
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_HW_RANDOM=y
-CONFIG_SPI=y
-CONFIG_SPI_SH_SCI=y
-CONFIG_MFD_SM501=y
-CONFIG_FB=y
-CONFIG_FB_SH_MOBILE_LCDC=m
-CONFIG_FB_SM501=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_LOGO=y
-# CONFIG_LOGO_LINUX_MONO is not set
-# CONFIG_LOGO_LINUX_VGA16 is not set
-# CONFIG_LOGO_LINUX_CLUT224 is not set
-# CONFIG_LOGO_SUPERH_MONO is not set
-# CONFIG_LOGO_SUPERH_VGA16 is not set
-CONFIG_SOUND=y
-CONFIG_SND=m
-CONFIG_SND_YMFPCI=m
-CONFIG_SOUND_PRIME=m
-CONFIG_HID_A4TECH=y
-CONFIG_HID_APPLE=y
-CONFIG_HID_BELKIN=y
-CONFIG_HID_CHERRY=y
-CONFIG_HID_CHICONY=y
-CONFIG_HID_CYPRESS=y
-CONFIG_HID_EZKEY=y
-CONFIG_HID_GYRATION=y
-CONFIG_HID_LOGITECH=y
-CONFIG_HID_MICROSOFT=y
-CONFIG_HID_MONTEREY=y
-CONFIG_HID_PANTHERLORD=y
-CONFIG_HID_PETALYNX=y
-CONFIG_HID_SAMSUNG=y
-CONFIG_HID_SONY=y
-CONFIG_HID_SUNPLUS=y
-CONFIG_USB=y
-CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
-CONFIG_USB_OHCI_HCD=y
-CONFIG_USB_STORAGE=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_R9701=y
-CONFIG_EXT2_FS=y
-CONFIG_MSDOS_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_MINIX_FS=y
-CONFIG_NLS_CODEPAGE_932=y
-CONFIG_DEBUG_FS=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRC_T10DIF=y
diff --git a/arch/sh/configs/sdk7780_defconfig b/arch/sh/configs/sdk7780_defconfig
deleted file mode 100644
index 41cb588ca99cb7..00000000000000
--- a/arch/sh/configs/sdk7780_defconfig
+++ /dev/null
@@ -1,139 +0,0 @@
-CONFIG_LOCALVERSION="_SDK7780"
-CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=18
-CONFIG_RELAY=y
-CONFIG_KALLSYMS_ALL=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7780=y
-CONFIG_MEMORY_SIZE=0x08000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_STORE_QUEUES=y
-CONFIG_SH_SDK7780=y
-CONFIG_SH_PCLK_FREQ=33333333
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_SH_DMA=y
-CONFIG_SH_DMA_API=y
-CONFIG_HEARTBEAT=y
-CONFIG_PREEMPT=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="mem=128M console=tty0 console=ttySC0,115200 ip=bootp root=/dev/nfs nfsroot=192.168.0.1:/home/rootfs"
-CONFIG_PCI=y
-CONFIG_PCI_DEBUG=y
-CONFIG_PCCARD=y
-CONFIG_YENTA=y
-CONFIG_HOTPLUG_PCI=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_INET_XFRM_MODE_BEET is not set
-CONFIG_IPV6=y
-# CONFIG_INET6_XFRM_MODE_BEET is not set
-CONFIG_NET_SCHED=y
-CONFIG_PARPORT=y
-CONFIG_BLK_DEV_LOOP=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_BLK_DEV_SR=y
-CONFIG_CHR_DEV_SG=y
-CONFIG_SCSI_SPI_ATTRS=y
-CONFIG_SCSI_FC_ATTRS=y
-CONFIG_ATA=y
-CONFIG_ATA_GENERIC=y
-CONFIG_PATA_PLATFORM=y
-CONFIG_MD=y
-CONFIG_BLK_DEV_DM=y
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SMC91X=y
-CONFIG_NETCONSOLE=y
-CONFIG_INPUT_FF_MEMLESS=m
-CONFIG_INPUT_EVDEV=y
-# CONFIG_SERIO_SERPORT is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_HW_RANDOM=y
-CONFIG_POWER_SUPPLY=y
-# CONFIG_HWMON is not set
-CONFIG_SSB=y
-CONFIG_SSB_DRIVER_PCICORE=y
-CONFIG_FB=y
-CONFIG_FB_SH_MOBILE_LCDC=m
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
-CONFIG_LOGO=y
-CONFIG_SOUND=y
-CONFIG_SOUND_PRIME=y
-CONFIG_HID_A4TECH=y
-CONFIG_HID_APPLE=y
-CONFIG_HID_BELKIN=y
-CONFIG_HID_CHERRY=y
-CONFIG_HID_CHICONY=y
-CONFIG_HID_CYPRESS=y
-CONFIG_HID_EZKEY=y
-CONFIG_HID_GYRATION=y
-CONFIG_HID_LOGITECH=y
-CONFIG_HID_MICROSOFT=y
-CONFIG_HID_MONTEREY=y
-CONFIG_HID_PANTHERLORD=y
-CONFIG_HID_PETALYNX=y
-CONFIG_HID_SAMSUNG=y
-CONFIG_HID_SONY=y
-CONFIG_HID_SUNPLUS=y
-CONFIG_USB=y
-CONFIG_USB_MON=y
-CONFIG_USB_EHCI_HCD=y
-# CONFIG_USB_EHCI_TT_NEWSCHED is not set
-CONFIG_USB_PRINTER=y
-CONFIG_USB_STORAGE=y
-CONFIG_NEW_LEDS=y
-CONFIG_LEDS_CLASS=y
-CONFIG_EXT2_FS=y
-CONFIG_EXT2_FS_XATTR=y
-CONFIG_EXT2_FS_POSIX_ACL=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_EXT3_FS_POSIX_ACL=y
-CONFIG_AUTOFS4_FS=y
-CONFIG_ISO9660_FS=y
-CONFIG_MSDOS_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_NTFS_FS=y
-CONFIG_NTFS_DEBUG=y
-CONFIG_NTFS_RW=y
-CONFIG_TMPFS=y
-CONFIG_TMPFS_POSIX_ACL=y
-CONFIG_HUGETLBFS=y
-CONFIG_MINIX_FS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_ROOT_NFS=y
-CONFIG_NFSD=y
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_ASCII=y
-CONFIG_NLS_ISO8859_1=y
-CONFIG_NLS_ISO8859_15=y
-CONFIG_NLS_UTF8=y
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_MAGIC_SYSRQ=y
-CONFIG_DEBUG_KERNEL=y
-CONFIG_DETECT_HUNG_TASK=y
-# CONFIG_SCHED_DEBUG is not set
-CONFIG_TIMER_STATS=y
-CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
-CONFIG_SH_STANDARD_BIOS=y
-CONFIG_CRYPTO_MD5=y
-CONFIG_CRYPTO_DES=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRC_T10DIF=y
diff --git a/arch/sh/configs/sdk7786_defconfig b/arch/sh/configs/sdk7786_defconfig
deleted file mode 100644
index 97b7356639ed82..00000000000000
--- a/arch/sh/configs/sdk7786_defconfig
+++ /dev/null
@@ -1,217 +0,0 @@
-CONFIG_KERNEL_LZO=y
-CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_BSD_PROCESS_ACCT_V3=y
-CONFIG_AUDIT=y
-CONFIG_AUDITSYSCALL=y
-CONFIG_RCU_TRACE=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_CGROUPS=y
-CONFIG_CGROUP_DEBUG=y
-CONFIG_CGROUP_FREEZER=y
-CONFIG_CGROUP_DEVICE=y
-CONFIG_CPUSETS=y
-# CONFIG_PROC_PID_CPUSET is not set
-CONFIG_CGROUP_CPUACCT=y
-CONFIG_CGROUP_MEMCG=y
-CONFIG_CGROUP_SCHED=y
-CONFIG_RT_GROUP_SCHED=y
-CONFIG_BLK_CGROUP=y
-CONFIG_RELAY=y
-CONFIG_NAMESPACES=y
-CONFIG_UTS_NS=y
-CONFIG_IPC_NS=y
-CONFIG_USER_NS=y
-CONFIG_PID_NS=y
-CONFIG_NET_NS=y
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_RD_BZIP2=y
-CONFIG_RD_LZMA=y
-CONFIG_RD_LZO=y
-# CONFIG_COMPAT_BRK is not set
-CONFIG_SLAB=y
-CONFIG_PROFILING=y
-CONFIG_KPROBES=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-CONFIG_IOSCHED_BFQ=y
-CONFIG_BFQ_GROUP_IOSCHED=y
-CONFIG_CPU_SUBTYPE_SH7786=y
-CONFIG_MEMORY_START=0x40000000
-CONFIG_MEMORY_SIZE=0x20000000
-CONFIG_PMB=y
-CONFIG_NUMA=y
-CONFIG_HUGETLB_PAGE_SIZE_64MB=y
-CONFIG_MEMORY_HOTPLUG=y
-CONFIG_MEMORY_HOTREMOVE=y
-CONFIG_KSM=y
-CONFIG_SH_STORE_QUEUES=y
-CONFIG_SPECULATIVE_EXECUTION=y
-CONFIG_SH_SDK7786=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_GOV_POWERSAVE=m
-CONFIG_CPU_FREQ_GOV_USERSPACE=m
-CONFIG_CPU_FREQ_GOV_ONDEMAND=m
-CONFIG_CPU_FREQ_GOV_CONSERVATIVE=m
-CONFIG_SH_CPU_FREQ=y
-CONFIG_SH_DMA=y
-CONFIG_HEARTBEAT=y
-CONFIG_HZ_1000=y
-CONFIG_KEXEC=y
-CONFIG_SECCOMP=y
-CONFIG_SMP=y
-CONFIG_HOTPLUG_CPU=y
-CONFIG_PREEMPT=y
-CONFIG_INTC_USERIMASK=y
-CONFIG_INTC_BALANCING=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC1,115200 earlyprintk=sh-sci.1,115200 root=/dev/sda1 nmi_debug=state,debounce rootdelay=5 pmb=iomap ignore_loglevel"
-CONFIG_PCI=y
-CONFIG_PCIEPORTBUS=y
-CONFIG_PCIEAER_INJECT=y
-CONFIG_PCIEASPM_DEBUG=y
-CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
-CONFIG_BINFMT_MISC=y
-CONFIG_PM=y
-CONFIG_PM_DEBUG=y
-CONFIG_PM=y
-CONFIG_CPU_IDLE=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_IPV6 is not set
-# CONFIG_WIRELESS is not set
-# CONFIG_FW_LOADER is not set
-CONFIG_MTD=y
-CONFIG_MTD_CMDLINE_PARTS=y
-CONFIG_MTD_BLOCK=y
-CONFIG_FTL=y
-CONFIG_NFTL=y
-CONFIG_MTD_OOPS=m
-CONFIG_MTD_CFI=y
-CONFIG_MTD_JEDECPROBE=y
-CONFIG_MTD_CFI_INTELEXT=m
-CONFIG_MTD_CFI_AMDSTD=m
-CONFIG_MTD_CFI_STAA=m
-CONFIG_MTD_ROM=m
-CONFIG_MTD_ABSENT=m
-CONFIG_MTD_PLATRAM=y
-CONFIG_MTD_PHRAM=y
-CONFIG_MTD_RAW_NAND=y
-CONFIG_MTD_NAND_PLATFORM=y
-CONFIG_MTD_NAND_SH_FLCTL=m
-CONFIG_MTD_UBI=y
-CONFIG_MTD_UBI_GLUEBI=m
-CONFIG_BLK_DEV_LOOP=y
-CONFIG_BLK_DEV_CRYPTOLOOP=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_BLK_DEV_SR=y
-CONFIG_SCSI_MULTI_LUN=y
-CONFIG_SCSI_CONSTANTS=y
-# CONFIG_SCSI_LOWLEVEL is not set
-CONFIG_ATA=y
-CONFIG_SATA_SIL24=y
-CONFIG_PATA_PLATFORM=y
-CONFIG_MD=y
-CONFIG_BLK_DEV_DM=y
-CONFIG_DM_DEBUG=y
-CONFIG_DM_UEVENT=y
-CONFIG_NETDEVICES=y
-CONFIG_MDIO_BITBANG=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SMC91X=y
-CONFIG_SMSC911X=y
-# CONFIG_WLAN is not set
-CONFIG_VT_HW_CONSOLE_BINDING=y
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=6
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_SERIAL_SH_SCI_DMA=y
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_HW_RANDOM is not set
-CONFIG_I2C=y
-# CONFIG_I2C_COMPAT is not set
-CONFIG_I2C_CHARDEV=y
-CONFIG_SPI=y
-# CONFIG_HWMON is not set
-CONFIG_WATCHDOG=y
-CONFIG_SH_WDT=y
-CONFIG_USB=y
-CONFIG_USB_MON=y
-CONFIG_USB_OHCI_HCD=y
-CONFIG_USB_STORAGE=y
-CONFIG_USB_GADGET=y
-CONFIG_USB_GADGET_M66592=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_MAX6900=y
-CONFIG_RTC_DRV_SH=y
-CONFIG_DMADEVICES=y
-CONFIG_SH_DMAE=y
-CONFIG_UIO=m
-CONFIG_UIO_PDRV=m
-CONFIG_UIO_PDRV_GENIRQ=m
-CONFIG_UIO_PCI_GENERIC=m
-CONFIG_STAGING=y
-# CONFIG_STAGING_EXCLUDE_BUILD is not set
-CONFIG_EXT2_FS=y
-CONFIG_EXT2_FS_XATTR=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_EXT4_FS=y
-CONFIG_XFS_FS=y
-CONFIG_BTRFS_FS=y
-CONFIG_AUTOFS4_FS=m
-CONFIG_FUSE_FS=y
-CONFIG_CUSE=m
-CONFIG_FSCACHE=m
-CONFIG_CACHEFILES=m
-CONFIG_ISO9660_FS=m
-CONFIG_JOLIET=y
-CONFIG_ZISOFS=y
-CONFIG_UDF_FS=m
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_HUGETLBFS=y
-CONFIG_CONFIGFS_FS=y
-CONFIG_JFFS2_FS=m
-CONFIG_JFFS2_FS_XATTR=y
-CONFIG_UBIFS_FS=m
-CONFIG_CRAMFS=m
-CONFIG_SQUASHFS=m
-CONFIG_ROMFS_FS=m
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_NFS_V4=y
-CONFIG_ROOT_NFS=y
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_CODEPAGE_936=m
-CONFIG_NLS_CODEPAGE_950=m
-CONFIG_NLS_CODEPAGE_932=y
-CONFIG_NLS_CODEPAGE_949=m
-CONFIG_NLS_ASCII=m
-CONFIG_NLS_ISO8859_1=y
-CONFIG_NLS_ISO8859_15=m
-CONFIG_NLS_UTF8=m
-CONFIG_PRINTK_TIME=y
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_MAGIC_SYSRQ=y
-CONFIG_DEBUG_KERNEL=y
-CONFIG_DETECT_HUNG_TASK=y
-CONFIG_TIMER_STATS=y
-CONFIG_DEBUG_MEMORY_INIT=y
-CONFIG_LATENCYTOP=y
-CONFIG_FUNCTION_TRACER=y
-# CONFIG_FUNCTION_GRAPH_TRACER is not set
-CONFIG_DMA_API_DEBUG=y
-CONFIG_DEBUG_STACK_USAGE=y
-CONFIG_DWARF_UNWINDER=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
diff --git a/arch/sh/configs/se7206_defconfig b/arch/sh/configs/se7206_defconfig
deleted file mode 100644
index 78e0e7be57ee1f..00000000000000
--- a/arch/sh/configs/se7206_defconfig
+++ /dev/null
@@ -1,108 +0,0 @@
-CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_AUDIT=y
-CONFIG_AUDITSYSCALL=y
-CONFIG_RCU_TRACE=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_CGROUPS=y
-CONFIG_CGROUP_DEBUG=y
-CONFIG_CGROUP_DEVICE=y
-CONFIG_CGROUP_CPUACCT=y
-CONFIG_CGROUP_MEMCG=y
-CONFIG_RELAY=y
-CONFIG_NAMESPACES=y
-CONFIG_UTS_NS=y
-CONFIG_IPC_NS=y
-CONFIG_USER_NS=y
-CONFIG_PID_NS=y
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_UID16 is not set
-CONFIG_KALLSYMS_ALL=y
-# CONFIG_ELF_CORE is not set
-# CONFIG_COMPAT_BRK is not set
-CONFIG_SLUB=y
-CONFIG_SLUB_TINY=y
-CONFIG_PROFILING=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7206=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_CPU_BIG_ENDIAN=y
-CONFIG_SH_7206_SOLUTION_ENGINE=y
-CONFIG_CPU_FREQ=y
-CONFIG_SH_CPU_FREQ=y
-CONFIG_HEARTBEAT=y
-CONFIG_HZ_1000=y
-CONFIG_PREEMPT=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC3,115200 ignore_loglevel earlyprintk=serial"
-CONFIG_BINFMT_FLAT=y
-CONFIG_BINFMT_ZFLAT=y
-CONFIG_BINFMT_MISC=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_IPV6 is not set
-# CONFIG_STANDALONE is not set
-# CONFIG_PREVENT_FIRMWARE_BUILD is not set
-# CONFIG_FW_LOADER is not set
-CONFIG_MTD=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_PHYSMAP=y
-CONFIG_BLK_DEV_LOOP=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_EEPROM_93CX6=y
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SMC91X=y
-# CONFIG_INPUT is not set
-# CONFIG_SERIO is not set
-# CONFIG_VT is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=4
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_UNIX98_PTYS is not set
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_HWMON is not set
-# CONFIG_USB_SUPPORT is not set
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_SH=y
-CONFIG_EXT2_FS=y
-# CONFIG_DNOTIFY is not set
-CONFIG_CONFIGFS_FS=y
-CONFIG_CRAMFS=y
-CONFIG_ROMFS_FS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_ROOT_NFS=y
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_DEBUG_KERNEL=y
-CONFIG_DETECT_HUNG_TASK=y
-CONFIG_DEBUG_SPINLOCK_SLEEP=y
-CONFIG_DEBUG_VM=y
-CONFIG_DEBUG_LIST=y
-CONFIG_FRAME_POINTER=y
-CONFIG_DEBUG_STACK_USAGE=y
-CONFIG_CRYPTO_DEFLATE=y
-CONFIG_CRYPTO_LZO=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-# CONFIG_CRYPTO_HW is not set
-CONFIG_CRC_CCITT=y
-CONFIG_CRC16=y
-CONFIG_CRC_ITU_T=y
-CONFIG_CRC7=y
-CONFIG_LIBCRC32C=y
diff --git a/arch/sh/configs/se7343_defconfig b/arch/sh/configs/se7343_defconfig
deleted file mode 100644
index 5d6c19338ebf29..00000000000000
--- a/arch/sh/configs/se7343_defconfig
+++ /dev/null
@@ -1,96 +0,0 @@
-# CONFIG_SWAP is not set
-CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_FUTEX is not set
-# CONFIG_EPOLL is not set
-# CONFIG_SHMEM is not set
-CONFIG_SLAB=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7343=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_MEMORY_SIZE=0x01000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_7343_SOLUTION_ENGINE=y
-# CONFIG_SH_TIMER_CMT is not set
-CONFIG_HEARTBEAT=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC0,115200"
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_SYN_COOKIES=y
-# CONFIG_INET_DIAG is not set
-# CONFIG_IPV6 is not set
-CONFIG_MTD=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_RAM=y
-CONFIG_MTD_PHYSMAP=y
-CONFIG_SCSI=y
-CONFIG_SCSI_MULTI_LUN=y
-# CONFIG_SCSI_LOWLEVEL is not set
-CONFIG_NETDEVICES=y
-CONFIG_USB_USBNET=y
-# CONFIG_USB_NET_AX8817X is not set
-CONFIG_USB_NET_DM9601=y
-# CONFIG_USB_NET_NET1080 is not set
-# CONFIG_USB_NET_CDC_SUBSET is not set
-# CONFIG_USB_NET_ZAURUS is not set
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_SERIAL_8250=y
-CONFIG_SERIAL_8250_NR_UARTS=2
-CONFIG_SERIAL_8250_RUNTIME_UARTS=2
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=4
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_UNIX98_PTYS is not set
-CONFIG_HW_RANDOM=y
-CONFIG_I2C=y
-CONFIG_I2C_SH_MOBILE=y
-# CONFIG_HWMON is not set
-CONFIG_FB=y
-CONFIG_FIRMWARE_EDID=y
-CONFIG_FB_SH_MOBILE_LCDC=m
-CONFIG_SOUND=y
-CONFIG_SND=y
-CONFIG_SND_SEQUENCER=y
-CONFIG_SND_PCM_OSS=y
-CONFIG_HID_A4TECH=y
-CONFIG_HID_APPLE=y
-CONFIG_HID_BELKIN=y
-CONFIG_HID_CHERRY=y
-CONFIG_HID_CHICONY=y
-CONFIG_HID_CYPRESS=y
-CONFIG_HID_EZKEY=y
-CONFIG_HID_GYRATION=y
-CONFIG_HID_LOGITECH=y
-CONFIG_HID_MICROSOFT=y
-CONFIG_HID_MONTEREY=y
-CONFIG_HID_PANTHERLORD=y
-CONFIG_HID_PETALYNX=y
-CONFIG_HID_SAMSUNG=y
-CONFIG_HID_SONY=y
-CONFIG_HID_SUNPLUS=y
-CONFIG_USB=y
-CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
-CONFIG_USB_ISP116X_HCD=y
-CONFIG_UIO=y
-CONFIG_EXT2_FS=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-# CONFIG_DNOTIFY is not set
-CONFIG_JFFS2_FS=y
-CONFIG_CRAMFS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_NFSD=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
diff --git a/arch/sh/configs/se7619_defconfig b/arch/sh/configs/se7619_defconfig
deleted file mode 100644
index 71a672c307168e..00000000000000
--- a/arch/sh/configs/se7619_defconfig
+++ /dev/null
@@ -1,43 +0,0 @@
-# CONFIG_LOCALVERSION_AUTO is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_UID16 is not set
-# CONFIG_KALLSYMS is not set
-# CONFIG_HOTPLUG is not set
-# CONFIG_ELF_CORE is not set
-# CONFIG_BASE_FULL is not set
-# CONFIG_FUTEX is not set
-# CONFIG_EPOLL is not set
-# CONFIG_VM_EVENT_COUNTERS is not set
-CONFIG_SLAB=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_CPU_BIG_ENDIAN=y
-CONFIG_SH_7619_SOLUTION_ENGINE=y
-CONFIG_HZ_100=y
-CONFIG_BINFMT_FLAT=y
-CONFIG_BINFMT_ZFLAT=y
-# CONFIG_STANDALONE is not set
-# CONFIG_PREVENT_FIRMWARE_BUILD is not set
-CONFIG_MTD=y
-CONFIG_MTD_REDBOOT_PARTS=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_PHYSMAP=y
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-# CONFIG_VT is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=3
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_UNIX98_PTYS is not set
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_HWMON is not set
-# CONFIG_DNOTIFY is not set
-# CONFIG_SYSFS is not set
-CONFIG_ROMFS_FS=y
-# CONFIG_ENABLE_MUST_CHECK is not set
diff --git a/arch/sh/configs/se7705_defconfig b/arch/sh/configs/se7705_defconfig
deleted file mode 100644
index ed00a6eeadf55e..00000000000000
--- a/arch/sh/configs/se7705_defconfig
+++ /dev/null
@@ -1,54 +0,0 @@
-# CONFIG_SWAP is not set
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-# CONFIG_KALLSYMS is not set
-# CONFIG_HOTPLUG is not set
-CONFIG_SLAB=y
-CONFIG_MODULES=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7705=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_MEMORY_SIZE=0x02000000
-CONFIG_FLATMEM_MANUAL=y
-# CONFIG_SH_ADC is not set
-CONFIG_SH_SOLUTION_ENGINE=y
-CONFIG_HEARTBEAT=y
-CONFIG_PREEMPT=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_IP_PNP_BOOTP=y
-CONFIG_IP_PNP_RARP=y
-# CONFIG_IPV6 is not set
-CONFIG_MTD=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_SIZE=8192
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_STNIC=y
-CONFIG_PPP=y
-CONFIG_PPP_ASYNC=y
-CONFIG_PPP_DEFLATE=y
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO_SERPORT is not set
-# CONFIG_VT is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_LEGACY_PTYS is not set
-CONFIG_HW_RANDOM=y
-CONFIG_EXT2_FS=y
-CONFIG_PROC_KCORE=y
-# CONFIG_SYSFS is not set
-CONFIG_JFFS2_FS=y
-CONFIG_NFS_FS=y
-CONFIG_ROOT_NFS=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
diff --git a/arch/sh/configs/se7712_defconfig b/arch/sh/configs/se7712_defconfig
deleted file mode 100644
index 36356223d51c83..00000000000000
--- a/arch/sh/configs/se7712_defconfig
+++ /dev/null
@@ -1,101 +0,0 @@
-# CONFIG_LOCALVERSION_AUTO is not set
-# CONFIG_SWAP is not set
-CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-CONFIG_KALLSYMS_ALL=y
-# CONFIG_BUG is not set
-# CONFIG_BASE_FULL is not set
-# CONFIG_SHMEM is not set
-CONFIG_SLAB=y
-CONFIG_MODULES=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7712=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_MEMORY_SIZE=0x02000000
-CONFIG_FLATMEM_MANUAL=y
-# CONFIG_SH_DSP is not set
-# CONFIG_SH_ADC is not set
-CONFIG_SH_SOLUTION_ENGINE=y
-CONFIG_SH_PCLK_FREQ=66666666
-CONFIG_HEARTBEAT=y
-CONFIG_PREEMPT_VOLUNTARY=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC0,115200 root=/dev/sda1"
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_MULTIPLE_TABLES=y
-CONFIG_IP_ROUTE_MULTIPATH=y
-CONFIG_IP_ROUTE_VERBOSE=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_IP_PNP_BOOTP=y
-CONFIG_IP_MROUTE=y
-CONFIG_IP_PIMSM_V1=y
-CONFIG_IP_PIMSM_V2=y
-CONFIG_SYN_COOKIES=y
-CONFIG_INET_AH=y
-CONFIG_INET_ESP=y
-CONFIG_INET_IPCOMP=y
-# CONFIG_INET_DIAG is not set
-# CONFIG_IPV6 is not set
-CONFIG_NET_SCHED=y
-CONFIG_NET_SCH_CBQ=y
-CONFIG_NET_SCH_HTB=y
-CONFIG_NET_SCH_HFSC=y
-CONFIG_NET_SCH_PRIO=y
-CONFIG_NET_SCH_RED=y
-CONFIG_NET_SCH_SFQ=y
-CONFIG_NET_SCH_TEQL=y
-CONFIG_NET_SCH_TBF=y
-CONFIG_NET_SCH_GRED=y
-CONFIG_NET_SCH_DSMARK=y
-CONFIG_NET_SCH_NETEM=y
-CONFIG_NET_CLS_TCINDEX=y
-CONFIG_NET_CLS_ROUTE4=y
-CONFIG_NET_CLS_FW=y
-CONFIG_MTD=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_ATA=y
-CONFIG_PATA_PLATFORM=y
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SH_ETH=y
-# CONFIG_INPUT is not set
-# CONFIG_SERIO is not set
-# CONFIG_VT is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_HWMON is not set
-CONFIG_NEW_LEDS=y
-CONFIG_LEDS_CLASS=y
-CONFIG_LEDS_TRIGGERS=y
-CONFIG_EXT2_FS=y
-CONFIG_EXT2_FS_XATTR=y
-CONFIG_EXT2_FS_POSIX_ACL=y
-CONFIG_EXT2_FS_SECURITY=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-# CONFIG_DNOTIFY is not set
-CONFIG_JFFS2_FS=y
-CONFIG_CRAMFS=y
-CONFIG_NFS_FS=y
-CONFIG_ROOT_NFS=y
-CONFIG_DEBUG_KERNEL=y
-CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
-CONFIG_FRAME_POINTER=y
-CONFIG_CRYPTO_ECB=m
-CONFIG_CRYPTO_PCBC=m
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRC_CCITT=y
diff --git a/arch/sh/configs/se7721_defconfig b/arch/sh/configs/se7721_defconfig
deleted file mode 100644
index 46c5a263a23925..00000000000000
--- a/arch/sh/configs/se7721_defconfig
+++ /dev/null
@@ -1,127 +0,0 @@
-# CONFIG_LOCALVERSION_AUTO is not set
-# CONFIG_SWAP is not set
-CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-CONFIG_KALLSYMS_ALL=y
-# CONFIG_BUG is not set
-# CONFIG_BASE_FULL is not set
-# CONFIG_SHMEM is not set
-CONFIG_SLAB=y
-CONFIG_MODULES=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7721=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_MEMORY_SIZE=0x02000000
-CONFIG_FLATMEM_MANUAL=y
-# CONFIG_SH_DSP is not set
-# CONFIG_SH_ADC is not set
-CONFIG_SH_7721_SOLUTION_ENGINE=y
-CONFIG_SH_PCLK_FREQ=33333333
-CONFIG_HEARTBEAT=y
-CONFIG_PREEMPT_VOLUNTARY=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC0,115200 root=/dev/sda2"
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_MULTIPLE_TABLES=y
-CONFIG_IP_ROUTE_MULTIPATH=y
-CONFIG_IP_ROUTE_VERBOSE=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_IP_MROUTE=y
-CONFIG_IP_PIMSM_V1=y
-CONFIG_IP_PIMSM_V2=y
-CONFIG_SYN_COOKIES=y
-CONFIG_INET_AH=y
-CONFIG_INET_ESP=y
-CONFIG_INET_IPCOMP=y
-# CONFIG_INET_DIAG is not set
-# CONFIG_IPV6 is not set
-CONFIG_NET_SCHED=y
-CONFIG_NET_SCH_CBQ=y
-CONFIG_NET_SCH_HTB=y
-CONFIG_NET_SCH_HFSC=y
-CONFIG_NET_SCH_PRIO=y
-CONFIG_NET_SCH_RED=y
-CONFIG_NET_SCH_SFQ=y
-CONFIG_NET_SCH_TEQL=y
-CONFIG_NET_SCH_TBF=y
-CONFIG_NET_SCH_GRED=y
-CONFIG_NET_SCH_DSMARK=y
-CONFIG_NET_SCH_NETEM=y
-CONFIG_NET_CLS_TCINDEX=y
-CONFIG_NET_CLS_ROUTE4=y
-CONFIG_NET_CLS_FW=y
-CONFIG_MTD=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_SCSI_MULTI_LUN=y
-# CONFIG_SCSI_LOWLEVEL is not set
-CONFIG_ATA=y
-CONFIG_PATA_PLATFORM=y
-CONFIG_NETDEVICES=y
-CONFIG_INPUT_FF_MEMLESS=m
-CONFIG_INPUT_EVDEV=y
-# CONFIG_KEYBOARD_ATKBD is not set
-# CONFIG_MOUSE_PS2 is not set
-# CONFIG_SERIO is not set
-# CONFIG_VT is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_HWMON is not set
-CONFIG_THERMAL=y
-CONFIG_HID_A4TECH=y
-CONFIG_HID_APPLE=y
-CONFIG_HID_BELKIN=y
-CONFIG_HID_CHERRY=y
-CONFIG_HID_CHICONY=y
-CONFIG_HID_CYPRESS=y
-CONFIG_HID_EZKEY=y
-CONFIG_HID_GYRATION=y
-CONFIG_HID_LOGITECH=y
-CONFIG_HID_MICROSOFT=y
-CONFIG_HID_MONTEREY=y
-CONFIG_HID_PANTHERLORD=y
-CONFIG_HID_PETALYNX=y
-CONFIG_HID_SAMSUNG=y
-CONFIG_HID_SONY=y
-CONFIG_HID_SUNPLUS=y
-CONFIG_USB=y
-CONFIG_USB_MON=y
-CONFIG_USB_OHCI_HCD=y
-CONFIG_USB_STORAGE=y
-CONFIG_NEW_LEDS=y
-CONFIG_LEDS_CLASS=y
-CONFIG_LEDS_TRIGGERS=y
-CONFIG_EXT2_FS=y
-CONFIG_EXT2_FS_XATTR=y
-CONFIG_EXT2_FS_POSIX_ACL=y
-CONFIG_EXT2_FS_SECURITY=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-# CONFIG_DNOTIFY is not set
-CONFIG_MSDOS_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_JFFS2_FS=y
-CONFIG_CRAMFS=y
-# CONFIG_NETWORK_FILESYSTEMS is not set
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_CODEPAGE_932=y
-CONFIG_NLS_ISO8859_1=y
-CONFIG_DEBUG_KERNEL=y
-CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
-CONFIG_FRAME_POINTER=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRC_CCITT=y
diff --git a/arch/sh/configs/se7722_defconfig b/arch/sh/configs/se7722_defconfig
deleted file mode 100644
index 09e45581744743..00000000000000
--- a/arch/sh/configs/se7722_defconfig
+++ /dev/null
@@ -1,56 +0,0 @@
-CONFIG_SYSVIPC=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_PROFILING=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7722=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_NUMA=y
-CONFIG_SH_STORE_QUEUES=y
-CONFIG_SH_7722_SOLUTION_ENGINE=y
-# CONFIG_SH_TIMER_CMT is not set
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_HEARTBEAT=y
-CONFIG_KEXEC=y
-CONFIG_PREEMPT=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-# CONFIG_IPV6 is not set
-# CONFIG_FW_LOADER is not set
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_ATA=y
-CONFIG_PATA_PLATFORM=y
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SMC91X=y
-# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO_SERPORT is not set
-# CONFIG_VT is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=3
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_HW_RANDOM=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_SH=y
-CONFIG_EXT2_FS=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_HUGETLBFS=y
-CONFIG_PRINTK_TIME=y
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_MAGIC_SYSRQ=y
-CONFIG_DEBUG_FS=y
-CONFIG_SH_STANDARD_BIOS=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
diff --git a/arch/sh/configs/se7724_defconfig b/arch/sh/configs/se7724_defconfig
deleted file mode 100644
index d817df7cc4a72a..00000000000000
--- a/arch/sh/configs/se7724_defconfig
+++ /dev/null
@@ -1,132 +0,0 @@
-# CONFIG_LOCALVERSION_AUTO is not set
-CONFIG_SYSVIPC=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_KALLSYMS is not set
-CONFIG_SLAB=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7724=y
-CONFIG_MEMORY_SIZE=0x08000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_7724_SOLUTION_ENGINE=y
-# CONFIG_SH_TIMER_CMT is not set
-CONFIG_SH_DMA=y
-CONFIG_SH_DMA_API=y
-CONFIG_HEARTBEAT=y
-CONFIG_SECCOMP=y
-CONFIG_PREEMPT=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=tty1 console=ttySC3,115200 root=/dev/nfs ip=dhcp memchunk.vpu=4m"
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_IPV6 is not set
-CONFIG_MTD=y
-CONFIG_MTD_CMDLINE_PARTS=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_PHYSMAP=y
-CONFIG_MTD_RAW_NAND=y
-CONFIG_MTD_UBI=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_RAM_COUNT=4
-CONFIG_SCSI=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_NETDEVICES=y
-CONFIG_SMSC_PHY=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SH_ETH=y
-CONFIG_SMC91X=y
-# CONFIG_INPUT_MOUSEDEV is not set
-CONFIG_INPUT_EVDEV=y
-# CONFIG_KEYBOARD_ATKBD is not set
-CONFIG_KEYBOARD_SH_KEYSC=y
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_VT_HW_CONSOLE_BINDING=y
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=6
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_HW_RANDOM=y
-CONFIG_I2C=y
-CONFIG_I2C_CHARDEV=y
-CONFIG_I2C_SH_MOBILE=y
-CONFIG_SPI=y
-CONFIG_SPI_BITBANG=y
-# CONFIG_HWMON is not set
-CONFIG_MEDIA_SUPPORT=y
-CONFIG_VIDEO_DEV=y
-# CONFIG_VIDEO_ALLOW_V4L1 is not set
-CONFIG_DVB_CORE=m
-# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
-CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
-CONFIG_VIDEO_SH_MOBILE_CEU=y
-# CONFIG_RADIO_ADAPTERS is not set
-# CONFIG_DVB_FE_CUSTOMISE is not set
-CONFIG_FB=y
-CONFIG_FB_SH_MOBILE_LCDC=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_LOGO=y
-# CONFIG_LOGO_LINUX_MONO is not set
-# CONFIG_LOGO_LINUX_VGA16 is not set
-# CONFIG_LOGO_LINUX_CLUT224 is not set
-# CONFIG_LOGO_SUPERH_MONO is not set
-# CONFIG_LOGO_SUPERH_VGA16 is not set
-CONFIG_SOUND=y
-CONFIG_SND=m
-# CONFIG_SND_SUPPORT_OLD_API is not set
-# CONFIG_SND_DRIVERS is not set
-# CONFIG_SND_SPI is not set
-# CONFIG_SND_SUPERH is not set
-CONFIG_SND_SOC=m
-CONFIG_SND_SOC_SH4_FSI=m
-CONFIG_SND_FSI_AK4642=y
-CONFIG_SND_SOC_ALL_CODECS=m
-CONFIG_USB=y
-CONFIG_USB_MON=y
-CONFIG_USB_R8A66597_HCD=y
-CONFIG_USB_STORAGE=y
-CONFIG_USB_GADGET=y
-CONFIG_USB_ETH=m
-CONFIG_USB_GADGETFS=m
-CONFIG_USB_MASS_STORAGE=m
-CONFIG_USB_G_SERIAL=m
-CONFIG_MMC=y
-CONFIG_MMC_SPI=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_PCF8563=y
-CONFIG_UIO=y
-CONFIG_UIO_PDRV_GENIRQ=y
-CONFIG_EXT2_FS=y
-CONFIG_EXT2_FS_XATTR=y
-CONFIG_EXT2_FS_POSIX_ACL=y
-CONFIG_EXT2_FS_SECURITY=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_EXT3_FS_POSIX_ACL=y
-CONFIG_EXT3_FS_SECURITY=y
-CONFIG_VFAT_FS=y
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_ROOT_NFS=y
-CONFIG_NFSD=y
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_CODEPAGE_932=y
-CONFIG_NLS_ISO8859_1=y
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_CRYPTO=y
-CONFIG_CRYPTO_CBC=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRC_T10DIF=y
diff --git a/arch/sh/configs/se7750_defconfig b/arch/sh/configs/se7750_defconfig
deleted file mode 100644
index 4defc7628a498a..00000000000000
--- a/arch/sh/configs/se7750_defconfig
+++ /dev/null
@@ -1,55 +0,0 @@
-# CONFIG_SWAP is not set
-CONFIG_SYSVIPC=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-# CONFIG_HOTPLUG is not set
-CONFIG_SLAB=y
-CONFIG_MODULES=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7750=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_MEMORY_SIZE=0x02000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_SOLUTION_ENGINE=y
-CONFIG_SH_PCLK_FREQ=33333333
-CONFIG_HEARTBEAT=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IPV6 is not set
-CONFIG_MTD=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_ROM=y
-CONFIG_SCSI=y
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_STNIC=y
-# CONFIG_INPUT is not set
-# CONFIG_SERIO is not set
-# CONFIG_VT is not set
-CONFIG_SERIAL_8250=y
-CONFIG_SERIAL_8250_NR_UARTS=2
-CONFIG_SERIAL_8250_RUNTIME_UARTS=2
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_HW_RANDOM=y
-CONFIG_WATCHDOG=y
-CONFIG_SH_WDT=y
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_JFFS2_FS=y
-CONFIG_NFS_FS=y
-CONFIG_ROOT_NFS=y
-CONFIG_PARTITION_ADVANCED=y
-# CONFIG_MSDOS_PARTITION is not set
-# CONFIG_ENABLE_MUST_CHECK is not set
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
diff --git a/arch/sh/configs/se7751_defconfig b/arch/sh/configs/se7751_defconfig
deleted file mode 100644
index 4a024065bb7501..00000000000000
--- a/arch/sh/configs/se7751_defconfig
+++ /dev/null
@@ -1,46 +0,0 @@
-CONFIG_SYSVIPC=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-# CONFIG_HOTPLUG is not set
-CONFIG_SLAB=y
-CONFIG_MODULES=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7751=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_7751_SOLUTION_ENGINE=y
-CONFIG_HEARTBEAT=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC1,38400"
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_IP_PNP_BOOTP=y
-CONFIG_IP_PNP_RARP=y
-# CONFIG_IPV6 is not set
-CONFIG_NETFILTER=y
-CONFIG_MTD=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_RAM=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_MII=y
-# CONFIG_INPUT is not set
-# CONFIG_SERIO is not set
-# CONFIG_VT is not set
-CONFIG_HW_RANDOM=y
-CONFIG_WATCHDOG=y
-CONFIG_EXT2_FS=y
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_JFFS2_FS=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
diff --git a/arch/sh/configs/se7780_defconfig b/arch/sh/configs/se7780_defconfig
deleted file mode 100644
index dcd85b858ac8ca..00000000000000
--- a/arch/sh/configs/se7780_defconfig
+++ /dev/null
@@ -1,106 +0,0 @@
-# CONFIG_SWAP is not set
-CONFIG_SYSVIPC=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_KALLSYMS is not set
-# CONFIG_HOTPLUG is not set
-# CONFIG_EPOLL is not set
-CONFIG_SLAB=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-CONFIG_CPU_SUBTYPE_SH7780=y
-CONFIG_MEMORY_SIZE=0x08000000
-CONFIG_SH_7780_SOLUTION_ENGINE=y
-CONFIG_SH_PCLK_FREQ=33333333
-CONFIG_HEARTBEAT=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC0,115200 root=/dev/sda1"
-CONFIG_PCI=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_PNP=y
-CONFIG_IPV6=y
-# CONFIG_INET6_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET6_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET6_XFRM_MODE_BEET is not set
-# CONFIG_IPV6_SIT is not set
-# CONFIG_PREVENT_FIRMWARE_BUILD is not set
-CONFIG_MTD=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_ADV_OPTIONS=y
-CONFIG_MTD_CFI_GEOMETRY=y
-# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_2 is not set
-# CONFIG_MTD_CFI_I1 is not set
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_ROM=y
-CONFIG_BLK_DEV_LOOP=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_CHR_DEV_SG=y
-CONFIG_ATA=y
-CONFIG_SATA_SIL=y
-CONFIG_NETDEVICES=y
-CONFIG_PHYLIB=y
-CONFIG_SMSC_PHY=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SMC91X=y
-CONFIG_NET_PCI=y
-CONFIG_INPUT_FF_MEMLESS=m
-# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_HW_RANDOM is not set
-CONFIG_THERMAL=y
-CONFIG_FB=y
-CONFIG_FIRMWARE_EDID=y
-CONFIG_FB_SH_MOBILE_LCDC=m
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_LOGO=y
-# CONFIG_LOGO_LINUX_MONO is not set
-# CONFIG_LOGO_LINUX_VGA16 is not set
-# CONFIG_LOGO_SUPERH_MONO is not set
-# CONFIG_LOGO_SUPERH_VGA16 is not set
-CONFIG_SOUND=y
-CONFIG_SOUND_PRIME=y
-CONFIG_HID_A4TECH=y
-CONFIG_HID_APPLE=y
-CONFIG_HID_BELKIN=y
-CONFIG_HID_CHERRY=y
-CONFIG_HID_CHICONY=y
-CONFIG_HID_CYPRESS=y
-CONFIG_HID_EZKEY=y
-CONFIG_HID_GYRATION=y
-CONFIG_HID_LOGITECH=y
-CONFIG_HID_MICROSOFT=y
-CONFIG_HID_MONTEREY=y
-CONFIG_HID_PANTHERLORD=y
-CONFIG_HID_PETALYNX=y
-CONFIG_HID_SAMSUNG=y
-CONFIG_HID_SONY=y
-CONFIG_HID_SUNPLUS=y
-CONFIG_USB=y
-CONFIG_USB_MON=y
-CONFIG_USB_EHCI_HCD=y
-CONFIG_USB_OHCI_HCD=y
-CONFIG_USB_STORAGE=y
-CONFIG_EXT2_FS=y
-# CONFIG_DNOTIFY is not set
-CONFIG_MSDOS_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_CRAMFS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_ROOT_NFS=y
-CONFIG_DEBUG_FS=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
diff --git a/arch/sh/configs/secureedge5410_defconfig b/arch/sh/configs/secureedge5410_defconfig
deleted file mode 100644
index 8422599cfb04dc..00000000000000
--- a/arch/sh/configs/secureedge5410_defconfig
+++ /dev/null
@@ -1,53 +0,0 @@
-# CONFIG_SWAP is not set
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_HOTPLUG is not set
-CONFIG_SLAB=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7751R=y
-CONFIG_MEMORY_SIZE=0x01000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_SECUREEDGE5410=y
-CONFIG_SH_DMA=y
-CONFIG_SH_DMA_API=y
-CONFIG_PCI=y
-CONFIG_NET=y
-CONFIG_INET=y
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_INET_DIAG is not set
-# CONFIG_IPV6 is not set
-CONFIG_MTD=y
-CONFIG_MTD_BLOCK_RO=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_ADV_OPTIONS=y
-CONFIG_MTD_CFI_GEOMETRY=y
-# CONFIG_MTD_MAP_BANK_WIDTH_2 is not set
-# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
-# CONFIG_MTD_CFI_I2 is not set
-CONFIG_MTD_CFI_INTELEXT=y
-CONFIG_MTD_PLATRAM=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_NET_PCI=y
-CONFIG_8139CP=y
-CONFIG_8139TOO=y
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-# CONFIG_VT is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_HW_RANDOM is not set
-# CONFIG_HWMON is not set
-# CONFIG_USB_SUPPORT is not set
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_DS1302=y
-CONFIG_EXT2_FS=y
-# CONFIG_DNOTIFY is not set
-CONFIG_TMPFS=y
-CONFIG_CRAMFS=y
-CONFIG_ROMFS_FS=y
diff --git a/arch/sh/configs/sh03_defconfig b/arch/sh/configs/sh03_defconfig
deleted file mode 100644
index 9fcf68b22dba9a..00000000000000
--- a/arch/sh/configs/sh03_defconfig
+++ /dev/null
@@ -1,126 +0,0 @@
-CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_SLAB=y
-CONFIG_PROFILING=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-CONFIG_MODVERSIONS=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7751=y
-CONFIG_MEMORY_SIZE=0x08000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_SH03=y
-CONFIG_HEARTBEAT=y
-CONFIG_PREEMPT=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC1,115200 mem=64M root=/dev/nfs"
-CONFIG_PCI=y
-CONFIG_HOTPLUG_PCI=y
-CONFIG_BINFMT_MISC=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_IP_PNP_BOOTP=y
-CONFIG_IP_PNP_RARP=y
-# CONFIG_IPV6 is not set
-# CONFIG_STANDALONE is not set
-# CONFIG_PREVENT_FIRMWARE_BUILD is not set
-# CONFIG_FW_LOADER is not set
-CONFIG_BLK_DEV_LOOP=y
-CONFIG_BLK_DEV_NBD=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_SCSI=m
-CONFIG_BLK_DEV_SD=m
-CONFIG_BLK_DEV_SR=m
-CONFIG_CHR_DEV_SG=m
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_NET_PCI=y
-CONFIG_8139CP=y
-# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_SERIAL_8250=m
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_HW_RANDOM=y
-CONFIG_WATCHDOG=y
-CONFIG_SH_WDT=m
-CONFIG_EXT2_FS=y
-CONFIG_EXT2_FS_XATTR=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_EXT3_FS_POSIX_ACL=y
-CONFIG_AUTOFS4_FS=y
-CONFIG_ISO9660_FS=m
-CONFIG_JOLIET=y
-CONFIG_ZISOFS=y
-CONFIG_UDF_FS=m
-CONFIG_MSDOS_FS=m
-CONFIG_VFAT_FS=m
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_NFS_V4=y
-CONFIG_ROOT_NFS=y
-CONFIG_NFSD=y
-CONFIG_PARTITION_ADVANCED=y
-CONFIG_NLS_CODEPAGE_437=m
-CONFIG_NLS_CODEPAGE_737=m
-CONFIG_NLS_CODEPAGE_775=m
-CONFIG_NLS_CODEPAGE_850=m
-CONFIG_NLS_CODEPAGE_852=m
-CONFIG_NLS_CODEPAGE_855=m
-CONFIG_NLS_CODEPAGE_857=m
-CONFIG_NLS_CODEPAGE_860=m
-CONFIG_NLS_CODEPAGE_861=m
-CONFIG_NLS_CODEPAGE_862=m
-CONFIG_NLS_CODEPAGE_863=m
-CONFIG_NLS_CODEPAGE_864=m
-CONFIG_NLS_CODEPAGE_865=m
-CONFIG_NLS_CODEPAGE_866=m
-CONFIG_NLS_CODEPAGE_869=m
-CONFIG_NLS_CODEPAGE_936=m
-CONFIG_NLS_CODEPAGE_950=m
-CONFIG_NLS_CODEPAGE_932=m
-CONFIG_NLS_CODEPAGE_949=m
-CONFIG_NLS_CODEPAGE_874=m
-CONFIG_NLS_ISO8859_8=m
-CONFIG_NLS_CODEPAGE_1250=m
-CONFIG_NLS_CODEPAGE_1251=m
-CONFIG_NLS_ASCII=m
-CONFIG_NLS_ISO8859_1=m
-CONFIG_NLS_ISO8859_2=m
-CONFIG_NLS_ISO8859_3=m
-CONFIG_NLS_ISO8859_4=m
-CONFIG_NLS_ISO8859_5=m
-CONFIG_NLS_ISO8859_6=m
-CONFIG_NLS_ISO8859_7=m
-CONFIG_NLS_ISO8859_9=m
-CONFIG_NLS_ISO8859_13=m
-CONFIG_NLS_ISO8859_14=m
-CONFIG_NLS_ISO8859_15=m
-CONFIG_NLS_KOI8_R=m
-CONFIG_NLS_KOI8_U=m
-CONFIG_NLS_UTF8=m
-CONFIG_DEBUG_FS=y
-CONFIG_SH_STANDARD_BIOS=y
-CONFIG_CRYPTO_ECB=m
-CONFIG_CRYPTO_HMAC=y
-CONFIG_CRYPTO_SHA1=y
-CONFIG_CRYPTO_DEFLATE=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRC_CCITT=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_GENERIC=y
diff --git a/arch/sh/configs/sh2007_defconfig b/arch/sh/configs/sh2007_defconfig
deleted file mode 100644
index 259c69e3fa2279..00000000000000
--- a/arch/sh/configs/sh2007_defconfig
+++ /dev/null
@@ -1,199 +0,0 @@
-# CONFIG_LOCALVERSION_AUTO is not set
-CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_AUDIT=y
-CONFIG_AUDITSYSCALL=y
-CONFIG_IKCONFIG=y
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-CONFIG_KALLSYMS_ALL=y
-CONFIG_SLAB=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7780=y
-CONFIG_MEMORY_SIZE=0x08000000
-# CONFIG_VSYSCALL is not set
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_SH2007=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_SH_DMA=y
-CONFIG_SH_DMA_API=y
-CONFIG_NR_DMA_CHANNELS_BOOL=y
-CONFIG_HZ_100=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC1,115200 ip=dhcp root=/dev/nfs rw nfsroot=/nfs/rootfs,rsize=1024,wsize=1024 earlyprintk=sh-sci.1"
-CONFIG_PCCARD=y
-CONFIG_BINFMT_MISC=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_XFRM_USER=y
-CONFIG_NET_KEY=y
-CONFIG_NET_KEY_MIGRATE=y
-CONFIG_INET=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_MULTIPLE_TABLES=y
-CONFIG_IP_ROUTE_MULTIPATH=y
-CONFIG_IP_ROUTE_VERBOSE=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_NET_IPIP=y
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-# CONFIG_IPV6 is not set
-CONFIG_NETWORK_SECMARK=y
-CONFIG_NET_PKTGEN=y
-CONFIG_BLK_DEV_LOOP=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_CDROM_PKTCDVD=y
-CONFIG_RAID_ATTRS=y
-CONFIG_SCSI=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_BLK_DEV_SR=y
-CONFIG_CHR_DEV_SG=y
-CONFIG_SCSI_MULTI_LUN=y
-CONFIG_SCSI_CONSTANTS=y
-CONFIG_SCSI_LOGGING=y
-CONFIG_SCSI_SCAN_ASYNC=y
-CONFIG_SCSI_SPI_ATTRS=y
-CONFIG_SCSI_FC_ATTRS=y
-CONFIG_SCSI_ISCSI_ATTRS=y
-CONFIG_SCSI_SRP_ATTRS=y
-# CONFIG_SCSI_LOWLEVEL is not set
-CONFIG_NETDEVICES=y
-CONFIG_DUMMY=y
-CONFIG_EQUALIZER=y
-CONFIG_TUN=y
-CONFIG_VETH=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SMSC911X=y
-# CONFIG_WLAN is not set
-CONFIG_INPUT_FF_MEMLESS=y
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_VT_HW_CONSOLE_BINDING=y
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_HWMON is not set
-CONFIG_WATCHDOG=y
-CONFIG_SH_WDT=y
-CONFIG_SSB=y
-CONFIG_FB=y
-# CONFIG_LCD_CLASS_DEVICE is not set
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
-CONFIG_LOGO=y
-CONFIG_USB=y
-CONFIG_USB_MON=y
-CONFIG_NEW_LEDS=y
-CONFIG_LEDS_CLASS=y
-CONFIG_LEDS_TRIGGERS=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_INTF_DEV_UIE_EMUL=y
-CONFIG_DMADEVICES=y
-CONFIG_TIMB_DMA=y
-CONFIG_EXT3_FS=y
-CONFIG_ISO9660_FS=y
-CONFIG_JOLIET=y
-CONFIG_ZISOFS=y
-CONFIG_UDF_FS=y
-CONFIG_MSDOS_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_FAT_DEFAULT_CODEPAGE=932
-CONFIG_FAT_DEFAULT_IOCHARSET="ascii"
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_TMPFS_POSIX_ACL=y
-CONFIG_CONFIGFS_FS=y
-# CONFIG_MISC_FILESYSTEMS is not set
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_NFS_V3_ACL=y
-CONFIG_NFS_V4=y
-CONFIG_ROOT_NFS=y
-CONFIG_NLS_DEFAULT="utf8"
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_CODEPAGE_737=y
-CONFIG_NLS_CODEPAGE_775=y
-CONFIG_NLS_CODEPAGE_850=y
-CONFIG_NLS_CODEPAGE_852=y
-CONFIG_NLS_CODEPAGE_855=y
-CONFIG_NLS_CODEPAGE_857=y
-CONFIG_NLS_CODEPAGE_860=y
-CONFIG_NLS_CODEPAGE_861=y
-CONFIG_NLS_CODEPAGE_862=y
-CONFIG_NLS_CODEPAGE_863=y
-CONFIG_NLS_CODEPAGE_864=y
-CONFIG_NLS_CODEPAGE_865=y
-CONFIG_NLS_CODEPAGE_866=y
-CONFIG_NLS_CODEPAGE_869=y
-CONFIG_NLS_CODEPAGE_936=y
-CONFIG_NLS_CODEPAGE_950=y
-CONFIG_NLS_CODEPAGE_932=y
-CONFIG_NLS_CODEPAGE_949=y
-CONFIG_NLS_CODEPAGE_874=y
-CONFIG_NLS_ISO8859_8=y
-CONFIG_NLS_CODEPAGE_1250=y
-CONFIG_NLS_CODEPAGE_1251=y
-CONFIG_NLS_ASCII=y
-CONFIG_NLS_ISO8859_1=y
-CONFIG_NLS_ISO8859_2=y
-CONFIG_NLS_ISO8859_3=y
-CONFIG_NLS_ISO8859_4=y
-CONFIG_NLS_ISO8859_5=y
-CONFIG_NLS_ISO8859_6=y
-CONFIG_NLS_ISO8859_7=y
-CONFIG_NLS_ISO8859_9=y
-CONFIG_NLS_ISO8859_13=y
-CONFIG_NLS_ISO8859_14=y
-CONFIG_NLS_ISO8859_15=y
-CONFIG_NLS_KOI8_R=y
-CONFIG_NLS_KOI8_U=y
-CONFIG_NLS_UTF8=y
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_DEBUG_FS=y
-CONFIG_DEBUG_KERNEL=y
-# CONFIG_DETECT_SOFTLOCKUP is not set
-# CONFIG_SCHED_DEBUG is not set
-CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
-CONFIG_FRAME_POINTER=y
-CONFIG_SH_STANDARD_BIOS=y
-CONFIG_CRYPTO_NULL=y
-CONFIG_CRYPTO_AUTHENC=y
-CONFIG_CRYPTO_ECB=y
-CONFIG_CRYPTO_LRW=y
-CONFIG_CRYPTO_PCBC=y
-CONFIG_CRYPTO_XTS=y
-CONFIG_CRYPTO_HMAC=y
-CONFIG_CRYPTO_XCBC=y
-CONFIG_CRYPTO_MD4=y
-CONFIG_CRYPTO_MICHAEL_MIC=y
-CONFIG_CRYPTO_SHA1=y
-CONFIG_CRYPTO_SHA256=y
-CONFIG_CRYPTO_SHA512=y
-CONFIG_CRYPTO_TGR192=y
-CONFIG_CRYPTO_WP512=y
-CONFIG_CRYPTO_AES=y
-CONFIG_CRYPTO_ANUBIS=y
-CONFIG_CRYPTO_ARC4=y
-CONFIG_CRYPTO_BLOWFISH=y
-CONFIG_CRYPTO_CAMELLIA=y
-CONFIG_CRYPTO_CAST5=y
-CONFIG_CRYPTO_CAST6=y
-CONFIG_CRYPTO_FCRYPT=y
-CONFIG_CRYPTO_KHAZAD=y
-CONFIG_CRYPTO_SEED=y
-CONFIG_CRYPTO_SERPENT=y
-CONFIG_CRYPTO_TEA=y
-CONFIG_CRYPTO_TWOFISH=y
-CONFIG_CRYPTO_DEFLATE=y
-CONFIG_CRYPTO_LZO=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-# CONFIG_CRYPTO_HW is not set
-CONFIG_CRC_CCITT=y
-CONFIG_CRC16=y
-CONFIG_LIBCRC32C=y
diff --git a/arch/sh/configs/sh7710voipgw_defconfig b/arch/sh/configs/sh7710voipgw_defconfig
deleted file mode 100644
index 0d814770b07fe9..00000000000000
--- a/arch/sh/configs/sh7710voipgw_defconfig
+++ /dev/null
@@ -1,55 +0,0 @@
-# CONFIG_SWAP is not set
-CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_FUTEX is not set
-# CONFIG_EPOLL is not set
-# CONFIG_SHMEM is not set
-CONFIG_SLAB=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7710=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_MEMORY_SIZE=0x00800000
-CONFIG_FLATMEM_MANUAL=y
-# CONFIG_SH_ADC is not set
-CONFIG_SH_PCLK_FREQ=32768000
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_SYN_COOKIES=y
-# CONFIG_INET_DIAG is not set
-# CONFIG_IPV6 is not set
-CONFIG_NETFILTER=y
-CONFIG_NET_SCHED=y
-CONFIG_NET_SCH_CBQ=y
-CONFIG_NET_CLS_BASIC=y
-CONFIG_NET_CLS_TCINDEX=y
-CONFIG_NET_CLS_ROUTE4=y
-CONFIG_NET_CLS_U32=y
-CONFIG_MTD=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_RAM=y
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_PHONE=y
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-# CONFIG_VT is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_UNIX98_PTYS is not set
-CONFIG_HW_RANDOM=y
-# CONFIG_HWMON is not set
-CONFIG_THERMAL=y
-# CONFIG_DNOTIFY is not set
-CONFIG_JFFS2_FS=y
-CONFIG_DEBUG_FS=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
diff --git a/arch/sh/configs/sh7724_generic_defconfig b/arch/sh/configs/sh7724_generic_defconfig
deleted file mode 100644
index cbc9389a89a8c0..00000000000000
--- a/arch/sh/configs/sh7724_generic_defconfig
+++ /dev/null
@@ -1,41 +0,0 @@
-# CONFIG_LOCALVERSION_AUTO is not set
-CONFIG_SYSVIPC=y
-CONFIG_CGROUPS=y
-# CONFIG_UID16 is not set
-# CONFIG_COMPAT_BRK is not set
-CONFIG_PROFILING=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7724=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_CPU_FREQ=y
-CONFIG_SH_CPU_FREQ=y
-CONFIG_KEXEC=y
-CONFIG_KEXEC_JUMP=y
-CONFIG_HIBERNATION=y
-CONFIG_CPU_IDLE=y
-# CONFIG_PREVENT_FIRMWARE_BUILD is not set
-# CONFIG_INPUT is not set
-# CONFIG_SERIO is not set
-# CONFIG_VT is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=6
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_UNIX98_PTYS is not set
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_HW_RANDOM is not set
-CONFIG_I2C=y
-CONFIG_I2C_CHARDEV=y
-CONFIG_I2C_SH_MOBILE=y
-# CONFIG_HWMON is not set
-# CONFIG_USB_SUPPORT is not set
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_SH=y
-CONFIG_UIO=y
-CONFIG_UIO_PDRV_GENIRQ=y
-# CONFIG_DNOTIFY is not set
-# CONFIG_PROC_FS is not set
-# CONFIG_SYSFS is not set
-# CONFIG_MISC_FILESYSTEMS is not set
-# CONFIG_ENABLE_MUST_CHECK is not set
-# CONFIG_CRC32 is not set
diff --git a/arch/sh/configs/sh7757lcr_defconfig b/arch/sh/configs/sh7757lcr_defconfig
deleted file mode 100644
index 2579dc4bc0c8f6..00000000000000
--- a/arch/sh/configs/sh7757lcr_defconfig
+++ /dev/null
@@ -1,85 +0,0 @@
-# CONFIG_SWAP is not set
-CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_TASKSTATS=y
-CONFIG_TASK_DELAY_ACCT=y
-CONFIG_TASK_XACCT=y
-CONFIG_TASK_IO_ACCOUNTING=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_KALLSYMS_ALL=y
-CONFIG_SLAB=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7757=y
-CONFIG_MEMORY_START=0x40000000
-CONFIG_MEMORY_SIZE=0x0f000000
-CONFIG_PMB=y
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_SH7757LCR=y
-CONFIG_HEARTBEAT=y
-CONFIG_SECCOMP=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC2,115200 root=/dev/nfs ip=dhcp"
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_IPV6=y
-# CONFIG_WIRELESS is not set
-# CONFIG_FW_LOADER is not set
-CONFIG_MTD=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_SPI_NOR=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_SCSI=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_NETDEVICES=y
-CONFIG_VITESSE_PHY=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SH_ETH=y
-# CONFIG_WLAN is not set
-# CONFIG_KEYBOARD_ATKBD is not set
-# CONFIG_MOUSE_PS2 is not set
-# CONFIG_SERIO is not set
-# CONFIG_LEGACY_PTYS is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=3
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_HW_RANDOM is not set
-CONFIG_SPI=y
-CONFIG_SPI_SH=y
-# CONFIG_HWMON is not set
-CONFIG_USB=y
-CONFIG_USB_EHCI_HCD=y
-CONFIG_USB_EHCI_SH=y
-CONFIG_USB_OHCI_HCD=y
-CONFIG_USB_OHCI_SH=y
-CONFIG_USB_STORAGE=y
-CONFIG_MMC=y
-CONFIG_MMC_SDHI=y
-CONFIG_MMC_SH_MMCIF=y
-CONFIG_EXT2_FS=y
-CONFIG_EXT3_FS=y
-CONFIG_ISO9660_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_SQUASHFS=y
-CONFIG_MINIX_FS=y
-CONFIG_NFS_FS=y
-CONFIG_ROOT_NFS=y
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_CODEPAGE_932=y
-CONFIG_NLS_ISO8859_1=y
-CONFIG_DEBUG_KERNEL=y
-# CONFIG_SCHED_DEBUG is not set
-# CONFIG_DEBUG_BUGVERBOSE is not set
-CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
-# CONFIG_FTRACE is not set
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
diff --git a/arch/sh/configs/sh7763rdp_defconfig b/arch/sh/configs/sh7763rdp_defconfig
deleted file mode 100644
index 8a6a446f9eb88a..00000000000000
--- a/arch/sh/configs/sh7763rdp_defconfig
+++ /dev/null
@@ -1,116 +0,0 @@
-CONFIG_SYSVIPC=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_NAMESPACES=y
-CONFIG_UTS_NS=y
-CONFIG_IPC_NS=y
-CONFIG_SLAB=y
-CONFIG_PROFILING=y
-CONFIG_MODULES=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7763=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_SH_SH7763RDP=y
-CONFIG_SH_PCLK_FREQ=66666666
-CONFIG_SECCOMP=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC2,115200 root=/dev/sda1 rootdelay=10"
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_IP_PNP_BOOTP=y
-# CONFIG_IPV6 is not set
-CONFIG_MTD=y
-CONFIG_MTD_CMDLINE_PARTS=y
-CONFIG_MTD_BLKDEVS=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_JEDECPROBE=y
-CONFIG_MTD_CFI_ADV_OPTIONS=y
-CONFIG_MTD_CFI_GEOMETRY=y
-# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
-CONFIG_MTD_CFI_INTELEXT=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_CFI_STAA=y
-CONFIG_MTD_COMPLEX_MAPPINGS=y
-CONFIG_MTD_PHYSMAP=y
-CONFIG_SCSI=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SH_ETH=y
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=3
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_HW_RANDOM=y
-# CONFIG_HWMON is not set
-CONFIG_FB=y
-CONFIG_FB_FOREIGN_ENDIAN=y
-CONFIG_FB_SH7760=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_LOGO=y
-CONFIG_USB=y
-CONFIG_USB_MON=y
-CONFIG_USB_OHCI_HCD=y
-CONFIG_USB_STORAGE=y
-CONFIG_MMC=y
-CONFIG_EXT2_FS=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_AUTOFS4_FS=y
-CONFIG_MSDOS_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_TMPFS_POSIX_ACL=y
-CONFIG_NFS_FS=y
-CONFIG_ROOT_NFS=y
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_CODEPAGE_737=y
-CONFIG_NLS_CODEPAGE_775=y
-CONFIG_NLS_CODEPAGE_850=y
-CONFIG_NLS_CODEPAGE_852=y
-CONFIG_NLS_CODEPAGE_855=y
-CONFIG_NLS_CODEPAGE_857=y
-CONFIG_NLS_CODEPAGE_860=y
-CONFIG_NLS_CODEPAGE_861=y
-CONFIG_NLS_CODEPAGE_862=y
-CONFIG_NLS_CODEPAGE_863=y
-CONFIG_NLS_CODEPAGE_864=y
-CONFIG_NLS_CODEPAGE_865=y
-CONFIG_NLS_CODEPAGE_866=y
-CONFIG_NLS_CODEPAGE_869=y
-CONFIG_NLS_CODEPAGE_936=y
-CONFIG_NLS_CODEPAGE_950=y
-CONFIG_NLS_CODEPAGE_932=y
-CONFIG_NLS_CODEPAGE_949=y
-CONFIG_NLS_CODEPAGE_874=y
-CONFIG_NLS_ISO8859_8=y
-CONFIG_NLS_CODEPAGE_1250=y
-CONFIG_NLS_CODEPAGE_1251=y
-CONFIG_NLS_ASCII=y
-CONFIG_NLS_ISO8859_1=y
-CONFIG_NLS_ISO8859_2=y
-CONFIG_NLS_ISO8859_3=y
-CONFIG_NLS_ISO8859_4=y
-CONFIG_NLS_ISO8859_5=y
-CONFIG_NLS_ISO8859_6=y
-CONFIG_NLS_ISO8859_7=y
-CONFIG_NLS_ISO8859_9=y
-CONFIG_NLS_ISO8859_13=y
-CONFIG_NLS_ISO8859_14=y
-CONFIG_NLS_ISO8859_15=y
-CONFIG_NLS_KOI8_R=y
-CONFIG_NLS_KOI8_U=y
-CONFIG_NLS_UTF8=y
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_DEBUG_FS=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRC_T10DIF=y
diff --git a/arch/sh/configs/sh7770_generic_defconfig b/arch/sh/configs/sh7770_generic_defconfig
deleted file mode 100644
index ee2357deba0f1c..00000000000000
--- a/arch/sh/configs/sh7770_generic_defconfig
+++ /dev/null
@@ -1,43 +0,0 @@
-# CONFIG_LOCALVERSION_AUTO is not set
-CONFIG_SYSVIPC=y
-CONFIG_CGROUPS=y
-# CONFIG_UID16 is not set
-# CONFIG_COMPAT_BRK is not set
-CONFIG_PROFILING=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7770=y
-CONFIG_SH_PCLK_FREQ=41666666
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_CPU_FREQ=y
-CONFIG_SH_CPU_FREQ=y
-CONFIG_KEXEC=y
-CONFIG_KEXEC_JUMP=y
-CONFIG_PM=y
-CONFIG_HIBERNATION=y
-CONFIG_CPU_IDLE=y
-# CONFIG_PREVENT_FIRMWARE_BUILD is not set
-# CONFIG_INPUT is not set
-# CONFIG_SERIO is not set
-# CONFIG_VT is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=6
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_UNIX98_PTYS is not set
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_HW_RANDOM is not set
-CONFIG_I2C=y
-CONFIG_I2C_CHARDEV=y
-CONFIG_I2C_SH_MOBILE=y
-# CONFIG_HWMON is not set
-# CONFIG_USB_SUPPORT is not set
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_SH=y
-CONFIG_UIO=y
-CONFIG_UIO_PDRV_GENIRQ=y
-# CONFIG_DNOTIFY is not set
-# CONFIG_PROC_FS is not set
-# CONFIG_SYSFS is not set
-# CONFIG_MISC_FILESYSTEMS is not set
-# CONFIG_ENABLE_MUST_CHECK is not set
-# CONFIG_CRC32 is not set
diff --git a/arch/sh/configs/sh7785lcr_32bit_defconfig b/arch/sh/configs/sh7785lcr_32bit_defconfig
deleted file mode 100644
index 781ff13227fc99..00000000000000
--- a/arch/sh/configs/sh7785lcr_32bit_defconfig
+++ /dev/null
@@ -1,149 +0,0 @@
-CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=16
-CONFIG_PERF_EVENTS=y
-# CONFIG_COMPAT_BRK is not set
-CONFIG_SLAB=y
-CONFIG_PROFILING=y
-CONFIG_GCOV_KERNEL=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7785=y
-CONFIG_MEMORY_START=0x40000000
-CONFIG_MEMORY_SIZE=0x20000000
-CONFIG_PMB=y
-CONFIG_HUGETLB_PAGE_SIZE_1MB=y
-CONFIG_SH_STORE_QUEUES=y
-CONFIG_SPECULATIVE_EXECUTION=y
-CONFIG_SH_SH7785LCR=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_STAT=y
-CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
-CONFIG_SH_CPU_FREQ=y
-CONFIG_HEARTBEAT=y
-CONFIG_KEXEC=y
-CONFIG_SECCOMP=y
-CONFIG_PREEMPT=y
-CONFIG_INTC_USERIMASK=y
-CONFIG_PCI=y
-CONFIG_PCI_DEBUG=y
-CONFIG_PM=y
-CONFIG_CPU_IDLE=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_IPV6 is not set
-CONFIG_MTD=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_PHYSMAP=y
-CONFIG_BLK_DEV_LOOP=y
-CONFIG_BLK_DEV_CRYPTOLOOP=m
-CONFIG_BLK_DEV_RAM=y
-# CONFIG_SCSI_PROC_FS is not set
-CONFIG_BLK_DEV_SD=y
-# CONFIG_SCSI_LOWLEVEL is not set
-CONFIG_ATA=y
-CONFIG_SATA_SIL=y
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_NET_VENDOR_3COM=y
-CONFIG_VORTEX=y
-CONFIG_R8169=y
-# CONFIG_WLAN is not set
-CONFIG_INPUT_FF_MEMLESS=m
-CONFIG_INPUT_EVDEV=y
-CONFIG_INPUT_EVBUG=m
-CONFIG_VT_HW_CONSOLE_BINDING=y
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=6
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_HW_RANDOM is not set
-CONFIG_I2C=y
-CONFIG_I2C_PCA_PLATFORM=y
-# CONFIG_HWMON is not set
-CONFIG_WATCHDOG=y
-CONFIG_SH_WDT=y
-CONFIG_MFD_SM501=y
-# CONFIG_VGA_ARB is not set
-CONFIG_FB=y
-CONFIG_FB_KYRO=y
-CONFIG_FB_SM501=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
-CONFIG_LOGO=y
-CONFIG_SOUND=y
-CONFIG_SND=y
-CONFIG_SND_SEQUENCER=y
-CONFIG_SND_MIXER_OSS=y
-CONFIG_SND_PCM_OSS=y
-CONFIG_SND_SEQUENCER_OSS=y
-CONFIG_SND_HRTIMER=y
-CONFIG_SND_DYNAMIC_MINORS=y
-# CONFIG_SND_SUPPORT_OLD_API is not set
-# CONFIG_SND_VERBOSE_PROCFS is not set
-CONFIG_SND_VERBOSE_PRINTK=y
-CONFIG_SND_DEBUG=y
-CONFIG_SND_DEBUG_VERBOSE=y
-# CONFIG_SND_DRIVERS is not set
-CONFIG_SND_CMIPCI=y
-CONFIG_SND_EMU10K1=y
-# CONFIG_SND_SUPERH is not set
-CONFIG_USB=y
-CONFIG_USB_R8A66597_HCD=y
-CONFIG_USB_STORAGE=y
-CONFIG_MMC=y
-CONFIG_MMC_SDHCI=m
-CONFIG_MMC_SDHCI_PLTFM=m
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_RS5C372=y
-CONFIG_DMADEVICES=y
-CONFIG_UIO=m
-CONFIG_EXT2_FS=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_MSDOS_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_NTFS_FS=y
-CONFIG_NTFS_RW=y
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_HUGETLBFS=y
-CONFIG_CONFIGFS_FS=y
-CONFIG_MINIX_FS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_NFS_V4=y
-CONFIG_ROOT_NFS=y
-CONFIG_NFSD=m
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_CODEPAGE_932=y
-CONFIG_NLS_ISO8859_1=y
-CONFIG_PRINTK_TIME=y
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_MAGIC_SYSRQ=y
-CONFIG_DEBUG_KERNEL=y
-CONFIG_DETECT_HUNG_TASK=y
-CONFIG_DEBUG_KMEMLEAK=y
-CONFIG_DEBUG_SPINLOCK=y
-CONFIG_DEBUG_MUTEXES=y
-CONFIG_DEBUG_SPINLOCK_SLEEP=y
-CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
-CONFIG_LATENCYTOP=y
-# CONFIG_FTRACE is not set
-CONFIG_CRYPTO_HMAC=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-# CONFIG_CRYPTO_HW is not set
diff --git a/arch/sh/configs/sh7785lcr_defconfig b/arch/sh/configs/sh7785lcr_defconfig
deleted file mode 100644
index 1b88929083f786..00000000000000
--- a/arch/sh/configs/sh7785lcr_defconfig
+++ /dev/null
@@ -1,117 +0,0 @@
-CONFIG_SYSVIPC=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_SLAB=y
-CONFIG_PROFILING=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7785=y
-CONFIG_MEMORY_SIZE=0x08000000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_STORE_QUEUES=y
-CONFIG_SH_SH7785LCR=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_HEARTBEAT=y
-CONFIG_KEXEC=y
-CONFIG_PREEMPT=y
-CONFIG_PCI=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_IPV6 is not set
-# CONFIG_FW_LOADER is not set
-CONFIG_MTD=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_PHYSMAP=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_SD=y
-# CONFIG_SCSI_LOWLEVEL is not set
-CONFIG_ATA=y
-CONFIG_SATA_SIL=y
-CONFIG_NETDEVICES=y
-CONFIG_R8169=y
-CONFIG_INPUT_FF_MEMLESS=m
-# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
-# CONFIG_KEYBOARD_ATKBD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_VT_HW_CONSOLE_BINDING=y
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=6
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_HW_RANDOM=y
-CONFIG_I2C=y
-CONFIG_I2C_PCA_PLATFORM=y
-# CONFIG_HWMON is not set
-CONFIG_MFD_SM501=y
-CONFIG_FB=y
-CONFIG_FB_SH_MOBILE_LCDC=m
-CONFIG_FB_SM501=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_LOGO=y
-# CONFIG_LOGO_LINUX_MONO is not set
-# CONFIG_LOGO_LINUX_VGA16 is not set
-# CONFIG_LOGO_SUPERH_MONO is not set
-# CONFIG_LOGO_SUPERH_VGA16 is not set
-# CONFIG_LOGO_SUPERH_CLUT224 is not set
-CONFIG_HID_A4TECH=y
-CONFIG_HID_APPLE=y
-CONFIG_HID_BELKIN=y
-CONFIG_HID_CHERRY=y
-CONFIG_HID_CHICONY=y
-CONFIG_HID_CYPRESS=y
-CONFIG_HID_EZKEY=y
-CONFIG_HID_GYRATION=y
-CONFIG_HID_LOGITECH=y
-CONFIG_HID_MICROSOFT=y
-CONFIG_HID_MONTEREY=y
-CONFIG_HID_PANTHERLORD=y
-CONFIG_HID_PETALYNX=y
-CONFIG_HID_SAMSUNG=y
-CONFIG_HID_SONY=y
-CONFIG_HID_SUNPLUS=y
-CONFIG_USB=y
-CONFIG_USB_MON=y
-CONFIG_USB_EHCI_HCD=m
-# CONFIG_USB_EHCI_TT_NEWSCHED is not set
-CONFIG_USB_OHCI_HCD=m
-CONFIG_USB_R8A66597_HCD=y
-CONFIG_USB_STORAGE=y
-CONFIG_USB_TEST=m
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_RS5C372=y
-CONFIG_EXT2_FS=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_MSDOS_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_NTFS_FS=y
-CONFIG_NTFS_RW=y
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_MINIX_FS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_NFS_V4=y
-CONFIG_ROOT_NFS=y
-CONFIG_NFSD=y
-CONFIG_NFSD_V4=y
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_CODEPAGE_932=y
-CONFIG_NLS_ISO8859_1=y
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_DEBUG_KERNEL=y
-CONFIG_DETECT_HUNG_TASK=y
-# CONFIG_DEBUG_BUGVERBOSE is not set
-CONFIG_CRYPTO_HMAC=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-# CONFIG_CRYPTO_HW is not set
diff --git a/arch/sh/configs/shmin_defconfig b/arch/sh/configs/shmin_defconfig
deleted file mode 100644
index e078b193a78a89..00000000000000
--- a/arch/sh/configs/shmin_defconfig
+++ /dev/null
@@ -1,52 +0,0 @@
-# CONFIG_SWAP is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_UID16 is not set
-# CONFIG_KALLSYMS is not set
-# CONFIG_HOTPLUG is not set
-# CONFIG_BUG is not set
-# CONFIG_ELF_CORE is not set
-# CONFIG_BASE_FULL is not set
-# CONFIG_FUTEX is not set
-# CONFIG_EPOLL is not set
-# CONFIG_SHMEM is not set
-CONFIG_SLUB=y
-CONFIG_SLUB_TINY=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7706=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_MEMORY_SIZE=0x00800000
-CONFIG_FLATMEM_MANUAL=y
-# CONFIG_SH_ADC is not set
-CONFIG_SH_SHMIN=y
-CONFIG_SH_PCLK_FREQ=32000000
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC1,115200 root=1f01 mtdparts=phys_mapped_flash:64k(firm)ro,-(sys) netdev=34,0x300,eth0 "
-CONFIG_NET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_PNP=y
-# CONFIG_IPV6 is not set
-CONFIG_MTD=y
-CONFIG_MTD_CMDLINE_PARTS=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_JEDECPROBE=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_PHYSMAP=y
-CONFIG_BLK_DEV_LOOP=y
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-# CONFIG_INPUT is not set
-# CONFIG_SERIO is not set
-# CONFIG_VT is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_HWMON is not set
-# CONFIG_DNOTIFY is not set
-# CONFIG_SYSFS is not set
-CONFIG_CRAMFS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_ROOT_NFS=y
-CONFIG_SH_STANDARD_BIOS=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
diff --git a/arch/sh/configs/shx3_defconfig b/arch/sh/configs/shx3_defconfig
deleted file mode 100644
index aa353dff7f1931..00000000000000
--- a/arch/sh/configs/shx3_defconfig
+++ /dev/null
@@ -1,103 +0,0 @@
-CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_AUDIT=y
-CONFIG_AUDITSYSCALL=y
-CONFIG_RCU_TRACE=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_CGROUPS=y
-CONFIG_CGROUP_FREEZER=y
-CONFIG_CGROUP_DEVICE=y
-CONFIG_CGROUP_CPUACCT=y
-CONFIG_CGROUP_MEMCG=y
-CONFIG_RELAY=y
-CONFIG_NAMESPACES=y
-CONFIG_UTS_NS=y
-CONFIG_IPC_NS=y
-CONFIG_USER_NS=y
-CONFIG_PID_NS=y
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-CONFIG_KALLSYMS_ALL=y
-CONFIG_SLUB=y
-CONFIG_SLUB_TINY=y
-CONFIG_PROFILING=y
-CONFIG_KPROBES=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SHX3=y
-CONFIG_MEMORY_START=0x0c000000
-CONFIG_NUMA=y
-CONFIG_PAGE_SIZE_64KB=y
-CONFIG_MEMORY_HOTPLUG=y
-CONFIG_MEMORY_HOTREMOVE=y
-CONFIG_SH_STORE_QUEUES=y
-CONFIG_SH_X3PROTO=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_GOV_POWERSAVE=m
-CONFIG_CPU_FREQ_GOV_USERSPACE=m
-CONFIG_CPU_FREQ_GOV_ONDEMAND=m
-CONFIG_CPU_FREQ_GOV_CONSERVATIVE=m
-CONFIG_SH_CPU_FREQ=y
-CONFIG_HEARTBEAT=y
-CONFIG_KEXEC=y
-CONFIG_SECCOMP=y
-CONFIG_SMP=y
-CONFIG_PREEMPT=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC0,115200 earlyprintk=bios ignore_loglevel"
-CONFIG_BINFMT_MISC=y
-CONFIG_NET=y
-CONFIG_INET=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_CAN=m
-CONFIG_CAN_RAW=m
-CONFIG_CAN_BCM=m
-CONFIG_CAN_VCAN=m
-# CONFIG_FW_LOADER is not set
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_ATA=y
-CONFIG_PATA_PLATFORM=y
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SMC91X=y
-# CONFIG_INPUT is not set
-# CONFIG_SERIO is not set
-# CONFIG_VT is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_HW_RANDOM is not set
-CONFIG_I2C=m
-CONFIG_SPI=y
-# CONFIG_HWMON is not set
-CONFIG_WATCHDOG=y
-CONFIG_USB=y
-CONFIG_USB_MON=y
-CONFIG_USB_R8A66597_HCD=m
-CONFIG_USB_GADGET=y
-CONFIG_USB_GADGET_M66592=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_SH=y
-CONFIG_UIO=m
-CONFIG_EXT2_FS=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_HUGETLBFS=y
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_MAGIC_SYSRQ=y
-CONFIG_DEBUG_KERNEL=y
-CONFIG_DEBUG_SHIRQ=y
-CONFIG_DETECT_HUNG_TASK=y
-CONFIG_DEBUG_VM=y
-CONFIG_FRAME_POINTER=y
-CONFIG_SH_STANDARD_BIOS=y
-CONFIG_DEBUG_STACK_USAGE=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
diff --git a/arch/sh/configs/titan_defconfig b/arch/sh/configs/titan_defconfig
deleted file mode 100644
index 73a0d68b0de6ce..00000000000000
--- a/arch/sh/configs/titan_defconfig
+++ /dev/null
@@ -1,272 +0,0 @@
-# CONFIG_LOCALVERSION_AUTO is not set
-CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=16
-CONFIG_BLK_DEV_INITRD=y
-# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
-CONFIG_SLAB=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-CONFIG_MODULE_FORCE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7751R=y
-CONFIG_MEMORY_START=0x08030000
-CONFIG_MEMORY_SIZE=0x7fd0000
-CONFIG_FLATMEM_MANUAL=y
-CONFIG_SH_TITAN=y
-CONFIG_SH_PCLK_FREQ=30000000
-CONFIG_SH_DMA=y
-CONFIG_SH_DMA_API=y
-CONFIG_PREEMPT_VOLUNTARY=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC1,38400N81 root=/dev/nfs ip=:::::eth1:autoconf rw"
-CONFIG_PCI=y
-CONFIG_HOTPLUG_PCI=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_NET_KEY=y
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_MULTIPLE_TABLES=y
-CONFIG_IP_ROUTE_MULTIPATH=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_IP_PNP_BOOTP=y
-CONFIG_IP_PNP_RARP=y
-CONFIG_NET_IPIP=y
-CONFIG_NET_IPGRE=y
-CONFIG_NET_IPGRE_BROADCAST=y
-CONFIG_IP_MROUTE=y
-CONFIG_IP_PIMSM_V1=y
-CONFIG_IP_PIMSM_V2=y
-CONFIG_SYN_COOKIES=y
-CONFIG_INET_AH=y
-CONFIG_INET_ESP=y
-CONFIG_INET_IPCOMP=y
-CONFIG_INET_DIAG=m
-CONFIG_IPV6=y
-CONFIG_IPV6_PRIVACY=y
-CONFIG_INET6_AH=y
-CONFIG_INET6_ESP=y
-CONFIG_INET6_IPCOMP=y
-CONFIG_IPV6_SIT=m
-CONFIG_IPV6_TUNNEL=y
-CONFIG_NETFILTER=y
-CONFIG_NETFILTER_NETLINK_QUEUE=m
-CONFIG_NETFILTER_NETLINK_LOG=m
-CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
-CONFIG_NETFILTER_XT_TARGET_MARK=m
-CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
-CONFIG_NETFILTER_XT_MATCH_COMMENT=m
-CONFIG_NETFILTER_XT_MATCH_DCCP=m
-CONFIG_NETFILTER_XT_MATCH_ESP=m
-CONFIG_NETFILTER_XT_MATCH_LENGTH=m
-CONFIG_NETFILTER_XT_MATCH_LIMIT=m
-CONFIG_NETFILTER_XT_MATCH_MAC=m
-CONFIG_NETFILTER_XT_MATCH_MARK=m
-CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
-CONFIG_NETFILTER_XT_MATCH_POLICY=m
-CONFIG_NETFILTER_XT_MATCH_PHYSDEV=m
-CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
-CONFIG_NETFILTER_XT_MATCH_REALM=m
-CONFIG_NETFILTER_XT_MATCH_SCTP=m
-CONFIG_NETFILTER_XT_MATCH_STRING=m
-CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
-CONFIG_IP_NF_IPTABLES=m
-CONFIG_IP_NF_MATCH_ADDRTYPE=m
-CONFIG_IP_NF_MATCH_AH=m
-CONFIG_IP_NF_MATCH_ECN=m
-CONFIG_IP_NF_MATCH_TTL=m
-CONFIG_IP_NF_FILTER=m
-CONFIG_IP_NF_TARGET_REJECT=m
-CONFIG_IP_NF_TARGET_LOG=m
-CONFIG_IP_NF_MANGLE=m
-CONFIG_IP_NF_TARGET_ECN=m
-CONFIG_IP_NF_TARGET_TTL=m
-CONFIG_IP_NF_RAW=m
-CONFIG_IP_NF_ARPTABLES=m
-CONFIG_IP_NF_ARPFILTER=m
-CONFIG_IP_NF_ARP_MANGLE=m
-CONFIG_IP6_NF_IPTABLES=m
-CONFIG_IP6_NF_MATCH_AH=m
-CONFIG_IP6_NF_MATCH_EUI64=m
-CONFIG_IP6_NF_MATCH_FRAG=m
-CONFIG_IP6_NF_MATCH_OPTS=m
-CONFIG_IP6_NF_MATCH_HL=m
-CONFIG_IP6_NF_MATCH_IPV6HEADER=m
-CONFIG_IP6_NF_MATCH_RT=m
-CONFIG_IP6_NF_TARGET_HL=m
-CONFIG_IP6_NF_FILTER=m
-CONFIG_IP6_NF_TARGET_REJECT=m
-CONFIG_IP6_NF_MANGLE=m
-CONFIG_IP6_NF_RAW=m
-CONFIG_BRIDGE=y
-CONFIG_VLAN_8021Q=y
-CONFIG_NET_SCHED=y
-CONFIG_NET_SCH_CBQ=m
-CONFIG_NET_SCH_HTB=m
-CONFIG_NET_SCH_HFSC=m
-CONFIG_NET_SCH_PRIO=m
-CONFIG_NET_SCH_RED=m
-CONFIG_NET_SCH_SFQ=m
-CONFIG_NET_SCH_TEQL=m
-CONFIG_NET_SCH_TBF=m
-CONFIG_NET_SCH_GRED=m
-CONFIG_NET_SCH_DSMARK=m
-CONFIG_NET_SCH_NETEM=m
-CONFIG_NET_SCH_INGRESS=m
-CONFIG_NET_CLS_BASIC=m
-CONFIG_NET_CLS_TCINDEX=m
-CONFIG_NET_CLS_ROUTE4=m
-CONFIG_NET_CLS_FW=m
-CONFIG_NET_CLS_U32=m
-CONFIG_CLS_U32_PERF=y
-CONFIG_CLS_U32_MARK=y
-CONFIG_NET_CLS_RSVP=m
-CONFIG_NET_CLS_RSVP6=m
-CONFIG_NET_EMATCH=y
-CONFIG_NET_EMATCH_CMP=m
-CONFIG_NET_EMATCH_NBYTE=m
-CONFIG_NET_EMATCH_U32=m
-CONFIG_NET_EMATCH_META=m
-CONFIG_NET_EMATCH_TEXT=m
-CONFIG_NET_CLS_ACT=y
-CONFIG_NET_ACT_POLICE=m
-CONFIG_NET_ACT_GACT=m
-CONFIG_GACT_PROB=y
-CONFIG_NET_ACT_MIRRED=m
-CONFIG_NET_ACT_IPT=m
-CONFIG_NET_ACT_PEDIT=m
-CONFIG_FW_LOADER=m
-CONFIG_CONNECTOR=m
-CONFIG_MTD=m
-CONFIG_MTD_DEBUG=y
-CONFIG_MTD_BLOCK=m
-CONFIG_FTL=m
-CONFIG_NFTL=m
-CONFIG_INFTL=m
-CONFIG_RFD_FTL=m
-CONFIG_MTD_CFI=m
-CONFIG_MTD_JEDECPROBE=m
-CONFIG_MTD_RAW_NAND=m
-CONFIG_BLK_DEV_LOOP=m
-CONFIG_BLK_DEV_CRYPTOLOOP=m
-CONFIG_BLK_DEV_RAM=y
-CONFIG_ATA_OVER_ETH=m
-CONFIG_SCSI=y
-CONFIG_BLK_DEV_SD=m
-CONFIG_BLK_DEV_SR=m
-CONFIG_CHR_DEV_SG=m
-CONFIG_NETDEVICES=y
-CONFIG_TUN=m
-CONFIG_PHYLIB=m
-CONFIG_MARVELL_PHY=m
-CONFIG_DAVICOM_PHY=m
-CONFIG_QSEMI_PHY=m
-CONFIG_LXT_PHY=m
-CONFIG_CICADA_PHY=m
-CONFIG_NET_ETHERNET=y
-CONFIG_NET_PCI=y
-CONFIG_8139TOO=y
-# CONFIG_8139TOO_PIO is not set
-CONFIG_8139TOO_TUNE_TWISTER=y
-CONFIG_8139_OLD_RX_RESET=y
-CONFIG_USB_CATC=m
-CONFIG_USB_KAWETH=m
-CONFIG_USB_PEGASUS=m
-CONFIG_USB_RTL8150=m
-CONFIG_USB_USBNET=m
-CONFIG_USB_NET_PLUSB=m
-# CONFIG_USB_NET_CDC_SUBSET is not set
-CONFIG_PPP=m
-CONFIG_PPP_MULTILINK=y
-CONFIG_PPP_FILTER=y
-CONFIG_PPP_ASYNC=m
-CONFIG_PPP_SYNC_TTY=m
-CONFIG_PPP_DEFLATE=m
-CONFIG_PPP_BSDCOMP=m
-CONFIG_PPP_MPPE=m
-CONFIG_PPPOE=m
-CONFIG_SLIP=m
-CONFIG_SLIP_COMPRESSED=y
-CONFIG_SLIP_SMART=y
-# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_HW_RANDOM=y
-CONFIG_WATCHDOG=y
-CONFIG_SH_WDT=m
-# CONFIG_USB_HID is not set
-CONFIG_USB=y
-CONFIG_USB_MON=y
-CONFIG_USB_EHCI_HCD=y
-CONFIG_USB_EHCI_ROOT_HUB_TT=y
-CONFIG_USB_OHCI_HCD=y
-CONFIG_USB_ACM=m
-CONFIG_USB_PRINTER=m
-CONFIG_USB_STORAGE=y
-CONFIG_USB_SERIAL=m
-CONFIG_USB_SERIAL_GENERIC=y
-CONFIG_USB_SERIAL_ARK3116=m
-CONFIG_USB_SERIAL_PL2303=m
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_SH=m
-CONFIG_EXT2_FS=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-# CONFIG_EXT3_FS_XATTR is not set
-CONFIG_REISERFS_FS=m
-CONFIG_XFS_FS=m
-CONFIG_FUSE_FS=m
-CONFIG_ISO9660_FS=m
-CONFIG_JOLIET=y
-CONFIG_ZISOFS=y
-CONFIG_UDF_FS=m
-CONFIG_MSDOS_FS=m
-CONFIG_VFAT_FS=m
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_CONFIGFS_FS=m
-CONFIG_ROMFS_FS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_ROOT_NFS=y
-CONFIG_NFSD=y
-CONFIG_SMB_FS=m
-CONFIG_CIFS=m
-CONFIG_PARTITION_ADVANCED=y
-CONFIG_NLS_CODEPAGE_437=m
-CONFIG_NLS_ASCII=m
-CONFIG_NLS_ISO8859_1=m
-CONFIG_NLS_UTF8=m
-CONFIG_MAGIC_SYSRQ=y
-CONFIG_DEBUG_KERNEL=y
-# CONFIG_DEBUG_BUGVERBOSE is not set
-CONFIG_CRYPTO_NULL=m
-CONFIG_CRYPTO_ECB=y
-CONFIG_CRYPTO_MD4=m
-CONFIG_CRYPTO_MICHAEL_MIC=y
-CONFIG_CRYPTO_SHA256=m
-CONFIG_CRYPTO_SHA512=m
-CONFIG_CRYPTO_TGR192=m
-CONFIG_CRYPTO_WP512=m
-CONFIG_CRYPTO_AES=y
-CONFIG_CRYPTO_ANUBIS=m
-CONFIG_CRYPTO_ARC4=y
-CONFIG_CRYPTO_BLOWFISH=m
-CONFIG_CRYPTO_CAST5=m
-CONFIG_CRYPTO_CAST6=m
-CONFIG_CRYPTO_KHAZAD=m
-CONFIG_CRYPTO_SERPENT=m
-CONFIG_CRYPTO_TEA=m
-CONFIG_CRYPTO_TWOFISH=m
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-CONFIG_CRC16=m
-CONFIG_LIBCRC32C=m
diff --git a/arch/sh/configs/ul2_defconfig b/arch/sh/configs/ul2_defconfig
deleted file mode 100644
index 103b81ec1ffb91..00000000000000
--- a/arch/sh/configs/ul2_defconfig
+++ /dev/null
@@ -1,84 +0,0 @@
-CONFIG_SYSVIPC=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_PROFILING=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7366=y
-CONFIG_MEMORY_SIZE=0x01f00000
-CONFIG_NUMA=y
-# CONFIG_MIGRATION is not set
-# CONFIG_SH_DSP is not set
-# CONFIG_SH_TIMER_CMT is not set
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_HZ_100=y
-CONFIG_KEXEC=y
-CONFIG_PREEMPT=y
-CONFIG_CMDLINE_OVERWRITE=y
-CONFIG_CMDLINE="console=ttySC0,115200 root=/dev/nfs ip=dhcp"
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_IPV6 is not set
-CONFIG_CFG80211=y
-CONFIG_MAC80211=y
-CONFIG_MAC80211_RC_PID=y
-# CONFIG_MAC80211_RC_MINSTREL is not set
-CONFIG_MTD=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_RAM=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_ATA=y
-CONFIG_PATA_PLATFORM=y
-CONFIG_NETDEVICES=y
-CONFIG_NET_ETHERNET=y
-CONFIG_LIBERTAS=m
-CONFIG_LIBERTAS_SDIO=m
-CONFIG_LIBERTAS_DEBUG=y
-CONFIG_USB_USBNET=y
-# CONFIG_USB_NET_NET1080 is not set
-# CONFIG_USB_NET_CDC_SUBSET is not set
-# CONFIG_USB_NET_ZAURUS is not set
-# CONFIG_INPUT_MOUSEDEV is not set
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-# CONFIG_VT is not set
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=1
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-# CONFIG_UNIX98_PTYS is not set
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_HW_RANDOM is not set
-CONFIG_USB=y
-CONFIG_USB_MON=y
-CONFIG_USB_R8A66597_HCD=y
-CONFIG_USB_STORAGE=y
-CONFIG_MMC=y
-CONFIG_EXT2_FS=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_VFAT_FS=y
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_HUGETLBFS=y
-CONFIG_CRAMFS=y
-CONFIG_NFS_FS=y
-CONFIG_ROOT_NFS=y
-CONFIG_NFSD=y
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_CODEPAGE_932=y
-CONFIG_NLS_ISO8859_1=y
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_CRYPTO_MICHAEL_MIC=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
diff --git a/arch/sh/configs/urquell_defconfig b/arch/sh/configs/urquell_defconfig
deleted file mode 100644
index 8fc687c98fd195..00000000000000
--- a/arch/sh/configs/urquell_defconfig
+++ /dev/null
@@ -1,147 +0,0 @@
-CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_BSD_PROCESS_ACCT=y
-CONFIG_AUDIT=y
-CONFIG_AUDITSYSCALL=y
-CONFIG_IKCONFIG=y
-CONFIG_IKCONFIG_PROC=y
-CONFIG_LOG_BUF_SHIFT=14
-CONFIG_CGROUPS=y
-CONFIG_CGROUP_DEBUG=y
-CONFIG_CGROUP_FREEZER=y
-CONFIG_CGROUP_DEVICE=y
-CONFIG_CPUSETS=y
-# CONFIG_PROC_PID_CPUSET is not set
-CONFIG_CGROUP_CPUACCT=y
-CONFIG_CGROUP_MEMCG=y
-CONFIG_CGROUP_SCHED=y
-CONFIG_RT_GROUP_SCHED=y
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_SLAB=y
-CONFIG_PROFILING=y
-CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
-CONFIG_CPU_SUBTYPE_SH7786=y
-CONFIG_MEMORY_SIZE=0x08000000
-CONFIG_SH_STORE_QUEUES=y
-CONFIG_SH_URQUELL=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_HEARTBEAT=y
-CONFIG_KEXEC=y
-CONFIG_SECCOMP=y
-CONFIG_PCI=y
-CONFIG_PCIEPORTBUS=y
-CONFIG_PCIEASPM_DEBUG=y
-CONFIG_PCI_DEBUG=y
-CONFIG_BINFMT_MISC=y
-CONFIG_PM=y
-CONFIG_CPU_IDLE=y
-CONFIG_NET=y
-CONFIG_PACKET=y
-CONFIG_UNIX=y
-CONFIG_INET=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_IPV6 is not set
-# CONFIG_FW_LOADER is not set
-CONFIG_MTD=y
-CONFIG_MTD_BLOCK=y
-CONFIG_MTD_CFI=y
-CONFIG_MTD_CFI_AMDSTD=y
-CONFIG_MTD_PHYSMAP=y
-CONFIG_BLK_DEV_RAM=y
-CONFIG_BLK_DEV_SD=y
-# CONFIG_SCSI_LOWLEVEL is not set
-CONFIG_ATA=y
-CONFIG_SATA_SIL24=y
-CONFIG_NETDEVICES=y
-CONFIG_PHYLIB=y
-CONFIG_MARVELL_PHY=y
-CONFIG_NET_ETHERNET=y
-CONFIG_SMC91X=y
-CONFIG_NET_PCI=y
-CONFIG_8139CP=y
-CONFIG_SKY2=y
-CONFIG_SKY2_DEBUG=y
-CONFIG_INPUT_FF_MEMLESS=m
-# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
-# CONFIG_KEYBOARD_ATKBD is not set
-# CONFIG_INPUT_MOUSE is not set
-# CONFIG_SERIO is not set
-CONFIG_VT_HW_CONSOLE_BINDING=y
-CONFIG_SERIAL_SH_SCI=y
-CONFIG_SERIAL_SH_SCI_NR_UARTS=6
-CONFIG_SERIAL_SH_SCI_CONSOLE=y
-CONFIG_HW_RANDOM=y
-CONFIG_I2C=y
-CONFIG_I2C_PCA_PLATFORM=y
-CONFIG_MFD_SM501=y
-CONFIG_MEDIA_SUPPORT=y
-CONFIG_FB=y
-CONFIG_FB_SH_MOBILE_LCDC=m
-CONFIG_FB_SM501=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_LOGO=y
-# CONFIG_LOGO_LINUX_MONO is not set
-# CONFIG_LOGO_LINUX_VGA16 is not set
-# CONFIG_LOGO_SUPERH_MONO is not set
-# CONFIG_LOGO_SUPERH_VGA16 is not set
-# CONFIG_LOGO_SUPERH_CLUT224 is not set
-CONFIG_HID_A4TECH=y
-CONFIG_HID_APPLE=y
-CONFIG_HID_BELKIN=y
-CONFIG_HID_CHERRY=y
-CONFIG_HID_CHICONY=y
-CONFIG_HID_CYPRESS=y
-CONFIG_HID_EZKEY=y
-CONFIG_HID_GYRATION=y
-CONFIG_HID_LOGITECH=y
-CONFIG_HID_MICROSOFT=y
-CONFIG_HID_MONTEREY=y
-CONFIG_HID_PANTHERLORD=y
-CONFIG_HID_PETALYNX=y
-CONFIG_HID_SAMSUNG=y
-CONFIG_HID_SONY=y
-CONFIG_HID_SUNPLUS=y
-CONFIG_USB=y
-CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
-CONFIG_USB_MON=y
-CONFIG_USB_OHCI_HCD=y
-CONFIG_USB_STORAGE=y
-CONFIG_RTC_CLASS=y
-CONFIG_RTC_DRV_SH=y
-CONFIG_RTC_DRV_GENERIC=y
-CONFIG_EXT2_FS=y
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-CONFIG_EXT4_FS=y
-CONFIG_BTRFS_FS=y
-CONFIG_MSDOS_FS=y
-CONFIG_VFAT_FS=y
-CONFIG_NTFS_FS=y
-CONFIG_NTFS_RW=y
-CONFIG_PROC_KCORE=y
-CONFIG_TMPFS=y
-CONFIG_HUGETLBFS=y
-CONFIG_CONFIGFS_FS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-CONFIG_NFS_V4=y
-CONFIG_ROOT_NFS=y
-CONFIG_NLS_CODEPAGE_437=y
-CONFIG_NLS_CODEPAGE_932=y
-CONFIG_NLS_ISO8859_1=y
-CONFIG_PRINTK_TIME=y
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_DEBUG_FS=y
-CONFIG_DEBUG_KERNEL=y
-CONFIG_DETECT_HUNG_TASK=y
-CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
-CONFIG_FRAME_POINTER=y
-# CONFIG_FTRACE is not set
-# CONFIG_DUMP_CODE is not set
-CONFIG_CRYPTO_HMAC=y
-# CONFIG_CRYPTO_ANSI_CPRNG is not set
-# CONFIG_CRYPTO_HW is not set
diff --git a/arch/sh/drivers/Kconfig b/arch/sh/drivers/Kconfig
deleted file mode 100644
index 80a45ad2852fdf..00000000000000
--- a/arch/sh/drivers/Kconfig
+++ /dev/null
@@ -1,20 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-source "arch/sh/drivers/dma/Kconfig"
-source "arch/sh/cchips/Kconfig"
-
-menu "Additional SuperH Device Drivers"
-
-config HEARTBEAT
-	bool "Heartbeat LED"
-	help
-	  Use the power-on LED on your machine as a load meter.  The exact
-	  behavior is platform-dependent, but normally the flash frequency is
-	  a hyperbolic function of the 5-minute load average.
-
-config PUSH_SWITCH
-	tristate "Push switch support"
-	help
-	  This enables support for the push switch framework, a simple
-	  framework that allows for sysfs driven switch status reporting.
-
-endmenu
diff --git a/arch/sh/drivers/Makefile b/arch/sh/drivers/Makefile
deleted file mode 100644
index 56b0acace6e7c8..00000000000000
--- a/arch/sh/drivers/Makefile
+++ /dev/null
@@ -1,11 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the Linux SuperH-specific device drivers.
-#
-
-obj-y		+= dma/ platform_early.o
-
-obj-$(CONFIG_PCI)		+= pci/
-obj-$(CONFIG_SUPERHYWAY)	+= superhyway/
-obj-$(CONFIG_PUSH_SWITCH)	+= push-switch.o
-obj-$(CONFIG_HEARTBEAT)		+= heartbeat.o
diff --git a/arch/sh/drivers/dma/Kconfig b/arch/sh/drivers/dma/Kconfig
deleted file mode 100644
index 7d54f284ce10fb..00000000000000
--- a/arch/sh/drivers/dma/Kconfig
+++ /dev/null
@@ -1,74 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-menu "DMA support"
-
-
-config SH_DMA
-	bool "SuperH on-chip DMA controller (DMAC) support"
-	depends on CPU_SH3 || CPU_SH4
-	default n
-
-config SH_DMA_IRQ_MULTI
-	bool
-	depends on SH_DMA
-	default y if CPU_SUBTYPE_SH7750  || CPU_SUBTYPE_SH7751  || \
-		     CPU_SUBTYPE_SH7750S || CPU_SUBTYPE_SH7750R || \
-		     CPU_SUBTYPE_SH7751R || CPU_SUBTYPE_SH7091  || \
-		     CPU_SUBTYPE_SH7763  || CPU_SUBTYPE_SH7780  || \
-		     CPU_SUBTYPE_SH7785  || CPU_SUBTYPE_SH7760
-
-config SH_DMA_API
-	depends on SH_DMA
-	bool "SuperH DMA API support"
-	default n
-	help
-	  SH_DMA_API always enabled DMA API of used SuperH.
-	  If you want to use DMA ENGINE, you must not enable this.
-	  Please enable DMA_ENGINE and SH_DMAE.
-
-config NR_ONCHIP_DMA_CHANNELS
-	int
-	depends on SH_DMA
-	default "4" if CPU_SUBTYPE_SH7750  || CPU_SUBTYPE_SH7751  || \
-		       CPU_SUBTYPE_SH7750S || CPU_SUBTYPE_SH7091
-	default "8" if CPU_SUBTYPE_SH7750R || CPU_SUBTYPE_SH7751R || \
-		       CPU_SUBTYPE_SH7760
-	default "12" if CPU_SUBTYPE_SH7723 || CPU_SUBTYPE_SH7780  || \
-			CPU_SUBTYPE_SH7785 || CPU_SUBTYPE_SH7724
-	default "6"
-	help
-	  This allows you to specify the number of channels that the on-chip
-	  DMAC supports. This will be 4 for SH7750/SH7751/Sh7750S/SH7091 and 8 for the
-	  SH7750R/SH7751R/SH7760, 12 for the SH7723/SH7780/SH7785/SH7724, default is 6.
-
-config SH_DMABRG
-	bool "SH7760 DMABRG support"
-	depends on CPU_SUBTYPE_SH7760
-	help
-	  The DMABRG does data transfers from main memory to Audio/USB units
-	  of the SH7760.
-	  Say Y if you want to use Audio/USB DMA on your SH7760 board.
-
-config PVR2_DMA
-	tristate "PowerVR 2 DMAC support"
-	depends on SH_DREAMCAST && SH_DMA
-	help
-	  Selecting this will enable support for the PVR2 DMA controller.
-	  As this chains off of the on-chip DMAC, that must also be
-	  enabled by default.
-
-	  This is primarily used by the pvr2fb framebuffer driver for
-	  certain optimizations, but is not necessary for functionality.
-
-	  If in doubt, say N.
-
-config G2_DMA
-	tristate "G2 Bus DMA support"
-	depends on SH_DREAMCAST && SH_DMA_API
-	help
-	  This enables support for the DMA controller for the Dreamcast's
-	  G2 bus. Drivers that want this will generally enable this on
-	  their own.
-
-	  If in doubt, say N.
-
-endmenu
diff --git a/arch/sh/drivers/dma/Makefile b/arch/sh/drivers/dma/Makefile
deleted file mode 100644
index d2fdd56208f6e3..00000000000000
--- a/arch/sh/drivers/dma/Makefile
+++ /dev/null
@@ -1,9 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the SuperH DMA specific kernel interface routines under Linux.
-#
-
-obj-$(CONFIG_SH_DMA_API)	+= dma-sh.o dma-api.o dma-sysfs.o
-obj-$(CONFIG_PVR2_DMA)		+= dma-pvr2.o
-obj-$(CONFIG_G2_DMA)		+= dma-g2.o
-obj-$(CONFIG_SH_DMABRG)		+= dmabrg.o
diff --git a/arch/sh/drivers/dma/dma-api.c b/arch/sh/drivers/dma/dma-api.c
deleted file mode 100644
index ab9170494dcc29..00000000000000
--- a/arch/sh/drivers/dma/dma-api.c
+++ /dev/null
@@ -1,417 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/drivers/dma/dma-api.c
- *
- * SuperH-specific DMA management API
- *
- * Copyright (C) 2003, 2004, 2005  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/spinlock.h>
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
-#include <linux/list.h>
-#include <linux/platform_device.h>
-#include <linux/mm.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-#include <asm/dma.h>
-
-DEFINE_SPINLOCK(dma_spin_lock);
-static LIST_HEAD(registered_dmac_list);
-
-struct dma_info *get_dma_info(unsigned int chan)
-{
-	struct dma_info *info;
-
-	/*
-	 * Look for each DMAC's range to determine who the owner of
-	 * the channel is.
-	 */
-	list_for_each_entry(info, &registered_dmac_list, list) {
-		if ((chan <  info->first_vchannel_nr) ||
-		    (chan >= info->first_vchannel_nr + info->nr_channels))
-			continue;
-
-		return info;
-	}
-
-	return NULL;
-}
-EXPORT_SYMBOL(get_dma_info);
-
-struct dma_info *get_dma_info_by_name(const char *dmac_name)
-{
-	struct dma_info *info;
-
-	list_for_each_entry(info, &registered_dmac_list, list) {
-		if (dmac_name && (strcmp(dmac_name, info->name) != 0))
-			continue;
-		else
-			return info;
-	}
-
-	return NULL;
-}
-EXPORT_SYMBOL(get_dma_info_by_name);
-
-static unsigned int get_nr_channels(void)
-{
-	struct dma_info *info;
-	unsigned int nr = 0;
-
-	if (unlikely(list_empty(&registered_dmac_list)))
-		return nr;
-
-	list_for_each_entry(info, &registered_dmac_list, list)
-		nr += info->nr_channels;
-
-	return nr;
-}
-
-struct dma_channel *get_dma_channel(unsigned int chan)
-{
-	struct dma_info *info = get_dma_info(chan);
-	struct dma_channel *channel;
-	int i;
-
-	if (unlikely(!info))
-		return ERR_PTR(-EINVAL);
-
-	for (i = 0; i < info->nr_channels; i++) {
-		channel = &info->channels[i];
-		if (channel->vchan == chan)
-			return channel;
-	}
-
-	return NULL;
-}
-EXPORT_SYMBOL(get_dma_channel);
-
-int get_dma_residue(unsigned int chan)
-{
-	struct dma_info *info = get_dma_info(chan);
-	struct dma_channel *channel = get_dma_channel(chan);
-
-	if (info->ops->get_residue)
-		return info->ops->get_residue(channel);
-
-	return 0;
-}
-EXPORT_SYMBOL(get_dma_residue);
-
-static int search_cap(const char **haystack, const char *needle)
-{
-	const char **p;
-
-	for (p = haystack; *p; p++)
-		if (strcmp(*p, needle) == 0)
-			return 1;
-
-	return 0;
-}
-
-/**
- * request_dma_bycap - Allocate a DMA channel based on its capabilities
- * @dmac: List of DMA controllers to search
- * @caps: List of capabilities
- *
- * Search all channels of all DMA controllers to find a channel which
- * matches the requested capabilities. The result is the channel
- * number if a match is found, or %-ENODEV if no match is found.
- *
- * Note that not all DMA controllers export capabilities, in which
- * case they can never be allocated using this API, and so
- * request_dma() must be used specifying the channel number.
- */
-int request_dma_bycap(const char **dmac, const char **caps, const char *dev_id)
-{
-	unsigned int found = 0;
-	struct dma_info *info;
-	const char **p;
-	int i;
-
-	BUG_ON(!dmac || !caps);
-
-	list_for_each_entry(info, &registered_dmac_list, list)
-		if (strcmp(*dmac, info->name) == 0) {
-			found = 1;
-			break;
-		}
-
-	if (!found)
-		return -ENODEV;
-
-	for (i = 0; i < info->nr_channels; i++) {
-		struct dma_channel *channel = &info->channels[i];
-
-		if (unlikely(!channel->caps))
-			continue;
-
-		for (p = caps; *p; p++) {
-			if (!search_cap(channel->caps, *p))
-				break;
-			if (request_dma(channel->chan, dev_id) == 0)
-				return channel->chan;
-		}
-	}
-
-	return -EINVAL;
-}
-EXPORT_SYMBOL(request_dma_bycap);
-
-int dmac_search_free_channel(const char *dev_id)
-{
-	struct dma_channel *channel = { 0 };
-	struct dma_info *info = get_dma_info(0);
-	int i;
-
-	for (i = 0; i < info->nr_channels; i++) {
-		channel = &info->channels[i];
-		if (unlikely(!channel))
-			return -ENODEV;
-
-		if (atomic_read(&channel->busy) == 0)
-			break;
-	}
-
-	if (info->ops->request) {
-		int result = info->ops->request(channel);
-		if (result)
-			return result;
-
-		atomic_set(&channel->busy, 1);
-		return channel->chan;
-	}
-
-	return -ENOSYS;
-}
-
-int request_dma(unsigned int chan, const char *dev_id)
-{
-	struct dma_channel *channel = { 0 };
-	struct dma_info *info = get_dma_info(chan);
-	int result;
-
-	channel = get_dma_channel(chan);
-	if (atomic_xchg(&channel->busy, 1))
-		return -EBUSY;
-
-	strlcpy(channel->dev_id, dev_id, sizeof(channel->dev_id));
-
-	if (info->ops->request) {
-		result = info->ops->request(channel);
-		if (result)
-			atomic_set(&channel->busy, 0);
-
-		return result;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(request_dma);
-
-void free_dma(unsigned int chan)
-{
-	struct dma_info *info = get_dma_info(chan);
-	struct dma_channel *channel = get_dma_channel(chan);
-
-	if (info->ops->free)
-		info->ops->free(channel);
-
-	atomic_set(&channel->busy, 0);
-}
-EXPORT_SYMBOL(free_dma);
-
-void dma_wait_for_completion(unsigned int chan)
-{
-	struct dma_info *info = get_dma_info(chan);
-	struct dma_channel *channel = get_dma_channel(chan);
-
-	if (channel->flags & DMA_TEI_CAPABLE) {
-		wait_event(channel->wait_queue,
-			   (info->ops->get_residue(channel) == 0));
-		return;
-	}
-
-	while (info->ops->get_residue(channel))
-		cpu_relax();
-}
-EXPORT_SYMBOL(dma_wait_for_completion);
-
-int register_chan_caps(const char *dmac, struct dma_chan_caps *caps)
-{
-	struct dma_info *info;
-	unsigned int found = 0;
-	int i;
-
-	list_for_each_entry(info, &registered_dmac_list, list)
-		if (strcmp(dmac, info->name) == 0) {
-			found = 1;
-			break;
-		}
-
-	if (unlikely(!found))
-		return -ENODEV;
-
-	for (i = 0; i < info->nr_channels; i++, caps++) {
-		struct dma_channel *channel;
-
-		if ((info->first_channel_nr + i) != caps->ch_num)
-			return -EINVAL;
-
-		channel = &info->channels[i];
-		channel->caps = caps->caplist;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(register_chan_caps);
-
-void dma_configure_channel(unsigned int chan, unsigned long flags)
-{
-	struct dma_info *info = get_dma_info(chan);
-	struct dma_channel *channel = get_dma_channel(chan);
-
-	if (info->ops->configure)
-		info->ops->configure(channel, flags);
-}
-EXPORT_SYMBOL(dma_configure_channel);
-
-int dma_xfer(unsigned int chan, unsigned long from,
-	     unsigned long to, size_t size, unsigned int mode)
-{
-	struct dma_info *info = get_dma_info(chan);
-	struct dma_channel *channel = get_dma_channel(chan);
-
-	channel->sar	= from;
-	channel->dar	= to;
-	channel->count	= size;
-	channel->mode	= mode;
-
-	return info->ops->xfer(channel);
-}
-EXPORT_SYMBOL(dma_xfer);
-
-int dma_extend(unsigned int chan, unsigned long op, void *param)
-{
-	struct dma_info *info = get_dma_info(chan);
-	struct dma_channel *channel = get_dma_channel(chan);
-
-	if (info->ops->extend)
-		return info->ops->extend(channel, op, param);
-
-	return -ENOSYS;
-}
-EXPORT_SYMBOL(dma_extend);
-
-static int dma_proc_show(struct seq_file *m, void *v)
-{
-	struct dma_info *info = v;
-
-	if (list_empty(&registered_dmac_list))
-		return 0;
-
-	/*
-	 * Iterate over each registered DMAC
-	 */
-	list_for_each_entry(info, &registered_dmac_list, list) {
-		int i;
-
-		/*
-		 * Iterate over each channel
-		 */
-		for (i = 0; i < info->nr_channels; i++) {
-			struct dma_channel *channel = info->channels + i;
-
-			if (!(channel->flags & DMA_CONFIGURED))
-				continue;
-
-			seq_printf(m, "%2d: %14s    %s\n", i,
-				   info->name, channel->dev_id);
-		}
-	}
-
-	return 0;
-}
-
-int register_dmac(struct dma_info *info)
-{
-	unsigned int total_channels, i;
-
-	INIT_LIST_HEAD(&info->list);
-
-	printk(KERN_INFO "DMA: Registering %s handler (%d channel%s).\n",
-	       info->name, info->nr_channels, info->nr_channels > 1 ? "s" : "");
-
-	BUG_ON((info->flags & DMAC_CHANNELS_CONFIGURED) && !info->channels);
-
-	info->pdev = platform_device_register_simple(info->name, -1,
-						     NULL, 0);
-	if (IS_ERR(info->pdev))
-		return PTR_ERR(info->pdev);
-
-	/*
-	 * Don't touch pre-configured channels
-	 */
-	if (!(info->flags & DMAC_CHANNELS_CONFIGURED)) {
-		unsigned int size;
-
-		size = sizeof(struct dma_channel) * info->nr_channels;
-
-		info->channels = kzalloc(size, GFP_KERNEL);
-		if (!info->channels)
-			return -ENOMEM;
-	}
-
-	total_channels = get_nr_channels();
-	info->first_vchannel_nr = total_channels;
-	for (i = 0; i < info->nr_channels; i++) {
-		struct dma_channel *chan = &info->channels[i];
-
-		atomic_set(&chan->busy, 0);
-
-		chan->chan  = info->first_channel_nr + i;
-		chan->vchan = info->first_channel_nr + i + total_channels;
-
-		memcpy(chan->dev_id, "Unused", 7);
-
-		if (info->flags & DMAC_CHANNELS_TEI_CAPABLE)
-			chan->flags |= DMA_TEI_CAPABLE;
-
-		init_waitqueue_head(&chan->wait_queue);
-		dma_create_sysfs_files(chan, info);
-	}
-
-	list_add(&info->list, &registered_dmac_list);
-
-	return 0;
-}
-EXPORT_SYMBOL(register_dmac);
-
-void unregister_dmac(struct dma_info *info)
-{
-	unsigned int i;
-
-	for (i = 0; i < info->nr_channels; i++)
-		dma_remove_sysfs_files(info->channels + i, info);
-
-	if (!(info->flags & DMAC_CHANNELS_CONFIGURED))
-		kfree(info->channels);
-
-	list_del(&info->list);
-	platform_device_unregister(info->pdev);
-}
-EXPORT_SYMBOL(unregister_dmac);
-
-static int __init dma_api_init(void)
-{
-	printk(KERN_NOTICE "DMA: Registering DMA API.\n");
-	return proc_create_single("dma", 0, NULL, dma_proc_show) ? 0 : -ENOMEM;
-}
-subsys_initcall(dma_api_init);
-
-MODULE_AUTHOR("Paul Mundt <lethal@linux-sh.org>");
-MODULE_DESCRIPTION("DMA API for SuperH");
-MODULE_LICENSE("GPL v2");
diff --git a/arch/sh/drivers/dma/dma-g2.c b/arch/sh/drivers/dma/dma-g2.c
deleted file mode 100644
index 52a8ae5e30d2fb..00000000000000
--- a/arch/sh/drivers/dma/dma-g2.c
+++ /dev/null
@@ -1,197 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/drivers/dma/dma-g2.c
- *
- * G2 bus DMA support
- *
- * Copyright (C) 2003 - 2006  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/interrupt.h>
-#include <asm/cacheflush.h>
-#include <mach/sysasic.h>
-#include <mach/dma.h>
-#include <asm/dma.h>
-
-struct g2_channel {
-	unsigned long g2_addr;		/* G2 bus address */
-	unsigned long root_addr;	/* Root bus (SH-4) address */
-	unsigned long size;		/* Size (in bytes), 32-byte aligned */
-	unsigned long direction;	/* Transfer direction */
-	unsigned long ctrl;		/* Transfer control */
-	unsigned long chan_enable;	/* Channel enable */
-	unsigned long xfer_enable;	/* Transfer enable */
-	unsigned long xfer_stat;	/* Transfer status */
-} __attribute__ ((aligned(32)));
-
-struct g2_status {
-	unsigned long g2_addr;
-	unsigned long root_addr;
-	unsigned long size;
-	unsigned long status;
-} __attribute__ ((aligned(16)));
-
-struct g2_dma_info {
-	struct g2_channel channel[G2_NR_DMA_CHANNELS];
-	unsigned long pad1[G2_NR_DMA_CHANNELS];
-	unsigned long wait_state;
-	unsigned long pad2[10];
-	unsigned long magic;
-	struct g2_status status[G2_NR_DMA_CHANNELS];
-} __attribute__ ((aligned(256)));
-
-static volatile struct g2_dma_info *g2_dma = (volatile struct g2_dma_info *)0xa05f7800;
-
-#define g2_bytes_remaining(i) \
-	((g2_dma->channel[i].size - \
-	  g2_dma->status[i].size) & 0x0fffffff)
-
-static irqreturn_t g2_dma_interrupt(int irq, void *dev_id)
-{
-	int i;
-
-	for (i = 0; i < G2_NR_DMA_CHANNELS; i++) {
-		if (g2_dma->status[i].status & 0x20000000) {
-			unsigned int bytes = g2_bytes_remaining(i);
-
-			if (likely(bytes == 0)) {
-				struct dma_info *info = dev_id;
-				struct dma_channel *chan = info->channels + i;
-
-				wake_up(&chan->wait_queue);
-
-				return IRQ_HANDLED;
-			}
-		}
-	}
-
-	return IRQ_NONE;
-}
-
-static int g2_enable_dma(struct dma_channel *chan)
-{
-	unsigned int chan_nr = chan->chan;
-
-	g2_dma->channel[chan_nr].chan_enable = 1;
-	g2_dma->channel[chan_nr].xfer_enable = 1;
-
-	return 0;
-}
-
-static int g2_disable_dma(struct dma_channel *chan)
-{
-	unsigned int chan_nr = chan->chan;
-
-	g2_dma->channel[chan_nr].chan_enable = 0;
-	g2_dma->channel[chan_nr].xfer_enable = 0;
-
-	return 0;
-}
-
-static int g2_xfer_dma(struct dma_channel *chan)
-{
-	unsigned int chan_nr = chan->chan;
-
-	if (chan->sar & 31) {
-		printk("g2dma: unaligned source 0x%lx\n", chan->sar);
-		return -EINVAL;
-	}
-
-	if (chan->dar & 31) {
-		printk("g2dma: unaligned dest 0x%lx\n", chan->dar);
-		return -EINVAL;
-	}
-
-	/* Align the count */
-	if (chan->count & 31)
-		chan->count = (chan->count + (32 - 1)) & ~(32 - 1);
-
-	/* Fixup destination */
-	chan->dar += 0xa0800000;
-
-	/* Fixup direction */
-	chan->mode = !chan->mode;
-
-	flush_icache_range((unsigned long)chan->sar, chan->count);
-
-	g2_disable_dma(chan);
-
-	g2_dma->channel[chan_nr].g2_addr   = chan->dar & 0x1fffffe0;
-	g2_dma->channel[chan_nr].root_addr = chan->sar & 0x1fffffe0;
-	g2_dma->channel[chan_nr].size	   = (chan->count & ~31) | 0x80000000;
-	g2_dma->channel[chan_nr].direction = chan->mode;
-
-	/*
-	 * bit 0 - ???
-	 * bit 1 - if set, generate a hardware event on transfer completion
-	 * bit 2 - ??? something to do with suspend?
-	 */
-	g2_dma->channel[chan_nr].ctrl	= 5; /* ?? */
-
-	g2_enable_dma(chan);
-
-	/* debug cruft */
-	pr_debug("count, sar, dar, mode, ctrl, chan, xfer: %ld, 0x%08lx, "
-		 "0x%08lx, %ld, %ld, %ld, %ld\n",
-		 g2_dma->channel[chan_nr].size,
-		 g2_dma->channel[chan_nr].root_addr,
-		 g2_dma->channel[chan_nr].g2_addr,
-		 g2_dma->channel[chan_nr].direction,
-		 g2_dma->channel[chan_nr].ctrl,
-		 g2_dma->channel[chan_nr].chan_enable,
-		 g2_dma->channel[chan_nr].xfer_enable);
-
-	return 0;
-}
-
-static int g2_get_residue(struct dma_channel *chan)
-{
-	return g2_bytes_remaining(chan->chan);
-}
-
-static struct dma_ops g2_dma_ops = {
-	.xfer		= g2_xfer_dma,
-	.get_residue	= g2_get_residue,
-};
-
-static struct dma_info g2_dma_info = {
-	.name		= "g2_dmac",
-	.nr_channels	= 4,
-	.ops		= &g2_dma_ops,
-	.flags		= DMAC_CHANNELS_TEI_CAPABLE,
-};
-
-static int __init g2_dma_init(void)
-{
-	int ret;
-
-	ret = request_irq(HW_EVENT_G2_DMA, g2_dma_interrupt, 0,
-			  "g2 DMA handler", &g2_dma_info);
-	if (unlikely(ret))
-		return -EINVAL;
-
-	/* Magic */
-	g2_dma->wait_state	= 27;
-	g2_dma->magic		= 0x4659404f;
-
-	ret = register_dmac(&g2_dma_info);
-	if (unlikely(ret != 0))
-		free_irq(HW_EVENT_G2_DMA, &g2_dma_info);
-
-	return ret;
-}
-
-static void __exit g2_dma_exit(void)
-{
-	free_irq(HW_EVENT_G2_DMA, &g2_dma_info);
-	unregister_dmac(&g2_dma_info);
-}
-
-subsys_initcall(g2_dma_init);
-module_exit(g2_dma_exit);
-
-MODULE_AUTHOR("Paul Mundt <lethal@linux-sh.org>");
-MODULE_DESCRIPTION("G2 bus DMA driver");
-MODULE_LICENSE("GPL v2");
diff --git a/arch/sh/drivers/dma/dma-pvr2.c b/arch/sh/drivers/dma/dma-pvr2.c
deleted file mode 100644
index 21c347543e193d..00000000000000
--- a/arch/sh/drivers/dma/dma-pvr2.c
+++ /dev/null
@@ -1,102 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/drivers/dma/dma-pvr2.c
- *
- * NEC PowerVR 2 (Dreamcast) DMA support
- *
- * Copyright (C) 2003, 2004  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/interrupt.h>
-#include <mach/sysasic.h>
-#include <mach/dma.h>
-#include <asm/dma.h>
-#include <asm/io.h>
-
-static unsigned int xfer_complete;
-static int count;
-
-static irqreturn_t pvr2_dma_interrupt(int irq, void *dev_id)
-{
-	if (get_dma_residue(PVR2_CASCADE_CHAN)) {
-		printk(KERN_WARNING "DMA: SH DMAC did not complete transfer "
-		       "on channel %d, waiting..\n", PVR2_CASCADE_CHAN);
-		dma_wait_for_completion(PVR2_CASCADE_CHAN);
-	}
-
-	if (count++ < 10)
-		pr_debug("Got a pvr2 dma interrupt for channel %d\n",
-			 irq - HW_EVENT_PVR2_DMA);
-
-	xfer_complete = 1;
-
-	return IRQ_HANDLED;
-}
-
-static int pvr2_request_dma(struct dma_channel *chan)
-{
-	if (__raw_readl(PVR2_DMA_MODE) != 0)
-		return -EBUSY;
-
-	__raw_writel(0, PVR2_DMA_LMMODE0);
-
-	return 0;
-}
-
-static int pvr2_get_dma_residue(struct dma_channel *chan)
-{
-	return xfer_complete == 0;
-}
-
-static int pvr2_xfer_dma(struct dma_channel *chan)
-{
-	if (chan->sar || !chan->dar)
-		return -EINVAL;
-
-	xfer_complete = 0;
-
-	__raw_writel(chan->dar, PVR2_DMA_ADDR);
-	__raw_writel(chan->count, PVR2_DMA_COUNT);
-	__raw_writel(chan->mode & DMA_MODE_MASK, PVR2_DMA_MODE);
-
-	return 0;
-}
-
-static struct dma_ops pvr2_dma_ops = {
-	.request	= pvr2_request_dma,
-	.get_residue	= pvr2_get_dma_residue,
-	.xfer		= pvr2_xfer_dma,
-};
-
-static struct dma_info pvr2_dma_info = {
-	.name		= "pvr2_dmac",
-	.nr_channels	= 1,
-	.ops		= &pvr2_dma_ops,
-	.flags		= DMAC_CHANNELS_TEI_CAPABLE,
-};
-
-static int __init pvr2_dma_init(void)
-{
-	if (request_irq(HW_EVENT_PVR2_DMA, pvr2_dma_interrupt, 0,
-			"pvr2 DMA handler", NULL))
-		pr_err("Failed to register pvr2 DMA handler interrupt\n");
-	request_dma(PVR2_CASCADE_CHAN, "pvr2 cascade");
-
-	return register_dmac(&pvr2_dma_info);
-}
-
-static void __exit pvr2_dma_exit(void)
-{
-	free_dma(PVR2_CASCADE_CHAN);
-	free_irq(HW_EVENT_PVR2_DMA, 0);
-	unregister_dmac(&pvr2_dma_info);
-}
-
-subsys_initcall(pvr2_dma_init);
-module_exit(pvr2_dma_exit);
-
-MODULE_AUTHOR("Paul Mundt <lethal@linux-sh.org>");
-MODULE_DESCRIPTION("NEC PowerVR 2 DMA driver");
-MODULE_LICENSE("GPL v2");
diff --git a/arch/sh/drivers/dma/dma-sh.c b/arch/sh/drivers/dma/dma-sh.c
deleted file mode 100644
index 96c626c2cd0a49..00000000000000
--- a/arch/sh/drivers/dma/dma-sh.c
+++ /dev/null
@@ -1,414 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/drivers/dma/dma-sh.c
- *
- * SuperH On-chip DMAC Support
- *
- * Copyright (C) 2000 Takashi YOSHII
- * Copyright (C) 2003, 2004 Paul Mundt
- * Copyright (C) 2005 Andriy Skulysh
- */
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/io.h>
-#include <mach-dreamcast/mach/dma.h>
-#include <asm/dma.h>
-#include <asm/dma-register.h>
-#include <cpu/dma-register.h>
-#include <cpu/dma.h>
-
-/*
- * Define the default configuration for dual address memory-memory transfer.
- * The 0x400 value represents auto-request, external->external.
- */
-#define RS_DUAL	(DM_INC | SM_INC | RS_AUTO | TS_INDEX2VAL(XMIT_SZ_32BIT))
-
-static unsigned long dma_find_base(unsigned int chan)
-{
-	unsigned long base = SH_DMAC_BASE0;
-
-#ifdef SH_DMAC_BASE1
-	if (chan >= 6)
-		base = SH_DMAC_BASE1;
-#endif
-
-	return base;
-}
-
-static unsigned long dma_base_addr(unsigned int chan)
-{
-	unsigned long base = dma_find_base(chan);
-
-	/* Normalize offset calculation */
-	if (chan >= 9)
-		chan -= 6;
-	if (chan >= 4)
-		base += 0x10;
-
-	return base + (chan * 0x10);
-}
-
-#ifdef CONFIG_SH_DMA_IRQ_MULTI
-static inline unsigned int get_dmte_irq(unsigned int chan)
-{
-	return chan >= 6 ? DMTE6_IRQ : DMTE0_IRQ;
-}
-#else
-
-static unsigned int dmte_irq_map[] = {
-	DMTE0_IRQ, DMTE0_IRQ + 1, DMTE0_IRQ + 2, DMTE0_IRQ + 3,
-
-#ifdef DMTE4_IRQ
-	DMTE4_IRQ, DMTE4_IRQ + 1,
-#endif
-
-#ifdef DMTE6_IRQ
-	DMTE6_IRQ, DMTE6_IRQ + 1,
-#endif
-
-#ifdef DMTE8_IRQ
-	DMTE8_IRQ, DMTE9_IRQ, DMTE10_IRQ, DMTE11_IRQ,
-#endif
-};
-
-static inline unsigned int get_dmte_irq(unsigned int chan)
-{
-	return dmte_irq_map[chan];
-}
-#endif
-
-/*
- * We determine the correct shift size based off of the CHCR transmit size
- * for the given channel. Since we know that it will take:
- *
- *	info->count >> ts_shift[transmit_size]
- *
- * iterations to complete the transfer.
- */
-static unsigned int ts_shift[] = TS_SHIFT;
-
-static inline unsigned int calc_xmit_shift(struct dma_channel *chan)
-{
-	u32 chcr = __raw_readl(dma_base_addr(chan->chan) + CHCR);
-	int cnt = ((chcr & CHCR_TS_LOW_MASK) >> CHCR_TS_LOW_SHIFT) |
-		((chcr & CHCR_TS_HIGH_MASK) >> CHCR_TS_HIGH_SHIFT);
-
-	return ts_shift[cnt];
-}
-
-/*
- * The transfer end interrupt must read the chcr register to end the
- * hardware interrupt active condition.
- * Besides that it needs to waken any waiting process, which should handle
- * setting up the next transfer.
- */
-static irqreturn_t dma_tei(int irq, void *dev_id)
-{
-	struct dma_channel *chan = dev_id;
-	u32 chcr;
-
-	chcr = __raw_readl(dma_base_addr(chan->chan) + CHCR);
-
-	if (!(chcr & CHCR_TE))
-		return IRQ_NONE;
-
-	chcr &= ~(CHCR_IE | CHCR_DE);
-	__raw_writel(chcr, (dma_base_addr(chan->chan) + CHCR));
-
-	wake_up(&chan->wait_queue);
-
-	return IRQ_HANDLED;
-}
-
-static int sh_dmac_request_dma(struct dma_channel *chan)
-{
-	if (unlikely(!(chan->flags & DMA_TEI_CAPABLE)))
-		return 0;
-
-	return request_irq(get_dmte_irq(chan->chan), dma_tei, IRQF_SHARED,
-			   chan->dev_id, chan);
-}
-
-static void sh_dmac_free_dma(struct dma_channel *chan)
-{
-	free_irq(get_dmte_irq(chan->chan), chan);
-}
-
-static int
-sh_dmac_configure_channel(struct dma_channel *chan, unsigned long chcr)
-{
-	if (!chcr)
-		chcr = RS_DUAL | CHCR_IE;
-
-	if (chcr & CHCR_IE) {
-		chcr &= ~CHCR_IE;
-		chan->flags |= DMA_TEI_CAPABLE;
-	} else {
-		chan->flags &= ~DMA_TEI_CAPABLE;
-	}
-
-	__raw_writel(chcr, (dma_base_addr(chan->chan) + CHCR));
-
-	chan->flags |= DMA_CONFIGURED;
-	return 0;
-}
-
-static void sh_dmac_enable_dma(struct dma_channel *chan)
-{
-	int irq;
-	u32 chcr;
-
-	chcr = __raw_readl(dma_base_addr(chan->chan) + CHCR);
-	chcr |= CHCR_DE;
-
-	if (chan->flags & DMA_TEI_CAPABLE)
-		chcr |= CHCR_IE;
-
-	__raw_writel(chcr, (dma_base_addr(chan->chan) + CHCR));
-
-	if (chan->flags & DMA_TEI_CAPABLE) {
-		irq = get_dmte_irq(chan->chan);
-		enable_irq(irq);
-	}
-}
-
-static void sh_dmac_disable_dma(struct dma_channel *chan)
-{
-	int irq;
-	u32 chcr;
-
-	if (chan->flags & DMA_TEI_CAPABLE) {
-		irq = get_dmte_irq(chan->chan);
-		disable_irq(irq);
-	}
-
-	chcr = __raw_readl(dma_base_addr(chan->chan) + CHCR);
-	chcr &= ~(CHCR_DE | CHCR_TE | CHCR_IE);
-	__raw_writel(chcr, (dma_base_addr(chan->chan) + CHCR));
-}
-
-static int sh_dmac_xfer_dma(struct dma_channel *chan)
-{
-	/*
-	 * If we haven't pre-configured the channel with special flags, use
-	 * the defaults.
-	 */
-	if (unlikely(!(chan->flags & DMA_CONFIGURED)))
-		sh_dmac_configure_channel(chan, 0);
-
-	sh_dmac_disable_dma(chan);
-
-	/*
-	 * Single-address mode usage note!
-	 *
-	 * It's important that we don't accidentally write any value to SAR/DAR
-	 * (this includes 0) that hasn't been directly specified by the user if
-	 * we're in single-address mode.
-	 *
-	 * In this case, only one address can be defined, anything else will
-	 * result in a DMA address error interrupt (at least on the SH-4),
-	 * which will subsequently halt the transfer.
-	 *
-	 * Channel 2 on the Dreamcast is a special case, as this is used for
-	 * cascading to the PVR2 DMAC. In this case, we still need to write
-	 * SAR and DAR, regardless of value, in order for cascading to work.
-	 */
-	if (chan->sar || (mach_is_dreamcast() &&
-			  chan->chan == PVR2_CASCADE_CHAN))
-		__raw_writel(chan->sar, (dma_base_addr(chan->chan) + SAR));
-	if (chan->dar || (mach_is_dreamcast() &&
-			  chan->chan == PVR2_CASCADE_CHAN))
-		__raw_writel(chan->dar, (dma_base_addr(chan->chan) + DAR));
-
-	__raw_writel(chan->count >> calc_xmit_shift(chan),
-		(dma_base_addr(chan->chan) + TCR));
-
-	sh_dmac_enable_dma(chan);
-
-	return 0;
-}
-
-static int sh_dmac_get_dma_residue(struct dma_channel *chan)
-{
-	if (!(__raw_readl(dma_base_addr(chan->chan) + CHCR) & CHCR_DE))
-		return 0;
-
-	return __raw_readl(dma_base_addr(chan->chan) + TCR)
-		 << calc_xmit_shift(chan);
-}
-
-/*
- * DMAOR handling
- */
-#if defined(CONFIG_CPU_SUBTYPE_SH7723)	|| \
-    defined(CONFIG_CPU_SUBTYPE_SH7724)	|| \
-    defined(CONFIG_CPU_SUBTYPE_SH7780)	|| \
-    defined(CONFIG_CPU_SUBTYPE_SH7785)
-#define NR_DMAOR	2
-#else
-#define NR_DMAOR	1
-#endif
-
-/*
- * DMAOR bases are broken out amongst channel groups. DMAOR0 manages
- * channels 0 - 5, DMAOR1 6 - 11 (optional).
- */
-#define dmaor_read_reg(n)		__raw_readw(dma_find_base((n)*6))
-#define dmaor_write_reg(n, data)	__raw_writew(data, dma_find_base(n)*6)
-
-static inline int dmaor_reset(int no)
-{
-	unsigned long dmaor = dmaor_read_reg(no);
-
-	/* Try to clear the error flags first, incase they are set */
-	dmaor &= ~(DMAOR_NMIF | DMAOR_AE);
-	dmaor_write_reg(no, dmaor);
-
-	dmaor |= DMAOR_INIT;
-	dmaor_write_reg(no, dmaor);
-
-	/* See if we got an error again */
-	if ((dmaor_read_reg(no) & (DMAOR_AE | DMAOR_NMIF))) {
-		printk(KERN_ERR "dma-sh: Can't initialize DMAOR.\n");
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-/*
- * DMAE handling
- */
-#ifdef CONFIG_CPU_SH4
-
-#if defined(DMAE1_IRQ)
-#define NR_DMAE		2
-#else
-#define NR_DMAE		1
-#endif
-
-static const char *dmae_name[] = {
-	"DMAC Address Error0",
-	"DMAC Address Error1"
-};
-
-#ifdef CONFIG_SH_DMA_IRQ_MULTI
-static inline unsigned int get_dma_error_irq(int n)
-{
-	return get_dmte_irq(n * 6);
-}
-#else
-
-static unsigned int dmae_irq_map[] = {
-	DMAE0_IRQ,
-
-#ifdef DMAE1_IRQ
-	DMAE1_IRQ,
-#endif
-};
-
-static inline unsigned int get_dma_error_irq(int n)
-{
-	return dmae_irq_map[n];
-}
-#endif
-
-static irqreturn_t dma_err(int irq, void *dummy)
-{
-	int i;
-
-	for (i = 0; i < NR_DMAOR; i++)
-		dmaor_reset(i);
-
-	disable_irq(irq);
-
-	return IRQ_HANDLED;
-}
-
-static int dmae_irq_init(void)
-{
-	int n;
-
-	for (n = 0; n < NR_DMAE; n++) {
-		int i = request_irq(get_dma_error_irq(n), dma_err,
-				    IRQF_SHARED, dmae_name[n], (void *)dmae_name[n]);
-		if (unlikely(i < 0)) {
-			printk(KERN_ERR "%s request_irq fail\n", dmae_name[n]);
-			return i;
-		}
-	}
-
-	return 0;
-}
-
-static void dmae_irq_free(void)
-{
-	int n;
-
-	for (n = 0; n < NR_DMAE; n++)
-		free_irq(get_dma_error_irq(n), NULL);
-}
-#else
-static inline int dmae_irq_init(void)
-{
-	return 0;
-}
-
-static void dmae_irq_free(void)
-{
-}
-#endif
-
-static struct dma_ops sh_dmac_ops = {
-	.request	= sh_dmac_request_dma,
-	.free		= sh_dmac_free_dma,
-	.get_residue	= sh_dmac_get_dma_residue,
-	.xfer		= sh_dmac_xfer_dma,
-	.configure	= sh_dmac_configure_channel,
-};
-
-static struct dma_info sh_dmac_info = {
-	.name		= "sh_dmac",
-	.nr_channels	= CONFIG_NR_ONCHIP_DMA_CHANNELS,
-	.ops		= &sh_dmac_ops,
-	.flags		= DMAC_CHANNELS_TEI_CAPABLE,
-};
-
-static int __init sh_dmac_init(void)
-{
-	struct dma_info *info = &sh_dmac_info;
-	int i, rc;
-
-	/*
-	 * Initialize DMAE, for parts that support it.
-	 */
-	rc = dmae_irq_init();
-	if (unlikely(rc != 0))
-		return rc;
-
-	/*
-	 * Initialize DMAOR, and clean up any error flags that may have
-	 * been set.
-	 */
-	for (i = 0; i < NR_DMAOR; i++) {
-		rc = dmaor_reset(i);
-		if (unlikely(rc != 0))
-			return rc;
-	}
-
-	return register_dmac(info);
-}
-
-static void __exit sh_dmac_exit(void)
-{
-	dmae_irq_free();
-	unregister_dmac(&sh_dmac_info);
-}
-
-subsys_initcall(sh_dmac_init);
-module_exit(sh_dmac_exit);
-
-MODULE_AUTHOR("Takashi YOSHII, Paul Mundt, Andriy Skulysh");
-MODULE_DESCRIPTION("SuperH On-Chip DMAC Support");
-MODULE_LICENSE("GPL v2");
diff --git a/arch/sh/drivers/dma/dma-sysfs.c b/arch/sh/drivers/dma/dma-sysfs.c
deleted file mode 100644
index 8ef318150f84db..00000000000000
--- a/arch/sh/drivers/dma/dma-sysfs.c
+++ /dev/null
@@ -1,164 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/drivers/dma/dma-sysfs.c
- *
- * sysfs interface for SH DMA API
- *
- * Copyright (C) 2004 - 2006  Paul Mundt
- */
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/stat.h>
-#include <linux/device.h>
-#include <linux/platform_device.h>
-#include <linux/err.h>
-#include <linux/string.h>
-#include <asm/dma.h>
-
-static struct bus_type dma_subsys = {
-	.name = "dma",
-	.dev_name = "dma",
-};
-
-static ssize_t dma_show_devices(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	ssize_t len = 0;
-	int i;
-
-	for (i = 0; i < 16; i++) {
-		struct dma_info *info = get_dma_info(i);
-		struct dma_channel *channel = get_dma_channel(i);
-
-		if (unlikely(!info) || !channel)
-			continue;
-
-		len += sprintf(buf + len, "%2d: %14s    %s\n",
-			       channel->chan, info->name,
-			       channel->dev_id);
-	}
-
-	return len;
-}
-
-static DEVICE_ATTR(devices, S_IRUGO, dma_show_devices, NULL);
-
-static int __init dma_subsys_init(void)
-{
-	int ret;
-
-	ret = subsys_system_register(&dma_subsys, NULL);
-	if (unlikely(ret))
-		return ret;
-
-	return device_create_file(dma_subsys.dev_root, &dev_attr_devices);
-}
-postcore_initcall(dma_subsys_init);
-
-static ssize_t dma_show_dev_id(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	struct dma_channel *channel = to_dma_channel(dev);
-	return sprintf(buf, "%s\n", channel->dev_id);
-}
-
-static ssize_t dma_store_dev_id(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf, size_t count)
-{
-	struct dma_channel *channel = to_dma_channel(dev);
-	strcpy(channel->dev_id, buf);
-	return count;
-}
-
-static DEVICE_ATTR(dev_id, S_IRUGO | S_IWUSR, dma_show_dev_id, dma_store_dev_id);
-
-static ssize_t dma_store_config(struct device *dev,
-				struct device_attribute *attr,
-				const char *buf, size_t count)
-{
-	struct dma_channel *channel = to_dma_channel(dev);
-	unsigned long config;
-
-	config = simple_strtoul(buf, NULL, 0);
-	dma_configure_channel(channel->vchan, config);
-
-	return count;
-}
-
-static DEVICE_ATTR(config, S_IWUSR, NULL, dma_store_config);
-
-static ssize_t dma_show_mode(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	struct dma_channel *channel = to_dma_channel(dev);
-	return sprintf(buf, "0x%08x\n", channel->mode);
-}
-
-static ssize_t dma_store_mode(struct device *dev,
-			      struct device_attribute *attr,
-			      const char *buf, size_t count)
-{
-	struct dma_channel *channel = to_dma_channel(dev);
-	channel->mode = simple_strtoul(buf, NULL, 0);
-	return count;
-}
-
-static DEVICE_ATTR(mode, S_IRUGO | S_IWUSR, dma_show_mode, dma_store_mode);
-
-#define dma_ro_attr(field, fmt)						\
-static ssize_t dma_show_##field(struct device *dev,		\
-				struct device_attribute *attr, char *buf)\
-{									\
-	struct dma_channel *channel = to_dma_channel(dev);		\
-	return sprintf(buf, fmt, channel->field);			\
-}									\
-static DEVICE_ATTR(field, S_IRUGO, dma_show_##field, NULL);
-
-dma_ro_attr(count, "0x%08x\n");
-dma_ro_attr(flags, "0x%08lx\n");
-
-int dma_create_sysfs_files(struct dma_channel *chan, struct dma_info *info)
-{
-	struct device *dev = &chan->dev;
-	char name[16];
-	int ret;
-
-	dev->id  = chan->vchan;
-	dev->bus = &dma_subsys;
-
-	ret = device_register(dev);
-	if (ret)
-		return ret;
-
-	ret |= device_create_file(dev, &dev_attr_dev_id);
-	ret |= device_create_file(dev, &dev_attr_count);
-	ret |= device_create_file(dev, &dev_attr_mode);
-	ret |= device_create_file(dev, &dev_attr_flags);
-	ret |= device_create_file(dev, &dev_attr_config);
-
-	if (unlikely(ret)) {
-		dev_err(&info->pdev->dev, "Failed creating attrs\n");
-		return ret;
-	}
-
-	snprintf(name, sizeof(name), "dma%d", chan->chan);
-	return sysfs_create_link(&info->pdev->dev.kobj, &dev->kobj, name);
-}
-
-void dma_remove_sysfs_files(struct dma_channel *chan, struct dma_info *info)
-{
-	struct device *dev = &chan->dev;
-	char name[16];
-
-	device_remove_file(dev, &dev_attr_dev_id);
-	device_remove_file(dev, &dev_attr_count);
-	device_remove_file(dev, &dev_attr_mode);
-	device_remove_file(dev, &dev_attr_flags);
-	device_remove_file(dev, &dev_attr_config);
-
-	snprintf(name, sizeof(name), "dma%d", chan->chan);
-	sysfs_remove_link(&info->pdev->dev.kobj, name);
-
-	device_unregister(dev);
-}
diff --git a/arch/sh/drivers/dma/dmabrg.c b/arch/sh/drivers/dma/dmabrg.c
deleted file mode 100644
index 5b2c1fd254d729..00000000000000
--- a/arch/sh/drivers/dma/dmabrg.c
+++ /dev/null
@@ -1,196 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7760 DMABRG IRQ handling
- *
- * (c) 2007 MSC Vertriebsges.m.b.H, Manuel Lauss <mlau@msc-ge.com>
- */
-
-#include <linux/interrupt.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <asm/dma.h>
-#include <asm/dmabrg.h>
-#include <asm/io.h>
-
-/*
- * The DMABRG is a special DMA unit within the SH7760. It does transfers
- * from USB-SRAM/Audio units to main memory (and also the LCDC; but that
- * part is sensibly placed  in the LCDC  registers and requires no irqs)
- * It has 3 IRQ lines which trigger 10 events, and works independently
- * from the traditional SH DMAC (although it blocks usage of DMAC 0)
- *
- * BRGIRQID   | component | dir | meaning      | source
- * -----------------------------------------------------
- *     0      | USB-DMA   | ... | xfer done    | DMABRGI1
- *     1      | USB-UAE   | ... | USB addr err.| DMABRGI0
- *     2      | HAC0/SSI0 | play| all done     | DMABRGI1
- *     3      | HAC0/SSI0 | play| half done    | DMABRGI2
- *     4      | HAC0/SSI0 | rec | all done     | DMABRGI1
- *     5      | HAC0/SSI0 | rec | half done    | DMABRGI2
- *     6      | HAC1/SSI1 | play| all done     | DMABRGI1
- *     7      | HAC1/SSI1 | play| half done    | DMABRGI2
- *     8      | HAC1/SSI1 | rec | all done     | DMABRGI1
- *     9      | HAC1/SSI1 | rec | half done    | DMABRGI2
- *
- * all can be enabled/disabled in the DMABRGCR register,
- * as well as checked if they occurred.
- *
- * DMABRGI0 services  USB  DMA  Address  errors,  but it still must be
- * enabled/acked in the DMABRGCR register.  USB-DMA complete indicator
- * is grouped together with the audio buffer end indicators, too bad...
- *
- * DMABRGCR:	Bits 31-24: audio-dma ENABLE flags,
- *		Bits 23-16: audio-dma STATUS flags,
- *		Bits  9-8:  USB error/xfer ENABLE,
- *		Bits  1-0:  USB error/xfer STATUS.
- *	Ack an IRQ by writing 0 to the STATUS flag.
- *	Mask IRQ by writing 0 to ENABLE flag.
- *
- * Usage is almost like with any other IRQ:
- *  dmabrg_request_irq(BRGIRQID, handler, data)
- *  dmabrg_free_irq(BRGIRQID)
- *
- * handler prototype:  void brgirqhandler(void *data)
- */
-
-#define DMARSRA		0xfe090000
-#define DMAOR		0xffa00040
-#define DMACHCR0	0xffa0000c
-#define DMABRGCR	0xfe3c0000
-
-#define DMAOR_BRG	0x0000c000
-#define DMAOR_DMEN	0x00000001
-
-#define DMABRGI0	68
-#define DMABRGI1	69
-#define DMABRGI2	70
-
-struct dmabrg_handler {
-	void (*handler)(void *);
-	void *data;
-} *dmabrg_handlers;
-
-static inline void dmabrg_call_handler(int i)
-{
-	dmabrg_handlers[i].handler(dmabrg_handlers[i].data);
-}
-
-/*
- * main DMABRG irq handler. It acks irqs and then
- * handles every set and unmasked bit sequentially.
- * No locking and no validity checks; it should be
- * as fast as possible (audio!)
- */
-static irqreturn_t dmabrg_irq(int irq, void *data)
-{
-	unsigned long dcr;
-	unsigned int i;
-
-	dcr = __raw_readl(DMABRGCR);
-	__raw_writel(dcr & ~0x00ff0003, DMABRGCR);	/* ack all */
-	dcr &= dcr >> 8;	/* ignore masked */
-
-	/* USB stuff, get it out of the way first */
-	if (dcr & 1)
-		dmabrg_call_handler(DMABRGIRQ_USBDMA);
-	if (dcr & 2)
-		dmabrg_call_handler(DMABRGIRQ_USBDMAERR);
-
-	/* Audio */
-	dcr >>= 16;
-	while (dcr) {
-		i = __ffs(dcr);
-		dcr &= dcr - 1;
-		dmabrg_call_handler(i + DMABRGIRQ_A0TXF);
-	}
-	return IRQ_HANDLED;
-}
-
-static void dmabrg_disable_irq(unsigned int dmairq)
-{
-	unsigned long dcr;
-	dcr = __raw_readl(DMABRGCR);
-	dcr &= ~(1 << ((dmairq > 1) ? dmairq + 22 : dmairq + 8));
-	__raw_writel(dcr, DMABRGCR);
-}
-
-static void dmabrg_enable_irq(unsigned int dmairq)
-{
-	unsigned long dcr;
-	dcr = __raw_readl(DMABRGCR);
-	dcr |= (1 << ((dmairq > 1) ? dmairq + 22 : dmairq + 8));
-	__raw_writel(dcr, DMABRGCR);
-}
-
-int dmabrg_request_irq(unsigned int dmairq, void(*handler)(void*),
-		       void *data)
-{
-	if ((dmairq > 9) || !handler)
-		return -ENOENT;
-	if (dmabrg_handlers[dmairq].handler)
-		return -EBUSY;
-
-	dmabrg_handlers[dmairq].handler = handler;
-	dmabrg_handlers[dmairq].data = data;
-	
-	dmabrg_enable_irq(dmairq);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(dmabrg_request_irq);
-
-void dmabrg_free_irq(unsigned int dmairq)
-{
-	if (likely(dmairq < 10)) {
-		dmabrg_disable_irq(dmairq);
-		dmabrg_handlers[dmairq].handler = NULL;
-		dmabrg_handlers[dmairq].data = NULL;
-	}
-}
-EXPORT_SYMBOL_GPL(dmabrg_free_irq);
-
-static int __init dmabrg_init(void)
-{
-	unsigned long or;
-	int ret;
-
-	dmabrg_handlers = kcalloc(10, sizeof(struct dmabrg_handler),
-				  GFP_KERNEL);
-	if (!dmabrg_handlers)
-		return -ENOMEM;
-
-#ifdef CONFIG_SH_DMA
-	/* request DMAC channel 0 before anyone else can get it */
-	ret = request_dma(0, "DMAC 0 (DMABRG)");
-	if (ret < 0)
-		printk(KERN_INFO "DMABRG: DMAC ch0 not reserved!\n");
-#endif
-
-	__raw_writel(0, DMABRGCR);
-	__raw_writel(0, DMACHCR0);
-	__raw_writel(0x94000000, DMARSRA);	/* enable DMABRG in DMAC 0 */
-
-	/* enable DMABRG mode, enable the DMAC */
-	or = __raw_readl(DMAOR);
-	__raw_writel(or | DMAOR_BRG | DMAOR_DMEN, DMAOR);
-
-	ret = request_irq(DMABRGI0, dmabrg_irq, 0,
-			"DMABRG USB address error", NULL);
-	if (ret)
-		goto out0;
-
-	ret = request_irq(DMABRGI1, dmabrg_irq, 0,
-			"DMABRG Transfer End", NULL);
-	if (ret)
-		goto out1;
-
-	ret = request_irq(DMABRGI2, dmabrg_irq, 0,
-			"DMABRG Transfer Half", NULL);
-	if (ret == 0)
-		return ret;
-
-	free_irq(DMABRGI1, NULL);
-out1:	free_irq(DMABRGI0, NULL);
-out0:	kfree(dmabrg_handlers);
-	return ret;
-}
-subsys_initcall(dmabrg_init);
diff --git a/arch/sh/drivers/heartbeat.c b/arch/sh/drivers/heartbeat.c
deleted file mode 100644
index 24391b444b286d..00000000000000
--- a/arch/sh/drivers/heartbeat.c
+++ /dev/null
@@ -1,152 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Generic heartbeat driver for regular LED banks
- *
- * Copyright (C) 2007 - 2010  Paul Mundt
- *
- * Most SH reference boards include a number of individual LEDs that can
- * be independently controlled (either via a pre-defined hardware
- * function or via the LED class, if desired -- the hardware tends to
- * encapsulate some of the same "triggers" that the LED class supports,
- * so there's not too much value in it).
- *
- * Additionally, most of these boards also have a LED bank that we've
- * traditionally used for strobing the load average. This use case is
- * handled by this driver, rather than giving each LED bit position its
- * own struct device.
- */
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/sched.h>
-#include <linux/sched/loadavg.h>
-#include <linux/timer.h>
-#include <linux/io.h>
-#include <linux/slab.h>
-#include <asm/heartbeat.h>
-
-#define DRV_NAME "heartbeat"
-#define DRV_VERSION "0.1.2"
-
-static unsigned char default_bit_pos[] = { 0, 1, 2, 3, 4, 5, 6, 7 };
-
-static inline void heartbeat_toggle_bit(struct heartbeat_data *hd,
-					unsigned bit, unsigned int inverted)
-{
-	unsigned int new;
-
-	new = (1 << hd->bit_pos[bit]);
-	if (inverted)
-		new = ~new;
-
-	new &= hd->mask;
-
-	switch (hd->regsize) {
-	case 32:
-		new |= ioread32(hd->base) & ~hd->mask;
-		iowrite32(new, hd->base);
-		break;
-	case 16:
-		new |= ioread16(hd->base) & ~hd->mask;
-		iowrite16(new, hd->base);
-		break;
-	default:
-		new |= ioread8(hd->base) & ~hd->mask;
-		iowrite8(new, hd->base);
-		break;
-	}
-}
-
-static void heartbeat_timer(struct timer_list *t)
-{
-	struct heartbeat_data *hd = from_timer(hd, t, timer);
-	static unsigned bit = 0, up = 1;
-
-	heartbeat_toggle_bit(hd, bit, hd->flags & HEARTBEAT_INVERTED);
-
-	bit += up;
-	if ((bit == 0) || (bit == (hd->nr_bits)-1))
-		up = -up;
-
-	mod_timer(&hd->timer, jiffies + (110 - ((300 << FSHIFT) /
-			((avenrun[0] / 5) + (3 << FSHIFT)))));
-}
-
-static int heartbeat_drv_probe(struct platform_device *pdev)
-{
-	struct resource *res;
-	struct heartbeat_data *hd;
-	int i;
-
-	if (unlikely(pdev->num_resources != 1)) {
-		dev_err(&pdev->dev, "invalid number of resources\n");
-		return -EINVAL;
-	}
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (unlikely(res == NULL)) {
-		dev_err(&pdev->dev, "invalid resource\n");
-		return -EINVAL;
-	}
-
-	if (pdev->dev.platform_data) {
-		hd = pdev->dev.platform_data;
-	} else {
-		hd = kzalloc(sizeof(struct heartbeat_data), GFP_KERNEL);
-		if (unlikely(!hd))
-			return -ENOMEM;
-	}
-
-	hd->base = ioremap(res->start, resource_size(res));
-	if (unlikely(!hd->base)) {
-		dev_err(&pdev->dev, "ioremap failed\n");
-
-		if (!pdev->dev.platform_data)
-			kfree(hd);
-
-		return -ENXIO;
-	}
-
-	if (!hd->nr_bits) {
-		hd->bit_pos = default_bit_pos;
-		hd->nr_bits = ARRAY_SIZE(default_bit_pos);
-	}
-
-	hd->mask = 0;
-	for (i = 0; i < hd->nr_bits; i++)
-		hd->mask |= (1 << hd->bit_pos[i]);
-
-	if (!hd->regsize) {
-		switch (res->flags & IORESOURCE_MEM_TYPE_MASK) {
-		case IORESOURCE_MEM_32BIT:
-			hd->regsize = 32;
-			break;
-		case IORESOURCE_MEM_16BIT:
-			hd->regsize = 16;
-			break;
-		case IORESOURCE_MEM_8BIT:
-		default:
-			hd->regsize = 8;
-			break;
-		}
-	}
-
-	timer_setup(&hd->timer, heartbeat_timer, 0);
-	platform_set_drvdata(pdev, hd);
-
-	return mod_timer(&hd->timer, jiffies + 1);
-}
-
-static struct platform_driver heartbeat_driver = {
-	.probe		= heartbeat_drv_probe,
-	.driver		= {
-		.name			= DRV_NAME,
-		.suppress_bind_attrs	= true,
-	},
-};
-
-static int __init heartbeat_init(void)
-{
-	printk(KERN_NOTICE DRV_NAME ": version %s loaded\n", DRV_VERSION);
-	return platform_driver_register(&heartbeat_driver);
-}
-device_initcall(heartbeat_init);
diff --git a/arch/sh/drivers/pci/Makefile b/arch/sh/drivers/pci/Makefile
deleted file mode 100644
index d313fd3ce7091e..00000000000000
--- a/arch/sh/drivers/pci/Makefile
+++ /dev/null
@@ -1,27 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the PCI specific kernel interface routines under Linux.
-#
-obj-y					+= common.o pci.o
-
-obj-$(CONFIG_CPU_SUBTYPE_SH7751)	+= pci-sh7751.o ops-sh4.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7751R)	+= pci-sh7751.o ops-sh4.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7763)	+= pci-sh7780.o ops-sh4.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7780)	+= pci-sh7780.o ops-sh4.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7785)	+= pci-sh7780.o ops-sh4.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7786)	+= pcie-sh7786.o ops-sh7786.o
-
-obj-$(CONFIG_SH_DREAMCAST)		+= ops-dreamcast.o fixups-dreamcast.o \
-					   pci-dreamcast.o
-obj-$(CONFIG_SH_SECUREEDGE5410)		+= fixups-snapgear.o
-obj-$(CONFIG_SH_7751_SOLUTION_ENGINE)	+= fixups-se7751.o
-obj-$(CONFIG_SH_RTS7751R2D)		+= fixups-rts7751r2d.o
-obj-$(CONFIG_SH_SH03)			+= fixups-sh03.o
-obj-$(CONFIG_SH_HIGHLANDER)		+= fixups-r7780rp.o
-obj-$(CONFIG_SH_SH7785LCR)		+= fixups-r7780rp.o
-obj-$(CONFIG_SH_SDK7786)		+= fixups-sdk7786.o
-obj-$(CONFIG_SH_SDK7780)		+= fixups-sdk7780.o
-obj-$(CONFIG_SH_7780_SOLUTION_ENGINE)	+= fixups-sdk7780.o
-obj-$(CONFIG_SH_TITAN)			+= fixups-titan.o
-obj-$(CONFIG_SH_LANDISK)		+= fixups-landisk.o
-obj-$(CONFIG_SH_LBOX_RE2)		+= fixups-rts7751r2d.o
diff --git a/arch/sh/drivers/pci/common.c b/arch/sh/drivers/pci/common.c
deleted file mode 100644
index 2fd2b77e12cec1..00000000000000
--- a/arch/sh/drivers/pci/common.c
+++ /dev/null
@@ -1,159 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/pci.h>
-#include <linux/interrupt.h>
-#include <linux/timer.h>
-#include <linux/kernel.h>
-
-/*
- * These functions are used early on before PCI scanning is done
- * and all of the pci_dev and pci_bus structures have been created.
- */
-static struct pci_dev *fake_pci_dev(struct pci_channel *hose,
-	int top_bus, int busnr, int devfn)
-{
-	static struct pci_dev dev;
-	static struct pci_bus bus;
-
-	dev.bus = &bus;
-	dev.sysdata = hose;
-	dev.devfn = devfn;
-	bus.number = busnr;
-	bus.sysdata = hose;
-	bus.ops = hose->pci_ops;
-
-	if(busnr != top_bus)
-		/* Fake a parent bus structure. */
-		bus.parent = &bus;
-	else
-		bus.parent = NULL;
-
-	return &dev;
-}
-
-#define EARLY_PCI_OP(rw, size, type)					\
-int __init early_##rw##_config_##size(struct pci_channel *hose,		\
-	int top_bus, int bus, int devfn, int offset, type value)	\
-{									\
-	return pci_##rw##_config_##size(				\
-		fake_pci_dev(hose, top_bus, bus, devfn),		\
-		offset, value);						\
-}
-
-EARLY_PCI_OP(read, byte, u8 *)
-EARLY_PCI_OP(read, word, u16 *)
-EARLY_PCI_OP(read, dword, u32 *)
-EARLY_PCI_OP(write, byte, u8)
-EARLY_PCI_OP(write, word, u16)
-EARLY_PCI_OP(write, dword, u32)
-
-int __init pci_is_66mhz_capable(struct pci_channel *hose,
-				int top_bus, int current_bus)
-{
-	u32 pci_devfn;
-	unsigned short vid;
-	int cap66 = -1;
-	u16 stat;
-
-	pr_info("PCI: Checking 66MHz capabilities...\n");
-
-	for (pci_devfn = 0; pci_devfn < 0xff; pci_devfn++) {
-		if (PCI_FUNC(pci_devfn))
-			continue;
-		if (early_read_config_word(hose, top_bus, current_bus,
-					   pci_devfn, PCI_VENDOR_ID, &vid) !=
-		    PCIBIOS_SUCCESSFUL)
-			continue;
-		if (vid == 0xffff)
-			continue;
-
-		/* check 66MHz capability */
-		if (cap66 < 0)
-			cap66 = 1;
-		if (cap66) {
-			early_read_config_word(hose, top_bus, current_bus,
-					       pci_devfn, PCI_STATUS, &stat);
-			if (!(stat & PCI_STATUS_66MHZ)) {
-				printk(KERN_DEBUG
-				       "PCI: %02x:%02x not 66MHz capable.\n",
-				       current_bus, pci_devfn);
-				cap66 = 0;
-				break;
-			}
-		}
-	}
-
-	return cap66 > 0;
-}
-
-static void pcibios_enable_err(struct timer_list *t)
-{
-	struct pci_channel *hose = from_timer(hose, t, err_timer);
-
-	del_timer(&hose->err_timer);
-	printk(KERN_DEBUG "PCI: re-enabling error IRQ.\n");
-	enable_irq(hose->err_irq);
-}
-
-static void pcibios_enable_serr(struct timer_list *t)
-{
-	struct pci_channel *hose = from_timer(hose, t, serr_timer);
-
-	del_timer(&hose->serr_timer);
-	printk(KERN_DEBUG "PCI: re-enabling system error IRQ.\n");
-	enable_irq(hose->serr_irq);
-}
-
-void pcibios_enable_timers(struct pci_channel *hose)
-{
-	if (hose->err_irq) {
-		timer_setup(&hose->err_timer, pcibios_enable_err, 0);
-	}
-
-	if (hose->serr_irq) {
-		timer_setup(&hose->serr_timer, pcibios_enable_serr, 0);
-	}
-}
-
-/*
- * A simple handler for the regular PCI status errors, called from IRQ
- * context.
- */
-unsigned int pcibios_handle_status_errors(unsigned long addr,
-					  unsigned int status,
-					  struct pci_channel *hose)
-{
-	unsigned int cmd = 0;
-
-	if (status & PCI_STATUS_REC_MASTER_ABORT) {
-		printk(KERN_DEBUG "PCI: master abort, pc=0x%08lx\n", addr);
-		cmd |= PCI_STATUS_REC_MASTER_ABORT;
-	}
-
-	if (status & PCI_STATUS_REC_TARGET_ABORT) {
-		printk(KERN_DEBUG "PCI: target abort: ");
-		pcibios_report_status(PCI_STATUS_REC_TARGET_ABORT |
-				      PCI_STATUS_SIG_TARGET_ABORT |
-				      PCI_STATUS_REC_MASTER_ABORT, 1);
-		pr_cont("\n");
-
-		cmd |= PCI_STATUS_REC_TARGET_ABORT;
-	}
-
-	if (status & (PCI_STATUS_PARITY | PCI_STATUS_DETECTED_PARITY)) {
-		printk(KERN_DEBUG "PCI: parity error detected: ");
-		pcibios_report_status(PCI_STATUS_PARITY |
-				      PCI_STATUS_DETECTED_PARITY, 1);
-		pr_cont("\n");
-
-		cmd |= PCI_STATUS_PARITY | PCI_STATUS_DETECTED_PARITY;
-
-		/* Now back off of the IRQ for awhile */
-		if (hose->err_irq) {
-			disable_irq_nosync(hose->err_irq);
-			hose->err_timer.expires = jiffies + HZ;
-			add_timer(&hose->err_timer);
-		}
-	}
-
-	return cmd;
-}
diff --git a/arch/sh/drivers/pci/fixups-dreamcast.c b/arch/sh/drivers/pci/fixups-dreamcast.c
deleted file mode 100644
index 41e4daee8f043f..00000000000000
--- a/arch/sh/drivers/pci/fixups-dreamcast.c
+++ /dev/null
@@ -1,84 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/drivers/pci/fixups-dreamcast.c
- *
- * PCI fixups for the Sega Dreamcast
- *
- * Copyright (C) 2001, 2002  M. R. Brown
- * Copyright (C) 2002, 2003, 2006  Paul Mundt
- *
- * This file originally bore the message (with enclosed-$):
- *	Id: pci.c,v 1.3 2003/05/04 19:29:46 lethal Exp
- *	Dreamcast PCI: Supports SEGA Broadband Adaptor only.
- */
-
-#include <linux/sched.h>
-#include <linux/kernel.h>
-#include <linux/param.h>
-#include <linux/interrupt.h>
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/pci.h>
-#include <linux/dma-map-ops.h>
-
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <mach/pci.h>
-
-static void gapspci_fixup_resources(struct pci_dev *dev)
-{
-	struct pci_channel *p = dev->sysdata;
-	struct resource res;
-	struct pci_bus_region region;
-
-	printk(KERN_NOTICE "PCI: Fixing up device %s\n", pci_name(dev));
-
-	switch (dev->device) {
-	case PCI_DEVICE_ID_SEGA_BBA:
-		/*
-		 * We also assume that dev->devfn == 0
-		 */
-		dev->resource[1].start	= p->resources[0].start  + 0x100;
-		dev->resource[1].end	= dev->resource[1].start + 0x200 - 1;
-
-		/*
-		 * This is not a normal BAR, prevent any attempts to move
-		 * the BAR, as this will result in a bus lock.
-		 */
-		dev->resource[1].flags |= IORESOURCE_PCI_FIXED;
-
-		/*
-		 * Redirect dma memory allocations to special memory window.
-		 *
-		 * If this GAPSPCI region were mapped by a BAR, the CPU
-		 * phys_addr_t would be pci_resource_start(), and the bus
-		 * address would be pci_bus_address(pci_resource_start()).
-		 * But apparently there's no BAR mapping it, so we just
-		 * "know" its CPU address is GAPSPCI_DMA_BASE.
-		 */
-		res.start = GAPSPCI_DMA_BASE;
-		res.end = GAPSPCI_DMA_BASE + GAPSPCI_DMA_SIZE - 1;
-		res.flags = IORESOURCE_MEM;
-		pcibios_resource_to_bus(dev->bus, &region, &res);
-		BUG_ON(dma_declare_coherent_memory(&dev->dev,
-						res.start,
-						region.start,
-						resource_size(&res)));
-		break;
-	default:
-		printk("PCI: Failed resource fixup\n");
-	}
-}
-DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, gapspci_fixup_resources);
-
-int pcibios_map_platform_irq(const struct pci_dev *dev, u8 slot, u8 pin)
-{
-	/*
-	 * The interrupt routing semantics here are quite trivial.
-	 *
-	 * We basically only support one interrupt, so we only bother
-	 * updating a device's interrupt line with this single shared
-	 * interrupt. Keeps routing quite simple, doesn't it?
-	 */
-	return GAPSPCI_IRQ;
-}
diff --git a/arch/sh/drivers/pci/fixups-landisk.c b/arch/sh/drivers/pci/fixups-landisk.c
deleted file mode 100644
index 53fa2fc87eec28..00000000000000
--- a/arch/sh/drivers/pci/fixups-landisk.c
+++ /dev/null
@@ -1,57 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/drivers/pci/fixups-landisk.c
- *
- * PCI initialization for the I-O DATA Device, Inc. LANDISK board
- *
- * Copyright (C) 2006 kogiidena
- * Copyright (C) 2010 Nobuhiro Iwamatsu
- */
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/pci.h>
-#include <linux/sh_intc.h>
-#include "pci-sh4.h"
-
-#define PCIMCR_MRSET_OFF	0xBFFFFFFF
-#define PCIMCR_RFSH_OFF		0xFFFFFFFB
-
-int pcibios_map_platform_irq(const struct pci_dev *pdev, u8 slot, u8 pin)
-{
-	/*
-	 * slot0: pin1-4 = irq5,6,7,8
-	 * slot1: pin1-4 = irq6,7,8,5
-	 * slot2: pin1-4 = irq7,8,5,6
-	 * slot3: pin1-4 = irq8,5,6,7
-	 */
-	int irq = ((slot + pin - 1) & 0x3) + evt2irq(0x2a0);
-
-	if ((slot | (pin - 1)) > 0x3) {
-		printk(KERN_WARNING "PCI: Bad IRQ mapping request for slot %d pin %c\n",
-		       slot, pin - 1 + 'A');
-		return -1;
-	}
-	return irq;
-}
-
-int pci_fixup_pcic(struct pci_channel *chan)
-{
-	unsigned long bcr1, mcr;
-
-	bcr1 = __raw_readl(SH7751_BCR1);
-	bcr1 |= 0x40080000;	/* Enable Bit 19 BREQEN, set PCIC to slave */
-	pci_write_reg(chan, bcr1, SH4_PCIBCR1);
-
-	mcr = __raw_readl(SH7751_MCR);
-	mcr = (mcr & PCIMCR_MRSET_OFF) & PCIMCR_RFSH_OFF;
-	pci_write_reg(chan, mcr, SH4_PCIMCR);
-
-	pci_write_reg(chan, 0x0c000000, SH7751_PCICONF5);
-	pci_write_reg(chan, 0xd0000000, SH7751_PCICONF6);
-	pci_write_reg(chan, 0x0c000000, SH4_PCILAR0);
-	pci_write_reg(chan, 0x00000000, SH4_PCILAR1);
-
-	return 0;
-}
diff --git a/arch/sh/drivers/pci/fixups-r7780rp.c b/arch/sh/drivers/pci/fixups-r7780rp.c
deleted file mode 100644
index 3c9139c5955e6d..00000000000000
--- a/arch/sh/drivers/pci/fixups-r7780rp.c
+++ /dev/null
@@ -1,18 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/drivers/pci/fixups-r7780rp.c
- *
- * Highlander R7780RP-1 PCI fixups
- *
- * Copyright (C) 2003  Lineo uSolutions, Inc.
- * Copyright (C) 2004 - 2006  Paul Mundt
- */
-#include <linux/pci.h>
-#include <linux/io.h>
-#include <linux/sh_intc.h>
-#include "pci-sh4.h"
-
-int pcibios_map_platform_irq(const struct pci_dev *pdev, u8 slot, u8 pin)
-{
-	return evt2irq(0xa20) + slot;
-}
diff --git a/arch/sh/drivers/pci/fixups-rts7751r2d.c b/arch/sh/drivers/pci/fixups-rts7751r2d.c
deleted file mode 100644
index 3f0a6fe1610b61..00000000000000
--- a/arch/sh/drivers/pci/fixups-rts7751r2d.c
+++ /dev/null
@@ -1,64 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/drivers/pci/fixups-rts7751r2d.c
- *
- * RTS7751R2D / LBOXRE2 PCI fixups
- *
- * Copyright (C) 2003  Lineo uSolutions, Inc.
- * Copyright (C) 2004  Paul Mundt
- * Copyright (C) 2007  Nobuhiro Iwamatsu
- */
-#include <linux/pci.h>
-#include <mach/lboxre2.h>
-#include <mach/r2d.h>
-#include "pci-sh4.h"
-#include <generated/machtypes.h>
-
-#define PCIMCR_MRSET_OFF	0xBFFFFFFF
-#define PCIMCR_RFSH_OFF		0xFFFFFFFB
-
-static u8 rts7751r2d_irq_tab[] = {
-	IRQ_PCI_INTA,
-	IRQ_PCI_INTB,
-	IRQ_PCI_INTC,
-	IRQ_PCI_INTD,
-};
-
-static char lboxre2_irq_tab[] = {
-	IRQ_ETH0, IRQ_ETH1, IRQ_INTA, IRQ_INTD,
-};
-
-int pcibios_map_platform_irq(const struct pci_dev *pdev, u8 slot, u8 pin)
-{
-	if (mach_is_lboxre2())
-		return lboxre2_irq_tab[slot];
-	else
-		return rts7751r2d_irq_tab[slot];
-}
-
-int pci_fixup_pcic(struct pci_channel *chan)
-{
-	unsigned long bcr1, mcr;
-
-	bcr1 = __raw_readl(SH7751_BCR1);
-	bcr1 |= 0x40080000;	/* Enable Bit 19 BREQEN, set PCIC to slave */
-	pci_write_reg(chan, bcr1, SH4_PCIBCR1);
-
-	/* Enable all interrupts, so we known what to fix */
-	pci_write_reg(chan, 0x0000c3ff, SH4_PCIINTM);
-	pci_write_reg(chan, 0x0000380f, SH4_PCIAINTM);
-
-	pci_write_reg(chan, 0xfb900047, SH7751_PCICONF1);
-	pci_write_reg(chan, 0xab000001, SH7751_PCICONF4);
-
-	mcr = __raw_readl(SH7751_MCR);
-	mcr = (mcr & PCIMCR_MRSET_OFF) & PCIMCR_RFSH_OFF;
-	pci_write_reg(chan, mcr, SH4_PCIMCR);
-
-	pci_write_reg(chan, 0x0c000000, SH7751_PCICONF5);
-	pci_write_reg(chan, 0xd0000000, SH7751_PCICONF6);
-	pci_write_reg(chan, 0x0c000000, SH4_PCILAR0);
-	pci_write_reg(chan, 0x00000000, SH4_PCILAR1);
-
-	return 0;
-}
diff --git a/arch/sh/drivers/pci/fixups-sdk7780.c b/arch/sh/drivers/pci/fixups-sdk7780.c
deleted file mode 100644
index c306040485bd23..00000000000000
--- a/arch/sh/drivers/pci/fixups-sdk7780.c
+++ /dev/null
@@ -1,40 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/drivers/pci/fixups-sdk7780.c
- *
- * PCI fixups for the SDK7780SE03
- *
- * Copyright (C) 2003  Lineo uSolutions, Inc.
- * Copyright (C) 2004 - 2006  Paul Mundt
- * Copyright (C) 2006  Nobuhiro Iwamatsu
- */
-#include <linux/pci.h>
-#include <linux/io.h>
-#include <linux/sh_intc.h>
-#include "pci-sh4.h"
-
-#define IRQ_INTA	evt2irq(0xa20)
-#define IRQ_INTB	evt2irq(0xa40)
-#define IRQ_INTC	evt2irq(0xa60)
-#define IRQ_INTD	evt2irq(0xa80)
-
-/* IDSEL [16][17][18][19][20][21][22][23][24][25][26][27][28][29][30][31] */
-static char sdk7780_irq_tab[4][16] = {
-	/* INTA */
-	{ IRQ_INTA, IRQ_INTD, IRQ_INTC, IRQ_INTD, -1, -1, -1, -1, -1, -1,
-	  -1, -1, -1, -1, -1, -1 },
-	/* INTB */
-	{ IRQ_INTB, IRQ_INTA, -1, IRQ_INTA, -1, -1, -1, -1, -1, -1, -1, -1,
-	  -1, -1, -1, -1 },
-	/* INTC */
-	{ IRQ_INTC, IRQ_INTB, -1, IRQ_INTB, -1, -1, -1, -1, -1, -1, -1, -1,
-	  -1, -1, -1, -1 },
-	/* INTD */
-	{ IRQ_INTD, IRQ_INTC, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
-	  -1, -1, -1 },
-};
-
-int pcibios_map_platform_irq(const struct pci_dev *pdev, u8 slot, u8 pin)
-{
-       return sdk7780_irq_tab[pin-1][slot];
-}
diff --git a/arch/sh/drivers/pci/fixups-sdk7786.c b/arch/sh/drivers/pci/fixups-sdk7786.c
deleted file mode 100644
index 6972af7b4e93d5..00000000000000
--- a/arch/sh/drivers/pci/fixups-sdk7786.c
+++ /dev/null
@@ -1,64 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SDK7786 FPGA PCIe mux handling
- *
- * Copyright (C) 2010  Paul Mundt
- */
-#define pr_fmt(fmt) "PCI: " fmt
-
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/pci.h>
-#include <mach/fpga.h>
-
-/*
- * The SDK7786 FPGA supports mangling of most of the slots in some way or
- * another. Slots 3/4 are special in that only one can be supported at a
- * time, and both appear on port 3 to the PCI bus scan. Enabling slot 4
- * (the horizontal edge connector) will disable slot 3 entirely.
- *
- * Misconfigurations can be detected through the FPGA via the slot
- * resistors to determine card presence. Hotplug remains unsupported.
- */
-static unsigned int slot4en __initdata;
-
-char *__init pcibios_setup(char *str)
-{
-	if (strcmp(str, "slot4en") == 0) {
-		slot4en = 1;
-		return NULL;
-	}
-
-	return str;
-}
-
-static int __init sdk7786_pci_init(void)
-{
-	u16 data = fpga_read_reg(PCIECR);
-
-	/*
-	 * Enable slot #4 if it's been specified on the command line.
-	 *
-	 * Optionally reroute if slot #4 has a card present while slot #3
-	 * does not, regardless of command line value.
-	 *
-	 * Card presence is logically inverted.
-	 */
-	slot4en ?: (!(data & PCIECR_PRST4) && (data & PCIECR_PRST3));
-	if (slot4en) {
-		pr_info("Activating PCIe slot#4 (disabling slot#3)\n");
-
-		data &= ~PCIECR_PCIEMUX1;
-		fpga_write_reg(data, PCIECR);
-
-		/* Warn about forced rerouting if slot#3 is occupied */
-		if ((data & PCIECR_PRST3) == 0) {
-			pr_warn("Unreachable card detected in slot#3\n");
-			return -EBUSY;
-		}
-	} else
-		pr_info("PCIe slot#4 disabled\n");
-
-	return 0;
-}
-postcore_initcall(sdk7786_pci_init);
diff --git a/arch/sh/drivers/pci/fixups-se7751.c b/arch/sh/drivers/pci/fixups-se7751.c
deleted file mode 100644
index 608f6521ceffcd..00000000000000
--- a/arch/sh/drivers/pci/fixups-se7751.c
+++ /dev/null
@@ -1,113 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/pci.h>
-#include <linux/io.h>
-#include <linux/sh_intc.h>
-#include "pci-sh4.h"
-
-int pcibios_map_platform_irq(const struct pci_dev *, u8 slot, u8 pin)
-{
-        switch (slot) {
-        case 0: return evt2irq(0x3a0);
-        case 1: return evt2irq(0x3a0);	/* AMD Ethernet controller */
-        case 2: return -1;
-        case 3: return -1;
-        case 4: return -1;
-        default:
-                printk("PCI: Bad IRQ mapping request for slot %d\n", slot);
-                return -1;
-        }
-}
-
-#define PCIMCR_MRSET_OFF	0xBFFFFFFF
-#define PCIMCR_RFSH_OFF		0xFFFFFFFB
-
-/*
- * Only long word accesses of the PCIC's internal local registers and the
- * configuration registers from the CPU is supported.
- */
-#define PCIC_WRITE(x,v) writel((v), PCI_REG(x))
-#define PCIC_READ(x) readl(PCI_REG(x))
-
-/*
- * Description:  This function sets up and initializes the pcic, sets
- * up the BARS, maps the DRAM into the address space etc, etc.
- */
-int pci_fixup_pcic(struct pci_channel *chan)
-{
-	unsigned long bcr1, wcr1, wcr2, wcr3, mcr;
-	unsigned short bcr2;
-
-	/*
-	* Initialize the slave bus controller on the pcic.  The values used
-	* here should not be hardcoded, but they should be taken from the bsc
-	* on the processor, to make this function as generic as possible.
-	* (i.e. Another sbc may usr different SDRAM timing settings -- in order
-	* for the pcic to work, its settings need to be exactly the same.)
-	*/
-	bcr1 = (*(volatile unsigned long*)(SH7751_BCR1));
-	bcr2 = (*(volatile unsigned short*)(SH7751_BCR2));
-	wcr1 = (*(volatile unsigned long*)(SH7751_WCR1));
-	wcr2 = (*(volatile unsigned long*)(SH7751_WCR2));
-	wcr3 = (*(volatile unsigned long*)(SH7751_WCR3));
-	mcr = (*(volatile unsigned long*)(SH7751_MCR));
-
-	bcr1 = bcr1 | 0x00080000;  /* Enable Bit 19, BREQEN */
-	(*(volatile unsigned long*)(SH7751_BCR1)) = bcr1;
-
-	bcr1 = bcr1 | 0x40080000;  /* Enable Bit 19 BREQEN, set PCIC to slave */
-	PCIC_WRITE(SH7751_PCIBCR1, bcr1);	 /* PCIC BCR1 */
-	PCIC_WRITE(SH7751_PCIBCR2, bcr2);     /* PCIC BCR2 */
-	PCIC_WRITE(SH7751_PCIWCR1, wcr1);     /* PCIC WCR1 */
-	PCIC_WRITE(SH7751_PCIWCR2, wcr2);     /* PCIC WCR2 */
-	PCIC_WRITE(SH7751_PCIWCR3, wcr3);     /* PCIC WCR3 */
-	mcr = (mcr & PCIMCR_MRSET_OFF) & PCIMCR_RFSH_OFF;
-	PCIC_WRITE(SH7751_PCIMCR, mcr);      /* PCIC MCR */
-
-
-	/* Enable all interrupts, so we know what to fix */
-	PCIC_WRITE(SH7751_PCIINTM, 0x0000c3ff);
-	PCIC_WRITE(SH7751_PCIAINTM, 0x0000380f);
-
-	/* Set up standard PCI config registers */
-	PCIC_WRITE(SH7751_PCICONF1,	0xF39000C7); /* Bus Master, Mem & I/O access */
-	PCIC_WRITE(SH7751_PCICONF2,	0x00000000); /* PCI Class code & Revision ID */
-	PCIC_WRITE(SH7751_PCICONF4,	0xab000001); /* PCI I/O address (local regs) */
-	PCIC_WRITE(SH7751_PCICONF5,	0x0c000000); /* PCI MEM address (local RAM)  */
-	PCIC_WRITE(SH7751_PCICONF6,	0xd0000000); /* PCI MEM address (unused)     */
-	PCIC_WRITE(SH7751_PCICONF11, 0x35051054); /* PCI Subsystem ID & Vendor ID */
-	PCIC_WRITE(SH7751_PCILSR0, 0x03f00000);   /* MEM (full 64M exposed)       */
-	PCIC_WRITE(SH7751_PCILSR1, 0x00000000);   /* MEM (unused)                 */
-	PCIC_WRITE(SH7751_PCILAR0, 0x0c000000);   /* MEM (direct map from PCI)    */
-	PCIC_WRITE(SH7751_PCILAR1, 0x00000000);   /* MEM (unused)                 */
-
-	/* Now turn it on... */
-	PCIC_WRITE(SH7751_PCICR, 0xa5000001);
-
-	/*
-	* Set PCIMBR and PCIIOBR here, assuming a single window
-	* (16M MEM, 256K IO) is enough.  If a larger space is
-	* needed, the readx/writex and inx/outx functions will
-	* have to do more (e.g. setting registers for each call).
-	*/
-
-	/*
-	* Set the MBR so PCI address is one-to-one with window,
-	* meaning all calls go straight through... use BUG_ON to
-	* catch erroneous assumption.
-	*/
-	BUG_ON(chan->resources[1].start != SH7751_PCI_MEMORY_BASE);
-
-	PCIC_WRITE(SH7751_PCIMBR, chan->resources[1].start);
-
-	/* Set IOBR for window containing area specified in pci.h */
-	PCIC_WRITE(SH7751_PCIIOBR, (chan->resources[0].start & SH7751_PCIIOBR_MASK));
-
-	/* All done, may as well say so... */
-	printk("SH7751 PCI: Finished initialization of the PCI controller\n");
-
-	return 1;
-}
diff --git a/arch/sh/drivers/pci/fixups-sh03.c b/arch/sh/drivers/pci/fixups-sh03.c
deleted file mode 100644
index 7ec4a74ab12c45..00000000000000
--- a/arch/sh/drivers/pci/fixups-sh03.c
+++ /dev/null
@@ -1,33 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/pci.h>
-#include <linux/sh_intc.h>
-
-int pcibios_map_platform_irq(const struct pci_dev *dev, u8 slot, u8 pin)
-{
-	int irq;
-
-	if (dev->bus->number == 0) {
-		switch (slot) {
-		case 4: return evt2irq(0x2a0);	/* eth0       */
-		case 8: return evt2irq(0x2a0);	/* eth1       */
-		case 6: return evt2irq(0x240);	/* PCI bridge */
-		default:
-			printk(KERN_ERR "PCI: Bad IRQ mapping request "
-					"for slot %d\n", slot);
-			return evt2irq(0x240);
-		}
-	} else {
-		switch (pin) {
-		case 0:   irq =  evt2irq(0x240); break;
-		case 1:   irq =  evt2irq(0x240); break;
-		case 2:   irq =  evt2irq(0x240); break;
-		case 3:   irq =  evt2irq(0x240); break;
-		case 4:   irq =  evt2irq(0x240); break;
-		default:  irq = -1; break;
-		}
-	}
-	return irq;
-}
diff --git a/arch/sh/drivers/pci/fixups-snapgear.c b/arch/sh/drivers/pci/fixups-snapgear.c
deleted file mode 100644
index 317225c094137f..00000000000000
--- a/arch/sh/drivers/pci/fixups-snapgear.c
+++ /dev/null
@@ -1,37 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/drivers/pci/ops-snapgear.c
- *
- * Author:  David McCullough <davidm@snapgear.com>
- *
- * Ported to new API by Paul Mundt <lethal@linux-sh.org>
- *
- * Highly leveraged from pci-bigsur.c, written by Dustin McIntire.
- *
- * PCI initialization for the SnapGear boards
- */
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/init.h>
-#include <linux/pci.h>
-#include <linux/sh_intc.h>
-#include "pci-sh4.h"
-
-int pcibios_map_platform_irq(const struct pci_dev *pdev, u8 slot, u8 pin)
-{
-	int irq = -1;
-
-	switch (slot) {
-	case 8:  /* the PCI bridge */ break;
-	case 11: irq = evt2irq(0x300); break; /* USB    */
-	case 12: irq = evt2irq(0x360); break; /* PCMCIA */
-	case 13: irq = evt2irq(0x2a0); break; /* eth0   */
-	case 14: irq = evt2irq(0x300); break; /* eth1   */
-	case 15: irq = evt2irq(0x360); break; /* safenet (unused) */
-	}
-
-	printk("PCI: Mapping SnapGear IRQ for slot %d, pin %c to irq %d\n",
-	       slot, pin - 1 + 'A', irq);
-
-	return irq;
-}
diff --git a/arch/sh/drivers/pci/fixups-titan.c b/arch/sh/drivers/pci/fixups-titan.c
deleted file mode 100644
index b5bb65caa16d6f..00000000000000
--- a/arch/sh/drivers/pci/fixups-titan.c
+++ /dev/null
@@ -1,36 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/drivers/pci/ops-titan.c
- *
- * Ported to new API by Paul Mundt <lethal@linux-sh.org>
- *
- * Modified from ops-snapgear.c written by  David McCullough
- * Highly leveraged from pci-bigsur.c, written by Dustin McIntire.
- *
- * PCI initialization for the Titan boards
- */
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/init.h>
-#include <linux/pci.h>
-#include <linux/io.h>
-#include <mach/titan.h>
-#include "pci-sh4.h"
-
-static char titan_irq_tab[] = {
-	TITAN_IRQ_WAN,
-	TITAN_IRQ_LAN,
-	TITAN_IRQ_MPCIA,
-	TITAN_IRQ_MPCIB,
-	TITAN_IRQ_USB,
-};
-
-int pcibios_map_platform_irq(const struct pci_dev *pdev, u8 slot, u8 pin)
-{
-	int irq = titan_irq_tab[slot];
-
-	printk("PCI: Mapping TITAN IRQ for slot %d, pin %c to irq %d\n",
-		slot, pin - 1 + 'A', irq);
-
-	return irq;
-}
diff --git a/arch/sh/drivers/pci/ops-dreamcast.c b/arch/sh/drivers/pci/ops-dreamcast.c
deleted file mode 100644
index 517a8a9702f662..00000000000000
--- a/arch/sh/drivers/pci/ops-dreamcast.c
+++ /dev/null
@@ -1,79 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * PCI operations for the Sega Dreamcast
- *
- * Copyright (C) 2001, 2002  M. R. Brown
- * Copyright (C) 2002, 2003  Paul Mundt
- */
-
-#include <linux/sched.h>
-#include <linux/kernel.h>
-#include <linux/param.h>
-#include <linux/interrupt.h>
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/pci.h>
-#include <linux/module.h>
-#include <linux/io.h>
-#include <mach/pci.h>
-
-/*
- * The !gapspci_config_access case really shouldn't happen, ever, unless
- * someone implicitly messes around with the last devfn value.. otherwise we
- * only support a single device anyways, and if we didn't have a BBA, we
- * wouldn't make it terribly far through the PCI setup anyways.
- *
- * Also, we could very easily support both Type 0 and Type 1 configurations
- * here, but since it doesn't seem that there is any such implementation in
- * existence, we don't bother.
- *
- * I suppose if someone actually gets around to ripping the chip out of
- * the BBA and hanging some more devices off of it, then this might be
- * something to take into consideration. However, due to the cost of the BBA,
- * and the general lack of activity by DC hardware hackers, this doesn't seem
- * likely to happen anytime soon.
- */
-static int gapspci_config_access(unsigned char bus, unsigned int devfn)
-{
-	return (bus == 0) && (devfn == 0);
-}
-
-/*
- * We can also actually read and write in b/w/l sizes! Thankfully this part
- * was at least done right, and we don't have to do the stupid masking and
- * shifting that we do on the 7751! Small wonders never cease to amaze.
- */
-static int gapspci_read(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 *val)
-{
-	*val = 0xffffffff;
-
-	if (!gapspci_config_access(bus->number, devfn))
-		return PCIBIOS_DEVICE_NOT_FOUND;
-
-	switch (size) {
-	case 1: *val = inb(GAPSPCI_BBA_CONFIG+where); break;
-	case 2: *val = inw(GAPSPCI_BBA_CONFIG+where); break;
-	case 4: *val = inl(GAPSPCI_BBA_CONFIG+where); break;
-	}
-
-        return PCIBIOS_SUCCESSFUL;
-}
-
-static int gapspci_write(struct pci_bus *bus, unsigned int devfn, int where, int size, u32 val)
-{
-	if (!gapspci_config_access(bus->number, devfn))
-		return PCIBIOS_DEVICE_NOT_FOUND;
-
-	switch (size) {
-	case 1: outb(( u8)val, GAPSPCI_BBA_CONFIG+where); break;
-	case 2: outw((u16)val, GAPSPCI_BBA_CONFIG+where); break;
-	case 4: outl((u32)val, GAPSPCI_BBA_CONFIG+where); break;
-	}
-
-        return PCIBIOS_SUCCESSFUL;
-}
-
-struct pci_ops gapspci_pci_ops = {
-	.read	= gapspci_read,
-	.write	= gapspci_write,
-};
diff --git a/arch/sh/drivers/pci/ops-sh4.c b/arch/sh/drivers/pci/ops-sh4.c
deleted file mode 100644
index a205be3bfc4a67..00000000000000
--- a/arch/sh/drivers/pci/ops-sh4.c
+++ /dev/null
@@ -1,105 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Generic SH-4 / SH-4A PCIC operations (SH7751, SH7780).
- *
- * Copyright (C) 2002 - 2009  Paul Mundt
- */
-#include <linux/pci.h>
-#include <linux/io.h>
-#include <linux/spinlock.h>
-#include <asm/addrspace.h>
-#include "pci-sh4.h"
-
-/*
- * Direct access to PCI hardware...
- */
-#define CONFIG_CMD(bus, devfn, where) \
-	(0x80000000 | (bus->number << 16) | (devfn << 8) | (where & ~3))
-
-/*
- * Functions for accessing PCI configuration space with type 1 accesses
- */
-static int sh4_pci_read(struct pci_bus *bus, unsigned int devfn,
-			   int where, int size, u32 *val)
-{
-	struct pci_channel *chan = bus->sysdata;
-	unsigned long flags;
-	u32 data;
-
-	/*
-	 * PCIPDR may only be accessed as 32 bit words,
-	 * so we must do byte alignment by hand
-	 */
-	raw_spin_lock_irqsave(&pci_config_lock, flags);
-	pci_write_reg(chan, CONFIG_CMD(bus, devfn, where), SH4_PCIPAR);
-	data = pci_read_reg(chan, SH4_PCIPDR);
-	raw_spin_unlock_irqrestore(&pci_config_lock, flags);
-
-	switch (size) {
-	case 1:
-		*val = (data >> ((where & 3) << 3)) & 0xff;
-		break;
-	case 2:
-		*val = (data >> ((where & 2) << 3)) & 0xffff;
-		break;
-	case 4:
-		*val = data;
-		break;
-	default:
-		return PCIBIOS_FUNC_NOT_SUPPORTED;
-	}
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-/*
- * Since SH4 only does 32bit access we'll have to do a read,
- * mask,write operation.
- * We'll allow an odd byte offset, though it should be illegal.
- */
-static int sh4_pci_write(struct pci_bus *bus, unsigned int devfn,
-			 int where, int size, u32 val)
-{
-	struct pci_channel *chan = bus->sysdata;
-	unsigned long flags;
-	int shift;
-	u32 data;
-
-	raw_spin_lock_irqsave(&pci_config_lock, flags);
-	pci_write_reg(chan, CONFIG_CMD(bus, devfn, where), SH4_PCIPAR);
-	data = pci_read_reg(chan, SH4_PCIPDR);
-	raw_spin_unlock_irqrestore(&pci_config_lock, flags);
-
-	switch (size) {
-	case 1:
-		shift = (where & 3) << 3;
-		data &= ~(0xff << shift);
-		data |= ((val & 0xff) << shift);
-		break;
-	case 2:
-		shift = (where & 2) << 3;
-		data &= ~(0xffff << shift);
-		data |= ((val & 0xffff) << shift);
-		break;
-	case 4:
-		data = val;
-		break;
-	default:
-		return PCIBIOS_FUNC_NOT_SUPPORTED;
-	}
-
-	pci_write_reg(chan, data, SH4_PCIPDR);
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-struct pci_ops sh4_pci_ops = {
-	.read		= sh4_pci_read,
-	.write		= sh4_pci_write,
-};
-
-int __attribute__((weak)) pci_fixup_pcic(struct pci_channel *chan)
-{
-	/* Nothing to do. */
-	return 0;
-}
diff --git a/arch/sh/drivers/pci/ops-sh7786.c b/arch/sh/drivers/pci/ops-sh7786.c
deleted file mode 100644
index a10f9f4ebd7fe9..00000000000000
--- a/arch/sh/drivers/pci/ops-sh7786.c
+++ /dev/null
@@ -1,168 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Generic SH7786 PCI-Express operations.
- *
- *  Copyright (C) 2009 - 2010  Paul Mundt
- */
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/pci.h>
-#include <linux/io.h>
-#include <linux/spinlock.h>
-#include "pcie-sh7786.h"
-
-enum {
-	PCI_ACCESS_READ,
-	PCI_ACCESS_WRITE,
-};
-
-static int sh7786_pcie_config_access(unsigned char access_type,
-		struct pci_bus *bus, unsigned int devfn, int where, u32 *data)
-{
-	struct pci_channel *chan = bus->sysdata;
-	int dev, func, type, reg;
-
-	dev = PCI_SLOT(devfn);
-	func = PCI_FUNC(devfn);
-	type = !!bus->parent;
-	reg = where & ~3;
-
-	if (bus->number > 255 || dev > 31 || func > 7)
-		return PCIBIOS_FUNC_NOT_SUPPORTED;
-
-	/*
-	 * While each channel has its own memory-mapped extended config
-	 * space, it's generally only accessible when in endpoint mode.
-	 * When in root complex mode, the controller is unable to target
-	 * itself with either type 0 or type 1 accesses, and indeed, any
-	 * controller initiated target transfer to its own config space
-	 * result in a completer abort.
-	 *
-	 * Each channel effectively only supports a single device, but as
-	 * the same channel <-> device access works for any PCI_SLOT()
-	 * value, we cheat a bit here and bind the controller's config
-	 * space to devfn 0 in order to enable self-enumeration. In this
-	 * case the regular PAR/PDR path is sidelined and the mangled
-	 * config access itself is initiated as a SuperHyway transaction.
-	 */
-	if (pci_is_root_bus(bus)) {
-		if (dev == 0) {
-			if (access_type == PCI_ACCESS_READ)
-				*data = pci_read_reg(chan, PCI_REG(reg));
-			else
-				pci_write_reg(chan, *data, PCI_REG(reg));
-
-			return PCIBIOS_SUCCESSFUL;
-		} else if (dev > 1)
-			return PCIBIOS_DEVICE_NOT_FOUND;
-	}
-
-	/* Clear errors */
-	pci_write_reg(chan, pci_read_reg(chan, SH4A_PCIEERRFR), SH4A_PCIEERRFR);
-
-	/* Set the PIO address */
-	pci_write_reg(chan, (bus->number << 24) | (dev << 19) |
-				(func << 16) | reg, SH4A_PCIEPAR);
-
-	/* Enable the configuration access */
-	pci_write_reg(chan, (1 << 31) | (type << 8), SH4A_PCIEPCTLR);
-
-	/* Check for errors */
-	if (pci_read_reg(chan, SH4A_PCIEERRFR) & 0x10)
-		return PCIBIOS_DEVICE_NOT_FOUND;
-
-	/* Check for master and target aborts */
-	if (pci_read_reg(chan, SH4A_PCIEPCICONF1) & ((1 << 29) | (1 << 28)))
-		return PCIBIOS_DEVICE_NOT_FOUND;
-
-	if (access_type == PCI_ACCESS_READ)
-		*data = pci_read_reg(chan, SH4A_PCIEPDR);
-	else
-		pci_write_reg(chan, *data, SH4A_PCIEPDR);
-
-	/* Disable the configuration access */
-	pci_write_reg(chan, 0, SH4A_PCIEPCTLR);
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static int sh7786_pcie_read(struct pci_bus *bus, unsigned int devfn,
-			    int where, int size, u32 *val)
-{
-	unsigned long flags;
-	int ret;
-	u32 data;
-
-        if ((size == 2) && (where & 1))
-		return PCIBIOS_BAD_REGISTER_NUMBER;
-	else if ((size == 4) && (where & 3))
-		return PCIBIOS_BAD_REGISTER_NUMBER;
-
-	raw_spin_lock_irqsave(&pci_config_lock, flags);
-	ret = sh7786_pcie_config_access(PCI_ACCESS_READ, bus,
-					devfn, where, &data);
-	if (ret != PCIBIOS_SUCCESSFUL) {
-		*val = 0xffffffff;
-		goto out;
-	}
-
-	if (size == 1)
-		*val = (data >> ((where & 3) << 3)) & 0xff;
-	else if (size == 2)
-		*val = (data >> ((where & 2) << 3)) & 0xffff;
-	else
-		*val = data;
-
-	dev_dbg(&bus->dev, "pcie-config-read: bus=%3d devfn=0x%04x "
-		"where=0x%04x size=%d val=0x%08lx\n", bus->number,
-		devfn, where, size, (unsigned long)*val);
-
-out:
-	raw_spin_unlock_irqrestore(&pci_config_lock, flags);
-	return ret;
-}
-
-static int sh7786_pcie_write(struct pci_bus *bus, unsigned int devfn,
-			     int where, int size, u32 val)
-{
-	unsigned long flags;
-	int shift, ret;
-	u32 data;
-
-        if ((size == 2) && (where & 1))
-		return PCIBIOS_BAD_REGISTER_NUMBER;
-	else if ((size == 4) && (where & 3))
-		return PCIBIOS_BAD_REGISTER_NUMBER;
-
-	raw_spin_lock_irqsave(&pci_config_lock, flags);
-	ret = sh7786_pcie_config_access(PCI_ACCESS_READ, bus,
-					devfn, where, &data);
-	if (ret != PCIBIOS_SUCCESSFUL)
-		goto out;
-
-	dev_dbg(&bus->dev, "pcie-config-write: bus=%3d devfn=0x%04x "
-		"where=0x%04x size=%d val=%08lx\n", bus->number,
-		devfn, where, size, (unsigned long)val);
-
-	if (size == 1) {
-		shift = (where & 3) << 3;
-		data &= ~(0xff << shift);
-		data |= ((val & 0xff) << shift);
-	} else if (size == 2) {
-		shift = (where & 2) << 3;
-		data &= ~(0xffff << shift);
-		data |= ((val & 0xffff) << shift);
-	} else
-		data = val;
-
-	ret = sh7786_pcie_config_access(PCI_ACCESS_WRITE, bus,
-					devfn, where, &data);
-out:
-	raw_spin_unlock_irqrestore(&pci_config_lock, flags);
-	return ret;
-}
-
-struct pci_ops sh7786_pci_ops = {
-	.read	= sh7786_pcie_read,
-	.write	= sh7786_pcie_write,
-};
diff --git a/arch/sh/drivers/pci/pci-dreamcast.c b/arch/sh/drivers/pci/pci-dreamcast.c
deleted file mode 100644
index 4cff2a8107bf06..00000000000000
--- a/arch/sh/drivers/pci/pci-dreamcast.c
+++ /dev/null
@@ -1,97 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * PCI support for the Sega Dreamcast
- *
- * Copyright (C) 2001, 2002  M. R. Brown
- * Copyright (C) 2002, 2003  Paul Mundt
- *
- * This file originally bore the message (with enclosed-$):
- *	Id: pci.c,v 1.3 2003/05/04 19:29:46 lethal Exp
- *	Dreamcast PCI: Supports SEGA Broadband Adaptor only.
- */
-
-#include <linux/sched.h>
-#include <linux/kernel.h>
-#include <linux/param.h>
-#include <linux/interrupt.h>
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/pci.h>
-#include <linux/module.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <mach/pci.h>
-
-static struct resource gapspci_resources[] = {
-	{
-		.name	= "GAPSPCI IO",
-		.start	= GAPSPCI_BBA_CONFIG,
-		.end	= GAPSPCI_BBA_CONFIG + GAPSPCI_BBA_CONFIG_SIZE - 1,
-		.flags	= IORESOURCE_IO,
-	},  {
-		.name	= "GAPSPCI mem",
-		.start	= GAPSPCI_DMA_BASE,
-		.end	= GAPSPCI_DMA_BASE + GAPSPCI_DMA_SIZE - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct pci_channel dreamcast_pci_controller = {
-	.pci_ops	= &gapspci_pci_ops,
-	.resources	= gapspci_resources,
-	.nr_resources	= ARRAY_SIZE(gapspci_resources),
-	.io_offset	= 0x00000000,
-	.mem_offset	= 0x00000000,
-};
-
-/*
- * gapspci init
- */
-
-static int __init gapspci_init(void)
-{
-	char idbuf[16];
-	int i;
-
-	/*
-	 * FIXME: All of this wants documenting to some degree,
-	 * even some basic register definitions would be nice.
-	 *
-	 * I haven't seen anything this ugly since.. maple.
-	 */
-
-	for (i=0; i<16; i++)
-		idbuf[i] = inb(GAPSPCI_REGS+i);
-
-	if (strncmp(idbuf, "GAPSPCI_BRIDGE_2", 16))
-		return -ENODEV;
-
-	outl(0x5a14a501, GAPSPCI_REGS+0x18);
-
-	for (i=0; i<1000000; i++)
-		cpu_relax();
-
-	if (inl(GAPSPCI_REGS+0x18) != 1)
-		return -EINVAL;
-
-	outl(0x01000000, GAPSPCI_REGS+0x20);
-	outl(0x01000000, GAPSPCI_REGS+0x24);
-
-	outl(GAPSPCI_DMA_BASE, GAPSPCI_REGS+0x28);
-	outl(GAPSPCI_DMA_BASE+GAPSPCI_DMA_SIZE, GAPSPCI_REGS+0x2c);
-
-	outl(1, GAPSPCI_REGS+0x14);
-	outl(1, GAPSPCI_REGS+0x34);
-
-	/* Setting Broadband Adapter */
-	outw(0xf900, GAPSPCI_BBA_CONFIG+0x06);
-	outl(0x00000000, GAPSPCI_BBA_CONFIG+0x30);
-	outb(0x00, GAPSPCI_BBA_CONFIG+0x3c);
-	outb(0xf0, GAPSPCI_BBA_CONFIG+0x0d);
-	outw(0x0006, GAPSPCI_BBA_CONFIG+0x04);
-	outl(0x00002001, GAPSPCI_BBA_CONFIG+0x10);
-	outl(0x01000000, GAPSPCI_BBA_CONFIG+0x14);
-
-	return register_pci_controller(&dreamcast_pci_controller);
-}
-arch_initcall(gapspci_init);
diff --git a/arch/sh/drivers/pci/pci-sh4.h b/arch/sh/drivers/pci/pci-sh4.h
deleted file mode 100644
index 1543c50b65031c..00000000000000
--- a/arch/sh/drivers/pci/pci-sh4.h
+++ /dev/null
@@ -1,182 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __PCI_SH4_H
-#define __PCI_SH4_H
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7780) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7785) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7763)
-#include "pci-sh7780.h"
-#else
-#include "pci-sh7751.h"
-#endif
-
-#include <asm/io.h>
-
-#define SH4_PCICR		0x100		/* PCI Control Register */
-  #define SH4_PCICR_PREFIX	  0xA5000000	/* CR prefix for write */
-  #define SH4_PCICR_FTO		  0x00000400	/* TRDY/IRDY Enable */
-  #define SH4_PCICR_TRSB	  0x00000200	/* Target Read Single */
-  #define SH4_PCICR_BSWP	  0x00000100	/* Target Byte Swap */
-  #define SH4_PCICR_PLUP	  0x00000080	/* Enable PCI Pullup */
-  #define SH4_PCICR_ARBM	  0x00000040	/* PCI Arbitration Mode */
-  #define SH4_PCICR_MD		  0x00000030	/* MD9 and MD10 status */
-  #define SH4_PCICR_SERR	  0x00000008	/* SERR output assert */
-  #define SH4_PCICR_INTA	  0x00000004	/* INTA output assert */
-  #define SH4_PCICR_PRST	  0x00000002	/* PCI Reset Assert */
-  #define SH4_PCICR_CFIN	  0x00000001	/* Central Fun. Init Done */
-#define SH4_PCILSR0		0x104		/* PCI Local Space Register0 */
-#define SH4_PCILSR1		0x108		/* PCI Local Space Register1 */
-#define SH4_PCILAR0		0x10C		/* PCI Local Addr Register1 */
-#define SH4_PCILAR1		0x110		/* PCI Local Addr Register1 */
-#define SH4_PCIINT		0x114		/* PCI Interrupt Register */
-  #define SH4_PCIINT_MLCK	  0x00008000	/* Master Lock Error */
-  #define SH4_PCIINT_TABT	  0x00004000	/* Target Abort Error */
-  #define SH4_PCIINT_TRET	  0x00000200	/* Target Retry Error */
-  #define SH4_PCIINT_MFDE	  0x00000100	/* Master Func. Disable Error */
-  #define SH4_PCIINT_PRTY	  0x00000080	/* Address Parity Error */
-  #define SH4_PCIINT_SERR	  0x00000040	/* SERR Detection Error */
-  #define SH4_PCIINT_TWDP	  0x00000020	/* Tgt. Write Parity Error */
-  #define SH4_PCIINT_TRDP	  0x00000010	/* Tgt. Read Parity Err Det. */
-  #define SH4_PCIINT_MTABT	  0x00000008	/* Master-Tgt. Abort Error */
-  #define SH4_PCIINT_MMABT	  0x00000004	/* Master-Master Abort Error */
-  #define SH4_PCIINT_MWPD	  0x00000002	/* Master Write PERR Detect */
-  #define SH4_PCIINT_MRPD	  0x00000001	/* Master Read PERR Detect */
-#define SH4_PCIINTM		0x118		/* PCI Interrupt Mask */
-  #define SH4_PCIINTM_TTADIM	  BIT(14)	/* Target-target abort interrupt */
-  #define SH4_PCIINTM_TMTOIM	  BIT(9)	/* Target retry timeout */
-  #define SH4_PCIINTM_MDEIM	  BIT(8)	/* Master function disable error */
-  #define SH4_PCIINTM_APEDIM	  BIT(7)	/* Address parity error detection */
-  #define SH4_PCIINTM_SDIM	  BIT(6)	/* SERR detection */
-  #define SH4_PCIINTM_DPEITWM	  BIT(5)	/* Data parity error for target write */
-  #define SH4_PCIINTM_PEDITRM	  BIT(4)	/* PERR detection for target read */
-  #define SH4_PCIINTM_TADIMM	  BIT(3)	/* Target abort for master */
-  #define SH4_PCIINTM_MADIMM	  BIT(2)	/* Master abort for master */
-  #define SH4_PCIINTM_MWPDIM	  BIT(1)	/* Master write data parity error */
-  #define SH4_PCIINTM_MRDPEIM	  BIT(0)	/* Master read data parity error */
-#define SH4_PCIALR		0x11C		/* Error Address Register */
-#define SH4_PCICLR		0x120		/* Error Command/Data */
-  #define SH4_PCICLR_MPIO	  0x80000000
-  #define SH4_PCICLR_MDMA0	  0x40000000	/* DMA0 Transfer Error */
-  #define SH4_PCICLR_MDMA1	  0x20000000	/* DMA1 Transfer Error */
-  #define SH4_PCICLR_MDMA2	  0x10000000	/* DMA2 Transfer Error */
-  #define SH4_PCICLR_MDMA3	  0x08000000	/* DMA3 Transfer Error */
-  #define SH4_PCICLR_TGT	  0x04000000	/* Target Transfer Error */
-  #define SH4_PCICLR_CMDL	  0x0000000F	/* PCI Command at Error */
-#define SH4_PCIAINT		0x130		/* Arbiter Interrupt Register */
-  #define SH4_PCIAINT_MBKN	  0x00002000	/* Master Broken Interrupt */
-  #define SH4_PCIAINT_TBTO	  0x00001000	/* Target Bus Time Out */
-  #define SH4_PCIAINT_MBTO	  0x00000800	/* Master Bus Time Out */
-  #define SH4_PCIAINT_TABT	  0x00000008	/* Target Abort */
-  #define SH4_PCIAINT_MABT	  0x00000004	/* Master Abort */
-  #define SH4_PCIAINT_RDPE	  0x00000002	/* Read Data Parity Error */
-  #define SH4_PCIAINT_WDPE	  0x00000001	/* Write Data Parity Error */
-#define SH4_PCIAINTM            0x134		/* Arbiter Int. Mask Register */
-#define SH4_PCIBMLR		0x138		/* Error Bus Master Register */
-  #define SH4_PCIBMLR_REQ4	  0x00000010	/* REQ4 bus master at error */
-  #define SH4_PCIBMLR_REQ3	  0x00000008	/* REQ3 bus master at error */
-  #define SH4_PCIBMLR_REQ2	  0x00000004	/* REQ2 bus master at error */
-  #define SH4_PCIBMLR_REQ1	  0x00000002	/* REQ1 bus master at error */
-  #define SH4_PCIBMLR_REQ0	  0x00000001	/* REQ0 bus master at error */
-#define SH4_PCIDMABT		0x140		/* DMA Transfer Arb. Register */
-  #define SH4_PCIDMABT_RRBN	  0x00000001	/* DMA Arbitor Round-Robin */
-#define SH4_PCIDPA0		0x180		/* DMA0 Transfer Addr. */
-#define SH4_PCIDLA0		0x184		/* DMA0 Local Addr. */
-#define SH4_PCIDTC0		0x188		/* DMA0 Transfer Cnt. */
-#define SH4_PCIDCR0		0x18C		/* DMA0 Control Register */
-  #define SH4_PCIDCR_ALGN	  0x00000600	/* DMA Alignment Mode */
-  #define SH4_PCIDCR_MAST	  0x00000100	/* DMA Termination Type */
-  #define SH4_PCIDCR_INTM	  0x00000080	/* DMA Interrupt Done Mask*/
-  #define SH4_PCIDCR_INTS	  0x00000040	/* DMA Interrupt Done Status */
-  #define SH4_PCIDCR_LHLD	  0x00000020	/* Local Address Control */
-  #define SH4_PCIDCR_PHLD	  0x00000010	/* PCI Address Control*/
-  #define SH4_PCIDCR_IOSEL	  0x00000008	/* PCI Address Space Type */
-  #define SH4_PCIDCR_DIR	  0x00000004	/* DMA Transfer Direction */
-  #define SH4_PCIDCR_STOP	  0x00000002	/* Force DMA Stop */
-  #define SH4_PCIDCR_STRT	  0x00000001	/* DMA Start */
-#define SH4_PCIDPA1		0x190		/* DMA1 Transfer Addr. */
-#define SH4_PCIDLA1		0x194		/* DMA1 Local Addr. */
-#define SH4_PCIDTC1		0x198		/* DMA1 Transfer Cnt. */
-#define SH4_PCIDCR1		0x19C		/* DMA1 Control Register */
-#define SH4_PCIDPA2		0x1A0		/* DMA2 Transfer Addr. */
-#define SH4_PCIDLA2		0x1A4		/* DMA2 Local Addr. */
-#define SH4_PCIDTC2		0x1A8		/* DMA2 Transfer Cnt. */
-#define SH4_PCIDCR2		0x1AC		/* DMA2 Control Register */
-#define SH4_PCIDPA3		0x1B0		/* DMA3 Transfer Addr. */
-#define SH4_PCIDLA3		0x1B4		/* DMA3 Local Addr. */
-#define SH4_PCIDTC3		0x1B8		/* DMA3 Transfer Cnt. */
-#define SH4_PCIDCR3		0x1BC		/* DMA3 Control Register */
-#define SH4_PCIPAR		0x1C0		/* PIO Address Register */
-  #define SH4_PCIPAR_CFGEN	  0x80000000	/* Configuration Enable */
-  #define SH4_PCIPAR_BUSNO	  0x00FF0000	/* Config. Bus Number */
-  #define SH4_PCIPAR_DEVNO	  0x0000FF00	/* Config. Device Number */
-  #define SH4_PCIPAR_REGAD	  0x000000FC	/* Register Address Number */
-#define SH4_PCIMBR		0x1C4		/* Memory Base Address */
-  #define SH4_PCIMBR_MASK	  0xFF000000	/* Memory Space Mask */
-  #define SH4_PCIMBR_LOCK	  0x00000001	/* Lock Memory Space */
-#define SH4_PCIIOBR		0x1C8		/* I/O Base Address Register */
-  #define SH4_PCIIOBR_MASK	  0xFFFC0000	/* IO Space Mask */
-  #define SH4_PCIIOBR_LOCK	  0x00000001	/* Lock IO Space */
-#define SH4_PCIPINT		0x1CC		/* Power Mgmnt Int. Register */
-  #define SH4_PCIPINT_D3	  0x00000002	/* D3 Pwr Mgmt. Interrupt */
-  #define SH4_PCIPINT_D0	  0x00000001	/* D0 Pwr Mgmt. Interrupt */
-#define SH4_PCIPINTM		0x1D0		/* Power Mgmnt Mask Register */
-#define SH4_PCICLKR		0x1D4		/* Clock Ctrl. Register */
-  #define SH4_PCICLKR_PCSTP	  0x00000002	/* PCI Clock Stop */
-  #define SH4_PCICLKR_BCSTP	  0x00000001	/* BCLK Clock Stop */
-/* For definitions of BCR, MCR see ... */
-#define SH4_PCIBCR1		0x1E0		/* Memory BCR1 Register */
-  #define SH4_PCIMBR0		SH4_PCIBCR1
-#define SH4_PCIBCR2		0x1E4		/* Memory BCR2 Register */
-  #define SH4_PCIMBMR0		SH4_PCIBCR2
-#define SH4_PCIWCR1		0x1E8		/* Wait Control 1 Register */
-#define SH4_PCIWCR2		0x1EC		/* Wait Control 2 Register */
-#define SH4_PCIWCR3		0x1F0		/* Wait Control 3 Register */
-  #define SH4_PCIMBR2		SH4_PCIWCR3
-#define SH4_PCIMCR		0x1F4		/* Memory Control Register */
-#define SH4_PCIBCR3		0x1f8		/* Memory BCR3 Register */
-#define SH4_PCIPCTR             0x200		/* Port Control Register */
-  #define SH4_PCIPCTR_P2EN	  0x000400000	/* Port 2 Enable */
-  #define SH4_PCIPCTR_P1EN	  0x000200000	/* Port 1 Enable */
-  #define SH4_PCIPCTR_P0EN	  0x000100000	/* Port 0 Enable */
-  #define SH4_PCIPCTR_P2UP	  0x000000020	/* Port2 Pull Up Enable */
-  #define SH4_PCIPCTR_P2IO	  0x000000010	/* Port2 Output Enable */
-  #define SH4_PCIPCTR_P1UP	  0x000000008	/* Port1 Pull Up Enable */
-  #define SH4_PCIPCTR_P1IO	  0x000000004	/* Port1 Output Enable */
-  #define SH4_PCIPCTR_P0UP	  0x000000002	/* Port0 Pull Up Enable */
-  #define SH4_PCIPCTR_P0IO	  0x000000001	/* Port0 Output Enable */
-#define SH4_PCIPDTR		0x204		/* Port Data Register */
-  #define SH4_PCIPDTR_PB5	  0x000000020	/* Port 5 Enable */
-  #define SH4_PCIPDTR_PB4	  0x000000010	/* Port 4 Enable */
-  #define SH4_PCIPDTR_PB3	  0x000000008	/* Port 3 Enable */
-  #define SH4_PCIPDTR_PB2	  0x000000004	/* Port 2 Enable */
-  #define SH4_PCIPDTR_PB1	  0x000000002	/* Port 1 Enable */
-  #define SH4_PCIPDTR_PB0	  0x000000001	/* Port 0 Enable */
-#define SH4_PCIPDR		0x220		/* Port IO Data Register */
-
-/* arch/sh/kernel/drivers/pci/ops-sh4.c */
-extern struct pci_ops sh4_pci_ops;
-int pci_fixup_pcic(struct pci_channel *chan);
-
-struct sh4_pci_address_space {
-	unsigned long base;
-	unsigned long size;
-};
-
-struct sh4_pci_address_map {
-	struct sh4_pci_address_space window0;
-	struct sh4_pci_address_space window1;
-};
-
-static inline void pci_write_reg(struct pci_channel *chan,
-				 unsigned long val, unsigned long reg)
-{
-	__raw_writel(val, chan->reg_base + reg);
-}
-
-static inline unsigned long pci_read_reg(struct pci_channel *chan,
-					 unsigned long reg)
-{
-	return __raw_readl(chan->reg_base + reg);
-}
-
-#endif /* __PCI_SH4_H */
diff --git a/arch/sh/drivers/pci/pci-sh7751.c b/arch/sh/drivers/pci/pci-sh7751.c
deleted file mode 100644
index 11ed21c2e9bb10..00000000000000
--- a/arch/sh/drivers/pci/pci-sh7751.c
+++ /dev/null
@@ -1,179 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Low-Level PCI Support for the SH7751
- *
- *  Copyright (C) 2003 - 2009  Paul Mundt
- *  Copyright (C) 2001  Dustin McIntire
- *
- *  With cleanup by Paul van Gool <pvangool@mimotech.com>, 2003.
- */
-#include <linux/init.h>
-#include <linux/pci.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/io.h>
-#include "pci-sh4.h"
-#include <asm/addrspace.h>
-#include <linux/sizes.h>
-
-static int __init __area_sdram_check(struct pci_channel *chan,
-				     unsigned int area)
-{
-	unsigned long word;
-
-	word = __raw_readl(SH7751_BCR1);
-	/* check BCR for SDRAM in area */
-	if (((word >> area) & 1) == 0) {
-		printk("PCI: Area %d is not configured for SDRAM. BCR1=0x%lx\n",
-		       area, word);
-		return 0;
-	}
-	pci_write_reg(chan, word, SH4_PCIBCR1);
-
-	word = __raw_readw(SH7751_BCR2);
-	/* check BCR2 for 32bit SDRAM interface*/
-	if (((word >> (area << 1)) & 0x3) != 0x3) {
-		printk("PCI: Area %d is not 32 bit SDRAM. BCR2=0x%lx\n",
-		       area, word);
-		return 0;
-	}
-	pci_write_reg(chan, word, SH4_PCIBCR2);
-
-	return 1;
-}
-
-static struct resource sh7751_pci_resources[] = {
-	{
-		.name	= "SH7751_IO",
-		.start	= 0x1000,
-		.end	= SZ_4M - 1,
-		.flags	= IORESOURCE_IO
-	}, {
-		.name	= "SH7751_mem",
-		.start	= SH7751_PCI_MEMORY_BASE,
-		.end	= SH7751_PCI_MEMORY_BASE + SH7751_PCI_MEM_SIZE - 1,
-		.flags	= IORESOURCE_MEM
-	},
-};
-
-static struct pci_channel sh7751_pci_controller = {
-	.pci_ops	= &sh4_pci_ops,
-	.resources	= sh7751_pci_resources,
-	.nr_resources	= ARRAY_SIZE(sh7751_pci_resources),
-	.mem_offset	= 0x00000000,
-	.io_offset	= 0x00000000,
-	.io_map_base	= SH7751_PCI_IO_BASE,
-};
-
-static struct sh4_pci_address_map sh7751_pci_map = {
-	.window0	= {
-		.base	= SH7751_CS3_BASE_ADDR,
-		.size	= 0x04000000,
-	},
-};
-
-static int __init sh7751_pci_init(void)
-{
-	struct pci_channel *chan = &sh7751_pci_controller;
-	unsigned int id;
-	u32 word, reg;
-
-	printk(KERN_NOTICE "PCI: Starting initialization.\n");
-
-	chan->reg_base = 0xfe200000;
-
-	/* check for SH7751/SH7751R hardware */
-	id = pci_read_reg(chan, SH7751_PCICONF0);
-	if (id != ((SH7751_DEVICE_ID << 16) | SH7751_VENDOR_ID) &&
-	    id != ((SH7751R_DEVICE_ID << 16) | SH7751_VENDOR_ID)) {
-		pr_debug("PCI: This is not an SH7751(R) (%x)\n", id);
-		return -ENODEV;
-	}
-
-	/* Set the BCR's to enable PCI access */
-	reg = __raw_readl(SH7751_BCR1);
-	reg |= 0x80000;
-	__raw_writel(reg, SH7751_BCR1);
-
-	/* Turn the clocks back on (not done in reset)*/
-	pci_write_reg(chan, 0, SH4_PCICLKR);
-	/* Clear Powerdown IRQ's (not done in reset) */
-	word = SH4_PCIPINT_D3 | SH4_PCIPINT_D0;
-	pci_write_reg(chan, word, SH4_PCIPINT);
-
-	/* set the command/status bits to:
-	 * Wait Cycle Control + Parity Enable + Bus Master +
-	 * Mem space enable
-	 */
-	word = SH7751_PCICONF1_WCC | SH7751_PCICONF1_PER |
-	       SH7751_PCICONF1_BUM | SH7751_PCICONF1_MES;
-	pci_write_reg(chan, word, SH7751_PCICONF1);
-
-	/* define this host as the host bridge */
-	word = PCI_BASE_CLASS_BRIDGE << 24;
-	pci_write_reg(chan, word, SH7751_PCICONF2);
-
-	/* Set IO and Mem windows to local address
-	 * Make PCI and local address the same for easy 1 to 1 mapping
-	 */
-	word = sh7751_pci_map.window0.size - 1;
-	pci_write_reg(chan, word, SH4_PCILSR0);
-	/* Set the values on window 0 PCI config registers */
-	word = P2SEGADDR(sh7751_pci_map.window0.base);
-	pci_write_reg(chan, word, SH4_PCILAR0);
-	pci_write_reg(chan, word, SH7751_PCICONF5);
-
-	/* Set the local 16MB PCI memory space window to
-	 * the lowest PCI mapped address
-	 */
-	word = chan->resources[1].start & SH4_PCIMBR_MASK;
-	pr_debug("PCI: Setting upper bits of Memory window to 0x%x\n", word);
-	pci_write_reg(chan, word , SH4_PCIMBR);
-
-	/* Make sure the MSB's of IO window are set to access PCI space
-	 * correctly */
-	word = chan->resources[0].start & SH4_PCIIOBR_MASK;
-	pr_debug("PCI: Setting upper bits of IO window to 0x%x\n", word);
-	pci_write_reg(chan, word, SH4_PCIIOBR);
-
-	/* Set PCI WCRx, BCRx's, copy from BSC locations */
-
-	/* check BCR for SDRAM in specified area */
-	switch (sh7751_pci_map.window0.base) {
-	case SH7751_CS0_BASE_ADDR: word = __area_sdram_check(chan, 0); break;
-	case SH7751_CS1_BASE_ADDR: word = __area_sdram_check(chan, 1); break;
-	case SH7751_CS2_BASE_ADDR: word = __area_sdram_check(chan, 2); break;
-	case SH7751_CS3_BASE_ADDR: word = __area_sdram_check(chan, 3); break;
-	case SH7751_CS4_BASE_ADDR: word = __area_sdram_check(chan, 4); break;
-	case SH7751_CS5_BASE_ADDR: word = __area_sdram_check(chan, 5); break;
-	case SH7751_CS6_BASE_ADDR: word = __area_sdram_check(chan, 6); break;
-	}
-
-	if (!word)
-		return -1;
-
-	/* configure the wait control registers */
-	word = __raw_readl(SH7751_WCR1);
-	pci_write_reg(chan, word, SH4_PCIWCR1);
-	word = __raw_readl(SH7751_WCR2);
-	pci_write_reg(chan, word, SH4_PCIWCR2);
-	word = __raw_readl(SH7751_WCR3);
-	pci_write_reg(chan, word, SH4_PCIWCR3);
-	word = __raw_readl(SH7751_MCR);
-	pci_write_reg(chan, word, SH4_PCIMCR);
-
-	/* NOTE: I'm ignoring the PCI error IRQs for now..
-	 * TODO: add support for the internal error interrupts and
-	 * DMA interrupts...
-	 */
-
-	pci_fixup_pcic(chan);
-
-	/* SH7751 init done, set central function init complete */
-	/* use round robin mode to stop a device starving/overruning */
-	word = SH4_PCICR_PREFIX | SH4_PCICR_CFIN | SH4_PCICR_ARBM;
-	pci_write_reg(chan, word, SH4_PCICR);
-
-	return register_pci_controller(chan);
-}
-arch_initcall(sh7751_pci_init);
diff --git a/arch/sh/drivers/pci/pci-sh7751.h b/arch/sh/drivers/pci/pci-sh7751.h
deleted file mode 100644
index d1951e50effc8b..00000000000000
--- a/arch/sh/drivers/pci/pci-sh7751.h
+++ /dev/null
@@ -1,126 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- *	Low-Level PCI Support for SH7751 targets
- *
- *  Dustin McIntire (dustin@sensoria.com) (c) 2001
- *  Paul Mundt (lethal@linux-sh.org) (c) 2003
- */
-
-#ifndef _PCI_SH7751_H_
-#define _PCI_SH7751_H_
-
-/* Platform Specific Values */
-#define SH7751_VENDOR_ID             0x1054
-#define SH7751_DEVICE_ID             0x3505
-#define SH7751R_DEVICE_ID            0x350e
-
-/* SH7751 Specific Values */
-#define SH7751_PCI_CONFIG_BASE	     0xFD000000  /* Config space base addr */
-#define SH7751_PCI_CONFIG_SIZE       0x1000000   /* Config space size */
-#define SH7751_PCI_MEMORY_BASE	     0xFD000000  /* Memory space base addr */
-#define SH7751_PCI_MEM_SIZE          0x01000000  /* Size of Memory window */
-#define SH7751_PCI_IO_BASE           0xFE240000  /* IO space base address */
-#define SH7751_PCI_IO_SIZE           0x40000     /* Size of IO window */
-
-#define SH7751_PCIREG_BASE           0xFE200000  /* PCI regs base address */
-
-#define SH7751_PCICONF0            0x0           /* PCI Config Reg 0 */
-  #define SH7751_PCICONF0_DEVID      0xFFFF0000  /* Device ID */
-  #define SH7751_PCICONF0_VNDID      0x0000FFFF  /* Vendor ID */
-#define SH7751_PCICONF1            0x4           /* PCI Config Reg 1 */
-  #define SH7751_PCICONF1_DPE        0x80000000  /* Data Parity Error */
-  #define SH7751_PCICONF1_SSE        0x40000000  /* System Error Status */
-  #define SH7751_PCICONF1_RMA        0x20000000  /* Master Abort */
-  #define SH7751_PCICONF1_RTA        0x10000000  /* Target Abort Rx Status */
-  #define SH7751_PCICONF1_STA        0x08000000  /* Target Abort Exec Status */
-  #define SH7751_PCICONF1_DEV        0x06000000  /* Timing Status */
-  #define SH7751_PCICONF1_DPD        0x01000000  /* Data Parity Status */
-  #define SH7751_PCICONF1_FBBC       0x00800000  /* Back 2 Back Status */
-  #define SH7751_PCICONF1_UDF        0x00400000  /* User Defined Status */
-  #define SH7751_PCICONF1_66M        0x00200000  /* 66Mhz Operation Status */
-  #define SH7751_PCICONF1_PM         0x00100000  /* Power Management Status */
-  #define SH7751_PCICONF1_PBBE       0x00000200  /* Back 2 Back Control */
-  #define SH7751_PCICONF1_SER        0x00000100  /* SERR Output Control */
-  #define SH7751_PCICONF1_WCC        0x00000080  /* Wait Cycle Control */
-  #define SH7751_PCICONF1_PER        0x00000040  /* Parity Error Response */
-  #define SH7751_PCICONF1_VPS        0x00000020  /* VGA Pallet Snoop */
-  #define SH7751_PCICONF1_MWIE       0x00000010  /* Memory Write+Invalidate */
-  #define SH7751_PCICONF1_SPC        0x00000008  /* Special Cycle Control */
-  #define SH7751_PCICONF1_BUM        0x00000004  /* Bus Master Control */
-  #define SH7751_PCICONF1_MES        0x00000002  /* Memory Space Control */
-  #define SH7751_PCICONF1_IOS        0x00000001  /* I/O Space Control */
-#define SH7751_PCICONF2            0x8           /* PCI Config Reg 2 */
-  #define SH7751_PCICONF2_BCC        0xFF000000  /* Base Class Code */
-  #define SH7751_PCICONF2_SCC        0x00FF0000  /* Sub-Class Code */
-  #define SH7751_PCICONF2_RLPI       0x0000FF00  /* Programming Interface */
-  #define SH7751_PCICONF2_REV        0x000000FF  /* Revision ID */
-#define SH7751_PCICONF3            0xC           /* PCI Config Reg 3 */
-  #define SH7751_PCICONF3_BIST7      0x80000000  /* Bist Supported */
-  #define SH7751_PCICONF3_BIST6      0x40000000  /* Bist Executing */
-  #define SH7751_PCICONF3_BIST3_0    0x0F000000  /* Bist Passed */
-  #define SH7751_PCICONF3_HD7        0x00800000  /* Single Function device */
-  #define SH7751_PCICONF3_HD6_0      0x007F0000  /* Configuration Layout */
-  #define SH7751_PCICONF3_LAT        0x0000FF00  /* Latency Timer */
-  #define SH7751_PCICONF3_CLS        0x000000FF  /* Cache Line Size */
-#define SH7751_PCICONF4            0x10          /* PCI Config Reg 4 */
-  #define SH7751_PCICONF4_BASE       0xFFFFFFFC  /* I/O Space Base Addr */
-  #define SH7751_PCICONF4_ASI        0x00000001  /* Address Space Type */
-#define SH7751_PCICONF5            0x14          /* PCI Config Reg 5 */
-  #define SH7751_PCICONF5_BASE       0xFFFFFFF0  /* Mem Space Base Addr */
-  #define SH7751_PCICONF5_LAP        0x00000008  /* Prefetch Enabled */
-  #define SH7751_PCICONF5_LAT        0x00000006  /* Local Memory type */
-  #define SH7751_PCICONF5_ASI        0x00000001  /* Address Space Type */
-#define SH7751_PCICONF6            0x18          /* PCI Config Reg 6 */
-  #define SH7751_PCICONF6_BASE       0xFFFFFFF0  /* Mem Space Base Addr */
-  #define SH7751_PCICONF6_LAP        0x00000008  /* Prefetch Enabled */
-  #define SH7751_PCICONF6_LAT        0x00000006  /* Local Memory type */
-  #define SH7751_PCICONF6_ASI        0x00000001  /* Address Space Type */
-/* PCICONF7 - PCICONF10 are undefined */
-#define SH7751_PCICONF11           0x2C          /* PCI Config Reg 11 */
-  #define SH7751_PCICONF11_SSID      0xFFFF0000  /* Subsystem ID */
-  #define SH7751_PCICONF11_SVID      0x0000FFFF  /* Subsystem Vendor ID */
-/* PCICONF12 is undefined */
-#define SH7751_PCICONF13           0x34          /* PCI Config Reg 13 */
-  #define SH7751_PCICONF13_CPTR      0x000000FF  /* PM function pointer */
-/* PCICONF14 is undefined */
-#define SH7751_PCICONF15           0x3C          /* PCI Config Reg 15 */
-  #define SH7751_PCICONF15_IPIN      0x000000FF  /* Interrupt Pin */
-#define SH7751_PCICONF16           0x40          /* PCI Config Reg 16 */
-  #define SH7751_PCICONF16_PMES      0xF8000000  /* PME Support */
-  #define SH7751_PCICONF16_D2S       0x04000000  /* D2 Support */
-  #define SH7751_PCICONF16_D1S       0x02000000  /* D1 Support */
-  #define SH7751_PCICONF16_DSI       0x00200000  /* Bit Device Init. */
-  #define SH7751_PCICONF16_PMCK      0x00080000  /* Clock for PME req. */
-  #define SH7751_PCICONF16_VER       0x00070000  /* PM Version */
-  #define SH7751_PCICONF16_NIP       0x0000FF00  /* Next Item Pointer */
-  #define SH7751_PCICONF16_CID       0x000000FF  /* Capability Identifier */
-#define SH7751_PCICONF17           0x44          /* PCI Config Reg 17 */
-  #define SH7751_PCICONF17_DATA      0xFF000000  /* Data field for PM */
-  #define SH7751_PCICONF17_PMES      0x00800000  /* PME Status */
-  #define SH7751_PCICONF17_DSCL      0x00600000  /* Data Scaling Value */
-  #define SH7751_PCICONF17_DSEL      0x001E0000  /* Data Select */
-  #define SH7751_PCICONF17_PMEN      0x00010000  /* PME Enable */
-  #define SH7751_PCICONF17_PWST      0x00000003  /* Power State */
-/* SH7715 Internal PCI Registers */
-
-/* Memory Control Registers */
-#define SH7751_BCR1                0xFF800000    /* Memory BCR1 Register */
-#define SH7751_BCR2                0xFF800004    /* Memory BCR2 Register */
-#define SH7751_BCR3                0xFF800050    /* Memory BCR3 Register */
-#define SH7751_BCR4                0xFE0A00F0    /* Memory BCR4 Register */
-#define SH7751_WCR1                0xFF800008    /* Wait Control 1 Register */
-#define SH7751_WCR2                0xFF80000C    /* Wait Control 2 Register */
-#define SH7751_WCR3                0xFF800010    /* Wait Control 3 Register */
-#define SH7751_MCR                 0xFF800014    /* Memory Control Register */
-
-/* General Memory Config Addresses */
-#define SH7751_CS0_BASE_ADDR       0x0
-#define SH7751_MEM_REGION_SIZE     0x04000000
-#define SH7751_CS1_BASE_ADDR       (SH7751_CS0_BASE_ADDR + SH7751_MEM_REGION_SIZE)
-#define SH7751_CS2_BASE_ADDR       (SH7751_CS1_BASE_ADDR + SH7751_MEM_REGION_SIZE)
-#define SH7751_CS3_BASE_ADDR       (SH7751_CS2_BASE_ADDR + SH7751_MEM_REGION_SIZE)
-#define SH7751_CS4_BASE_ADDR       (SH7751_CS3_BASE_ADDR + SH7751_MEM_REGION_SIZE)
-#define SH7751_CS5_BASE_ADDR       (SH7751_CS4_BASE_ADDR + SH7751_MEM_REGION_SIZE)
-#define SH7751_CS6_BASE_ADDR       (SH7751_CS5_BASE_ADDR + SH7751_MEM_REGION_SIZE)
-
-#endif /* _PCI_SH7751_H_ */
diff --git a/arch/sh/drivers/pci/pci-sh7780.c b/arch/sh/drivers/pci/pci-sh7780.c
deleted file mode 100644
index 9a624a6ee35479..00000000000000
--- a/arch/sh/drivers/pci/pci-sh7780.c
+++ /dev/null
@@ -1,407 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Low-Level PCI Support for the SH7780
- *
- *  Copyright (C) 2005 - 2010  Paul Mundt
- */
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/pci.h>
-#include <linux/interrupt.h>
-#include <linux/timer.h>
-#include <linux/irq.h>
-#include <linux/errno.h>
-#include <linux/delay.h>
-#include <linux/log2.h>
-#include "pci-sh4.h"
-#include <asm/mmu.h>
-#include <linux/sizes.h>
-
-#if defined(CONFIG_CPU_BIG_ENDIAN)
-# define PCICR_ENDIANNESS SH4_PCICR_BSWP
-#else
-# define PCICR_ENDIANNESS 0
-#endif
-
-
-static struct resource sh7785_pci_resources[] = {
-	{
-		.name	= "PCI IO",
-		.start	= 0x1000,
-		.end	= SZ_4M - 1,
-		.flags	= IORESOURCE_IO,
-	}, {
-		.name	= "PCI MEM 0",
-		.start	= 0xfd000000,
-		.end	= 0xfd000000 + SZ_16M - 1,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.name	= "PCI MEM 1",
-		.start	= 0x10000000,
-		.end	= 0x10000000 + SZ_64M - 1,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		/*
-		 * 32-bit only resources must be last.
-		 */
-		.name	= "PCI MEM 2",
-		.start	= 0xc0000000,
-		.end	= 0xc0000000 + SZ_512M - 1,
-		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_32BIT,
-	},
-};
-
-static struct pci_channel sh7780_pci_controller = {
-	.pci_ops	= &sh4_pci_ops,
-	.resources	= sh7785_pci_resources,
-	.nr_resources	= ARRAY_SIZE(sh7785_pci_resources),
-	.io_offset	= 0,
-	.mem_offset	= 0,
-	.io_map_base	= 0xfe200000,
-	.serr_irq	= evt2irq(0xa00),
-	.err_irq	= evt2irq(0xaa0),
-};
-
-struct pci_errors {
-	unsigned int	mask;
-	const char	*str;
-} pci_arbiter_errors[] = {
-	{ SH4_PCIAINT_MBKN,	"master broken" },
-	{ SH4_PCIAINT_TBTO,	"target bus time out" },
-	{ SH4_PCIAINT_MBTO,	"master bus time out" },
-	{ SH4_PCIAINT_TABT,	"target abort" },
-	{ SH4_PCIAINT_MABT,	"master abort" },
-	{ SH4_PCIAINT_RDPE,	"read data parity error" },
-	{ SH4_PCIAINT_WDPE,	"write data parity error" },
-}, pci_interrupt_errors[] = {
-	{ SH4_PCIINT_MLCK,	"master lock error" },
-	{ SH4_PCIINT_TABT,	"target-target abort" },
-	{ SH4_PCIINT_TRET,	"target retry time out" },
-	{ SH4_PCIINT_MFDE,	"master function disable error" },
-	{ SH4_PCIINT_PRTY,	"address parity error" },
-	{ SH4_PCIINT_SERR,	"SERR" },
-	{ SH4_PCIINT_TWDP,	"data parity error for target write" },
-	{ SH4_PCIINT_TRDP,	"PERR detected for target read" },
-	{ SH4_PCIINT_MTABT,	"target abort for master" },
-	{ SH4_PCIINT_MMABT,	"master abort for master" },
-	{ SH4_PCIINT_MWPD,	"master write data parity error" },
-	{ SH4_PCIINT_MRPD,	"master read data parity error" },
-};
-
-static irqreturn_t sh7780_pci_err_irq(int irq, void *dev_id)
-{
-	struct pci_channel *hose = dev_id;
-	unsigned long addr;
-	unsigned int status;
-	unsigned int cmd;
-	int i;
-
-	addr = __raw_readl(hose->reg_base + SH4_PCIALR);
-
-	/*
-	 * Handle status errors.
-	 */
-	status = __raw_readw(hose->reg_base + PCI_STATUS);
-	if (status & (PCI_STATUS_PARITY |
-		      PCI_STATUS_DETECTED_PARITY |
-		      PCI_STATUS_SIG_TARGET_ABORT |
-		      PCI_STATUS_REC_TARGET_ABORT |
-		      PCI_STATUS_REC_MASTER_ABORT)) {
-		cmd = pcibios_handle_status_errors(addr, status, hose);
-		if (likely(cmd))
-			__raw_writew(cmd, hose->reg_base + PCI_STATUS);
-	}
-
-	/*
-	 * Handle arbiter errors.
-	 */
-	status = __raw_readl(hose->reg_base + SH4_PCIAINT);
-	for (i = cmd = 0; i < ARRAY_SIZE(pci_arbiter_errors); i++) {
-		if (status & pci_arbiter_errors[i].mask) {
-			printk(KERN_DEBUG "PCI: %s, addr=%08lx\n",
-			       pci_arbiter_errors[i].str, addr);
-			cmd |= pci_arbiter_errors[i].mask;
-		}
-	}
-	__raw_writel(cmd, hose->reg_base + SH4_PCIAINT);
-
-	/*
-	 * Handle the remaining PCI errors.
-	 */
-	status = __raw_readl(hose->reg_base + SH4_PCIINT);
-	for (i = cmd = 0; i < ARRAY_SIZE(pci_interrupt_errors); i++) {
-		if (status & pci_interrupt_errors[i].mask) {
-			printk(KERN_DEBUG "PCI: %s, addr=%08lx\n",
-			       pci_interrupt_errors[i].str, addr);
-			cmd |= pci_interrupt_errors[i].mask;
-		}
-	}
-	__raw_writel(cmd, hose->reg_base + SH4_PCIINT);
-
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t sh7780_pci_serr_irq(int irq, void *dev_id)
-{
-	struct pci_channel *hose = dev_id;
-
-	printk(KERN_DEBUG "PCI: system error received: ");
-	pcibios_report_status(PCI_STATUS_SIG_SYSTEM_ERROR, 1);
-	pr_cont("\n");
-
-	/* Deassert SERR */
-	__raw_writel(SH4_PCIINTM_SDIM, hose->reg_base + SH4_PCIINTM);
-
-	/* Back off the IRQ for awhile */
-	disable_irq_nosync(irq);
-	hose->serr_timer.expires = jiffies + HZ;
-	add_timer(&hose->serr_timer);
-
-	return IRQ_HANDLED;
-}
-
-static int __init sh7780_pci_setup_irqs(struct pci_channel *hose)
-{
-	int ret;
-
-	/* Clear out PCI arbiter IRQs */
-	__raw_writel(0, hose->reg_base + SH4_PCIAINT);
-
-	/* Clear all error conditions */
-	__raw_writew(PCI_STATUS_DETECTED_PARITY  | \
-		     PCI_STATUS_SIG_SYSTEM_ERROR | \
-		     PCI_STATUS_REC_MASTER_ABORT | \
-		     PCI_STATUS_REC_TARGET_ABORT | \
-		     PCI_STATUS_SIG_TARGET_ABORT | \
-		     PCI_STATUS_PARITY, hose->reg_base + PCI_STATUS);
-
-	ret = request_irq(hose->serr_irq, sh7780_pci_serr_irq, 0,
-			  "PCI SERR interrupt", hose);
-	if (unlikely(ret)) {
-		pr_err("PCI: Failed hooking SERR IRQ\n");
-		return ret;
-	}
-
-	/*
-	 * The PCI ERR IRQ needs to be IRQF_SHARED since all of the power
-	 * down IRQ vectors are routed through the ERR IRQ vector. We
-	 * only request_irq() once as there is only a single masking
-	 * source for multiple events.
-	 */
-	ret = request_irq(hose->err_irq, sh7780_pci_err_irq, IRQF_SHARED,
-			  "PCI ERR interrupt", hose);
-	if (unlikely(ret)) {
-		free_irq(hose->serr_irq, hose);
-		return ret;
-	}
-
-	/* Unmask all of the arbiter IRQs. */
-	__raw_writel(SH4_PCIAINT_MBKN | SH4_PCIAINT_TBTO | SH4_PCIAINT_MBTO | \
-		     SH4_PCIAINT_TABT | SH4_PCIAINT_MABT | SH4_PCIAINT_RDPE | \
-		     SH4_PCIAINT_WDPE, hose->reg_base + SH4_PCIAINTM);
-
-	/* Unmask all of the PCI IRQs */
-	__raw_writel(SH4_PCIINTM_TTADIM  | SH4_PCIINTM_TMTOIM  | \
-		     SH4_PCIINTM_MDEIM   | SH4_PCIINTM_APEDIM  | \
-		     SH4_PCIINTM_SDIM    | SH4_PCIINTM_DPEITWM | \
-		     SH4_PCIINTM_PEDITRM | SH4_PCIINTM_TADIMM  | \
-		     SH4_PCIINTM_MADIMM  | SH4_PCIINTM_MWPDIM  | \
-		     SH4_PCIINTM_MRDPEIM, hose->reg_base + SH4_PCIINTM);
-
-	return ret;
-}
-
-static inline void __init sh7780_pci_teardown_irqs(struct pci_channel *hose)
-{
-	free_irq(hose->err_irq, hose);
-	free_irq(hose->serr_irq, hose);
-}
-
-static void __init sh7780_pci66_init(struct pci_channel *hose)
-{
-	unsigned int tmp;
-
-	if (!pci_is_66mhz_capable(hose, 0, 0))
-		return;
-
-	/* Enable register access */
-	tmp = __raw_readl(hose->reg_base + SH4_PCICR);
-	tmp |= SH4_PCICR_PREFIX;
-	__raw_writel(tmp, hose->reg_base + SH4_PCICR);
-
-	/* Enable 66MHz operation */
-	tmp = __raw_readw(hose->reg_base + PCI_STATUS);
-	tmp |= PCI_STATUS_66MHZ;
-	__raw_writew(tmp, hose->reg_base + PCI_STATUS);
-
-	/* Done */
-	tmp = __raw_readl(hose->reg_base + SH4_PCICR);
-	tmp |= SH4_PCICR_PREFIX | SH4_PCICR_CFIN;
-	__raw_writel(tmp, hose->reg_base + SH4_PCICR);
-}
-
-static int __init sh7780_pci_init(void)
-{
-	struct pci_channel *chan = &sh7780_pci_controller;
-	phys_addr_t memphys;
-	size_t memsize;
-	unsigned int id;
-	const char *type;
-	int ret, i;
-
-	pr_notice("PCI: Starting initialization.\n");
-
-	chan->reg_base = 0xfe040000;
-
-	/* Enable CPU access to the PCIC registers. */
-	__raw_writel(PCIECR_ENBL, PCIECR);
-
-	/* Reset */
-	__raw_writel(SH4_PCICR_PREFIX | SH4_PCICR_PRST | PCICR_ENDIANNESS,
-		     chan->reg_base + SH4_PCICR);
-
-	/*
-	 * Wait for it to come back up. The spec says to allow for up to
-	 * 1 second after toggling the reset pin, but in practice 100ms
-	 * is more than enough.
-	 */
-	mdelay(100);
-
-	id = __raw_readw(chan->reg_base + PCI_VENDOR_ID);
-	if (id != PCI_VENDOR_ID_RENESAS) {
-		pr_err("PCI: Unknown vendor ID 0x%04x.\n", id);
-		return -ENODEV;
-	}
-
-	id = __raw_readw(chan->reg_base + PCI_DEVICE_ID);
-	type = (id == PCI_DEVICE_ID_RENESAS_SH7763) ? "SH7763" :
-	       (id == PCI_DEVICE_ID_RENESAS_SH7780) ? "SH7780" :
-	       (id == PCI_DEVICE_ID_RENESAS_SH7781) ? "SH7781" :
-	       (id == PCI_DEVICE_ID_RENESAS_SH7785) ? "SH7785" :
-					  NULL;
-	if (unlikely(!type)) {
-		pr_err("PCI: Found an unsupported Renesas host controller, device id 0x%04x.\n",
-		       id);
-		return -EINVAL;
-	}
-
-	pr_notice("PCI: Found a Renesas %s host controller, revision %d.\n",
-		  type, __raw_readb(chan->reg_base + PCI_REVISION_ID));
-
-	/*
-	 * Now throw it in to register initialization mode and
-	 * start the real work.
-	 */
-	__raw_writel(SH4_PCICR_PREFIX | PCICR_ENDIANNESS,
-		     chan->reg_base + SH4_PCICR);
-
-	memphys = __pa(memory_start);
-	memsize = roundup_pow_of_two(memory_end - memory_start);
-
-	/*
-	 * If there's more than 512MB of memory, we need to roll over to
-	 * LAR1/LSR1.
-	 */
-	if (memsize > SZ_512M) {
-		__raw_writel(memphys + SZ_512M, chan->reg_base + SH4_PCILAR1);
-		__raw_writel((((memsize - SZ_512M) - SZ_1M) & 0x1ff00000) | 1,
-			     chan->reg_base + SH4_PCILSR1);
-		memsize = SZ_512M;
-	} else {
-		/*
-		 * Otherwise just zero it out and disable it.
-		 */
-		__raw_writel(0, chan->reg_base + SH4_PCILAR1);
-		__raw_writel(0, chan->reg_base + SH4_PCILSR1);
-	}
-
-	/*
-	 * LAR0/LSR0 covers up to the first 512MB, which is enough to
-	 * cover all of lowmem on most platforms.
-	 */
-	__raw_writel(memphys, chan->reg_base + SH4_PCILAR0);
-	__raw_writel(((memsize - SZ_1M) & 0x1ff00000) | 1,
-		     chan->reg_base + SH4_PCILSR0);
-
-	/*
-	 * Hook up the ERR and SERR IRQs.
-	 */
-	ret = sh7780_pci_setup_irqs(chan);
-	if (unlikely(ret))
-		return ret;
-
-	/*
-	 * Disable the cache snoop controller for non-coherent DMA.
-	 */
-	__raw_writel(0, chan->reg_base + SH7780_PCICSCR0);
-	__raw_writel(0, chan->reg_base + SH7780_PCICSAR0);
-	__raw_writel(0, chan->reg_base + SH7780_PCICSCR1);
-	__raw_writel(0, chan->reg_base + SH7780_PCICSAR1);
-
-	/*
-	 * Setup the memory BARs
-	 */
-	for (i = 1; i < chan->nr_resources; i++) {
-		struct resource *res = chan->resources + i;
-		resource_size_t size;
-
-		if (unlikely(res->flags & IORESOURCE_IO))
-			continue;
-
-		/*
-		 * Make sure we're in the right physical addressing mode
-		 * for dealing with the resource.
-		 */
-		if ((res->flags & IORESOURCE_MEM_32BIT) && __in_29bit_mode()) {
-			chan->nr_resources--;
-			continue;
-		}
-
-		size = resource_size(res);
-
-		/*
-		 * The MBMR mask is calculated in units of 256kB, which
-		 * keeps things pretty simple.
-		 */
-		__raw_writel(((roundup_pow_of_two(size) / SZ_256K) - 1) << 18,
-			     chan->reg_base + SH7780_PCIMBMR(i - 1));
-		__raw_writel(res->start, chan->reg_base + SH7780_PCIMBR(i - 1));
-	}
-
-	/*
-	 * And I/O.
-	 */
-	__raw_writel(0, chan->reg_base + PCI_BASE_ADDRESS_0);
-	__raw_writel(0, chan->reg_base + SH7780_PCIIOBR);
-	__raw_writel(0, chan->reg_base + SH7780_PCIIOBMR);
-
-	__raw_writew(PCI_COMMAND_SERR   | PCI_COMMAND_WAIT   | \
-		     PCI_COMMAND_PARITY | PCI_COMMAND_MASTER | \
-		     PCI_COMMAND_MEMORY, chan->reg_base + PCI_COMMAND);
-
-	/*
-	 * Initialization mode complete, release the control register and
-	 * enable round robin mode to stop device overruns/starvation.
-	 */
-	__raw_writel(SH4_PCICR_PREFIX | SH4_PCICR_CFIN | SH4_PCICR_FTO |
-		     PCICR_ENDIANNESS,
-		     chan->reg_base + SH4_PCICR);
-
-	ret = register_pci_controller(chan);
-	if (unlikely(ret))
-		goto err;
-
-	sh7780_pci66_init(chan);
-
-	pr_notice("PCI: Running at %dMHz.\n",
-		  (__raw_readw(chan->reg_base + PCI_STATUS) & PCI_STATUS_66MHZ)
-		  ? 66 : 33);
-
-	return 0;
-
-err:
-	sh7780_pci_teardown_irqs(chan);
-	return ret;
-}
-arch_initcall(sh7780_pci_init);
diff --git a/arch/sh/drivers/pci/pci-sh7780.h b/arch/sh/drivers/pci/pci-sh7780.h
deleted file mode 100644
index e2ac770f8e3502..00000000000000
--- a/arch/sh/drivers/pci/pci-sh7780.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- *	Low-Level PCI Support for SH7780 targets
- *
- *  Dustin McIntire (dustin@sensoria.com) (c) 2001
- *  Paul Mundt (lethal@linux-sh.org) (c) 2003
- */
-
-#ifndef _PCI_SH7780_H_
-#define _PCI_SH7780_H_
-
-/* SH7780 Control Registers */
-#define	PCIECR			0xFE000008
-#define PCIECR_ENBL		0x01
-
-/* SH7780 Specific Values */
-#define SH7780_PCI_CONFIG_BASE	0xFD000000	/* Config space base addr */
-#define SH7780_PCI_CONFIG_SIZE	0x01000000	/* Config space size */
-
-#define SH7780_PCIREG_BASE	0xFE040000	/* PCI regs base address */
-
-/* SH7780 PCI Config Registers */
-#define SH7780_PCIIR		0x114		/* PCI Interrupt Register */
-#define SH7780_PCIIMR		0x118		/* PCI Interrupt Mask Register */
-#define SH7780_PCIAIR		0x11C		/* Error Address Register */
-#define SH7780_PCICIR		0x120		/* Error Command/Data Register */
-#define SH7780_PCIAINT		0x130		/* Arbiter Interrupt Register */
-#define SH7780_PCIAINTM		0x134		/* Arbiter Int. Mask Register */
-#define SH7780_PCIBMIR		0x138		/* Error Bus Master Register */
-#define SH7780_PCIPAR		0x1C0		/* PIO Address Register */
-#define SH7780_PCIPINT		0x1CC		/* Power Mgmnt Int. Register */
-#define SH7780_PCIPINTM		0x1D0		/* Power Mgmnt Mask Register */
-
-#define SH7780_PCIMBR(x)	(0x1E0 + ((x) * 8))
-#define SH7780_PCIMBMR(x)	(0x1E4 + ((x) * 8))
-#define SH7780_PCIIOBR		0x1F8
-#define SH7780_PCIIOBMR		0x1FC
-#define SH7780_PCICSCR0		0x210		/* Cache Snoop1 Cnt. Register */
-#define SH7780_PCICSCR1		0x214		/* Cache Snoop2 Cnt. Register */
-#define SH7780_PCICSAR0		0x218	/* Cache Snoop1 Addr. Register */
-#define SH7780_PCICSAR1		0x21C	/* Cache Snoop2 Addr. Register */
-
-#endif /* _PCI_SH7780_H_ */
diff --git a/arch/sh/drivers/pci/pci.c b/arch/sh/drivers/pci/pci.c
deleted file mode 100644
index a3903304f33faa..00000000000000
--- a/arch/sh/drivers/pci/pci.c
+++ /dev/null
@@ -1,298 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * New-style PCI core.
- *
- * Copyright (c) 2004 - 2009  Paul Mundt
- * Copyright (c) 2002  M. R. Brown
- *
- * Modelled after arch/mips/pci/pci.c:
- *  Copyright (C) 2003, 04 Ralf Baechle (ralf@linux-mips.org)
- */
-#include <linux/kernel.h>
-#include <linux/mm.h>
-#include <linux/pci.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/io.h>
-#include <linux/mutex.h>
-#include <linux/spinlock.h>
-#include <linux/export.h>
-
-unsigned long PCIBIOS_MIN_IO = 0x0000;
-unsigned long PCIBIOS_MIN_MEM = 0;
-
-/*
- * The PCI controller list.
- */
-static struct pci_channel *hose_head, **hose_tail = &hose_head;
-
-static int pci_initialized;
-
-static void pcibios_scanbus(struct pci_channel *hose)
-{
-	static int next_busno;
-	static int need_domain_info;
-	LIST_HEAD(resources);
-	struct resource *res;
-	resource_size_t offset;
-	int i, ret;
-	struct pci_host_bridge *bridge;
-
-	bridge = pci_alloc_host_bridge(0);
-	if (!bridge)
-		return;
-
-	for (i = 0; i < hose->nr_resources; i++) {
-		res = hose->resources + i;
-		offset = 0;
-		if (res->flags & IORESOURCE_DISABLED)
-			continue;
-		if (res->flags & IORESOURCE_IO)
-			offset = hose->io_offset;
-		else if (res->flags & IORESOURCE_MEM)
-			offset = hose->mem_offset;
-		pci_add_resource_offset(&resources, res, offset);
-	}
-
-	list_splice_init(&resources, &bridge->windows);
-	bridge->dev.parent = NULL;
-	bridge->sysdata = hose;
-	bridge->busnr = next_busno;
-	bridge->ops = hose->pci_ops;
-	bridge->swizzle_irq = pci_common_swizzle;
-	bridge->map_irq = pcibios_map_platform_irq;
-
-	ret = pci_scan_root_bus_bridge(bridge);
-	if (ret) {
-		pci_free_host_bridge(bridge);
-		return;
-	}
-
-	hose->bus = bridge->bus;
-
-	need_domain_info = need_domain_info || hose->index;
-	hose->need_domain_info = need_domain_info;
-
-	next_busno = hose->bus->busn_res.end + 1;
-	/* Don't allow 8-bit bus number overflow inside the hose -
-	   reserve some space for bridges. */
-	if (next_busno > 224) {
-		next_busno = 0;
-		need_domain_info = 1;
-	}
-
-	pci_bus_size_bridges(hose->bus);
-	pci_bus_assign_resources(hose->bus);
-	pci_bus_add_devices(hose->bus);
-}
-
-/*
- * This interrupt-safe spinlock protects all accesses to PCI
- * configuration space.
- */
-DEFINE_RAW_SPINLOCK(pci_config_lock);
-static DEFINE_MUTEX(pci_scan_mutex);
-
-int register_pci_controller(struct pci_channel *hose)
-{
-	int i;
-
-	for (i = 0; i < hose->nr_resources; i++) {
-		struct resource *res = hose->resources + i;
-
-		if (res->flags & IORESOURCE_DISABLED)
-			continue;
-
-		if (res->flags & IORESOURCE_IO) {
-			if (request_resource(&ioport_resource, res) < 0)
-				goto out;
-		} else {
-			if (request_resource(&iomem_resource, res) < 0)
-				goto out;
-		}
-	}
-
-	*hose_tail = hose;
-	hose_tail = &hose->next;
-
-	/*
-	 * Do not panic here but later - this might happen before console init.
-	 */
-	if (!hose->io_map_base) {
-		pr_warn("registering PCI controller with io_map_base unset\n");
-	}
-
-	/*
-	 * Setup the ERR/PERR and SERR timers, if available.
-	 */
-	pcibios_enable_timers(hose);
-
-	/*
-	 * Scan the bus if it is register after the PCI subsystem
-	 * initialization.
-	 */
-	if (pci_initialized) {
-		mutex_lock(&pci_scan_mutex);
-		pcibios_scanbus(hose);
-		mutex_unlock(&pci_scan_mutex);
-	}
-
-	return 0;
-
-out:
-	for (--i; i >= 0; i--)
-		release_resource(&hose->resources[i]);
-
-	pr_warn("Skipping PCI bus scan due to resource conflict\n");
-	return -1;
-}
-
-static int __init pcibios_init(void)
-{
-	struct pci_channel *hose;
-
-	/* Scan all of the recorded PCI controllers.  */
-	for (hose = hose_head; hose; hose = hose->next)
-		pcibios_scanbus(hose);
-
-	pci_initialized = 1;
-
-	return 0;
-}
-subsys_initcall(pcibios_init);
-
-/*
- * We need to avoid collisions with `mirrored' VGA ports
- * and other strange ISA hardware, so we always want the
- * addresses to be allocated in the 0x000-0x0ff region
- * modulo 0x400.
- */
-resource_size_t pcibios_align_resource(void *data, const struct resource *res,
-				resource_size_t size, resource_size_t align)
-{
-	struct pci_dev *dev = data;
-	struct pci_channel *hose = dev->sysdata;
-	resource_size_t start = res->start;
-
-	if (res->flags & IORESOURCE_IO) {
-		if (start < PCIBIOS_MIN_IO + hose->resources[0].start)
-			start = PCIBIOS_MIN_IO + hose->resources[0].start;
-
-		/*
-                 * Put everything into 0x00-0xff region modulo 0x400.
-		 */
-		if (start & 0x300)
-			start = (start + 0x3ff) & ~0x3ff;
-	}
-
-	return start;
-}
-
-static void __init
-pcibios_bus_report_status_early(struct pci_channel *hose,
-				int top_bus, int current_bus,
-				unsigned int status_mask, int warn)
-{
-	unsigned int pci_devfn;
-	u16 status;
-	int ret;
-
-	for (pci_devfn = 0; pci_devfn < 0xff; pci_devfn++) {
-		if (PCI_FUNC(pci_devfn))
-			continue;
-		ret = early_read_config_word(hose, top_bus, current_bus,
-					     pci_devfn, PCI_STATUS, &status);
-		if (ret != PCIBIOS_SUCCESSFUL)
-			continue;
-		if (status == 0xffff)
-			continue;
-
-		early_write_config_word(hose, top_bus, current_bus,
-					pci_devfn, PCI_STATUS,
-					status & status_mask);
-		if (warn)
-			pr_cont("(%02x:%02x: %04X) ", current_bus, pci_devfn,
-				status);
-	}
-}
-
-/*
- * We can't use pci_find_device() here since we are
- * called from interrupt context.
- */
-static void __ref
-pcibios_bus_report_status(struct pci_bus *bus, unsigned int status_mask,
-			  int warn)
-{
-	struct pci_dev *dev;
-
-	list_for_each_entry(dev, &bus->devices, bus_list) {
-		u16 status;
-
-		/*
-		 * ignore host bridge - we handle
-		 * that separately
-		 */
-		if (dev->bus->number == 0 && dev->devfn == 0)
-			continue;
-
-		pci_read_config_word(dev, PCI_STATUS, &status);
-		if (status == 0xffff)
-			continue;
-
-		if ((status & status_mask) == 0)
-			continue;
-
-		/* clear the status errors */
-		pci_write_config_word(dev, PCI_STATUS, status & status_mask);
-
-		if (warn)
-			pr_cont("(%s: %04X) ", pci_name(dev), status);
-	}
-
-	list_for_each_entry(dev, &bus->devices, bus_list)
-		if (dev->subordinate)
-			pcibios_bus_report_status(dev->subordinate, status_mask, warn);
-}
-
-void __ref pcibios_report_status(unsigned int status_mask, int warn)
-{
-	struct pci_channel *hose;
-
-	for (hose = hose_head; hose; hose = hose->next) {
-		if (unlikely(!hose->bus))
-			pcibios_bus_report_status_early(hose, hose_head->index,
-					hose->index, status_mask, warn);
-		else
-			pcibios_bus_report_status(hose->bus, status_mask, warn);
-	}
-}
-
-#ifndef CONFIG_GENERIC_IOMAP
-
-void __iomem *__pci_ioport_map(struct pci_dev *dev,
-			       unsigned long port, unsigned int nr)
-{
-	struct pci_channel *chan = dev->sysdata;
-
-	if (unlikely(!chan->io_map_base)) {
-		chan->io_map_base = sh_io_port_base;
-
-		if (pci_domains_supported)
-			panic("To avoid data corruption io_map_base MUST be "
-			      "set with multiple PCI domains.");
-	}
-
-	return (void __iomem *)(chan->io_map_base + port);
-}
-
-void pci_iounmap(struct pci_dev *dev, void __iomem *addr)
-{
-	iounmap(addr);
-}
-EXPORT_SYMBOL(pci_iounmap);
-
-#endif /* CONFIG_GENERIC_IOMAP */
-
-EXPORT_SYMBOL(PCIBIOS_MIN_IO);
-EXPORT_SYMBOL(PCIBIOS_MIN_MEM);
diff --git a/arch/sh/drivers/pci/pcie-sh7786.c b/arch/sh/drivers/pci/pcie-sh7786.c
deleted file mode 100644
index b0c2a5238d0497..00000000000000
--- a/arch/sh/drivers/pci/pcie-sh7786.c
+++ /dev/null
@@ -1,609 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Low-Level PCI Express Support for the SH7786
- *
- *  Copyright (C) 2009 - 2011  Paul Mundt
- */
-#define pr_fmt(fmt) "PCI: " fmt
-
-#include <linux/pci.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/async.h>
-#include <linux/delay.h>
-#include <linux/dma-map-ops.h>
-#include <linux/slab.h>
-#include <linux/clk.h>
-#include <linux/sh_clk.h>
-#include <linux/sh_intc.h>
-#include <cpu/sh7786.h>
-#include "pcie-sh7786.h"
-#include <linux/sizes.h>
-
-struct sh7786_pcie_port {
-	struct pci_channel	*hose;
-	struct clk		*fclk, phy_clk;
-	unsigned int		index;
-	int			endpoint;
-	int			link;
-};
-
-static struct sh7786_pcie_port *sh7786_pcie_ports;
-static unsigned int nr_ports;
-static unsigned long dma_pfn_offset;
-size_t memsize;
-u64 memstart;
-
-static struct sh7786_pcie_hwops {
-	int (*core_init)(void);
-	async_func_t port_init_hw;
-} *sh7786_pcie_hwops;
-
-static struct resource sh7786_pci0_resources[] = {
-	{
-		.name	= "PCIe0 MEM 0",
-		.start	= 0xfd000000,
-		.end	= 0xfd000000 + SZ_8M - 1,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.name	= "PCIe0 MEM 1",
-		.start	= 0xc0000000,
-		.end	= 0xc0000000 + SZ_512M - 1,
-		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_32BIT,
-	}, {
-		.name	= "PCIe0 MEM 2",
-		.start	= 0x10000000,
-		.end	= 0x10000000 + SZ_64M - 1,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.name	= "PCIe0 IO",
-		.start	= 0xfe100000,
-		.end	= 0xfe100000 + SZ_1M - 1,
-		.flags	= IORESOURCE_IO,
-	},
-};
-
-static struct resource sh7786_pci1_resources[] = {
-	{
-		.name	= "PCIe1 MEM 0",
-		.start	= 0xfd800000,
-		.end	= 0xfd800000 + SZ_8M - 1,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.name	= "PCIe1 MEM 1",
-		.start	= 0xa0000000,
-		.end	= 0xa0000000 + SZ_512M - 1,
-		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_32BIT,
-	}, {
-		.name	= "PCIe1 MEM 2",
-		.start	= 0x30000000,
-		.end	= 0x30000000 + SZ_256M - 1,
-		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_32BIT,
-	}, {
-		.name	= "PCIe1 IO",
-		.start	= 0xfe300000,
-		.end	= 0xfe300000 + SZ_1M - 1,
-		.flags	= IORESOURCE_IO,
-	},
-};
-
-static struct resource sh7786_pci2_resources[] = {
-	{
-		.name	= "PCIe2 MEM 0",
-		.start	= 0xfc800000,
-		.end	= 0xfc800000 + SZ_4M - 1,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.name	= "PCIe2 MEM 1",
-		.start	= 0x80000000,
-		.end	= 0x80000000 + SZ_512M - 1,
-		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_32BIT,
-	}, {
-		.name	= "PCIe2 MEM 2",
-		.start	= 0x20000000,
-		.end	= 0x20000000 + SZ_256M - 1,
-		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_32BIT,
-	}, {
-		.name	= "PCIe2 IO",
-		.start	= 0xfcd00000,
-		.end	= 0xfcd00000 + SZ_1M - 1,
-		.flags	= IORESOURCE_IO,
-	},
-};
-
-extern struct pci_ops sh7786_pci_ops;
-
-#define DEFINE_CONTROLLER(start, idx)					\
-{									\
-	.pci_ops	= &sh7786_pci_ops,				\
-	.resources	= sh7786_pci##idx##_resources,			\
-	.nr_resources	= ARRAY_SIZE(sh7786_pci##idx##_resources),	\
-	.reg_base	= start,					\
-	.mem_offset	= 0,						\
-	.io_offset	= 0,						\
-}
-
-static struct pci_channel sh7786_pci_channels[] = {
-	DEFINE_CONTROLLER(0xfe000000, 0),
-	DEFINE_CONTROLLER(0xfe200000, 1),
-	DEFINE_CONTROLLER(0xfcc00000, 2),
-};
-
-static struct clk fixed_pciexclkp = {
-	.rate = 100000000,	/* 100 MHz reference clock */
-};
-
-static void sh7786_pci_fixup(struct pci_dev *dev)
-{
-	/*
-	 * Prevent enumeration of root complex resources.
-	 */
-	if (pci_is_root_bus(dev->bus) && dev->devfn == 0) {
-		int i;
-
-		for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
-			dev->resource[i].start	= 0;
-			dev->resource[i].end	= 0;
-			dev->resource[i].flags	= 0;
-		}
-	}
-}
-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_RENESAS, PCI_DEVICE_ID_RENESAS_SH7786,
-			 sh7786_pci_fixup);
-
-static int __init phy_wait_for_ack(struct pci_channel *chan)
-{
-	unsigned int timeout = 100;
-
-	while (timeout--) {
-		if (pci_read_reg(chan, SH4A_PCIEPHYADRR) & (1 << BITS_ACK))
-			return 0;
-
-		udelay(100);
-	}
-
-	return -ETIMEDOUT;
-}
-
-static int __init pci_wait_for_irq(struct pci_channel *chan, unsigned int mask)
-{
-	unsigned int timeout = 100;
-
-	while (timeout--) {
-		if ((pci_read_reg(chan, SH4A_PCIEINTR) & mask) == mask)
-			return 0;
-
-		udelay(100);
-	}
-
-	return -ETIMEDOUT;
-}
-
-static void __init phy_write_reg(struct pci_channel *chan, unsigned int addr,
-				 unsigned int lane, unsigned int data)
-{
-	unsigned long phyaddr;
-
-	phyaddr = (1 << BITS_CMD) + ((lane & 0xf) << BITS_LANE) +
-			((addr & 0xff) << BITS_ADR);
-
-	/* Set write data */
-	pci_write_reg(chan, data, SH4A_PCIEPHYDOUTR);
-	pci_write_reg(chan, phyaddr, SH4A_PCIEPHYADRR);
-
-	phy_wait_for_ack(chan);
-
-	/* Clear command */
-	pci_write_reg(chan, 0, SH4A_PCIEPHYDOUTR);
-	pci_write_reg(chan, 0, SH4A_PCIEPHYADRR);
-
-	phy_wait_for_ack(chan);
-}
-
-static int __init pcie_clk_init(struct sh7786_pcie_port *port)
-{
-	struct pci_channel *chan = port->hose;
-	struct clk *clk;
-	char fclk_name[16];
-	int ret;
-
-	/*
-	 * First register the fixed clock
-	 */
-	ret = clk_register(&fixed_pciexclkp);
-	if (unlikely(ret != 0))
-		return ret;
-
-	/*
-	 * Grab the port's function clock, which the PHY clock depends
-	 * on. clock lookups don't help us much at this point, since no
-	 * dev_id is available this early. Lame.
-	 */
-	snprintf(fclk_name, sizeof(fclk_name), "pcie%d_fck", port->index);
-
-	port->fclk = clk_get(NULL, fclk_name);
-	if (IS_ERR(port->fclk)) {
-		ret = PTR_ERR(port->fclk);
-		goto err_fclk;
-	}
-
-	clk_enable(port->fclk);
-
-	/*
-	 * And now, set up the PHY clock
-	 */
-	clk = &port->phy_clk;
-
-	memset(clk, 0, sizeof(struct clk));
-
-	clk->parent = &fixed_pciexclkp;
-	clk->enable_reg = (void __iomem *)(chan->reg_base + SH4A_PCIEPHYCTLR);
-	clk->enable_bit = BITS_CKE;
-
-	ret = sh_clk_mstp_register(clk, 1);
-	if (unlikely(ret < 0))
-		goto err_phy;
-
-	return 0;
-
-err_phy:
-	clk_disable(port->fclk);
-	clk_put(port->fclk);
-err_fclk:
-	clk_unregister(&fixed_pciexclkp);
-
-	return ret;
-}
-
-static int __init phy_init(struct sh7786_pcie_port *port)
-{
-	struct pci_channel *chan = port->hose;
-	unsigned int timeout = 100;
-
-	clk_enable(&port->phy_clk);
-
-	/* Initialize the phy */
-	phy_write_reg(chan, 0x60, 0xf, 0x004b008b);
-	phy_write_reg(chan, 0x61, 0xf, 0x00007b41);
-	phy_write_reg(chan, 0x64, 0xf, 0x00ff4f00);
-	phy_write_reg(chan, 0x65, 0xf, 0x09070907);
-	phy_write_reg(chan, 0x66, 0xf, 0x00000010);
-	phy_write_reg(chan, 0x74, 0xf, 0x0007001c);
-	phy_write_reg(chan, 0x79, 0xf, 0x01fc000d);
-	phy_write_reg(chan, 0xb0, 0xf, 0x00000610);
-
-	/* Deassert Standby */
-	phy_write_reg(chan, 0x67, 0x1, 0x00000400);
-
-	/* Disable clock */
-	clk_disable(&port->phy_clk);
-
-	while (timeout--) {
-		if (pci_read_reg(chan, SH4A_PCIEPHYSR))
-			return 0;
-
-		udelay(100);
-	}
-
-	return -ETIMEDOUT;
-}
-
-static void __init pcie_reset(struct sh7786_pcie_port *port)
-{
-	struct pci_channel *chan = port->hose;
-
-	pci_write_reg(chan, 1, SH4A_PCIESRSTR);
-	pci_write_reg(chan, 0, SH4A_PCIETCTLR);
-	pci_write_reg(chan, 0, SH4A_PCIESRSTR);
-	pci_write_reg(chan, 0, SH4A_PCIETXVC0SR);
-}
-
-static int __init pcie_init(struct sh7786_pcie_port *port)
-{
-	struct pci_channel *chan = port->hose;
-	unsigned int data;
-	phys_addr_t memstart, memend;
-	int ret, i, win;
-
-	/* Begin initialization */
-	pcie_reset(port);
-
-	/*
-	 * Initial header for port config space is type 1, set the device
-	 * class to match. Hardware takes care of propagating the IDSETR
-	 * settings, so there is no need to bother with a quirk.
-	 */
-	pci_write_reg(chan, PCI_CLASS_BRIDGE_PCI_NORMAL << 8, SH4A_PCIEIDSETR1);
-
-	/* Initialize default capabilities. */
-	data = pci_read_reg(chan, SH4A_PCIEEXPCAP0);
-	data &= ~(PCI_EXP_FLAGS_TYPE << 16);
-
-	if (port->endpoint)
-		data |= PCI_EXP_TYPE_ENDPOINT << 20;
-	else
-		data |= PCI_EXP_TYPE_ROOT_PORT << 20;
-
-	data |= PCI_CAP_ID_EXP;
-	pci_write_reg(chan, data, SH4A_PCIEEXPCAP0);
-
-	/* Enable data link layer active state reporting */
-	pci_write_reg(chan, PCI_EXP_LNKCAP_DLLLARC, SH4A_PCIEEXPCAP3);
-
-	/* Enable extended sync and ASPM L0s support */
-	data = pci_read_reg(chan, SH4A_PCIEEXPCAP4);
-	data &= ~PCI_EXP_LNKCTL_ASPMC;
-	data |= PCI_EXP_LNKCTL_ES | 1;
-	pci_write_reg(chan, data, SH4A_PCIEEXPCAP4);
-
-	/* Write out the physical slot number */
-	data = pci_read_reg(chan, SH4A_PCIEEXPCAP5);
-	data &= ~PCI_EXP_SLTCAP_PSN;
-	data |= (port->index + 1) << 19;
-	pci_write_reg(chan, data, SH4A_PCIEEXPCAP5);
-
-	/* Set the completion timer timeout to the maximum 32ms. */
-	data = pci_read_reg(chan, SH4A_PCIETLCTLR);
-	data &= ~0x3f00;
-	data |= 0x32 << 8;
-	pci_write_reg(chan, data, SH4A_PCIETLCTLR);
-
-	/*
-	 * Set fast training sequences to the maximum 255,
-	 * and enable MAC data scrambling.
-	 */
-	data = pci_read_reg(chan, SH4A_PCIEMACCTLR);
-	data &= ~PCIEMACCTLR_SCR_DIS;
-	data |= (0xff << 16);
-	pci_write_reg(chan, data, SH4A_PCIEMACCTLR);
-
-	memstart = __pa(memory_start);
-	memend   = __pa(memory_end);
-	memsize = roundup_pow_of_two(memend - memstart);
-
-	/*
-	 * The start address must be aligned on its size. So we round
-	 * it down, and then recalculate the size so that it covers
-	 * the entire memory.
-	 */
-	memstart = ALIGN_DOWN(memstart, memsize);
-	memsize = roundup_pow_of_two(memend - memstart);
-
-	/*
-	 * If there's more than 512MB of memory, we need to roll over to
-	 * LAR1/LAMR1.
-	 */
-	if (memsize > SZ_512M) {
-		pci_write_reg(chan, memstart + SZ_512M, SH4A_PCIELAR1);
-		pci_write_reg(chan, ((memsize - SZ_512M) - SZ_256) | 1,
-			      SH4A_PCIELAMR1);
-		memsize = SZ_512M;
-	} else {
-		/*
-		 * Otherwise just zero it out and disable it.
-		 */
-		pci_write_reg(chan, 0, SH4A_PCIELAR1);
-		pci_write_reg(chan, 0, SH4A_PCIELAMR1);
-	}
-
-	/*
-	 * LAR0/LAMR0 covers up to the first 512MB, which is enough to
-	 * cover all of lowmem on most platforms.
-	 */
-	pci_write_reg(chan, memstart, SH4A_PCIELAR0);
-	pci_write_reg(chan, (memsize - SZ_256) | 1, SH4A_PCIELAMR0);
-
-	/* Finish initialization */
-	data = pci_read_reg(chan, SH4A_PCIETCTLR);
-	data |= 0x1;
-	pci_write_reg(chan, data, SH4A_PCIETCTLR);
-
-	/* Let things settle down a bit.. */
-	mdelay(100);
-
-	/* Enable DL_Active Interrupt generation */
-	data = pci_read_reg(chan, SH4A_PCIEDLINTENR);
-	data |= PCIEDLINTENR_DLL_ACT_ENABLE;
-	pci_write_reg(chan, data, SH4A_PCIEDLINTENR);
-
-	/* Disable MAC data scrambling. */
-	data = pci_read_reg(chan, SH4A_PCIEMACCTLR);
-	data |= PCIEMACCTLR_SCR_DIS | (0xff << 16);
-	pci_write_reg(chan, data, SH4A_PCIEMACCTLR);
-
-	/*
-	 * This will timeout if we don't have a link, but we permit the
-	 * port to register anyways in order to support hotplug on future
-	 * hardware.
-	 */
-	ret = pci_wait_for_irq(chan, MASK_INT_TX_CTRL);
-
-	data = pci_read_reg(chan, SH4A_PCIEPCICONF1);
-	data &= ~(PCI_STATUS_DEVSEL_MASK << 16);
-	data |= PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER |
-		(PCI_STATUS_CAP_LIST | PCI_STATUS_DEVSEL_FAST) << 16;
-	pci_write_reg(chan, data, SH4A_PCIEPCICONF1);
-
-	pci_write_reg(chan, 0x80888000, SH4A_PCIETXVC0DCTLR);
-	pci_write_reg(chan, 0x00222000, SH4A_PCIERXVC0DCTLR);
-
-	wmb();
-
-	if (ret == 0) {
-		data = pci_read_reg(chan, SH4A_PCIEMACSR);
-		printk(KERN_NOTICE "PCI: PCIe#%d x%d link detected\n",
-		       port->index, (data >> 20) & 0x3f);
-	} else
-		printk(KERN_NOTICE "PCI: PCIe#%d link down\n",
-		       port->index);
-
-	for (i = win = 0; i < chan->nr_resources; i++) {
-		struct resource *res = chan->resources + i;
-		resource_size_t size;
-		u32 mask;
-
-		/*
-		 * We can't use the 32-bit mode windows in legacy 29-bit
-		 * mode, so just skip them entirely.
-		 */
-		if ((res->flags & IORESOURCE_MEM_32BIT) && __in_29bit_mode())
-			res->flags |= IORESOURCE_DISABLED;
-
-		if (res->flags & IORESOURCE_DISABLED)
-			continue;
-
-		pci_write_reg(chan, 0x00000000, SH4A_PCIEPTCTLR(win));
-
-		/*
-		 * The PAMR mask is calculated in units of 256kB, which
-		 * keeps things pretty simple.
-		 */
-		size = resource_size(res);
-		mask = (roundup_pow_of_two(size) / SZ_256K) - 1;
-		pci_write_reg(chan, mask << 18, SH4A_PCIEPAMR(win));
-
-		pci_write_reg(chan, upper_32_bits(res->start),
-			      SH4A_PCIEPARH(win));
-		pci_write_reg(chan, lower_32_bits(res->start),
-			      SH4A_PCIEPARL(win));
-
-		mask = MASK_PARE;
-		if (res->flags & IORESOURCE_IO)
-			mask |= MASK_SPC;
-
-		pci_write_reg(chan, mask, SH4A_PCIEPTCTLR(win));
-
-		win++;
-	}
-
-	return 0;
-}
-
-int pcibios_map_platform_irq(const struct pci_dev *pdev, u8 slot, u8 pin)
-{
-        return evt2irq(0xae0);
-}
-
-void pcibios_bus_add_device(struct pci_dev *pdev)
-{
-	dma_direct_set_offset(&pdev->dev, __pa(memory_start),
-			      __pa(memory_start) - memstart, memsize);
-}
-
-static int __init sh7786_pcie_core_init(void)
-{
-	/* Return the number of ports */
-	return test_mode_pin(MODE_PIN12) ? 3 : 2;
-}
-
-static void __init sh7786_pcie_init_hw(void *data, async_cookie_t cookie)
-{
-	struct sh7786_pcie_port *port = data;
-	int ret;
-
-	/*
-	 * Check if we are configured in endpoint or root complex mode,
-	 * this is a fixed pin setting that applies to all PCIe ports.
-	 */
-	port->endpoint = test_mode_pin(MODE_PIN11);
-
-	/*
-	 * Setup clocks, needed both for PHY and PCIe registers.
-	 */
-	ret = pcie_clk_init(port);
-	if (unlikely(ret < 0)) {
-		pr_err("clock initialization failed for port#%d\n",
-		       port->index);
-		return;
-	}
-
-	ret = phy_init(port);
-	if (unlikely(ret < 0)) {
-		pr_err("phy initialization failed for port#%d\n",
-		       port->index);
-		return;
-	}
-
-	ret = pcie_init(port);
-	if (unlikely(ret < 0)) {
-		pr_err("core initialization failed for port#%d\n",
-			       port->index);
-		return;
-	}
-
-	/* In the interest of preserving device ordering, synchronize */
-	async_synchronize_cookie(cookie);
-
-	register_pci_controller(port->hose);
-}
-
-static struct sh7786_pcie_hwops sh7786_65nm_pcie_hwops __initdata = {
-	.core_init	= sh7786_pcie_core_init,
-	.port_init_hw	= sh7786_pcie_init_hw,
-};
-
-static int __init sh7786_pcie_init(void)
-{
-	struct clk *platclk;
-	u32 mm_sel;
-	int i;
-
-	printk(KERN_NOTICE "PCI: Starting initialization.\n");
-
-	sh7786_pcie_hwops = &sh7786_65nm_pcie_hwops;
-
-	nr_ports = sh7786_pcie_hwops->core_init();
-	BUG_ON(nr_ports > ARRAY_SIZE(sh7786_pci_channels));
-
-	if (unlikely(nr_ports == 0))
-		return -ENODEV;
-
-	sh7786_pcie_ports = kcalloc(nr_ports, sizeof(struct sh7786_pcie_port),
-				    GFP_KERNEL);
-	if (unlikely(!sh7786_pcie_ports))
-		return -ENOMEM;
-
-	/*
-	 * Fetch any optional platform clock associated with this block.
-	 *
-	 * This is a rather nasty hack for boards with spec-mocking FPGAs
-	 * that have a secondary set of clocks outside of the on-chip
-	 * ones that need to be accounted for before there is any chance
-	 * of touching the existing MSTP bits or CPG clocks.
-	 */
-	platclk = clk_get(NULL, "pcie_plat_clk");
-	if (IS_ERR(platclk)) {
-		/* Sane hardware should probably get a WARN_ON.. */
-		platclk = NULL;
-	}
-
-	clk_enable(platclk);
-
-	mm_sel = sh7786_mm_sel();
-
-	/*
-	 * Depending on the MMSELR register value, the PCIe0 MEM 1
-	 * area may not be available. See Table 13.11 of the SH7786
-	 * datasheet.
-	 */
-	if (mm_sel != 1 && mm_sel != 2 && mm_sel != 5 && mm_sel != 6)
-		sh7786_pci0_resources[2].flags |= IORESOURCE_DISABLED;
-
-	printk(KERN_NOTICE "PCI: probing %d ports.\n", nr_ports);
-
-	for (i = 0; i < nr_ports; i++) {
-		struct sh7786_pcie_port *port = sh7786_pcie_ports + i;
-
-		port->index		= i;
-		port->hose		= sh7786_pci_channels + i;
-		port->hose->io_map_base	= port->hose->resources[0].start;
-
-		async_schedule(sh7786_pcie_hwops->port_init_hw, port);
-	}
-
-	async_synchronize_full();
-
-	return 0;
-}
-arch_initcall(sh7786_pcie_init);
diff --git a/arch/sh/drivers/pci/pcie-sh7786.h b/arch/sh/drivers/pci/pcie-sh7786.h
deleted file mode 100644
index ffe383681a0bd2..00000000000000
--- a/arch/sh/drivers/pci/pcie-sh7786.h
+++ /dev/null
@@ -1,577 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * SH7786 PCI-Express controller definitions.
- *
- * Copyright (C) 2008, 2009 Renesas Technology Corp.
- * All rights reserved.
- */
-#ifndef __PCI_SH7786_H
-#define __PCI_SH7786_H
-
-/* PCIe bus-0(x4) on SH7786 */			// Rev1.171
-#define SH4A_PCIE_SPW_BASE	0xFE000000	/* spw config address for controller 0 */
-#define SH4A_PCIE_SPW_BASE1	0xFE200000	/* spw config address for controller 1 (Rev1.14)*/
-#define SH4A_PCIE_SPW_BASE2	0xFCC00000	/* spw config address for controller 2 (Rev1.171)*/
-#define SH4A_PCIE_SPW_BASE_LEN	0x00080000
-
-#define SH4A_PCI_CNFG_BASE	0xFE040000	/* pci config address for controller 0 */
-#define SH4A_PCI_CNFG_BASE1	0xFE240000	/* pci config address for controller 1 (Rev1.14)*/
-#define SH4A_PCI_CNFG_BASE2	0xFCC40000	/* pci config address for controller 2 (Rev1.171)*/
-#define SH4A_PCI_CNFG_BASE_LEN	0x00040000
-
-#define SH4A_PCIPIO_ADDR_OFFSET	0x000001c0	/* offset to pci config_address */
-#define SH4A_PCIPIO_DATA_OFFSET	0x00000220	/* offset to pci config_data */
-
-/*
- * for PEX8111(Max Payload Size=128B,PCIIO_SIZE=64K),
- * for other(Max Payload Size=4096B,PCIIO_SIZE=8M)
- */
-
-/* PCI0: PCI memory target transfer 32-bit address translation value(Rev1.11T)*/
-#define SH4A_PCIBMSTR_TRANSLATION	0x20000000
-
-/*	SPVCR0		*/
-#define	SH4A_PCIEVCR0		(0x000000)	/* R - 0x0000 0000 32 */
-#define		BITS_TOP_MB	(24)
-#define		MASK_TOP_MB	(0xff<<BITS_TOP_MB)
-#define		BITS_BOT_MB	(16)
-#define		MASK_BOT_MB	(0xff<<BITS_BOT_MB)
-#define		BITS_VC_ID	(0)
-#define		MASK_VC_ID	(0xffff<<BITS_VC_ID)
-
-/*	SPVCR1		*/
-#define	SH4A_PCIEVCR1		(0x000004)	/* R - 0x0000 0000 32*/
-#define		BITS_BADOPC	(5)		/* 5 BADOPC 0 R/W */
-#define		MASK_BADOPC	(1<<BITS_BADOPC)
-#define		BITS_BADDEST	(4)		/*4 BADDEST 0 R/W  */
-#define		MASK_BADDEST	(1<<BITS_BADDEST)
-#define		BITS_UNSOLRESP	(3)		/* 3 UNSOLRESP 0 R/W  */
-#define		MASK_UNSOLRESP	(1<<BITS_UNSOLRESP)
-#define		BITS_ERRSNT	(1)		/* 1 ERRSNT 0 */
-#define		MASK_ERRSNT	(1<<BITS_ERRSNT)
-#define		BITS_ERRRCV	(0)		/* 0 ERRRCV 0 */
-#define		MASK_ERRRCV	(1<<BITS_ERRRCV)
-
-/*	PCIEENBLR	 */
-#define	SH4A_PCIEENBLR		(0x000008)	/* R/W - 0x0000 0001 32 */
-
-/*	PCIEECR		*/
-#define	SH4A_PCIEECR		(0x00000C)	/* R/W - 0x0000 0000 32 */
-#define		BITS_ENBL	(0)	/* 0 ENBL 0 R/W */
-#define		MASK_ENBL	(1<<BITS_ENBL)
-
-/*	PCIEPAR		*/
-#define	SH4A_PCIEPAR		(0x000010)	/* R/W - 0x0000 0000 32 */
-#define		BITS_BN		(24)
-#define		MASK_BN		(0xff<<BITS_BN)
-#define		BITS_DN		(19)
-#define		MASK_DN		(0x1f<<BITS_DN)
-#define		BITS_FN		(16)
-#define		MASK_FN		(0x7<<BITS_FN)
-#define		BITS_EREGNO	(8)
-#define		MASK_EREGNO	(0xff<<BITS_EREGNO)
-#define		BITS_REGNO	(2)
-#define		MASK_REGNO	(0x3f<<BITS_REGNO)
-
-/*	PCIEPCTLR	*/
-#define	SH4A_PCIEPCTLR		(0x000018)	/* R/W - 0x0000 0000 32 */
-#define		BITS_CCIE	(31)	/*  31 CCIE */
-#define		MASK_CCIE	(1<<BITS_CCIE)
-#define		BITS_TYPE	(8)
-#define		MASK_TYPE	(1<<BITS_TYPE)
-#define		BITS_C_VC	(0)
-#define		MASK_C_VC	(1<<BITS_C_VC)
-
-/*	PCIEPDR		*/
-#define	SH4A_PCIEPDR		(0x000020)	/* R/W - 0x0000 0000 32 */
-#define		BITS_PDR	(0)
-#define		MASK_PDR	(0xffffffff<<BITS_PDR)
-
-/*	PCIEMSGALR	*/
-#define	SH4A_PCIEMSGALR		(0x000030)	/* R/W - 0x0000 0000 32 */
-#define		BITS_MSGADRL	(0)
-#define		MASK_MSGADRL	(0xffffffff<<BITS_MSGADRL)
-
-/*	PCIEMSGAHR	*/
-#define	SH4A_PCIEMSGAHR		(0x000034)	/* R/W - 0x0000 0000 32 */
-#define		BITS_MSGADRH	(0)
-#define		MASK_MSGADRH	(0xffffffff<<BITS_MSGADRH)
-
-/*	PCIEMSGCTLR	*/
-#define	SH4A_PCIEMSGCTLR	(0x000038)	/* R/W - 0x0000 0000 32 */
-#define		BITS_MSGIE	(31)
-#define		MASK_MSGIE	(1<<BITS_MSGIE)
-#define		BITS_MROUTE	(16)
-#define		MASK_MROUTE	(0x7<<BITS_MROUTE)
-#define		BITS_MCODE	(8)
-#define		MASK_MCODE	(0xff<<BITS_MCODE)
-#define		BITS_M_VC	(0)
-#define		MASK_M_VC	(1<<BITS_M_VC)
-
-/*	PCIEMSG		*/
-#define	SH4A_PCIEMSG		(0x000040)	/* W - - 32	*/
-#define		BITS_MDATA	(0)
-#define		MASK_MDATA	(0xffffffff<<BITS_MDATA)
-
-/*	PCIEUNLOCKCR	*/
-#define	SH4A_PCIEUNLOCKCR	(0x000048)	/* R/W - 0x0000 0000 32 */
-
-/*	PCIEIDR		*/
-#define	SH4A_PCIEIDR		(0x000060)	/* R/W - 0x0101 1101 32 */
-
-/*	PCIEDBGCTLR	*/
-#define	SH4A_PCIEDBGCTLR	(0x000100)	/* R/W - 0x0000 0000 32 */
-
-/*	PCIEINTXR	*/
-#define	SH4A_PCIEINTXR		(0x004000)	/* R/W - 0x0000 0000 32 */
-
-/*	PCIERMSGR	*/
-#define	SH4A_PCIERMSGR		(0x004010)	/* R/W - 0x0000 0000 32 */
-
-/*	PCIERSTR	*/
-#define SH4A_PCIERSTR(x)	(0x008000 + ((x) * 0x4)) /* R/W - 0x0000 0000 32 */
-
-/*	PCIESRSTR	 */
-#define SH4A_PCIESRSTR		(0x008040)	/* R/W - 0x0000 0000 32 */
-
-/*	PCIEPHYCTLR	*/
-#define	SH4A_PCIEPHYCTLR	(0x010000)	/* R/W - 0x0000 0000 32 */
-#define		BITS_CKE	(0)
-#define		MASK_CKE	(1<<BITS_CKE)
-
-/*	PCIERMSGIER	*/
-#define	SH4A_PCIERMSGIER	(0x004040)	/* R/W - 0x0000 0000 32 */
-
-/*	PCIEPHYADRR	*/
-#define	SH4A_PCIEPHYADRR	(0x010004)	/* R/W - 0x0000 0000 32 */
-#define		BITS_ACK	(24)			// Rev1.171
-#define		MASK_ACK	(1<<BITS_ACK)		// Rev1.171
-#define		BITS_CMD	(16)			// Rev1.171
-#define		MASK_CMD	(0x03<<BITS_CMD)	// Rev1.171
-#define		BITS_LANE	(8)
-#define		MASK_LANE	(0x0f<<BITS_LANE)
-#define		BITS_ADR	(0)
-#define		MASK_ADR	(0xff<<BITS_ADR)
-
-/*	PCIEPHYDINR	*/							// Rev1.171 start.
-#define	SH4A_PCIEPHYDINR	(0x010008)	/* R/W - 0x0000 0000 32 */
-
-/*	PCIEPHYDOUTR	*/
-#define	SH4A_PCIEPHYDOUTR	(0x01000C)	/* R/W - 0x0000 0000 32 */
-
-/*	PCIEPHYSR	*/
-#define	SH4A_PCIEPHYSR		(0x010010)	/* R/W - 0x0000 0000 32 */	// Rev1.171 end.
-
-/*	PCIEPHYDATAR	*/
-#define	SH4A_PCIEPHYDATAR	(0x00008)	/* R/W - 0xxxxx xxxx 32 */
-#define		BITS_DATA	(0)
-#define		MASK_DATA	(0xffffffff<<BITS_DATA)
-
-/*	PCIETCTLR	*/
-#define	SH4A_PCIETCTLR		(0x020000)	/* R/W R/W 0x0000 0000 32 */
-#define		BITS_CFINT	(0)
-#define		MASK_CFINT	(1<<BITS_CFINT)
-
-/*	PCIETSTR	*/
-#define	SH4A_PCIETSTR		(0x020004)	/* R 0x0000 0000 32  */
-
-/*	PCIEINTR	*/
-#define	SH4A_PCIEINTR		(0x020008)	/* R/W R/W 0x0000 0000 32  */
-#define		BITS_INT_RX_ERP			(31)
-#define		MASK_INT_RX_ERP			(1<<BITS_INT_RX_ERP)
-#define		BITS_INT_RX_VCX_Posted		(30)
-#define		MASK_INT_RX_VCX_Posted		(1<<BITS_INT_RX_VCX_Posted)
-#define		BITS_INT_RX_VCX_NonPosted	(29)
-#define		MASK_INT_RX_VCX_NonPosted	(1<<BITS_INT_RX_VCX_NonPosted)
-#define		BITS_INT_RX_VCX_CPL		(28)
-#define		MASK_INT_RX_VCX_CPL		(1<<BITS_INT_RX_VCX_CPL)
-#define		BITS_INT_TX_VCX_Posted		(26)
-#define		MASK_INT_TX_VCX_Posted		(1<<BITS_INT_TX_VCX_Posted)
-#define		BITS_INT_TX_VCX_NonPosted	(25)
-#define		MASK_INT_TX_VCX_NonPosted	(1<<BITS_INT_TX_VCX_NonPosted)
-#define		BITS_INT_TX_VCX_CPL		(24)
-#define		MASK_INT_TX_VCX_CPL		(1<<BITS_INT_TX_VCX_CPL)
-#define		BITS_INT_RX_VC0_Posted		(22)
-#define		MASK_INT_RX_VC0_Posted		(1<<BITS_INT_RX_VC0_Posted)
-#define		BITS_INT_RX_VC0_NonPosted	(21)
-#define		MASK_INT_RX_VC0_NonPosted	(1<<BITS_INT_RX_VC0_NonPosted)
-#define		BITS_INT_RX_VC0_CPL		(20)
-#define		MASK_INT_RX_VC0_CPL		(1<<BITS_INT_RX_VC0_CPL)
-#define		BITS_INT_TX_VC0_Posted		(18)
-#define		MASK_INT_TX_VC0_Posted		(1<<BITS_INT_TX_VC0_Posted)
-#define		BITS_INT_TX_VC0_NonPosted	(17)
-#define		MASK_INT_TX_VC0_NonPosted	(1<<BITS_INT_TX_VC0_NonPosted)
-#define		BITS_INT_TX_VC0_CPL		(16)
-#define		MASK_INT_TX_VC0_CPL		(1<<BITS_INT_TX_VC0_CPL)
-#define		BITS_INT_RX_CTRL		(15)
-#define		MASK_INT_RX_CTRL		(1<<BITS_INT_RX_CTRL)
-#define		BITS_INT_TX_CTRL		(14)
-#define		MASK_INT_TX_CTRL		(1<<BITS_INT_TX_CTRL)
-#define		BITS_INTTL			(11)
-#define		MASK_INTTL			(1<<BITS_INTTL)
-#define		BITS_INTDL			(10)
-#define		MASK_INTDL			(1<<BITS_INTDL)
-#define		BITS_INTMAC			(9)
-#define		MASK_INTMAC			(1<<BITS_INTMAC)
-#define		BITS_INTPM			(8)
-#define		MASK_INTPM			(1<<BITS_INTPM)
-
-/*	PCIEINTER	*/
-#define	SH4A_PCIEINTER		(0x02000C)	/* R/W R/W 0x0000 0000 32 */
-#define		BITS_INT_RX_ERP			(31)
-#define		MASK_INT_RX_ERP			(1<<BITS_INT_RX_ERP)
-#define		BITS_INT_RX_VCX_Posted		(30)
-#define		MASK_INT_RX_VCX_Posted		(1<<BITS_INT_RX_VCX_Posted)
-#define		BITS_INT_RX_VCX_NonPosted	(29)
-#define		MASK_INT_RX_VCX_NonPosted	(1<<BITS_INT_RX_VCX_NonPosted)
-#define		BITS_INT_RX_VCX_CPL		(28)
-#define		MASK_INT_RX_VCX_CPL		(1<<BITS_INT_RX_VCX_CPL)
-#define		BITS_INT_TX_VCX_Posted		(26)
-#define		MASK_INT_TX_VCX_Posted		(1<<BITS_INT_TX_VCX_Posted)
-#define		BITS_INT_TX_VCX_NonPosted	(25)
-#define		MASK_INT_TX_VCX_NonPosted	(1<<BITS_INT_TX_VCX_NonPosted)
-#define		BITS_INT_TX_VCX_CPL		(24)
-#define		MASK_INT_TX_VCX_CPL		(1<<BITS_INT_TX_VCX_CPL)
-#define		BITS_INT_RX_VC0_Posted		(22)
-#define		MASK_INT_RX_VC0_Posted		(1<<BITS_INT_RX_VC0_Posted)
-#define		BITS_INT_RX_VC0_NonPosted	(21)
-#define		MASK_INT_RX_VC0_NonPosted	(1<<BITS_INT_RX_VC0_NonPosted)
-#define		BITS_INT_RX_VC0_CPL		(20)
-#define		MASK_INT_RX_VC0_CPL		(1<<BITS_INT_RX_VC0_CPL)
-#define		BITS_INT_TX_VC0_Posted		(18)
-#define		MASK_INT_TX_VC0_Posted		(1<<BITS_INT_TX_VC0_Posted)
-#define		BITS_INT_TX_VC0_NonPosted	(17)
-#define		MASK_INT_TX_VC0_NonPosted	(1<<BITS_INT_TX_VC0_NonPosted)
-#define		BITS_INT_TX_VC0_CPL		(16)
-#define		MASK_INT_TX_VC0_CPL		(1<<BITS_INT_TX_VC0_CPL)
-#define		BITS_INT_RX_CTRL		(15)
-#define		MASK_INT_RX_CTRL		(1<<BITS_INT_RX_CTRL)
-#define		BITS_INT_TX_CTRL		(14)
-#define		MASK_INT_TX_CTRL		(1<<BITS_INT_TX_CTRL)
-#define		BITS_INTTL			(11)
-#define		MASK_INTTL			(1<<BITS_INTTL)
-#define		BITS_INTDL			(10)
-#define		MASK_INTDL			(1<<BITS_INTDL)
-#define		BITS_INTMAC			(9)
-#define		MASK_INTMAC			(1<<BITS_INTMAC)
-#define		BITS_INTPM			(8)
-#define		MASK_INTPM			(1<<BITS_INTPM)
-
-/*	PCIEEH0R	*/
-#define SH4A_PCIEEHR(x)		(0x020010 + ((x) * 0x4)) /* R - 0x0000 0000 32 */
-
-/*	PCIEAIR	 */
-#define	SH4A_PCIEAIR		(SH4A_PCIE_BASE + 0x020010)	/* R/W R/W 0xxxxx xxxx 32 */
-
-/*	 PCIECIR	 */
-#define	SH4A_PCIECIR		(SH4A_PCIE_BASE)	/* R/W R/W 0xxxxx xxxx 32 */
-
-/*	 PCIEERRFR	 */								// Rev1.18
-#define	SH4A_PCIEERRFR		(0x020020)		/* R/W R/W 0xxxxx xxxx 32 */	// Rev1.18
-
-/*	PCIEERRFER	*/
-#define SH4A_PCIEERRFER		(0x020024)		/* R/W R/W 0x0000 0000 32 */
-
-/*	PCIEERRFR2	*/
-#define SH4A_PCIEERRFR2		(0x020028)		/* R/W R/W 0x0000 0000 32 */
-
-/*	PCIEMSIR	*/
-#define SH4A_PCIEMSIR		(0x020040)		/* R/W - 0x0000 0000 32 */
-
-/*	PCIEMSIFR	*/
-#define SH4A_PCIEMSIFR		(0x020044)		/* R/W R/W 0x0000 0000 32 */
-
-/*	PCIEPWRCTLR	*/
-#define SH4A_PCIEPWRCTLR	(0x020100)		/* R/W - 0x0000 0000 32 */
-
-/*	PCIEPCCTLR	*/
-#define SH4A_PCIEPCCTLR		(0x020180)		/* R/W - 0x0000 0000 32 */
-
-											// Rev1.18
-/*	PCIELAR0	*/
-#define	SH4A_PCIELAR0		(0x020200)	/* R/W R/W 0x0000 0000 32 */
-#define		BITS_LARn	(20)
-#define		MASK_LARn	(0xfff<<BITS_LARn)
-
-#define	SH4A_PCIE_020204	(0x020204)	/* R/W R/W 0x0000 0000 32 */
-
-/*	PCIELAMR0	*/
-#define	SH4A_PCIELAMR0		(0x020208)	/* R/W R/W 0x0000 0000 32 */
-#define		BITS_LAMRn	(20)
-#define		MASK_LAMRn	(0x1ff<<BITS_LAMRn)
-#define		BITS_LAREn	(0)
-#define		MASK_LAREn	(0x1<<BITS_LAREn)
-
-/*	PCIECSCR0	*/
-#define	SH4A_PCIECSCR0		(0x020210)	/* R/W R/W 0x0000 0000 32 */
-#define		BITS_RANGE	(2)
-#define		MASK_RANGE	(0x7<<BITS_RANGE)
-#define		BITS_SNPMD	(0)
-#define		MASK_SNPMD	(0x3<<BITS_SNPMD)
-
-/*	PCIECSAR0	*/
-#define	SH4A_PCIECSAR0		(0x020214)	/* R/W R/W 0x0000 0000 32 */
-#define		BITS_CSADR	(0)
-#define		MASK_CSADR	(0xffffffff<<BITS_CSADR)
-
-/*	PCIESTCTLR0	*/
-#define	SH4A_PCIESTCTLR0	(0x020218)	/* R/W R/W 0x0000 0000 32 */
-#define		BITS_SHPRI	(8)
-#define		MASK_SHPRI	(0x0f<<BITS_SHPRI)
-
-#define	SH4A_PCIE_020224	(0x020224)	/* R/W R/W 0x0000 0000 32 */
-
-#define	SH4A_PCIELAR1		(0x020220)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIELAMR1		(0x020228)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIECSCR1		(0x020230)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIECSAR1		(0x020234)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIESTCTLR1	(0x020238)	/* R/W R/W 0x0000 0000 32 */
-
-#define	SH4A_PCIELAR2		(0x020240)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIE_020244	(0x020244)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIELAMR2		(0x020248)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIECSCR2		(0x020250)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIECSAR2		(0x020254)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIESTCTLR2	(0x020258)	/* R/W R/W 0x0000 0000 32 */
-
-#define	SH4A_PCIELAR3		(0x020260)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIE_020264	(0x020264)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIELAMR3		(0x020268)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIECSCR3		(0x020270)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIECSAR3		(0x020274)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIESTCTLR3	(0x020278)	/* R/W R/W 0x0000 0000 32 */
-
-#define	SH4A_PCIELAR4		(0x020280)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIE_020284	(0x020284)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIELAMR4		(0x020288)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIECSCR4		(0x020290)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIECSAR4		(0x020294)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIESTCTLR4	(0x020298)	/* R/W R/W 0x0000 0000 32 */
-
-#define	SH4A_PCIELAR5		(0x0202A0)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIE_0202A4	(0x0202A4)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIELAMR5		(0x0202A8)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIECSCR5		(0x0202B0)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIECSAR5		(0x0202B4)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIESTCTLR5	(0x0202B8)	/* R/W R/W 0x0000 0000 32 */
-
-/*	PCIEPARL	*/
-#define	SH4A_PCIEPARL(x)	(0x020400 + ((x) * 0x20)) /* R/W R/W 0x0000 0000 32 */
-#define		BITS_PAL	(18)
-#define		MASK_PAL	(0x3fff<<BITS_PAL)
-
-/*	PCIEPARH	*/
-#define	SH4A_PCIEPARH(x)	(0x020404 + ((x) * 0x20)) /* R/W R/W 0x0000 0000 32 */
-#define		BITS_PAH	(0)
-#define		MASK_PAH	(0xffffffff<<BITS_PAH)
-
-/*	PCIEPAMR	 */
-#define	SH4A_PCIEPAMR(x)	(0x020408 + ((x) * 0x20)) /* R/W R/W 0x0000 0000 32 */
-#define		BITS_PAM	(18)
-#define		MASK_PAM	(0x3fff<<BITS_PAM)
-
-/*	PCIEPTCTLR	*/
-#define SH4A_PCIEPTCTLR(x)	(0x02040C + ((x) * 0x20))
-#define		BITS_PARE	(31)
-#define		MASK_PARE	(0x1<<BITS_PARE)
-#define		BITS_TC		(20)
-#define		MASK_TC		(0x7<<BITS_TC)
-#define		BITS_T_VC	(16)
-#define		MASK_T_VC	(0x1<<BITS_T_VC)
-#define		BITS_LOCK	(12)
-#define		MASK_LOCK	(0x1<<BITS_LOCK)
-#define		BITS_SPC	(8)
-#define		MASK_SPC	(0x1<<BITS_SPC)
-
-#define	SH4A_PCIEDMAOR		(0x021000)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMSAR0		(0x021100)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMSAHR0	(0x021104)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMDAR0		(0x021108)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMDAHR0	(0x02110C)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMBCNTR0	(0x021110)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMSBCNTR0	(0x021114)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMSTRR0	(0x021118)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMCCAR0	(0x02111C)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMCCR0		(0x021120)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMCC2R0	(0x021124)	/* R/W R/W 0x0000 0000 - */
-#define	SH4A_PCIEDMCCCR0	(0x021128)	/* R/W R/W 0x0000 0000 32 */
-#define SH4A_PCIEDMCHSR0	(0x02112C)	/* R/W - 0x0000 0000 32 */
-#define	SH4A_PCIEDMSAR1		(0x021140)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMSAHR1	(0x021144)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMDAR1		(0x021148)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMDAHR1	(0x02114C)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMBCNTR1	(0x021150)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMSBCNTR1	(0x021154)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMSTRR1	(0x021158)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMCCAR1	(0x02115C)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMCCR1		(0x021160)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMCC2R1	(0x021164)	/* R/W R/W 0x0000 0000 - */
-#define	SH4A_PCIEDMCCCR1	(0x021168)	/* R/W R/W 0x0000 0000 32 */
-#define SH4A_PCIEDMCHSR1	(0x02116C)	/* R/W - 0x0000 0000 32 */
-#define	SH4A_PCIEDMSAR2		(0x021180)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMSAHR2	(0x021184)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMDAR2		(0x021188)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMDAHR2	(0x02118C)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMBCNTR2	(0x021190)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMSBCNTR2	(0x021194)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMSTRR2	(0x021198)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMCCAR2	(0x02119C)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMCCR2		(0x0211A0)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMCC2R2	(0x0211A4)	/* R/W R/W 0x0000 0000 -  */
-#define	SH4A_PCIEDMCCCR2	(0x0211A8)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMSAR3		(0x0211C0)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMSAHR3	(0x0211C4)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMDAR3		(0x0211C8)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMDAHR3	(0x0211CC)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMBCNTR3	(0x0211D0)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMSBCNTR3	(0x0211D4)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMSTRR3	(0x0211D8)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMCCAR3	(0x0211DC)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMCCR3		(0x0211E0)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEDMCC2R3	(0x0211E4)	/* R/W R/W 0x0000 0000 -  */
-#define	SH4A_PCIEDMCCCR3	(0x0211E8)	/* R/W R/W 0x0000 0000 32 */
-#define SH4A_PCIEDMCHSR3	(0x0211EC)	/* R/W R/W 0x0000 0000 32 */
-#define	SH4A_PCIEPCICONF0	(0x040000)	/* R R - 8/16/32 */
-#define	SH4A_PCIEPCICONF1	(0x040004)	/* R/W R/W 0x0008 0000 8/16/32 */
-#define	SH4A_PCIEPCICONF2	(0x040008)	/* R/W R/W 0xFF00 0000 8/16/32 */
-#define	SH4A_PCIEPCICONF3	(0x04000C)	/* R/W R/W 0x0000 0000 8/16/32 */
-#define	SH4A_PCIEPCICONF4	(0x040010)	/* - R/W - 8/16/32 */
-#define	SH4A_PCIEPCICONF5	(0x040014)	/* - R/W - 8/16/32 */
-#define	SH4A_PCIEPCICONF6	(0x040018)	/* - R/W - 8/16/32 */
-#define	SH4A_PCIEPCICONF7	(0x04001C)	/* - R/W - 8/16/32 */
-#define	SH4A_PCIEPCICONF8	(0x040020)	/* - R/W - 8/16/32 */
-#define	SH4A_PCIEPCICONF9	(0x040024)	/* - R/W - 8/16/32 */
-#define	SH4A_PCIEPCICONF10	(0x040028)	/* R/W R/W 0x0000 0000 8/16/32 */
-#define	SH4A_PCIEPCICONF11	(0x04002C)	/* R/W R/W 0x0000 0000 8/16/32 */
-#define	SH4A_PCIEPCICONF12	(0x040030)	/* R/W R/W 0x0000 0000 8/16/32 */
-#define	SH4A_PCIEPCICONF13	(0x040034)	/* R/W R/W 0x0000 0040 8/16/32 */
-#define	SH4A_PCIEPCICONF14	(0x040038)	/* R/W R/W 0x0000 0000 8/16/32 */
-#define	SH4A_PCIEPCICONF15	(0x04003C)	/* R/W R/W 0x0000 00FF 8/16/32 */
-#define	SH4A_PCIEPMCAP0		(0x040040)	/* R/W R 0x0003 5001 8/16/32 */
-#define	SH4A_PCIEPMCAP1		(0x040044)	/* R/W R/W 0x0000 0000 8/16/32 */
-#define	SH4A_PCIEMSICAP0	(0x040050)	/* R/W R/W 0x0180 7005 8/16/32 */
-#define	SH4A_PCIEMSICAP1	(0x040054)	/* R/W R/W 0x0000 0000 8/16/32 */
-#define	SH4A_PCIEMSICAP2	(0x040058)	/* R/W R/W 0x0000 0000 8/16/32 */
-#define	SH4A_PCIEMSICAP3	(0x04005C)	/* R/W R/W 0x0000 0000 8/16/32 */
-#define	SH4A_PCIEMSICAP4	(0x040060)	/* R/W R/W 0x0000 0000 8/16/32 */
-#define	SH4A_PCIEMSICAP5	(0x040064)	/* R/W R/W 0x0000 0000 8/16/32 */
-#define	SH4A_PCIEEXPCAP0	(0x040070)	/* R/W R/W 0x0001 0010 8/16/32 */
-#define	SH4A_PCIEEXPCAP1	(0x040074)	/* R/W R 0x0000 0005 8/16/32 */
-#define	SH4A_PCIEEXPCAP2	(0x040078)	/* R/W R/W 0x0000 0801 8/16/32 */
-#define	SH4A_PCIEEXPCAP3	(0x04007C)	/* R/W R 0x0003 F421 8/16/32 */
-#define	SH4A_PCIEEXPCAP4	(0x040080)	/* R/W R/W 0x0041 0000 8/16/32 */
-#define	SH4A_PCIEEXPCAP5	(0x040084)	/* R/W R/W 0x0000 0000 8/16/32 */
-#define	SH4A_PCIEEXPCAP6	(0x040088)	/* R/W R/W 0x0000 03C0 8/16/32 */
-#define	SH4A_PCIEEXPCAP7	(0x04008C)	/* R/W R/W 0x0000 0000 8/16/32 */
-#define	SH4A_PCIEEXPCAP8	(0x040090)	/* R/W R/W 0x0000 0000 8/16/32 */
-#define	SH4A_PCIEVCCAP0		(0x040100)	/* R/W R 0x1B01 0002 8/16/32 */
-#define	SH4A_PCIEVCCAP1		(0x040104)	/* R R 0x0000 0001 8/16/32 */
-#define	SH4A_PCIEVCCAP2		(0x040108)	/* R R 0x0000 0000 8/16/32 */
-#define	SH4A_PCIEVCCAP3		(0x04010C)	/* R R/W 0x0000 0000 8/16/32 */
-#define	SH4A_PCIEVCCAP4		(0x040110)	/* R/W R/W 0x0000 0000 8/16/32 */
-#define	SH4A_PCIEVCCAP5		(0x040114)	/* R/W R/W 0x8000 00FF 8/16/32 */
-#define	SH4A_PCIEVCCAP6		(0x040118)	/* R/W R 0x0002 0000 8/16/32 */
-#define	SH4A_PCIEVCCAP7		(0x04011C)	/* R/W R/W 0x0000 0000 8/16/32 */
-#define	SH4A_PCIEVCCAP8		(0x040120)	/* R/W R/W 0x0000 0000 8/16/32 */
-#define	SH4A_PCIEVCCAP9		(0x040124)	/* R/W R 0x0002 0000 8/16/32 */
-#define	SH4A_PCIENUMCAP0	(0x0001B0)	/* RW R 0x0001 0003 8/16/32 */
-#define	SH4A_PCIENUMCAP1	(0x0001B4)	/* R R 0x0000 0000 8/16/32 */
-#define	SH4A_PCIENUMCAP2	(0x0001B8)	/* R R 0x0000 0000 8/16/32 */
-#define	SH4A_PCIEIDSETR0	(0x041000)	/* R/W R 0x0000 FFFF 16/32 */
-#define	SH4A_PCIEIDSETR1	(0x041004)	/* R/W R 0xFF00 0000 16/32 */
-#define	SH4A_PCIEBAR0SETR	(0x041008)	/* R/W R 0x0000 0000 16/32 */
-#define	SH4A_PCIEBAR1SETR	(0x04100C)	/* R/W R 0x0000 0000 16/32 */
-#define	SH4A_PCIEBAR2SETR	(0x041010)	/* R/W R 0x0000 0000 16/32 */
-#define	SH4A_PCIEBAR3SETR	(0x041014)	/* R/W R 0x0000 0000 16/32 */
-#define	SH4A_PCIEBAR4SETR	(0x041018)	/* R/W R 0x0000 0000 16/32 */
-#define	SH4A_PCIEBAR5SETR	(0x04101C)	/* R/W R 0x0000 0000 16/32 */
-#define	SH4A_PCIECISSETR	(0x041020)	/* R/W R 0x0000 0000 16/32 */
-#define	SH4A_PCIEIDSETR2	(0x041024)	/* R/W R 0x0000 0000 16/32 */
-#define	SH4A_PCIEEROMSETR	(0x041028)	/* R/W R 0x0000 0000 16/32 */
-#define	SH4A_PCIEDSERSETR0	(0x04102C)	/* R/W R 0x0000 0000 16/32 */
-#define	SH4A_PCIEDSERSETR1	(0x041030)	/* R/W R 0x0000 0000 16/32 */
-#define	SH4A_PCIECTLR		(0x041040)	/* R/W R 0x0000 0000 16/32 */
-#define	SH4A_PCIETLSR		(0x041044)	/* R/W1C R 0x0000 0000 16/32 */
-#define	SH4A_PCIETLCTLR		(0x041048)	/* R/W R 0x0000 0000 16/32 */
-#define	SH4A_PCIEDLSR		(0x04104C)	/* R/W1C R 0x4003 0000 16/32 */
-#define	SH4A_PCIEDLCTLR		(0x041050)	/* R R 0x0000 0000 16/32 */
-#define	SH4A_PCIEMACSR		(0x041054)	/* R/W1C R 0x0041 0000 16/32 */
-#define	SH4A_PCIEMACCTLR	(0x041058)	/* R/W R 0x0000 0000 16/32 */
-#define		PCIEMACCTLR_SCR_DIS	(1 << 27)	/* scramble disable */
-#define	SH4A_PCIEPMSTR		(0x04105C)	/* R/W1C R 0x0000 0000 16/32 */
-#define	SH4A_PCIEPMCTLR		(0x041060)	/* R/W R 0x0000 0000 16/32 */
-#define	SH4A_PCIETLINTENR	(0x041064)	/* R/W R 0x0000 0000 16/32 */
-#define	SH4A_PCIEDLINTENR	(0x041068)	/* R/W R 0x0000 0000 16/32 */
-#define		PCIEDLINTENR_DLL_ACT_ENABLE	(1 << 31) /* DL active irq */
-#define	SH4A_PCIEMACINTENR	(0x04106C)	/* R/W R 0x0000 0000 16/32 */
-#define	SH4A_PCIEPMINTENR	(0x041070)	/* R/W R 0x0000 0000 16/32 */
-#define	SH4A_PCIETXDCTLR	(0x044000)	/* R/W - H'00000000_00000000 32/64 */
-#define	SH4A_PCIETXCTLR		(0x044020)	/* R/W - H'00000000_00000000 32/64 */
-#define	SH4A_PCIETXSR		(0x044028)	/* R - H'00000000_00000000 32/64 */
-#define	SH4A_PCIETXVC0DCTLR	(0x044100)	/* R/W - H'00000000_00000000 32/64 */
-#define	SH4A_PCIETXVC0SR	(0x044108)	/* R/W - H'00888000_00000000 32/64 */
-#define	SH4A_PCIEVC0PDTXR	(0x044110)	/* W - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVC0PHTXR	(0x044118)	/* W - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVC0NPDTXR	(0x044120)	/* W - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVC0NPHTXR	(0x044128)	/* W - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVC0CDTXR	(0x044130)	/* W - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVC0CHTXR	(0x044138)	/* W - H'00000000_00000000 32/64 */
-#define	SH4A_PCIETXVCXDCTLR	(0x044200)	/* R/W - H'00000000_00000000 32/64 */
-#define	SH4A_PCIETXVCXSR	(0x044208)	/* R/W - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVCXPDTXR	(0x044210)	/* W - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVCXPHTXR	(0x044218)	/* W - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVCXNPDTXR	(0x044220)	/* W - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVCXNPHTXR	(0x044228)	/* W - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVCXCDTXR	(0x044230)	/* W - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVCXCHTXR	(0x044238)	/* W - H'00000000_00000000 32/64 */
-#define	SH4A_PCIERDCTLR		(0x046000)	/* RW - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEERPCTLR	(0x046008)	/* RW - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEERPHR		(0x046010)	/* R - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEERPERR		(0x046018)	/* R - H'00000000_00000000 32/64 */
-#define	SH4A_PCIERXVC0DCTLR	(0x046100)	/* RW - H'00000000_00000000 32/64 */
-#define	SH4A_PCIERXVC0SR	(0x046108)	/* RW - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVC0PDRXR	(0x046140)	/* R - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVC0PHRXR	(0x046148)	/* R - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVC0PERR	(0x046150)	/* R - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVC0NPDRXR	(0x046158)	/* R - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVC0NPHRXR	(0x046160)	/* R - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVC0NPERR	(0x046168)	/* R - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVC0CDRXR	(0x046170)	/* R - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVC0CHRXR	(0x046178)	/* R - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVC0CERR	(0x046180)	/* R - H'00000000_00000000 32/64 */
-#define	SH4A_PCIERXVCXDCTLR	(0x046200)	/* RW - H'00000000_00000000 32/64 */
-#define	SH4A_PCIERXVCXSR	(0x046208)	/* RW - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVCXPDRXR	(0x046240)	/* R - H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVCXPHRXR	(0x046248)	/* R H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVCXPERR	(0x046250)	/* R H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVCXNPDRXR	(0x046258)	/* R H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVCXNPHRXR	(0x046260)	/* R H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVCXNPERR	(0x046268)	/* R H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVCXCDRXR	(0x046270)	/* R H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVCXCHRXR	(0x046278)	/* R H'00000000_00000000 32/64 */
-#define	SH4A_PCIEVCXCERR	(0x046280)	/* R H'00000000_00000000 32/64 */
-
-/* SSI Register Definition for MSI WORK AROUND --hamada */
-#define SH4A_PCI_SSI_BASE	0xFFE00000	/* spw config address	*/
-#define SH4A_PCI_SSI_BASE_LEN	0x00100000	/* 1MB			*/
-
-#define	SH4A_SSICR0		(0x000000)
-#define	SH4A_SSICR1		(0x010000)
-#define	SH4A_SSICR2		(0x020000)
-#define	SH4A_SSICR3		(0x030000)
-
-#define PCI_REG(x)		((x) + 0x40000)
-
-static inline void
-pci_write_reg(struct pci_channel *chan, unsigned long val, unsigned long reg)
-{
-	__raw_writel(val, chan->reg_base + reg);
-}
-
-static inline unsigned long
-pci_read_reg(struct pci_channel *chan, unsigned long reg)
-{
-	return __raw_readl(chan->reg_base + reg);
-}
-
-#endif /* __PCI_SH7786_H */
diff --git a/arch/sh/drivers/platform_early.c b/arch/sh/drivers/platform_early.c
deleted file mode 100644
index 143747c45206fe..00000000000000
--- a/arch/sh/drivers/platform_early.c
+++ /dev/null
@@ -1,340 +0,0 @@
-// SPDX--License-Identifier: GPL-2.0
-
-#include <asm/platform_early.h>
-#include <linux/mod_devicetable.h>
-#include <linux/pm.h>
-
-static __initdata LIST_HEAD(sh_early_platform_driver_list);
-static __initdata LIST_HEAD(sh_early_platform_device_list);
-
-static const struct platform_device_id *
-platform_match_id(const struct platform_device_id *id,
-		  struct platform_device *pdev)
-{
-	while (id->name[0]) {
-		if (strcmp(pdev->name, id->name) == 0) {
-			pdev->id_entry = id;
-			return id;
-		}
-		id++;
-	}
-	return NULL;
-}
-
-static int platform_match(struct device *dev, struct device_driver *drv)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct platform_driver *pdrv = to_platform_driver(drv);
-
-	/* When driver_override is set, only bind to the matching driver */
-	if (pdev->driver_override)
-		return !strcmp(pdev->driver_override, drv->name);
-
-	/* Then try to match against the id table */
-	if (pdrv->id_table)
-		return platform_match_id(pdrv->id_table, pdev) != NULL;
-
-	/* fall-back to driver name match */
-	return (strcmp(pdev->name, drv->name) == 0);
-}
-
-#ifdef CONFIG_PM
-static void device_pm_init_common(struct device *dev)
-{
-	if (!dev->power.early_init) {
-		spin_lock_init(&dev->power.lock);
-		dev->power.qos = NULL;
-		dev->power.early_init = true;
-	}
-}
-
-static void pm_runtime_early_init(struct device *dev)
-{
-	dev->power.disable_depth = 1;
-	device_pm_init_common(dev);
-}
-#else
-static void pm_runtime_early_init(struct device *dev) {}
-#endif
-
-/**
- * sh_early_platform_driver_register - register early platform driver
- * @epdrv: sh_early_platform driver structure
- * @buf: string passed from early_param()
- *
- * Helper function for sh_early_platform_init() / sh_early_platform_init_buffer()
- */
-int __init sh_early_platform_driver_register(struct sh_early_platform_driver *epdrv,
-					  char *buf)
-{
-	char *tmp;
-	int n;
-
-	/* Simply add the driver to the end of the global list.
-	 * Drivers will by default be put on the list in compiled-in order.
-	 */
-	if (!epdrv->list.next) {
-		INIT_LIST_HEAD(&epdrv->list);
-		list_add_tail(&epdrv->list, &sh_early_platform_driver_list);
-	}
-
-	/* If the user has specified device then make sure the driver
-	 * gets prioritized. The driver of the last device specified on
-	 * command line will be put first on the list.
-	 */
-	n = strlen(epdrv->pdrv->driver.name);
-	if (buf && !strncmp(buf, epdrv->pdrv->driver.name, n)) {
-		list_move(&epdrv->list, &sh_early_platform_driver_list);
-
-		/* Allow passing parameters after device name */
-		if (buf[n] == '\0' || buf[n] == ',')
-			epdrv->requested_id = -1;
-		else {
-			epdrv->requested_id = simple_strtoul(&buf[n + 1],
-							     &tmp, 10);
-
-			if (buf[n] != '.' || (tmp == &buf[n + 1])) {
-				epdrv->requested_id = EARLY_PLATFORM_ID_ERROR;
-				n = 0;
-			} else
-				n += strcspn(&buf[n + 1], ",") + 1;
-		}
-
-		if (buf[n] == ',')
-			n++;
-
-		if (epdrv->bufsize) {
-			memcpy(epdrv->buffer, &buf[n],
-			       min_t(int, epdrv->bufsize, strlen(&buf[n]) + 1));
-			epdrv->buffer[epdrv->bufsize - 1] = '\0';
-		}
-	}
-
-	return 0;
-}
-
-/**
- * sh_early_platform_add_devices - adds a number of early platform devices
- * @devs: array of early platform devices to add
- * @num: number of early platform devices in array
- *
- * Used by early architecture code to register early platform devices and
- * their platform data.
- */
-void __init sh_early_platform_add_devices(struct platform_device **devs, int num)
-{
-	struct device *dev;
-	int i;
-
-	/* simply add the devices to list */
-	for (i = 0; i < num; i++) {
-		dev = &devs[i]->dev;
-
-		if (!dev->devres_head.next) {
-			pm_runtime_early_init(dev);
-			INIT_LIST_HEAD(&dev->devres_head);
-			list_add_tail(&dev->devres_head,
-				      &sh_early_platform_device_list);
-		}
-	}
-}
-
-/**
- * sh_early_platform_driver_register_all - register early platform drivers
- * @class_str: string to identify early platform driver class
- *
- * Used by architecture code to register all early platform drivers
- * for a certain class. If omitted then only early platform drivers
- * with matching kernel command line class parameters will be registered.
- */
-void __init sh_early_platform_driver_register_all(char *class_str)
-{
-	/* The "class_str" parameter may or may not be present on the kernel
-	 * command line. If it is present then there may be more than one
-	 * matching parameter.
-	 *
-	 * Since we register our early platform drivers using early_param()
-	 * we need to make sure that they also get registered in the case
-	 * when the parameter is missing from the kernel command line.
-	 *
-	 * We use parse_early_options() to make sure the early_param() gets
-	 * called at least once. The early_param() may be called more than
-	 * once since the name of the preferred device may be specified on
-	 * the kernel command line. sh_early_platform_driver_register() handles
-	 * this case for us.
-	 */
-	parse_early_options(class_str);
-}
-
-/**
- * sh_early_platform_match - find early platform device matching driver
- * @epdrv: early platform driver structure
- * @id: id to match against
- */
-static struct platform_device * __init
-sh_early_platform_match(struct sh_early_platform_driver *epdrv, int id)
-{
-	struct platform_device *pd;
-
-	list_for_each_entry(pd, &sh_early_platform_device_list, dev.devres_head)
-		if (platform_match(&pd->dev, &epdrv->pdrv->driver))
-			if (pd->id == id)
-				return pd;
-
-	return NULL;
-}
-
-/**
- * sh_early_platform_left - check if early platform driver has matching devices
- * @epdrv: early platform driver structure
- * @id: return true if id or above exists
- */
-static int __init sh_early_platform_left(struct sh_early_platform_driver *epdrv,
-				       int id)
-{
-	struct platform_device *pd;
-
-	list_for_each_entry(pd, &sh_early_platform_device_list, dev.devres_head)
-		if (platform_match(&pd->dev, &epdrv->pdrv->driver))
-			if (pd->id >= id)
-				return 1;
-
-	return 0;
-}
-
-/**
- * sh_early_platform_driver_probe_id - probe drivers matching class_str and id
- * @class_str: string to identify early platform driver class
- * @id: id to match against
- * @nr_probe: number of platform devices to successfully probe before exiting
- */
-static int __init sh_early_platform_driver_probe_id(char *class_str,
-						 int id,
-						 int nr_probe)
-{
-	struct sh_early_platform_driver *epdrv;
-	struct platform_device *match;
-	int match_id;
-	int n = 0;
-	int left = 0;
-
-	list_for_each_entry(epdrv, &sh_early_platform_driver_list, list) {
-		/* only use drivers matching our class_str */
-		if (strcmp(class_str, epdrv->class_str))
-			continue;
-
-		if (id == -2) {
-			match_id = epdrv->requested_id;
-			left = 1;
-
-		} else {
-			match_id = id;
-			left += sh_early_platform_left(epdrv, id);
-
-			/* skip requested id */
-			switch (epdrv->requested_id) {
-			case EARLY_PLATFORM_ID_ERROR:
-			case EARLY_PLATFORM_ID_UNSET:
-				break;
-			default:
-				if (epdrv->requested_id == id)
-					match_id = EARLY_PLATFORM_ID_UNSET;
-			}
-		}
-
-		switch (match_id) {
-		case EARLY_PLATFORM_ID_ERROR:
-			pr_warn("%s: unable to parse %s parameter\n",
-				class_str, epdrv->pdrv->driver.name);
-			fallthrough;
-		case EARLY_PLATFORM_ID_UNSET:
-			match = NULL;
-			break;
-		default:
-			match = sh_early_platform_match(epdrv, match_id);
-		}
-
-		if (match) {
-			/*
-			 * Set up a sensible init_name to enable
-			 * dev_name() and others to be used before the
-			 * rest of the driver core is initialized.
-			 */
-			if (!match->dev.init_name && slab_is_available()) {
-				if (match->id != -1)
-					match->dev.init_name =
-						kasprintf(GFP_KERNEL, "%s.%d",
-							  match->name,
-							  match->id);
-				else
-					match->dev.init_name =
-						kasprintf(GFP_KERNEL, "%s",
-							  match->name);
-
-				if (!match->dev.init_name)
-					return -ENOMEM;
-			}
-
-			if (epdrv->pdrv->probe(match))
-				pr_warn("%s: unable to probe %s early.\n",
-					class_str, match->name);
-			else
-				n++;
-		}
-
-		if (n >= nr_probe)
-			break;
-	}
-
-	if (left)
-		return n;
-	else
-		return -ENODEV;
-}
-
-/**
- * sh_early_platform_driver_probe - probe a class of registered drivers
- * @class_str: string to identify early platform driver class
- * @nr_probe: number of platform devices to successfully probe before exiting
- * @user_only: only probe user specified early platform devices
- *
- * Used by architecture code to probe registered early platform drivers
- * within a certain class. For probe to happen a registered early platform
- * device matching a registered early platform driver is needed.
- */
-int __init sh_early_platform_driver_probe(char *class_str,
-				       int nr_probe,
-				       int user_only)
-{
-	int k, n, i;
-
-	n = 0;
-	for (i = -2; n < nr_probe; i++) {
-		k = sh_early_platform_driver_probe_id(class_str, i, nr_probe - n);
-
-		if (k < 0)
-			break;
-
-		n += k;
-
-		if (user_only)
-			break;
-	}
-
-	return n;
-}
-
-/**
- * early_platform_cleanup - clean up early platform code
- */
-void __init early_platform_cleanup(void)
-{
-	struct platform_device *pd, *pd2;
-
-	/* clean up the devres list used to chain devices */
-	list_for_each_entry_safe(pd, pd2, &sh_early_platform_device_list,
-				 dev.devres_head) {
-		list_del(&pd->dev.devres_head);
-		memset(&pd->dev.devres_head, 0, sizeof(pd->dev.devres_head));
-	}
-}
diff --git a/arch/sh/drivers/push-switch.c b/arch/sh/drivers/push-switch.c
deleted file mode 100644
index c95f48ff3f6fb4..00000000000000
--- a/arch/sh/drivers/push-switch.c
+++ /dev/null
@@ -1,136 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Generic push-switch framework
- *
- * Copyright (C) 2006  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/module.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <asm/push-switch.h>
-
-#define DRV_NAME "push-switch"
-#define DRV_VERSION "0.1.1"
-
-static ssize_t switch_show(struct device *dev,
-			   struct device_attribute *attr,
-			   char *buf)
-{
-	struct push_switch_platform_info *psw_info = dev->platform_data;
-	return sprintf(buf, "%s\n", psw_info->name);
-}
-static DEVICE_ATTR_RO(switch);
-
-static void switch_timer(struct timer_list *t)
-{
-	struct push_switch *psw = from_timer(psw, t, debounce);
-
-	schedule_work(&psw->work);
-}
-
-static void switch_work_handler(struct work_struct *work)
-{
-	struct push_switch *psw = container_of(work, struct push_switch, work);
-	struct platform_device *pdev = psw->pdev;
-
-	psw->state = 0;
-
-	kobject_uevent(&pdev->dev.kobj, KOBJ_CHANGE);
-}
-
-static int switch_drv_probe(struct platform_device *pdev)
-{
-	struct push_switch_platform_info *psw_info;
-	struct push_switch *psw;
-	int ret, irq;
-
-	psw = kzalloc(sizeof(struct push_switch), GFP_KERNEL);
-	if (unlikely(!psw))
-		return -ENOMEM;
-
-	irq = platform_get_irq(pdev, 0);
-	if (unlikely(irq < 0)) {
-		ret = -ENODEV;
-		goto err;
-	}
-
-	psw_info = pdev->dev.platform_data;
-	BUG_ON(!psw_info);
-
-	ret = request_irq(irq, psw_info->irq_handler,
-			  psw_info->irq_flags,
-			  psw_info->name ? psw_info->name : DRV_NAME, pdev);
-	if (unlikely(ret < 0))
-		goto err;
-
-	if (psw_info->name) {
-		ret = device_create_file(&pdev->dev, &dev_attr_switch);
-		if (unlikely(ret)) {
-			dev_err(&pdev->dev, "Failed creating device attrs\n");
-			ret = -EINVAL;
-			goto err_irq;
-		}
-	}
-
-	INIT_WORK(&psw->work, switch_work_handler);
-	timer_setup(&psw->debounce, switch_timer, 0);
-
-	/* Workqueue API brain-damage */
-	psw->pdev = pdev;
-
-	platform_set_drvdata(pdev, psw);
-
-	return 0;
-
-err_irq:
-	free_irq(irq, pdev);
-err:
-	kfree(psw);
-	return ret;
-}
-
-static int switch_drv_remove(struct platform_device *pdev)
-{
-	struct push_switch *psw = platform_get_drvdata(pdev);
-	struct push_switch_platform_info *psw_info = pdev->dev.platform_data;
-	int irq = platform_get_irq(pdev, 0);
-
-	if (psw_info->name)
-		device_remove_file(&pdev->dev, &dev_attr_switch);
-
-	platform_set_drvdata(pdev, NULL);
-	flush_work(&psw->work);
-	timer_shutdown_sync(&psw->debounce);
-	free_irq(irq, pdev);
-
-	kfree(psw);
-
-	return 0;
-}
-
-static struct platform_driver switch_driver = {
-	.probe		= switch_drv_probe,
-	.remove		= switch_drv_remove,
-	.driver		= {
-		.name	= DRV_NAME,
-	},
-};
-
-static int __init switch_init(void)
-{
-	printk(KERN_NOTICE DRV_NAME ": version %s loaded\n", DRV_VERSION);
-	return platform_driver_register(&switch_driver);
-}
-
-static void __exit switch_exit(void)
-{
-	platform_driver_unregister(&switch_driver);
-}
-module_init(switch_init);
-module_exit(switch_exit);
-
-MODULE_VERSION(DRV_VERSION);
-MODULE_AUTHOR("Paul Mundt");
-MODULE_LICENSE("GPL v2");
diff --git a/arch/sh/drivers/superhyway/Makefile b/arch/sh/drivers/superhyway/Makefile
deleted file mode 100644
index aa6e3267c055d9..00000000000000
--- a/arch/sh/drivers/superhyway/Makefile
+++ /dev/null
@@ -1,7 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the SuperHyway specific kernel interface routines under Linux.
-#
-
-obj-$(CONFIG_CPU_SUBTYPE_SH4_202)	+= ops-sh4-202.o
-
diff --git a/arch/sh/drivers/superhyway/ops-sh4-202.c b/arch/sh/drivers/superhyway/ops-sh4-202.c
deleted file mode 100644
index 490142274e3b0a..00000000000000
--- a/arch/sh/drivers/superhyway/ops-sh4-202.c
+++ /dev/null
@@ -1,168 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/drivers/superhyway/ops-sh4-202.c
- *
- * SuperHyway bus support for SH4-202
- *
- * Copyright (C) 2005  Paul Mundt
- */
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/superhyway.h>
-#include <linux/string.h>
-#include <asm/addrspace.h>
-#include <asm/io.h>
-
-#define PHYS_EMI_CBLOCK		P4SEGADDR(0x1ec00000)
-#define PHYS_EMI_DBLOCK		P4SEGADDR(0x08000000)
-#define PHYS_FEMI_CBLOCK	P4SEGADDR(0x1f800000)
-#define PHYS_FEMI_DBLOCK	P4SEGADDR(0x00000000)
-
-#define PHYS_EPBR_BLOCK		P4SEGADDR(0x1de00000)
-#define PHYS_DMAC_BLOCK		P4SEGADDR(0x1fa00000)
-#define PHYS_PBR_BLOCK		P4SEGADDR(0x1fc00000)
-
-static struct resource emi_resources[] = {
-	[0] = {
-		.start	= PHYS_EMI_CBLOCK,
-		.end	= PHYS_EMI_CBLOCK + 0x00300000 - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= PHYS_EMI_DBLOCK,
-		.end	= PHYS_EMI_DBLOCK + 0x08000000 - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct superhyway_device emi_device = {
-	.name		= "emi",
-	.num_resources	= ARRAY_SIZE(emi_resources),
-	.resource	= emi_resources,
-};
-
-static struct resource femi_resources[] = {
-	[0] = {
-		.start	= PHYS_FEMI_CBLOCK,
-		.end	= PHYS_FEMI_CBLOCK + 0x00100000 - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= PHYS_FEMI_DBLOCK,
-		.end	= PHYS_FEMI_DBLOCK + 0x08000000 - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct superhyway_device femi_device = {
-	.name		= "femi",
-	.num_resources	= ARRAY_SIZE(femi_resources),
-	.resource	= femi_resources,
-};
-
-static struct resource epbr_resources[] = {
-	[0] = {
-		.start	= P4SEGADDR(0x1e7ffff8),
-		.end	= P4SEGADDR(0x1e7ffff8 + (sizeof(u32) * 2) - 1),
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= PHYS_EPBR_BLOCK,
-		.end	= PHYS_EPBR_BLOCK + 0x00a00000 - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct superhyway_device epbr_device = {
-	.name		= "epbr",
-	.num_resources	= ARRAY_SIZE(epbr_resources),
-	.resource	= epbr_resources,
-};
-
-static struct resource dmac_resource = {
-	.start	= PHYS_DMAC_BLOCK,
-	.end	= PHYS_DMAC_BLOCK + 0x00100000 - 1,
-	.flags	= IORESOURCE_MEM,
-};
-
-static struct superhyway_device dmac_device = {
-	.name		= "dmac",
-	.num_resources	= 1,
-	.resource	= &dmac_resource,
-};
-
-static struct resource pbr_resources[] = {
-	[0] = {
-		.start	= P4SEGADDR(0x1ffffff8),
-		.end	= P4SEGADDR(0x1ffffff8 + (sizeof(u32) * 2) - 1),
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= PHYS_PBR_BLOCK,
-		.end	= PHYS_PBR_BLOCK + 0x00400000 - (sizeof(u32) * 2) - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct superhyway_device pbr_device = {
-	.name		= "pbr",
-	.num_resources	= ARRAY_SIZE(pbr_resources),
-	.resource	= pbr_resources,
-};
-
-static struct superhyway_device *sh4202_devices[] __initdata = {
-	&emi_device, &femi_device, &epbr_device, &dmac_device, &pbr_device,
-};
-
-static int sh4202_read_vcr(unsigned long base, struct superhyway_vcr_info *vcr)
-{
-	u32 vcrh, vcrl;
-	u64 tmp;
-
-	/*
-	 * XXX: Even though the SH4-202 Evaluation Device documentation
-	 * indicates that VCRL is mapped first with VCRH at a + 0x04
-	 * offset, the opposite seems to be true.
-	 *
-	 * Some modules (PBR and ePBR for instance) also appear to have
-	 * VCRL/VCRH flipped in the documentation, but on the SH4-202
-	 * itself it appears that these are all consistently mapped with
-	 * VCRH preceding VCRL.
-	 *
-	 * Do not trust the documentation, for it is evil.
-	 */
-	vcrh = __raw_readl(base);
-	vcrl = __raw_readl(base + sizeof(u32));
-
-	tmp = ((u64)vcrh << 32) | vcrl;
-	memcpy(vcr, &tmp, sizeof(u64));
-
-	return 0;
-}
-
-static int sh4202_write_vcr(unsigned long base, struct superhyway_vcr_info vcr)
-{
-	u64 tmp = *(u64 *)&vcr;
-
-	__raw_writel((tmp >> 32) & 0xffffffff, base);
-	__raw_writel(tmp & 0xffffffff, base + sizeof(u32));
-
-	return 0;
-}
-
-static struct superhyway_ops sh4202_superhyway_ops = {
-	.read_vcr	= sh4202_read_vcr,
-	.write_vcr	= sh4202_write_vcr,
-};
-
-struct superhyway_bus superhyway_channels[] = {
-	{ &sh4202_superhyway_ops, },
-	{ 0, },
-};
-
-int __init superhyway_scan_bus(struct superhyway_bus *bus)
-{
-	return superhyway_add_devices(bus, sh4202_devices,
-				      ARRAY_SIZE(sh4202_devices));
-}
-
diff --git a/arch/sh/include/asm/Kbuild b/arch/sh/include/asm/Kbuild
deleted file mode 100644
index fc44d9c88b4191..00000000000000
--- a/arch/sh/include/asm/Kbuild
+++ /dev/null
@@ -1,5 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-generated-y += syscall_table.h
-generic-y += kvm_para.h
-generic-y += mcs_spinlock.h
-generic-y += parport.h
diff --git a/arch/sh/include/asm/adc.h b/arch/sh/include/asm/adc.h
deleted file mode 100644
index feccfe639e3896..00000000000000
--- a/arch/sh/include/asm/adc.h
+++ /dev/null
@@ -1,12 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_ADC_H
-#define __ASM_ADC_H
-/*
- * Copyright (C) 2004  Andriy Skulysh
- */
-
-#include <cpu/adc.h>
-
-int adc_single(unsigned int channel);
-
-#endif /* __ASM_ADC_H */
diff --git a/arch/sh/include/asm/addrspace.h b/arch/sh/include/asm/addrspace.h
deleted file mode 100644
index 468fba333e896b..00000000000000
--- a/arch/sh/include/asm/addrspace.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * Copyright (C) 1999 by Kaz Kojima
- *
- * Defitions for the address spaces of the SH CPUs.
- */
-#ifndef __ASM_SH_ADDRSPACE_H
-#define __ASM_SH_ADDRSPACE_H
-
-#include <cpu/addrspace.h>
-
-/* If this CPU supports segmentation, hook up the helpers */
-#ifdef P1SEG
-
-/*
-   [ P0/U0 (virtual) ]		0x00000000     <------ User space
-   [ P1 (fixed)   cached ]	0x80000000     <------ Kernel space
-   [ P2 (fixed)  non-cachable]	0xA0000000     <------ Physical access
-   [ P3 (virtual) cached]	0xC0000000     <------ vmalloced area
-   [ P4 control   ]		0xE0000000
- */
-
-/* Returns the privileged segment base of a given address  */
-#define PXSEG(a)	(((unsigned long)(a)) & 0xe0000000)
-
-#ifdef CONFIG_29BIT
-/*
- * Map an address to a certain privileged segment
- */
-#define P1SEGADDR(a)	\
-	((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | P1SEG))
-#define P2SEGADDR(a)	\
-	((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | P2SEG))
-#define P3SEGADDR(a)	\
-	((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | P3SEG))
-#define P4SEGADDR(a)	\
-	((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | P4SEG))
-#else
-/*
- * These will never work in 32-bit, don't even bother.
- */
-#define P1SEGADDR(a)	({ (void)(a); BUG(); NULL; })
-#define P2SEGADDR(a)	({ (void)(a); BUG(); NULL; })
-#define P3SEGADDR(a)	({ (void)(a); BUG(); NULL; })
-#define P4SEGADDR(a)	({ (void)(a); BUG(); NULL; })
-#endif
-#endif /* P1SEG */
-
-/* Check if an address can be reached in 29 bits */
-#define IS_29BIT(a)	(((unsigned long)(a)) < 0x20000000)
-
-#ifdef CONFIG_SH_STORE_QUEUES
-/*
- * This is a special case for the SH-4 store queues, as pages for this
- * space still need to be faulted in before it's possible to flush the
- * store queue cache for writeout to the remapped region.
- */
-#define P3_ADDR_MAX		(P4SEG_STORE_QUE + 0x04000000)
-#else
-#define P3_ADDR_MAX		P4SEG
-#endif
-
-#endif /* __ASM_SH_ADDRSPACE_H */
diff --git a/arch/sh/include/asm/alignment.h b/arch/sh/include/asm/alignment.h
deleted file mode 100644
index 4f3e715b8c2668..00000000000000
--- a/arch/sh/include/asm/alignment.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_ALIGNMENT_H
-#define __ASM_SH_ALIGNMENT_H
-
-#include <linux/types.h>
-
-extern void inc_unaligned_byte_access(void);
-extern void inc_unaligned_word_access(void);
-extern void inc_unaligned_dword_access(void);
-extern void inc_unaligned_multi_access(void);
-extern void inc_unaligned_user_access(void);
-extern void inc_unaligned_kernel_access(void);
-
-#define UM_WARN		(1 << 0)
-#define UM_FIXUP	(1 << 1)
-#define UM_SIGNAL	(1 << 2)
-
-extern unsigned int unaligned_user_action(void);
-
-extern void unaligned_fixups_notify(struct task_struct *, insn_size_t, struct pt_regs *);
-
-#endif /* __ASM_SH_ALIGNMENT_H */
diff --git a/arch/sh/include/asm/asm-offsets.h b/arch/sh/include/asm/asm-offsets.h
deleted file mode 100644
index 9f8535716392cc..00000000000000
--- a/arch/sh/include/asm/asm-offsets.h
+++ /dev/null
@@ -1,2 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <generated/asm-offsets.h>
diff --git a/arch/sh/include/asm/atomic-grb.h b/arch/sh/include/asm/atomic-grb.h
deleted file mode 100644
index 059791fd394fc4..00000000000000
--- a/arch/sh/include/asm/atomic-grb.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_ATOMIC_GRB_H
-#define __ASM_SH_ATOMIC_GRB_H
-
-#define ATOMIC_OP(op)							\
-static inline void arch_atomic_##op(int i, atomic_t *v)			\
-{									\
-	int tmp;							\
-									\
-	__asm__ __volatile__ (						\
-		"   .align 2              \n\t"				\
-		"   mova    1f,   r0      \n\t" /* r0 = end point */	\
-		"   mov    r15,   r1      \n\t" /* r1 = saved sp */	\
-		"   mov    #-6,   r15     \n\t" /* LOGIN: r15 = size */	\
-		"   mov.l  @%1,   %0      \n\t" /* load  old value */	\
-		" " #op "   %2,   %0      \n\t" /* $op */		\
-		"   mov.l   %0,   @%1     \n\t" /* store new value */	\
-		"1: mov     r1,   r15     \n\t" /* LOGOUT */		\
-		: "=&r" (tmp),						\
-		  "+r"  (v)						\
-		: "r"   (i)						\
-		: "memory" , "r0", "r1");				\
-}									\
-
-#define ATOMIC_OP_RETURN(op)						\
-static inline int arch_atomic_##op##_return(int i, atomic_t *v)		\
-{									\
-	int tmp;							\
-									\
-	__asm__ __volatile__ (						\
-		"   .align 2              \n\t"				\
-		"   mova    1f,   r0      \n\t" /* r0 = end point */	\
-		"   mov    r15,   r1      \n\t" /* r1 = saved sp */	\
-		"   mov    #-6,   r15     \n\t" /* LOGIN: r15 = size */	\
-		"   mov.l  @%1,   %0      \n\t" /* load  old value */	\
-		" " #op "   %2,   %0      \n\t" /* $op */		\
-		"   mov.l   %0,   @%1     \n\t" /* store new value */	\
-		"1: mov     r1,   r15     \n\t" /* LOGOUT */		\
-		: "=&r" (tmp),						\
-		  "+r"  (v)						\
-		: "r"   (i)						\
-		: "memory" , "r0", "r1");				\
-									\
-	return tmp;							\
-}
-
-#define ATOMIC_FETCH_OP(op)						\
-static inline int arch_atomic_fetch_##op(int i, atomic_t *v)		\
-{									\
-	int res, tmp;							\
-									\
-	__asm__ __volatile__ (						\
-		"   .align 2              \n\t"				\
-		"   mova    1f,   r0      \n\t" /* r0 = end point */	\
-		"   mov    r15,   r1      \n\t" /* r1 = saved sp */	\
-		"   mov    #-6,   r15     \n\t" /* LOGIN: r15 = size */	\
-		"   mov.l  @%2,   %0      \n\t" /* load old value */	\
-		"   mov     %0,   %1      \n\t" /* save old value */	\
-		" " #op "   %3,   %0      \n\t" /* $op */		\
-		"   mov.l   %0,   @%2     \n\t" /* store new value */	\
-		"1: mov     r1,   r15     \n\t" /* LOGOUT */		\
-		: "=&r" (tmp), "=&r" (res), "+r"  (v)			\
-		: "r"   (i)						\
-		: "memory" , "r0", "r1");				\
-									\
-	return res;							\
-}
-
-#define ATOMIC_OPS(op) ATOMIC_OP(op) ATOMIC_OP_RETURN(op) ATOMIC_FETCH_OP(op)
-
-ATOMIC_OPS(add)
-ATOMIC_OPS(sub)
-
-#undef ATOMIC_OPS
-#define ATOMIC_OPS(op) ATOMIC_OP(op) ATOMIC_FETCH_OP(op)
-
-ATOMIC_OPS(and)
-ATOMIC_OPS(or)
-ATOMIC_OPS(xor)
-
-#undef ATOMIC_OPS
-#undef ATOMIC_FETCH_OP
-#undef ATOMIC_OP_RETURN
-#undef ATOMIC_OP
-
-#endif /* __ASM_SH_ATOMIC_GRB_H */
diff --git a/arch/sh/include/asm/atomic-irq.h b/arch/sh/include/asm/atomic-irq.h
deleted file mode 100644
index 7665de9d00d0d1..00000000000000
--- a/arch/sh/include/asm/atomic-irq.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_ATOMIC_IRQ_H
-#define __ASM_SH_ATOMIC_IRQ_H
-
-#include <linux/irqflags.h>
-
-/*
- * To get proper branch prediction for the main line, we must branch
- * forward to code at the end of this object's .text section, then
- * branch back to restart the operation.
- */
-
-#define ATOMIC_OP(op, c_op)						\
-static inline void arch_atomic_##op(int i, atomic_t *v)			\
-{									\
-	unsigned long flags;						\
-									\
-	raw_local_irq_save(flags);					\
-	v->counter c_op i;						\
-	raw_local_irq_restore(flags);					\
-}
-
-#define ATOMIC_OP_RETURN(op, c_op)					\
-static inline int arch_atomic_##op##_return(int i, atomic_t *v)		\
-{									\
-	unsigned long temp, flags;					\
-									\
-	raw_local_irq_save(flags);					\
-	temp = v->counter;						\
-	temp c_op i;							\
-	v->counter = temp;						\
-	raw_local_irq_restore(flags);					\
-									\
-	return temp;							\
-}
-
-#define ATOMIC_FETCH_OP(op, c_op)					\
-static inline int arch_atomic_fetch_##op(int i, atomic_t *v)		\
-{									\
-	unsigned long temp, flags;					\
-									\
-	raw_local_irq_save(flags);					\
-	temp = v->counter;						\
-	v->counter c_op i;						\
-	raw_local_irq_restore(flags);					\
-									\
-	return temp;							\
-}
-
-#define ATOMIC_OPS(op, c_op)						\
-	ATOMIC_OP(op, c_op)						\
-	ATOMIC_OP_RETURN(op, c_op)					\
-	ATOMIC_FETCH_OP(op, c_op)
-
-ATOMIC_OPS(add, +=)
-ATOMIC_OPS(sub, -=)
-
-#undef ATOMIC_OPS
-#define ATOMIC_OPS(op, c_op)						\
-	ATOMIC_OP(op, c_op)						\
-	ATOMIC_FETCH_OP(op, c_op)
-
-ATOMIC_OPS(and, &=)
-ATOMIC_OPS(or, |=)
-ATOMIC_OPS(xor, ^=)
-
-#undef ATOMIC_OPS
-#undef ATOMIC_FETCH_OP
-#undef ATOMIC_OP_RETURN
-#undef ATOMIC_OP
-
-#endif /* __ASM_SH_ATOMIC_IRQ_H */
diff --git a/arch/sh/include/asm/atomic-llsc.h b/arch/sh/include/asm/atomic-llsc.h
deleted file mode 100644
index b63dcfbfa14ef5..00000000000000
--- a/arch/sh/include/asm/atomic-llsc.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_ATOMIC_LLSC_H
-#define __ASM_SH_ATOMIC_LLSC_H
-
-/*
- * SH-4A note:
- *
- * We basically get atomic_xxx_return() for free compared with
- * atomic_xxx(). movli.l/movco.l require r0 due to the instruction
- * encoding, so the retval is automatically set without having to
- * do any special work.
- */
-/*
- * To get proper branch prediction for the main line, we must branch
- * forward to code at the end of this object's .text section, then
- * branch back to restart the operation.
- */
-
-#define ATOMIC_OP(op)							\
-static inline void arch_atomic_##op(int i, atomic_t *v)			\
-{									\
-	unsigned long tmp;						\
-									\
-	__asm__ __volatile__ (						\
-"1:	movli.l @%2, %0		! atomic_" #op "\n"			\
-"	" #op "	%1, %0				\n"			\
-"	movco.l	%0, @%2				\n"			\
-"	bf	1b				\n"			\
-	: "=&z" (tmp)							\
-	: "r" (i), "r" (&v->counter)					\
-	: "t");								\
-}
-
-#define ATOMIC_OP_RETURN(op)						\
-static inline int arch_atomic_##op##_return(int i, atomic_t *v)		\
-{									\
-	unsigned long temp;						\
-									\
-	__asm__ __volatile__ (						\
-"1:	movli.l @%2, %0		! atomic_" #op "_return	\n"		\
-"	" #op "	%1, %0					\n"		\
-"	movco.l	%0, @%2					\n"		\
-"	bf	1b					\n"		\
-"	synco						\n"		\
-	: "=&z" (temp)							\
-	: "r" (i), "r" (&v->counter)					\
-	: "t");								\
-									\
-	return temp;							\
-}
-
-#define ATOMIC_FETCH_OP(op)						\
-static inline int arch_atomic_fetch_##op(int i, atomic_t *v)		\
-{									\
-	unsigned long res, temp;					\
-									\
-	__asm__ __volatile__ (						\
-"1:	movli.l @%3, %0		! atomic_fetch_" #op "	\n"		\
-"	mov %0, %1					\n"		\
-"	" #op "	%2, %0					\n"		\
-"	movco.l	%0, @%3					\n"		\
-"	bf	1b					\n"		\
-"	synco						\n"		\
-	: "=&z" (temp), "=&r" (res)					\
-	: "r" (i), "r" (&v->counter)					\
-	: "t");								\
-									\
-	return res;							\
-}
-
-#define ATOMIC_OPS(op) ATOMIC_OP(op) ATOMIC_OP_RETURN(op) ATOMIC_FETCH_OP(op)
-
-ATOMIC_OPS(add)
-ATOMIC_OPS(sub)
-
-#undef ATOMIC_OPS
-#define ATOMIC_OPS(op) ATOMIC_OP(op) ATOMIC_FETCH_OP(op)
-
-ATOMIC_OPS(and)
-ATOMIC_OPS(or)
-ATOMIC_OPS(xor)
-
-#undef ATOMIC_OPS
-#undef ATOMIC_FETCH_OP
-#undef ATOMIC_OP_RETURN
-#undef ATOMIC_OP
-
-#endif /* __ASM_SH_ATOMIC_LLSC_H */
diff --git a/arch/sh/include/asm/atomic.h b/arch/sh/include/asm/atomic.h
deleted file mode 100644
index 528bfeda78f569..00000000000000
--- a/arch/sh/include/asm/atomic.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_ATOMIC_H
-#define __ASM_SH_ATOMIC_H
-
-#if defined(CONFIG_CPU_J2)
-
-#include <asm-generic/atomic.h>
-
-#else
-
-/*
- * Atomic operations that C can't guarantee us.  Useful for
- * resource counting etc..
- *
- */
-
-#include <linux/compiler.h>
-#include <linux/types.h>
-#include <asm/cmpxchg.h>
-#include <asm/barrier.h>
-
-#define arch_atomic_read(v)		READ_ONCE((v)->counter)
-#define arch_atomic_set(v,i)		WRITE_ONCE((v)->counter, (i))
-
-#if defined(CONFIG_GUSA_RB)
-#include <asm/atomic-grb.h>
-#elif defined(CONFIG_CPU_SH4A)
-#include <asm/atomic-llsc.h>
-#else
-#include <asm/atomic-irq.h>
-#endif
-
-#define arch_atomic_xchg(v, new)	(arch_xchg(&((v)->counter), new))
-#define arch_atomic_cmpxchg(v, o, n)	(arch_cmpxchg(&((v)->counter), (o), (n)))
-
-#endif /* CONFIG_CPU_J2 */
-
-#endif /* __ASM_SH_ATOMIC_H */
diff --git a/arch/sh/include/asm/barrier.h b/arch/sh/include/asm/barrier.h
deleted file mode 100644
index 0d58a0159aa6dc..00000000000000
--- a/arch/sh/include/asm/barrier.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 1999, 2000  Niibe Yutaka  &  Kaz Kojima
- * Copyright (C) 2002 Paul Mundt
- */
-#ifndef __ASM_SH_BARRIER_H
-#define __ASM_SH_BARRIER_H
-
-#if defined(CONFIG_CPU_SH4A)
-#include <asm/cache_insns.h>
-#endif
-
-/*
- * A brief note on ctrl_barrier(), the control register write barrier.
- *
- * Legacy SH cores typically require a sequence of 8 nops after
- * modification of a control register in order for the changes to take
- * effect. On newer cores (like the sh4a and sh5) this is accomplished
- * with icbi.
- *
- * Also note that on sh4a in the icbi case we can forego a synco for the
- * write barrier, as it's not necessary for control registers.
- *
- * Historically we have only done this type of barrier for the MMUCR, but
- * it's also necessary for the CCR, so we make it generic here instead.
- */
-#if defined(CONFIG_CPU_SH4A)
-#define mb()		__asm__ __volatile__ ("synco": : :"memory")
-#define rmb()		mb()
-#define wmb()		mb()
-#define ctrl_barrier()	__icbi(PAGE_OFFSET)
-#else
-#if defined(CONFIG_CPU_J2) && defined(CONFIG_SMP)
-#define __smp_mb()	do { int tmp = 0; __asm__ __volatile__ ("cas.l %0,%0,@%1" : "+r"(tmp) : "z"(&tmp) : "memory", "t"); } while(0)
-#define __smp_rmb()	__smp_mb()
-#define __smp_wmb()	__smp_mb()
-#endif
-#define ctrl_barrier()	__asm__ __volatile__ ("nop;nop;nop;nop;nop;nop;nop;nop")
-#endif
-
-#define __smp_store_mb(var, value) do { (void)xchg(&var, value); } while (0)
-
-#include <asm-generic/barrier.h>
-
-#endif /* __ASM_SH_BARRIER_H */
diff --git a/arch/sh/include/asm/bitops-cas.h b/arch/sh/include/asm/bitops-cas.h
deleted file mode 100644
index ba517b3f24da62..00000000000000
--- a/arch/sh/include/asm/bitops-cas.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_BITOPS_CAS_H
-#define __ASM_SH_BITOPS_CAS_H
-
-static inline unsigned __bo_cas(volatile unsigned *p, unsigned old, unsigned new)
-{
-	__asm__ __volatile__("cas.l %1,%0,@r0"
-		: "+r"(new)
-		: "r"(old), "z"(p)
-		: "t", "memory" );
-	return new;
-}
-
-static inline void set_bit(int nr, volatile void *addr)
-{
-	unsigned mask, old;
-	volatile unsigned *a = addr;
-
-	a += nr >> 5;
-	mask = 1U << (nr & 0x1f);
-
-	do old = *a;
-	while (__bo_cas(a, old, old|mask) != old);
-}
-
-static inline void clear_bit(int nr, volatile void *addr)
-{
-	unsigned mask, old;
-	volatile unsigned *a = addr;
-
-	a += nr >> 5;
-	mask = 1U << (nr & 0x1f);
-
-	do old = *a;
-	while (__bo_cas(a, old, old&~mask) != old);
-}
-
-static inline void change_bit(int nr, volatile void *addr)
-{
-	unsigned mask, old;
-	volatile unsigned *a = addr;
-
-	a += nr >> 5;
-	mask = 1U << (nr & 0x1f);
-
-	do old = *a;
-	while (__bo_cas(a, old, old^mask) != old);
-}
-
-static inline int test_and_set_bit(int nr, volatile void *addr)
-{
-	unsigned mask, old;
-	volatile unsigned *a = addr;
-
-	a += nr >> 5;
-	mask = 1U << (nr & 0x1f);
-
-	do old = *a;
-	while (__bo_cas(a, old, old|mask) != old);
-
-	return !!(old & mask);
-}
-
-static inline int test_and_clear_bit(int nr, volatile void *addr)
-{
-	unsigned mask, old;
-	volatile unsigned *a = addr;
-
-	a += nr >> 5;
-	mask = 1U << (nr & 0x1f);
-
-	do old = *a;
-	while (__bo_cas(a, old, old&~mask) != old);
-
-	return !!(old & mask);
-}
-
-static inline int test_and_change_bit(int nr, volatile void *addr)
-{
-	unsigned mask, old;
-	volatile unsigned *a = addr;
-
-	a += nr >> 5;
-	mask = 1U << (nr & 0x1f);
-
-	do old = *a;
-	while (__bo_cas(a, old, old^mask) != old);
-
-	return !!(old & mask);
-}
-
-#include <asm-generic/bitops/non-atomic.h>
-
-#endif /* __ASM_SH_BITOPS_CAS_H */
diff --git a/arch/sh/include/asm/bitops-grb.h b/arch/sh/include/asm/bitops-grb.h
deleted file mode 100644
index 75b5980399d44d..00000000000000
--- a/arch/sh/include/asm/bitops-grb.h
+++ /dev/null
@@ -1,173 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_BITOPS_GRB_H
-#define __ASM_SH_BITOPS_GRB_H
-
-static inline void set_bit(int nr, volatile void * addr)
-{
-	int	mask;
-	volatile unsigned int *a = addr;
-	unsigned long tmp;
-
-	a += nr >> 5;
-	mask = 1 << (nr & 0x1f);
-
-        __asm__ __volatile__ (
-                "   .align 2              \n\t"
-                "   mova    1f,   r0      \n\t" /* r0 = end point */
-                "   mov    r15,   r1      \n\t" /* r1 = saved sp */
-                "   mov    #-6,   r15     \n\t" /* LOGIN: r15 = size */
-                "   mov.l  @%1,   %0      \n\t" /* load  old value */
-                "   or      %2,   %0      \n\t" /* or */
-                "   mov.l   %0,   @%1     \n\t" /* store new value */
-                "1: mov     r1,   r15     \n\t" /* LOGOUT */
-                : "=&r" (tmp),
-                  "+r"  (a)
-                : "r"   (mask)
-                : "memory" , "r0", "r1");
-}
-
-static inline void clear_bit(int nr, volatile void * addr)
-{
-	int	mask;
-	volatile unsigned int *a = addr;
-        unsigned long tmp;
-
-	a += nr >> 5;
-        mask = ~(1 << (nr & 0x1f));
-        __asm__ __volatile__ (
-                "   .align 2              \n\t"
-                "   mova    1f,   r0      \n\t" /* r0 = end point */
-                "   mov    r15,   r1      \n\t" /* r1 = saved sp */
-                "   mov    #-6,   r15     \n\t" /* LOGIN: r15 = size */
-                "   mov.l  @%1,   %0      \n\t" /* load  old value */
-                "   and     %2,   %0      \n\t" /* and */
-                "   mov.l   %0,   @%1     \n\t" /* store new value */
-                "1: mov     r1,   r15     \n\t" /* LOGOUT */
-                : "=&r" (tmp),
-                  "+r"  (a)
-                : "r"   (mask)
-                : "memory" , "r0", "r1");
-}
-
-static inline void change_bit(int nr, volatile void * addr)
-{
-        int     mask;
-        volatile unsigned int *a = addr;
-        unsigned long tmp;
-
-        a += nr >> 5;
-        mask = 1 << (nr & 0x1f);
-        __asm__ __volatile__ (
-                "   .align 2              \n\t"
-                "   mova    1f,   r0      \n\t" /* r0 = end point */
-                "   mov    r15,   r1      \n\t" /* r1 = saved sp */
-                "   mov    #-6,   r15     \n\t" /* LOGIN: r15 = size */
-                "   mov.l  @%1,   %0      \n\t" /* load  old value */
-                "   xor     %2,   %0      \n\t" /* xor */
-                "   mov.l   %0,   @%1     \n\t" /* store new value */
-                "1: mov     r1,   r15     \n\t" /* LOGOUT */
-                : "=&r" (tmp),
-                  "+r"  (a)
-                : "r"   (mask)
-                : "memory" , "r0", "r1");
-}
-
-static inline int test_and_set_bit(int nr, volatile void * addr)
-{
-        int     mask, retval;
-	volatile unsigned int *a = addr;
-        unsigned long tmp;
-
-	a += nr >> 5;
-	mask = 1 << (nr & 0x1f);
-
-        __asm__ __volatile__ (
-                "   .align 2              \n\t"
-                "   mova    1f,   r0      \n\t" /* r0 = end point */
-                "   mov    r15,   r1      \n\t" /* r1 = saved sp */
-                "   mov   #-14,   r15     \n\t" /* LOGIN: r15 = size */
-                "   mov.l  @%2,   %0      \n\t" /* load old value */
-                "   mov     %0,   %1      \n\t"
-                "   tst     %1,   %3      \n\t" /* T = ((*a & mask) == 0) */
-                "   mov    #-1,   %1      \n\t" /* retvat = -1 */
-                "   negc    %1,   %1      \n\t" /* retval = (mask & *a) != 0 */
-                "   or      %3,   %0      \n\t"
-                "   mov.l   %0,  @%2      \n\t" /* store new value */
-                "1: mov     r1,  r15      \n\t" /* LOGOUT */
-                : "=&r" (tmp),
-                  "=&r" (retval),
-                  "+r"  (a)
-                : "r"   (mask)
-                : "memory" , "r0", "r1" ,"t");
-
-        return retval;
-}
-
-static inline int test_and_clear_bit(int nr, volatile void * addr)
-{
-        int     mask, retval,not_mask;
-        volatile unsigned int *a = addr;
-        unsigned long tmp;
-
-        a += nr >> 5;
-        mask = 1 << (nr & 0x1f);
-
-	not_mask = ~mask;
-
-        __asm__ __volatile__ (
-                "   .align 2              \n\t"
-		"   mova    1f,   r0      \n\t" /* r0 = end point */
-                "   mov    r15,   r1      \n\t" /* r1 = saved sp */
-		"   mov   #-14,   r15     \n\t" /* LOGIN */
-		"   mov.l  @%2,   %0      \n\t" /* load old value */
-                "   mov     %0,   %1      \n\t" /* %1 = *a */
-                "   tst     %1,   %3      \n\t" /* T = ((*a & mask) == 0) */
-		"   mov    #-1,   %1      \n\t" /* retvat = -1 */
-                "   negc    %1,   %1      \n\t" /* retval = (mask & *a) != 0 */
-                "   and     %4,   %0      \n\t"
-                "   mov.l   %0,  @%2      \n\t" /* store new value */
-		"1: mov     r1,   r15     \n\t" /* LOGOUT */
-		: "=&r" (tmp),
-		  "=&r" (retval),
-		  "+r"  (a)
-		: "r"   (mask),
-		  "r"   (not_mask)
-		: "memory" , "r0", "r1", "t");
-
-        return retval;
-}
-
-static inline int test_and_change_bit(int nr, volatile void * addr)
-{
-        int     mask, retval;
-        volatile unsigned int *a = addr;
-        unsigned long tmp;
-
-        a += nr >> 5;
-        mask = 1 << (nr & 0x1f);
-
-        __asm__ __volatile__ (
-                "   .align 2              \n\t"
-                "   mova    1f,   r0      \n\t" /* r0 = end point */
-                "   mov    r15,   r1      \n\t" /* r1 = saved sp */
-                "   mov   #-14,   r15     \n\t" /* LOGIN */
-                "   mov.l  @%2,   %0      \n\t" /* load old value */
-                "   mov     %0,   %1      \n\t" /* %1 = *a */
-                "   tst     %1,   %3      \n\t" /* T = ((*a & mask) == 0) */
-                "   mov    #-1,   %1      \n\t" /* retvat = -1 */
-                "   negc    %1,   %1      \n\t" /* retval = (mask & *a) != 0 */
-                "   xor     %3,   %0      \n\t"
-                "   mov.l   %0,  @%2      \n\t" /* store new value */
-                "1: mov     r1,   r15     \n\t" /* LOGOUT */
-                : "=&r" (tmp),
-                  "=&r" (retval),
-                  "+r"  (a)
-                : "r"   (mask)
-                : "memory" , "r0", "r1", "t");
-
-        return retval;
-}
-
-#include <asm-generic/bitops/non-atomic.h>
-
-#endif /* __ASM_SH_BITOPS_GRB_H */
diff --git a/arch/sh/include/asm/bitops-llsc.h b/arch/sh/include/asm/bitops-llsc.h
deleted file mode 100644
index 47036845fc6837..00000000000000
--- a/arch/sh/include/asm/bitops-llsc.h
+++ /dev/null
@@ -1,147 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_BITOPS_LLSC_H
-#define __ASM_SH_BITOPS_LLSC_H
-
-static inline void set_bit(int nr, volatile void *addr)
-{
-	int	mask;
-	volatile unsigned int *a = addr;
-	unsigned long tmp;
-
-	a += nr >> 5;
-	mask = 1 << (nr & 0x1f);
-
-	__asm__ __volatile__ (
-		"1:						\n\t"
-		"movli.l	@%1, %0	! set_bit		\n\t"
-		"or		%2, %0				\n\t"
-		"movco.l	%0, @%1				\n\t"
-		"bf		1b				\n\t"
-		: "=&z" (tmp)
-		: "r" (a), "r" (mask)
-		: "t", "memory"
-	);
-}
-
-static inline void clear_bit(int nr, volatile void *addr)
-{
-	int	mask;
-	volatile unsigned int *a = addr;
-	unsigned long tmp;
-
-	a += nr >> 5;
-	mask = 1 << (nr & 0x1f);
-
-	__asm__ __volatile__ (
-		"1:						\n\t"
-		"movli.l	@%1, %0	! clear_bit		\n\t"
-		"and		%2, %0				\n\t"
-		"movco.l	%0, @%1				\n\t"
-		"bf		1b				\n\t"
-		: "=&z" (tmp)
-		: "r" (a), "r" (~mask)
-		: "t", "memory"
-	);
-}
-
-static inline void change_bit(int nr, volatile void *addr)
-{
-	int	mask;
-	volatile unsigned int *a = addr;
-	unsigned long tmp;
-
-	a += nr >> 5;
-	mask = 1 << (nr & 0x1f);
-
-	__asm__ __volatile__ (
-		"1:						\n\t"
-		"movli.l	@%1, %0	! change_bit		\n\t"
-		"xor		%2, %0				\n\t"
-		"movco.l	%0, @%1				\n\t"
-		"bf		1b				\n\t"
-		: "=&z" (tmp)
-		: "r" (a), "r" (mask)
-		: "t", "memory"
-	);
-}
-
-static inline int test_and_set_bit(int nr, volatile void *addr)
-{
-	int	mask, retval;
-	volatile unsigned int *a = addr;
-	unsigned long tmp;
-
-	a += nr >> 5;
-	mask = 1 << (nr & 0x1f);
-
-	__asm__ __volatile__ (
-		"1:						\n\t"
-		"movli.l	@%2, %0	! test_and_set_bit	\n\t"
-		"mov		%0, %1				\n\t"
-		"or		%3, %0				\n\t"
-		"movco.l	%0, @%2				\n\t"
-		"bf		1b				\n\t"
-		"and		%3, %1				\n\t"
-		: "=&z" (tmp), "=&r" (retval)
-		: "r" (a), "r" (mask)
-		: "t", "memory"
-	);
-
-	return retval != 0;
-}
-
-static inline int test_and_clear_bit(int nr, volatile void *addr)
-{
-	int	mask, retval;
-	volatile unsigned int *a = addr;
-	unsigned long tmp;
-
-	a += nr >> 5;
-	mask = 1 << (nr & 0x1f);
-
-	__asm__ __volatile__ (
-		"1:						\n\t"
-		"movli.l	@%2, %0	! test_and_clear_bit	\n\t"
-		"mov		%0, %1				\n\t"
-		"and		%4, %0				\n\t"
-		"movco.l	%0, @%2				\n\t"
-		"bf		1b				\n\t"
-		"and		%3, %1				\n\t"
-		"synco						\n\t"
-		: "=&z" (tmp), "=&r" (retval)
-		: "r" (a), "r" (mask), "r" (~mask)
-		: "t", "memory"
-	);
-
-	return retval != 0;
-}
-
-static inline int test_and_change_bit(int nr, volatile void *addr)
-{
-	int	mask, retval;
-	volatile unsigned int *a = addr;
-	unsigned long tmp;
-
-	a += nr >> 5;
-	mask = 1 << (nr & 0x1f);
-
-	__asm__ __volatile__ (
-		"1:						\n\t"
-		"movli.l	@%2, %0	! test_and_change_bit	\n\t"
-		"mov		%0, %1				\n\t"
-		"xor		%3, %0				\n\t"
-		"movco.l	%0, @%2				\n\t"
-		"bf		1b				\n\t"
-		"and		%3, %1				\n\t"
-		"synco						\n\t"
-		: "=&z" (tmp), "=&r" (retval)
-		: "r" (a), "r" (mask)
-		: "t", "memory"
-	);
-
-	return retval != 0;
-}
-
-#include <asm-generic/bitops/non-atomic.h>
-
-#endif /* __ASM_SH_BITOPS_LLSC_H */
diff --git a/arch/sh/include/asm/bitops-op32.h b/arch/sh/include/asm/bitops-op32.h
deleted file mode 100644
index 5ace89b4650791..00000000000000
--- a/arch/sh/include/asm/bitops-op32.h
+++ /dev/null
@@ -1,143 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_BITOPS_OP32_H
-#define __ASM_SH_BITOPS_OP32_H
-
-#include <linux/bits.h>
-
-/*
- * The bit modifying instructions on SH-2A are only capable of working
- * with a 3-bit immediate, which signifies the shift position for the bit
- * being worked on.
- */
-#if defined(__BIG_ENDIAN)
-#define BITOP_LE_SWIZZLE	((BITS_PER_LONG-1) & ~0x7)
-#define BYTE_NUMBER(nr)		((nr ^ BITOP_LE_SWIZZLE) / BITS_PER_BYTE)
-#define BYTE_OFFSET(nr)		((nr ^ BITOP_LE_SWIZZLE) % BITS_PER_BYTE)
-#else
-#define BYTE_NUMBER(nr)		((nr) / BITS_PER_BYTE)
-#define BYTE_OFFSET(nr)		((nr) % BITS_PER_BYTE)
-#endif
-
-static __always_inline void
-arch___set_bit(unsigned long nr, volatile unsigned long *addr)
-{
-	if (__builtin_constant_p(nr)) {
-		__asm__ __volatile__ (
-			"bset.b %1, @(%O2,%0)		! __set_bit\n\t"
-			: "+r" (addr)
-			: "i" (BYTE_OFFSET(nr)), "i" (BYTE_NUMBER(nr))
-			: "t", "memory"
-		);
-	} else {
-		unsigned long mask = BIT_MASK(nr);
-		unsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);
-
-		*p |= mask;
-	}
-}
-
-static __always_inline void
-arch___clear_bit(unsigned long nr, volatile unsigned long *addr)
-{
-	if (__builtin_constant_p(nr)) {
-		__asm__ __volatile__ (
-			"bclr.b %1, @(%O2,%0)		! __clear_bit\n\t"
-			: "+r" (addr)
-			: "i" (BYTE_OFFSET(nr)),
-			  "i" (BYTE_NUMBER(nr))
-			: "t", "memory"
-		);
-	} else {
-		unsigned long mask = BIT_MASK(nr);
-		unsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);
-
-		*p &= ~mask;
-	}
-}
-
-/**
- * arch___change_bit - Toggle a bit in memory
- * @nr: the bit to change
- * @addr: the address to start counting from
- *
- * Unlike change_bit(), this function is non-atomic and may be reordered.
- * If it's called on the same region of memory simultaneously, the effect
- * may be that only one operation succeeds.
- */
-static __always_inline void
-arch___change_bit(unsigned long nr, volatile unsigned long *addr)
-{
-	if (__builtin_constant_p(nr)) {
-		__asm__ __volatile__ (
-			"bxor.b %1, @(%O2,%0)		! __change_bit\n\t"
-			: "+r" (addr)
-			: "i" (BYTE_OFFSET(nr)),
-			  "i" (BYTE_NUMBER(nr))
-			: "t", "memory"
-		);
-	} else {
-		unsigned long mask = BIT_MASK(nr);
-		unsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);
-
-		*p ^= mask;
-	}
-}
-
-/**
- * arch___test_and_set_bit - Set a bit and return its old value
- * @nr: Bit to set
- * @addr: Address to count from
- *
- * This operation is non-atomic and can be reordered.
- * If two examples of this operation race, one can appear to succeed
- * but actually fail.  You must protect multiple accesses with a lock.
- */
-static __always_inline bool
-arch___test_and_set_bit(unsigned long nr, volatile unsigned long *addr)
-{
-	unsigned long mask = BIT_MASK(nr);
-	unsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);
-	unsigned long old = *p;
-
-	*p = old | mask;
-	return (old & mask) != 0;
-}
-
-/**
- * arch___test_and_clear_bit - Clear a bit and return its old value
- * @nr: Bit to clear
- * @addr: Address to count from
- *
- * This operation is non-atomic and can be reordered.
- * If two examples of this operation race, one can appear to succeed
- * but actually fail.  You must protect multiple accesses with a lock.
- */
-static __always_inline bool
-arch___test_and_clear_bit(unsigned long nr, volatile unsigned long *addr)
-{
-	unsigned long mask = BIT_MASK(nr);
-	unsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);
-	unsigned long old = *p;
-
-	*p = old & ~mask;
-	return (old & mask) != 0;
-}
-
-/* WARNING: non atomic and it can be reordered! */
-static __always_inline bool
-arch___test_and_change_bit(unsigned long nr, volatile unsigned long *addr)
-{
-	unsigned long mask = BIT_MASK(nr);
-	unsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);
-	unsigned long old = *p;
-
-	*p = old ^ mask;
-	return (old & mask) != 0;
-}
-
-#define arch_test_bit generic_test_bit
-#define arch_test_bit_acquire generic_test_bit_acquire
-
-#include <asm-generic/bitops/non-instrumented-non-atomic.h>
-
-#endif /* __ASM_SH_BITOPS_OP32_H */
diff --git a/arch/sh/include/asm/bitops.h b/arch/sh/include/asm/bitops.h
deleted file mode 100644
index 10ceb0d6b5a997..00000000000000
--- a/arch/sh/include/asm/bitops.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_BITOPS_H
-#define __ASM_SH_BITOPS_H
-
-#ifndef _LINUX_BITOPS_H
-#error only <linux/bitops.h> can be included directly
-#endif
-
-/* For __swab32 */
-#include <asm/byteorder.h>
-#include <asm/barrier.h>
-
-#ifdef CONFIG_GUSA_RB
-#include <asm/bitops-grb.h>
-#elif defined(CONFIG_CPU_SH2A)
-#include <asm-generic/bitops/atomic.h>
-#include <asm/bitops-op32.h>
-#elif defined(CONFIG_CPU_SH4A)
-#include <asm/bitops-llsc.h>
-#elif defined(CONFIG_CPU_J2) && defined(CONFIG_SMP)
-#include <asm/bitops-cas.h>
-#else
-#include <asm-generic/bitops/atomic.h>
-#include <asm-generic/bitops/non-atomic.h>
-#endif
-
-static inline unsigned long ffz(unsigned long word)
-{
-	unsigned long result;
-
-	__asm__("1:\n\t"
-		"shlr	%1\n\t"
-		"bt/s	1b\n\t"
-		" add	#1, %0"
-		: "=r" (result), "=r" (word)
-		: "0" (~0L), "1" (word)
-		: "t");
-	return result;
-}
-
-/**
- * __ffs - find first bit in word.
- * @word: The word to search
- *
- * Undefined if no bit exists, so code should check against 0 first.
- */
-static inline unsigned long __ffs(unsigned long word)
-{
-	unsigned long result;
-
-	__asm__("1:\n\t"
-		"shlr	%1\n\t"
-		"bf/s	1b\n\t"
-		" add	#1, %0"
-		: "=r" (result), "=r" (word)
-		: "0" (~0L), "1" (word)
-		: "t");
-	return result;
-}
-
-#include <asm-generic/bitops/ffs.h>
-#include <asm-generic/bitops/hweight.h>
-#include <asm-generic/bitops/lock.h>
-#include <asm-generic/bitops/sched.h>
-#include <asm-generic/bitops/ext2-atomic.h>
-#include <asm-generic/bitops/fls.h>
-#include <asm-generic/bitops/__fls.h>
-#include <asm-generic/bitops/fls64.h>
-
-#include <asm-generic/bitops/le.h>
-
-#endif /* __ASM_SH_BITOPS_H */
diff --git a/arch/sh/include/asm/bl_bit.h b/arch/sh/include/asm/bl_bit.h
deleted file mode 100644
index 5d04f2c6256376..00000000000000
--- a/arch/sh/include/asm/bl_bit.h
+++ /dev/null
@@ -1,2 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <asm/bl_bit_32.h>
diff --git a/arch/sh/include/asm/bl_bit_32.h b/arch/sh/include/asm/bl_bit_32.h
deleted file mode 100644
index 1f7d225fc604f8..00000000000000
--- a/arch/sh/include/asm/bl_bit_32.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_BL_BIT_32_H
-#define __ASM_SH_BL_BIT_32_H
-
-static inline void set_bl_bit(void)
-{
-	unsigned long __dummy0, __dummy1;
-
-	__asm__ __volatile__ (
-		"stc	sr, %0\n\t"
-		"or	%2, %0\n\t"
-		"and	%3, %0\n\t"
-		"ldc	%0, sr\n\t"
-		: "=&r" (__dummy0), "=r" (__dummy1)
-		: "r" (0x10000000), "r" (0xffffff0f)
-		: "memory"
-	);
-}
-
-static inline void clear_bl_bit(void)
-{
-	unsigned long __dummy0, __dummy1;
-
-	__asm__ __volatile__ (
-		"stc	sr, %0\n\t"
-		"and	%2, %0\n\t"
-		"ldc	%0, sr\n\t"
-		: "=&r" (__dummy0), "=r" (__dummy1)
-		: "1" (~0x10000000)
-		: "memory"
-	);
-}
-
-#endif /* __ASM_SH_BL_BIT_32_H */
diff --git a/arch/sh/include/asm/bug.h b/arch/sh/include/asm/bug.h
deleted file mode 100644
index 05a485c4fabcfc..00000000000000
--- a/arch/sh/include/asm/bug.h
+++ /dev/null
@@ -1,121 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_BUG_H
-#define __ASM_SH_BUG_H
-
-#include <linux/linkage.h>
-
-#define TRAPA_BUG_OPCODE	0xc33e	/* trapa #0x3e */
-#define BUGFLAG_UNWINDER	(1 << 1)
-
-#ifdef CONFIG_GENERIC_BUG
-#define HAVE_ARCH_BUG
-#define HAVE_ARCH_WARN_ON
-
-/**
- * _EMIT_BUG_ENTRY
- * %1 - __FILE__
- * %2 - __LINE__
- * %3 - trap type
- * %4 - sizeof(struct bug_entry)
- *
- * The trapa opcode itself sits in %0.
- * The %O notation is used to avoid # generation.
- *
- * The offending file and line are encoded in the __bug_table section.
- */
-#ifdef CONFIG_DEBUG_BUGVERBOSE
-#define _EMIT_BUG_ENTRY				\
-	"\t.pushsection __bug_table,\"aw\"\n"	\
-	"2:\t.long 1b, %O1\n"			\
-	"\t.short %O2, %O3\n"			\
-	"\t.org 2b+%O4\n"			\
-	"\t.popsection\n"
-#else
-#define _EMIT_BUG_ENTRY				\
-	"\t.pushsection __bug_table,\"aw\"\n"	\
-	"2:\t.long 1b\n"			\
-	"\t.short %O3\n"			\
-	"\t.org 2b+%O4\n"			\
-	"\t.popsection\n"
-#endif
-
-#define BUG()						\
-do {							\
-	__asm__ __volatile__ (				\
-		"1:\t.short %O0\n"			\
-		_EMIT_BUG_ENTRY				\
-		 :					\
-		 : "n" (TRAPA_BUG_OPCODE),		\
-		   "i" (__FILE__),			\
-		   "i" (__LINE__), "i" (0),		\
-		   "i" (sizeof(struct bug_entry)));	\
-	unreachable();					\
-} while (0)
-
-#define __WARN_FLAGS(flags)				\
-do {							\
-	__asm__ __volatile__ (				\
-		"1:\t.short %O0\n"			\
-		 _EMIT_BUG_ENTRY			\
-		 :					\
-		 : "n" (TRAPA_BUG_OPCODE),		\
-		   "i" (__FILE__),			\
-		   "i" (__LINE__),			\
-		   "i" (BUGFLAG_WARNING|(flags)),	\
-		   "i" (sizeof(struct bug_entry)));	\
-} while (0)
-
-#define WARN_ON(x) ({						\
-	int __ret_warn_on = !!(x);				\
-	if (__builtin_constant_p(__ret_warn_on)) {		\
-		if (__ret_warn_on)				\
-			__WARN();				\
-	} else {						\
-		if (unlikely(__ret_warn_on))			\
-			__WARN();				\
-	}							\
-	unlikely(__ret_warn_on);				\
-})
-
-#define UNWINDER_BUG()					\
-do {							\
-	__asm__ __volatile__ (				\
-		"1:\t.short %O0\n"			\
-		_EMIT_BUG_ENTRY				\
-		 :					\
-		 : "n" (TRAPA_BUG_OPCODE),		\
-		   "i" (__FILE__),			\
-		   "i" (__LINE__),			\
-		   "i" (BUGFLAG_UNWINDER),		\
-		   "i" (sizeof(struct bug_entry)));	\
-} while (0)
-
-#define UNWINDER_BUG_ON(x) ({					\
-	int __ret_unwinder_on = !!(x);				\
-	if (__builtin_constant_p(__ret_unwinder_on)) {		\
-		if (__ret_unwinder_on)				\
-			UNWINDER_BUG();				\
-	} else {						\
-		if (unlikely(__ret_unwinder_on))		\
-			UNWINDER_BUG();				\
-	}							\
-	unlikely(__ret_unwinder_on);				\
-})
-
-#else
-
-#define UNWINDER_BUG	BUG
-#define UNWINDER_BUG_ON	BUG_ON
-
-#endif /* CONFIG_GENERIC_BUG */
-
-#include <asm-generic/bug.h>
-
-struct pt_regs;
-
-/* arch/sh/kernel/traps.c */
-extern void die(const char *str, struct pt_regs *regs, long err) __attribute__ ((noreturn));
-extern void die_if_kernel(const char *str, struct pt_regs *regs, long err);
-extern void die_if_no_fixup(const char *str, struct pt_regs *regs, long err);
-
-#endif /* __ASM_SH_BUG_H */
diff --git a/arch/sh/include/asm/bugs.h b/arch/sh/include/asm/bugs.h
deleted file mode 100644
index fe52abb69cea31..00000000000000
--- a/arch/sh/include/asm/bugs.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_BUGS_H
-#define __ASM_SH_BUGS_H
-
-/*
- * This is included by init/main.c to check for architecture-dependent bugs.
- *
- * Needs:
- *	void check_bugs(void);
- */
-
-/*
- * I don't know of any Super-H bugs yet.
- */
-
-#include <asm/processor.h>
-
-extern void select_idle_routine(void);
-
-static void __init check_bugs(void)
-{
-	extern unsigned long loops_per_jiffy;
-	char *p = &init_utsname()->machine[2]; /* "sh" */
-
-	select_idle_routine();
-
-	current_cpu_data.loops_per_jiffy = loops_per_jiffy;
-
-	switch (current_cpu_data.family) {
-	case CPU_FAMILY_SH2:
-		*p++ = '2';
-		break;
-	case CPU_FAMILY_SH2A:
-		*p++ = '2';
-		*p++ = 'a';
-		break;
-	case CPU_FAMILY_SH3:
-		*p++ = '3';
-		break;
-	case CPU_FAMILY_SH4:
-		*p++ = '4';
-		break;
-	case CPU_FAMILY_SH4A:
-		*p++ = '4';
-		*p++ = 'a';
-		break;
-	case CPU_FAMILY_SH4AL_DSP:
-		*p++ = '4';
-		*p++ = 'a';
-		*p++ = 'l';
-		*p++ = '-';
-		*p++ = 'd';
-		*p++ = 's';
-		*p++ = 'p';
-		break;
-	case CPU_FAMILY_UNKNOWN:
-		/*
-		 * Specifically use CPU_FAMILY_UNKNOWN rather than
-		 * default:, so we're able to have the compiler whine
-		 * about unhandled enumerations.
-		 */
-		break;
-	}
-
-	printk("CPU: %s\n", get_cpu_subtype(&current_cpu_data));
-
-#ifndef __LITTLE_ENDIAN__
-	/* 'eb' means 'Endian Big' */
-	*p++ = 'e';
-	*p++ = 'b';
-#endif
-	*p = '\0';
-}
-#endif /* __ASM_SH_BUGS_H */
diff --git a/arch/sh/include/asm/cache.h b/arch/sh/include/asm/cache.h
deleted file mode 100644
index 32dfa6b82ec663..00000000000000
--- a/arch/sh/include/asm/cache.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/* $Id: cache.h,v 1.6 2004/03/11 18:08:05 lethal Exp $
- *
- * include/asm-sh/cache.h
- *
- * Copyright 1999 (C) Niibe Yutaka
- * Copyright 2002, 2003 (C) Paul Mundt
- */
-#ifndef __ASM_SH_CACHE_H
-#define __ASM_SH_CACHE_H
-
-#include <linux/init.h>
-#include <cpu/cache.h>
-
-#define L1_CACHE_BYTES		(1 << L1_CACHE_SHIFT)
-
-#define __read_mostly __section(".data..read_mostly")
-
-#ifndef __ASSEMBLY__
-struct cache_info {
-	unsigned int ways;		/* Number of cache ways */
-	unsigned int sets;		/* Number of cache sets */
-	unsigned int linesz;		/* Cache line size (bytes) */
-
-	unsigned int way_size;		/* sets * line size */
-
-	/*
-	 * way_incr is the address offset for accessing the next way
-	 * in memory mapped cache array ops.
-	 */
-	unsigned int way_incr;
-	unsigned int entry_shift;
-	unsigned int entry_mask;
-
-	/*
-	 * Compute a mask which selects the address bits which overlap between
-	 * 1. those used to select the cache set during indexing
-	 * 2. those in the physical page number.
-	 */
-	unsigned int alias_mask;
-	unsigned int n_aliases;		/* Number of aliases */
-
-	unsigned long flags;
-};
-#endif /* __ASSEMBLY__ */
-#endif /* __ASM_SH_CACHE_H */
diff --git a/arch/sh/include/asm/cache_insns.h b/arch/sh/include/asm/cache_insns.h
deleted file mode 100644
index d7edd5297bd0f8..00000000000000
--- a/arch/sh/include/asm/cache_insns.h
+++ /dev/null
@@ -1,2 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <asm/cache_insns_32.h>
diff --git a/arch/sh/include/asm/cache_insns_32.h b/arch/sh/include/asm/cache_insns_32.h
deleted file mode 100644
index 470880b972cb1e..00000000000000
--- a/arch/sh/include/asm/cache_insns_32.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_CACHE_INSNS_32_H
-#define __ASM_SH_CACHE_INSNS_32_H
-
-#include <linux/types.h>
-
-#if defined(CONFIG_CPU_SH4A)
-#define __icbi(addr)	__asm__ __volatile__ ( "icbi @%0\n\t" : : "r" (addr))
-#else
-#define __icbi(addr)	mb()
-#endif
-
-#define __ocbp(addr)	__asm__ __volatile__ ( "ocbp @%0\n\t" : : "r" (addr))
-#define __ocbi(addr)	__asm__ __volatile__ ( "ocbi @%0\n\t" : : "r" (addr))
-#define __ocbwb(addr)	__asm__ __volatile__ ( "ocbwb @%0\n\t" : : "r" (addr))
-
-static inline reg_size_t register_align(void *val)
-{
-	return (unsigned long)(signed long)val;
-}
-
-#endif /* __ASM_SH_CACHE_INSNS_32_H */
diff --git a/arch/sh/include/asm/cacheflush.h b/arch/sh/include/asm/cacheflush.h
deleted file mode 100644
index 481a664287e2e4..00000000000000
--- a/arch/sh/include/asm/cacheflush.h
+++ /dev/null
@@ -1,106 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_CACHEFLUSH_H
-#define __ASM_SH_CACHEFLUSH_H
-
-#include <linux/mm.h>
-
-/*
- * Cache flushing:
- *
- *  - flush_cache_all() flushes entire cache
- *  - flush_cache_mm(mm) flushes the specified mm context's cache lines
- *  - flush_cache_dup mm(mm) handles cache flushing when forking
- *  - flush_cache_page(mm, vmaddr, pfn) flushes a single page
- *  - flush_cache_range(vma, start, end) flushes a range of pages
- *
- *  - flush_dcache_page(pg) flushes(wback&invalidates) a page for dcache
- *  - flush_icache_range(start, end) flushes(invalidates) a range for icache
- *  - flush_icache_page(vma, pg) flushes(invalidates) a page for icache
- *  - flush_cache_sigtramp(vaddr) flushes the signal trampoline
- */
-extern void (*local_flush_cache_all)(void *args);
-extern void (*local_flush_cache_mm)(void *args);
-extern void (*local_flush_cache_dup_mm)(void *args);
-extern void (*local_flush_cache_page)(void *args);
-extern void (*local_flush_cache_range)(void *args);
-extern void (*local_flush_dcache_page)(void *args);
-extern void (*local_flush_icache_range)(void *args);
-extern void (*local_flush_icache_page)(void *args);
-extern void (*local_flush_cache_sigtramp)(void *args);
-
-static inline void cache_noop(void *args) { }
-
-extern void (*__flush_wback_region)(void *start, int size);
-extern void (*__flush_purge_region)(void *start, int size);
-extern void (*__flush_invalidate_region)(void *start, int size);
-
-extern void flush_cache_all(void);
-extern void flush_cache_mm(struct mm_struct *mm);
-extern void flush_cache_dup_mm(struct mm_struct *mm);
-extern void flush_cache_page(struct vm_area_struct *vma,
-				unsigned long addr, unsigned long pfn);
-extern void flush_cache_range(struct vm_area_struct *vma,
-				 unsigned long start, unsigned long end);
-#define ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE 1
-void flush_dcache_page(struct page *page);
-extern void flush_icache_range(unsigned long start, unsigned long end);
-#define flush_icache_user_range flush_icache_range
-extern void flush_icache_page(struct vm_area_struct *vma,
-				 struct page *page);
-extern void flush_cache_sigtramp(unsigned long address);
-
-struct flusher_data {
-	struct vm_area_struct *vma;
-	unsigned long addr1, addr2;
-};
-
-#define ARCH_HAS_FLUSH_ANON_PAGE
-extern void __flush_anon_page(struct page *page, unsigned long);
-
-static inline void flush_anon_page(struct vm_area_struct *vma,
-				   struct page *page, unsigned long vmaddr)
-{
-	if (boot_cpu_data.dcache.n_aliases && PageAnon(page))
-		__flush_anon_page(page, vmaddr);
-}
-
-#define ARCH_IMPLEMENTS_FLUSH_KERNEL_VMAP_RANGE 1
-static inline void flush_kernel_vmap_range(void *addr, int size)
-{
-	__flush_wback_region(addr, size);
-}
-static inline void invalidate_kernel_vmap_range(void *addr, int size)
-{
-	__flush_invalidate_region(addr, size);
-}
-
-extern void copy_to_user_page(struct vm_area_struct *vma,
-	struct page *page, unsigned long vaddr, void *dst, const void *src,
-	unsigned long len);
-
-extern void copy_from_user_page(struct vm_area_struct *vma,
-	struct page *page, unsigned long vaddr, void *dst, const void *src,
-	unsigned long len);
-
-#define flush_cache_vmap(start, end)		local_flush_cache_all(NULL)
-#define flush_cache_vunmap(start, end)		local_flush_cache_all(NULL)
-
-#define flush_dcache_mmap_lock(mapping)		do { } while (0)
-#define flush_dcache_mmap_unlock(mapping)	do { } while (0)
-
-void kmap_coherent_init(void);
-void *kmap_coherent(struct page *page, unsigned long addr);
-void kunmap_coherent(void *kvaddr);
-
-#define PG_dcache_clean	PG_arch_1
-
-void cpu_cache_init(void);
-
-static inline void *sh_cacheop_vaddr(void *vaddr)
-{
-	if (__in_29bit_mode())
-		vaddr = (void *)CAC_ADDR((unsigned long)vaddr);
-	return vaddr;
-}
-
-#endif /* __ASM_SH_CACHEFLUSH_H */
diff --git a/arch/sh/include/asm/checksum.h b/arch/sh/include/asm/checksum.h
deleted file mode 100644
index 00e39dd0d146a3..00000000000000
--- a/arch/sh/include/asm/checksum.h
+++ /dev/null
@@ -1,2 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <asm/checksum_32.h>
diff --git a/arch/sh/include/asm/checksum_32.h b/arch/sh/include/asm/checksum_32.h
deleted file mode 100644
index a6501b856f3eb4..00000000000000
--- a/arch/sh/include/asm/checksum_32.h
+++ /dev/null
@@ -1,203 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_CHECKSUM_H
-#define __ASM_SH_CHECKSUM_H
-
-/*
- * Copyright (C) 1999 by Kaz Kojima & Niibe Yutaka
- */
-
-#include <linux/in6.h>
-
-/*
- * computes the checksum of a memory block at buff, length len,
- * and adds in "sum" (32-bit)
- *
- * returns a 32-bit number suitable for feeding into itself
- * or csum_tcpudp_magic
- *
- * this function must be called with even lengths, except
- * for the last fragment, which may be odd
- *
- * it's best to have buff aligned on a 32-bit boundary
- */
-asmlinkage __wsum csum_partial(const void *buff, int len, __wsum sum);
-
-/*
- * the same as csum_partial, but copies from src while it
- * checksums, and handles user-space pointer exceptions correctly, when needed.
- *
- * here even more important to align src and dst on a 32-bit (or even
- * better 64-bit) boundary
- */
-
-asmlinkage __wsum csum_partial_copy_generic(const void *src, void *dst, int len);
-
-#define _HAVE_ARCH_CSUM_AND_COPY
-/*
- *	Note: when you get a NULL pointer exception here this means someone
- *	passed in an incorrect kernel address to one of these functions.
- *
- *	If you use these functions directly please don't forget the
- *	access_ok().
- */
-static inline
-__wsum csum_partial_copy_nocheck(const void *src, void *dst, int len)
-{
-	return csum_partial_copy_generic(src, dst, len);
-}
-
-#define _HAVE_ARCH_COPY_AND_CSUM_FROM_USER
-static inline
-__wsum csum_and_copy_from_user(const void __user *src, void *dst, int len)
-{
-	if (!access_ok(src, len))
-		return 0;
-	return csum_partial_copy_generic((__force const void *)src, dst, len);
-}
-
-/*
- *	Fold a partial checksum
- */
-
-static inline __sum16 csum_fold(__wsum sum)
-{
-	unsigned int __dummy;
-	__asm__("swap.w %0, %1\n\t"
-		"extu.w	%0, %0\n\t"
-		"extu.w	%1, %1\n\t"
-		"add	%1, %0\n\t"
-		"swap.w	%0, %1\n\t"
-		"add	%1, %0\n\t"
-		"not	%0, %0\n\t"
-		: "=r" (sum), "=&r" (__dummy)
-		: "0" (sum)
-		: "t");
-	return (__force __sum16)sum;
-}
-
-/*
- *	This is a version of ip_compute_csum() optimized for IP headers,
- *	which always checksum on 4 octet boundaries.
- *
- *      i386 version by Jorge Cwik <jorge@laser.satlink.net>, adapted
- *      for linux by * Arnt Gulbrandsen.
- */
-static inline __sum16 ip_fast_csum(const void *iph, unsigned int ihl)
-{
-	__wsum sum;
-	unsigned int __dummy0, __dummy1;
-
-	__asm__ __volatile__(
-		"mov.l	@%1+, %0\n\t"
-		"mov.l	@%1+, %3\n\t"
-		"add	#-2, %2\n\t"
-		"clrt\n\t"
-		"1:\t"
-		"addc	%3, %0\n\t"
-		"movt	%4\n\t"
-		"mov.l	@%1+, %3\n\t"
-		"dt	%2\n\t"
-		"bf/s	1b\n\t"
-		" cmp/eq #1, %4\n\t"
-		"addc	%3, %0\n\t"
-		"addc	%2, %0"	    /* Here %2 is 0, add carry-bit */
-	/* Since the input registers which are loaded with iph and ihl
-	   are modified, we must also specify them as outputs, or gcc
-	   will assume they contain their original values. */
-	: "=r" (sum), "=r" (iph), "=r" (ihl), "=&r" (__dummy0), "=&z" (__dummy1)
-	: "1" (iph), "2" (ihl)
-	: "t", "memory");
-
-	return	csum_fold(sum);
-}
-
-static inline __wsum csum_tcpudp_nofold(__be32 saddr, __be32 daddr,
-					__u32 len, __u8 proto,
-					__wsum sum)
-{
-#ifdef __LITTLE_ENDIAN__
-	unsigned long len_proto = (proto + len) << 8;
-#else
-	unsigned long len_proto = proto + len;
-#endif
-	__asm__("clrt\n\t"
-		"addc	%0, %1\n\t"
-		"addc	%2, %1\n\t"
-		"addc	%3, %1\n\t"
-		"movt	%0\n\t"
-		"add	%1, %0"
-		: "=r" (sum), "=r" (len_proto)
-		: "r" (daddr), "r" (saddr), "1" (len_proto), "0" (sum)
-		: "t");
-
-	return sum;
-}
-
-/*
- * computes the checksum of the TCP/UDP pseudo-header
- * returns a 16-bit checksum, already complemented
- */
-static inline __sum16 csum_tcpudp_magic(__be32 saddr, __be32 daddr,
-					__u32 len, __u8 proto,
-					__wsum sum)
-{
-	return csum_fold(csum_tcpudp_nofold(saddr, daddr, len, proto, sum));
-}
-
-/*
- * this routine is used for miscellaneous IP-like checksums, mainly
- * in icmp.c
- */
-static inline __sum16 ip_compute_csum(const void *buff, int len)
-{
-    return csum_fold(csum_partial(buff, len, 0));
-}
-
-#define _HAVE_ARCH_IPV6_CSUM
-static inline __sum16 csum_ipv6_magic(const struct in6_addr *saddr,
-				      const struct in6_addr *daddr,
-				      __u32 len, __u8 proto, __wsum sum)
-{
-	unsigned int __dummy;
-	__asm__("clrt\n\t"
-		"mov.l	@(0,%2), %1\n\t"
-		"addc	%1, %0\n\t"
-		"mov.l	@(4,%2), %1\n\t"
-		"addc	%1, %0\n\t"
-		"mov.l	@(8,%2), %1\n\t"
-		"addc	%1, %0\n\t"
-		"mov.l	@(12,%2), %1\n\t"
-		"addc	%1, %0\n\t"
-		"mov.l	@(0,%3), %1\n\t"
-		"addc	%1, %0\n\t"
-		"mov.l	@(4,%3), %1\n\t"
-		"addc	%1, %0\n\t"
-		"mov.l	@(8,%3), %1\n\t"
-		"addc	%1, %0\n\t"
-		"mov.l	@(12,%3), %1\n\t"
-		"addc	%1, %0\n\t"
-		"addc	%4, %0\n\t"
-		"addc	%5, %0\n\t"
-		"movt	%1\n\t"
-		"add	%1, %0\n"
-		: "=r" (sum), "=&r" (__dummy)
-		: "r" (saddr), "r" (daddr),
-		  "r" (htonl(len)), "r" (htonl(proto)), "0" (sum)
-		: "t");
-
-	return csum_fold(sum);
-}
-
-/*
- *	Copy and checksum to user
- */
-#define HAVE_CSUM_COPY_USER
-static inline __wsum csum_and_copy_to_user(const void *src,
-					   void __user *dst,
-					   int len)
-{
-	if (!access_ok(dst, len))
-		return 0;
-	return csum_partial_copy_generic(src, (__force void *)dst, len);
-}
-#endif /* __ASM_SH_CHECKSUM_H */
diff --git a/arch/sh/include/asm/clock.h b/arch/sh/include/asm/clock.h
deleted file mode 100644
index b65bc2908e8aaf..00000000000000
--- a/arch/sh/include/asm/clock.h
+++ /dev/null
@@ -1,17 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_CLOCK_H
-#define __ASM_SH_CLOCK_H
-
-#include <linux/sh_clk.h>
-
-/* Should be defined by processor-specific code */
-void __deprecated arch_init_clk_ops(struct sh_clk_ops **, int type);
-int __init arch_clk_init(void);
-
-/* arch/sh/kernel/cpu/clock-cpg.c */
-int __init __deprecated cpg_clk_init(void);
-
-/* arch/sh/kernel/cpu/clock.c */
-int clk_init(void);
-
-#endif /* __ASM_SH_CLOCK_H */
diff --git a/arch/sh/include/asm/cmpxchg-cas.h b/arch/sh/include/asm/cmpxchg-cas.h
deleted file mode 100644
index f508db6eaf3192..00000000000000
--- a/arch/sh/include/asm/cmpxchg-cas.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_CMPXCHG_CAS_H
-#define __ASM_SH_CMPXCHG_CAS_H
-
-static inline unsigned long
-__cmpxchg_u32(volatile u32 *m, unsigned long old, unsigned long new)
-{
-	__asm__ __volatile__("cas.l %1,%0,@r0"
-		: "+r"(new)
-		: "r"(old), "z"(m)
-		: "t", "memory" );
-	return new;
-}
-
-static inline unsigned long xchg_u32(volatile u32 *m, unsigned long val)
-{
-	unsigned long old;
-	do old = *m;
-	while (__cmpxchg_u32(m, old, val) != old);
-	return old;
-}
-
-#include <asm/cmpxchg-xchg.h>
-
-#endif /* __ASM_SH_CMPXCHG_CAS_H */
diff --git a/arch/sh/include/asm/cmpxchg-grb.h b/arch/sh/include/asm/cmpxchg-grb.h
deleted file mode 100644
index e12279ea35cf74..00000000000000
--- a/arch/sh/include/asm/cmpxchg-grb.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_CMPXCHG_GRB_H
-#define __ASM_SH_CMPXCHG_GRB_H
-
-static inline unsigned long xchg_u32(volatile u32 *m, unsigned long val)
-{
-	unsigned long retval;
-
-	__asm__ __volatile__ (
-		"   .align 2              \n\t"
-		"   mova    1f,   r0      \n\t" /* r0 = end point */
-		"   nop                   \n\t"
-		"   mov    r15,   r1      \n\t" /* r1 = saved sp */
-		"   mov    #-4,   r15     \n\t" /* LOGIN */
-		"   mov.l  @%1,   %0      \n\t" /* load  old value */
-		"   mov.l   %2,   @%1     \n\t" /* store new value */
-		"1: mov     r1,   r15     \n\t" /* LOGOUT */
-		: "=&r" (retval),
-		  "+r"  (m),
-		  "+r"  (val)		/* inhibit r15 overloading */
-		:
-		: "memory", "r0", "r1");
-
-	return retval;
-}
-
-static inline unsigned long xchg_u16(volatile u16 *m, unsigned long val)
-{
-	unsigned long retval;
-
-	__asm__ __volatile__ (
-		"   .align  2             \n\t"
-		"   mova    1f,   r0      \n\t" /* r0 = end point */
-		"   mov    r15,   r1      \n\t" /* r1 = saved sp */
-		"   mov    #-6,   r15     \n\t" /* LOGIN */
-		"   mov.w  @%1,   %0      \n\t" /* load  old value */
-		"   extu.w  %0,   %0      \n\t" /* extend as unsigned */
-		"   mov.w   %2,   @%1     \n\t" /* store new value */
-		"1: mov     r1,   r15     \n\t" /* LOGOUT */
-		: "=&r" (retval),
-		  "+r"  (m),
-		  "+r"  (val)		/* inhibit r15 overloading */
-		:
-		: "memory" , "r0", "r1");
-
-	return retval;
-}
-
-static inline unsigned long xchg_u8(volatile u8 *m, unsigned long val)
-{
-	unsigned long retval;
-
-	__asm__ __volatile__ (
-		"   .align  2             \n\t"
-		"   mova    1f,   r0      \n\t" /* r0 = end point */
-		"   mov    r15,   r1      \n\t" /* r1 = saved sp */
-		"   mov    #-6,   r15     \n\t" /* LOGIN */
-		"   mov.b  @%1,   %0      \n\t" /* load  old value */
-		"   extu.b  %0,   %0      \n\t" /* extend as unsigned */
-		"   mov.b   %2,   @%1     \n\t" /* store new value */
-		"1: mov     r1,   r15     \n\t" /* LOGOUT */
-		: "=&r" (retval),
-		  "+r"  (m),
-		  "+r"  (val)		/* inhibit r15 overloading */
-		:
-		: "memory" , "r0", "r1");
-
-	return retval;
-}
-
-static inline unsigned long __cmpxchg_u32(volatile int *m, unsigned long old,
-					  unsigned long new)
-{
-	unsigned long retval;
-
-	__asm__ __volatile__ (
-		"   .align  2             \n\t"
-		"   mova    1f,   r0      \n\t" /* r0 = end point */
-		"   nop                   \n\t"
-		"   mov    r15,   r1      \n\t" /* r1 = saved sp */
-		"   mov    #-8,   r15     \n\t" /* LOGIN */
-		"   mov.l  @%3,   %0      \n\t" /* load  old value */
-		"   cmp/eq  %0,   %1      \n\t"
-		"   bf            1f      \n\t" /* if not equal */
-		"   mov.l   %2,   @%3     \n\t" /* store new value */
-		"1: mov     r1,   r15     \n\t" /* LOGOUT */
-		: "=&r" (retval),
-		  "+r"  (old), "+r"  (new) /* old or new can be r15 */
-		:  "r"  (m)
-		: "memory" , "r0", "r1", "t");
-
-	return retval;
-}
-
-#endif /* __ASM_SH_CMPXCHG_GRB_H */
diff --git a/arch/sh/include/asm/cmpxchg-irq.h b/arch/sh/include/asm/cmpxchg-irq.h
deleted file mode 100644
index 07d3e7f0838919..00000000000000
--- a/arch/sh/include/asm/cmpxchg-irq.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_CMPXCHG_IRQ_H
-#define __ASM_SH_CMPXCHG_IRQ_H
-
-#include <linux/irqflags.h>
-
-static inline unsigned long xchg_u32(volatile u32 *m, unsigned long val)
-{
-	unsigned long flags, retval;
-
-	local_irq_save(flags);
-	retval = *m;
-	*m = val;
-	local_irq_restore(flags);
-	return retval;
-}
-
-static inline unsigned long xchg_u16(volatile u16 *m, unsigned long val)
-{
-	unsigned long flags, retval;
-
-	local_irq_save(flags);
-	retval = *m;
-	*m = val;
-	local_irq_restore(flags);
-	return retval;
-}
-
-static inline unsigned long xchg_u8(volatile u8 *m, unsigned long val)
-{
-	unsigned long flags, retval;
-
-	local_irq_save(flags);
-	retval = *m;
-	*m = val & 0xff;
-	local_irq_restore(flags);
-	return retval;
-}
-
-static inline unsigned long __cmpxchg_u32(volatile int *m, unsigned long old,
-	unsigned long new)
-{
-	__u32 retval;
-	unsigned long flags;
-
-	local_irq_save(flags);
-	retval = *m;
-	if (retval == old)
-		*m = new;
-	local_irq_restore(flags);       /* implies memory barrier  */
-	return retval;
-}
-
-#endif /* __ASM_SH_CMPXCHG_IRQ_H */
diff --git a/arch/sh/include/asm/cmpxchg-llsc.h b/arch/sh/include/asm/cmpxchg-llsc.h
deleted file mode 100644
index d5270cd297c142..00000000000000
--- a/arch/sh/include/asm/cmpxchg-llsc.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_CMPXCHG_LLSC_H
-#define __ASM_SH_CMPXCHG_LLSC_H
-
-static inline unsigned long xchg_u32(volatile u32 *m, unsigned long val)
-{
-	unsigned long retval;
-	unsigned long tmp;
-
-	__asm__ __volatile__ (
-		"1:					\n\t"
-		"movli.l	@%2, %0	! xchg_u32	\n\t"
-		"mov		%0, %1			\n\t"
-		"mov		%3, %0			\n\t"
-		"movco.l	%0, @%2			\n\t"
-		"bf		1b			\n\t"
-		"synco					\n\t"
-		: "=&z"(tmp), "=&r" (retval)
-		: "r" (m), "r" (val)
-		: "t", "memory"
-	);
-
-	return retval;
-}
-
-static inline unsigned long
-__cmpxchg_u32(volatile u32 *m, unsigned long old, unsigned long new)
-{
-	unsigned long retval;
-	unsigned long tmp;
-
-	__asm__ __volatile__ (
-		"1:						\n\t"
-		"movli.l	@%2, %0	! __cmpxchg_u32		\n\t"
-		"mov		%0, %1				\n\t"
-		"cmp/eq		%1, %3				\n\t"
-		"bf		2f				\n\t"
-		"mov		%4, %0				\n\t"
-		"2:						\n\t"
-		"movco.l	%0, @%2				\n\t"
-		"bf		1b				\n\t"
-		"synco						\n\t"
-		: "=&z" (tmp), "=&r" (retval)
-		: "r" (m), "r" (old), "r" (new)
-		: "t", "memory"
-	);
-
-	return retval;
-}
-
-#include <asm/cmpxchg-xchg.h>
-
-#endif /* __ASM_SH_CMPXCHG_LLSC_H */
diff --git a/arch/sh/include/asm/cmpxchg-xchg.h b/arch/sh/include/asm/cmpxchg-xchg.h
deleted file mode 100644
index c373f21efe4d90..00000000000000
--- a/arch/sh/include/asm/cmpxchg-xchg.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_CMPXCHG_XCHG_H
-#define __ASM_SH_CMPXCHG_XCHG_H
-
-/*
- * Copyright (C) 2016 Red Hat, Inc.
- * Author: Michael S. Tsirkin <mst@redhat.com>
- */
-#include <linux/bits.h>
-#include <linux/compiler.h>
-#include <asm/byteorder.h>
-
-/*
- * Portable implementations of 1 and 2 byte xchg using a 4 byte cmpxchg.
- * Note: this header isn't self-contained: before including it, __cmpxchg_u32
- * must be defined first.
- */
-static inline u32 __xchg_cmpxchg(volatile void *ptr, u32 x, int size)
-{
-	int off = (unsigned long)ptr % sizeof(u32);
-	volatile u32 *p = ptr - off;
-#ifdef __BIG_ENDIAN
-	int bitoff = (sizeof(u32) - size - off) * BITS_PER_BYTE;
-#else
-	int bitoff = off * BITS_PER_BYTE;
-#endif
-	u32 bitmask = ((0x1 << size * BITS_PER_BYTE) - 1) << bitoff;
-	u32 oldv, newv;
-	u32 ret;
-
-	do {
-		oldv = READ_ONCE(*p);
-		ret = (oldv & bitmask) >> bitoff;
-		newv = (oldv & ~bitmask) | (x << bitoff);
-	} while (__cmpxchg_u32(p, oldv, newv) != oldv);
-
-	return ret;
-}
-
-static inline unsigned long xchg_u16(volatile u16 *m, unsigned long val)
-{
-	return __xchg_cmpxchg(m, val, sizeof *m);
-}
-
-static inline unsigned long xchg_u8(volatile u8 *m, unsigned long val)
-{
-	return __xchg_cmpxchg(m, val, sizeof *m);
-}
-
-#endif /* __ASM_SH_CMPXCHG_XCHG_H */
diff --git a/arch/sh/include/asm/cmpxchg.h b/arch/sh/include/asm/cmpxchg.h
deleted file mode 100644
index 0ed9b3f4a57796..00000000000000
--- a/arch/sh/include/asm/cmpxchg.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_CMPXCHG_H
-#define __ASM_SH_CMPXCHG_H
-
-/*
- * Atomic operations that C can't guarantee us.  Useful for
- * resource counting etc..
- */
-
-#include <linux/compiler.h>
-#include <linux/types.h>
-
-#if defined(CONFIG_GUSA_RB)
-#include <asm/cmpxchg-grb.h>
-#elif defined(CONFIG_CPU_SH4A)
-#include <asm/cmpxchg-llsc.h>
-#elif defined(CONFIG_CPU_J2) && defined(CONFIG_SMP)
-#include <asm/cmpxchg-cas.h>
-#else
-#include <asm/cmpxchg-irq.h>
-#endif
-
-extern void __xchg_called_with_bad_pointer(void);
-
-#define __xchg(ptr, x, size)				\
-({							\
-	unsigned long __xchg__res;			\
-	volatile void *__xchg_ptr = (ptr);		\
-	switch (size) {					\
-	case 4:						\
-		__xchg__res = xchg_u32(__xchg_ptr, x);	\
-		break;					\
-	case 2:						\
-		__xchg__res = xchg_u16(__xchg_ptr, x);	\
-		break;					\
-	case 1:						\
-		__xchg__res = xchg_u8(__xchg_ptr, x);	\
-		break;					\
-	default:					\
-		__xchg_called_with_bad_pointer();	\
-		__xchg__res = x;			\
-		break;					\
-	}						\
-							\
-	__xchg__res;					\
-})
-
-#define arch_xchg(ptr,x)	\
-	((__typeof__(*(ptr)))__xchg((ptr),(unsigned long)(x), sizeof(*(ptr))))
-
-/* This function doesn't exist, so you'll get a linker error
- * if something tries to do an invalid cmpxchg(). */
-extern void __cmpxchg_called_with_bad_pointer(void);
-
-static inline unsigned long __cmpxchg(volatile void * ptr, unsigned long old,
-		unsigned long new, int size)
-{
-	switch (size) {
-	case 4:
-		return __cmpxchg_u32(ptr, old, new);
-	}
-	__cmpxchg_called_with_bad_pointer();
-	return old;
-}
-
-#define arch_cmpxchg(ptr,o,n)						 \
-  ({									 \
-     __typeof__(*(ptr)) _o_ = (o);					 \
-     __typeof__(*(ptr)) _n_ = (n);					 \
-     (__typeof__(*(ptr))) __cmpxchg((ptr), (unsigned long)_o_,		 \
-				    (unsigned long)_n_, sizeof(*(ptr))); \
-  })
-
-#endif /* __ASM_SH_CMPXCHG_H */
diff --git a/arch/sh/include/asm/device.h b/arch/sh/include/asm/device.h
deleted file mode 100644
index 6f3e686a1c6f3e..00000000000000
--- a/arch/sh/include/asm/device.h
+++ /dev/null
@@ -1,17 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * Arch specific extensions to struct device
- */
-#ifndef __ASM_SH_DEVICE_H
-#define __ASM_SH_DEVICE_H
-
-#include <asm-generic/device.h>
-
-struct platform_device;
-/* allocate contiguous memory chunk and fill in struct resource */
-int platform_resource_setup_memory(struct platform_device *pdev,
-				   char *name, unsigned long memsize);
-
-void plat_early_device_setup(void);
-
-#endif /* __ASM_SH_DEVICE_H */
diff --git a/arch/sh/include/asm/dma-register.h b/arch/sh/include/asm/dma-register.h
deleted file mode 100644
index 724dab912b7108..00000000000000
--- a/arch/sh/include/asm/dma-register.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * Common header for the legacy SH DMA driver and the new dmaengine driver
- *
- * extracted from arch/sh/include/asm/dma-sh.h:
- *
- * Copyright (C) 2000  Takashi YOSHII
- * Copyright (C) 2003  Paul Mundt
- */
-#ifndef DMA_REGISTER_H
-#define DMA_REGISTER_H
-
-/* DMA registers */
-#define SAR	0x00	/* Source Address Register */
-#define DAR	0x04	/* Destination Address Register */
-#define TCR	0x08	/* Transfer Count Register */
-#define CHCR	0x0C	/* Channel Control Register */
-#define DMAOR	0x40	/* DMA Operation Register */
-
-/* DMAOR definitions */
-#define DMAOR_AE	0x00000004	/* Address Error Flag */
-#define DMAOR_NMIF	0x00000002
-#define DMAOR_DME	0x00000001	/* DMA Master Enable */
-
-/* Definitions for the SuperH DMAC */
-#define REQ_L	0x00000000
-#define REQ_E	0x00080000
-#define RACK_H	0x00000000
-#define RACK_L	0x00040000
-#define ACK_R	0x00000000
-#define ACK_W	0x00020000
-#define ACK_H	0x00000000
-#define ACK_L	0x00010000
-#define DM_INC	0x00004000	/* Destination addresses are incremented */
-#define DM_DEC	0x00008000	/* Destination addresses are decremented */
-#define DM_FIX	0x0000c000	/* Destination address is fixed */
-#define SM_INC	0x00001000	/* Source addresses are incremented */
-#define SM_DEC	0x00002000	/* Source addresses are decremented */
-#define SM_FIX	0x00003000	/* Source address is fixed */
-#define RS_IN	0x00000200
-#define RS_OUT	0x00000300
-#define RS_AUTO	0x00000400	/* Auto Request */
-#define RS_ERS	0x00000800	/* DMA extended resource selector */
-#define TS_BLK	0x00000040
-#define TM_BUR	0x00000020
-#define CHCR_DE	0x00000001	/* DMA Enable */
-#define CHCR_TE	0x00000002	/* Transfer End Flag */
-#define CHCR_IE	0x00000004	/* Interrupt Enable */
-
-#endif
diff --git a/arch/sh/include/asm/dma.h b/arch/sh/include/asm/dma.h
deleted file mode 100644
index c8bee3f985a293..00000000000000
--- a/arch/sh/include/asm/dma.h
+++ /dev/null
@@ -1,140 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/dma.h
- *
- * Copyright (C) 2003, 2004  Paul Mundt
- */
-#ifndef __ASM_SH_DMA_H
-#define __ASM_SH_DMA_H
-
-#include <linux/spinlock.h>
-#include <linux/wait.h>
-#include <linux/sched.h>
-#include <linux/device.h>
-#include <asm-generic/dma.h>
-
-/*
- * Read and write modes can mean drastically different things depending on the
- * channel configuration. Consult your DMAC documentation and module
- * implementation for further clues.
- */
-#define DMA_MODE_READ		0x00
-#define DMA_MODE_WRITE		0x01
-#define DMA_MODE_MASK		0x01
-
-#define DMA_AUTOINIT		0x10
-
-/*
- * DMAC (dma_info) flags
- */
-enum {
-	DMAC_CHANNELS_CONFIGURED	= 0x01,
-	DMAC_CHANNELS_TEI_CAPABLE	= 0x02,	/* Transfer end interrupt */
-};
-
-/*
- * DMA channel capabilities / flags
- */
-enum {
-	DMA_CONFIGURED			= 0x01,
-
-	/*
-	 * Transfer end interrupt, inherited from DMAC.
-	 * wait_queue used in dma_wait_for_completion.
-	 */
-	DMA_TEI_CAPABLE			= 0x02,
-};
-
-extern spinlock_t dma_spin_lock;
-
-struct dma_channel;
-
-struct dma_ops {
-	int (*request)(struct dma_channel *chan);
-	void (*free)(struct dma_channel *chan);
-
-	int (*get_residue)(struct dma_channel *chan);
-	int (*xfer)(struct dma_channel *chan);
-	int (*configure)(struct dma_channel *chan, unsigned long flags);
-	int (*extend)(struct dma_channel *chan, unsigned long op, void *param);
-};
-
-struct dma_channel {
-	char dev_id[16];		/* unique name per DMAC of channel */
-
-	unsigned int chan;		/* DMAC channel number */
-	unsigned int vchan;		/* Virtual channel number */
-
-	unsigned int mode;
-	unsigned int count;
-
-	unsigned long sar;
-	unsigned long dar;
-
-	const char **caps;
-
-	unsigned long flags;
-	atomic_t busy;
-
-	wait_queue_head_t wait_queue;
-
-	struct device dev;
-	void *priv_data;
-};
-
-struct dma_info {
-	struct platform_device *pdev;
-
-	const char *name;
-	unsigned int nr_channels;
-	unsigned long flags;
-
-	struct dma_ops *ops;
-	struct dma_channel *channels;
-
-	struct list_head list;
-	int first_channel_nr;
-	int first_vchannel_nr;
-};
-
-struct dma_chan_caps {
-	int ch_num;
-	const char **caplist;
-};
-
-#define to_dma_channel(channel) container_of(channel, struct dma_channel, dev)
-
-/* arch/sh/drivers/dma/dma-api.c */
-extern int dma_xfer(unsigned int chan, unsigned long from,
-		    unsigned long to, size_t size, unsigned int mode);
-
-#define dma_write(chan, from, to, size)	\
-	dma_xfer(chan, from, to, size, DMA_MODE_WRITE)
-#define dma_write_page(chan, from, to)	\
-	dma_write(chan, from, to, PAGE_SIZE)
-
-#define dma_read(chan, from, to, size)	\
-	dma_xfer(chan, from, to, size, DMA_MODE_READ)
-#define dma_read_page(chan, from, to)	\
-	dma_read(chan, from, to, PAGE_SIZE)
-
-extern int request_dma_bycap(const char **dmac, const char **caps,
-			     const char *dev_id);
-extern int get_dma_residue(unsigned int chan);
-extern struct dma_info *get_dma_info(unsigned int chan);
-extern struct dma_channel *get_dma_channel(unsigned int chan);
-extern void dma_wait_for_completion(unsigned int chan);
-extern void dma_configure_channel(unsigned int chan, unsigned long flags);
-
-extern int register_dmac(struct dma_info *info);
-extern void unregister_dmac(struct dma_info *info);
-extern struct dma_info *get_dma_info_by_name(const char *dmac_name);
-
-extern int dma_extend(unsigned int chan, unsigned long op, void *param);
-extern int register_chan_caps(const char *dmac, struct dma_chan_caps *capslist);
-
-/* arch/sh/drivers/dma/dma-sysfs.c */
-extern int dma_create_sysfs_files(struct dma_channel *, struct dma_info *);
-extern void dma_remove_sysfs_files(struct dma_channel *, struct dma_info *);
-
-#endif /* __ASM_SH_DMA_H */
diff --git a/arch/sh/include/asm/dmabrg.h b/arch/sh/include/asm/dmabrg.h
deleted file mode 100644
index 69e119cfd711e2..00000000000000
--- a/arch/sh/include/asm/dmabrg.h
+++ /dev/null
@@ -1,24 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * SH7760 DMABRG (USB/Audio) support
- */
-
-#ifndef _DMABRG_H_
-#define _DMABRG_H_
-
-/* IRQ sources */
-#define DMABRGIRQ_USBDMA	0
-#define DMABRGIRQ_USBDMAERR	1
-#define DMABRGIRQ_A0TXF		2
-#define DMABRGIRQ_A0TXH		3
-#define DMABRGIRQ_A0RXF		4
-#define DMABRGIRQ_A0RXH		5
-#define DMABRGIRQ_A1TXF		6
-#define DMABRGIRQ_A1TXH		7
-#define DMABRGIRQ_A1RXF		8
-#define DMABRGIRQ_A1RXH		9
-
-extern int dmabrg_request_irq(unsigned int, void(*)(void *), void *);
-extern void dmabrg_free_irq(unsigned int);
-
-#endif
diff --git a/arch/sh/include/asm/dwarf.h b/arch/sh/include/asm/dwarf.h
deleted file mode 100644
index 57195447412212..00000000000000
--- a/arch/sh/include/asm/dwarf.h
+++ /dev/null
@@ -1,417 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * Copyright (C) 2009 Matt Fleming <matt@console-pimps.org>
- */
-#ifndef __ASM_SH_DWARF_H
-#define __ASM_SH_DWARF_H
-
-#ifdef CONFIG_DWARF_UNWINDER
-
-/*
- * DWARF expression operations
- */
-#define DW_OP_addr	0x03
-#define DW_OP_deref	0x06
-#define DW_OP_const1u	0x08
-#define DW_OP_const1s	0x09
-#define DW_OP_const2u	0x0a
-#define DW_OP_const2s	0x0b
-#define DW_OP_const4u	0x0c
-#define DW_OP_const4s	0x0d
-#define DW_OP_const8u	0x0e
-#define DW_OP_const8s	0x0f
-#define DW_OP_constu	0x10
-#define DW_OP_consts	0x11
-#define DW_OP_dup	0x12
-#define DW_OP_drop	0x13
-#define DW_OP_over	0x14
-#define DW_OP_pick	0x15
-#define DW_OP_swap	0x16
-#define DW_OP_rot	0x17
-#define DW_OP_xderef	0x18
-#define DW_OP_abs	0x19
-#define DW_OP_and	0x1a
-#define DW_OP_div	0x1b
-#define DW_OP_minus	0x1c
-#define DW_OP_mod	0x1d
-#define DW_OP_mul	0x1e
-#define DW_OP_neg	0x1f
-#define DW_OP_not	0x20
-#define DW_OP_or	0x21
-#define DW_OP_plus	0x22
-#define DW_OP_plus_uconst	0x23
-#define DW_OP_shl	0x24
-#define DW_OP_shr	0x25
-#define DW_OP_shra	0x26
-#define DW_OP_xor	0x27
-#define DW_OP_skip	0x2f
-#define DW_OP_bra	0x28
-#define DW_OP_eq	0x29
-#define DW_OP_ge	0x2a
-#define DW_OP_gt	0x2b
-#define DW_OP_le	0x2c
-#define DW_OP_lt	0x2d
-#define DW_OP_ne	0x2e
-#define DW_OP_lit0	0x30
-#define DW_OP_lit1	0x31
-#define DW_OP_lit2	0x32
-#define DW_OP_lit3	0x33
-#define DW_OP_lit4	0x34
-#define DW_OP_lit5	0x35
-#define DW_OP_lit6	0x36
-#define DW_OP_lit7	0x37
-#define DW_OP_lit8	0x38
-#define DW_OP_lit9	0x39
-#define DW_OP_lit10	0x3a
-#define DW_OP_lit11	0x3b
-#define DW_OP_lit12	0x3c
-#define DW_OP_lit13	0x3d
-#define DW_OP_lit14	0x3e
-#define DW_OP_lit15	0x3f
-#define DW_OP_lit16	0x40
-#define DW_OP_lit17	0x41
-#define DW_OP_lit18	0x42
-#define DW_OP_lit19	0x43
-#define DW_OP_lit20	0x44
-#define DW_OP_lit21	0x45
-#define DW_OP_lit22	0x46
-#define DW_OP_lit23	0x47
-#define DW_OP_lit24	0x48
-#define DW_OP_lit25	0x49
-#define DW_OP_lit26	0x4a
-#define DW_OP_lit27	0x4b
-#define DW_OP_lit28	0x4c
-#define DW_OP_lit29	0x4d
-#define DW_OP_lit30	0x4e
-#define DW_OP_lit31	0x4f
-#define DW_OP_reg0	0x50
-#define DW_OP_reg1	0x51
-#define DW_OP_reg2	0x52
-#define DW_OP_reg3	0x53
-#define DW_OP_reg4	0x54
-#define DW_OP_reg5	0x55
-#define DW_OP_reg6	0x56
-#define DW_OP_reg7	0x57
-#define DW_OP_reg8	0x58
-#define DW_OP_reg9	0x59
-#define DW_OP_reg10	0x5a
-#define DW_OP_reg11	0x5b
-#define DW_OP_reg12	0x5c
-#define DW_OP_reg13	0x5d
-#define DW_OP_reg14	0x5e
-#define DW_OP_reg15	0x5f
-#define DW_OP_reg16	0x60
-#define DW_OP_reg17	0x61
-#define DW_OP_reg18	0x62
-#define DW_OP_reg19	0x63
-#define DW_OP_reg20	0x64
-#define DW_OP_reg21	0x65
-#define DW_OP_reg22	0x66
-#define DW_OP_reg23	0x67
-#define DW_OP_reg24	0x68
-#define DW_OP_reg25	0x69
-#define DW_OP_reg26	0x6a
-#define DW_OP_reg27	0x6b
-#define DW_OP_reg28	0x6c
-#define DW_OP_reg29	0x6d
-#define DW_OP_reg30	0x6e
-#define DW_OP_reg31	0x6f
-#define DW_OP_breg0	0x70
-#define DW_OP_breg1	0x71
-#define DW_OP_breg2	0x72
-#define DW_OP_breg3	0x73
-#define DW_OP_breg4	0x74
-#define DW_OP_breg5	0x75
-#define DW_OP_breg6	0x76
-#define DW_OP_breg7	0x77
-#define DW_OP_breg8	0x78
-#define DW_OP_breg9	0x79
-#define DW_OP_breg10	0x7a
-#define DW_OP_breg11	0x7b
-#define DW_OP_breg12	0x7c
-#define DW_OP_breg13	0x7d
-#define DW_OP_breg14	0x7e
-#define DW_OP_breg15	0x7f
-#define DW_OP_breg16	0x80
-#define DW_OP_breg17	0x81
-#define DW_OP_breg18	0x82
-#define DW_OP_breg19	0x83
-#define DW_OP_breg20	0x84
-#define DW_OP_breg21	0x85
-#define DW_OP_breg22	0x86
-#define DW_OP_breg23	0x87
-#define DW_OP_breg24	0x88
-#define DW_OP_breg25	0x89
-#define DW_OP_breg26	0x8a
-#define DW_OP_breg27	0x8b
-#define DW_OP_breg28	0x8c
-#define DW_OP_breg29	0x8d
-#define DW_OP_breg30	0x8e
-#define DW_OP_breg31	0x8f
-#define DW_OP_regx	0x90
-#define DW_OP_fbreg	0x91
-#define DW_OP_bregx	0x92
-#define DW_OP_piece	0x93
-#define DW_OP_deref_size	0x94
-#define DW_OP_xderef_size	0x95
-#define DW_OP_nop	0x96
-#define DW_OP_push_object_address	0x97
-#define DW_OP_call2	0x98
-#define DW_OP_call4	0x99
-#define DW_OP_call_ref	0x9a
-#define DW_OP_form_tls_address	0x9b
-#define DW_OP_call_frame_cfa	0x9c
-#define DW_OP_bit_piece	0x9d
-#define DW_OP_lo_user	0xe0
-#define DW_OP_hi_user	0xff
-
-/*
- * Addresses used in FDE entries in the .eh_frame section may be encoded
- * using one of the following encodings.
- */
-#define DW_EH_PE_absptr	0x00
-#define DW_EH_PE_omit	0xff
-#define DW_EH_PE_uleb128	0x01
-#define DW_EH_PE_udata2	0x02
-#define DW_EH_PE_udata4	0x03
-#define DW_EH_PE_udata8	0x04
-#define DW_EH_PE_sleb128	0x09
-#define DW_EH_PE_sdata2	0x0a
-#define DW_EH_PE_sdata4	0x0b
-#define DW_EH_PE_sdata8	0x0c
-#define DW_EH_PE_signed	0x09
-
-#define DW_EH_PE_pcrel	0x10
-
-/*
- * The architecture-specific register number that contains the return
- * address in the .debug_frame table.
- */
-#define DWARF_ARCH_RA_REG	17
-
-#ifndef __ASSEMBLY__
-
-#include <linux/compiler.h>
-#include <linux/bug.h>
-#include <linux/list.h>
-#include <linux/module.h>
-
-/*
- * Read either the frame pointer (r14) or the stack pointer (r15).
- * NOTE: this MUST be inlined.
- */
-static __always_inline unsigned long dwarf_read_arch_reg(unsigned int reg)
-{
-	unsigned long value = 0;
-
-	switch (reg) {
-	case 14:
-		__asm__ __volatile__("mov r14, %0\n" : "=r" (value));
-		break;
-	case 15:
-		__asm__ __volatile__("mov r15, %0\n" : "=r" (value));
-		break;
-	default:
-		BUG();
-	}
-
-	return value;
-}
-
-/**
- *	dwarf_cie - Common Information Entry
- */
-struct dwarf_cie {
-	unsigned long length;
-	unsigned long cie_id;
-	unsigned char version;
-	const char *augmentation;
-	unsigned int code_alignment_factor;
-	int data_alignment_factor;
-
-	/* Which column in the rule table represents return addr of func. */
-	unsigned int return_address_reg;
-
-	unsigned char *initial_instructions;
-	unsigned char *instructions_end;
-
-	unsigned char encoding;
-
-	unsigned long cie_pointer;
-
-	unsigned long flags;
-#define DWARF_CIE_Z_AUGMENTATION	(1 << 0)
-
-	/* linked-list entry if this CIE is from a module */
-	struct list_head link;
-
-	struct rb_node node;
-};
-
-/**
- *	dwarf_fde - Frame Description Entry
- */
-struct dwarf_fde {
-	unsigned long length;
-	unsigned long cie_pointer;
-	struct dwarf_cie *cie;
-	unsigned long initial_location;
-	unsigned long address_range;
-	unsigned char *instructions;
-	unsigned char *end;
-
-	/* linked-list entry if this FDE is from a module */
-	struct list_head link;
-
-	struct rb_node node;
-};
-
-/**
- *	dwarf_frame - DWARF information for a frame in the call stack
- */
-struct dwarf_frame {
-	struct dwarf_frame *prev, *next;
-
-	unsigned long pc;
-
-	struct list_head reg_list;
-
-	unsigned long cfa;
-
-	/* Valid when DW_FRAME_CFA_REG_OFFSET is set in flags */
-	unsigned int cfa_register;
-	unsigned int cfa_offset;
-
-	/* Valid when DW_FRAME_CFA_REG_EXP is set in flags */
-	unsigned char *cfa_expr;
-	unsigned int cfa_expr_len;
-
-	unsigned long flags;
-#define DWARF_FRAME_CFA_REG_OFFSET	(1 << 0)
-#define DWARF_FRAME_CFA_REG_EXP		(1 << 1)
-
-	unsigned long return_addr;
-};
-
-/**
- *	dwarf_reg - DWARF register
- *	@flags: Describes how to calculate the value of this register
- */
-struct dwarf_reg {
-	struct list_head link;
-
-	unsigned int number;
-
-	unsigned long addr;
-	unsigned long flags;
-#define DWARF_REG_OFFSET	(1 << 0)
-#define DWARF_VAL_OFFSET	(1 << 1)
-#define DWARF_UNDEFINED		(1 << 2)
-};
-
-/*
- * Call Frame instruction opcodes.
- */
-#define DW_CFA_advance_loc	0x40
-#define DW_CFA_offset		0x80
-#define DW_CFA_restore		0xc0
-#define DW_CFA_nop		0x00
-#define DW_CFA_set_loc		0x01
-#define DW_CFA_advance_loc1	0x02
-#define DW_CFA_advance_loc2	0x03
-#define DW_CFA_advance_loc4	0x04
-#define DW_CFA_offset_extended	0x05
-#define DW_CFA_restore_extended	0x06
-#define DW_CFA_undefined	0x07
-#define DW_CFA_same_value	0x08
-#define DW_CFA_register		0x09
-#define DW_CFA_remember_state	0x0a
-#define DW_CFA_restore_state	0x0b
-#define DW_CFA_def_cfa		0x0c
-#define DW_CFA_def_cfa_register	0x0d
-#define DW_CFA_def_cfa_offset	0x0e
-#define DW_CFA_def_cfa_expression	0x0f
-#define DW_CFA_expression	0x10
-#define DW_CFA_offset_extended_sf	0x11
-#define DW_CFA_def_cfa_sf	0x12
-#define DW_CFA_def_cfa_offset_sf	0x13
-#define DW_CFA_val_offset	0x14
-#define DW_CFA_val_offset_sf	0x15
-#define DW_CFA_val_expression	0x16
-#define DW_CFA_lo_user		0x1c
-#define DW_CFA_hi_user		0x3f
-
-/* GNU extension opcodes  */
-#define DW_CFA_GNU_args_size	0x2e
-#define DW_CFA_GNU_negative_offset_extended 0x2f
-
-/*
- * Some call frame instructions encode their operands in the opcode. We
- * need some helper functions to extract both the opcode and operands
- * from an instruction.
- */
-static inline unsigned int DW_CFA_opcode(unsigned long insn)
-{
-	return (insn & 0xc0);
-}
-
-static inline unsigned int DW_CFA_operand(unsigned long insn)
-{
-	return (insn & 0x3f);
-}
-
-#define DW_EH_FRAME_CIE	0		/* .eh_frame CIE IDs are 0 */
-#define DW_CIE_ID	0xffffffff
-#define DW64_CIE_ID	0xffffffffffffffffULL
-
-/*
- * DWARF FDE/CIE length field values.
- */
-#define DW_EXT_LO	0xfffffff0
-#define DW_EXT_HI	0xffffffff
-#define DW_EXT_DWARF64	DW_EXT_HI
-
-extern struct dwarf_frame *dwarf_unwind_stack(unsigned long,
-					      struct dwarf_frame *);
-extern void dwarf_free_frame(struct dwarf_frame *);
-
-extern int module_dwarf_finalize(const Elf_Ehdr *, const Elf_Shdr *,
-				 struct module *);
-extern void module_dwarf_cleanup(struct module *);
-
-#endif /* !__ASSEMBLY__ */
-
-#define CFI_STARTPROC	.cfi_startproc
-#define CFI_ENDPROC	.cfi_endproc
-#define CFI_DEF_CFA	.cfi_def_cfa
-#define CFI_REGISTER	.cfi_register
-#define CFI_REL_OFFSET	.cfi_rel_offset
-#define CFI_UNDEFINED	.cfi_undefined
-
-#else
-
-/*
- * Use the asm comment character to ignore the rest of the line.
- */
-#define CFI_IGNORE	!
-
-#define CFI_STARTPROC	CFI_IGNORE
-#define CFI_ENDPROC	CFI_IGNORE
-#define CFI_DEF_CFA	CFI_IGNORE
-#define CFI_REGISTER	CFI_IGNORE
-#define CFI_REL_OFFSET	CFI_IGNORE
-#define CFI_UNDEFINED	CFI_IGNORE
-
-#ifndef __ASSEMBLY__
-static inline void dwarf_unwinder_init(void)
-{
-}
-
-#define module_dwarf_finalize(hdr, sechdrs, me)	(0)
-#define module_dwarf_cleanup(mod)		do { } while (0)
-
-#endif
-
-#endif /* CONFIG_DWARF_UNWINDER */
-
-#endif /* __ASM_SH_DWARF_H */
diff --git a/arch/sh/include/asm/elf.h b/arch/sh/include/asm/elf.h
deleted file mode 100644
index 2862d6d1cb64f1..00000000000000
--- a/arch/sh/include/asm/elf.h
+++ /dev/null
@@ -1,211 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_ELF_H
-#define __ASM_SH_ELF_H
-
-#include <linux/utsname.h>
-#include <asm/auxvec.h>
-#include <asm/ptrace.h>
-#include <asm/user.h>
-
-/* ELF header e_flags defines */
-#define EF_SH_PIC		0x100	/* -fpic */
-#define EF_SH_FDPIC		0x8000	/* -mfdpic */
-
-/* SH (particularly SHcompact) relocation types  */
-#define	R_SH_NONE		0
-#define	R_SH_DIR32		1
-#define	R_SH_REL32		2
-#define	R_SH_DIR8WPN		3
-#define	R_SH_IND12W		4
-#define	R_SH_DIR8WPL		5
-#define	R_SH_DIR8WPZ		6
-#define	R_SH_DIR8BP		7
-#define	R_SH_DIR8W		8
-#define	R_SH_DIR8L		9
-#define	R_SH_SWITCH16		25
-#define	R_SH_SWITCH32		26
-#define	R_SH_USES		27
-#define	R_SH_COUNT		28
-#define	R_SH_ALIGN		29
-#define	R_SH_CODE		30
-#define	R_SH_DATA		31
-#define	R_SH_LABEL		32
-#define	R_SH_SWITCH8		33
-#define	R_SH_GNU_VTINHERIT	34
-#define	R_SH_GNU_VTENTRY	35
-#define	R_SH_TLS_GD_32		144
-#define	R_SH_TLS_LD_32		145
-#define	R_SH_TLS_LDO_32		146
-#define	R_SH_TLS_IE_32		147
-#define	R_SH_TLS_LE_32		148
-#define	R_SH_TLS_DTPMOD32	149
-#define	R_SH_TLS_DTPOFF32	150
-#define	R_SH_TLS_TPOFF32	151
-#define	R_SH_GOT32		160
-#define	R_SH_PLT32		161
-#define	R_SH_COPY		162
-#define	R_SH_GLOB_DAT		163
-#define	R_SH_JMP_SLOT		164
-#define	R_SH_RELATIVE		165
-#define	R_SH_GOTOFF		166
-#define	R_SH_GOTPC		167
-
-/* FDPIC relocs */
-#define R_SH_GOT20		201
-#define R_SH_GOTOFF20		202
-#define R_SH_GOTFUNCDESC	203
-#define R_SH_GOTFUNCDESC20	204
-#define R_SH_GOTOFFFUNCDESC	205
-#define R_SH_GOTOFFFUNCDESC20	206
-#define R_SH_FUNCDESC		207
-#define R_SH_FUNCDESC_VALUE	208
-
-/* SHmedia relocs */
-#define R_SH_IMM_LOW16		246
-#define R_SH_IMM_LOW16_PCREL	247
-#define R_SH_IMM_MEDLOW16	248
-#define R_SH_IMM_MEDLOW16_PCREL	249
-/* Keep this the last entry.  */
-#define	R_SH_NUM		256
-
-/*
- * ELF register definitions..
- */
-
-typedef unsigned long elf_greg_t;
-
-#define ELF_NGREG (sizeof (struct pt_regs) / sizeof(elf_greg_t))
-typedef elf_greg_t elf_gregset_t[ELF_NGREG];
-
-typedef struct user_fpu_struct elf_fpregset_t;
-
-/*
- * These are used to set parameters in the core dumps.
- */
-#define ELF_CLASS	ELFCLASS32
-#ifdef __LITTLE_ENDIAN__
-#define ELF_DATA	ELFDATA2LSB
-#else
-#define ELF_DATA	ELFDATA2MSB
-#endif
-#define ELF_ARCH	EM_SH
-
-/*
- * This is used to ensure we don't load something for the wrong architecture.
- */
-#define elf_check_arch(x)		((x)->e_machine == EM_SH)
-#define elf_check_fdpic(x)		((x)->e_flags & EF_SH_FDPIC)
-#define elf_check_const_displacement(x)	((x)->e_flags & EF_SH_PIC)
-
-/*
- * Enable dump using regset.
- * This covers all of general/DSP/FPU regs.
- */
-#define CORE_DUMP_USE_REGSET
-
-#define ELF_FDPIC_CORE_EFLAGS	EF_SH_FDPIC
-#define ELF_EXEC_PAGESIZE	PAGE_SIZE
-
-/* This is the location that an ET_DYN program is loaded if exec'ed.  Typical
-   use of this is to invoke "./ld.so someprog" to test out a new version of
-   the loader.  We need to make sure that it is out of the way of the program
-   that it will "exec", and that there is sufficient room for the brk.  */
-
-#define ELF_ET_DYN_BASE         (2 * TASK_SIZE / 3)
-
-#define ELF_CORE_COPY_REGS(_dest,_regs)				\
-	memcpy((char *) &_dest, (char *) _regs,			\
-	       sizeof(struct pt_regs));
-
-/* This yields a mask that user programs can use to figure out what
-   instruction set this CPU supports.  This could be done in user space,
-   but it's not easy, and we've already done it here.  */
-
-#define ELF_HWCAP	(boot_cpu_data.flags)
-
-/* This yields a string that ld.so will use to load implementation
-   specific libraries for optimization.  This is more specific in
-   intent than poking at uname or /proc/cpuinfo.
-
-   For the moment, we have only optimizations for the Intel generations,
-   but that could change... */
-
-#define ELF_PLATFORM	(utsname()->machine)
-
-#define ELF_PLAT_INIT(_r, load_addr) \
-  do { _r->regs[0]=0; _r->regs[1]=0; _r->regs[2]=0; _r->regs[3]=0; \
-       _r->regs[4]=0; _r->regs[5]=0; _r->regs[6]=0; _r->regs[7]=0; \
-       _r->regs[8]=0; _r->regs[9]=0; _r->regs[10]=0; _r->regs[11]=0; \
-       _r->regs[12]=0; _r->regs[13]=0; _r->regs[14]=0; \
-       _r->sr = SR_FD; } while (0)
-
-#define ELF_FDPIC_PLAT_INIT(_r, _exec_map_addr, _interp_map_addr,	\
-			    _dynamic_addr)				\
-do {									\
-	_r->regs[0]	= 0;						\
-	_r->regs[1]	= 0;						\
-	_r->regs[2]	= 0;						\
-	_r->regs[3]	= 0;						\
-	_r->regs[4]	= 0;						\
-	_r->regs[5]	= 0;						\
-	_r->regs[6]	= 0;						\
-	_r->regs[7]	= 0;						\
-	_r->regs[8]	= _exec_map_addr;				\
-	_r->regs[9]	= _interp_map_addr;				\
-	_r->regs[10]	= _dynamic_addr;				\
-	_r->regs[11]	= 0;						\
-	_r->regs[12]	= 0;						\
-	_r->regs[13]	= 0;						\
-	_r->regs[14]	= 0;						\
-	_r->sr		= SR_FD;					\
-} while (0)
-
-#define SET_PERSONALITY(ex) \
-	set_personality(PER_LINUX_32BIT | (current->personality & (~PER_MASK)))
-
-#ifdef CONFIG_VSYSCALL
-/* vDSO has arch_setup_additional_pages */
-#define ARCH_HAS_SETUP_ADDITIONAL_PAGES
-struct linux_binprm;
-extern int arch_setup_additional_pages(struct linux_binprm *bprm,
-				       int uses_interp);
-
-extern unsigned int vdso_enabled;
-extern void __kernel_vsyscall;
-
-#define VDSO_BASE		((unsigned long)current->mm->context.vdso)
-#define VDSO_SYM(x)		(VDSO_BASE + (unsigned long)(x))
-
-#define VSYSCALL_AUX_ENT					\
-	if (vdso_enabled)					\
-		NEW_AUX_ENT(AT_SYSINFO_EHDR, VDSO_BASE);	\
-	else							\
-		NEW_AUX_ENT(AT_IGNORE, 0)
-#else
-#define VSYSCALL_AUX_ENT	NEW_AUX_ENT(AT_IGNORE, 0)
-#endif /* CONFIG_VSYSCALL */
-
-#ifdef CONFIG_SH_FPU
-#define FPU_AUX_ENT	NEW_AUX_ENT(AT_FPUCW, FPSCR_INIT)
-#else
-#define FPU_AUX_ENT	NEW_AUX_ENT(AT_IGNORE, 0)
-#endif
-
-extern int l1i_cache_shape, l1d_cache_shape, l2_cache_shape;
-
-/* update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT entries changes */
-#define ARCH_DLINFO						\
-do {								\
-	/* Optional FPU initialization */			\
-	FPU_AUX_ENT;						\
-								\
-	/* Optional vsyscall entry */				\
-	VSYSCALL_AUX_ENT;					\
-								\
-	/* Cache desc */					\
-	NEW_AUX_ENT(AT_L1I_CACHESHAPE, l1i_cache_shape);	\
-	NEW_AUX_ENT(AT_L1D_CACHESHAPE, l1d_cache_shape);	\
-	NEW_AUX_ENT(AT_L2_CACHESHAPE, l2_cache_shape);		\
-} while (0)
-
-#endif /* __ASM_SH_ELF_H */
diff --git a/arch/sh/include/asm/entry-macros.S b/arch/sh/include/asm/entry-macros.S
deleted file mode 100644
index 5ce142d8c5a89e..00000000000000
--- a/arch/sh/include/asm/entry-macros.S
+++ /dev/null
@@ -1,123 +0,0 @@
-! SPDX-License-Identifier: GPL-2.0
-! entry.S macro define
-	
-	.macro	cli
-	stc	sr, r0
-	or	#0xf0, r0
-	ldc	r0, sr
-	.endm
-
-	.macro	sti
-	mov	#0xfffffff0, r11
-	extu.b	r11, r11
-	not	r11, r11
-	stc	sr, r10
-	and	r11, r10
-#ifdef CONFIG_CPU_HAS_SR_RB
-	stc	k_g_imask, r11
-	or	r11, r10
-#endif
-	ldc	r10, sr
-	.endm
-
-	.macro	get_current_thread_info, ti, tmp
-#ifdef CONFIG_CPU_HAS_SR_RB
-	stc	r7_bank, \ti
-#else
-	mov	#((THREAD_SIZE - 1) >> 10) ^ 0xff, \tmp
-	shll8	\tmp
-	shll2	\tmp
-	mov	r15, \ti
-	and	\tmp, \ti
-#endif	
-	.endm
-
-#ifdef CONFIG_TRACE_IRQFLAGS
-
-	.macro	TRACE_IRQS_ON
-	mov.l	r0, @-r15
-	mov.l	r1, @-r15
-	mov.l	r2, @-r15
-	mov.l	r3, @-r15
-	mov.l	r4, @-r15
-	mov.l	r5, @-r15
-	mov.l	r6, @-r15
-	mov.l	r7, @-r15
-
-	mov.l   7834f, r0
-	jsr	@r0
-	 nop
-
-	mov.l	@r15+, r7
-	mov.l	@r15+, r6
-	mov.l	@r15+, r5
-	mov.l	@r15+, r4
-	mov.l	@r15+, r3
-	mov.l	@r15+, r2
-	mov.l	@r15+, r1
-	mov.l	@r15+, r0
-	mov.l	7834f, r0
-
-	bra	7835f
-	 nop
-	.balign	4
-7834:	.long	trace_hardirqs_on
-7835:
-	.endm
-	.macro	TRACE_IRQS_OFF
-
-	mov.l	r0, @-r15
-	mov.l	r1, @-r15
-	mov.l	r2, @-r15
-	mov.l	r3, @-r15
-	mov.l	r4, @-r15
-	mov.l	r5, @-r15
-	mov.l	r6, @-r15
-	mov.l	r7, @-r15
-
-	mov.l	7834f, r0
-	jsr	@r0
-	 nop
-
-	mov.l	@r15+, r7
-	mov.l	@r15+, r6
-	mov.l	@r15+, r5
-	mov.l	@r15+, r4
-	mov.l	@r15+, r3
-	mov.l	@r15+, r2
-	mov.l	@r15+, r1
-	mov.l	@r15+, r0
-	mov.l	7834f, r0
-
-	bra	7835f
-	 nop
-	.balign	4
-7834:	.long	trace_hardirqs_off
-7835:
-	.endm
-
-#else
-	.macro	TRACE_IRQS_ON
-	.endm
-
-	.macro	TRACE_IRQS_OFF
-	.endm
-#endif
-
-#if defined(CONFIG_CPU_SH2A) || defined(CONFIG_CPU_SH4)
-# define PREF(x)	pref	@x
-#else
-# define PREF(x)	nop
-#endif
-
-	/*
-	 * Macro for use within assembly. Because the DWARF unwinder
-	 * needs to use the frame register to unwind the stack, we
-	 * need to setup r14 with the value of the stack pointer as
-	 * the return address is usually on the stack somewhere.
-	 */
-	.macro	setup_frame_reg
-#ifdef CONFIG_DWARF_UNWINDER
-	mov	r15, r14
-#endif
-	.endm
diff --git a/arch/sh/include/asm/extable.h b/arch/sh/include/asm/extable.h
deleted file mode 100644
index 5658d2bae37242..00000000000000
--- a/arch/sh/include/asm/extable.h
+++ /dev/null
@@ -1,7 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_EXTABLE_H
-#define __ASM_SH_EXTABLE_H
-
-#include <asm-generic/extable.h>
-
-#endif
diff --git a/arch/sh/include/asm/fb.h b/arch/sh/include/asm/fb.h
deleted file mode 100644
index 9a0bca2686fd3d..00000000000000
--- a/arch/sh/include/asm/fb.h
+++ /dev/null
@@ -1,20 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _ASM_FB_H_
-#define _ASM_FB_H_
-
-#include <linux/fb.h>
-#include <linux/fs.h>
-#include <asm/page.h>
-
-static inline void fb_pgprotect(struct file *file, struct vm_area_struct *vma,
-				unsigned long off)
-{
-	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
-}
-
-static inline int fb_is_primary_device(struct fb_info *info)
-{
-	return 0;
-}
-
-#endif /* _ASM_FB_H_ */
diff --git a/arch/sh/include/asm/fixmap.h b/arch/sh/include/asm/fixmap.h
deleted file mode 100644
index b07fbc7f7bc6ac..00000000000000
--- a/arch/sh/include/asm/fixmap.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * fixmap.h: compile-time virtual memory allocation
- *
- * Copyright (C) 1998 Ingo Molnar
- *
- * Support of BIGMEM added by Gerhard Wichert, Siemens AG, July 1999
- */
-
-#ifndef _ASM_FIXMAP_H
-#define _ASM_FIXMAP_H
-
-#include <linux/kernel.h>
-#include <linux/threads.h>
-#include <asm/page.h>
-
-/*
- * Here we define all the compile-time 'special' virtual
- * addresses. The point is to have a constant address at
- * compile time, but to set the physical address only
- * in the boot process. We allocate these special  addresses
- * from the end of P3 backwards.
- * Also this lets us do fail-safe vmalloc(), we
- * can guarantee that these special addresses and
- * vmalloc()-ed addresses never overlap.
- *
- * these 'compile-time allocated' memory buffers are
- * fixed-size 4k pages. (or larger if used with an increment
- * highger than 1) use fixmap_set(idx,phys) to associate
- * physical memory with fixmap indices.
- *
- * TLB entries of such buffers will not be flushed across
- * task switches.
- */
-
-/*
- * on UP currently we will have no trace of the fixmap mechanizm,
- * no page table allocations, etc. This might change in the
- * future, say framebuffers for the console driver(s) could be
- * fix-mapped?
- */
-enum fixed_addresses {
-	/*
-	 * The FIX_CMAP entries are used by kmap_coherent() to get virtual
-	 * addresses which are of a known color, and so their values are
-	 * important. __fix_to_virt(FIX_CMAP_END - n) must give an address
-	 * which is the same color as a page (n<<PAGE_SHIFT).
-	 */
-#define FIX_N_COLOURS 8
-	FIX_CMAP_BEGIN,
-	FIX_CMAP_END = FIX_CMAP_BEGIN + (FIX_N_COLOURS * NR_CPUS) - 1,
-
-#ifdef CONFIG_IOREMAP_FIXED
-	/*
-	 * FIX_IOREMAP entries are useful for mapping physical address
-	 * space before ioremap() is useable, e.g. really early in boot
-	 * before kmalloc() is working.
-	 */
-#define FIX_N_IOREMAPS	32
-	FIX_IOREMAP_BEGIN,
-	FIX_IOREMAP_END = FIX_IOREMAP_BEGIN + FIX_N_IOREMAPS - 1,
-#endif
-
-	__end_of_fixed_addresses
-};
-
-extern void __set_fixmap(enum fixed_addresses idx,
-			 unsigned long phys, pgprot_t flags);
-extern void __clear_fixmap(enum fixed_addresses idx, pgprot_t flags);
-
-/*
- * used by vmalloc.c.
- *
- * Leave one empty page between vmalloc'ed areas and
- * the start of the fixmap, and leave one page empty
- * at the top of mem..
- */
-#define FIXADDR_TOP	(P4SEG - PAGE_SIZE)
-#define FIXADDR_SIZE	(__end_of_fixed_addresses << PAGE_SHIFT)
-#define FIXADDR_START	(FIXADDR_TOP - FIXADDR_SIZE)
-
-#define FIXMAP_PAGE_NOCACHE PAGE_KERNEL_NOCACHE
-
-#include <asm-generic/fixmap.h>
-
-#endif
diff --git a/arch/sh/include/asm/flat.h b/arch/sh/include/asm/flat.h
deleted file mode 100644
index fee4f25555cb53..00000000000000
--- a/arch/sh/include/asm/flat.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/flat.h
- *
- * uClinux flat-format executables
- *
- * Copyright (C) 2003  Paul Mundt
- */
-#ifndef __ASM_SH_FLAT_H
-#define __ASM_SH_FLAT_H
-
-#include <asm/unaligned.h>
-
-static inline int flat_get_addr_from_rp(u32 __user *rp, u32 relval, u32 flags,
-					u32 *addr)
-{
-	*addr = get_unaligned((__force u32 *)rp);
-	return 0;
-}
-static inline int flat_put_addr_at_rp(u32 __user *rp, u32 addr, u32 rel)
-{
-	put_unaligned(addr, (__force u32 *)rp);
-	return 0;
-}
-
-#define FLAT_PLAT_INIT(_r) \
-  do { _r->regs[0]=0; _r->regs[1]=0; _r->regs[2]=0; _r->regs[3]=0; \
-       _r->regs[4]=0; _r->regs[5]=0; _r->regs[6]=0; _r->regs[7]=0; \
-       _r->regs[8]=0; _r->regs[9]=0; _r->regs[10]=0; _r->regs[11]=0; \
-       _r->regs[12]=0; _r->regs[13]=0; _r->regs[14]=0; \
-       _r->sr = SR_FD; } while (0)
-
-#endif /* __ASM_SH_FLAT_H */
diff --git a/arch/sh/include/asm/fpu.h b/arch/sh/include/asm/fpu.h
deleted file mode 100644
index 04584be8986c41..00000000000000
--- a/arch/sh/include/asm/fpu.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_FPU_H
-#define __ASM_SH_FPU_H
-
-#ifndef __ASSEMBLY__
-
-#include <asm/ptrace.h>
-
-struct task_struct;
-
-#ifdef CONFIG_SH_FPU
-static inline void release_fpu(struct pt_regs *regs)
-{
-	regs->sr |= SR_FD;
-}
-
-static inline void grab_fpu(struct pt_regs *regs)
-{
-	regs->sr &= ~SR_FD;
-}
-
-extern void save_fpu(struct task_struct *__tsk);
-extern void restore_fpu(struct task_struct *__tsk);
-extern void fpu_state_restore(struct pt_regs *regs);
-extern void __fpu_state_restore(void);
-#else
-#define save_fpu(tsk)			do { } while (0)
-#define restore_fpu(tsk)		do { } while (0)
-#define release_fpu(regs)		do { } while (0)
-#define grab_fpu(regs)			do { } while (0)
-#define fpu_state_restore(regs)		do { } while (0)
-#define __fpu_state_restore(regs)	do { } while (0)
-#endif
-
-struct user_regset;
-
-extern int do_fpu_inst(unsigned short, struct pt_regs *);
-extern int init_fpu(struct task_struct *);
-
-static inline void __unlazy_fpu(struct task_struct *tsk, struct pt_regs *regs)
-{
-	if (task_thread_info(tsk)->status & TS_USEDFPU) {
-		task_thread_info(tsk)->status &= ~TS_USEDFPU;
-		save_fpu(tsk);
-		release_fpu(regs);
-	} else
-		tsk->thread.fpu_counter = 0;
-}
-
-static inline void unlazy_fpu(struct task_struct *tsk, struct pt_regs *regs)
-{
-	preempt_disable();
-	__unlazy_fpu(tsk, regs);
-	preempt_enable();
-}
-
-static inline void clear_fpu(struct task_struct *tsk, struct pt_regs *regs)
-{
-	preempt_disable();
-	if (task_thread_info(tsk)->status & TS_USEDFPU) {
-		task_thread_info(tsk)->status &= ~TS_USEDFPU;
-		release_fpu(regs);
-	}
-	preempt_enable();
-}
-
-#endif /* __ASSEMBLY__ */
-
-#endif /* __ASM_SH_FPU_H */
diff --git a/arch/sh/include/asm/freq.h b/arch/sh/include/asm/freq.h
deleted file mode 100644
index 87c23621b7ae81..00000000000000
--- a/arch/sh/include/asm/freq.h
+++ /dev/null
@@ -1,12 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+
- *
- * include/asm-sh/freq.h
- *
- * Copyright (C) 2002, 2003 Paul Mundt
- */
-#ifndef __ASM_SH_FREQ_H
-#define __ASM_SH_FREQ_H
-
-#include <cpu/freq.h>
-
-#endif /* __ASM_SH_FREQ_H */
diff --git a/arch/sh/include/asm/ftrace.h b/arch/sh/include/asm/ftrace.h
deleted file mode 100644
index b1c1dc0cc261d1..00000000000000
--- a/arch/sh/include/asm/ftrace.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_FTRACE_H
-#define __ASM_SH_FTRACE_H
-
-#ifdef CONFIG_FUNCTION_TRACER
-
-#define MCOUNT_INSN_SIZE	4 /* sizeof mcount call */
-#define FTRACE_SYSCALL_MAX	NR_syscalls
-
-#ifndef __ASSEMBLY__
-extern void mcount(void);
-
-#define MCOUNT_ADDR		((unsigned long)(mcount))
-
-#ifdef CONFIG_DYNAMIC_FTRACE
-#define CALL_ADDR		((long)(ftrace_call))
-#define STUB_ADDR		((long)(ftrace_stub))
-#define GRAPH_ADDR		((long)(ftrace_graph_call))
-#define CALLER_ADDR		((long)(ftrace_caller))
-
-#define MCOUNT_INSN_OFFSET	((STUB_ADDR - CALL_ADDR) - 4)
-#define GRAPH_INSN_OFFSET	((CALLER_ADDR - GRAPH_ADDR) - 4)
-
-struct dyn_arch_ftrace {
-	/* No extra data needed on sh */
-};
-
-#endif /* CONFIG_DYNAMIC_FTRACE */
-
-static inline unsigned long ftrace_call_adjust(unsigned long addr)
-{
-	/* 'addr' is the memory table address. */
-	return addr;
-}
-
-#endif /* __ASSEMBLY__ */
-#endif /* CONFIG_FUNCTION_TRACER */
-
-#ifndef __ASSEMBLY__
-
-/* arch/sh/kernel/return_address.c */
-extern void *return_address(unsigned int);
-
-#define ftrace_return_address(n) return_address(n)
-
-#endif /* __ASSEMBLY__ */
-
-#endif /* __ASM_SH_FTRACE_H */
diff --git a/arch/sh/include/asm/futex-cas.h b/arch/sh/include/asm/futex-cas.h
deleted file mode 100644
index ed738e32b5ec45..00000000000000
--- a/arch/sh/include/asm/futex-cas.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_FUTEX_CAS_H
-#define __ASM_SH_FUTEX_CAS_H
-
-static inline int atomic_futex_op_cmpxchg_inatomic(u32 *uval,
-						   u32 __user *uaddr,
-						   u32 oldval, u32 newval)
-{
-	int err = 0;
-	__asm__ __volatile__(
-		"1:\n\t"
-		"cas.l	%2, %1, @r0\n"
-		"2:\n\t"
-#ifdef CONFIG_MMU
-		".section	.fixup,\"ax\"\n"
-		"3:\n\t"
-		"mov.l	4f, %0\n\t"
-		"jmp	@%0\n\t"
-		" mov	%3, %0\n\t"
-		".balign	4\n"
-		"4:	.long	2b\n\t"
-		".previous\n"
-		".section	__ex_table,\"a\"\n\t"
-		".long	1b, 3b\n\t"
-		".previous"
-#endif
-		:"+r" (err), "+r" (newval)
-		:"r" (oldval), "i" (-EFAULT), "z" (uaddr)
-		:"t", "memory");
-	if (err) return err;
-	*uval = newval;
-	return 0;
-}
-
-#endif /* __ASM_SH_FUTEX_CAS_H */
diff --git a/arch/sh/include/asm/futex-irq.h b/arch/sh/include/asm/futex-irq.h
deleted file mode 100644
index 9bc053242ea037..00000000000000
--- a/arch/sh/include/asm/futex-irq.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_FUTEX_IRQ_H
-#define __ASM_SH_FUTEX_IRQ_H
-
-static inline int atomic_futex_op_cmpxchg_inatomic(u32 *uval,
-						   u32 __user *uaddr,
-						   u32 oldval, u32 newval)
-{
-	unsigned long flags;
-	int ret;
-	u32 prev = 0;
-
-	local_irq_save(flags);
-
-	ret = get_user(prev, uaddr);
-	if (!ret && oldval == prev)
-		ret = put_user(newval, uaddr);
-
-	local_irq_restore(flags);
-
-	*uval = prev;
-	return ret;
-}
-
-#endif /* __ASM_SH_FUTEX_IRQ_H */
diff --git a/arch/sh/include/asm/futex-llsc.h b/arch/sh/include/asm/futex-llsc.h
deleted file mode 100644
index 6e1570752bc1e9..00000000000000
--- a/arch/sh/include/asm/futex-llsc.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_FUTEX_LLSC_H
-#define __ASM_SH_FUTEX_LLSC_H
-
-static inline int atomic_futex_op_cmpxchg_inatomic(u32 *uval,
-						   u32 __user *uaddr,
-						   u32 oldval, u32 newval)
-{
-	int err = 0;
-	__asm__ __volatile__(
-		"synco\n"
-		"1:\n\t"
-		"movli.l	@%2, r0\n\t"
-		"mov	r0, %1\n\t"
-		"cmp/eq	%1, %4\n\t"
-		"bf	2f\n\t"
-		"mov	%5, r0\n\t"
-		"movco.l	r0, @%2\n\t"
-		"bf	1b\n"
-		"2:\n\t"
-		"synco\n\t"
-#ifdef CONFIG_MMU
-		".section	.fixup,\"ax\"\n"
-		"3:\n\t"
-		"mov.l	4f, %0\n\t"
-		"jmp	@%0\n\t"
-		" mov	%3, %0\n\t"
-		".balign	4\n"
-		"4:	.long	2b\n\t"
-		".previous\n"
-		".section	__ex_table,\"a\"\n\t"
-		".long	1b, 3b\n\t"
-		".previous"
-#endif
-		:"+r" (err), "=&r" (*uval)
-		:"r" (uaddr), "i" (-EFAULT), "r" (oldval), "r" (newval)
-		:"t", "memory", "r0");
-	if (err) return err;
-	return 0;
-}
-
-#endif /* __ASM_SH_FUTEX_LLSC_H */
diff --git a/arch/sh/include/asm/futex.h b/arch/sh/include/asm/futex.h
deleted file mode 100644
index b70f3fce6ed77a..00000000000000
--- a/arch/sh/include/asm/futex.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_FUTEX_H
-#define __ASM_SH_FUTEX_H
-
-#include <linux/futex.h>
-#include <linux/uaccess.h>
-#include <asm/errno.h>
-
-#if !defined(CONFIG_SMP)
-#include <asm/futex-irq.h>
-#elif defined(CONFIG_CPU_J2)
-#include <asm/futex-cas.h>
-#elif defined(CONFIG_CPU_SH4A)
-#include <asm/futex-llsc.h>
-#else
-#error SMP not supported on this configuration.
-#endif
-
-static inline int
-futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr,
-			      u32 oldval, u32 newval)
-{
-	if (!access_ok(uaddr, sizeof(u32)))
-		return -EFAULT;
-
-	return atomic_futex_op_cmpxchg_inatomic(uval, uaddr, oldval, newval);
-}
-
-static inline int arch_futex_atomic_op_inuser(int op, u32 oparg, int *oval,
-		u32 __user *uaddr)
-{
-	u32 oldval, newval, prev;
-	int ret;
-
-	do {
-		ret = get_user(oldval, uaddr);
-
-		if (ret) break;
-
-		switch (op) {
-		case FUTEX_OP_SET:
-			newval = oparg;
-			break;
-		case FUTEX_OP_ADD:
-			newval = oldval + oparg;
-			break;
-		case FUTEX_OP_OR:
-			newval = oldval | oparg;
-			break;
-		case FUTEX_OP_ANDN:
-			newval = oldval & ~oparg;
-			break;
-		case FUTEX_OP_XOR:
-			newval = oldval ^ oparg;
-			break;
-		default:
-			ret = -ENOSYS;
-			break;
-		}
-
-		if (ret) break;
-
-		ret = futex_atomic_cmpxchg_inatomic(&prev, uaddr, oldval, newval);
-	} while (!ret && prev != oldval);
-
-	if (!ret)
-		*oval = oldval;
-
-	return ret;
-}
-
-#endif /* __ASM_SH_FUTEX_H */
diff --git a/arch/sh/include/asm/gpio.h b/arch/sh/include/asm/gpio.h
deleted file mode 100644
index d643250f0a0fa0..00000000000000
--- a/arch/sh/include/asm/gpio.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- *  include/asm-sh/gpio.h
- *
- * Generic GPIO API and pinmux table support for SuperH.
- *
- * Copyright (c) 2008 Magnus Damm
- */
-#ifndef __ASM_SH_GPIO_H
-#define __ASM_SH_GPIO_H
-
-#include <linux/kernel.h>
-#include <linux/errno.h>
-
-#if defined(CONFIG_CPU_SH3)
-#include <cpu/gpio.h>
-#endif
-
-#include <asm-generic/gpio.h>
-
-#ifdef CONFIG_GPIOLIB
-
-static inline int gpio_get_value(unsigned gpio)
-{
-	return __gpio_get_value(gpio);
-}
-
-static inline void gpio_set_value(unsigned gpio, int value)
-{
-	__gpio_set_value(gpio, value);
-}
-
-static inline int gpio_cansleep(unsigned gpio)
-{
-	return __gpio_cansleep(gpio);
-}
-
-static inline int gpio_to_irq(unsigned gpio)
-{
-	return __gpio_to_irq(gpio);
-}
-
-static inline int irq_to_gpio(unsigned int irq)
-{
-	return -ENOSYS;
-}
-
-#endif /* CONFIG_GPIOLIB */
-
-#endif /* __ASM_SH_GPIO_H */
diff --git a/arch/sh/include/asm/hardirq.h b/arch/sh/include/asm/hardirq.h
deleted file mode 100644
index 9fe4495a8e90b3..00000000000000
--- a/arch/sh/include/asm/hardirq.h
+++ /dev/null
@@ -1,11 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_HARDIRQ_H
-#define __ASM_SH_HARDIRQ_H
-
-extern void ack_bad_irq(unsigned int irq);
-#define ack_bad_irq ack_bad_irq
-#define ARCH_WANTS_NMI_IRQSTAT
-
-#include <asm-generic/hardirq.h>
-
-#endif /* __ASM_SH_HARDIRQ_H */
diff --git a/arch/sh/include/asm/hd64461.h b/arch/sh/include/asm/hd64461.h
deleted file mode 100644
index afb24cb034b114..00000000000000
--- a/arch/sh/include/asm/hd64461.h
+++ /dev/null
@@ -1,252 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_HD64461
-#define __ASM_SH_HD64461
-/*
- *	Copyright (C) 2007 Kristoffer Ericson <Kristoffer.Ericson@gmail.com>
- *	Copyright (C) 2004 Paul Mundt
- *	Copyright (C) 2000 YAEGASHI Takeshi
- *
- *		Hitachi HD64461 companion chip support
- *	(please note manual reference 0x10000000 = 0xb0000000)
- */
-
-/* Constants for PCMCIA mappings */
-#define	HD64461_PCC_WINDOW	0x01000000
-
-/* Area 6 - Slot 0 - memory and/or IO card */
-#define HD64461_IOBASE		0xb0000000
-#define HD64461_IO_OFFSET(x)	(HD64461_IOBASE + (x))
-#define	HD64461_PCC0_BASE	HD64461_IO_OFFSET(0x8000000)
-#define	HD64461_PCC0_ATTR	(HD64461_PCC0_BASE)				/* 0xb80000000 */
-#define	HD64461_PCC0_COMM	(HD64461_PCC0_BASE+HD64461_PCC_WINDOW)		/* 0xb90000000 */
-#define	HD64461_PCC0_IO		(HD64461_PCC0_BASE+2*HD64461_PCC_WINDOW)	/* 0xba0000000 */
-
-/* Area 5 - Slot 1 - memory card only */
-#define	HD64461_PCC1_BASE	HD64461_IO_OFFSET(0x4000000)
-#define	HD64461_PCC1_ATTR	(HD64461_PCC1_BASE)				/* 0xb4000000 */
-#define	HD64461_PCC1_COMM	(HD64461_PCC1_BASE+HD64461_PCC_WINDOW)		/* 0xb5000000 */
-
-/* Standby Control Register for HD64461 */
-#define	HD64461_STBCR			HD64461_IO_OFFSET(0x00000000)
-#define	HD64461_STBCR_CKIO_STBY		0x2000
-#define	HD64461_STBCR_SAFECKE_IST	0x1000
-#define	HD64461_STBCR_SLCKE_IST		0x0800
-#define	HD64461_STBCR_SAFECKE_OST	0x0400
-#define	HD64461_STBCR_SLCKE_OST		0x0200
-#define	HD64461_STBCR_SMIAST		0x0100
-#define	HD64461_STBCR_SLCDST		0x0080
-#define	HD64461_STBCR_SPC0ST		0x0040
-#define	HD64461_STBCR_SPC1ST		0x0020
-#define	HD64461_STBCR_SAFEST		0x0010
-#define	HD64461_STBCR_STM0ST		0x0008
-#define	HD64461_STBCR_STM1ST		0x0004
-#define	HD64461_STBCR_SIRST		0x0002
-#define	HD64461_STBCR_SURTST		0x0001
-
-/* System Configuration Register */
-#define	HD64461_SYSCR		HD64461_IO_OFFSET(0x02)
-
-/* CPU Data Bus Control Register */
-#define	HD64461_SCPUCR		HD64461_IO_OFFSET(0x04)
-
-/* Base Address Register */
-#define	HD64461_LCDCBAR		HD64461_IO_OFFSET(0x1000)
-
-/* Line increment address */
-#define	HD64461_LCDCLOR		HD64461_IO_OFFSET(0x1002)
-
-/* Controls LCD controller */
-#define	HD64461_LCDCCR		HD64461_IO_OFFSET(0x1004)
-
-/* LCCDR control bits */
-#define	HD64461_LCDCCR_STBACK	0x0400	/* Standby Back */
-#define	HD64461_LCDCCR_STREQ	0x0100	/* Standby Request */
-#define	HD64461_LCDCCR_MOFF	0x0080	/* Memory Off */
-#define	HD64461_LCDCCR_REFSEL	0x0040	/* Refresh Select */
-#define	HD64461_LCDCCR_EPON	0x0020	/* End Power On */
-#define	HD64461_LCDCCR_SPON	0x0010	/* Start Power On */
-
-/* Controls LCD (1) */
-#define	HD64461_LDR1		HD64461_IO_OFFSET(0x1010)
-#define	HD64461_LDR1_DON	0x01	/* Display On */
-#define	HD64461_LDR1_DINV	0x80	/* Display Invert */
-
-/* Controls LCD (2) */
-#define	HD64461_LDR2		HD64461_IO_OFFSET(0x1012)
-#define	HD64461_LDHNCR		HD64461_IO_OFFSET(0x1014)	/* Number of horizontal characters */
-#define	HD64461_LDHNSR		HD64461_IO_OFFSET(0x1016)	/* Specify output start position + width of CL1 */
-#define	HD64461_LDVNTR		HD64461_IO_OFFSET(0x1018)	/* Specify total vertical lines */
-#define	HD64461_LDVNDR		HD64461_IO_OFFSET(0x101a)	/* specify number of display vertical lines */
-#define	HD64461_LDVSPR		HD64461_IO_OFFSET(0x101c)	/* specify vertical synchronization pos and AC nr */
-
-/* Controls LCD (3) */
-#define	HD64461_LDR3		HD64461_IO_OFFSET(0x101e)
-
-/* Palette Registers */
-#define	HD64461_CPTWAR		HD64461_IO_OFFSET(0x1030)	/* Color Palette Write Address Register */
-#define	HD64461_CPTWDR		HD64461_IO_OFFSET(0x1032)	/* Color Palette Write Data Register */
-#define	HD64461_CPTRAR		HD64461_IO_OFFSET(0x1034)	/* Color Palette Read Address Register */
-#define	HD64461_CPTRDR		HD64461_IO_OFFSET(0x1036)	/* Color Palette Read Data Register */
-
-#define	HD64461_GRDOR		HD64461_IO_OFFSET(0x1040)	/* Display Resolution Offset Register */
-#define	HD64461_GRSCR		HD64461_IO_OFFSET(0x1042)	/* Solid Color Register */
-#define	HD64461_GRCFGR		HD64461_IO_OFFSET(0x1044)	/* Accelerator Configuration Register */
-
-#define	HD64461_GRCFGR_ACCSTATUS	0x10	/* Accelerator Status */
-#define	HD64461_GRCFGR_ACCRESET		0x08	/* Accelerator Reset */
-#define	HD64461_GRCFGR_ACCSTART_BITBLT	0x06	/* Accelerator Start BITBLT */
-#define	HD64461_GRCFGR_ACCSTART_LINE	0x04	/* Accelerator Start Line Drawing */
-#define	HD64461_GRCFGR_COLORDEPTH16	0x01	/* Sets Colordepth 16 for Accelerator */
-#define	HD64461_GRCFGR_COLORDEPTH8	0x01	/* Sets Colordepth 8 for Accelerator */
-
-/* Line Drawing Registers */
-#define	HD64461_LNSARH		HD64461_IO_OFFSET(0x1046)	/* Line Start Address Register (H) */
-#define	HD64461_LNSARL		HD64461_IO_OFFSET(0x1048)	/* Line Start Address Register (L) */
-#define	HD64461_LNAXLR		HD64461_IO_OFFSET(0x104a)	/* Axis Pixel Length Register */
-#define	HD64461_LNDGR		HD64461_IO_OFFSET(0x104c)	/* Diagonal Register */
-#define	HD64461_LNAXR		HD64461_IO_OFFSET(0x104e)	/* Axial Register */
-#define	HD64461_LNERTR		HD64461_IO_OFFSET(0x1050)	/* Start Error Term Register */
-#define	HD64461_LNMDR		HD64461_IO_OFFSET(0x1052)	/* Line Mode Register */
-
-/* BitBLT Registers */
-#define	HD64461_BBTSSARH	HD64461_IO_OFFSET(0x1054)	/* Source Start Address Register (H) */
-#define	HD64461_BBTSSARL	HD64461_IO_OFFSET(0x1056)	/* Source Start Address Register (L) */
-#define	HD64461_BBTDSARH	HD64461_IO_OFFSET(0x1058)	/* Destination Start Address Register (H) */
-#define	HD64461_BBTDSARL	HD64461_IO_OFFSET(0x105a)	/* Destination Start Address Register (L) */
-#define	HD64461_BBTDWR		HD64461_IO_OFFSET(0x105c)	/* Destination Block Width Register */
-#define	HD64461_BBTDHR		HD64461_IO_OFFSET(0x105e)	/* Destination Block Height Register */
-#define	HD64461_BBTPARH		HD64461_IO_OFFSET(0x1060)	/* Pattern Start Address Register (H) */
-#define	HD64461_BBTPARL		HD64461_IO_OFFSET(0x1062)	/* Pattern Start Address Register (L) */
-#define	HD64461_BBTMARH		HD64461_IO_OFFSET(0x1064)	/* Mask Start Address Register (H) */
-#define	HD64461_BBTMARL		HD64461_IO_OFFSET(0x1066)	/* Mask Start Address Register (L) */
-#define	HD64461_BBTROPR		HD64461_IO_OFFSET(0x1068)	/* ROP Register */
-#define	HD64461_BBTMDR		HD64461_IO_OFFSET(0x106a)	/* BitBLT Mode Register */
-
-/* PC Card Controller Registers */
-/* Maps to Physical Area 6 */
-#define	HD64461_PCC0ISR		HD64461_IO_OFFSET(0x2000)	/* socket 0 interface status */
-#define	HD64461_PCC0GCR		HD64461_IO_OFFSET(0x2002)	/* socket 0 general control */
-#define	HD64461_PCC0CSCR	HD64461_IO_OFFSET(0x2004)	/* socket 0 card status change */
-#define	HD64461_PCC0CSCIER	HD64461_IO_OFFSET(0x2006)	/* socket 0 card status change interrupt enable */
-#define	HD64461_PCC0SCR		HD64461_IO_OFFSET(0x2008)	/* socket 0 software control */
-/* Maps to Physical Area 5 */
-#define	HD64461_PCC1ISR		HD64461_IO_OFFSET(0x2010)	/* socket 1 interface status */
-#define	HD64461_PCC1GCR		HD64461_IO_OFFSET(0x2012)	/* socket 1 general control */
-#define	HD64461_PCC1CSCR	HD64461_IO_OFFSET(0x2014)	/* socket 1 card status change */
-#define	HD64461_PCC1CSCIER	HD64461_IO_OFFSET(0x2016)	/* socket 1 card status change interrupt enable */
-#define	HD64461_PCC1SCR		HD64461_IO_OFFSET(0x2018)	/* socket 1 software control */
-
-/* PCC Interface Status Register */
-#define	HD64461_PCCISR_READY		0x80	/* card ready */
-#define	HD64461_PCCISR_MWP		0x40	/* card write-protected */
-#define	HD64461_PCCISR_VS2		0x20	/* voltage select pin 2 */
-#define	HD64461_PCCISR_VS1		0x10	/* voltage select pin 1 */
-#define	HD64461_PCCISR_CD2		0x08	/* card detect 2 */
-#define	HD64461_PCCISR_CD1		0x04	/* card detect 1 */
-#define	HD64461_PCCISR_BVD2		0x02	/* battery 1 */
-#define	HD64461_PCCISR_BVD1		0x01	/* battery 1 */
-
-#define	HD64461_PCCISR_PCD_MASK		0x0c	/* card detect */
-#define	HD64461_PCCISR_BVD_MASK		0x03	/* battery voltage */
-#define	HD64461_PCCISR_BVD_BATGOOD	0x03	/* battery good */
-#define	HD64461_PCCISR_BVD_BATWARN	0x01	/* battery low warning */
-#define	HD64461_PCCISR_BVD_BATDEAD1	0x02	/* battery dead */
-#define	HD64461_PCCISR_BVD_BATDEAD2	0x00	/* battery dead */
-
-/* PCC General Control Register */
-#define	HD64461_PCCGCR_DRVE		0x80	/* output drive */
-#define	HD64461_PCCGCR_PCCR		0x40	/* PC card reset */
-#define	HD64461_PCCGCR_PCCT		0x20	/* PC card type, 1=IO&mem, 0=mem */
-#define	HD64461_PCCGCR_VCC0		0x10	/* voltage control pin VCC0SEL0 */
-#define	HD64461_PCCGCR_PMMOD		0x08	/* memory mode */
-#define	HD64461_PCCGCR_PA25		0x04	/* pin A25 */
-#define	HD64461_PCCGCR_PA24		0x02	/* pin A24 */
-#define	HD64461_PCCGCR_REG		0x01	/* pin PCC0REG# */
-
-/* PCC Card Status Change Register */
-#define	HD64461_PCCCSCR_SCDI		0x80	/* sw card detect intr */
-#define	HD64461_PCCCSCR_SRV1		0x40	/* reserved */
-#define	HD64461_PCCCSCR_IREQ		0x20	/* IREQ intr req */
-#define	HD64461_PCCCSCR_SC		0x10	/* STSCHG (status change) pin */
-#define	HD64461_PCCCSCR_CDC		0x08	/* CD (card detect) change */
-#define	HD64461_PCCCSCR_RC		0x04	/* READY change */
-#define	HD64461_PCCCSCR_BW		0x02	/* battery warning change */
-#define	HD64461_PCCCSCR_BD		0x01	/* battery dead change */
-
-/* PCC Card Status Change Interrupt Enable Register */
-#define	HD64461_PCCCSCIER_CRE		0x80	/* change reset enable */
-#define	HD64461_PCCCSCIER_IREQE_MASK	0x60	/* IREQ enable */
-#define	HD64461_PCCCSCIER_IREQE_DISABLED 0x00	/* IREQ disabled */
-#define	HD64461_PCCCSCIER_IREQE_LEVEL	0x20	/* IREQ level-triggered */
-#define	HD64461_PCCCSCIER_IREQE_FALLING	0x40	/* IREQ falling-edge-trig */
-#define	HD64461_PCCCSCIER_IREQE_RISING	0x60	/* IREQ rising-edge-trig */
-
-#define	HD64461_PCCCSCIER_SCE		0x10	/* status change enable */
-#define	HD64461_PCCCSCIER_CDE		0x08	/* card detect change enable */
-#define	HD64461_PCCCSCIER_RE		0x04	/* ready change enable */
-#define	HD64461_PCCCSCIER_BWE		0x02	/* battery warn change enable */
-#define	HD64461_PCCCSCIER_BDE		0x01	/* battery dead change enable*/
-
-/* PCC Software Control Register */
-#define	HD64461_PCCSCR_VCC1		0x02	/* voltage control pin 1 */
-#define	HD64461_PCCSCR_SWP		0x01	/* write protect */
-
-/* PCC0 Output Pins Control Register */
-#define	HD64461_P0OCR		HD64461_IO_OFFSET(0x202a)
-
-/* PCC1 Output Pins Control Register */
-#define	HD64461_P1OCR		HD64461_IO_OFFSET(0x202c)
-
-/* PC Card General Control Register */
-#define	HD64461_PGCR		HD64461_IO_OFFSET(0x202e)
-
-/* Port Control Registers */
-#define	HD64461_GPACR		HD64461_IO_OFFSET(0x4000)	/* Port A - Handles IRDA/TIMER */
-#define	HD64461_GPBCR		HD64461_IO_OFFSET(0x4002)	/* Port B - Handles UART */
-#define	HD64461_GPCCR		HD64461_IO_OFFSET(0x4004)	/* Port C - Handles PCMCIA 1 */
-#define	HD64461_GPDCR		HD64461_IO_OFFSET(0x4006)	/* Port D - Handles PCMCIA 1 */
-
-/* Port Control Data Registers */
-#define	HD64461_GPADR		HD64461_IO_OFFSET(0x4010)	/* A */
-#define	HD64461_GPBDR		HD64461_IO_OFFSET(0x4012)	/* B */
-#define	HD64461_GPCDR		HD64461_IO_OFFSET(0x4014)	/* C */
-#define	HD64461_GPDDR		HD64461_IO_OFFSET(0x4016)	/* D */
-
-/* Interrupt Control Registers */
-#define	HD64461_GPAICR		HD64461_IO_OFFSET(0x4020)	/* A */
-#define	HD64461_GPBICR		HD64461_IO_OFFSET(0x4022)	/* B */
-#define	HD64461_GPCICR		HD64461_IO_OFFSET(0x4024)	/* C */
-#define	HD64461_GPDICR		HD64461_IO_OFFSET(0x4026)	/* D */
-
-/* Interrupt Status Registers */
-#define	HD64461_GPAISR		HD64461_IO_OFFSET(0x4040)	/* A */
-#define	HD64461_GPBISR		HD64461_IO_OFFSET(0x4042)	/* B */
-#define	HD64461_GPCISR		HD64461_IO_OFFSET(0x4044)	/* C */
-#define	HD64461_GPDISR		HD64461_IO_OFFSET(0x4046)	/* D */
-
-/* Interrupt Request Register & Interrupt Mask Register */
-#define	HD64461_NIRR		HD64461_IO_OFFSET(0x5000)
-#define	HD64461_NIMR		HD64461_IO_OFFSET(0x5002)
-
-#define	HD64461_IRQBASE		OFFCHIP_IRQ_BASE
-#define	OFFCHIP_IRQ_BASE	64
-#define	HD64461_IRQ_NUM		16
-
-#define	HD64461_IRQ_UART	(HD64461_IRQBASE+5)
-#define	HD64461_IRQ_IRDA	(HD64461_IRQBASE+6)
-#define	HD64461_IRQ_TMU1	(HD64461_IRQBASE+9)
-#define	HD64461_IRQ_TMU0	(HD64461_IRQBASE+10)
-#define	HD64461_IRQ_GPIO	(HD64461_IRQBASE+11)
-#define	HD64461_IRQ_AFE		(HD64461_IRQBASE+12)
-#define	HD64461_IRQ_PCC1	(HD64461_IRQBASE+13)
-#define	HD64461_IRQ_PCC0	(HD64461_IRQBASE+14)
-
-#define __IO_PREFIX	hd64461
-#include <asm/io_generic.h>
-
-/* arch/sh/cchips/hd6446x/hd64461/setup.c */
-void hd64461_register_irq_demux(int irq,
-				int (*demux) (int irq, void *dev), void *dev);
-void hd64461_unregister_irq_demux(int irq);
-
-#endif
diff --git a/arch/sh/include/asm/heartbeat.h b/arch/sh/include/asm/heartbeat.h
deleted file mode 100644
index 4028ca4058d171..00000000000000
--- a/arch/sh/include/asm/heartbeat.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_HEARTBEAT_H
-#define __ASM_SH_HEARTBEAT_H
-
-#include <linux/timer.h>
-
-#define HEARTBEAT_INVERTED	(1 << 0)
-
-struct heartbeat_data {
-	void __iomem *base;
-	unsigned char *bit_pos;
-	unsigned int nr_bits;
-	struct timer_list timer;
-	unsigned int regsize;
-	unsigned int mask;
-	unsigned long flags;
-};
-
-#endif /* __ASM_SH_HEARTBEAT_H */
diff --git a/arch/sh/include/asm/hugetlb.h b/arch/sh/include/asm/hugetlb.h
deleted file mode 100644
index 4d3ba39e681c4f..00000000000000
--- a/arch/sh/include/asm/hugetlb.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _ASM_SH_HUGETLB_H
-#define _ASM_SH_HUGETLB_H
-
-#include <asm/cacheflush.h>
-#include <asm/page.h>
-
-/*
- * If the arch doesn't supply something else, assume that hugepage
- * size aligned regions are ok without further preparation.
- */
-#define __HAVE_ARCH_PREPARE_HUGEPAGE_RANGE
-static inline int prepare_hugepage_range(struct file *file,
-			unsigned long addr, unsigned long len)
-{
-	if (len & ~HPAGE_MASK)
-		return -EINVAL;
-	if (addr & ~HPAGE_MASK)
-		return -EINVAL;
-	return 0;
-}
-
-#define __HAVE_ARCH_HUGE_PTEP_CLEAR_FLUSH
-static inline pte_t huge_ptep_clear_flush(struct vm_area_struct *vma,
-					  unsigned long addr, pte_t *ptep)
-{
-	return *ptep;
-}
-
-static inline void arch_clear_hugepage_flags(struct page *page)
-{
-	clear_bit(PG_dcache_clean, &page->flags);
-}
-#define arch_clear_hugepage_flags arch_clear_hugepage_flags
-
-#include <asm-generic/hugetlb.h>
-
-#endif /* _ASM_SH_HUGETLB_H */
diff --git a/arch/sh/include/asm/hw_breakpoint.h b/arch/sh/include/asm/hw_breakpoint.h
deleted file mode 100644
index 361a0f57bdebda..00000000000000
--- a/arch/sh/include/asm/hw_breakpoint.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_HW_BREAKPOINT_H
-#define __ASM_SH_HW_BREAKPOINT_H
-
-#include <uapi/asm/hw_breakpoint.h>
-
-#define __ARCH_HW_BREAKPOINT_H
-
-#include <linux/kdebug.h>
-#include <linux/types.h>
-
-struct arch_hw_breakpoint {
-	unsigned long	address;
-	u16		len;
-	u16		type;
-};
-
-enum {
-	SH_BREAKPOINT_READ	= (1 << 1),
-	SH_BREAKPOINT_WRITE	= (1 << 2),
-	SH_BREAKPOINT_RW	= SH_BREAKPOINT_READ | SH_BREAKPOINT_WRITE,
-
-	SH_BREAKPOINT_LEN_1	= (1 << 12),
-	SH_BREAKPOINT_LEN_2	= (1 << 13),
-	SH_BREAKPOINT_LEN_4	= SH_BREAKPOINT_LEN_1 | SH_BREAKPOINT_LEN_2,
-	SH_BREAKPOINT_LEN_8	= (1 << 14),
-};
-
-struct sh_ubc {
-	const char	*name;
-	unsigned int	num_events;
-	unsigned int	trap_nr;
-	void		(*enable)(struct arch_hw_breakpoint *, int);
-	void		(*disable)(struct arch_hw_breakpoint *, int);
-	void		(*enable_all)(unsigned long);
-	void		(*disable_all)(void);
-	unsigned long	(*active_mask)(void);
-	unsigned long	(*triggered_mask)(void);
-	void		(*clear_triggered_mask)(unsigned long);
-	struct clk	*clk;	/* optional interface clock / MSTP bit */
-};
-
-struct perf_event_attr;
-struct perf_event;
-struct task_struct;
-struct pmu;
-
-/* Maximum number of UBC channels */
-#define HBP_NUM		2
-
-#define hw_breakpoint_slots(type) (HBP_NUM)
-
-/* arch/sh/kernel/hw_breakpoint.c */
-extern int arch_check_bp_in_kernelspace(struct arch_hw_breakpoint *hw);
-extern int hw_breakpoint_arch_parse(struct perf_event *bp,
-				    const struct perf_event_attr *attr,
-				    struct arch_hw_breakpoint *hw);
-extern int hw_breakpoint_exceptions_notify(struct notifier_block *unused,
-					   unsigned long val, void *data);
-
-int arch_install_hw_breakpoint(struct perf_event *bp);
-void arch_uninstall_hw_breakpoint(struct perf_event *bp);
-void hw_breakpoint_pmu_read(struct perf_event *bp);
-
-extern void arch_fill_perf_breakpoint(struct perf_event *bp);
-extern int register_sh_ubc(struct sh_ubc *);
-
-extern struct pmu perf_ops_bp;
-
-#endif /* __ASM_SH_HW_BREAKPOINT_H */
diff --git a/arch/sh/include/asm/hw_irq.h b/arch/sh/include/asm/hw_irq.h
deleted file mode 100644
index ce23e3332f9c97..00000000000000
--- a/arch/sh/include/asm/hw_irq.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_HW_IRQ_H
-#define __ASM_SH_HW_IRQ_H
-
-#include <linux/init.h>
-#include <linux/sh_intc.h>
-#include <linux/atomic.h>
-
-extern atomic_t irq_err_count;
-
-struct ipr_data {
-	unsigned char irq;
-	unsigned char ipr_idx;		/* Index for the IPR registered */
-	unsigned char shift;		/* Number of bits to shift the data */
-	unsigned char priority;		/* The priority */
-};
-
-struct ipr_desc {
-	unsigned long *ipr_offsets;
-	unsigned int nr_offsets;
-	struct ipr_data *ipr_data;
-	unsigned int nr_irqs;
-	struct irq_chip chip;
-};
-
-void register_ipr_controller(struct ipr_desc *);
-
-void __init plat_irq_setup(void);
-void __init plat_irq_setup_sh3(void);
-void __init plat_irq_setup_pins(int mode);
-
-enum { IRQ_MODE_IRQ, IRQ_MODE_IRQ7654, IRQ_MODE_IRQ3210,
-       IRQ_MODE_IRL7654_MASK, IRQ_MODE_IRL3210_MASK,
-       IRQ_MODE_IRL7654, IRQ_MODE_IRL3210 };
-
-#endif /* __ASM_SH_HW_IRQ_H */
diff --git a/arch/sh/include/asm/i2c-sh7760.h b/arch/sh/include/asm/i2c-sh7760.h
deleted file mode 100644
index a777f1410a6e98..00000000000000
--- a/arch/sh/include/asm/i2c-sh7760.h
+++ /dev/null
@@ -1,21 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * MMIO/IRQ and platform data for SH7760 I2C channels
- */
-
-#ifndef _I2C_SH7760_H_
-#define _I2C_SH7760_H_
-
-#define SH7760_I2C_DEVNAME	"sh7760-i2c"
-
-#define SH7760_I2C0_MMIO	0xFE140000
-#define SH7760_I2C0_MMIOEND	0xFE14003B
-
-#define SH7760_I2C1_MMIO	0xFE150000
-#define SH7760_I2C1_MMIOEND	0xFE15003B
-
-struct sh7760_i2c_platdata {
-	unsigned int speed_khz;
-};
-
-#endif
diff --git a/arch/sh/include/asm/io.h b/arch/sh/include/asm/io.h
deleted file mode 100644
index fba90e670ed41d..00000000000000
--- a/arch/sh/include/asm/io.h
+++ /dev/null
@@ -1,294 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_IO_H
-#define __ASM_SH_IO_H
-
-/*
- * Convention:
- *    read{b,w,l,q}/write{b,w,l,q} are for PCI,
- *    while in{b,w,l}/out{b,w,l} are for ISA
- *
- * In addition we have 'pausing' versions: in{b,w,l}_p/out{b,w,l}_p
- * and 'string' versions: ins{b,w,l}/outs{b,w,l}
- *
- * While read{b,w,l,q} and write{b,w,l,q} contain memory barriers
- * automatically, there are also __raw versions, which do not.
- */
-#include <linux/errno.h>
-#include <asm/cache.h>
-#include <asm/addrspace.h>
-#include <asm/machvec.h>
-#include <asm/page.h>
-#include <linux/pgtable.h>
-#include <asm-generic/iomap.h>
-
-#define __IO_PREFIX     generic
-#include <asm/io_generic.h>
-#include <asm-generic/pci_iomap.h>
-#include <mach/mangle-port.h>
-
-#define __raw_writeb(v,a)	(__chk_io_ptr(a), *(volatile u8  __force *)(a) = (v))
-#define __raw_writew(v,a)	(__chk_io_ptr(a), *(volatile u16 __force *)(a) = (v))
-#define __raw_writel(v,a)	(__chk_io_ptr(a), *(volatile u32 __force *)(a) = (v))
-#define __raw_writeq(v,a)	(__chk_io_ptr(a), *(volatile u64 __force *)(a) = (v))
-
-#define __raw_readb(a)		(__chk_io_ptr(a), *(volatile u8  __force *)(a))
-#define __raw_readw(a)		(__chk_io_ptr(a), *(volatile u16 __force *)(a))
-#define __raw_readl(a)		(__chk_io_ptr(a), *(volatile u32 __force *)(a))
-#define __raw_readq(a)		(__chk_io_ptr(a), *(volatile u64 __force *)(a))
-
-#define readb_relaxed(c)	({ u8  __v = ioswabb(__raw_readb(c)); __v; })
-#define readw_relaxed(c)	({ u16 __v = ioswabw(__raw_readw(c)); __v; })
-#define readl_relaxed(c)	({ u32 __v = ioswabl(__raw_readl(c)); __v; })
-#define readq_relaxed(c)	({ u64 __v = ioswabq(__raw_readq(c)); __v; })
-
-#define writeb_relaxed(v,c)	((void)__raw_writeb((__force  u8)ioswabb(v),c))
-#define writew_relaxed(v,c)	((void)__raw_writew((__force u16)ioswabw(v),c))
-#define writel_relaxed(v,c)	((void)__raw_writel((__force u32)ioswabl(v),c))
-#define writeq_relaxed(v,c)	((void)__raw_writeq((__force u64)ioswabq(v),c))
-
-#define readb(a)		({ u8  r_ = readb_relaxed(a); rmb(); r_; })
-#define readw(a)		({ u16 r_ = readw_relaxed(a); rmb(); r_; })
-#define readl(a)		({ u32 r_ = readl_relaxed(a); rmb(); r_; })
-#define readq(a)		({ u64 r_ = readq_relaxed(a); rmb(); r_; })
-
-#define writeb(v,a)		({ wmb(); writeb_relaxed((v),(a)); })
-#define writew(v,a)		({ wmb(); writew_relaxed((v),(a)); })
-#define writel(v,a)		({ wmb(); writel_relaxed((v),(a)); })
-#define writeq(v,a)		({ wmb(); writeq_relaxed((v),(a)); })
-
-#define readsb(p,d,l)		__raw_readsb(p,d,l)
-#define readsw(p,d,l)		__raw_readsw(p,d,l)
-#define readsl(p,d,l)		__raw_readsl(p,d,l)
-
-#define writesb(p,d,l)		__raw_writesb(p,d,l)
-#define writesw(p,d,l)		__raw_writesw(p,d,l)
-#define writesl(p,d,l)		__raw_writesl(p,d,l)
-
-#define __BUILD_UNCACHED_IO(bwlq, type)					\
-static inline type read##bwlq##_uncached(unsigned long addr)		\
-{									\
-	type ret;							\
-	jump_to_uncached();						\
-	ret = __raw_read##bwlq(addr);					\
-	back_to_cached();						\
-	return ret;							\
-}									\
-									\
-static inline void write##bwlq##_uncached(type v, unsigned long addr)	\
-{									\
-	jump_to_uncached();						\
-	__raw_write##bwlq(v, addr);					\
-	back_to_cached();						\
-}
-
-__BUILD_UNCACHED_IO(b, u8)
-__BUILD_UNCACHED_IO(w, u16)
-__BUILD_UNCACHED_IO(l, u32)
-__BUILD_UNCACHED_IO(q, u64)
-
-#define __BUILD_MEMORY_STRING(pfx, bwlq, type)				\
-									\
-static inline void							\
-pfx##writes##bwlq(volatile void __iomem *mem, const void *addr,		\
-		  unsigned int count)					\
-{									\
-	const volatile type *__addr = addr;				\
-									\
-	while (count--) {						\
-		__raw_write##bwlq(*__addr, mem);			\
-		__addr++;						\
-	}								\
-}									\
-									\
-static inline void pfx##reads##bwlq(volatile void __iomem *mem,		\
-				    void *addr, unsigned int count)	\
-{									\
-	volatile type *__addr = addr;					\
-									\
-	while (count--) {						\
-		*__addr = __raw_read##bwlq(mem);			\
-		__addr++;						\
-	}								\
-}
-
-__BUILD_MEMORY_STRING(__raw_, b, u8)
-__BUILD_MEMORY_STRING(__raw_, w, u16)
-
-void __raw_writesl(void __iomem *addr, const void *data, int longlen);
-void __raw_readsl(const void __iomem *addr, void *data, int longlen);
-
-__BUILD_MEMORY_STRING(__raw_, q, u64)
-
-#ifdef CONFIG_HAS_IOPORT_MAP
-
-/*
- * Slowdown I/O port space accesses for antique hardware.
- */
-#undef CONF_SLOWDOWN_IO
-
-/*
- * On SuperH I/O ports are memory mapped, so we access them using normal
- * load/store instructions. sh_io_port_base is the virtual address to
- * which all ports are being mapped.
- */
-extern unsigned long sh_io_port_base;
-
-static inline void __set_io_port_base(unsigned long pbase)
-{
-	*(unsigned long *)&sh_io_port_base = pbase;
-	barrier();
-}
-
-#ifdef CONFIG_GENERIC_IOMAP
-#define __ioport_map ioport_map
-#else
-extern void __iomem *__ioport_map(unsigned long addr, unsigned int size);
-#endif
-
-#ifdef CONF_SLOWDOWN_IO
-#define SLOW_DOWN_IO __raw_readw(sh_io_port_base)
-#else
-#define SLOW_DOWN_IO
-#endif
-
-#define __BUILD_IOPORT_SINGLE(pfx, bwlq, type, p, slow)			\
-									\
-static inline void pfx##out##bwlq##p(type val, unsigned long port)	\
-{									\
-	volatile type *__addr;						\
-									\
-	__addr = __ioport_map(port, sizeof(type));			\
-	*__addr = val;							\
-	slow;								\
-}									\
-									\
-static inline type pfx##in##bwlq##p(unsigned long port)			\
-{									\
-	volatile type *__addr;						\
-	type __val;							\
-									\
-	__addr = __ioport_map(port, sizeof(type));			\
-	__val = *__addr;						\
-	slow;								\
-									\
-	return __val;							\
-}
-
-#define __BUILD_IOPORT_PFX(bus, bwlq, type)				\
-	__BUILD_IOPORT_SINGLE(bus, bwlq, type, ,)			\
-	__BUILD_IOPORT_SINGLE(bus, bwlq, type, _p, SLOW_DOWN_IO)
-
-#define BUILDIO_IOPORT(bwlq, type)					\
-	__BUILD_IOPORT_PFX(, bwlq, type)
-
-BUILDIO_IOPORT(b, u8)
-BUILDIO_IOPORT(w, u16)
-BUILDIO_IOPORT(l, u32)
-BUILDIO_IOPORT(q, u64)
-
-#define __BUILD_IOPORT_STRING(bwlq, type)				\
-									\
-static inline void outs##bwlq(unsigned long port, const void *addr,	\
-			      unsigned int count)			\
-{									\
-	const volatile type *__addr = addr;				\
-									\
-	while (count--) {						\
-		out##bwlq(*__addr, port);				\
-		__addr++;						\
-	}								\
-}									\
-									\
-static inline void ins##bwlq(unsigned long port, void *addr,		\
-			     unsigned int count)			\
-{									\
-	volatile type *__addr = addr;					\
-									\
-	while (count--) {						\
-		*__addr = in##bwlq(port);				\
-		__addr++;						\
-	}								\
-}
-
-__BUILD_IOPORT_STRING(b, u8)
-__BUILD_IOPORT_STRING(w, u16)
-__BUILD_IOPORT_STRING(l, u32)
-__BUILD_IOPORT_STRING(q, u64)
-
-#else /* !CONFIG_HAS_IOPORT_MAP */
-
-#include <asm/io_noioport.h>
-
-#endif
-
-
-#define IO_SPACE_LIMIT 0xffffffff
-
-/* We really want to try and get these to memcpy etc */
-void memcpy_fromio(void *, const volatile void __iomem *, unsigned long);
-void memcpy_toio(volatile void __iomem *, const void *, unsigned long);
-void memset_io(volatile void __iomem *, int, unsigned long);
-
-/* Quad-word real-mode I/O, don't ask.. */
-unsigned long long peek_real_address_q(unsigned long long addr);
-unsigned long long poke_real_address_q(unsigned long long addr,
-				       unsigned long long val);
-
-#if !defined(CONFIG_MMU)
-#define virt_to_phys(address)	((unsigned long)(address))
-#define phys_to_virt(address)	((void *)(address))
-#else
-#define virt_to_phys(address)	(__pa(address))
-#define phys_to_virt(address)	(__va(address))
-#endif
-
-#ifdef CONFIG_MMU
-void iounmap(void __iomem *addr);
-void __iomem *__ioremap_caller(phys_addr_t offset, unsigned long size,
-			       pgprot_t prot, void *caller);
-
-static inline void __iomem *ioremap(phys_addr_t offset, unsigned long size)
-{
-	return __ioremap_caller(offset, size, PAGE_KERNEL_NOCACHE,
-			__builtin_return_address(0));
-}
-
-static inline void __iomem *
-ioremap_cache(phys_addr_t offset, unsigned long size)
-{
-	return __ioremap_caller(offset, size, PAGE_KERNEL,
-			__builtin_return_address(0));
-}
-#define ioremap_cache ioremap_cache
-
-#ifdef CONFIG_HAVE_IOREMAP_PROT
-static inline void __iomem *ioremap_prot(phys_addr_t offset, unsigned long size,
-		unsigned long flags)
-{
-	return __ioremap_caller(offset, size, __pgprot(flags),
-			__builtin_return_address(0));
-}
-#endif /* CONFIG_HAVE_IOREMAP_PROT */
-
-#else /* CONFIG_MMU */
-static inline void __iomem *ioremap(phys_addr_t offset, size_t size)
-{
-	return (void __iomem *)(unsigned long)offset;
-}
-
-static inline void iounmap(volatile void __iomem *addr) { }
-#endif /* CONFIG_MMU */
-
-#define ioremap_uc	ioremap
-
-/*
- * Convert a physical pointer to a virtual kernel pointer for /dev/mem
- * access
- */
-#define xlate_dev_mem_ptr(p)	__va(p)
-
-#define ARCH_HAS_VALID_PHYS_ADDR_RANGE
-int valid_phys_addr_range(phys_addr_t addr, size_t size);
-int valid_mmap_phys_addr_range(unsigned long pfn, size_t size);
-
-#endif /* __ASM_SH_IO_H */
diff --git a/arch/sh/include/asm/io_generic.h b/arch/sh/include/asm/io_generic.h
deleted file mode 100644
index 87ec38f4e53291..00000000000000
--- a/arch/sh/include/asm/io_generic.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Trivial I/O routine definitions, intentionally meant to be included
- * multiple times. Ugly I/O routine concatenation helpers taken from
- * alpha. Must be included _before_ io.h to avoid preprocessor-induced
- * routine mismatch.
- */
-#define IO_CONCAT(a,b)	_IO_CONCAT(a,b)
-#define _IO_CONCAT(a,b)	a ## _ ## b
-
-#ifndef __IO_PREFIX
-#error "Don't include this header without a valid system prefix"
-#endif
-
-void __iomem *IO_CONCAT(__IO_PREFIX,ioport_map)(unsigned long addr, unsigned int size);
-void IO_CONCAT(__IO_PREFIX,ioport_unmap)(void __iomem *addr);
-void IO_CONCAT(__IO_PREFIX,mem_init)(void);
-
-#undef __IO_PREFIX
diff --git a/arch/sh/include/asm/io_noioport.h b/arch/sh/include/asm/io_noioport.h
deleted file mode 100644
index f7938fe0f91121..00000000000000
--- a/arch/sh/include/asm/io_noioport.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_IO_NOIOPORT_H
-#define __ASM_SH_IO_NOIOPORT_H
-
-static inline u8 inb(unsigned long addr)
-{
-	BUG();
-	return -1;
-}
-
-static inline u16 inw(unsigned long addr)
-{
-	BUG();
-	return -1;
-}
-
-static inline u32 inl(unsigned long addr)
-{
-	BUG();
-	return -1;
-}
-
-static inline void outb(unsigned char x, unsigned long port)
-{
-	BUG();
-}
-
-static inline void outw(unsigned short x, unsigned long port)
-{
-	BUG();
-}
-
-static inline void outl(unsigned int x, unsigned long port)
-{
-	BUG();
-}
-
-static inline void __iomem *ioport_map(unsigned long port, unsigned int size)
-{
-	BUG();
-	return NULL;
-}
-
-static inline void ioport_unmap(void __iomem *addr)
-{
-	BUG();
-}
-
-#define inb_p(addr)	inb(addr)
-#define inw_p(addr)	inw(addr)
-#define inl_p(addr)	inl(addr)
-#define outb_p(x, addr)	outb((x), (addr))
-#define outw_p(x, addr)	outw((x), (addr))
-#define outl_p(x, addr)	outl((x), (addr))
-
-static inline void insb(unsigned long port, void *dst, unsigned long count)
-{
-	BUG();
-}
-
-static inline void insw(unsigned long port, void *dst, unsigned long count)
-{
-	BUG();
-}
-
-static inline void insl(unsigned long port, void *dst, unsigned long count)
-{
-	BUG();
-}
-
-static inline void outsb(unsigned long port, const void *src, unsigned long count)
-{
-	BUG();
-}
-
-static inline void outsw(unsigned long port, const void *src, unsigned long count)
-{
-	BUG();
-}
-
-static inline void outsl(unsigned long port, const void *src, unsigned long count)
-{
-	BUG();
-}
-
-#endif /* __ASM_SH_IO_NOIOPORT_H */
diff --git a/arch/sh/include/asm/io_trapped.h b/arch/sh/include/asm/io_trapped.h
deleted file mode 100644
index ac01b201d9aa9b..00000000000000
--- a/arch/sh/include/asm/io_trapped.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_IO_TRAPPED_H
-#define __ASM_SH_IO_TRAPPED_H
-
-#include <linux/list.h>
-#include <linux/ioport.h>
-#include <asm/page.h>
-
-#define IO_TRAPPED_MAGIC 0xfeedbeef
-
-struct trapped_io {
-	unsigned int magic;
-	struct resource *resource;
-	unsigned int num_resources;
-	unsigned int minimum_bus_width;
-	struct list_head list;
-	void __iomem *virt_base;
-} __aligned(PAGE_SIZE);
-
-#ifdef CONFIG_IO_TRAPPED
-int register_trapped_io(struct trapped_io *tiop);
-int handle_trapped_io(struct pt_regs *regs, unsigned long address);
-
-void __iomem *match_trapped_io_handler(struct list_head *list,
-				       unsigned long offset,
-				       unsigned long size);
-
-#ifdef CONFIG_HAS_IOMEM
-extern struct list_head trapped_mem;
-
-static inline void __iomem *
-__ioremap_trapped(unsigned long offset, unsigned long size)
-{
-	return match_trapped_io_handler(&trapped_mem, offset, size);
-}
-#else
-#define __ioremap_trapped(offset, size) NULL
-#endif
-
-#ifdef CONFIG_HAS_IOPORT_MAP
-extern struct list_head trapped_io;
-
-static inline void __iomem *
-__ioport_map_trapped(unsigned long offset, unsigned long size)
-{
-	return match_trapped_io_handler(&trapped_io, offset, size);
-}
-#else
-#define __ioport_map_trapped(offset, size) NULL
-#endif
-
-#else
-#define register_trapped_io(tiop) (-1)
-#define handle_trapped_io(tiop, address) 0
-#define __ioremap_trapped(offset, size) NULL
-#define __ioport_map_trapped(offset, size) NULL
-#endif
-
-#endif /* __ASM_SH_IO_TRAPPED_H */
diff --git a/arch/sh/include/asm/irq.h b/arch/sh/include/asm/irq.h
deleted file mode 100644
index 1c4923502fd4c1..00000000000000
--- a/arch/sh/include/asm/irq.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_IRQ_H
-#define __ASM_SH_IRQ_H
-
-#include <linux/cpumask.h>
-#include <asm/machvec.h>
-
-/*
- * This is a special IRQ number for indicating that no IRQ has been
- * triggered and to simply ignore the IRQ dispatch. This is a special
- * case that can happen with IRQ auto-distribution when multiple CPUs
- * are woken up and signalled in parallel.
- */
-#define NO_IRQ_IGNORE		((unsigned int)-1)
-
-/*
- * Simple Mask Register Support
- */
-extern void make_maskreg_irq(unsigned int irq);
-extern unsigned short *irq_mask_register;
-
-/*
- * PINT IRQs
- */
-void init_IRQ_pint(void);
-void make_imask_irq(unsigned int irq);
-
-static inline int generic_irq_demux(int irq)
-{
-	return irq;
-}
-
-#define irq_demux(irq)		sh_mv.mv_irq_demux(irq)
-
-void init_IRQ(void);
-void migrate_irqs(void);
-
-asmlinkage int do_IRQ(unsigned int irq, struct pt_regs *regs);
-
-#ifdef CONFIG_IRQSTACKS
-extern void irq_ctx_init(int cpu);
-extern void irq_ctx_exit(int cpu);
-#else
-# define irq_ctx_init(cpu) do { } while (0)
-# define irq_ctx_exit(cpu) do { } while (0)
-#endif
-
-#ifdef CONFIG_INTC_BALANCING
-extern unsigned int irq_lookup(unsigned int irq);
-extern void irq_finish(unsigned int irq);
-#else
-#define irq_lookup(irq)		(irq)
-#define irq_finish(irq)		do { } while (0)
-#endif
-
-#include <asm-generic/irq.h>
-
-#endif /* __ASM_SH_IRQ_H */
diff --git a/arch/sh/include/asm/irqflags.h b/arch/sh/include/asm/irqflags.h
deleted file mode 100644
index 25f6cfef3f043a..00000000000000
--- a/arch/sh/include/asm/irqflags.h
+++ /dev/null
@@ -1,10 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_IRQFLAGS_H
-#define __ASM_SH_IRQFLAGS_H
-
-#define ARCH_IRQ_DISABLED	0xf0
-#define ARCH_IRQ_ENABLED	0x00
-
-#include <asm-generic/irqflags.h>
-
-#endif /* __ASM_SH_IRQFLAGS_H */
diff --git a/arch/sh/include/asm/kdebug.h b/arch/sh/include/asm/kdebug.h
deleted file mode 100644
index de8693fabb1d95..00000000000000
--- a/arch/sh/include/asm/kdebug.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_KDEBUG_H
-#define __ASM_SH_KDEBUG_H
-
-/* Grossly misnamed. */
-enum die_val {
-	DIE_TRAP,
-	DIE_NMI,
-	DIE_OOPS,
-	DIE_BREAKPOINT,
-	DIE_SSTEP,
-};
-
-/* arch/sh/kernel/dumpstack.c */
-extern void printk_address(unsigned long address, int reliable);
-extern void dump_mem(const char *str, const char *loglvl,
-		     unsigned long bottom, unsigned long top);
-
-#endif /* __ASM_SH_KDEBUG_H */
diff --git a/arch/sh/include/asm/kexec.h b/arch/sh/include/asm/kexec.h
deleted file mode 100644
index 927d80ba2332a7..00000000000000
--- a/arch/sh/include/asm/kexec.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_KEXEC_H
-#define __ASM_SH_KEXEC_H
-
-#include <asm/ptrace.h>
-#include <asm/string.h>
-#include <linux/kernel.h>
-
-/*
- * KEXEC_SOURCE_MEMORY_LIMIT maximum page get_free_page can return.
- * I.e. Maximum page that is mapped directly into kernel memory,
- * and kmap is not required.
- *
- * Someone correct me if FIXADDR_START - PAGEOFFSET is not the correct
- * calculation for the amount of memory directly mappable into the
- * kernel memory space.
- */
-
-/* Maximum physical address we can use pages from */
-#define KEXEC_SOURCE_MEMORY_LIMIT (-1UL)
-/* Maximum address we can reach in physical address mode */
-#define KEXEC_DESTINATION_MEMORY_LIMIT (-1UL)
-/* Maximum address we can use for the control code buffer */
-#define KEXEC_CONTROL_MEMORY_LIMIT TASK_SIZE
-
-#define KEXEC_CONTROL_PAGE_SIZE	4096
-
-/* The native architecture */
-#define KEXEC_ARCH KEXEC_ARCH_SH
-
-#ifdef CONFIG_KEXEC
-/* arch/sh/kernel/machine_kexec.c */
-void reserve_crashkernel(void);
-
-static inline void crash_setup_regs(struct pt_regs *newregs,
-				    struct pt_regs *oldregs)
-{
-	if (oldregs)
-		memcpy(newregs, oldregs, sizeof(*newregs));
-	else {
-		__asm__ __volatile__ ("mov r0, %0" : "=r" (newregs->regs[0]));
-		__asm__ __volatile__ ("mov r1, %0" : "=r" (newregs->regs[1]));
-		__asm__ __volatile__ ("mov r2, %0" : "=r" (newregs->regs[2]));
-		__asm__ __volatile__ ("mov r3, %0" : "=r" (newregs->regs[3]));
-		__asm__ __volatile__ ("mov r4, %0" : "=r" (newregs->regs[4]));
-		__asm__ __volatile__ ("mov r5, %0" : "=r" (newregs->regs[5]));
-		__asm__ __volatile__ ("mov r6, %0" : "=r" (newregs->regs[6]));
-		__asm__ __volatile__ ("mov r7, %0" : "=r" (newregs->regs[7]));
-		__asm__ __volatile__ ("mov r8, %0" : "=r" (newregs->regs[8]));
-		__asm__ __volatile__ ("mov r9, %0" : "=r" (newregs->regs[9]));
-		__asm__ __volatile__ ("mov r10, %0" : "=r" (newregs->regs[10]));
-		__asm__ __volatile__ ("mov r11, %0" : "=r" (newregs->regs[11]));
-		__asm__ __volatile__ ("mov r12, %0" : "=r" (newregs->regs[12]));
-		__asm__ __volatile__ ("mov r13, %0" : "=r" (newregs->regs[13]));
-		__asm__ __volatile__ ("mov r14, %0" : "=r" (newregs->regs[14]));
-		__asm__ __volatile__ ("mov r15, %0" : "=r" (newregs->regs[15]));
-
-		__asm__ __volatile__ ("sts pr, %0" : "=r" (newregs->pr));
-		__asm__ __volatile__ ("sts macl, %0" : "=r" (newregs->macl));
-		__asm__ __volatile__ ("sts mach, %0" : "=r" (newregs->mach));
-
-		__asm__ __volatile__ ("stc gbr, %0" : "=r" (newregs->gbr));
-		__asm__ __volatile__ ("stc sr, %0" : "=r" (newregs->sr));
-
-		newregs->pc = _THIS_IP_;
-	}
-}
-#else
-static inline void reserve_crashkernel(void) { }
-#endif /* CONFIG_KEXEC */
-
-#endif /* __ASM_SH_KEXEC_H */
diff --git a/arch/sh/include/asm/kgdb.h b/arch/sh/include/asm/kgdb.h
deleted file mode 100644
index 0d5b840cb28963..00000000000000
--- a/arch/sh/include/asm/kgdb.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_KGDB_H
-#define __ASM_SH_KGDB_H
-
-#include <asm/cacheflush.h>
-#include <asm/ptrace.h>
-
-enum regnames {
-	GDB_R0, GDB_R1, GDB_R2, GDB_R3, GDB_R4, GDB_R5, GDB_R6, GDB_R7,
-	GDB_R8, GDB_R9, GDB_R10, GDB_R11, GDB_R12, GDB_R13, GDB_R14, GDB_R15,
-
-	GDB_PC, GDB_PR, GDB_SR, GDB_GBR, GDB_MACH, GDB_MACL, GDB_VBR,
-};
-
-#define _GP_REGS	16
-#define _EXTRA_REGS	7
-#define GDB_SIZEOF_REG	sizeof(u32)
-
-#define DBG_MAX_REG_NUM	(_GP_REGS + _EXTRA_REGS)
-#define NUMREGBYTES	(DBG_MAX_REG_NUM * sizeof(GDB_SIZEOF_REG))
-
-static inline void arch_kgdb_breakpoint(void)
-{
-	__asm__ __volatile__ ("trapa #0x3c\n");
-}
-
-#define BREAK_INSTR_SIZE	2
-#define BUFMAX			2048
-
-#ifdef CONFIG_SMP
-# define CACHE_FLUSH_IS_SAFE	0
-#else
-# define CACHE_FLUSH_IS_SAFE	1
-#endif
-
-#define GDB_ADJUSTS_BREAK_OFFSET
-
-#endif /* __ASM_SH_KGDB_H */
diff --git a/arch/sh/include/asm/kprobes.h b/arch/sh/include/asm/kprobes.h
deleted file mode 100644
index eeba83e0a7d294..00000000000000
--- a/arch/sh/include/asm/kprobes.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_KPROBES_H
-#define __ASM_SH_KPROBES_H
-
-#include <asm-generic/kprobes.h>
-
-#define BREAKPOINT_INSTRUCTION	0xc33a
-
-#ifdef CONFIG_KPROBES
-
-#include <linux/types.h>
-#include <linux/ptrace.h>
-
-typedef insn_size_t kprobe_opcode_t;
-
-#define MAX_INSN_SIZE 16
-#define MAX_STACK_SIZE 64
-#define MIN_STACK_SIZE(ADDR) (((MAX_STACK_SIZE) < \
-	(((unsigned long)current_thread_info()) + THREAD_SIZE - (ADDR))) \
-	? (MAX_STACK_SIZE) \
-	: (((unsigned long)current_thread_info()) + THREAD_SIZE - (ADDR)))
-
-#define flush_insn_slot(p)		do { } while (0)
-#define kretprobe_blacklist_size	0
-
-struct kprobe;
-
-void arch_remove_kprobe(struct kprobe *);
-void __kretprobe_trampoline(void);
-
-/* Architecture specific copy of original instruction*/
-struct arch_specific_insn {
-	/* copy of the original instruction */
-	kprobe_opcode_t insn[MAX_INSN_SIZE];
-};
-
-struct prev_kprobe {
-	struct kprobe *kp;
-	unsigned long status;
-};
-
-/* per-cpu kprobe control block */
-struct kprobe_ctlblk {
-	unsigned long kprobe_status;
-	struct prev_kprobe prev_kprobe;
-};
-
-extern int kprobe_fault_handler(struct pt_regs *regs, int trapnr);
-extern int kprobe_exceptions_notify(struct notifier_block *self,
-				    unsigned long val, void *data);
-extern int kprobe_handle_illslot(unsigned long pc);
-#else
-
-#define kprobe_handle_illslot(pc)	(-1)
-
-#endif /* CONFIG_KPROBES */
-#endif /* __ASM_SH_KPROBES_H */
diff --git a/arch/sh/include/asm/linkage.h b/arch/sh/include/asm/linkage.h
deleted file mode 100644
index 7c2fa27a43f849..00000000000000
--- a/arch/sh/include/asm/linkage.h
+++ /dev/null
@@ -1,8 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_LINKAGE_H
-#define __ASM_LINKAGE_H
-
-#define __ALIGN .balign 4
-#define __ALIGN_STR ".balign 4"
-
-#endif
diff --git a/arch/sh/include/asm/machvec.h b/arch/sh/include/asm/machvec.h
deleted file mode 100644
index 2b4b085e8f2195..00000000000000
--- a/arch/sh/include/asm/machvec.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/machvec.h
- *
- * Copyright 2000 Stuart Menefy (stuart.menefy@st.com)
- */
-
-#ifndef _ASM_SH_MACHVEC_H
-#define _ASM_SH_MACHVEC_H
-
-#include <linux/types.h>
-#include <linux/time.h>
-#include <generated/machtypes.h>
-
-struct sh_machine_vector {
-	void (*mv_setup)(char **cmdline_p);
-	const char *mv_name;
-
-	int (*mv_irq_demux)(int irq);
-	void (*mv_init_irq)(void);
-
-#ifdef CONFIG_HAS_IOPORT_MAP
-	void __iomem *(*mv_ioport_map)(unsigned long port, unsigned int size);
-	void (*mv_ioport_unmap)(void __iomem *);
-#endif
-
-	int (*mv_clk_init)(void);
-	int (*mv_mode_pins)(void);
-
-	void (*mv_mem_init)(void);
-	void (*mv_mem_reserve)(void);
-};
-
-extern struct sh_machine_vector sh_mv;
-
-#define get_system_type()	sh_mv.mv_name
-
-#define __initmv \
-	__used __section(".machvec.init")
-
-#endif /* _ASM_SH_MACHVEC_H */
diff --git a/arch/sh/include/asm/mmiowb.h b/arch/sh/include/asm/mmiowb.h
deleted file mode 100644
index 535d59735f1d85..00000000000000
--- a/arch/sh/include/asm/mmiowb.h
+++ /dev/null
@@ -1,12 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_MMIOWB_H
-#define __ASM_SH_MMIOWB_H
-
-#include <asm/barrier.h>
-
-/* synco on SH-4A, otherwise a nop */
-#define mmiowb()			wmb()
-
-#include <asm-generic/mmiowb.h>
-
-#endif	/* __ASM_SH_MMIOWB_H */
diff --git a/arch/sh/include/asm/mmu.h b/arch/sh/include/asm/mmu.h
deleted file mode 100644
index 172e329fd92d02..00000000000000
--- a/arch/sh/include/asm/mmu.h
+++ /dev/null
@@ -1,107 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __MMU_H
-#define __MMU_H
-
-/*
- * Privileged Space Mapping Buffer (PMB) definitions
- */
-#define PMB_PASCR		0xff000070
-#define PMB_IRMCR		0xff000078
-
-#define PASCR_SE		0x80000000
-
-#define PMB_ADDR		0xf6100000
-#define PMB_DATA		0xf7100000
-
-#define NR_PMB_ENTRIES		16
-
-#define PMB_E_MASK		0x0000000f
-#define PMB_E_SHIFT		8
-
-#define PMB_PFN_MASK		0xff000000
-
-#define PMB_SZ_16M		0x00000000
-#define PMB_SZ_64M		0x00000010
-#define PMB_SZ_128M		0x00000080
-#define PMB_SZ_512M		0x00000090
-#define PMB_SZ_MASK		PMB_SZ_512M
-#define PMB_C			0x00000008
-#define PMB_WT			0x00000001
-#define PMB_UB			0x00000200
-#define PMB_CACHE_MASK		(PMB_C | PMB_WT | PMB_UB)
-#define PMB_V			0x00000100
-
-#define PMB_NO_ENTRY		(-1)
-
-#ifndef __ASSEMBLY__
-#include <linux/errno.h>
-#include <linux/threads.h>
-#include <asm/page.h>
-
-/* Default "unsigned long" context */
-typedef unsigned long mm_context_id_t[NR_CPUS];
-
-typedef struct {
-#ifdef CONFIG_MMU
-	mm_context_id_t		id;
-	void			*vdso;
-#else
-	unsigned long		end_brk;
-#endif
-#ifdef CONFIG_BINFMT_ELF_FDPIC
-	unsigned long		exec_fdpic_loadmap;
-	unsigned long		interp_fdpic_loadmap;
-#endif
-} mm_context_t;
-
-#ifdef CONFIG_PMB
-/* arch/sh/mm/pmb.c */
-bool __in_29bit_mode(void);
-
-void pmb_init(void);
-int pmb_bolt_mapping(unsigned long virt, phys_addr_t phys,
-		     unsigned long size, pgprot_t prot);
-void __iomem *pmb_remap_caller(phys_addr_t phys, unsigned long size,
-			       pgprot_t prot, void *caller);
-int pmb_unmap(void __iomem *addr);
-
-#else
-
-static inline int
-pmb_bolt_mapping(unsigned long virt, phys_addr_t phys,
-		 unsigned long size, pgprot_t prot)
-{
-	return -EINVAL;
-}
-
-static inline void __iomem *
-pmb_remap_caller(phys_addr_t phys, unsigned long size,
-		 pgprot_t prot, void *caller)
-{
-	return NULL;
-}
-
-static inline int pmb_unmap(void __iomem *addr)
-{
-	return -EINVAL;
-}
-
-#define pmb_init(addr)		do { } while (0)
-
-#ifdef CONFIG_29BIT
-#define __in_29bit_mode()	(1)
-#else
-#define __in_29bit_mode()	(0)
-#endif
-
-#endif /* CONFIG_PMB */
-
-static inline void __iomem *
-pmb_remap(phys_addr_t phys, unsigned long size, pgprot_t prot)
-{
-	return pmb_remap_caller(phys, size, prot, __builtin_return_address(0));
-}
-
-#endif /* __ASSEMBLY__ */
-
-#endif /* __MMU_H */
diff --git a/arch/sh/include/asm/mmu_context.h b/arch/sh/include/asm/mmu_context.h
deleted file mode 100644
index 78eef4e7d5df28..00000000000000
--- a/arch/sh/include/asm/mmu_context.h
+++ /dev/null
@@ -1,178 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 1999 Niibe Yutaka
- * Copyright (C) 2003 - 2007 Paul Mundt
- *
- * ASID handling idea taken from MIPS implementation.
- */
-#ifndef __ASM_SH_MMU_CONTEXT_H
-#define __ASM_SH_MMU_CONTEXT_H
-
-#include <cpu/mmu_context.h>
-#include <asm/tlbflush.h>
-#include <linux/uaccess.h>
-#include <linux/mm_types.h>
-
-#include <asm/io.h>
-#include <asm-generic/mm_hooks.h>
-
-/*
- * The MMU "context" consists of two things:
- *    (a) TLB cache version (or round, cycle whatever expression you like)
- *    (b) ASID (Address Space IDentifier)
- */
-#ifdef CONFIG_CPU_HAS_PTEAEX
-#define MMU_CONTEXT_ASID_MASK		0x0000ffff
-#else
-#define MMU_CONTEXT_ASID_MASK		0x000000ff
-#endif
-
-#define MMU_CONTEXT_VERSION_MASK	(~0UL & ~MMU_CONTEXT_ASID_MASK)
-#define MMU_CONTEXT_FIRST_VERSION	(MMU_CONTEXT_ASID_MASK + 1)
-
-/* Impossible ASID value, to differentiate from NO_CONTEXT. */
-#define MMU_NO_ASID			MMU_CONTEXT_FIRST_VERSION
-#define NO_CONTEXT			0UL
-
-#define asid_cache(cpu)		(cpu_data[cpu].asid_cache)
-
-#ifdef CONFIG_MMU
-#define cpu_context(cpu, mm)	((mm)->context.id[cpu])
-
-#define cpu_asid(cpu, mm)	\
-	(cpu_context((cpu), (mm)) & MMU_CONTEXT_ASID_MASK)
-
-/*
- * Virtual Page Number mask
- */
-#define MMU_VPN_MASK	0xfffff000
-
-#include <asm/mmu_context_32.h>
-
-/*
- * Get MMU context if needed.
- */
-static inline void get_mmu_context(struct mm_struct *mm, unsigned int cpu)
-{
-	unsigned long asid = asid_cache(cpu);
-
-	/* Check if we have old version of context. */
-	if (((cpu_context(cpu, mm) ^ asid) & MMU_CONTEXT_VERSION_MASK) == 0)
-		/* It's up to date, do nothing */
-		return;
-
-	/* It's old, we need to get new context with new version. */
-	if (!(++asid & MMU_CONTEXT_ASID_MASK)) {
-		/*
-		 * We exhaust ASID of this version.
-		 * Flush all TLB and start new cycle.
-		 */
-		local_flush_tlb_all();
-
-		/*
-		 * Fix version; Note that we avoid version #0
-		 * to distinguish NO_CONTEXT.
-		 */
-		if (!asid)
-			asid = MMU_CONTEXT_FIRST_VERSION;
-	}
-
-	cpu_context(cpu, mm) = asid_cache(cpu) = asid;
-}
-
-/*
- * Initialize the context related info for a new mm_struct
- * instance.
- */
-#define init_new_context init_new_context
-static inline int init_new_context(struct task_struct *tsk,
-				   struct mm_struct *mm)
-{
-	int i;
-
-	for_each_online_cpu(i)
-		cpu_context(i, mm) = NO_CONTEXT;
-
-	return 0;
-}
-
-/*
- * After we have set current->mm to a new value, this activates
- * the context for the new mm so we see the new mappings.
- */
-static inline void activate_context(struct mm_struct *mm, unsigned int cpu)
-{
-	get_mmu_context(mm, cpu);
-	set_asid(cpu_asid(cpu, mm));
-}
-
-static inline void switch_mm(struct mm_struct *prev,
-			     struct mm_struct *next,
-			     struct task_struct *tsk)
-{
-	unsigned int cpu = smp_processor_id();
-
-	if (likely(prev != next)) {
-		cpumask_set_cpu(cpu, mm_cpumask(next));
-		set_TTB(next->pgd);
-		activate_context(next, cpu);
-	} else
-		if (!cpumask_test_and_set_cpu(cpu, mm_cpumask(next)))
-			activate_context(next, cpu);
-}
-
-#include <asm-generic/mmu_context.h>
-
-#else
-
-#define set_asid(asid)			do { } while (0)
-#define get_asid()			(0)
-#define cpu_asid(cpu, mm)		({ (void)cpu; NO_CONTEXT; })
-#define switch_and_save_asid(asid)	(0)
-#define set_TTB(pgd)			do { } while (0)
-#define get_TTB()			(0)
-
-#include <asm-generic/nommu_context.h>
-
-#endif /* CONFIG_MMU */
-
-#if defined(CONFIG_CPU_SH3) || defined(CONFIG_CPU_SH4)
-/*
- * If this processor has an MMU, we need methods to turn it off/on ..
- * paging_init() will also have to be updated for the processor in
- * question.
- */
-static inline void enable_mmu(void)
-{
-	unsigned int cpu = smp_processor_id();
-
-	/* Enable MMU */
-	__raw_writel(MMU_CONTROL_INIT, MMUCR);
-	ctrl_barrier();
-
-	if (asid_cache(cpu) == NO_CONTEXT)
-		asid_cache(cpu) = MMU_CONTEXT_FIRST_VERSION;
-
-	set_asid(asid_cache(cpu) & MMU_CONTEXT_ASID_MASK);
-}
-
-static inline void disable_mmu(void)
-{
-	unsigned long cr;
-
-	cr = __raw_readl(MMUCR);
-	cr &= ~MMU_CONTROL_INIT;
-	__raw_writel(cr, MMUCR);
-
-	ctrl_barrier();
-}
-#else
-/*
- * MMU control handlers for processors lacking memory
- * management hardware.
- */
-#define enable_mmu()	do { } while (0)
-#define disable_mmu()	do { } while (0)
-#endif
-
-#endif /* __ASM_SH_MMU_CONTEXT_H */
diff --git a/arch/sh/include/asm/mmu_context_32.h b/arch/sh/include/asm/mmu_context_32.h
deleted file mode 100644
index bc5034fa62493b..00000000000000
--- a/arch/sh/include/asm/mmu_context_32.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_MMU_CONTEXT_32_H
-#define __ASM_SH_MMU_CONTEXT_32_H
-
-#ifdef CONFIG_CPU_HAS_PTEAEX
-static inline void set_asid(unsigned long asid)
-{
-	__raw_writel(asid, MMU_PTEAEX);
-}
-
-static inline unsigned long get_asid(void)
-{
-	return __raw_readl(MMU_PTEAEX) & MMU_CONTEXT_ASID_MASK;
-}
-#else
-static inline void set_asid(unsigned long asid)
-{
-	unsigned long __dummy;
-
-	__asm__ __volatile__ ("mov.l	%2, %0\n\t"
-			      "and	%3, %0\n\t"
-			      "or	%1, %0\n\t"
-			      "mov.l	%0, %2"
-			      : "=&r" (__dummy)
-			      : "r" (asid), "m" (__m(MMU_PTEH)),
-			        "r" (0xffffff00));
-}
-
-static inline unsigned long get_asid(void)
-{
-	unsigned long asid;
-
-	__asm__ __volatile__ ("mov.l	%1, %0"
-			      : "=r" (asid)
-			      : "m" (__m(MMU_PTEH)));
-	asid &= MMU_CONTEXT_ASID_MASK;
-	return asid;
-}
-#endif /* CONFIG_CPU_HAS_PTEAEX */
-
-/* MMU_TTB is used for optimizing the fault handling. */
-static inline void set_TTB(pgd_t *pgd)
-{
-	__raw_writel((unsigned long)pgd, MMU_TTB);
-}
-
-static inline pgd_t *get_TTB(void)
-{
-	return (pgd_t *)__raw_readl(MMU_TTB);
-}
-#endif /* __ASM_SH_MMU_CONTEXT_32_H */
diff --git a/arch/sh/include/asm/mmzone.h b/arch/sh/include/asm/mmzone.h
deleted file mode 100644
index 7b8dead2723dc3..00000000000000
--- a/arch/sh/include/asm/mmzone.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_MMZONE_H
-#define __ASM_SH_MMZONE_H
-
-#ifdef CONFIG_NUMA
-#include <linux/numa.h>
-
-extern struct pglist_data *node_data[];
-#define NODE_DATA(nid)		(node_data[nid])
-
-static inline int pfn_to_nid(unsigned long pfn)
-{
-	int nid;
-
-	for (nid = 0; nid < MAX_NUMNODES; nid++)
-		if (pfn >= node_start_pfn(nid) && pfn <= node_end_pfn(nid))
-			break;
-
-	return nid;
-}
-
-static inline struct pglist_data *pfn_to_pgdat(unsigned long pfn)
-{
-	return NODE_DATA(pfn_to_nid(pfn));
-}
-
-/* arch/sh/mm/numa.c */
-void __init setup_bootmem_node(int nid, unsigned long start, unsigned long end);
-#else
-static inline void
-setup_bootmem_node(int nid, unsigned long start, unsigned long end)
-{
-}
-#endif /* CONFIG_NUMA */
-
-/* Platform specific mem init */
-void __init plat_mem_setup(void);
-
-/* arch/sh/kernel/setup.c */
-void __init __add_active_range(unsigned int nid, unsigned long start_pfn,
-			       unsigned long end_pfn);
-/* arch/sh/mm/init.c */
-void __init allocate_pgdat(unsigned int nid);
-
-#endif /* __ASM_SH_MMZONE_H */
diff --git a/arch/sh/include/asm/module.h b/arch/sh/include/asm/module.h
deleted file mode 100644
index 337663a028dbc0..00000000000000
--- a/arch/sh/include/asm/module.h
+++ /dev/null
@@ -1,14 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _ASM_SH_MODULE_H
-#define _ASM_SH_MODULE_H
-
-#include <asm-generic/module.h>
-
-#ifdef CONFIG_DWARF_UNWINDER
-struct mod_arch_specific {
-	struct list_head fde_list;
-	struct list_head cie_list;
-};
-#endif
-
-#endif /* _ASM_SH_MODULE_H */
diff --git a/arch/sh/include/asm/page.h b/arch/sh/include/asm/page.h
deleted file mode 100644
index eca5daa43b93df..00000000000000
--- a/arch/sh/include/asm/page.h
+++ /dev/null
@@ -1,186 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_PAGE_H
-#define __ASM_SH_PAGE_H
-
-/*
- * Copyright (C) 1999  Niibe Yutaka
- */
-
-#include <linux/const.h>
-
-/* PAGE_SHIFT determines the page size */
-#if defined(CONFIG_PAGE_SIZE_4KB)
-# define PAGE_SHIFT	12
-#elif defined(CONFIG_PAGE_SIZE_8KB)
-# define PAGE_SHIFT	13
-#elif defined(CONFIG_PAGE_SIZE_16KB)
-# define PAGE_SHIFT	14
-#elif defined(CONFIG_PAGE_SIZE_64KB)
-# define PAGE_SHIFT	16
-#else
-# error "Bogus kernel page size?"
-#endif
-
-#define PAGE_SIZE	(_AC(1, UL) << PAGE_SHIFT)
-#define PAGE_MASK	(~(PAGE_SIZE-1))
-#define PTE_MASK	PAGE_MASK
-
-#if defined(CONFIG_HUGETLB_PAGE_SIZE_64K)
-#define HPAGE_SHIFT	16
-#elif defined(CONFIG_HUGETLB_PAGE_SIZE_256K)
-#define HPAGE_SHIFT	18
-#elif defined(CONFIG_HUGETLB_PAGE_SIZE_1MB)
-#define HPAGE_SHIFT	20
-#elif defined(CONFIG_HUGETLB_PAGE_SIZE_4MB)
-#define HPAGE_SHIFT	22
-#elif defined(CONFIG_HUGETLB_PAGE_SIZE_64MB)
-#define HPAGE_SHIFT	26
-#endif
-
-#ifdef CONFIG_HUGETLB_PAGE
-#define HPAGE_SIZE		(1UL << HPAGE_SHIFT)
-#define HPAGE_MASK		(~(HPAGE_SIZE-1))
-#define HUGETLB_PAGE_ORDER	(HPAGE_SHIFT-PAGE_SHIFT)
-#endif
-
-#ifndef __ASSEMBLY__
-#include <asm/uncached.h>
-
-extern unsigned long shm_align_mask;
-extern unsigned long max_low_pfn, min_low_pfn;
-extern unsigned long memory_start, memory_end, memory_limit;
-
-static inline unsigned long
-pages_do_alias(unsigned long addr1, unsigned long addr2)
-{
-	return (addr1 ^ addr2) & shm_align_mask;
-}
-
-#define clear_page(page)	memset((void *)(page), 0, PAGE_SIZE)
-extern void copy_page(void *to, void *from);
-#define copy_user_page(to, from, vaddr, pg)  __copy_user(to, from, PAGE_SIZE)
-
-struct page;
-struct vm_area_struct;
-
-extern void copy_user_highpage(struct page *to, struct page *from,
-			       unsigned long vaddr, struct vm_area_struct *vma);
-#define __HAVE_ARCH_COPY_USER_HIGHPAGE
-extern void clear_user_highpage(struct page *page, unsigned long vaddr);
-#define clear_user_highpage	clear_user_highpage
-
-/*
- * These are used to make use of C type-checking..
- */
-#ifdef CONFIG_X2TLB
-typedef struct { unsigned long pte_low, pte_high; } pte_t;
-typedef struct { unsigned long long pgprot; } pgprot_t;
-typedef struct { unsigned long long pgd; } pgd_t;
-#define pte_val(x) \
-	((x).pte_low | ((unsigned long long)(x).pte_high << 32))
-#define __pte(x) \
-	({ pte_t __pte = {(x), ((unsigned long long)(x)) >> 32}; __pte; })
-#else
-typedef struct { unsigned long pte_low; } pte_t;
-typedef struct { unsigned long pgprot; } pgprot_t;
-typedef struct { unsigned long pgd; } pgd_t;
-#define pte_val(x)	((x).pte_low)
-#define __pte(x)	((pte_t) { (x) } )
-#endif
-
-#define pgd_val(x)	((x).pgd)
-#define pgprot_val(x)	((x).pgprot)
-
-#define __pgd(x) ((pgd_t) { (x) } )
-#define __pgprot(x)	((pgprot_t) { (x) } )
-
-typedef struct page *pgtable_t;
-
-#define pte_pgprot(x) __pgprot(pte_val(x) & PTE_FLAGS_MASK)
-
-#endif /* !__ASSEMBLY__ */
-
-/*
- * __MEMORY_START and SIZE are the physical addresses and size of RAM.
- */
-#define __MEMORY_START		CONFIG_MEMORY_START
-#define __MEMORY_SIZE		CONFIG_MEMORY_SIZE
-
-/*
- * PHYSICAL_OFFSET is the offset in physical memory where the base
- * of the kernel is loaded.
- */
-#ifdef CONFIG_PHYSICAL_START
-#define PHYSICAL_OFFSET (CONFIG_PHYSICAL_START - __MEMORY_START)
-#else
-#define PHYSICAL_OFFSET 0
-#endif
-
-/*
- * PAGE_OFFSET is the virtual address of the start of kernel address
- * space.
- */
-#define PAGE_OFFSET		CONFIG_PAGE_OFFSET
-
-/*
- * Virtual to physical RAM address translation.
- *
- * In 29 bit mode, the physical offset of RAM from address 0 is visible in
- * the kernel virtual address space, and thus we don't have to take
- * this into account when translating. However in 32 bit mode this offset
- * is not visible (it is part of the PMB mapping) and so needs to be
- * added or subtracted as required.
- */
-#ifdef CONFIG_PMB
-#define ___pa(x)	((x)-PAGE_OFFSET+__MEMORY_START)
-#define ___va(x)	((x)+PAGE_OFFSET-__MEMORY_START)
-#else
-#define ___pa(x)	((x)-PAGE_OFFSET)
-#define ___va(x)	((x)+PAGE_OFFSET)
-#endif
-
-#ifndef __ASSEMBLY__
-#define __pa(x)		___pa((unsigned long)x)
-#define __va(x)		(void *)___va((unsigned long)x)
-#endif /* !__ASSEMBLY__ */
-
-#ifdef CONFIG_UNCACHED_MAPPING
-#if defined(CONFIG_29BIT)
-#define UNCAC_ADDR(addr)	P2SEGADDR(addr)
-#define CAC_ADDR(addr)		P1SEGADDR(addr)
-#else
-#define UNCAC_ADDR(addr)	((addr) - PAGE_OFFSET + uncached_start)
-#define CAC_ADDR(addr)		((addr) - uncached_start + PAGE_OFFSET)
-#endif
-#else
-#define UNCAC_ADDR(addr)	((addr))
-#define CAC_ADDR(addr)		((addr))
-#endif
-
-#define pfn_to_kaddr(pfn)	__va((pfn) << PAGE_SHIFT)
-#define page_to_phys(page)	(page_to_pfn(page) << PAGE_SHIFT)
-
-/*
- * PFN = physical frame number (ie PFN 0 == physical address 0)
- * PFN_START is the PFN of the first page of RAM. By defining this we
- * don't have struct page entries for the portion of address space
- * between physical address 0 and the start of RAM.
- */
-#define PFN_START		(__MEMORY_START >> PAGE_SHIFT)
-#define ARCH_PFN_OFFSET		(PFN_START)
-#define virt_to_page(kaddr)	pfn_to_page(__pa(kaddr) >> PAGE_SHIFT)
-#ifdef CONFIG_FLATMEM
-#define pfn_valid(pfn)		((pfn) >= min_low_pfn && (pfn) < max_low_pfn)
-#endif
-#define virt_addr_valid(kaddr)	pfn_valid(__pa(kaddr) >> PAGE_SHIFT)
-
-#include <asm-generic/memory_model.h>
-#include <asm-generic/getorder.h>
-
-/*
- * Some drivers need to perform DMA into kmalloc'ed buffers
- * and so we have to increase the kmalloc minalign for this.
- */
-#define ARCH_DMA_MINALIGN	L1_CACHE_BYTES
-
-#endif /* __ASM_SH_PAGE_H */
diff --git a/arch/sh/include/asm/pci.h b/arch/sh/include/asm/pci.h
deleted file mode 100644
index 54c30126ea17c3..00000000000000
--- a/arch/sh/include/asm/pci.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_PCI_H
-#define __ASM_SH_PCI_H
-
-/* Can be used to override the logic in pci_scan_bus for skipping
-   already-configured bus numbers - to be used for buggy BIOSes
-   or architectures with incomplete PCI setup by the loader */
-
-#define pcibios_assign_all_busses()	1
-
-/*
- * A board can define one or more PCI channels that represent built-in (or
- * external) PCI controllers.
- */
-struct pci_channel {
-	struct pci_channel	*next;
-	struct pci_bus		*bus;
-
-	struct pci_ops		*pci_ops;
-
-	struct resource		*resources;
-	unsigned int		nr_resources;
-
-	unsigned long		io_offset;
-	unsigned long		mem_offset;
-
-	unsigned long		reg_base;
-	unsigned long		io_map_base;
-
-	unsigned int		index;
-	unsigned int		need_domain_info;
-
-	/* Optional error handling */
-	struct timer_list	err_timer, serr_timer;
-	unsigned int		err_irq, serr_irq;
-};
-
-/* arch/sh/drivers/pci/pci.c */
-extern raw_spinlock_t pci_config_lock;
-
-extern int register_pci_controller(struct pci_channel *hose);
-extern void pcibios_report_status(unsigned int status_mask, int warn);
-
-/* arch/sh/drivers/pci/common.c */
-extern int early_read_config_byte(struct pci_channel *hose, int top_bus,
-				  int bus, int devfn, int offset, u8 *value);
-extern int early_read_config_word(struct pci_channel *hose, int top_bus,
-				  int bus, int devfn, int offset, u16 *value);
-extern int early_read_config_dword(struct pci_channel *hose, int top_bus,
-				   int bus, int devfn, int offset, u32 *value);
-extern int early_write_config_byte(struct pci_channel *hose, int top_bus,
-				   int bus, int devfn, int offset, u8 value);
-extern int early_write_config_word(struct pci_channel *hose, int top_bus,
-				   int bus, int devfn, int offset, u16 value);
-extern int early_write_config_dword(struct pci_channel *hose, int top_bus,
-				    int bus, int devfn, int offset, u32 value);
-extern void pcibios_enable_timers(struct pci_channel *hose);
-extern unsigned int pcibios_handle_status_errors(unsigned long addr,
-				 unsigned int status, struct pci_channel *hose);
-extern int pci_is_66mhz_capable(struct pci_channel *hose,
-				int top_bus, int current_bus);
-
-extern unsigned long PCIBIOS_MIN_IO, PCIBIOS_MIN_MEM;
-
-#define HAVE_PCI_MMAP
-#define ARCH_GENERIC_PCI_MMAP_RESOURCE
-
-/* Dynamic DMA mapping stuff.
- * SuperH has everything mapped statically like x86.
- */
-
-#ifdef CONFIG_PCI
-/*
- * None of the SH PCI controllers support MWI, it is always treated as a
- * direct memory write.
- */
-#define PCI_DISABLE_MWI
-#endif
-
-/* Board-specific fixup routines. */
-int pcibios_map_platform_irq(const struct pci_dev *dev, u8 slot, u8 pin);
-
-#define pci_domain_nr(bus) ((struct pci_channel *)(bus)->sysdata)->index
-
-static inline int pci_proc_domain(struct pci_bus *bus)
-{
-	struct pci_channel *hose = bus->sysdata;
-	return hose->need_domain_info;
-}
-
-#endif /* __ASM_SH_PCI_H */
diff --git a/arch/sh/include/asm/perf_event.h b/arch/sh/include/asm/perf_event.h
deleted file mode 100644
index 468c7ca8bd2e50..00000000000000
--- a/arch/sh/include/asm/perf_event.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_PERF_EVENT_H
-#define __ASM_SH_PERF_EVENT_H
-
-struct hw_perf_event;
-
-#define MAX_HWEVENTS	2
-
-struct sh_pmu {
-	const char	*name;
-	unsigned int	num_events;
-	void		(*disable_all)(void);
-	void		(*enable_all)(void);
-	void		(*enable)(struct hw_perf_event *, int);
-	void		(*disable)(struct hw_perf_event *, int);
-	u64		(*read)(int);
-	int		(*event_map)(int);
-	unsigned int	max_events;
-	unsigned long	raw_event_mask;
-	const int	(*cache_events)[PERF_COUNT_HW_CACHE_MAX]
-				       [PERF_COUNT_HW_CACHE_OP_MAX]
-				       [PERF_COUNT_HW_CACHE_RESULT_MAX];
-};
-
-/* arch/sh/kernel/perf_event.c */
-extern int register_sh_pmu(struct sh_pmu *);
-extern int reserve_pmc_hardware(void);
-extern void release_pmc_hardware(void);
-
-#endif /* __ASM_SH_PERF_EVENT_H */
diff --git a/arch/sh/include/asm/pgalloc.h b/arch/sh/include/asm/pgalloc.h
deleted file mode 100644
index a9e98233c4d498..00000000000000
--- a/arch/sh/include/asm/pgalloc.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_PGALLOC_H
-#define __ASM_SH_PGALLOC_H
-
-#include <asm/page.h>
-
-#define __HAVE_ARCH_PMD_ALLOC_ONE
-#define __HAVE_ARCH_PMD_FREE
-#define __HAVE_ARCH_PGD_FREE
-#include <asm-generic/pgalloc.h>
-
-extern pgd_t *pgd_alloc(struct mm_struct *);
-extern void pgd_free(struct mm_struct *mm, pgd_t *pgd);
-
-#if PAGETABLE_LEVELS > 2
-extern void pud_populate(struct mm_struct *mm, pud_t *pudp, pmd_t *pmd);
-extern pmd_t *pmd_alloc_one(struct mm_struct *mm, unsigned long address);
-extern void pmd_free(struct mm_struct *mm, pmd_t *pmd);
-#define __pmd_free_tlb(tlb, pmdp, addr)		pmd_free((tlb)->mm, (pmdp))
-#endif
-
-static inline void pmd_populate_kernel(struct mm_struct *mm, pmd_t *pmd,
-				       pte_t *pte)
-{
-	set_pmd(pmd, __pmd((unsigned long)pte));
-}
-
-static inline void pmd_populate(struct mm_struct *mm, pmd_t *pmd,
-				pgtable_t pte)
-{
-	set_pmd(pmd, __pmd((unsigned long)page_address(pte)));
-}
-
-#define __pte_free_tlb(tlb,pte,addr)			\
-do {							\
-	pgtable_pte_page_dtor(pte);			\
-	tlb_remove_page((tlb), (pte));			\
-} while (0)
-
-#endif /* __ASM_SH_PGALLOC_H */
diff --git a/arch/sh/include/asm/pgtable-2level.h b/arch/sh/include/asm/pgtable-2level.h
deleted file mode 100644
index 08bff93927ffde..00000000000000
--- a/arch/sh/include/asm/pgtable-2level.h
+++ /dev/null
@@ -1,24 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_PGTABLE_2LEVEL_H
-#define __ASM_SH_PGTABLE_2LEVEL_H
-
-#include <asm-generic/pgtable-nopmd.h>
-
-/*
- * traditional two-level paging structure
- */
-#define PAGETABLE_LEVELS	2
-
-/* PTE bits */
-#define PTE_MAGNITUDE		2	/* 32-bit PTEs */
-
-#define PTE_SHIFT		PAGE_SHIFT
-#define PTE_BITS		(PTE_SHIFT - PTE_MAGNITUDE)
-
-/* PGD bits */
-#define PGDIR_SHIFT		(PTE_SHIFT + PTE_BITS)
-
-#define PTRS_PER_PGD		(PAGE_SIZE / (1 << PTE_MAGNITUDE))
-#define USER_PTRS_PER_PGD	(TASK_SIZE/PGDIR_SIZE)
-
-#endif /* __ASM_SH_PGTABLE_2LEVEL_H */
diff --git a/arch/sh/include/asm/pgtable-3level.h b/arch/sh/include/asm/pgtable-3level.h
deleted file mode 100644
index d1ce73f3bd85ef..00000000000000
--- a/arch/sh/include/asm/pgtable-3level.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_PGTABLE_3LEVEL_H
-#define __ASM_SH_PGTABLE_3LEVEL_H
-
-#include <asm-generic/pgtable-nopud.h>
-
-/*
- * Some cores need a 3-level page table layout, for example when using
- * 64-bit PTEs and 4K pages.
- */
-#define PAGETABLE_LEVELS	3
-
-#define PTE_MAGNITUDE		3	/* 64-bit PTEs on SH-X2 TLB */
-
-/* PGD bits */
-#define PGDIR_SHIFT		30
-
-#define PTRS_PER_PGD		4
-#define USER_PTRS_PER_PGD	2
-
-/* PMD bits */
-#define PMD_SHIFT	(PAGE_SHIFT + (PAGE_SHIFT - PTE_MAGNITUDE))
-#define PMD_SIZE	(1UL << PMD_SHIFT)
-#define PMD_MASK	(~(PMD_SIZE-1))
-
-#define PTRS_PER_PMD	((1 << PGDIR_SHIFT) / PMD_SIZE)
-
-#define pmd_ERROR(e) \
-	printk("%s:%d: bad pmd %016llx.\n", __FILE__, __LINE__, pmd_val(e))
-
-typedef union {
-	struct {
-		unsigned long pmd_low;
-		unsigned long pmd_high;
-	};
-	unsigned long long pmd;
-} pmd_t;
-#define pmd_val(x)	((x).pmd)
-#define __pmd(x)	((pmd_t) { .pmd = (x) } )
-
-static inline pmd_t *pud_pgtable(pud_t pud)
-{
-	return (pmd_t *)(unsigned long)pud_val(pud);
-}
-
-/* only used by the stubbed out hugetlb gup code, should never be called */
-#define pud_page(pud)		NULL
-#define pud_none(x)	(!pud_val(x))
-#define pud_present(x)	(pud_val(x))
-#define pud_clear(xp)	do { set_pud(xp, __pud(0)); } while (0)
-#define	pud_bad(x)	(pud_val(x) & ~PAGE_MASK)
-
-/*
- * (puds are folded into pgds so this doesn't get actually called,
- * but the define is needed for a generic inline function.)
- */
-#define set_pud(pudptr, pudval) do { *(pudptr) = (pudval); } while(0)
-
-#endif /* __ASM_SH_PGTABLE_3LEVEL_H */
diff --git a/arch/sh/include/asm/pgtable.h b/arch/sh/include/asm/pgtable.h
deleted file mode 100644
index 3ce30becf6dfa9..00000000000000
--- a/arch/sh/include/asm/pgtable.h
+++ /dev/null
@@ -1,150 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * This file contains the functions and defines necessary to modify and
- * use the SuperH page table tree.
- *
- * Copyright (C) 1999 Niibe Yutaka
- * Copyright (C) 2002 - 2007 Paul Mundt
- */
-#ifndef __ASM_SH_PGTABLE_H
-#define __ASM_SH_PGTABLE_H
-
-#ifdef CONFIG_X2TLB
-#include <asm/pgtable-3level.h>
-#else
-#include <asm/pgtable-2level.h>
-#endif
-#include <asm/page.h>
-#include <asm/mmu.h>
-
-#ifndef __ASSEMBLY__
-#include <asm/addrspace.h>
-#include <asm/fixmap.h>
-
-/*
- * ZERO_PAGE is a global shared page that is always zero: used
- * for zero-mapped memory areas etc..
- */
-extern unsigned long empty_zero_page[PAGE_SIZE / sizeof(unsigned long)];
-#define ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page))
-
-#endif /* !__ASSEMBLY__ */
-
-/*
- * Effective and physical address definitions, to aid with sign
- * extension.
- */
-#define NEFF		32
-#define	NEFF_SIGN	(1LL << (NEFF - 1))
-#define	NEFF_MASK	(-1LL << NEFF)
-
-static inline unsigned long long neff_sign_extend(unsigned long val)
-{
-	unsigned long long extended = val;
-	return (extended & NEFF_SIGN) ? (extended | NEFF_MASK) : extended;
-}
-
-#ifdef CONFIG_29BIT
-#define NPHYS		29
-#else
-#define NPHYS		32
-#endif
-
-#define	NPHYS_SIGN	(1LL << (NPHYS - 1))
-#define	NPHYS_MASK	(-1LL << NPHYS)
-
-#define PGDIR_SIZE	(1UL << PGDIR_SHIFT)
-#define PGDIR_MASK	(~(PGDIR_SIZE-1))
-
-/* Entries per level */
-#define PTRS_PER_PTE	(PAGE_SIZE / (1 << PTE_MAGNITUDE))
-
-#define PHYS_ADDR_MASK29		0x1fffffff
-#define PHYS_ADDR_MASK32		0xffffffff
-
-static inline unsigned long phys_addr_mask(void)
-{
-	/* Is the MMU in 29bit mode? */
-	if (__in_29bit_mode())
-		return PHYS_ADDR_MASK29;
-
-	return PHYS_ADDR_MASK32;
-}
-
-#define PTE_PHYS_MASK		(phys_addr_mask() & PAGE_MASK)
-#define PTE_FLAGS_MASK		(~(PTE_PHYS_MASK) << PAGE_SHIFT)
-
-#define VMALLOC_START	(P3SEG)
-#define VMALLOC_END	(FIXADDR_START-2*PAGE_SIZE)
-
-#include <asm/pgtable_32.h>
-
-/*
- * SH-X and lower (legacy) SuperH parts (SH-3, SH-4, some SH-4A) can't do page
- * protection for execute, and considers it the same as a read. Also, write
- * permission implies read permission. This is the closest we can get..
- *
- * SH-X2 (SH7785) and later parts take this to the opposite end of the extreme,
- * not only supporting separate execute, read, and write bits, but having
- * completely separate permission bits for user and kernel space.
- */
-	 /*xwr*/
-
-typedef pte_t *pte_addr_t;
-
-#define pte_pfn(x)		((unsigned long)(((x).pte_low >> PAGE_SHIFT)))
-
-struct vm_area_struct;
-struct mm_struct;
-
-extern void __update_cache(struct vm_area_struct *vma,
-			   unsigned long address, pte_t pte);
-extern void __update_tlb(struct vm_area_struct *vma,
-			 unsigned long address, pte_t pte);
-
-static inline void
-update_mmu_cache(struct vm_area_struct *vma, unsigned long address, pte_t *ptep)
-{
-	pte_t pte = *ptep;
-	__update_cache(vma, address, pte);
-	__update_tlb(vma, address, pte);
-}
-
-extern pgd_t swapper_pg_dir[PTRS_PER_PGD];
-extern void paging_init(void);
-extern void page_table_range_init(unsigned long start, unsigned long end,
-				  pgd_t *pgd);
-
-static inline bool __pte_access_permitted(pte_t pte, u64 prot)
-{
-	return (pte_val(pte) & (prot | _PAGE_SPECIAL)) == prot;
-}
-
-#ifdef CONFIG_X2TLB
-static inline bool pte_access_permitted(pte_t pte, bool write)
-{
-	u64 prot = _PAGE_PRESENT;
-
-	prot |= _PAGE_EXT(_PAGE_EXT_KERN_READ | _PAGE_EXT_USER_READ);
-	if (write)
-		prot |= _PAGE_EXT(_PAGE_EXT_KERN_WRITE | _PAGE_EXT_USER_WRITE);
-	return __pte_access_permitted(pte, prot);
-}
-#else
-static inline bool pte_access_permitted(pte_t pte, bool write)
-{
-	u64 prot = _PAGE_PRESENT | _PAGE_USER;
-
-	if (write)
-		prot |= _PAGE_RW;
-	return __pte_access_permitted(pte, prot);
-}
-#endif
-
-#define pte_access_permitted pte_access_permitted
-
-/* arch/sh/mm/mmap.c */
-#define HAVE_ARCH_UNMAPPED_AREA
-#define HAVE_ARCH_UNMAPPED_AREA_TOPDOWN
-
-#endif /* __ASM_SH_PGTABLE_H */
diff --git a/arch/sh/include/asm/pgtable_32.h b/arch/sh/include/asm/pgtable_32.h
deleted file mode 100644
index d0240decacca7f..00000000000000
--- a/arch/sh/include/asm/pgtable_32.h
+++ /dev/null
@@ -1,462 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_PGTABLE_32_H
-#define __ASM_SH_PGTABLE_32_H
-
-/*
- * Linux PTEL encoding.
- *
- * Hardware and software bit definitions for the PTEL value (see below for
- * notes on SH-X2 MMUs and 64-bit PTEs):
- *
- * - Bits 0 and 7 are reserved on SH-3 (_PAGE_WT and _PAGE_SZ1 on SH-4).
- *
- * - Bit 1 is the SH-bit, but is unused on SH-3 due to an MMU bug (the
- *   hardware PTEL value can't have the SH-bit set when MMUCR.IX is set,
- *   which is the default in cpu-sh3/mmu_context.h:MMU_CONTROL_INIT).
- *
- *   In order to keep this relatively clean, do not use these for defining
- *   SH-3 specific flags until all of the other unused bits have been
- *   exhausted.
- *
- * - Bit 9 is reserved by everyone and used by _PAGE_PROTNONE.
- *
- * - Bits 10 and 11 are low bits of the PPN that are reserved on >= 4K pages.
- *   Bit 10 is used for _PAGE_ACCESSED, and bit 11 is used for _PAGE_SPECIAL.
- *
- * - On 29 bit platforms, bits 31 to 29 are used for the space attributes
- *   and timing control which (together with bit 0) are moved into the
- *   old-style PTEA on the parts that support it.
- *
- * SH-X2 MMUs and extended PTEs
- *
- * SH-X2 supports an extended mode TLB with split data arrays due to the
- * number of bits needed for PR and SZ (now EPR and ESZ) encodings. The PR and
- * SZ bit placeholders still exist in data array 1, but are implemented as
- * reserved bits, with the real logic existing in data array 2.
- *
- * The downside to this is that we can no longer fit everything in to a 32-bit
- * PTE encoding, so a 64-bit pte_t is necessary for these parts. On the plus
- * side, this gives us quite a few spare bits to play with for future usage.
- */
-/* Legacy and compat mode bits */
-#define	_PAGE_WT	0x001		/* WT-bit on SH-4, 0 on SH-3 */
-#define _PAGE_HW_SHARED	0x002		/* SH-bit  : shared among processes */
-#define _PAGE_DIRTY	0x004		/* D-bit   : page changed */
-#define _PAGE_CACHABLE	0x008		/* C-bit   : cachable */
-#define _PAGE_SZ0	0x010		/* SZ0-bit : Size of page */
-#define _PAGE_RW	0x020		/* PR0-bit : write access allowed */
-#define _PAGE_USER	0x040		/* PR1-bit : user space access allowed*/
-#define _PAGE_SZ1	0x080		/* SZ1-bit : Size of page (on SH-4) */
-#define _PAGE_PRESENT	0x100		/* V-bit   : page is valid */
-#define _PAGE_PROTNONE	0x200		/* software: if not present  */
-#define _PAGE_ACCESSED	0x400		/* software: page referenced */
-#define _PAGE_SPECIAL	0x800		/* software: special page */
-
-#define _PAGE_SZ_MASK	(_PAGE_SZ0 | _PAGE_SZ1)
-#define _PAGE_PR_MASK	(_PAGE_RW | _PAGE_USER)
-
-/* Extended mode bits */
-#define _PAGE_EXT_ESZ0		0x0010	/* ESZ0-bit: Size of page */
-#define _PAGE_EXT_ESZ1		0x0020	/* ESZ1-bit: Size of page */
-#define _PAGE_EXT_ESZ2		0x0040	/* ESZ2-bit: Size of page */
-#define _PAGE_EXT_ESZ3		0x0080	/* ESZ3-bit: Size of page */
-
-#define _PAGE_EXT_USER_EXEC	0x0100	/* EPR0-bit: User space executable */
-#define _PAGE_EXT_USER_WRITE	0x0200	/* EPR1-bit: User space writable */
-#define _PAGE_EXT_USER_READ	0x0400	/* EPR2-bit: User space readable */
-
-#define _PAGE_EXT_KERN_EXEC	0x0800	/* EPR3-bit: Kernel space executable */
-#define _PAGE_EXT_KERN_WRITE	0x1000	/* EPR4-bit: Kernel space writable */
-#define _PAGE_EXT_KERN_READ	0x2000	/* EPR5-bit: Kernel space readable */
-
-#define _PAGE_EXT_WIRED		0x4000	/* software: Wire TLB entry */
-
-/* Wrapper for extended mode pgprot twiddling */
-#define _PAGE_EXT(x)		((unsigned long long)(x) << 32)
-
-#ifdef CONFIG_X2TLB
-#define _PAGE_PCC_MASK	0x00000000	/* No legacy PTEA support */
-#else
-
-/* software: moves to PTEA.TC (Timing Control) */
-#define _PAGE_PCC_AREA5	0x00000000	/* use BSC registers for area5 */
-#define _PAGE_PCC_AREA6	0x80000000	/* use BSC registers for area6 */
-
-/* software: moves to PTEA.SA[2:0] (Space Attributes) */
-#define _PAGE_PCC_IODYN 0x00000001	/* IO space, dynamically sized bus */
-#define _PAGE_PCC_IO8	0x20000000	/* IO space, 8 bit bus */
-#define _PAGE_PCC_IO16	0x20000001	/* IO space, 16 bit bus */
-#define _PAGE_PCC_COM8	0x40000000	/* Common Memory space, 8 bit bus */
-#define _PAGE_PCC_COM16	0x40000001	/* Common Memory space, 16 bit bus */
-#define _PAGE_PCC_ATR8	0x60000000	/* Attribute Memory space, 8 bit bus */
-#define _PAGE_PCC_ATR16	0x60000001	/* Attribute Memory space, 6 bit bus */
-
-#define _PAGE_PCC_MASK	0xe0000001
-
-/* copy the ptea attributes */
-static inline unsigned long copy_ptea_attributes(unsigned long x)
-{
-	return	((x >> 28) & 0xe) | (x & 0x1);
-}
-#endif
-
-/* Mask which drops unused bits from the PTEL value */
-#if defined(CONFIG_CPU_SH3)
-#define _PAGE_CLEAR_FLAGS	(_PAGE_PROTNONE | _PAGE_ACCESSED| \
-				  _PAGE_SZ1	| _PAGE_HW_SHARED)
-#elif defined(CONFIG_X2TLB)
-/* Get rid of the legacy PR/SZ bits when using extended mode */
-#define _PAGE_CLEAR_FLAGS	(_PAGE_PROTNONE | _PAGE_ACCESSED | \
-				 _PAGE_PR_MASK | _PAGE_SZ_MASK)
-#else
-#define _PAGE_CLEAR_FLAGS	(_PAGE_PROTNONE | _PAGE_ACCESSED)
-#endif
-
-#define _PAGE_FLAGS_HARDWARE_MASK	(phys_addr_mask() & ~(_PAGE_CLEAR_FLAGS))
-
-/* Hardware flags, page size encoding */
-#if !defined(CONFIG_MMU)
-# define _PAGE_FLAGS_HARD	0ULL
-#elif defined(CONFIG_X2TLB)
-# if defined(CONFIG_PAGE_SIZE_4KB)
-#  define _PAGE_FLAGS_HARD	_PAGE_EXT(_PAGE_EXT_ESZ0)
-# elif defined(CONFIG_PAGE_SIZE_8KB)
-#  define _PAGE_FLAGS_HARD	_PAGE_EXT(_PAGE_EXT_ESZ1)
-# elif defined(CONFIG_PAGE_SIZE_64KB)
-#  define _PAGE_FLAGS_HARD	_PAGE_EXT(_PAGE_EXT_ESZ2)
-# endif
-#else
-# if defined(CONFIG_PAGE_SIZE_4KB)
-#  define _PAGE_FLAGS_HARD	_PAGE_SZ0
-# elif defined(CONFIG_PAGE_SIZE_64KB)
-#  define _PAGE_FLAGS_HARD	_PAGE_SZ1
-# endif
-#endif
-
-#if defined(CONFIG_X2TLB)
-# if defined(CONFIG_HUGETLB_PAGE_SIZE_64K)
-#  define _PAGE_SZHUGE	(_PAGE_EXT_ESZ2)
-# elif defined(CONFIG_HUGETLB_PAGE_SIZE_256K)
-#  define _PAGE_SZHUGE	(_PAGE_EXT_ESZ0 | _PAGE_EXT_ESZ2)
-# elif defined(CONFIG_HUGETLB_PAGE_SIZE_1MB)
-#  define _PAGE_SZHUGE	(_PAGE_EXT_ESZ0 | _PAGE_EXT_ESZ1 | _PAGE_EXT_ESZ2)
-# elif defined(CONFIG_HUGETLB_PAGE_SIZE_4MB)
-#  define _PAGE_SZHUGE	(_PAGE_EXT_ESZ3)
-# elif defined(CONFIG_HUGETLB_PAGE_SIZE_64MB)
-#  define _PAGE_SZHUGE	(_PAGE_EXT_ESZ2 | _PAGE_EXT_ESZ3)
-# endif
-# define _PAGE_WIRED	(_PAGE_EXT(_PAGE_EXT_WIRED))
-#else
-# if defined(CONFIG_HUGETLB_PAGE_SIZE_64K)
-#  define _PAGE_SZHUGE	(_PAGE_SZ1)
-# elif defined(CONFIG_HUGETLB_PAGE_SIZE_1MB)
-#  define _PAGE_SZHUGE	(_PAGE_SZ0 | _PAGE_SZ1)
-# endif
-# define _PAGE_WIRED	(0)
-#endif
-
-/*
- * Stub out _PAGE_SZHUGE if we don't have a good definition for it,
- * to make pte_mkhuge() happy.
- */
-#ifndef _PAGE_SZHUGE
-# define _PAGE_SZHUGE	(_PAGE_FLAGS_HARD)
-#endif
-
-/*
- * Mask of bits that are to be preserved across pgprot changes.
- */
-#define _PAGE_CHG_MASK \
-	(PTE_MASK | _PAGE_ACCESSED | _PAGE_CACHABLE | \
-	 _PAGE_DIRTY | _PAGE_SPECIAL)
-
-#ifndef __ASSEMBLY__
-
-#if defined(CONFIG_X2TLB) /* SH-X2 TLB */
-#define PAGE_NONE	__pgprot(_PAGE_PROTNONE | _PAGE_CACHABLE | \
-				 _PAGE_ACCESSED | _PAGE_FLAGS_HARD)
-
-#define PAGE_SHARED	__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED | \
-				 _PAGE_CACHABLE | _PAGE_FLAGS_HARD | \
-				 _PAGE_EXT(_PAGE_EXT_KERN_READ  | \
-					   _PAGE_EXT_KERN_WRITE | \
-					   _PAGE_EXT_USER_READ  | \
-					   _PAGE_EXT_USER_WRITE))
-
-#define PAGE_EXECREAD	__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED | \
-				 _PAGE_CACHABLE | _PAGE_FLAGS_HARD | \
-				 _PAGE_EXT(_PAGE_EXT_KERN_EXEC | \
-					   _PAGE_EXT_KERN_READ | \
-					   _PAGE_EXT_USER_EXEC | \
-					   _PAGE_EXT_USER_READ))
-
-#define PAGE_COPY	PAGE_EXECREAD
-
-#define PAGE_READONLY	__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED | \
-				 _PAGE_CACHABLE | _PAGE_FLAGS_HARD | \
-				 _PAGE_EXT(_PAGE_EXT_KERN_READ | \
-					   _PAGE_EXT_USER_READ))
-
-#define PAGE_WRITEONLY	__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED | \
-				 _PAGE_CACHABLE | _PAGE_FLAGS_HARD | \
-				 _PAGE_EXT(_PAGE_EXT_KERN_WRITE | \
-					   _PAGE_EXT_USER_WRITE))
-
-#define PAGE_RWX	__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED | \
-				 _PAGE_CACHABLE | _PAGE_FLAGS_HARD | \
-				 _PAGE_EXT(_PAGE_EXT_KERN_WRITE | \
-					   _PAGE_EXT_KERN_READ  | \
-					   _PAGE_EXT_KERN_EXEC  | \
-					   _PAGE_EXT_USER_WRITE | \
-					   _PAGE_EXT_USER_READ  | \
-					   _PAGE_EXT_USER_EXEC))
-
-#define PAGE_KERNEL	__pgprot(_PAGE_PRESENT | _PAGE_CACHABLE | \
-				 _PAGE_DIRTY | _PAGE_ACCESSED | \
-				 _PAGE_HW_SHARED | _PAGE_FLAGS_HARD | \
-				 _PAGE_EXT(_PAGE_EXT_KERN_READ | \
-					   _PAGE_EXT_KERN_WRITE | \
-					   _PAGE_EXT_KERN_EXEC))
-
-#define PAGE_KERNEL_NOCACHE \
-			__pgprot(_PAGE_PRESENT | _PAGE_DIRTY | \
-				 _PAGE_ACCESSED | _PAGE_HW_SHARED | \
-				 _PAGE_FLAGS_HARD | \
-				 _PAGE_EXT(_PAGE_EXT_KERN_READ | \
-					   _PAGE_EXT_KERN_WRITE | \
-					   _PAGE_EXT_KERN_EXEC))
-
-#define PAGE_KERNEL_RO	__pgprot(_PAGE_PRESENT | _PAGE_CACHABLE | \
-				 _PAGE_DIRTY | _PAGE_ACCESSED | \
-				 _PAGE_HW_SHARED | _PAGE_FLAGS_HARD | \
-				 _PAGE_EXT(_PAGE_EXT_KERN_READ | \
-					   _PAGE_EXT_KERN_EXEC))
-
-#define PAGE_KERNEL_PCC(slot, type) \
-			__pgprot(0)
-
-#elif defined(CONFIG_MMU) /* SH-X TLB */
-#define PAGE_NONE	__pgprot(_PAGE_PROTNONE | _PAGE_CACHABLE | \
-				 _PAGE_ACCESSED | _PAGE_FLAGS_HARD)
-
-#define PAGE_SHARED	__pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_USER | \
-				 _PAGE_CACHABLE | _PAGE_ACCESSED | \
-				 _PAGE_FLAGS_HARD)
-
-#define PAGE_COPY	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_CACHABLE | \
-				 _PAGE_ACCESSED | _PAGE_FLAGS_HARD)
-
-#define PAGE_READONLY	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_CACHABLE | \
-				 _PAGE_ACCESSED | _PAGE_FLAGS_HARD)
-
-#define PAGE_EXECREAD	PAGE_READONLY
-#define PAGE_RWX	PAGE_SHARED
-#define PAGE_WRITEONLY	PAGE_SHARED
-
-#define PAGE_KERNEL	__pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_CACHABLE | \
-				 _PAGE_DIRTY | _PAGE_ACCESSED | \
-				 _PAGE_HW_SHARED | _PAGE_FLAGS_HARD)
-
-#define PAGE_KERNEL_NOCACHE \
-			__pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_DIRTY | \
-				 _PAGE_ACCESSED | _PAGE_HW_SHARED | \
-				 _PAGE_FLAGS_HARD)
-
-#define PAGE_KERNEL_RO	__pgprot(_PAGE_PRESENT | _PAGE_CACHABLE | \
-				 _PAGE_DIRTY | _PAGE_ACCESSED | \
-				 _PAGE_HW_SHARED | _PAGE_FLAGS_HARD)
-
-#define PAGE_KERNEL_PCC(slot, type) \
-			__pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_DIRTY | \
-				 _PAGE_ACCESSED | _PAGE_FLAGS_HARD | \
-				 (slot ? _PAGE_PCC_AREA5 : _PAGE_PCC_AREA6) | \
-				 (type))
-#else /* no mmu */
-#define PAGE_NONE		__pgprot(0)
-#define PAGE_SHARED		__pgprot(0)
-#define PAGE_COPY		__pgprot(0)
-#define PAGE_EXECREAD		__pgprot(0)
-#define PAGE_RWX		__pgprot(0)
-#define PAGE_READONLY		__pgprot(0)
-#define PAGE_WRITEONLY		__pgprot(0)
-#define PAGE_KERNEL		__pgprot(0)
-#define PAGE_KERNEL_NOCACHE	__pgprot(0)
-#define PAGE_KERNEL_RO		__pgprot(0)
-
-#define PAGE_KERNEL_PCC(slot, type) \
-				__pgprot(0)
-#endif
-
-#endif /* __ASSEMBLY__ */
-
-#ifndef __ASSEMBLY__
-
-/*
- * Certain architectures need to do special things when PTEs
- * within a page table are directly modified.  Thus, the following
- * hook is made available.
- */
-#ifdef CONFIG_X2TLB
-static inline void set_pte(pte_t *ptep, pte_t pte)
-{
-	ptep->pte_high = pte.pte_high;
-	smp_wmb();
-	ptep->pte_low = pte.pte_low;
-}
-#else
-#define set_pte(pteptr, pteval) (*(pteptr) = pteval)
-#endif
-
-#define set_pte_at(mm,addr,ptep,pteval) set_pte(ptep,pteval)
-
-/*
- * (pmds are folded into pgds so this doesn't get actually called,
- * but the define is needed for a generic inline function.)
- */
-#define set_pmd(pmdptr, pmdval) (*(pmdptr) = pmdval)
-
-#define pfn_pte(pfn, prot) \
-	__pte(((unsigned long long)(pfn) << PAGE_SHIFT) | pgprot_val(prot))
-#define pfn_pmd(pfn, prot) \
-	__pmd(((unsigned long long)(pfn) << PAGE_SHIFT) | pgprot_val(prot))
-
-#define pte_none(x)		(!pte_val(x))
-#define pte_present(x)		((x).pte_low & (_PAGE_PRESENT | _PAGE_PROTNONE))
-
-#define pte_clear(mm,addr,xp) do { set_pte_at(mm, addr, xp, __pte(0)); } while (0)
-
-#define pmd_none(x)	(!pmd_val(x))
-#define pmd_present(x)	(pmd_val(x))
-#define pmd_clear(xp)	do { set_pmd(xp, __pmd(0)); } while (0)
-#define	pmd_bad(x)	(pmd_val(x) & ~PAGE_MASK)
-
-#define pages_to_mb(x)	((x) >> (20-PAGE_SHIFT))
-#define pte_page(x)	pfn_to_page(pte_pfn(x))
-
-/*
- * The following only work if pte_present() is true.
- * Undefined behaviour if not..
- */
-#define pte_not_present(pte)	(!((pte).pte_low & _PAGE_PRESENT))
-#define pte_dirty(pte)		((pte).pte_low & _PAGE_DIRTY)
-#define pte_young(pte)		((pte).pte_low & _PAGE_ACCESSED)
-#define pte_special(pte)	((pte).pte_low & _PAGE_SPECIAL)
-
-#ifdef CONFIG_X2TLB
-#define pte_write(pte) \
-	((pte).pte_high & (_PAGE_EXT_USER_WRITE | _PAGE_EXT_KERN_WRITE))
-#else
-#define pte_write(pte)		((pte).pte_low & _PAGE_RW)
-#endif
-
-#define PTE_BIT_FUNC(h,fn,op) \
-static inline pte_t pte_##fn(pte_t pte) { pte.pte_##h op; return pte; }
-
-#ifdef CONFIG_X2TLB
-/*
- * We cheat a bit in the SH-X2 TLB case. As the permission bits are
- * individually toggled (and user permissions are entirely decoupled from
- * kernel permissions), we attempt to couple them a bit more sanely here.
- */
-PTE_BIT_FUNC(high, wrprotect, &= ~(_PAGE_EXT_USER_WRITE | _PAGE_EXT_KERN_WRITE));
-PTE_BIT_FUNC(high, mkwrite, |= _PAGE_EXT_USER_WRITE | _PAGE_EXT_KERN_WRITE);
-PTE_BIT_FUNC(high, mkhuge, |= _PAGE_SZHUGE);
-#else
-PTE_BIT_FUNC(low, wrprotect, &= ~_PAGE_RW);
-PTE_BIT_FUNC(low, mkwrite, |= _PAGE_RW);
-PTE_BIT_FUNC(low, mkhuge, |= _PAGE_SZHUGE);
-#endif
-
-PTE_BIT_FUNC(low, mkclean, &= ~_PAGE_DIRTY);
-PTE_BIT_FUNC(low, mkdirty, |= _PAGE_DIRTY);
-PTE_BIT_FUNC(low, mkold, &= ~_PAGE_ACCESSED);
-PTE_BIT_FUNC(low, mkyoung, |= _PAGE_ACCESSED);
-PTE_BIT_FUNC(low, mkspecial, |= _PAGE_SPECIAL);
-
-/*
- * Macro and implementation to make a page protection as uncachable.
- */
-#define pgprot_writecombine(prot) \
-	__pgprot(pgprot_val(prot) & ~_PAGE_CACHABLE)
-
-#define pgprot_noncached	 pgprot_writecombine
-
-/*
- * Conversion functions: convert a page and protection to a page entry,
- * and a page entry and page directory to the page they refer to.
- *
- * extern pte_t mk_pte(struct page *page, pgprot_t pgprot)
- */
-#define mk_pte(page, pgprot)	pfn_pte(page_to_pfn(page), (pgprot))
-
-static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
-{
-	pte.pte_low &= _PAGE_CHG_MASK;
-	pte.pte_low |= pgprot_val(newprot);
-
-#ifdef CONFIG_X2TLB
-	pte.pte_high |= pgprot_val(newprot) >> 32;
-#endif
-
-	return pte;
-}
-
-static inline unsigned long pmd_page_vaddr(pmd_t pmd)
-{
-	return (unsigned long)pmd_val(pmd);
-}
-
-#define pmd_pfn(pmd)		(__pa(pmd_val(pmd)) >> PAGE_SHIFT)
-#define pmd_page(pmd)		(virt_to_page(pmd_val(pmd)))
-
-#ifdef CONFIG_X2TLB
-#define pte_ERROR(e) \
-	printk("%s:%d: bad pte %p(%08lx%08lx).\n", __FILE__, __LINE__, \
-	       &(e), (e).pte_high, (e).pte_low)
-#define pgd_ERROR(e) \
-	printk("%s:%d: bad pgd %016llx.\n", __FILE__, __LINE__, pgd_val(e))
-#else
-#define pte_ERROR(e) \
-	printk("%s:%d: bad pte %08lx.\n", __FILE__, __LINE__, pte_val(e))
-#define pgd_ERROR(e) \
-	printk("%s:%d: bad pgd %08lx.\n", __FILE__, __LINE__, pgd_val(e))
-#endif
-
-/*
- * Encode and de-code a swap entry
- *
- * Constraints:
- *	_PAGE_PRESENT at bit 8
- *	_PAGE_PROTNONE at bit 9
- *
- * For the normal case, we encode the swap type into bits 0:7 and the
- * swap offset into bits 10:30. For the 64-bit PTE case, we keep the
- * preserved bits in the low 32-bits and use the upper 32 as the swap
- * offset (along with a 5-bit type), following the same approach as x86
- * PAE. This keeps the logic quite simple.
- *
- * As is evident by the Alpha code, if we ever get a 64-bit unsigned
- * long (swp_entry_t) to match up with the 64-bit PTEs, this all becomes
- * much cleaner..
- *
- * NOTE: We should set ZEROs at the position of _PAGE_PRESENT
- *       and _PAGE_PROTNONE bits
- */
-#ifdef CONFIG_X2TLB
-#define __swp_type(x)			((x).val & 0x1f)
-#define __swp_offset(x)			((x).val >> 5)
-#define __swp_entry(type, offset)	((swp_entry_t){ (type) | (offset) << 5})
-#define __pte_to_swp_entry(pte)		((swp_entry_t){ (pte).pte_high })
-#define __swp_entry_to_pte(x)		((pte_t){ 0, (x).val })
-
-#else
-#define __swp_type(x)			((x).val & 0xff)
-#define __swp_offset(x)			((x).val >> 10)
-#define __swp_entry(type, offset)	((swp_entry_t){(type) | (offset) <<10})
-
-#define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) >> 1 })
-#define __swp_entry_to_pte(x)		((pte_t) { (x).val << 1 })
-#endif
-
-#endif /* __ASSEMBLY__ */
-#endif /* __ASM_SH_PGTABLE_32_H */
diff --git a/arch/sh/include/asm/platform_early.h b/arch/sh/include/asm/platform_early.h
deleted file mode 100644
index fc802137c37d43..00000000000000
--- a/arch/sh/include/asm/platform_early.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/* SPDX--License-Identifier: GPL-2.0 */
-
-#ifndef __PLATFORM_EARLY__
-#define __PLATFORM_EARLY__
-
-#include <linux/types.h>
-#include <linux/platform_device.h>
-#include <linux/pm_runtime.h>
-#include <linux/slab.h>
-
-struct sh_early_platform_driver {
-	const char *class_str;
-	struct platform_driver *pdrv;
-	struct list_head list;
-	int requested_id;
-	char *buffer;
-	int bufsize;
-};
-
-#define EARLY_PLATFORM_ID_UNSET -2
-#define EARLY_PLATFORM_ID_ERROR -3
-
-extern int sh_early_platform_driver_register(struct sh_early_platform_driver *epdrv,
-					  char *buf);
-extern void sh_early_platform_add_devices(struct platform_device **devs, int num);
-
-static inline int is_sh_early_platform_device(struct platform_device *pdev)
-{
-	return !pdev->dev.driver;
-}
-
-extern void sh_early_platform_driver_register_all(char *class_str);
-extern int sh_early_platform_driver_probe(char *class_str,
-				       int nr_probe, int user_only);
-
-#define sh_early_platform_init(class_string, platdrv)		\
-	sh_early_platform_init_buffer(class_string, platdrv, NULL, 0)
-
-#ifndef MODULE
-#define sh_early_platform_init_buffer(class_string, platdrv, buf, bufsiz)	\
-static __initdata struct sh_early_platform_driver early_driver = {		\
-	.class_str = class_string,					\
-	.buffer = buf,							\
-	.bufsize = bufsiz,						\
-	.pdrv = platdrv,						\
-	.requested_id = EARLY_PLATFORM_ID_UNSET,			\
-};									\
-static int __init sh_early_platform_driver_setup_func(char *buffer)	\
-{									\
-	return sh_early_platform_driver_register(&early_driver, buffer);	\
-}									\
-early_param(class_string, sh_early_platform_driver_setup_func)
-#else /* MODULE */
-#define sh_early_platform_init_buffer(class_string, platdrv, buf, bufsiz)	\
-static inline char *sh_early_platform_driver_setup_func(void)		\
-{									\
-	return bufsiz ? buf : NULL;					\
-}
-#endif /* MODULE */
-
-#endif /* __PLATFORM_EARLY__ */
diff --git a/arch/sh/include/asm/posix_types.h b/arch/sh/include/asm/posix_types.h
deleted file mode 100644
index f8982b757c33ac..00000000000000
--- a/arch/sh/include/asm/posix_types.h
+++ /dev/null
@@ -1,2 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <asm/posix_types_32.h>
diff --git a/arch/sh/include/asm/processor.h b/arch/sh/include/asm/processor.h
deleted file mode 100644
index 85a6c1c3c16e70..00000000000000
--- a/arch/sh/include/asm/processor.h
+++ /dev/null
@@ -1,173 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_PROCESSOR_H
-#define __ASM_SH_PROCESSOR_H
-
-#include <asm/cpu-features.h>
-#include <asm/cache.h>
-
-#ifndef __ASSEMBLY__
-/*
- *  CPU type and hardware bug flags. Kept separately for each CPU.
- *
- *  Each one of these also needs a CONFIG_CPU_SUBTYPE_xxx entry
- *  in arch/sh/mm/Kconfig, as well as an entry in arch/sh/kernel/setup.c
- *  for parsing the subtype in get_cpu_subtype().
- */
-enum cpu_type {
-	/* SH-2 types */
-	CPU_SH7619, CPU_J2,
-
-	/* SH-2A types */
-	CPU_SH7201, CPU_SH7203, CPU_SH7206, CPU_SH7263, CPU_SH7264, CPU_SH7269,
-	CPU_MXG,
-
-	/* SH-3 types */
-	CPU_SH7705, CPU_SH7706, CPU_SH7707,
-	CPU_SH7708, CPU_SH7708S, CPU_SH7708R,
-	CPU_SH7709, CPU_SH7709A, CPU_SH7710, CPU_SH7712,
-	CPU_SH7720, CPU_SH7721, CPU_SH7729,
-
-	/* SH-4 types */
-	CPU_SH7750, CPU_SH7750S, CPU_SH7750R, CPU_SH7751, CPU_SH7751R,
-	CPU_SH7760, CPU_SH4_202, CPU_SH4_501,
-
-	/* SH-4A types */
-	CPU_SH7763, CPU_SH7770, CPU_SH7780, CPU_SH7781, CPU_SH7785, CPU_SH7786,
-	CPU_SH7723, CPU_SH7724, CPU_SH7757, CPU_SH7734, CPU_SHX3,
-
-	/* SH4AL-DSP types */
-	CPU_SH7343, CPU_SH7722, CPU_SH7366, CPU_SH7372,
-
-	/* Unknown subtype */
-	CPU_SH_NONE
-};
-
-enum cpu_family {
-	CPU_FAMILY_SH2,
-	CPU_FAMILY_SH2A,
-	CPU_FAMILY_SH3,
-	CPU_FAMILY_SH4,
-	CPU_FAMILY_SH4A,
-	CPU_FAMILY_SH4AL_DSP,
-	CPU_FAMILY_UNKNOWN,
-};
-
-/*
- * TLB information structure
- *
- * Defined for both I and D tlb, per-processor.
- */
-struct tlb_info {
-	unsigned long long next;
-	unsigned long long first;
-	unsigned long long last;
-
-	unsigned int entries;
-	unsigned int step;
-
-	unsigned long flags;
-};
-
-struct sh_cpuinfo {
-	unsigned int type, family;
-	int cut_major, cut_minor;
-	unsigned long loops_per_jiffy;
-	unsigned long asid_cache;
-
-	struct cache_info icache;	/* Primary I-cache */
-	struct cache_info dcache;	/* Primary D-cache */
-	struct cache_info scache;	/* Secondary cache */
-
-	/* TLB info */
-	struct tlb_info itlb;
-	struct tlb_info dtlb;
-
-	unsigned int phys_bits;
-	unsigned long flags;
-} __attribute__ ((aligned(L1_CACHE_BYTES)));
-
-extern struct sh_cpuinfo cpu_data[];
-#define boot_cpu_data cpu_data[0]
-#define current_cpu_data cpu_data[smp_processor_id()]
-#define raw_current_cpu_data cpu_data[raw_smp_processor_id()]
-
-#define cpu_sleep()	__asm__ __volatile__ ("sleep" : : : "memory")
-#define cpu_relax()	barrier()
-
-void default_idle(void);
-void stop_this_cpu(void *);
-
-/* Forward decl */
-struct seq_operations;
-struct task_struct;
-
-extern struct pt_regs fake_swapper_regs;
-
-extern void cpu_init(void);
-extern void cpu_probe(void);
-
-/* arch/sh/kernel/process.c */
-extern unsigned int xstate_size;
-extern void free_thread_xstate(struct task_struct *);
-extern struct kmem_cache *task_xstate_cachep;
-
-/* arch/sh/mm/alignment.c */
-extern int get_unalign_ctl(struct task_struct *, unsigned long addr);
-extern int set_unalign_ctl(struct task_struct *, unsigned int val);
-
-#define GET_UNALIGN_CTL(tsk, addr)	get_unalign_ctl((tsk), (addr))
-#define SET_UNALIGN_CTL(tsk, val)	set_unalign_ctl((tsk), (val))
-
-/* arch/sh/mm/init.c */
-extern unsigned int mem_init_done;
-
-/* arch/sh/kernel/setup.c */
-const char *get_cpu_subtype(struct sh_cpuinfo *c);
-extern const struct seq_operations cpuinfo_op;
-
-/* thread_struct flags */
-#define SH_THREAD_UAC_NOPRINT	(1 << 0)
-#define SH_THREAD_UAC_SIGBUS	(1 << 1)
-#define SH_THREAD_UAC_MASK	(SH_THREAD_UAC_NOPRINT | SH_THREAD_UAC_SIGBUS)
-
-/* processor boot mode configuration */
-#define MODE_PIN0 (1 << 0)
-#define MODE_PIN1 (1 << 1)
-#define MODE_PIN2 (1 << 2)
-#define MODE_PIN3 (1 << 3)
-#define MODE_PIN4 (1 << 4)
-#define MODE_PIN5 (1 << 5)
-#define MODE_PIN6 (1 << 6)
-#define MODE_PIN7 (1 << 7)
-#define MODE_PIN8 (1 << 8)
-#define MODE_PIN9 (1 << 9)
-#define MODE_PIN10 (1 << 10)
-#define MODE_PIN11 (1 << 11)
-#define MODE_PIN12 (1 << 12)
-#define MODE_PIN13 (1 << 13)
-#define MODE_PIN14 (1 << 14)
-#define MODE_PIN15 (1 << 15)
-
-int generic_mode_pins(void);
-int test_mode_pin(int pin);
-
-#ifdef CONFIG_VSYSCALL
-int vsyscall_init(void);
-#else
-#define vsyscall_init() do { } while (0)
-#endif
-
-/*
- * SH-2A has both 16 and 32-bit opcodes, do lame encoding checks.
- */
-#ifdef CONFIG_CPU_SH2A
-extern unsigned int instruction_size(unsigned int insn);
-#else
-#define instruction_size(insn)	(2)
-#endif
-
-#endif /* __ASSEMBLY__ */
-
-#include <asm/processor_32.h>
-
-#endif /* __ASM_SH_PROCESSOR_H */
diff --git a/arch/sh/include/asm/processor_32.h b/arch/sh/include/asm/processor_32.h
deleted file mode 100644
index 27aebf1e75a200..00000000000000
--- a/arch/sh/include/asm/processor_32.h
+++ /dev/null
@@ -1,202 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * include/asm-sh/processor.h
- *
- * Copyright (C) 1999, 2000  Niibe Yutaka
- * Copyright (C) 2002, 2003  Paul Mundt
- */
-
-#ifndef __ASM_SH_PROCESSOR_32_H
-#define __ASM_SH_PROCESSOR_32_H
-
-#include <linux/compiler.h>
-#include <linux/linkage.h>
-#include <asm/page.h>
-#include <asm/types.h>
-#include <asm/hw_breakpoint.h>
-
-/* Core Processor Version Register */
-#define CCN_PVR		0xff000030
-#define CCN_CVR		0xff000040
-#define CCN_PRR		0xff000044
-
-/*
- * User space process size: 2GB.
- *
- * Since SH7709 and SH7750 have "area 7", we can't use 0x7c000000--0x7fffffff
- */
-#define TASK_SIZE	0x7c000000UL
-
-#define STACK_TOP	TASK_SIZE
-#define STACK_TOP_MAX	STACK_TOP
-
-/* This decides where the kernel will search for a free chunk of vm
- * space during mmap's.
- */
-#define TASK_UNMAPPED_BASE	PAGE_ALIGN(TASK_SIZE / 3)
-
-/*
- * Bit of SR register
- *
- * FD-bit:
- *     When it's set, it means the processor doesn't have right to use FPU,
- *     and it results exception when the floating operation is executed.
- *
- * IMASK-bit:
- *     Interrupt level mask
- */
-#define SR_DSP		0x00001000
-#define SR_IMASK	0x000000f0
-#define SR_FD		0x00008000
-#define SR_MD		0x40000000
-
-/*
- * DSP structure and data
- */
-struct sh_dsp_struct {
-	unsigned long dsp_regs[14];
-	long status;
-};
-
-/*
- * FPU structure and data
- */
-
-struct sh_fpu_hard_struct {
-	unsigned long fp_regs[16];
-	unsigned long xfp_regs[16];
-	unsigned long fpscr;
-	unsigned long fpul;
-
-	long status; /* software status information */
-};
-
-/* Dummy fpu emulator  */
-struct sh_fpu_soft_struct {
-	unsigned long fp_regs[16];
-	unsigned long xfp_regs[16];
-	unsigned long fpscr;
-	unsigned long fpul;
-
-	unsigned char lookahead;
-	unsigned long entry_pc;
-};
-
-union thread_xstate {
-	struct sh_fpu_hard_struct hardfpu;
-	struct sh_fpu_soft_struct softfpu;
-};
-
-struct thread_struct {
-	/* Saved registers when thread is descheduled */
-	unsigned long sp;
-	unsigned long pc;
-
-	/* Various thread flags, see SH_THREAD_xxx */
-	unsigned long flags;
-
-	/* Save middle states of ptrace breakpoints */
-	struct perf_event *ptrace_bps[HBP_NUM];
-
-#ifdef CONFIG_SH_DSP
-	/* Dsp status information */
-	struct sh_dsp_struct dsp_status;
-#endif
-
-	/* Extended processor state */
-	union thread_xstate *xstate;
-
-	/*
-	 * fpu_counter contains the number of consecutive context switches
-	 * that the FPU is used. If this is over a threshold, the lazy fpu
-	 * saving becomes unlazy to save the trap. This is an unsigned char
-	 * so that after 256 times the counter wraps and the behavior turns
-	 * lazy again; this to deal with bursty apps that only use FPU for
-	 * a short time
-	 */
-	unsigned char fpu_counter;
-};
-
-#define INIT_THREAD  {						\
-	.sp = sizeof(init_stack) + (long) &init_stack,		\
-	.flags = 0,						\
-}
-
-/* Forward declaration, a strange C thing */
-struct task_struct;
-
-extern void start_thread(struct pt_regs *regs, unsigned long new_pc, unsigned long new_sp);
-
-/*
- * FPU lazy state save handling.
- */
-
-static __inline__ void disable_fpu(void)
-{
-	unsigned long __dummy;
-
-	/* Set FD flag in SR */
-	__asm__ __volatile__("stc	sr, %0\n\t"
-			     "or	%1, %0\n\t"
-			     "ldc	%0, sr"
-			     : "=&r" (__dummy)
-			     : "r" (SR_FD));
-}
-
-static __inline__ void enable_fpu(void)
-{
-	unsigned long __dummy;
-
-	/* Clear out FD flag in SR */
-	__asm__ __volatile__("stc	sr, %0\n\t"
-			     "and	%1, %0\n\t"
-			     "ldc	%0, sr"
-			     : "=&r" (__dummy)
-			     : "r" (~SR_FD));
-}
-
-/* Double presision, NANS as NANS, rounding to nearest, no exceptions */
-#define FPSCR_INIT  0x00080000
-
-#define	FPSCR_CAUSE_MASK	0x0001f000	/* Cause bits */
-#define	FPSCR_FLAG_MASK		0x0000007c	/* Flag bits */
-
-/*
- * Return saved PC of a blocked thread.
- */
-#define thread_saved_pc(tsk)	(tsk->thread.pc)
-
-void show_trace(struct task_struct *tsk, unsigned long *sp,
-		struct pt_regs *regs, const char *loglvl);
-
-#ifdef CONFIG_DUMP_CODE
-void show_code(struct pt_regs *regs);
-#else
-static inline void show_code(struct pt_regs *regs)
-{
-}
-#endif
-
-extern unsigned long __get_wchan(struct task_struct *p);
-
-#define KSTK_EIP(tsk)  (task_pt_regs(tsk)->pc)
-#define KSTK_ESP(tsk)  (task_pt_regs(tsk)->regs[15])
-
-#if defined(CONFIG_CPU_SH2A) || defined(CONFIG_CPU_SH4)
-
-#define PREFETCH_STRIDE		L1_CACHE_BYTES
-#define ARCH_HAS_PREFETCH
-#define ARCH_HAS_PREFETCHW
-
-static inline void prefetch(const void *x)
-{
-	__builtin_prefetch(x, 0, 3);
-}
-
-static inline void prefetchw(const void *x)
-{
-	__builtin_prefetch(x, 1, 3);
-}
-#endif
-
-#endif /* __ASM_SH_PROCESSOR_32_H */
diff --git a/arch/sh/include/asm/ptrace.h b/arch/sh/include/asm/ptrace.h
deleted file mode 100644
index 6c89e3e04cee7f..00000000000000
--- a/arch/sh/include/asm/ptrace.h
+++ /dev/null
@@ -1,139 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 1999, 2000  Niibe Yutaka
- */
-#ifndef __ASM_SH_PTRACE_H
-#define __ASM_SH_PTRACE_H
-
-
-#include <linux/stringify.h>
-#include <linux/stddef.h>
-#include <linux/thread_info.h>
-#include <asm/addrspace.h>
-#include <asm/page.h>
-#include <uapi/asm/ptrace.h>
-
-#define user_mode(regs)			(((regs)->sr & 0x40000000)==0)
-#define kernel_stack_pointer(_regs)	((unsigned long)(_regs)->regs[15])
-
-static inline unsigned long instruction_pointer(struct pt_regs *regs)
-{
-	return regs->pc;
-}
-static inline void instruction_pointer_set(struct pt_regs *regs,
-		unsigned long val)
-{
-	regs->pc = val;
-}
-
-static inline unsigned long frame_pointer(struct pt_regs *regs)
-{
-	return regs->regs[14];
-}
-
-static inline unsigned long user_stack_pointer(struct pt_regs *regs)
-{
-	return regs->regs[15];
-}
-
-static inline void user_stack_pointer_set(struct pt_regs *regs,
-		unsigned long val)
-{
-	regs->regs[15] = val;
-}
-
-#define arch_has_single_step()	(1)
-
-/*
- * kprobe-based event tracer support
- */
-struct pt_regs_offset {
-	const char *name;
-	int offset;
-};
-
-#define REG_OFFSET_NAME(r) {.name = #r, .offset = offsetof(struct pt_regs, r)}
-#define REGS_OFFSET_NAME(num)	\
-	{.name = __stringify(r##num), .offset = offsetof(struct pt_regs, regs[num])}
-#define TREGS_OFFSET_NAME(num)	\
-	{.name = __stringify(tr##num), .offset = offsetof(struct pt_regs, tregs[num])}
-#define REG_OFFSET_END {.name = NULL, .offset = 0}
-
-/* Query offset/name of register from its name/offset */
-extern int regs_query_register_offset(const char *name);
-extern const char *regs_query_register_name(unsigned int offset);
-
-extern const struct pt_regs_offset regoffset_table[];
-
-/**
- * regs_get_register() - get register value from its offset
- * @regs:	pt_regs from which register value is gotten.
- * @offset:	offset number of the register.
- *
- * regs_get_register returns the value of a register. The @offset is the
- * offset of the register in struct pt_regs address which specified by @regs.
- * If @offset is bigger than MAX_REG_OFFSET, this returns 0.
- */
-static inline unsigned long regs_get_register(struct pt_regs *regs,
-					      unsigned int offset)
-{
-	if (unlikely(offset > MAX_REG_OFFSET))
-		return 0;
-	return *(unsigned long *)((unsigned long)regs + offset);
-}
-
-/**
- * regs_within_kernel_stack() - check the address in the stack
- * @regs:	pt_regs which contains kernel stack pointer.
- * @addr:	address which is checked.
- *
- * regs_within_kernel_stack() checks @addr is within the kernel stack page(s).
- * If @addr is within the kernel stack, it returns true. If not, returns false.
- */
-static inline int regs_within_kernel_stack(struct pt_regs *regs,
-					   unsigned long addr)
-{
-	return ((addr & ~(THREAD_SIZE - 1))  ==
-		(kernel_stack_pointer(regs) & ~(THREAD_SIZE - 1)));
-}
-
-/**
- * regs_get_kernel_stack_nth() - get Nth entry of the stack
- * @regs:	pt_regs which contains kernel stack pointer.
- * @n:		stack entry number.
- *
- * regs_get_kernel_stack_nth() returns @n th entry of the kernel stack which
- * is specified by @regs. If the @n th entry is NOT in the kernel stack,
- * this returns 0.
- */
-static inline unsigned long regs_get_kernel_stack_nth(struct pt_regs *regs,
-						      unsigned int n)
-{
-	unsigned long *addr = (unsigned long *)kernel_stack_pointer(regs);
-	addr += n;
-	if (regs_within_kernel_stack(regs, (unsigned long)addr))
-		return *addr;
-	else
-		return 0;
-}
-
-struct perf_event;
-struct perf_sample_data;
-
-extern void ptrace_triggered(struct perf_event *bp,
-		      struct perf_sample_data *data, struct pt_regs *regs);
-
-#define task_pt_regs(task) \
-	((struct pt_regs *) (task_stack_page(task) + THREAD_SIZE) - 1)
-
-static inline unsigned long profile_pc(struct pt_regs *regs)
-{
-	unsigned long pc = regs->pc;
-
-	if (virt_addr_uncached(pc))
-		return CAC_ADDR(pc);
-
-	return pc;
-}
-
-#endif /* __ASM_SH_PTRACE_H */
diff --git a/arch/sh/include/asm/ptrace_32.h b/arch/sh/include/asm/ptrace_32.h
deleted file mode 100644
index 5f37ad7c60652b..00000000000000
--- a/arch/sh/include/asm/ptrace_32.h
+++ /dev/null
@@ -1,14 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_PTRACE_32_H
-#define __ASM_SH_PTRACE_32_H
-
-#include <uapi/asm/ptrace_32.h>
-
-
-#define MAX_REG_OFFSET		offsetof(struct pt_regs, tra)
-static inline long regs_return_value(struct pt_regs *regs)
-{
-	return regs->regs[0];
-}
-
-#endif /* __ASM_SH_PTRACE_32_H */
diff --git a/arch/sh/include/asm/push-switch.h b/arch/sh/include/asm/push-switch.h
deleted file mode 100644
index c5f072572fd18a..00000000000000
--- a/arch/sh/include/asm/push-switch.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_PUSH_SWITCH_H
-#define __ASM_SH_PUSH_SWITCH_H
-
-#include <linux/timer.h>
-#include <linux/interrupt.h>
-#include <linux/workqueue.h>
-#include <linux/platform_device.h>
-
-struct push_switch {
-	/* switch state */
-	unsigned int		state:1;
-	/* debounce timer */
-	struct timer_list	debounce;
-	/* workqueue */
-	struct work_struct	work;
-	/* platform device, for workqueue handler */
-	struct platform_device	*pdev;
-};
-
-struct push_switch_platform_info {
-	/* IRQ handler */
-	irqreturn_t		(*irq_handler)(int irq, void *data);
-	/* Special IRQ flags */
-	unsigned int		irq_flags;
-	/* Bit location of switch */
-	unsigned int		bit;
-	/* Symbolic switch name */
-	const char		*name;
-};
-
-#endif /* __ASM_SH_PUSH_SWITCH_H */
diff --git a/arch/sh/include/asm/reboot.h b/arch/sh/include/asm/reboot.h
deleted file mode 100644
index 5c445c90df14d9..00000000000000
--- a/arch/sh/include/asm/reboot.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_REBOOT_H
-#define __ASM_SH_REBOOT_H
-
-#include <linux/kdebug.h>
-
-struct pt_regs;
-
-struct machine_ops {
-	void (*restart)(char *cmd);
-	void (*halt)(void);
-	void (*power_off)(void);
-	void (*shutdown)(void);
-	void (*crash_shutdown)(struct pt_regs *);
-};
-
-extern struct machine_ops machine_ops;
-
-/* arch/sh/kernel/machine_kexec.c */
-void native_machine_crash_shutdown(struct pt_regs *regs);
-
-#endif /* __ASM_SH_REBOOT_H */
diff --git a/arch/sh/include/asm/romimage-macros.h b/arch/sh/include/asm/romimage-macros.h
deleted file mode 100644
index f9352ee7c21b4b..00000000000000
--- a/arch/sh/include/asm/romimage-macros.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ROMIMAGE_MACRO_H
-#define __ROMIMAGE_MACRO_H
-
-/* The LIST command is used to include comments in the script */
-.macro	LIST comment
-.endm
-
-/* The ED command is used to write a 32-bit word */
-.macro  ED, addr, data
-	mov.l 1f, r1
-	mov.l 2f, r0
-	mov.l r0, @r1
-	bra 3f
-	 nop
-	.align 2
-1 :	.long \addr
-2 :	.long \data
-3 :
-.endm
-
-/* The EW command is used to write a 16-bit word */
-.macro  EW, addr, data
-	mov.l 1f, r1
-	mov.l 2f, r0
-	mov.w r0, @r1
-	bra 3f
-	 nop
-	.align 2
-1 :	.long \addr
-2 :	.long \data
-3 :
-.endm
-
-/* The EB command is used to write an 8-bit word */
-.macro  EB, addr, data
-	mov.l 1f, r1
-	mov.l 2f, r0
-	mov.b r0, @r1
-	bra 3f
-	 nop
-	.align 2
-1 :	.long \addr
-2 :	.long \data
-3 :
-.endm
-
-/* The WAIT command is used to delay the execution */
-.macro  WAIT, time
-	mov.l  2f, r3
-1 :
-	nop
-	tst     r3, r3
-	bf/s    1b
-	dt      r3
-	bra	3f
-	 nop
-	.align 2
-2 :	.long \time * 100
-3 :
-.endm
-
-/* The DD command is used to read a 32-bit word */
-.macro  DD, addr, addr2, nr
-	mov.l 1f, r1
-	mov.l @r1, r0
-	bra 2f
-	 nop
-	.align 2
-1 :	.long \addr
-2 :
-.endm
-
-#endif /* __ROMIMAGE_MACRO_H */
diff --git a/arch/sh/include/asm/rtc.h b/arch/sh/include/asm/rtc.h
deleted file mode 100644
index 69dbae2949b0dd..00000000000000
--- a/arch/sh/include/asm/rtc.h
+++ /dev/null
@@ -1,15 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _ASM_RTC_H
-#define _ASM_RTC_H
-
-void time_init(void);
-
-#define RTC_CAP_4_DIGIT_YEAR	(1 << 0)
-
-struct sh_rtc_platform_info {
-	unsigned long capabilities;
-};
-
-#include <cpu/rtc.h>
-
-#endif /* _ASM_RTC_H */
diff --git a/arch/sh/include/asm/seccomp.h b/arch/sh/include/asm/seccomp.h
deleted file mode 100644
index d4578395fd665c..00000000000000
--- a/arch/sh/include/asm/seccomp.h
+++ /dev/null
@@ -1,21 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SECCOMP_H
-
-#include <linux/unistd.h>
-
-#define __NR_seccomp_read __NR_read
-#define __NR_seccomp_write __NR_write
-#define __NR_seccomp_exit __NR_exit
-#define __NR_seccomp_sigreturn __NR_rt_sigreturn
-
-#ifdef CONFIG_CPU_LITTLE_ENDIAN
-#define __SECCOMP_ARCH_LE		__AUDIT_ARCH_LE
-#else
-#define __SECCOMP_ARCH_LE		0
-#endif
-
-#define SECCOMP_ARCH_NATIVE		(AUDIT_ARCH_SH | __SECCOMP_ARCH_LE)
-#define SECCOMP_ARCH_NATIVE_NR		NR_syscalls
-#define SECCOMP_ARCH_NATIVE_NAME	"sh"
-
-#endif /* __ASM_SECCOMP_H */
diff --git a/arch/sh/include/asm/sections.h b/arch/sh/include/asm/sections.h
deleted file mode 100644
index 0cb0ca149ac34a..00000000000000
--- a/arch/sh/include/asm/sections.h
+++ /dev/null
@@ -1,12 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_SECTIONS_H
-#define __ASM_SH_SECTIONS_H
-
-#include <asm-generic/sections.h>
-
-extern char __machvec_start[], __machvec_end[];
-extern char __uncached_start, __uncached_end;
-extern char __start_eh_frame[], __stop_eh_frame[];
-
-#endif /* __ASM_SH_SECTIONS_H */
-
diff --git a/arch/sh/include/asm/setup.h b/arch/sh/include/asm/setup.h
deleted file mode 100644
index fc807011187fa1..00000000000000
--- a/arch/sh/include/asm/setup.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _SH_SETUP_H
-#define _SH_SETUP_H
-
-#include <uapi/asm/setup.h>
-
-/*
- * This is set up by the setup-routine at boot-time
- */
-#define PARAM	((unsigned char *)empty_zero_page)
-
-#define MOUNT_ROOT_RDONLY (*(unsigned long *) (PARAM+0x000))
-#define RAMDISK_FLAGS (*(unsigned long *) (PARAM+0x004))
-#define ORIG_ROOT_DEV (*(unsigned long *) (PARAM+0x008))
-#define LOADER_TYPE (*(unsigned long *) (PARAM+0x00c))
-#define INITRD_START (*(unsigned long *) (PARAM+0x010))
-#define INITRD_SIZE (*(unsigned long *) (PARAM+0x014))
-/* ... */
-#define COMMAND_LINE ((char *) (PARAM+0x100))
-
-void sh_mv_setup(void);
-void check_for_initrd(void);
-void per_cpu_trap_init(void);
-
-#endif /* _SH_SETUP_H */
diff --git a/arch/sh/include/asm/sfp-machine.h b/arch/sh/include/asm/sfp-machine.h
deleted file mode 100644
index 2d2423478b71d4..00000000000000
--- a/arch/sh/include/asm/sfp-machine.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+
- *
- * Machine-dependent software floating-point definitions.
-   SuperH kernel version.
-   Copyright (C) 1997,1998,1999 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Richard Henderson (rth@cygnus.com),
-		  Jakub Jelinek (jj@ultra.linux.cz),
-		  David S. Miller (davem@redhat.com) and
-		  Peter Maydell (pmaydell@chiark.greenend.org.uk).
-*/
-
-#ifndef _SFP_MACHINE_H
-#define _SFP_MACHINE_H
-
-#ifdef __BIG_ENDIAN__
-#define __BYTE_ORDER __BIG_ENDIAN
-#define __LITTLE_ENDIAN 0
-#else
-#define __BYTE_ORDER __LITTLE_ENDIAN
-#define __BIG_ENDIAN 0
-#endif
-
-#define _FP_W_TYPE_SIZE		32
-#define _FP_W_TYPE		unsigned long
-#define _FP_WS_TYPE		signed long
-#define _FP_I_TYPE		long
-
-#define _FP_MUL_MEAT_S(R,X,Y)					\
-  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)
-#define _FP_MUL_MEAT_D(R,X,Y)					\
-  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
-#define _FP_MUL_MEAT_Q(R,X,Y)					\
-  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)
-
-#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_udiv(S,R,X,Y)
-#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_2_udiv(D,R,X,Y)
-#define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_4_udiv(Q,R,X,Y)
-
-#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
-#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
-#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
-#define _FP_NANSIGN_S		0
-#define _FP_NANSIGN_D		0
-#define _FP_NANSIGN_Q		0
-
-#define _FP_KEEPNANFRACP 1
-
-/*
- * If one NaN is signaling and the other is not,
- * we choose that one, otherwise we choose X.
- */
-#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)                      \
-  do {                                                          \
-    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)          \
-        && !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))     \
-      {                                                         \
-        R##_s = Y##_s;                                          \
-        _FP_FRAC_COPY_##wc(R,Y);                                \
-      }                                                         \
-    else                                                        \
-      {                                                         \
-        R##_s = X##_s;                                          \
-        _FP_FRAC_COPY_##wc(R,X);                                \
-      }                                                         \
-    R##_c = FP_CLS_NAN;                                         \
-  } while (0)
-
-//#define FP_ROUNDMODE		FPSCR_RM
-#define FP_DENORM_ZERO		1/*FPSCR_DN*/
-
-/* Exception flags. */
-#define FP_EX_INVALID		(1<<4)
-#define FP_EX_DIVZERO		(1<<3)
-#define FP_EX_OVERFLOW		(1<<2)
-#define FP_EX_UNDERFLOW		(1<<1)
-#define FP_EX_INEXACT		(1<<0)
-
-#endif
-
diff --git a/arch/sh/include/asm/sh7760fb.h b/arch/sh/include/asm/sh7760fb.h
deleted file mode 100644
index 2d9433d7540299..00000000000000
--- a/arch/sh/include/asm/sh7760fb.h
+++ /dev/null
@@ -1,198 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * sh7760fb.h -- platform data for SH7760/SH7763 LCDC framebuffer driver.
- *
- * (c) 2006-2008 MSC Vertriebsges.m.b.H.,
- * 			Manuel Lauss <mano@roarinelk.homelinux.net>
- * (c) 2008 Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
- */
-
-#ifndef _ASM_SH_SH7760FB_H
-#define _ASM_SH_SH7760FB_H
-
-/*
- * some bits of the colormap registers should be written as zero.
- * create a mask for that.
- */
-#define SH7760FB_PALETTE_MASK 0x00f8fcf8
-
-/* The LCDC dma engine always sets bits 27-26 to 1: this is Area3 */
-#define SH7760FB_DMA_MASK 0x0C000000
-
-/* palette */
-#define LDPR(x) (((x) << 2))
-
-/* framebuffer registers and bits */
-#define LDICKR 0x400
-#define LDMTR 0x402
-/* see sh7760fb.h for LDMTR bits */
-#define LDDFR 0x404
-#define LDDFR_PABD (1 << 8)
-#define LDDFR_COLOR_MASK 0x7F
-#define LDSMR 0x406
-#define LDSMR_ROT (1 << 13)
-#define LDSARU 0x408
-#define LDSARL 0x40c
-#define LDLAOR 0x410
-#define LDPALCR 0x412
-#define LDPALCR_PALS (1 << 4)
-#define LDPALCR_PALEN (1 << 0)
-#define LDHCNR 0x414
-#define LDHSYNR 0x416
-#define LDVDLNR 0x418
-#define LDVTLNR 0x41a
-#define LDVSYNR 0x41c
-#define LDACLNR 0x41e
-#define LDINTR 0x420
-#define LDPMMR 0x424
-#define LDPSPR 0x426
-#define LDCNTR 0x428
-#define LDCNTR_DON (1 << 0)
-#define LDCNTR_DON2 (1 << 4)
-
-#ifdef CONFIG_CPU_SUBTYPE_SH7763
-# define LDLIRNR       0x440
-/* LDINTR bit */
-# define LDINTR_MINTEN (1 << 15)
-# define LDINTR_FINTEN (1 << 14)
-# define LDINTR_VSINTEN (1 << 13)
-# define LDINTR_VEINTEN (1 << 12)
-# define LDINTR_MINTS (1 << 11)
-# define LDINTR_FINTS (1 << 10)
-# define LDINTR_VSINTS (1 << 9)
-# define LDINTR_VEINTS (1 << 8)
-# define VINT_START (LDINTR_VSINTEN)
-# define VINT_CHECK (LDINTR_VSINTS)
-#else
-/* LDINTR bit */
-# define LDINTR_VINTSEL (1 << 12)
-# define LDINTR_VINTE (1 << 8)
-# define LDINTR_VINTS (1 << 0)
-# define VINT_START (LDINTR_VINTSEL)
-# define VINT_CHECK (LDINTR_VINTS)
-#endif
-
-/* HSYNC polarity inversion */
-#define LDMTR_FLMPOL (1 << 15)
-
-/* VSYNC polarity inversion */
-#define LDMTR_CL1POL (1 << 14)
-
-/* DISPLAY-ENABLE polarity inversion */
-#define LDMTR_DISPEN_LOWACT (1 << 13)
-
-/* DISPLAY DATA BUS polarity inversion */
-#define LDMTR_DPOL_LOWACT (1 << 12)
-
-/* AC modulation signal enable */
-#define LDMTR_MCNT (1 << 10)
-
-/* Disable output of HSYNC during VSYNC period */
-#define LDMTR_CL1CNT (1 << 9)
-
-/* Disable output of VSYNC during VSYNC period */
-#define LDMTR_CL2CNT (1 << 8)
-
-/* Display types supported by the LCDC */
-#define LDMTR_STN_MONO_4       0x00
-#define LDMTR_STN_MONO_8       0x01
-#define LDMTR_STN_COLOR_4      0x08
-#define LDMTR_STN_COLOR_8      0x09
-#define LDMTR_STN_COLOR_12     0x0A
-#define LDMTR_STN_COLOR_16     0x0B
-#define LDMTR_DSTN_MONO_8      0x11
-#define LDMTR_DSTN_MONO_16     0x13
-#define LDMTR_DSTN_COLOR_8     0x19
-#define LDMTR_DSTN_COLOR_12    0x1A
-#define LDMTR_DSTN_COLOR_16    0x1B
-#define LDMTR_TFT_COLOR_16     0x2B
-
-/* framebuffer color layout */
-#define LDDFR_1BPP_MONO 0x00
-#define LDDFR_2BPP_MONO 0x01
-#define LDDFR_4BPP_MONO 0x02
-#define LDDFR_6BPP_MONO 0x04
-#define LDDFR_4BPP 0x0A
-#define LDDFR_8BPP 0x0C
-#define LDDFR_16BPP_RGB555 0x1D
-#define LDDFR_16BPP_RGB565 0x2D
-
-/* LCDC Pixclock sources */
-#define LCDC_CLKSRC_BUSCLOCK 0
-#define LCDC_CLKSRC_PERIPHERAL 1
-#define LCDC_CLKSRC_EXTERNAL 2
-
-#define LDICKR_CLKSRC(x) \
-       (((x) & 3) << 12)
-
-/* LCDC pixclock input divider. Set to 1 at a minimum! */
-#define LDICKR_CLKDIV(x) \
-       ((x) & 0x1f)
-
-struct sh7760fb_platdata {
-
-	/* Set this member to a valid fb_videmode for the display you
-	 * wish to use.  The following members must be initialized:
-	 * xres, yres, hsync_len, vsync_len, sync,
-	 * {left,right,upper,lower}_margin.
-	 * The driver uses the above members to calculate register values
-	 * and memory requirements. Other members are ignored but may
-	 * be used by other framebuffer layer components.
-	 */
-	struct fb_videomode *def_mode;
-
-	/* LDMTR includes display type and signal polarity.  The
-	 * HSYNC/VSYNC polarities are derived from the fb_var_screeninfo
-	 * data above; however the polarities of the following signals
-	 * must be encoded in the ldmtr member:
-	 * Display Enable signal (default high-active)  DISPEN_LOWACT
-	 * Display Data signals (default high-active)   DPOL_LOWACT
-	 * AC Modulation signal (default off)           MCNT
-	 * Hsync-During-Vsync suppression (default off) CL1CNT
-	 * Vsync-during-vsync suppression (default off) CL2CNT
-	 * NOTE: also set a display type!
-	 * (one of LDMTR_{STN,DSTN,TFT}_{MONO,COLOR}_{4,8,12,16})
-	 */
-	u16 ldmtr;
-
-	/* LDDFR controls framebuffer image format (depth, organization)
-	 * Use ONE of the LDDFR_?BPP_* macros!
-	 */
-	u16 lddfr;
-
-	/* LDPMMR and LDPSPR control the timing of the power signals
-	 * for the display. Please read the SH7760 Hardware Manual,
-	 * Chapters 30.3.17, 30.3.18 and 30.4.6!
-	 */
-	u16 ldpmmr;
-	u16 ldpspr;
-
-	/* LDACLNR contains the line numbers after which the AC modulation
-	 * signal is to toggle. Set to ZERO for TFTs or displays which
-	 * do not need it. (Chapter 30.3.15 in SH7760 Hardware Manual).
-	 */
-	u16 ldaclnr;
-
-	/* LDICKR contains information on pixelclock source and config.
-	 * Please use the LDICKR_CLKSRC() and LDICKR_CLKDIV() macros.
-	 * minimal value for CLKDIV() must be 1!.
-	 */
-	u16 ldickr;
-
-	/* set this member to 1 if you wish to use the LCDC's hardware
-	 * rotation function.  This is limited to displays <= 320x200
-	 * pixels resolution!
-	 */
-	int rotate;		/* set to 1 to rotate 90 CCW */
-
-	/* set this to 1 to suppress vsync irq use. */
-	int novsync;
-
-	/* blanking hook for platform. Set this if your platform can do
-	 * more than the LCDC in terms of blanking (e.g. disable clock
-	 * generator / backlight power supply / etc.
-	 */
-	void (*blank) (int);
-};
-
-#endif /* _ASM_SH_SH7760FB_H */
diff --git a/arch/sh/include/asm/sh_bios.h b/arch/sh/include/asm/sh_bios.h
deleted file mode 100644
index ab693b9824421d..00000000000000
--- a/arch/sh/include/asm/sh_bios.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_BIOS_H
-#define __ASM_SH_BIOS_H
-
-#ifdef CONFIG_SH_STANDARD_BIOS
-
-/*
- * Copyright (C) 2000 Greg Banks, Mitch Davis
- * C API to interface to the standard LinuxSH BIOS
- * usually from within the early stages of kernel boot.
- */
-extern void sh_bios_console_write(const char *buf, unsigned int len);
-extern void sh_bios_gdb_detach(void);
-
-extern void sh_bios_get_node_addr(unsigned char *node_addr);
-extern void sh_bios_shutdown(unsigned int how);
-
-extern void sh_bios_vbr_init(void);
-extern void sh_bios_vbr_reload(void);
-
-#else
-
-static inline void sh_bios_vbr_init(void) { }
-static inline void sh_bios_vbr_reload(void) { }
-
-#endif /* CONFIG_SH_STANDARD_BIOS */
-
-#endif /* __ASM_SH_BIOS_H */
diff --git a/arch/sh/include/asm/shmparam.h b/arch/sh/include/asm/shmparam.h
deleted file mode 100644
index 6c580a644a78c6..00000000000000
--- a/arch/sh/include/asm/shmparam.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/shmparam.h
- *
- * Copyright (C) 1999 Niibe Yutaka
- * Copyright (C) 2006 Paul Mundt
- */
-#ifndef __ASM_SH_SHMPARAM_H
-#define __ASM_SH_SHMPARAM_H
-
-/*
- * SH-4 and SH-3 7705 have an aliasing dcache. Bump this up to a sensible value
- * for everyone, and work out the specifics from the probed cache descriptor.
- */
-#define	SHMLBA	0x4000		 /* attach addr a multiple of this */
-
-#define __ARCH_FORCE_SHMLBA
-
-#endif /* __ASM_SH_SHMPARAM_H */
diff --git a/arch/sh/include/asm/siu.h b/arch/sh/include/asm/siu.h
deleted file mode 100644
index 35e4839d381e88..00000000000000
--- a/arch/sh/include/asm/siu.h
+++ /dev/null
@@ -1,20 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * platform header for the SIU ASoC driver
- *
- * Copyright (C) 2009-2010 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
- */
-
-#ifndef ASM_SIU_H
-#define ASM_SIU_H
-
-struct device;
-
-struct siu_platform {
-	unsigned int dma_slave_tx_a;
-	unsigned int dma_slave_rx_a;
-	unsigned int dma_slave_tx_b;
-	unsigned int dma_slave_rx_b;
-};
-
-#endif /* ASM_SIU_H */
diff --git a/arch/sh/include/asm/smc37c93x.h b/arch/sh/include/asm/smc37c93x.h
deleted file mode 100644
index 891f2f8f2fd03a..00000000000000
--- a/arch/sh/include/asm/smc37c93x.h
+++ /dev/null
@@ -1,191 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_SMC37C93X_H
-#define __ASM_SH_SMC37C93X_H
-
-/*
- * linux/include/asm-sh/smc37c93x.h
- *
- * Copyright (C) 2000  Kazumoto Kojima
- *
- * SMSC 37C93x Super IO Chip support
- */
-
-/* Default base I/O address */
-#define FDC_PRIMARY_BASE	0x3f0
-#define IDE1_PRIMARY_BASE	0x1f0
-#define IDE1_SECONDARY_BASE	0x170
-#define PARPORT_PRIMARY_BASE	0x378
-#define COM1_PRIMARY_BASE	0x2f8
-#define COM2_PRIMARY_BASE	0x3f8
-#define RTC_PRIMARY_BASE	0x070
-#define KBC_PRIMARY_BASE	0x060
-#define AUXIO_PRIMARY_BASE	0x000	/* XXX */
-
-/* Logical device number */
-#define LDN_FDC			0
-#define LDN_IDE1		1
-#define LDN_IDE2		2
-#define LDN_PARPORT		3
-#define LDN_COM1		4
-#define LDN_COM2		5
-#define LDN_RTC			6
-#define LDN_KBC			7
-#define LDN_AUXIO		8
-
-/* Configuration port and key */
-#define CONFIG_PORT		0x3f0
-#define INDEX_PORT		CONFIG_PORT
-#define DATA_PORT		0x3f1
-#define CONFIG_ENTER		0x55
-#define CONFIG_EXIT		0xaa
-
-/* Configuration index */
-#define CURRENT_LDN_INDEX	0x07
-#define POWER_CONTROL_INDEX	0x22
-#define ACTIVATE_INDEX		0x30
-#define IO_BASE_HI_INDEX	0x60
-#define IO_BASE_LO_INDEX	0x61
-#define IRQ_SELECT_INDEX	0x70
-#define DMA_SELECT_INDEX	0x74
-
-#define GPIO46_INDEX		0xc6
-#define GPIO47_INDEX		0xc7
-
-/* UART stuff. Only for debugging.  */
-/* UART Register */
-
-#define UART_RBR	0x0	/* Receiver Buffer Register (Read Only) */
-#define UART_THR	0x0	/* Transmitter Holding Register (Write Only) */
-#define UART_IER	0x2	/* Interrupt Enable Register */
-#define UART_IIR	0x4	/* Interrupt Ident Register (Read Only) */
-#define UART_FCR	0x4	/* FIFO Control Register (Write Only) */
-#define UART_LCR	0x6	/* Line Control Register */
-#define UART_MCR	0x8	/* MODEM Control Register */
-#define UART_LSR	0xa	/* Line Status Register */
-#define UART_MSR	0xc	/* MODEM Status Register */
-#define UART_SCR	0xe	/* Scratch Register */
-#define UART_DLL	0x0	/* Divisor Latch (LS) */
-#define UART_DLM	0x2	/* Divisor Latch (MS) */
-
-#ifndef __ASSEMBLY__
-typedef struct uart_reg {
-	volatile __u16 rbr;
-	volatile __u16 ier;
-	volatile __u16 iir;
-	volatile __u16 lcr;
-	volatile __u16 mcr;
-	volatile __u16 lsr;
-	volatile __u16 msr;
-	volatile __u16 scr;
-} uart_reg;
-#endif /* ! __ASSEMBLY__ */
-
-/* Alias for Write Only Register */
-
-#define thr	rbr
-#define tcr	iir
-
-/* Alias for Divisor Latch Register */
-
-#define dll	rbr
-#define dlm	ier
-#define fcr	iir
-
-/* Interrupt Enable Register */
-
-#define IER_ERDAI	0x0100	/* Enable Received Data Available Interrupt */
-#define IER_ETHREI	0x0200	/* Enable Transmitter Holding Register Empty Interrupt */
-#define IER_ELSI	0x0400	/* Enable Receiver Line Status Interrupt */
-#define IER_EMSI	0x0800	/* Enable MODEM Status Interrupt */
-
-/* Interrupt Ident Register */
-
-#define IIR_IP		0x0100	/* "0" if Interrupt Pending */
-#define IIR_IIB0	0x0200	/* Interrupt ID Bit 0 */
-#define IIR_IIB1	0x0400	/* Interrupt ID Bit 1 */
-#define IIR_IIB2	0x0800	/* Interrupt ID Bit 2 */
-#define IIR_FIFO	0xc000	/* FIFOs enabled */
-
-/* FIFO Control Register */
-
-#define FCR_FEN		0x0100	/* FIFO enable */
-#define FCR_RFRES	0x0200	/* Receiver FIFO reset */
-#define FCR_TFRES	0x0400	/* Transmitter FIFO reset */
-#define FCR_DMA		0x0800	/* DMA mode select */
-#define FCR_RTL		0x4000	/* Receiver trigger (LSB) */
-#define FCR_RTM		0x8000	/* Receiver trigger (MSB) */
-
-/* Line Control Register */
-
-#define LCR_WLS0	0x0100	/* Word Length Select Bit 0 */
-#define LCR_WLS1	0x0200	/* Word Length Select Bit 1 */
-#define LCR_STB		0x0400	/* Number of Stop Bits */
-#define LCR_PEN		0x0800	/* Parity Enable */
-#define LCR_EPS		0x1000	/* Even Parity Select */
-#define LCR_SP		0x2000	/* Stick Parity */
-#define LCR_SB		0x4000	/* Set Break */
-#define LCR_DLAB	0x8000	/* Divisor Latch Access Bit */
-
-/* MODEM Control Register */
-
-#define MCR_DTR		0x0100	/* Data Terminal Ready */
-#define MCR_RTS		0x0200	/* Request to Send */
-#define MCR_OUT1	0x0400	/* Out 1 */
-#define MCR_IRQEN	0x0800	/* IRQ Enable */
-#define MCR_LOOP	0x1000	/* Loop */
-
-/* Line Status Register */
-
-#define LSR_DR		0x0100	/* Data Ready */
-#define LSR_OE		0x0200	/* Overrun Error */
-#define LSR_PE		0x0400	/* Parity Error */
-#define LSR_FE		0x0800	/* Framing Error */
-#define LSR_BI		0x1000	/* Break Interrupt */
-#define LSR_THRE	0x2000	/* Transmitter Holding Register Empty */
-#define LSR_TEMT	0x4000	/* Transmitter Empty */
-#define LSR_FIFOE	0x8000	/* Receiver FIFO error */
-
-/* MODEM Status Register */
-
-#define MSR_DCTS	0x0100	/* Delta Clear to Send */
-#define MSR_DDSR	0x0200	/* Delta Data Set Ready */
-#define MSR_TERI	0x0400	/* Trailing Edge Ring Indicator */
-#define MSR_DDCD	0x0800	/* Delta Data Carrier Detect */
-#define MSR_CTS		0x1000	/* Clear to Send */
-#define MSR_DSR		0x2000	/* Data Set Ready */
-#define MSR_RI		0x4000	/* Ring Indicator */
-#define MSR_DCD		0x8000	/* Data Carrier Detect */
-
-/* Baud Rate Divisor */
-
-#define UART_CLK	(1843200)	/* 1.8432 MHz */
-#define UART_BAUD(x)	(UART_CLK / (16 * (x)))
-
-/* RTC register definition */
-#define RTC_SECONDS             0
-#define RTC_SECONDS_ALARM       1
-#define RTC_MINUTES             2
-#define RTC_MINUTES_ALARM       3
-#define RTC_HOURS               4
-#define RTC_HOURS_ALARM         5
-#define RTC_DAY_OF_WEEK         6
-#define RTC_DAY_OF_MONTH        7
-#define RTC_MONTH               8
-#define RTC_YEAR                9
-#define RTC_FREQ_SELECT		10
-# define RTC_UIP 0x80
-# define RTC_DIV_CTL 0x70
-/* This RTC can work under 32.768KHz clock only.  */
-# define RTC_OSC_ENABLE 0x20
-# define RTC_OSC_DISABLE 0x00
-#define RTC_CONTROL     	11
-# define RTC_SET 0x80
-# define RTC_PIE 0x40
-# define RTC_AIE 0x20
-# define RTC_UIE 0x10
-# define RTC_SQWE 0x08
-# define RTC_DM_BINARY 0x04
-# define RTC_24H 0x02
-# define RTC_DST_EN 0x01
-
-#endif  /* __ASM_SH_SMC37C93X_H */
diff --git a/arch/sh/include/asm/smp-ops.h b/arch/sh/include/asm/smp-ops.h
deleted file mode 100644
index e27702130eb6f3..00000000000000
--- a/arch/sh/include/asm/smp-ops.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_SMP_OPS_H
-#define __ASM_SH_SMP_OPS_H
-
-struct plat_smp_ops {
-	void (*smp_setup)(void);
-	unsigned int (*smp_processor_id)(void);
-	void (*prepare_cpus)(unsigned int max_cpus);
-	void (*start_cpu)(unsigned int cpu, unsigned long entry_point);
-	void (*send_ipi)(unsigned int cpu, unsigned int message);
-	int (*cpu_disable)(unsigned int cpu);
-	void (*cpu_die)(unsigned int cpu);
-	void (*play_dead)(void);
-};
-
-extern struct plat_smp_ops *mp_ops;
-extern struct plat_smp_ops shx3_smp_ops;
-
-#ifdef CONFIG_SMP
-
-static inline void plat_smp_setup(void)
-{
-	BUG_ON(!mp_ops);
-	mp_ops->smp_setup();
-}
-
-static inline void play_dead(void)
-{
-	mp_ops->play_dead();
-}
-
-extern void register_smp_ops(struct plat_smp_ops *ops);
-
-#else
-
-static inline void plat_smp_setup(void)
-{
-	/* UP, nothing to do ... */
-}
-
-static inline void register_smp_ops(struct plat_smp_ops *ops)
-{
-}
-
-static inline void play_dead(void)
-{
-	BUG();
-}
-
-#endif /* CONFIG_SMP */
-
-#endif /* __ASM_SH_SMP_OPS_H */
diff --git a/arch/sh/include/asm/smp.h b/arch/sh/include/asm/smp.h
deleted file mode 100644
index 199381f77293c7..00000000000000
--- a/arch/sh/include/asm/smp.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_SMP_H
-#define __ASM_SH_SMP_H
-
-#include <linux/bitops.h>
-#include <linux/cpumask.h>
-#include <asm/smp-ops.h>
-
-#ifdef CONFIG_SMP
-
-#include <linux/atomic.h>
-#include <asm/current.h>
-#include <asm/percpu.h>
-
-#define raw_smp_processor_id()	(current_thread_info()->cpu)
-
-/* Map from cpu id to sequential logical cpu number. */
-extern int __cpu_number_map[NR_CPUS];
-#define cpu_number_map(cpu)  __cpu_number_map[cpu]
-
-/* The reverse map from sequential logical cpu number to cpu id.  */
-extern int __cpu_logical_map[NR_CPUS];
-#define cpu_logical_map(cpu)  __cpu_logical_map[cpu]
-
-enum {
-	SMP_MSG_FUNCTION,
-	SMP_MSG_RESCHEDULE,
-	SMP_MSG_FUNCTION_SINGLE,
-	SMP_MSG_TIMER,
-
-	SMP_MSG_NR,	/* must be last */
-};
-
-DECLARE_PER_CPU(int, cpu_state);
-
-void smp_message_recv(unsigned int msg);
-
-void arch_send_call_function_single_ipi(int cpu);
-void arch_send_call_function_ipi_mask(const struct cpumask *mask);
-
-void native_play_dead(void);
-void native_cpu_die(unsigned int cpu);
-int native_cpu_disable(unsigned int cpu);
-
-#ifdef CONFIG_HOTPLUG_CPU
-void play_dead_common(void);
-extern int __cpu_disable(void);
-
-static inline void __cpu_die(unsigned int cpu)
-{
-	extern struct plat_smp_ops *mp_ops;     /* private */
-
-	mp_ops->cpu_die(cpu);
-}
-#endif
-
-static inline int hard_smp_processor_id(void)
-{
-	extern struct plat_smp_ops *mp_ops;	/* private */
-
-	if (!mp_ops)
-		return 0;	/* boot CPU */
-
-	return mp_ops->smp_processor_id();
-}
-
-struct of_cpu_method {
-	const char *method;
-	struct plat_smp_ops *ops;
-};
-
-#define CPU_METHOD_OF_DECLARE(name, _method, _ops)			\
-	static const struct of_cpu_method __cpu_method_of_table_##name	\
-		__used __section("__cpu_method_of_table")		\
-		= { .method = _method, .ops = _ops }
-
-#else
-
-#define hard_smp_processor_id()	(0)
-
-#endif /* CONFIG_SMP */
-
-#endif /* __ASM_SH_SMP_H */
diff --git a/arch/sh/include/asm/sparsemem.h b/arch/sh/include/asm/sparsemem.h
deleted file mode 100644
index 4703cbe2384481..00000000000000
--- a/arch/sh/include/asm/sparsemem.h
+++ /dev/null
@@ -1,12 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_SPARSEMEM_H
-#define __ASM_SH_SPARSEMEM_H
-
-/*
- * SECTION_SIZE_BITS		2^N: how big each section will be
- * MAX_PHYSMEM_BITS		2^N: how much physical address space we have
- */
-#define SECTION_SIZE_BITS	26
-#define MAX_PHYSMEM_BITS	32
-
-#endif /* __ASM_SH_SPARSEMEM_H */
diff --git a/arch/sh/include/asm/spi.h b/arch/sh/include/asm/spi.h
deleted file mode 100644
index 6780753bd24914..00000000000000
--- a/arch/sh/include/asm/spi.h
+++ /dev/null
@@ -1,14 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SPI_H__
-#define __ASM_SPI_H__
-
-struct sh_spi_info;
-
-struct sh_spi_info {
-	int			 bus_num;
-	int			 num_chipselect;
-
-	void (*chip_select)(struct sh_spi_info *spi, int cs, int state);
-};
-
-#endif /* __ASM_SPI_H__ */
diff --git a/arch/sh/include/asm/spinlock-cas.h b/arch/sh/include/asm/spinlock-cas.h
deleted file mode 100644
index 3d49985ebf41c9..00000000000000
--- a/arch/sh/include/asm/spinlock-cas.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/spinlock-cas.h
- *
- * Copyright (C) 2015 SEI
- */
-#ifndef __ASM_SH_SPINLOCK_CAS_H
-#define __ASM_SH_SPINLOCK_CAS_H
-
-#include <asm/barrier.h>
-#include <asm/processor.h>
-
-static inline unsigned __sl_cas(volatile unsigned *p, unsigned old, unsigned new)
-{
-	__asm__ __volatile__("cas.l %1,%0,@r0"
-		: "+r"(new)
-		: "r"(old), "z"(p)
-		: "t", "memory" );
-	return new;
-}
-
-/*
- * Your basic SMP spinlocks, allowing only a single CPU anywhere
- */
-
-#define arch_spin_is_locked(x)		((x)->lock <= 0)
-
-static inline void arch_spin_lock(arch_spinlock_t *lock)
-{
-	while (!__sl_cas(&lock->lock, 1, 0));
-}
-
-static inline void arch_spin_unlock(arch_spinlock_t *lock)
-{
-	__sl_cas(&lock->lock, 0, 1);
-}
-
-static inline int arch_spin_trylock(arch_spinlock_t *lock)
-{
-	return __sl_cas(&lock->lock, 1, 0);
-}
-
-/*
- * Read-write spinlocks, allowing multiple readers but only one writer.
- *
- * NOTE! it is quite common to have readers in interrupts but no interrupt
- * writers. For those circumstances we can "mix" irq-safe locks - any writer
- * needs to get a irq-safe write-lock, but readers can get non-irqsafe
- * read-locks.
- */
-
-static inline void arch_read_lock(arch_rwlock_t *rw)
-{
-	unsigned old;
-	do old = rw->lock;
-	while (!old || __sl_cas(&rw->lock, old, old-1) != old);
-}
-
-static inline void arch_read_unlock(arch_rwlock_t *rw)
-{
-	unsigned old;
-	do old = rw->lock;
-	while (__sl_cas(&rw->lock, old, old+1) != old);
-}
-
-static inline void arch_write_lock(arch_rwlock_t *rw)
-{
-	while (__sl_cas(&rw->lock, RW_LOCK_BIAS, 0) != RW_LOCK_BIAS);
-}
-
-static inline void arch_write_unlock(arch_rwlock_t *rw)
-{
-	__sl_cas(&rw->lock, 0, RW_LOCK_BIAS);
-}
-
-static inline int arch_read_trylock(arch_rwlock_t *rw)
-{
-	unsigned old;
-	do old = rw->lock;
-	while (old && __sl_cas(&rw->lock, old, old-1) != old);
-	return !!old;
-}
-
-static inline int arch_write_trylock(arch_rwlock_t *rw)
-{
-	return __sl_cas(&rw->lock, RW_LOCK_BIAS, 0) == RW_LOCK_BIAS;
-}
-
-#endif /* __ASM_SH_SPINLOCK_CAS_H */
diff --git a/arch/sh/include/asm/spinlock-llsc.h b/arch/sh/include/asm/spinlock-llsc.h
deleted file mode 100644
index 7fd929cd2e7a08..00000000000000
--- a/arch/sh/include/asm/spinlock-llsc.h
+++ /dev/null
@@ -1,198 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/spinlock-llsc.h
- *
- * Copyright (C) 2002, 2003 Paul Mundt
- * Copyright (C) 2006, 2007 Akio Idehara
- */
-#ifndef __ASM_SH_SPINLOCK_LLSC_H
-#define __ASM_SH_SPINLOCK_LLSC_H
-
-#include <asm/barrier.h>
-#include <asm/processor.h>
-
-/*
- * Your basic SMP spinlocks, allowing only a single CPU anywhere
- */
-
-#define arch_spin_is_locked(x)		((x)->lock <= 0)
-
-/*
- * Simple spin lock operations.  There are two variants, one clears IRQ's
- * on the local processor, one does not.
- *
- * We make no fairness assumptions.  They have a cost.
- */
-static inline void arch_spin_lock(arch_spinlock_t *lock)
-{
-	unsigned long tmp;
-	unsigned long oldval;
-
-	__asm__ __volatile__ (
-		"1:						\n\t"
-		"movli.l	@%2, %0	! arch_spin_lock	\n\t"
-		"mov		%0, %1				\n\t"
-		"mov		#0, %0				\n\t"
-		"movco.l	%0, @%2				\n\t"
-		"bf		1b				\n\t"
-		"cmp/pl		%1				\n\t"
-		"bf		1b				\n\t"
-		: "=&z" (tmp), "=&r" (oldval)
-		: "r" (&lock->lock)
-		: "t", "memory"
-	);
-}
-
-static inline void arch_spin_unlock(arch_spinlock_t *lock)
-{
-	unsigned long tmp;
-
-	/* This could be optimised with ARCH_HAS_MMIOWB */
-	mmiowb();
-	__asm__ __volatile__ (
-		"mov		#1, %0 ! arch_spin_unlock	\n\t"
-		"mov.l		%0, @%1				\n\t"
-		: "=&z" (tmp)
-		: "r" (&lock->lock)
-		: "t", "memory"
-	);
-}
-
-static inline int arch_spin_trylock(arch_spinlock_t *lock)
-{
-	unsigned long tmp, oldval;
-
-	__asm__ __volatile__ (
-		"1:						\n\t"
-		"movli.l	@%2, %0	! arch_spin_trylock	\n\t"
-		"mov		%0, %1				\n\t"
-		"mov		#0, %0				\n\t"
-		"movco.l	%0, @%2				\n\t"
-		"bf		1b				\n\t"
-		"synco						\n\t"
-		: "=&z" (tmp), "=&r" (oldval)
-		: "r" (&lock->lock)
-		: "t", "memory"
-	);
-
-	return oldval;
-}
-
-/*
- * Read-write spinlocks, allowing multiple readers but only one writer.
- *
- * NOTE! it is quite common to have readers in interrupts but no interrupt
- * writers. For those circumstances we can "mix" irq-safe locks - any writer
- * needs to get a irq-safe write-lock, but readers can get non-irqsafe
- * read-locks.
- */
-
-static inline void arch_read_lock(arch_rwlock_t *rw)
-{
-	unsigned long tmp;
-
-	__asm__ __volatile__ (
-		"1:						\n\t"
-		"movli.l	@%1, %0	! arch_read_lock	\n\t"
-		"cmp/pl		%0				\n\t"
-		"bf		1b				\n\t"
-		"add		#-1, %0				\n\t"
-		"movco.l	%0, @%1				\n\t"
-		"bf		1b				\n\t"
-		: "=&z" (tmp)
-		: "r" (&rw->lock)
-		: "t", "memory"
-	);
-}
-
-static inline void arch_read_unlock(arch_rwlock_t *rw)
-{
-	unsigned long tmp;
-
-	__asm__ __volatile__ (
-		"1:						\n\t"
-		"movli.l	@%1, %0	! arch_read_unlock	\n\t"
-		"add		#1, %0				\n\t"
-		"movco.l	%0, @%1				\n\t"
-		"bf		1b				\n\t"
-		: "=&z" (tmp)
-		: "r" (&rw->lock)
-		: "t", "memory"
-	);
-}
-
-static inline void arch_write_lock(arch_rwlock_t *rw)
-{
-	unsigned long tmp;
-
-	__asm__ __volatile__ (
-		"1:						\n\t"
-		"movli.l	@%1, %0	! arch_write_lock	\n\t"
-		"cmp/hs		%2, %0				\n\t"
-		"bf		1b				\n\t"
-		"sub		%2, %0				\n\t"
-		"movco.l	%0, @%1				\n\t"
-		"bf		1b				\n\t"
-		: "=&z" (tmp)
-		: "r" (&rw->lock), "r" (RW_LOCK_BIAS)
-		: "t", "memory"
-	);
-}
-
-static inline void arch_write_unlock(arch_rwlock_t *rw)
-{
-	__asm__ __volatile__ (
-		"mov.l		%1, @%0 ! arch_write_unlock	\n\t"
-		:
-		: "r" (&rw->lock), "r" (RW_LOCK_BIAS)
-		: "t", "memory"
-	);
-}
-
-static inline int arch_read_trylock(arch_rwlock_t *rw)
-{
-	unsigned long tmp, oldval;
-
-	__asm__ __volatile__ (
-		"1:						\n\t"
-		"movli.l	@%2, %0	! arch_read_trylock	\n\t"
-		"mov		%0, %1				\n\t"
-		"cmp/pl		%0				\n\t"
-		"bf		2f				\n\t"
-		"add		#-1, %0				\n\t"
-		"movco.l	%0, @%2				\n\t"
-		"bf		1b				\n\t"
-		"2:						\n\t"
-		"synco						\n\t"
-		: "=&z" (tmp), "=&r" (oldval)
-		: "r" (&rw->lock)
-		: "t", "memory"
-	);
-
-	return (oldval > 0);
-}
-
-static inline int arch_write_trylock(arch_rwlock_t *rw)
-{
-	unsigned long tmp, oldval;
-
-	__asm__ __volatile__ (
-		"1:						\n\t"
-		"movli.l	@%2, %0	! arch_write_trylock	\n\t"
-		"mov		%0, %1				\n\t"
-		"cmp/hs		%3, %0				\n\t"
-		"bf		2f				\n\t"
-		"sub		%3, %0				\n\t"
-		"2:						\n\t"
-		"movco.l	%0, @%2				\n\t"
-		"bf		1b				\n\t"
-		"synco						\n\t"
-		: "=&z" (tmp), "=&r" (oldval)
-		: "r" (&rw->lock), "r" (RW_LOCK_BIAS)
-		: "t", "memory"
-	);
-
-	return (oldval > (RW_LOCK_BIAS - 1));
-}
-
-#endif /* __ASM_SH_SPINLOCK_LLSC_H */
diff --git a/arch/sh/include/asm/spinlock.h b/arch/sh/include/asm/spinlock.h
deleted file mode 100644
index fa6801f63551ce..00000000000000
--- a/arch/sh/include/asm/spinlock.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/spinlock.h
- *
- * Copyright (C) 2002, 2003 Paul Mundt
- * Copyright (C) 2006, 2007 Akio Idehara
- */
-#ifndef __ASM_SH_SPINLOCK_H
-#define __ASM_SH_SPINLOCK_H
-
-#if defined(CONFIG_CPU_SH4A)
-#include <asm/spinlock-llsc.h>
-#elif defined(CONFIG_CPU_J2)
-#include <asm/spinlock-cas.h>
-#else
-#error "The configured cpu type does not support spinlocks"
-#endif
-
-#endif /* __ASM_SH_SPINLOCK_H */
diff --git a/arch/sh/include/asm/spinlock_types.h b/arch/sh/include/asm/spinlock_types.h
deleted file mode 100644
index 907bda4b1619a9..00000000000000
--- a/arch/sh/include/asm/spinlock_types.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_SPINLOCK_TYPES_H
-#define __ASM_SH_SPINLOCK_TYPES_H
-
-#ifndef __LINUX_SPINLOCK_TYPES_RAW_H
-# error "please don't include this file directly"
-#endif
-
-typedef struct {
-	volatile unsigned int lock;
-} arch_spinlock_t;
-
-#define __ARCH_SPIN_LOCK_UNLOCKED		{ 1 }
-
-typedef struct {
-	volatile unsigned int lock;
-} arch_rwlock_t;
-
-#define RW_LOCK_BIAS			0x01000000
-#define __ARCH_RW_LOCK_UNLOCKED		{ RW_LOCK_BIAS }
-
-#endif
diff --git a/arch/sh/include/asm/sram.h b/arch/sh/include/asm/sram.h
deleted file mode 100644
index c125cf2198683e..00000000000000
--- a/arch/sh/include/asm/sram.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SRAM_H
-#define __ASM_SRAM_H
-
-#ifdef CONFIG_HAVE_SRAM_POOL
-
-#include <linux/spinlock.h>
-#include <linux/genalloc.h>
-
-/* arch/sh/mm/sram.c */
-extern struct gen_pool *sram_pool;
-
-static inline unsigned long sram_alloc(size_t len)
-{
-	if (!sram_pool)
-		return 0UL;
-
-	return gen_pool_alloc(sram_pool, len);
-}
-
-static inline void sram_free(unsigned long addr, size_t len)
-{
-	return gen_pool_free(sram_pool, addr, len);
-}
-
-#else
-
-static inline unsigned long sram_alloc(size_t len)
-{
-	return 0;
-}
-
-static inline void sram_free(unsigned long addr, size_t len)
-{
-}
-
-#endif /* CONFIG_HAVE_SRAM_POOL */
-
-#endif /* __ASM_SRAM_H */
diff --git a/arch/sh/include/asm/stackprotector.h b/arch/sh/include/asm/stackprotector.h
deleted file mode 100644
index 665dafac376f8d..00000000000000
--- a/arch/sh/include/asm/stackprotector.h
+++ /dev/null
@@ -1,21 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_STACKPROTECTOR_H
-#define __ASM_SH_STACKPROTECTOR_H
-
-extern unsigned long __stack_chk_guard;
-
-/*
- * Initialize the stackprotector canary value.
- *
- * NOTE: this must only be called from functions that never return,
- * and it must always be inlined.
- */
-static __always_inline void boot_init_stack_canary(void)
-{
-	unsigned long canary = get_random_canary();
-
-	current->stack_canary = canary;
-	__stack_chk_guard = current->stack_canary;
-}
-
-#endif /* __ASM_SH_STACKPROTECTOR_H */
diff --git a/arch/sh/include/asm/stacktrace.h b/arch/sh/include/asm/stacktrace.h
deleted file mode 100644
index 4f98cdc64ec59b..00000000000000
--- a/arch/sh/include/asm/stacktrace.h
+++ /dev/null
@@ -1,21 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (C) 2009  Matt Fleming
- *
- * Based on:
- *	The x86 implementation - arch/x86/include/asm/stacktrace.h
- */
-#ifndef _ASM_SH_STACKTRACE_H
-#define _ASM_SH_STACKTRACE_H
-
-/* Generic stack tracer with callbacks */
-
-struct stacktrace_ops {
-	void (*address)(void *data, unsigned long address, int reliable);
-};
-
-void dump_trace(struct task_struct *tsk, struct pt_regs *regs,
-		unsigned long *stack,
-		const struct stacktrace_ops *ops, void *data);
-
-#endif /* _ASM_SH_STACKTRACE_H */
diff --git a/arch/sh/include/asm/string.h b/arch/sh/include/asm/string.h
deleted file mode 100644
index 0f6331ec28ed4e..00000000000000
--- a/arch/sh/include/asm/string.h
+++ /dev/null
@@ -1,2 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <asm/string_32.h>
diff --git a/arch/sh/include/asm/string_32.h b/arch/sh/include/asm/string_32.h
deleted file mode 100644
index a276b193d3b4fd..00000000000000
--- a/arch/sh/include/asm/string_32.h
+++ /dev/null
@@ -1,102 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_STRING_H
-#define __ASM_SH_STRING_H
-
-/*
- * Copyright (C) 1999 Niibe Yutaka
- * But consider these trivial functions to be public domain.
- */
-
-#define __HAVE_ARCH_STRCPY
-static inline char *strcpy(char *__dest, const char *__src)
-{
-	register char *__xdest = __dest;
-	unsigned long __dummy;
-
-	__asm__ __volatile__("1:\n\t"
-			     "mov.b	@%1+, %2\n\t"
-			     "mov.b	%2, @%0\n\t"
-			     "cmp/eq	#0, %2\n\t"
-			     "bf/s	1b\n\t"
-			     " add	#1, %0\n\t"
-			     : "=r" (__dest), "=r" (__src), "=&z" (__dummy)
-			     : "0" (__dest), "1" (__src)
-			     : "memory", "t");
-
-	return __xdest;
-}
-
-#define __HAVE_ARCH_STRCMP
-static inline int strcmp(const char *__cs, const char *__ct)
-{
-	register int __res;
-	unsigned long __dummy;
-
-	__asm__ __volatile__(
-		"mov.b	@%1+, %3\n"
-		"1:\n\t"
-		"mov.b	@%0+, %2\n\t"
-		"cmp/eq #0, %3\n\t"
-		"bt	2f\n\t"
-		"cmp/eq %2, %3\n\t"
-		"bt/s	1b\n\t"
-		" mov.b	@%1+, %3\n\t"
-		"add	#-2, %1\n\t"
-		"mov.b	@%1, %3\n\t"
-		"sub	%3, %2\n"
-		"2:"
-		: "=r" (__cs), "=r" (__ct), "=&r" (__res), "=&z" (__dummy)
-		: "0" (__cs), "1" (__ct)
-		: "t");
-
-	return __res;
-}
-
-#define __HAVE_ARCH_STRNCMP
-static inline int strncmp(const char *__cs, const char *__ct, size_t __n)
-{
-	register int __res;
-	unsigned long __dummy;
-
-	if (__n == 0)
-		return 0;
-
-	__asm__ __volatile__(
-		"mov.b	@%1+, %3\n"
-		"1:\n\t"
-		"mov.b	@%0+, %2\n\t"
-		"cmp/eq %6, %0\n\t"
-		"bt/s	2f\n\t"
-		" cmp/eq #0, %3\n\t"
-		"bt/s	3f\n\t"
-		" cmp/eq %3, %2\n\t"
-		"bt/s	1b\n\t"
-		" mov.b	@%1+, %3\n\t"
-		"add	#-2, %1\n\t"
-		"mov.b	@%1, %3\n"
-		"2:\n\t"
-		"sub	%3, %2\n"
-		"3:"
-		:"=r" (__cs), "=r" (__ct), "=&r" (__res), "=&z" (__dummy)
-		: "0" (__cs), "1" (__ct), "r" (__cs+__n)
-		: "t");
-
-	return __res;
-}
-
-#define __HAVE_ARCH_MEMSET
-extern void *memset(void *__s, int __c, size_t __count);
-
-#define __HAVE_ARCH_MEMCPY
-extern void *memcpy(void *__to, __const__ void *__from, size_t __n);
-
-#define __HAVE_ARCH_MEMMOVE
-extern void *memmove(void *__dest, __const__ void *__src, size_t __n);
-
-#define __HAVE_ARCH_MEMCHR
-extern void *memchr(const void *__s, int __c, size_t __n);
-
-#define __HAVE_ARCH_STRLEN
-extern size_t strlen(const char *);
-
-#endif /* __ASM_SH_STRING_H */
diff --git a/arch/sh/include/asm/suspend.h b/arch/sh/include/asm/suspend.h
deleted file mode 100644
index 47db17520261e8..00000000000000
--- a/arch/sh/include/asm/suspend.h
+++ /dev/null
@@ -1,97 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _ASM_SH_SUSPEND_H
-#define _ASM_SH_SUSPEND_H
-
-#ifndef __ASSEMBLY__
-#include <linux/notifier.h>
-
-#include <asm/ptrace.h>
-
-struct swsusp_arch_regs {
-	struct pt_regs user_regs;
-	unsigned long bank1_regs[8];
-};
-
-void sh_mobile_call_standby(unsigned long mode);
-
-#ifdef CONFIG_CPU_IDLE
-int sh_mobile_setup_cpuidle(void);
-#else
-static inline int sh_mobile_setup_cpuidle(void) { return 0; }
-#endif
-
-/* notifier chains for pre/post sleep hooks */
-extern struct atomic_notifier_head sh_mobile_pre_sleep_notifier_list;
-extern struct atomic_notifier_head sh_mobile_post_sleep_notifier_list;
-
-/* priority levels for notifiers */
-#define SH_MOBILE_SLEEP_BOARD	0
-#define SH_MOBILE_SLEEP_CPU	1
-#define SH_MOBILE_PRE(x)	(x)
-#define SH_MOBILE_POST(x)	(-(x))
-
-/* board code registration function for self-refresh assembly snippets */
-void sh_mobile_register_self_refresh(unsigned long flags,
-				     void *pre_start, void *pre_end,
-				     void *post_start, void *post_end);
-
-/* register structure for address/data information */
-struct sh_sleep_regs {
-	unsigned long stbcr;
-	unsigned long bar;
-
-	/* MMU */
-	unsigned long pteh;
-	unsigned long ptel;
-	unsigned long ttb;
-	unsigned long tea;
-	unsigned long mmucr;
-	unsigned long ptea;
-	unsigned long pascr;
-	unsigned long irmcr;
-
-	/* Cache */
-	unsigned long ccr;
-	unsigned long ramcr;
-};
-
-/* data area for low-level sleep code */
-struct sh_sleep_data {
-	/* current sleep mode (SUSP_SH_...) */
-	unsigned long mode;
-
-	/* addresses of board specific self-refresh snippets */
-	unsigned long sf_pre;
-	unsigned long sf_post;
-
-	/* address of resume code */
-	unsigned long resume;
-
-	/* register state saved and restored by the assembly code */
-	unsigned long vbr;
-	unsigned long spc;
-	unsigned long sr;
-	unsigned long sp;
-
-	/* structure for keeping register addresses */
-	struct sh_sleep_regs addr;
-
-	/* structure for saving/restoring register state */
-	struct sh_sleep_regs data;
-};
-
-/* a bitmap of supported sleep modes (SUSP_SH..) */
-extern unsigned long sh_mobile_sleep_supported;
-
-#endif
-
-/* flags passed to assembly suspend code */
-#define SUSP_SH_SLEEP		(1 << 0) /* Regular sleep mode */
-#define SUSP_SH_STANDBY		(1 << 1) /* SH-Mobile Software standby mode */
-#define SUSP_SH_RSTANDBY	(1 << 2) /* SH-Mobile R-standby mode */
-#define SUSP_SH_USTANDBY	(1 << 3) /* SH-Mobile U-standby mode */
-#define SUSP_SH_SF		(1 << 4) /* Enable self-refresh */
-#define SUSP_SH_MMU		(1 << 5) /* Save/restore MMU and cache */
-#define SUSP_SH_REGS		(1 << 6) /* Save/restore registers */
-
-#endif /* _ASM_SH_SUSPEND_H */
diff --git a/arch/sh/include/asm/switch_to.h b/arch/sh/include/asm/switch_to.h
deleted file mode 100644
index bd139bcdeec142..00000000000000
--- a/arch/sh/include/asm/switch_to.h
+++ /dev/null
@@ -1,7 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * Copyright (C) 2000, 2001  Paolo Alberelli
- * Copyright (C) 2003  Paul Mundt
- * Copyright (C) 2004  Richard Curnow
- */
-#include <asm/switch_to_32.h>
diff --git a/arch/sh/include/asm/switch_to_32.h b/arch/sh/include/asm/switch_to_32.h
deleted file mode 100644
index 9c93fb91adb4aa..00000000000000
--- a/arch/sh/include/asm/switch_to_32.h
+++ /dev/null
@@ -1,131 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_SWITCH_TO_32_H
-#define __ASM_SH_SWITCH_TO_32_H
-
-#ifdef CONFIG_SH_DSP
-
-#define is_dsp_enabled(tsk)						\
-	(!!(tsk->thread.dsp_status.status & SR_DSP))
-
-#define __restore_dsp(tsk)						\
-do {									\
-	register u32 *__ts2 __asm__ ("r2") =				\
-			(u32 *)&tsk->thread.dsp_status;			\
-	__asm__ __volatile__ (						\
-		".balign 4\n\t"						\
-		"movs.l	@r2+, a0\n\t"					\
-		"movs.l	@r2+, a1\n\t"					\
-		"movs.l	@r2+, a0g\n\t"					\
-		"movs.l	@r2+, a1g\n\t"					\
-		"movs.l	@r2+, m0\n\t"					\
-		"movs.l	@r2+, m1\n\t"					\
-		"movs.l	@r2+, x0\n\t"					\
-		"movs.l	@r2+, x1\n\t"					\
-		"movs.l	@r2+, y0\n\t"					\
-		"movs.l	@r2+, y1\n\t"					\
-		"lds.l	@r2+, dsr\n\t"					\
-		"ldc.l	@r2+, rs\n\t"					\
-		"ldc.l	@r2+, re\n\t"					\
-		"ldc.l	@r2+, mod\n\t"					\
-		: : "r" (__ts2));					\
-} while (0)
-
-#define __save_dsp(tsk)							\
-do {									\
-	register u32 *__ts2 __asm__ ("r2") =				\
-			(u32 *)&tsk->thread.dsp_status + 14;		\
-									\
-	__asm__ __volatile__ (						\
-		".balign 4\n\t"						\
-		"stc.l	mod, @-r2\n\t"					\
-		"stc.l	re, @-r2\n\t"					\
-		"stc.l	rs, @-r2\n\t"					\
-		"sts.l	dsr, @-r2\n\t"					\
-		"movs.l	y1, @-r2\n\t"					\
-		"movs.l	y0, @-r2\n\t"					\
-		"movs.l	x1, @-r2\n\t"					\
-		"movs.l	x0, @-r2\n\t"					\
-		"movs.l	m1, @-r2\n\t"					\
-		"movs.l	m0, @-r2\n\t"					\
-		"movs.l	a1g, @-r2\n\t"					\
-		"movs.l	a0g, @-r2\n\t"					\
-		"movs.l	a1, @-r2\n\t"					\
-		"movs.l	a0, @-r2\n\t"					\
-		: : "r" (__ts2));					\
-} while (0)
-
-#else
-
-#define is_dsp_enabled(tsk)	(0)
-#define __save_dsp(tsk)		do { } while (0)
-#define __restore_dsp(tsk)	do { } while (0)
-#endif
-
-struct task_struct *__switch_to(struct task_struct *prev,
-				struct task_struct *next);
-
-/*
- *	switch_to() should switch tasks to task nr n, first
- */
-#define switch_to(prev, next, last)				\
-do {								\
-	register u32 *__ts1 __asm__ ("r1");			\
-	register u32 *__ts2 __asm__ ("r2");			\
-	register u32 *__ts4 __asm__ ("r4");			\
-	register u32 *__ts5 __asm__ ("r5");			\
-	register u32 *__ts6 __asm__ ("r6");			\
-	register u32 __ts7 __asm__ ("r7");			\
-	struct task_struct *__last;				\
-								\
-	if (is_dsp_enabled(prev))				\
-		__save_dsp(prev);				\
-	if (is_dsp_enabled(next))				\
-		__restore_dsp(next);				\
-								\
-	__ts1 = (u32 *)&prev->thread.sp;			\
-	__ts2 = (u32 *)&prev->thread.pc;			\
-	__ts4 = (u32 *)prev;					\
-	__ts5 = (u32 *)next;					\
-	__ts6 = (u32 *)&next->thread.sp;			\
-	__ts7 = next->thread.pc;				\
-								\
-	__asm__ __volatile__ (					\
-		".balign 4\n\t"					\
-		"stc.l	gbr, @-r15\n\t"				\
-		"sts.l	pr, @-r15\n\t"				\
-		"mov.l	r8, @-r15\n\t"				\
-		"mov.l	r9, @-r15\n\t"				\
-		"mov.l	r10, @-r15\n\t"				\
-		"mov.l	r11, @-r15\n\t"				\
-		"mov.l	r12, @-r15\n\t"				\
-		"mov.l	r13, @-r15\n\t"				\
-		"mov.l	r14, @-r15\n\t"				\
-		"mov.l	r15, @r1\t! save SP\n\t"		\
-		"mov.l	@r6, r15\t! change to new stack\n\t"	\
-		"mova	1f, %0\n\t"				\
-		"mov.l	%0, @r2\t! save PC\n\t"			\
-		"mov.l	2f, %0\n\t"				\
-		"jmp	@%0\t! call __switch_to\n\t"		\
-		" lds	r7, pr\t!  with return to new PC\n\t"	\
-		".balign	4\n"				\
-		"2:\n\t"					\
-		".long	__switch_to\n"				\
-		"1:\n\t"					\
-		"mov.l	@r15+, r14\n\t"				\
-		"mov.l	@r15+, r13\n\t"				\
-		"mov.l	@r15+, r12\n\t"				\
-		"mov.l	@r15+, r11\n\t"				\
-		"mov.l	@r15+, r10\n\t"				\
-		"mov.l	@r15+, r9\n\t"				\
-		"mov.l	@r15+, r8\n\t"				\
-		"lds.l	@r15+, pr\n\t"				\
-		"ldc.l	@r15+, gbr\n\t"				\
-		: "=z" (__last)					\
-		: "r" (__ts1), "r" (__ts2), "r" (__ts4),	\
-		  "r" (__ts5), "r" (__ts6), "r" (__ts7)		\
-		: "r3", "t");					\
-								\
-	last = __last;						\
-} while (0)
-
-#endif /* __ASM_SH_SWITCH_TO_32_H */
diff --git a/arch/sh/include/asm/syscall.h b/arch/sh/include/asm/syscall.h
deleted file mode 100644
index 570699eb0e58ae..00000000000000
--- a/arch/sh/include/asm/syscall.h
+++ /dev/null
@@ -1,9 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_SYSCALL_H
-#define __ASM_SH_SYSCALL_H
-
-extern const unsigned long sys_call_table[];
-
-#include <asm/syscall_32.h>
-
-#endif /* __ASM_SH_SYSCALL_H */
diff --git a/arch/sh/include/asm/syscall_32.h b/arch/sh/include/asm/syscall_32.h
deleted file mode 100644
index d87738eebe30cb..00000000000000
--- a/arch/sh/include/asm/syscall_32.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_SYSCALL_32_H
-#define __ASM_SH_SYSCALL_32_H
-
-#include <uapi/linux/audit.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/err.h>
-#include <asm/ptrace.h>
-
-/* The system call number is given by the user in R3 */
-static inline long syscall_get_nr(struct task_struct *task,
-				  struct pt_regs *regs)
-{
-	return (regs->tra >= 0) ? regs->regs[3] : -1L;
-}
-
-static inline void syscall_rollback(struct task_struct *task,
-				    struct pt_regs *regs)
-{
-	/*
-	 * XXX: This needs some thought. On SH we don't
-	 * save away the original r0 value anywhere.
-	 */
-}
-
-static inline long syscall_get_error(struct task_struct *task,
-				     struct pt_regs *regs)
-{
-	return IS_ERR_VALUE(regs->regs[0]) ? regs->regs[0] : 0;
-}
-
-static inline long syscall_get_return_value(struct task_struct *task,
-					    struct pt_regs *regs)
-{
-	return regs->regs[0];
-}
-
-static inline void syscall_set_return_value(struct task_struct *task,
-					    struct pt_regs *regs,
-					    int error, long val)
-{
-	regs->regs[0] = (long) error ?: val;
-}
-
-static inline void syscall_get_arguments(struct task_struct *task,
-					 struct pt_regs *regs,
-					 unsigned long *args)
-{
-
-	/* Argument pattern is: R4, R5, R6, R7, R0, R1 */
-	args[5] = regs->regs[1];
-	args[4] = regs->regs[0];
-	args[3] = regs->regs[7];
-	args[2] = regs->regs[6];
-	args[1] = regs->regs[5];
-	args[0] = regs->regs[4];
-}
-
-static inline int syscall_get_arch(struct task_struct *task)
-{
-	int arch = AUDIT_ARCH_SH;
-
-#ifdef CONFIG_CPU_LITTLE_ENDIAN
-	arch |= __AUDIT_ARCH_LE;
-#endif
-	return arch;
-}
-#endif /* __ASM_SH_SYSCALL_32_H */
diff --git a/arch/sh/include/asm/syscalls.h b/arch/sh/include/asm/syscalls.h
deleted file mode 100644
index 387105316d2882..00000000000000
--- a/arch/sh/include/asm/syscalls.h
+++ /dev/null
@@ -1,14 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_SYSCALLS_H
-#define __ASM_SH_SYSCALLS_H
-
-asmlinkage int old_mmap(unsigned long addr, unsigned long len,
-			unsigned long prot, unsigned long flags,
-			int fd, unsigned long off);
-asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,
-			  unsigned long prot, unsigned long flags,
-			  unsigned long fd, unsigned long pgoff);
-
-#include <asm/syscalls_32.h>
-
-#endif /* __ASM_SH_SYSCALLS_H */
diff --git a/arch/sh/include/asm/syscalls_32.h b/arch/sh/include/asm/syscalls_32.h
deleted file mode 100644
index 5c555b864fe092..00000000000000
--- a/arch/sh/include/asm/syscalls_32.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_SYSCALLS_32_H
-#define __ASM_SH_SYSCALLS_32_H
-
-#include <linux/compiler.h>
-#include <linux/linkage.h>
-#include <linux/types.h>
-
-struct pt_regs;
-
-asmlinkage int sys_sigreturn(void);
-asmlinkage int sys_rt_sigreturn(void);
-asmlinkage int sys_sh_pipe(void);
-asmlinkage ssize_t sys_pread_wrapper(unsigned int fd, char __user *buf,
-				     size_t count, long dummy, loff_t pos);
-asmlinkage ssize_t sys_pwrite_wrapper(unsigned int fd, const char __user *buf,
-				      size_t count, long dummy, loff_t pos);
-asmlinkage int sys_fadvise64_64_wrapper(int fd, u32 offset0, u32 offset1,
-					u32 len0, u32 len1, int advice);
-
-/* Misc syscall related bits */
-asmlinkage long do_syscall_trace_enter(struct pt_regs *regs);
-asmlinkage void do_syscall_trace_leave(struct pt_regs *regs);
-asmlinkage void do_notify_resume(struct pt_regs *regs, unsigned int save_r0,
-				 unsigned long thread_info_flags);
-
-#endif /* __ASM_SH_SYSCALLS_32_H */
diff --git a/arch/sh/include/asm/thread_info.h b/arch/sh/include/asm/thread_info.h
deleted file mode 100644
index 1400fbb8b423b9..00000000000000
--- a/arch/sh/include/asm/thread_info.h
+++ /dev/null
@@ -1,171 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_THREAD_INFO_H
-#define __ASM_SH_THREAD_INFO_H
-
-/* SuperH version
- * Copyright (C) 2002  Niibe Yutaka
- *
- * The copyright of original i386 version is:
- *
- *  Copyright (C) 2002  David Howells (dhowells@redhat.com)
- *  - Incorporating suggestions made by Linus Torvalds and Dave Miller
- */
-#include <asm/page.h>
-
-/*
- * Page fault error code bits
- */
-#define FAULT_CODE_WRITE	(1 << 0)	/* write access */
-#define FAULT_CODE_INITIAL	(1 << 1)	/* initial page write */
-#define FAULT_CODE_ITLB		(1 << 2)	/* ITLB miss */
-#define FAULT_CODE_PROT		(1 << 3)	/* protection fault */
-#define FAULT_CODE_USER		(1 << 4)	/* user-mode access */
-
-#ifndef __ASSEMBLY__
-#include <asm/processor.h>
-
-struct thread_info {
-	struct task_struct	*task;		/* main task structure */
-	unsigned long		flags;		/* low level flags */
-	__u32			status;		/* thread synchronous flags */
-	__u32			cpu;
-	int			preempt_count; /* 0 => preemptable, <0 => BUG */
-	unsigned long		previous_sp;	/* sp of previous stack in case
-						   of nested IRQ stacks */
-	__u8			supervisor_stack[];
-};
-
-#endif
-
-#if defined(CONFIG_4KSTACKS)
-#define THREAD_SHIFT	12
-#else
-#define THREAD_SHIFT	13
-#endif
-
-#define THREAD_SIZE	(1 << THREAD_SHIFT)
-#define STACK_WARN	(THREAD_SIZE >> 3)
-
-/*
- * macros/functions for gaining access to the thread information structure
- */
-#ifndef __ASSEMBLY__
-#define INIT_THREAD_INFO(tsk)			\
-{						\
-	.task		= &tsk,			\
-	.flags		= 0,			\
-	.status		= 0,			\
-	.cpu		= 0,			\
-	.preempt_count	= INIT_PREEMPT_COUNT,	\
-}
-
-/* how to get the current stack pointer from C */
-register unsigned long current_stack_pointer asm("r15") __used;
-
-/* how to get the thread information struct from C */
-static inline struct thread_info *current_thread_info(void)
-{
-	struct thread_info *ti;
-#if defined(CONFIG_CPU_HAS_SR_RB)
-	__asm__ __volatile__ ("stc	r7_bank, %0" : "=r" (ti));
-#else
-	unsigned long __dummy;
-
-	__asm__ __volatile__ (
-		"mov	r15, %0\n\t"
-		"and	%1, %0\n\t"
-		: "=&r" (ti), "=r" (__dummy)
-		: "1" (~(THREAD_SIZE - 1))
-		: "memory");
-#endif
-
-	return ti;
-}
-
-#define THREAD_SIZE_ORDER	(THREAD_SHIFT - PAGE_SHIFT)
-
-extern void arch_task_cache_init(void);
-extern int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src);
-extern void arch_release_task_struct(struct task_struct *tsk);
-extern void init_thread_xstate(void);
-
-#endif /* __ASSEMBLY__ */
-
-/*
- * Thread information flags
- *
- * - Limited to 24 bits, upper byte used for fault code encoding.
- *
- * - _TIF_ALLWORK_MASK and _TIF_WORK_MASK need to fit within 2 bytes, or
- *   we blow the tst immediate size constraints and need to fix up
- *   arch/sh/kernel/entry-common.S.
- */
-#define TIF_SYSCALL_TRACE	0	/* syscall trace active */
-#define TIF_SIGPENDING		1	/* signal pending */
-#define TIF_NEED_RESCHED	2	/* rescheduling necessary */
-#define TIF_NOTIFY_SIGNAL	3	/* signal notifications exist */
-#define TIF_SINGLESTEP		4	/* singlestepping active */
-#define TIF_SYSCALL_AUDIT	5	/* syscall auditing active */
-#define TIF_SECCOMP		6	/* secure computing */
-#define TIF_NOTIFY_RESUME	7	/* callback before returning to user */
-#define TIF_SYSCALL_TRACEPOINT	8	/* for ftrace syscall instrumentation */
-#define TIF_POLLING_NRFLAG	17	/* true if poll_idle() is polling TIF_NEED_RESCHED */
-#define TIF_MEMDIE		18	/* is terminating due to OOM killer */
-
-#define _TIF_SYSCALL_TRACE	(1 << TIF_SYSCALL_TRACE)
-#define _TIF_SIGPENDING		(1 << TIF_SIGPENDING)
-#define _TIF_NEED_RESCHED	(1 << TIF_NEED_RESCHED)
-#define _TIF_NOTIFY_SIGNAL	(1 << TIF_NOTIFY_SIGNAL)
-#define _TIF_SINGLESTEP		(1 << TIF_SINGLESTEP)
-#define _TIF_SYSCALL_AUDIT	(1 << TIF_SYSCALL_AUDIT)
-#define _TIF_SECCOMP		(1 << TIF_SECCOMP)
-#define _TIF_NOTIFY_RESUME	(1 << TIF_NOTIFY_RESUME)
-#define _TIF_SYSCALL_TRACEPOINT	(1 << TIF_SYSCALL_TRACEPOINT)
-#define _TIF_POLLING_NRFLAG	(1 << TIF_POLLING_NRFLAG)
-
-/* work to do in syscall trace */
-#define _TIF_WORK_SYSCALL_MASK	(_TIF_SYSCALL_TRACE | _TIF_SINGLESTEP | \
-				 _TIF_SYSCALL_AUDIT | _TIF_SECCOMP    | \
-				 _TIF_SYSCALL_TRACEPOINT)
-
-/* work to do on any return to u-space */
-#define _TIF_ALLWORK_MASK	(_TIF_SYSCALL_TRACE | _TIF_SIGPENDING      | \
-				 _TIF_NEED_RESCHED  | _TIF_SYSCALL_AUDIT   | \
-				 _TIF_SINGLESTEP    | _TIF_NOTIFY_RESUME   | \
-				 _TIF_SYSCALL_TRACEPOINT | _TIF_NOTIFY_SIGNAL)
-
-/* work to do on interrupt/exception return */
-#define _TIF_WORK_MASK		(_TIF_ALLWORK_MASK & ~(_TIF_SYSCALL_TRACE | \
-				 _TIF_SYSCALL_AUDIT | _TIF_SINGLESTEP))
-
-/*
- * Thread-synchronous status.
- *
- * This is different from the flags in that nobody else
- * ever touches our thread-synchronous status, so we don't
- * have to worry about atomic accesses.
- */
-#define TS_USEDFPU		0x0002	/* FPU used by this task this quantum */
-
-#ifndef __ASSEMBLY__
-
-#define TI_FLAG_FAULT_CODE_SHIFT	24
-
-/*
- * Additional thread flag encoding
- */
-static inline void set_thread_fault_code(unsigned int val)
-{
-	struct thread_info *ti = current_thread_info();
-	ti->flags = (ti->flags & (~0 >> (32 - TI_FLAG_FAULT_CODE_SHIFT)))
-		| (val << TI_FLAG_FAULT_CODE_SHIFT);
-}
-
-static inline unsigned int get_thread_fault_code(void)
-{
-	struct thread_info *ti = current_thread_info();
-	return ti->flags >> TI_FLAG_FAULT_CODE_SHIFT;
-}
-
-#endif	/* !__ASSEMBLY__ */
-#endif /* __ASM_SH_THREAD_INFO_H */
diff --git a/arch/sh/include/asm/timex.h b/arch/sh/include/asm/timex.h
deleted file mode 100644
index f53f95bf42887f..00000000000000
--- a/arch/sh/include/asm/timex.h
+++ /dev/null
@@ -1,24 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * linux/include/asm-sh/timex.h
- *
- * sh architecture timex specifications
- */
-#ifndef __ASM_SH_TIMEX_H
-#define __ASM_SH_TIMEX_H
-
-/*
- * Only parts using the legacy CPG code for their clock framework
- * implementation need to define their own Pclk value. If provided, this
- * can be used for accurately setting CLOCK_TICK_RATE, otherwise we
- * simply fall back on the i8253 PIT value.
- */
-#ifdef CONFIG_SH_PCLK_FREQ
-#define CLOCK_TICK_RATE		(CONFIG_SH_PCLK_FREQ / 4) /* Underlying HZ */
-#else
-#define CLOCK_TICK_RATE		1193180
-#endif
-
-#include <asm-generic/timex.h>
-
-#endif /* __ASM_SH_TIMEX_H */
diff --git a/arch/sh/include/asm/tlb.h b/arch/sh/include/asm/tlb.h
deleted file mode 100644
index aeb8915e925496..00000000000000
--- a/arch/sh/include/asm/tlb.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_TLB_H
-#define __ASM_SH_TLB_H
-
-#ifndef __ASSEMBLY__
-#include <linux/pagemap.h>
-#include <asm-generic/tlb.h>
-
-#ifdef CONFIG_MMU
-#include <linux/swap.h>
-
-#if defined(CONFIG_CPU_SH4)
-extern void tlb_wire_entry(struct vm_area_struct *, unsigned long, pte_t);
-extern void tlb_unwire_entry(void);
-#else
-static inline void tlb_wire_entry(struct vm_area_struct *vma ,
-				  unsigned long addr, pte_t pte)
-{
-	BUG();
-}
-
-static inline void tlb_unwire_entry(void)
-{
-	BUG();
-}
-#endif /* CONFIG_CPU_SH4 */
-#endif /* CONFIG_MMU */
-#endif /* __ASSEMBLY__ */
-#endif /* __ASM_SH_TLB_H */
diff --git a/arch/sh/include/asm/tlbflush.h b/arch/sh/include/asm/tlbflush.h
deleted file mode 100644
index 8f180cd3bcd638..00000000000000
--- a/arch/sh/include/asm/tlbflush.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_TLBFLUSH_H
-#define __ASM_SH_TLBFLUSH_H
-
-/*
- * TLB flushing:
- *
- *  - flush_tlb_all() flushes all processes TLBs
- *  - flush_tlb_mm(mm) flushes the specified mm context TLB's
- *  - flush_tlb_page(vma, vmaddr) flushes one page
- *  - flush_tlb_range(vma, start, end) flushes a range of pages
- *  - flush_tlb_kernel_range(start, end) flushes a range of kernel pages
- */
-extern void local_flush_tlb_all(void);
-extern void local_flush_tlb_mm(struct mm_struct *mm);
-extern void local_flush_tlb_range(struct vm_area_struct *vma,
-				  unsigned long start,
-				  unsigned long end);
-extern void local_flush_tlb_page(struct vm_area_struct *vma,
-				 unsigned long page);
-extern void local_flush_tlb_kernel_range(unsigned long start,
-					 unsigned long end);
-extern void local_flush_tlb_one(unsigned long asid, unsigned long page);
-
-extern void __flush_tlb_global(void);
-
-#ifdef CONFIG_SMP
-
-extern void flush_tlb_all(void);
-extern void flush_tlb_mm(struct mm_struct *mm);
-extern void flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
-			    unsigned long end);
-extern void flush_tlb_page(struct vm_area_struct *vma, unsigned long page);
-extern void flush_tlb_kernel_range(unsigned long start, unsigned long end);
-extern void flush_tlb_one(unsigned long asid, unsigned long page);
-
-#else
-
-#define flush_tlb_all()			local_flush_tlb_all()
-#define flush_tlb_mm(mm)		local_flush_tlb_mm(mm)
-#define flush_tlb_page(vma, page)	local_flush_tlb_page(vma, page)
-#define flush_tlb_one(asid, page)	local_flush_tlb_one(asid, page)
-
-#define flush_tlb_range(vma, start, end)	\
-	local_flush_tlb_range(vma, start, end)
-
-#define flush_tlb_kernel_range(start, end)	\
-	local_flush_tlb_kernel_range(start, end)
-
-#endif /* CONFIG_SMP */
-
-#endif /* __ASM_SH_TLBFLUSH_H */
diff --git a/arch/sh/include/asm/topology.h b/arch/sh/include/asm/topology.h
deleted file mode 100644
index 1db470e024565b..00000000000000
--- a/arch/sh/include/asm/topology.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _ASM_SH_TOPOLOGY_H
-#define _ASM_SH_TOPOLOGY_H
-
-#ifdef CONFIG_NUMA
-
-#define cpu_to_node(cpu)	((void)(cpu),0)
-
-#define cpumask_of_node(node)	((void)node, cpu_online_mask)
-
-#define pcibus_to_node(bus)	((void)(bus), -1)
-#define cpumask_of_pcibus(bus)	(pcibus_to_node(bus) == -1 ? \
-					cpu_all_mask : \
-					cpumask_of_node(pcibus_to_node(bus)))
-
-#endif
-
-#define mc_capable()    (1)
-
-const struct cpumask *cpu_coregroup_mask(int cpu);
-
-extern cpumask_t cpu_core_map[NR_CPUS];
-
-#define topology_core_cpumask(cpu)	(&cpu_core_map[cpu])
-
-#include <asm-generic/topology.h>
-
-#endif /* _ASM_SH_TOPOLOGY_H */
diff --git a/arch/sh/include/asm/traps.h b/arch/sh/include/asm/traps.h
deleted file mode 100644
index ba831bc7e08f5d..00000000000000
--- a/arch/sh/include/asm/traps.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_TRAPS_H
-#define __ASM_SH_TRAPS_H
-
-#include <linux/compiler.h>
-
-# include <asm/traps_32.h>
-
-BUILD_TRAP_HANDLER(address_error);
-BUILD_TRAP_HANDLER(debug);
-BUILD_TRAP_HANDLER(bug);
-BUILD_TRAP_HANDLER(breakpoint);
-BUILD_TRAP_HANDLER(singlestep);
-BUILD_TRAP_HANDLER(fpu_error);
-BUILD_TRAP_HANDLER(fpu_state_restore);
-BUILD_TRAP_HANDLER(nmi);
-
-#endif /* __ASM_SH_TRAPS_H */
diff --git a/arch/sh/include/asm/traps_32.h b/arch/sh/include/asm/traps_32.h
deleted file mode 100644
index 8c5bbb7b6053cf..00000000000000
--- a/arch/sh/include/asm/traps_32.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_TRAPS_32_H
-#define __ASM_SH_TRAPS_32_H
-
-#include <linux/types.h>
-#include <asm/mmu.h>
-
-#ifdef CONFIG_CPU_HAS_SR_RB
-#define lookup_exception_vector()	\
-({					\
-	unsigned long _vec;		\
-					\
-	__asm__ __volatile__ (		\
-		"stc r2_bank, %0\n\t"	\
-		: "=r" (_vec)		\
-	);				\
-					\
-	_vec;				\
-})
-#else
-#define lookup_exception_vector()	\
-({					\
-	unsigned long _vec;		\
-	__asm__ __volatile__ (		\
-		"mov r4, %0\n\t"	\
-		: "=r" (_vec)		\
-	);				\
-					\
-	_vec;				\
-})
-#endif
-
-static inline void trigger_address_error(void)
-{
-	__asm__ __volatile__ (
-		"ldc %0, sr\n\t"
-		"mov.l @%1, %0"
-		:
-		: "r" (0x10000000), "r" (0x80000001)
-	);
-}
-
-asmlinkage void do_address_error(struct pt_regs *regs,
-				 unsigned long writeaccess,
-				 unsigned long address);
-asmlinkage void do_divide_error(unsigned long r4);
-asmlinkage void do_reserved_inst(void);
-asmlinkage void do_illegal_slot_inst(void);
-asmlinkage void do_exception_error(void);
-
-#define BUILD_TRAP_HANDLER(name)					\
-asmlinkage void name##_trap_handler(unsigned long r4, unsigned long r5,	\
-				    unsigned long r6, unsigned long r7,	\
-				    struct pt_regs __regs)
-
-#define TRAP_HANDLER_DECL				\
-	struct pt_regs *regs = RELOC_HIDE(&__regs, 0);	\
-	unsigned int vec = regs->tra;			\
-	(void)vec;
-
-#endif /* __ASM_SH_TRAPS_32_H */
diff --git a/arch/sh/include/asm/types.h b/arch/sh/include/asm/types.h
deleted file mode 100644
index 68eb24ad201383..00000000000000
--- a/arch/sh/include/asm/types.h
+++ /dev/null
@@ -1,16 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_TYPES_H
-#define __ASM_SH_TYPES_H
-
-#include <uapi/asm/types.h>
-
-/*
- * These aren't exported outside the kernel to avoid name space clashes
- */
-#ifndef __ASSEMBLY__
-
-typedef u16 insn_size_t;
-typedef u32 reg_size_t;
-
-#endif /* __ASSEMBLY__ */
-#endif /* __ASM_SH_TYPES_H */
diff --git a/arch/sh/include/asm/uaccess.h b/arch/sh/include/asm/uaccess.h
deleted file mode 100644
index a79609eb14be43..00000000000000
--- a/arch/sh/include/asm/uaccess.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_UACCESS_H
-#define __ASM_SH_UACCESS_H
-
-#include <asm/extable.h>
-#include <asm-generic/access_ok.h>
-
-/*
- * Uh, these should become the main single-value transfer routines ...
- * They automatically use the right size if we just have the right
- * pointer type ...
- *
- * As SuperH uses the same address space for kernel and user data, we
- * can just do these as direct assignments.
- *
- * Careful to not
- * (a) re-use the arguments for side effects (sizeof is ok)
- * (b) require any knowledge of processes at this stage
- */
-#define put_user(x,ptr)		__put_user_check((x), (ptr), sizeof(*(ptr)))
-#define get_user(x,ptr)		__get_user_check((x), (ptr), sizeof(*(ptr)))
-
-/*
- * The "__xxx" versions do not do address space checking, useful when
- * doing multiple accesses to the same area (the user has to do the
- * checks by hand with "access_ok()")
- */
-#define __put_user(x,ptr)	__put_user_nocheck((x), (ptr), sizeof(*(ptr)))
-#define __get_user(x,ptr)	__get_user_nocheck((x), (ptr), sizeof(*(ptr)))
-
-struct __large_struct { unsigned long buf[100]; };
-#define __m(x) (*(struct __large_struct __user *)(x))
-
-#define __get_user_nocheck(x,ptr,size)				\
-({								\
-	long __gu_err;						\
-	unsigned long __gu_val;					\
-	const __typeof__(*(ptr)) __user *__gu_addr = (ptr);	\
-	__chk_user_ptr(ptr);					\
-	__get_user_size(__gu_val, __gu_addr, (size), __gu_err);	\
-	(x) = (__force __typeof__(*(ptr)))__gu_val;		\
-	__gu_err;						\
-})
-
-#define __get_user_check(x,ptr,size)					\
-({									\
-	long __gu_err = -EFAULT;					\
-	unsigned long __gu_val = 0;					\
-	const __typeof__(*(ptr)) __user *__gu_addr = (ptr);			\
-	if (likely(access_ok(__gu_addr, (size))))		\
-		__get_user_size(__gu_val, __gu_addr, (size), __gu_err);	\
-	(x) = (__force __typeof__(*(ptr)))__gu_val;			\
-	__gu_err;							\
-})
-
-#define __put_user_nocheck(x,ptr,size)				\
-({								\
-	long __pu_err;						\
-	__typeof__(*(ptr)) __user *__pu_addr = (ptr);		\
-	__typeof__(*(ptr)) __pu_val = x;			\
-	__chk_user_ptr(ptr);					\
-	__put_user_size(__pu_val, __pu_addr, (size), __pu_err);	\
-	__pu_err;						\
-})
-
-#define __put_user_check(x,ptr,size)				\
-({								\
-	long __pu_err = -EFAULT;				\
-	__typeof__(*(ptr)) __user *__pu_addr = (ptr);		\
-	__typeof__(*(ptr)) __pu_val = x;			\
-	if (likely(access_ok(__pu_addr, size)))	\
-		__put_user_size(__pu_val, __pu_addr, (size),	\
-				__pu_err);			\
-	__pu_err;						\
-})
-
-# include <asm/uaccess_32.h>
-
-extern long strncpy_from_user(char *dest, const char __user *src, long count);
-
-extern __must_check long strnlen_user(const char __user *str, long n);
-
-/* Generic arbitrary sized copy.  */
-/* Return the number of bytes NOT copied */
-__kernel_size_t __copy_user(void *to, const void *from, __kernel_size_t n);
-
-static __always_inline unsigned long
-raw_copy_from_user(void *to, const void __user *from, unsigned long n)
-{
-	return __copy_user(to, (__force void *)from, n);
-}
-
-static __always_inline unsigned long __must_check
-raw_copy_to_user(void __user *to, const void *from, unsigned long n)
-{
-	return __copy_user((__force void *)to, from, n);
-}
-#define INLINE_COPY_FROM_USER
-#define INLINE_COPY_TO_USER
-
-/*
- * Clear the area and return remaining number of bytes
- * (on failure.  Usually it's 0.)
- */
-__kernel_size_t __clear_user(void __user *addr, __kernel_size_t size);
-
-#define clear_user(addr,n)						\
-({									\
-	void __user * __cl_addr = (addr);				\
-	unsigned long __cl_size = (n);					\
-									\
-	if (__cl_size && access_ok(__cl_addr, __cl_size))		\
-		__cl_size = __clear_user(__cl_addr, __cl_size);		\
-									\
-	__cl_size;							\
-})
-
-extern void *set_exception_table_vec(unsigned int vec, void *handler);
-
-static inline void *set_exception_table_evt(unsigned int evt, void *handler)
-{
-	return set_exception_table_vec(evt >> 5, handler);
-}
-
-struct mem_access {
-	unsigned long (*from)(void *dst, const void __user *src, unsigned long cnt);
-	unsigned long (*to)(void __user *dst, const void *src, unsigned long cnt);
-};
-
-int handle_unaligned_access(insn_size_t instruction, struct pt_regs *regs,
-			    struct mem_access *ma, int, unsigned long address);
-
-#endif /* __ASM_SH_UACCESS_H */
diff --git a/arch/sh/include/asm/uaccess_32.h b/arch/sh/include/asm/uaccess_32.h
deleted file mode 100644
index 5d7ddc092afd77..00000000000000
--- a/arch/sh/include/asm/uaccess_32.h
+++ /dev/null
@@ -1,227 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * User space memory access functions
- *
- * Copyright (C) 1999, 2002  Niibe Yutaka
- * Copyright (C) 2003 - 2008  Paul Mundt
- *
- *  Based on:
- *     MIPS implementation version 1.15 by
- *              Copyright (C) 1996, 1997, 1998 by Ralf Baechle
- *     and i386 version.
- */
-#ifndef __ASM_SH_UACCESS_32_H
-#define __ASM_SH_UACCESS_32_H
-
-#define __get_user_size(x,ptr,size,retval)			\
-do {								\
-	retval = 0;						\
-	switch (size) {						\
-	case 1:							\
-		__get_user_asm(x, ptr, retval, "b");		\
-		break;						\
-	case 2:							\
-		__get_user_asm(x, ptr, retval, "w");		\
-		break;						\
-	case 4:							\
-		__get_user_asm(x, ptr, retval, "l");		\
-		break;						\
-	case 8:							\
-		__get_user_u64(x, ptr, retval);			\
-		break;						\
-	default:						\
-		__get_user_unknown();				\
-		break;						\
-	}							\
-} while (0)
-
-#ifdef CONFIG_MMU
-#define __get_user_asm(x, addr, err, insn) \
-({ \
-__asm__ __volatile__( \
-	"1:\n\t" \
-	"mov." insn "	%2, %1\n\t" \
-	"2:\n" \
-	".section	.fixup,\"ax\"\n" \
-	"3:\n\t" \
-	"mov	#0, %1\n\t" \
-	"mov.l	4f, %0\n\t" \
-	"jmp	@%0\n\t" \
-	" mov	%3, %0\n\t" \
-	".balign	4\n" \
-	"4:	.long	2b\n\t" \
-	".previous\n" \
-	".section	__ex_table,\"a\"\n\t" \
-	".long	1b, 3b\n\t" \
-	".previous" \
-	:"=&r" (err), "=&r" (x) \
-	:"m" (__m(addr)), "i" (-EFAULT), "0" (err)); })
-#else
-#define __get_user_asm(x, addr, err, insn)		\
-do {							\
-	__asm__ __volatile__ (				\
-		"mov." insn "	%1, %0\n\t"		\
-		: "=&r" (x)				\
-		: "m" (__m(addr))			\
-	);						\
-} while (0)
-#endif /* CONFIG_MMU */
-
-extern void __get_user_unknown(void);
-
-#if defined(CONFIG_CPU_LITTLE_ENDIAN)
-#define __get_user_u64(x, addr, err) \
-({ \
-__asm__ __volatile__( \
-	"1:\n\t" \
-	"mov.l	%2,%R1\n\t" \
-	"mov.l	%T2,%S1\n\t" \
-	"2:\n" \
-	".section	.fixup,\"ax\"\n" \
-	"3:\n\t" \
-	"mov  #0,%R1\n\t"   \
-	"mov  #0,%S1\n\t"   \
-	"mov.l	4f, %0\n\t" \
-	"jmp	@%0\n\t" \
-	" mov	%3, %0\n\t" \
-	".balign	4\n" \
-	"4:	.long	2b\n\t" \
-	".previous\n" \
-	".section	__ex_table,\"a\"\n\t" \
-	".long	1b, 3b\n\t" \
-	".long	1b + 2, 3b\n\t" \
-	".previous" \
-	:"=&r" (err), "=&r" (x) \
-	:"m" (__m(addr)), "i" (-EFAULT), "0" (err)); })
-#else
-#define __get_user_u64(x, addr, err) \
-({ \
-__asm__ __volatile__( \
-	"1:\n\t" \
-	"mov.l	%2,%S1\n\t" \
-	"mov.l	%T2,%R1\n\t" \
-	"2:\n" \
-	".section	.fixup,\"ax\"\n" \
-	"3:\n\t" \
-	"mov  #0,%S1\n\t"   \
-	"mov  #0,%R1\n\t"   \
-	"mov.l	4f, %0\n\t" \
-	"jmp	@%0\n\t" \
-	" mov	%3, %0\n\t" \
-	".balign	4\n" \
-	"4:	.long	2b\n\t" \
-	".previous\n" \
-	".section	__ex_table,\"a\"\n\t" \
-	".long	1b, 3b\n\t" \
-	".long	1b + 2, 3b\n\t" \
-	".previous" \
-	:"=&r" (err), "=&r" (x) \
-	:"m" (__m(addr)), "i" (-EFAULT), "0" (err)); })
-#endif
-
-#define __put_user_size(x,ptr,size,retval)		\
-do {							\
-	retval = 0;					\
-	switch (size) {					\
-	case 1:						\
-		__put_user_asm(x, ptr, retval, "b");	\
-		break;					\
-	case 2:						\
-		__put_user_asm(x, ptr, retval, "w");	\
-		break;					\
-	case 4:						\
-		__put_user_asm(x, ptr, retval, "l");	\
-		break;					\
-	case 8:						\
-		__put_user_u64(x, ptr, retval);		\
-		break;					\
-	default:					\
-		__put_user_unknown();			\
-	}						\
-} while (0)
-
-#ifdef CONFIG_MMU
-#define __put_user_asm(x, addr, err, insn)			\
-do {								\
-	__asm__ __volatile__ (					\
-		"1:\n\t"					\
-		"mov." insn "	%1, %2\n\t"			\
-		"2:\n"						\
-		".section	.fixup,\"ax\"\n"		\
-		"3:\n\t"					\
-		"mov.l	4f, %0\n\t"				\
-		"jmp	@%0\n\t"				\
-		" mov	%3, %0\n\t"				\
-		".balign	4\n"				\
-		"4:	.long	2b\n\t"				\
-		".previous\n"					\
-		".section	__ex_table,\"a\"\n\t"		\
-		".long	1b, 3b\n\t"				\
-		".previous"					\
-		: "=&r" (err)					\
-		: "r" (x), "m" (__m(addr)), "i" (-EFAULT),	\
-		  "0" (err)					\
-		: "memory"					\
-	);							\
-} while (0)
-#else
-#define __put_user_asm(x, addr, err, insn)		\
-do {							\
-	__asm__ __volatile__ (				\
-		"mov." insn "	%0, %1\n\t"		\
-		: /* no outputs */			\
-		: "r" (x), "m" (__m(addr))		\
-		: "memory"				\
-	);						\
-} while (0)
-#endif /* CONFIG_MMU */
-
-#if defined(CONFIG_CPU_LITTLE_ENDIAN)
-#define __put_user_u64(val,addr,retval) \
-({ \
-__asm__ __volatile__( \
-	"1:\n\t" \
-	"mov.l	%R1,%2\n\t" \
-	"mov.l	%S1,%T2\n\t" \
-	"2:\n" \
-	".section	.fixup,\"ax\"\n" \
-	"3:\n\t" \
-	"mov.l	4f,%0\n\t" \
-	"jmp	@%0\n\t" \
-	" mov	%3,%0\n\t" \
-	".balign	4\n" \
-	"4:	.long	2b\n\t" \
-	".previous\n" \
-	".section	__ex_table,\"a\"\n\t" \
-	".long	1b, 3b\n\t" \
-	".previous" \
-	: "=r" (retval) \
-	: "r" (val), "m" (__m(addr)), "i" (-EFAULT), "0" (retval) \
-        : "memory"); })
-#else
-#define __put_user_u64(val,addr,retval) \
-({ \
-__asm__ __volatile__( \
-	"1:\n\t" \
-	"mov.l	%S1,%2\n\t" \
-	"mov.l	%R1,%T2\n\t" \
-	"2:\n" \
-	".section	.fixup,\"ax\"\n" \
-	"3:\n\t" \
-	"mov.l	4f,%0\n\t" \
-	"jmp	@%0\n\t" \
-	" mov	%3,%0\n\t" \
-	".balign	4\n" \
-	"4:	.long	2b\n\t" \
-	".previous\n" \
-	".section	__ex_table,\"a\"\n\t" \
-	".long	1b, 3b\n\t" \
-	".previous" \
-	: "=r" (retval) \
-	: "r" (val), "m" (__m(addr)), "i" (-EFAULT), "0" (retval) \
-        : "memory"); })
-#endif
-
-extern void __put_user_unknown(void);
-
-#endif /* __ASM_SH_UACCESS_32_H */
diff --git a/arch/sh/include/asm/uncached.h b/arch/sh/include/asm/uncached.h
deleted file mode 100644
index e7f68ec61014c3..00000000000000
--- a/arch/sh/include/asm/uncached.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_UNCACHED_H
-#define __ASM_SH_UNCACHED_H
-
-#include <linux/bug.h>
-
-#ifdef CONFIG_UNCACHED_MAPPING
-extern unsigned long cached_to_uncached;
-extern unsigned long uncached_size;
-extern unsigned long uncached_start, uncached_end;
-
-extern int virt_addr_uncached(unsigned long kaddr);
-extern void uncached_init(void);
-extern void uncached_resize(unsigned long size);
-
-/*
- * Jump to uncached area.
- * When handling TLB or caches, we need to do it from an uncached area.
- */
-#define jump_to_uncached()			\
-do {						\
-	unsigned long __dummy;			\
-						\
-	__asm__ __volatile__(			\
-		"mova	1f, %0\n\t"		\
-		"add	%1, %0\n\t"		\
-		"jmp	@%0\n\t"		\
-		" nop\n\t"			\
-		".balign 4\n"			\
-		"1:"				\
-		: "=&z" (__dummy)		\
-		: "r" (cached_to_uncached));	\
-} while (0)
-
-/*
- * Back to cached area.
- */
-#define back_to_cached()				\
-do {							\
-	unsigned long __dummy;				\
-	ctrl_barrier();					\
-	__asm__ __volatile__(				\
-		"mov.l	1f, %0\n\t"			\
-		"jmp	@%0\n\t"			\
-		" nop\n\t"				\
-		".balign 4\n"				\
-		"1:	.long 2f\n"			\
-		"2:"					\
-		: "=&r" (__dummy));			\
-} while (0)
-#else
-#define virt_addr_uncached(kaddr)	(0)
-#define uncached_init()			do { } while (0)
-#define uncached_resize(size)		BUG()
-#define jump_to_uncached()		do { } while (0)
-#define back_to_cached()		do { } while (0)
-#endif
-
-#endif /* __ASM_SH_UNCACHED_H */
diff --git a/arch/sh/include/asm/unistd.h b/arch/sh/include/asm/unistd.h
deleted file mode 100644
index d6e1262501368a..00000000000000
--- a/arch/sh/include/asm/unistd.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <asm/unistd_32.h>
-
-#define NR_syscalls	__NR_syscalls
-
-# define __ARCH_WANT_NEW_STAT
-# define __ARCH_WANT_OLD_READDIR
-# define __ARCH_WANT_OLD_STAT
-# define __ARCH_WANT_STAT64
-# define __ARCH_WANT_SYS_ALARM
-# define __ARCH_WANT_SYS_GETHOSTNAME
-# define __ARCH_WANT_SYS_IPC
-# define __ARCH_WANT_SYS_PAUSE
-# define __ARCH_WANT_SYS_SIGNAL
-# define __ARCH_WANT_SYS_TIME32
-# define __ARCH_WANT_SYS_UTIME32
-# define __ARCH_WANT_SYS_WAITPID
-# define __ARCH_WANT_SYS_SOCKETCALL
-# define __ARCH_WANT_SYS_FADVISE64
-# define __ARCH_WANT_SYS_GETPGRP
-# define __ARCH_WANT_SYS_NICE
-# define __ARCH_WANT_SYS_OLD_GETRLIMIT
-# define __ARCH_WANT_SYS_OLD_UNAME
-# define __ARCH_WANT_SYS_OLDUMOUNT
-# define __ARCH_WANT_SYS_SIGPENDING
-# define __ARCH_WANT_SYS_SIGPROCMASK
-# define __ARCH_WANT_SYS_FORK
-# define __ARCH_WANT_SYS_VFORK
-# define __ARCH_WANT_SYS_CLONE
-
-#include <uapi/asm/unistd.h>
diff --git a/arch/sh/include/asm/unwinder.h b/arch/sh/include/asm/unwinder.h
deleted file mode 100644
index ce82c96c789904..00000000000000
--- a/arch/sh/include/asm/unwinder.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _LINUX_UNWINDER_H
-#define _LINUX_UNWINDER_H
-
-#include <asm/stacktrace.h>
-
-struct unwinder {
-	const char *name;
-	struct list_head list;
-	int rating;
-	void (*dump)(struct task_struct *, struct pt_regs *,
-		     unsigned long *, const struct stacktrace_ops *, void *);
-};
-
-extern int unwinder_init(void);
-extern int unwinder_register(struct unwinder *);
-
-extern void unwind_stack(struct task_struct *, struct pt_regs *,
-			 unsigned long *, const struct stacktrace_ops *,
-			 void *);
-
-extern void stack_reader_dump(struct task_struct *, struct pt_regs *,
-			      unsigned long *, const struct stacktrace_ops *,
-			      void *);
-
-/*
- * Used by fault handling code to signal to the unwinder code that it
- * should switch to a different unwinder.
- */
-extern int unwinder_faulted;
-
-#endif /* _LINUX_UNWINDER_H */
diff --git a/arch/sh/include/asm/user.h b/arch/sh/include/asm/user.h
deleted file mode 100644
index 12ea0f3f441991..00000000000000
--- a/arch/sh/include/asm/user.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_USER_H
-#define __ASM_SH_USER_H
-
-#include <asm/ptrace.h>
-#include <asm/page.h>
-
-/*
- * Core file format: The core file is written in such a way that gdb
- * can understand it and provide useful information to the user (under
- * linux we use the `trad-core' bfd).  The file contents are as follows:
- *
- *  upage: 1 page consisting of a user struct that tells gdb
- *	what is present in the file.  Directly after this is a
- *	copy of the task_struct, which is currently not used by gdb,
- *	but it may come in handy at some point.  All of the registers
- *	are stored as part of the upage.  The upage should always be
- *	only one page long.
- *  data: The data segment follows next.  We use current->end_text to
- *	current->brk to pick up all of the user variables, plus any memory
- *	that may have been sbrk'ed.  No attempt is made to determine if a
- *	page is demand-zero or if a page is totally unused, we just cover
- *	the entire range.  All of the addresses are rounded in such a way
- *	that an integral number of pages is written.
- *  stack: We need the stack information in order to get a meaningful
- *	backtrace.  We need to write the data from usp to
- *	current->start_stack, so we round each of these in order to be able
- *	to write an integer number of pages.
- */
-
-struct user_fpu_struct {
-	unsigned long fp_regs[16];
-	unsigned long xfp_regs[16];
-	unsigned long fpscr;
-	unsigned long fpul;
-};
-
-struct user {
-	struct pt_regs	regs;			/* entire machine state */
-	struct user_fpu_struct fpu;	/* Math Co-processor registers  */
-	int u_fpvalid;		/* True if math co-processor being used */
-	size_t		u_tsize;		/* text size (pages) */
-	size_t		u_dsize;		/* data size (pages) */
-	size_t		u_ssize;		/* stack size (pages) */
-	unsigned long	start_code;		/* text starting address */
-	unsigned long	start_data;		/* data starting address */
-	unsigned long	start_stack;		/* stack starting address */
-	long int	signal;			/* signal causing core dump */
-	unsigned long	u_ar0;			/* help gdb find registers */
-	struct user_fpu_struct* u_fpstate;	/* Math Co-processor pointer */
-	unsigned long	magic;			/* identifies a core file */
-	char		u_comm[32];		/* user command name */
-};
-
-#endif /* __ASM_SH_USER_H */
diff --git a/arch/sh/include/asm/vermagic.h b/arch/sh/include/asm/vermagic.h
deleted file mode 100644
index 5b2057c39170ed..00000000000000
--- a/arch/sh/include/asm/vermagic.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-#ifndef _ASM_VERMAGIC_H
-#define _ASM_VERMAGIC_H
-
-#ifdef CONFIG_CPU_LITTLE_ENDIAN
-# ifdef CONFIG_CPU_SH2
-#  define MODULE_PROC_FAMILY "SH2LE "
-# elif defined  CONFIG_CPU_SH3
-#  define MODULE_PROC_FAMILY "SH3LE "
-# elif defined  CONFIG_CPU_SH4
-#  define MODULE_PROC_FAMILY "SH4LE "
-# else
-#  error unknown processor family
-# endif
-#else
-# ifdef CONFIG_CPU_SH2
-#  define MODULE_PROC_FAMILY "SH2BE "
-# elif defined  CONFIG_CPU_SH3
-#  define MODULE_PROC_FAMILY "SH3BE "
-# elif defined  CONFIG_CPU_SH4
-#  define MODULE_PROC_FAMILY "SH4BE "
-# else
-#  error unknown processor family
-# endif
-#endif
-
-#define MODULE_ARCH_VERMAGIC MODULE_PROC_FAMILY
-
-#endif /* _ASM_VERMAGIC_H */
diff --git a/arch/sh/include/asm/vga.h b/arch/sh/include/asm/vga.h
deleted file mode 100644
index 089fbdc6c0b1d0..00000000000000
--- a/arch/sh/include/asm/vga.h
+++ /dev/null
@@ -1,7 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_VGA_H
-#define __ASM_SH_VGA_H
-
-/* Stupid drivers. */
-
-#endif /* __ASM_SH_VGA_H */
diff --git a/arch/sh/include/asm/vmalloc.h b/arch/sh/include/asm/vmalloc.h
deleted file mode 100644
index 716b7747264658..00000000000000
--- a/arch/sh/include/asm/vmalloc.h
+++ /dev/null
@@ -1,4 +0,0 @@
-#ifndef _ASM_SH_VMALLOC_H
-#define _ASM_SH_VMALLOC_H
-
-#endif /* _ASM_SH_VMALLOC_H */
diff --git a/arch/sh/include/asm/vmlinux.lds.h b/arch/sh/include/asm/vmlinux.lds.h
deleted file mode 100644
index 8d96c4f9b35b88..00000000000000
--- a/arch/sh/include/asm/vmlinux.lds.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_VMLINUX_LDS_H
-#define __ASM_SH_VMLINUX_LDS_H
-
-#include <asm-generic/vmlinux.lds.h>
-
-#ifdef CONFIG_DWARF_UNWINDER
-#define DWARF_EH_FRAME							\
-	.eh_frame : AT(ADDR(.eh_frame) - LOAD_OFFSET) {			\
-		  __start_eh_frame = .;					\
-		  *(.eh_frame)						\
-		  __stop_eh_frame = .;					\
-	}
-#else
-#define DWARF_EH_FRAME
-#endif
-
-#endif /* __ASM_SH_VMLINUX_LDS_H */
diff --git a/arch/sh/include/asm/watchdog.h b/arch/sh/include/asm/watchdog.h
deleted file mode 100644
index b9ca4c99f046a6..00000000000000
--- a/arch/sh/include/asm/watchdog.h
+++ /dev/null
@@ -1,159 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+
- *
- * include/asm-sh/watchdog.h
- *
- * Copyright (C) 2002, 2003 Paul Mundt
- * Copyright (C) 2009 Siemens AG
- * Copyright (C) 2009 Valentin Sitdikov
- */
-#ifndef __ASM_SH_WATCHDOG_H
-#define __ASM_SH_WATCHDOG_H
-
-#include <linux/types.h>
-#include <linux/io.h>
-
-#define WTCNT_HIGH	0x5a
-#define WTCSR_HIGH	0xa5
-
-#define WTCSR_CKS2	0x04
-#define WTCSR_CKS1	0x02
-#define WTCSR_CKS0	0x01
-
-#include <cpu/watchdog.h>
-
-/*
- * See cpu-sh2/watchdog.h for explanation of this stupidity..
- */
-#ifndef WTCNT_R
-#  define WTCNT_R	WTCNT
-#endif
-
-#ifndef WTCSR_R
-#  define WTCSR_R	WTCSR
-#endif
-
-/*
- * CKS0-2 supports a number of clock division ratios. At the time the watchdog
- * is enabled, it defaults to a 41 usec overflow period .. we overload this to
- * something a little more reasonable, and really can't deal with anything
- * lower than WTCSR_CKS_1024, else we drop back into the usec range.
- *
- * Clock Division Ratio         Overflow Period
- * --------------------------------------------
- *     1/32 (initial value)       41 usecs
- *     1/64                       82 usecs
- *     1/128                     164 usecs
- *     1/256                     328 usecs
- *     1/512                     656 usecs
- *     1/1024                   1.31 msecs
- *     1/2048                   2.62 msecs
- *     1/4096                   5.25 msecs
- */
-#define WTCSR_CKS_32	0x00
-#define WTCSR_CKS_64	0x01
-#define WTCSR_CKS_128	0x02
-#define WTCSR_CKS_256	0x03
-#define WTCSR_CKS_512	0x04
-#define WTCSR_CKS_1024	0x05
-#define WTCSR_CKS_2048	0x06
-#define WTCSR_CKS_4096	0x07
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7785) || defined(CONFIG_CPU_SUBTYPE_SH7780)
-/**
- * 	sh_wdt_read_cnt - Read from Counter
- * 	Reads back the WTCNT value.
- */
-static inline __u32 sh_wdt_read_cnt(void)
-{
-	return __raw_readl(WTCNT_R);
-}
-
-/**
- *	sh_wdt_write_cnt - Write to Counter
- *	@val: Value to write
- *
- *	Writes the given value @val to the lower byte of the timer counter.
- *	The upper byte is set manually on each write.
- */
-static inline void sh_wdt_write_cnt(__u32 val)
-{
-	__raw_writel((WTCNT_HIGH << 24) | (__u32)val, WTCNT);
-}
-
-/**
- *	sh_wdt_write_bst - Write to Counter
- *	@val: Value to write
- *
- *	Writes the given value @val to the lower byte of the timer counter.
- *	The upper byte is set manually on each write.
- */
-static inline void sh_wdt_write_bst(__u32 val)
-{
-	__raw_writel((WTBST_HIGH << 24) | (__u32)val, WTBST);
-}
-/**
- * 	sh_wdt_read_csr - Read from Control/Status Register
- *
- *	Reads back the WTCSR value.
- */
-static inline __u32 sh_wdt_read_csr(void)
-{
-	return __raw_readl(WTCSR_R);
-}
-
-/**
- * 	sh_wdt_write_csr - Write to Control/Status Register
- * 	@val: Value to write
- *
- * 	Writes the given value @val to the lower byte of the control/status
- * 	register. The upper byte is set manually on each write.
- */
-static inline void sh_wdt_write_csr(__u32 val)
-{
-	__raw_writel((WTCSR_HIGH << 24) | (__u32)val, WTCSR);
-}
-#else
-/**
- * 	sh_wdt_read_cnt - Read from Counter
- * 	Reads back the WTCNT value.
- */
-static inline __u8 sh_wdt_read_cnt(void)
-{
-	return __raw_readb(WTCNT_R);
-}
-
-/**
- *	sh_wdt_write_cnt - Write to Counter
- *	@val: Value to write
- *
- *	Writes the given value @val to the lower byte of the timer counter.
- *	The upper byte is set manually on each write.
- */
-static inline void sh_wdt_write_cnt(__u8 val)
-{
-	__raw_writew((WTCNT_HIGH << 8) | (__u16)val, WTCNT);
-}
-
-/**
- * 	sh_wdt_read_csr - Read from Control/Status Register
- *
- *	Reads back the WTCSR value.
- */
-static inline __u8 sh_wdt_read_csr(void)
-{
-	return __raw_readb(WTCSR_R);
-}
-
-/**
- * 	sh_wdt_write_csr - Write to Control/Status Register
- * 	@val: Value to write
- *
- * 	Writes the given value @val to the lower byte of the control/status
- * 	register. The upper byte is set manually on each write.
- */
-static inline void sh_wdt_write_csr(__u8 val)
-{
-	__raw_writew((WTCSR_HIGH << 8) | (__u16)val, WTCSR);
-}
-#endif /* CONFIG_CPU_SUBTYPE_SH7785 || CONFIG_CPU_SUBTYPE_SH7780 */
-#endif /* __ASM_SH_WATCHDOG_H */
diff --git a/arch/sh/include/asm/word-at-a-time.h b/arch/sh/include/asm/word-at-a-time.h
deleted file mode 100644
index 4aa398455b94ab..00000000000000
--- a/arch/sh/include/asm/word-at-a-time.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_WORD_AT_A_TIME_H
-#define __ASM_SH_WORD_AT_A_TIME_H
-
-#ifdef CONFIG_CPU_BIG_ENDIAN
-# include <asm-generic/word-at-a-time.h>
-#else
-/*
- * Little-endian version cribbed from x86.
- */
-struct word_at_a_time {
-	const unsigned long one_bits, high_bits;
-};
-
-#define WORD_AT_A_TIME_CONSTANTS { REPEAT_BYTE(0x01), REPEAT_BYTE(0x80) }
-
-/* Carl Chatfield / Jan Achrenius G+ version for 32-bit */
-static inline long count_masked_bytes(long mask)
-{
-	/* (000000 0000ff 00ffff ffffff) -> ( 1 1 2 3 ) */
-	long a = (0x0ff0001+mask) >> 23;
-	/* Fix the 1 for 00 case */
-	return a & mask;
-}
-
-/* Return nonzero if it has a zero */
-static inline unsigned long has_zero(unsigned long a, unsigned long *bits, const struct word_at_a_time *c)
-{
-	unsigned long mask = ((a - c->one_bits) & ~a) & c->high_bits;
-	*bits = mask;
-	return mask;
-}
-
-static inline unsigned long prep_zero_mask(unsigned long a, unsigned long bits, const struct word_at_a_time *c)
-{
-	return bits;
-}
-
-static inline unsigned long create_zero_mask(unsigned long bits)
-{
-	bits = (bits - 1) & ~bits;
-	return bits >> 7;
-}
-
-/* The mask we created is directly usable as a bytemask */
-#define zero_bytemask(mask) (mask)
-
-static inline unsigned long find_zero(unsigned long mask)
-{
-	return count_masked_bytes(mask);
-}
-#endif
-
-#endif
diff --git a/arch/sh/include/cpu-common/cpu/addrspace.h b/arch/sh/include/cpu-common/cpu/addrspace.h
deleted file mode 100644
index d8bf5d7d2fdf0a..00000000000000
--- a/arch/sh/include/cpu-common/cpu/addrspace.h
+++ /dev/null
@@ -1,16 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * Definitions for the address spaces of the SH-2 CPUs.
- *
- * Copyright (C) 2003  Paul Mundt
- */
-#ifndef __ASM_CPU_SH2_ADDRSPACE_H
-#define __ASM_CPU_SH2_ADDRSPACE_H
-
-#define P0SEG		0x00000000
-#define P1SEG		0x80000000
-#define P2SEG		0xa0000000
-#define P3SEG		0xc0000000
-#define P4SEG		0xe0000000
-
-#endif /* __ASM_CPU_SH2_ADDRSPACE_H */
diff --git a/arch/sh/include/cpu-common/cpu/mmu_context.h b/arch/sh/include/cpu-common/cpu/mmu_context.h
deleted file mode 100644
index cef3a30dbf97c8..00000000000000
--- a/arch/sh/include/cpu-common/cpu/mmu_context.h
+++ /dev/null
@@ -1,13 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/cpu-sh2/mmu_context.h
- *
- * Copyright (C) 2003  Paul Mundt
- */
-#ifndef __ASM_CPU_SH2_MMU_CONTEXT_H
-#define __ASM_CPU_SH2_MMU_CONTEXT_H
-
-/* No MMU */
-
-#endif /* __ASM_CPU_SH2_MMU_CONTEXT_H */
-
diff --git a/arch/sh/include/cpu-common/cpu/pfc.h b/arch/sh/include/cpu-common/cpu/pfc.h
deleted file mode 100644
index 879d2c9da537fa..00000000000000
--- a/arch/sh/include/cpu-common/cpu/pfc.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * SH Pin Function Control Initialization
- *
- * Copyright (C) 2012  Renesas Solutions Corp.
- */
-
-#ifndef __ARCH_SH_CPU_PFC_H__
-#define __ARCH_SH_CPU_PFC_H__
-
-#include <linux/types.h>
-
-struct resource;
-
-int sh_pfc_register(const char *name,
-		    struct resource *resource, u32 num_resources);
-
-#endif /* __ARCH_SH_CPU_PFC_H__ */
diff --git a/arch/sh/include/cpu-common/cpu/rtc.h b/arch/sh/include/cpu-common/cpu/rtc.h
deleted file mode 100644
index 5fe726acd9f8f5..00000000000000
--- a/arch/sh/include/cpu-common/cpu/rtc.h
+++ /dev/null
@@ -1,9 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_CPU_SH2_RTC_H
-#define __ASM_SH_CPU_SH2_RTC_H
-
-#define rtc_reg_size		sizeof(u16)
-#define RTC_BIT_INVERTED	0
-#define RTC_DEF_CAPABILITIES	0UL
-
-#endif /* __ASM_SH_CPU_SH2_RTC_H */
diff --git a/arch/sh/include/cpu-common/cpu/sigcontext.h b/arch/sh/include/cpu-common/cpu/sigcontext.h
deleted file mode 100644
index e005dd176ff211..00000000000000
--- a/arch/sh/include/cpu-common/cpu/sigcontext.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_CPU_SH2_SIGCONTEXT_H
-#define __ASM_CPU_SH2_SIGCONTEXT_H
-
-struct sigcontext {
-	unsigned long	oldmask;
-
-	/* CPU registers */
-	unsigned long sc_regs[16];
-	unsigned long sc_pc;
-	unsigned long sc_pr;
-	unsigned long sc_sr;
-	unsigned long sc_gbr;
-	unsigned long sc_mach;
-	unsigned long sc_macl;
-};
-
-#endif /* __ASM_CPU_SH2_SIGCONTEXT_H */
diff --git a/arch/sh/include/cpu-common/cpu/timer.h b/arch/sh/include/cpu-common/cpu/timer.h
deleted file mode 100644
index af51438755e003..00000000000000
--- a/arch/sh/include/cpu-common/cpu/timer.h
+++ /dev/null
@@ -1,7 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_CPU_SH2_TIMER_H
-#define __ASM_CPU_SH2_TIMER_H
-
-/* Nothing needed yet */
-
-#endif /* __ASM_CPU_SH2_TIMER_H */
diff --git a/arch/sh/include/cpu-sh2/cpu/cache.h b/arch/sh/include/cpu-sh2/cpu/cache.h
deleted file mode 100644
index 070aa9f50d3f09..00000000000000
--- a/arch/sh/include/cpu-sh2/cpu/cache.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/cpu-sh2/cache.h
- *
- * Copyright (C) 2003 Paul Mundt
- */
-#ifndef __ASM_CPU_SH2_CACHE_H
-#define __ASM_CPU_SH2_CACHE_H
-
-#define L1_CACHE_SHIFT	4
-
-#define SH_CACHE_VALID		1
-#define SH_CACHE_UPDATED	2
-#define SH_CACHE_COMBINED	4
-#define SH_CACHE_ASSOC		8
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7619)
-#define SH_CCR		0xffffffec
-
-#define CCR_CACHE_CE	0x01	/* Cache enable */
-#define CCR_CACHE_WT	0x02    /* CCR[bit1=1,bit2=1] */
-				/* 0x00000000-0x7fffffff: Write-through  */
-				/* 0x80000000-0x9fffffff: Write-back     */
-                                /* 0xc0000000-0xdfffffff: Write-through  */
-#define CCR_CACHE_CB	0x04    /* CCR[bit1=0,bit2=0] */
-				/* 0x00000000-0x7fffffff: Write-back     */
-				/* 0x80000000-0x9fffffff: Write-through  */
-                                /* 0xc0000000-0xdfffffff: Write-back     */
-#define CCR_CACHE_CF	0x08	/* Cache invalidate */
-
-#define CACHE_OC_ADDRESS_ARRAY	0xf0000000
-#define CACHE_OC_DATA_ARRAY	0xf1000000
-
-#define CCR_CACHE_ENABLE	CCR_CACHE_CE
-#define CCR_CACHE_INVALIDATE	CCR_CACHE_CF
-#define CACHE_PHYSADDR_MASK	0x1ffffc00
-
-#endif
-
-#endif /* __ASM_CPU_SH2_CACHE_H */
diff --git a/arch/sh/include/cpu-sh2/cpu/freq.h b/arch/sh/include/cpu-sh2/cpu/freq.h
deleted file mode 100644
index fb2e5d2831bc76..00000000000000
--- a/arch/sh/include/cpu-sh2/cpu/freq.h
+++ /dev/null
@@ -1,15 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/cpu-sh2/freq.h
- *
- * Copyright (C) 2006  Yoshinori Sato
- */
-#ifndef __ASM_CPU_SH2_FREQ_H
-#define __ASM_CPU_SH2_FREQ_H
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7619)
-#define FREQCR	0xf815ff80
-#endif
-
-#endif /* __ASM_CPU_SH2_FREQ_H */
-
diff --git a/arch/sh/include/cpu-sh2/cpu/watchdog.h b/arch/sh/include/cpu-sh2/cpu/watchdog.h
deleted file mode 100644
index 141fe296d75168..00000000000000
--- a/arch/sh/include/cpu-sh2/cpu/watchdog.h
+++ /dev/null
@@ -1,66 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/cpu-sh2/watchdog.h
- *
- * Copyright (C) 2002, 2003 Paul Mundt
- */
-#ifndef __ASM_CPU_SH2_WATCHDOG_H
-#define __ASM_CPU_SH2_WATCHDOG_H
-
-/*
- * More SH-2 brilliance .. its not good enough that we can't read
- * and write the same sizes to WTCNT, now we have to read and write
- * with different sizes at different addresses for WTCNT _and_ RSTCSR.
- *
- * At least on the bright side no one has managed to screw over WTCSR
- * in this fashion .. yet.
- */
-/* Register definitions */
-#define WTCNT		0xfffffe80
-#define WTCSR		0xfffffe80
-#define RSTCSR		0xfffffe82
-
-#define WTCNT_R		(WTCNT + 1)
-#define RSTCSR_R	(RSTCSR + 1)
-
-/* Bit definitions */
-#define WTCSR_IOVF	0x80
-#define WTCSR_WT	0x40
-#define WTCSR_TME	0x20
-#define WTCSR_RSTS	0x00
-
-#define RSTCSR_RSTS	0x20
-
-/**
- * 	sh_wdt_read_rstcsr - Read from Reset Control/Status Register
- *
- *	Reads back the RSTCSR value.
- */
-static inline __u8 sh_wdt_read_rstcsr(void)
-{
-	/*
-	 * Same read/write brain-damage as for WTCNT here..
-	 */
-	return __raw_readb(RSTCSR_R);
-}
-
-/**
- * 	sh_wdt_write_csr - Write to Reset Control/Status Register
- *
- * 	@val: Value to write
- *
- * 	Writes the given value @val to the lower byte of the control/status
- * 	register. The upper byte is set manually on each write.
- */
-static inline void sh_wdt_write_rstcsr(__u8 val)
-{
-	/*
-	 * Note: Due to the brain-damaged nature of this register,
-	 * we can't presently touch the WOVF bit, since the upper byte
-	 * has to be swapped for this. So just leave it alone..
-	 */
-	__raw_writeb((WTCNT_HIGH << 8) | (__u16)val, RSTCSR);
-}
-
-#endif /* __ASM_CPU_SH2_WATCHDOG_H */
-
diff --git a/arch/sh/include/cpu-sh2a/cpu/addrspace.h b/arch/sh/include/cpu-sh2a/cpu/addrspace.h
deleted file mode 100644
index 3afa46c09fb531..00000000000000
--- a/arch/sh/include/cpu-sh2a/cpu/addrspace.h
+++ /dev/null
@@ -1,11 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_CPU_SH2A_ADDRSPACE_H
-#define __ASM_SH_CPU_SH2A_ADDRSPACE_H
-
-#define P0SEG		0x00000000
-#define P1SEG		0x00000000
-#define P2SEG		0x20000000
-#define P3SEG		0x40000000
-#define P4SEG		0x60000000
-
-#endif /* __ASM_SH_CPU_SH2A_ADDRSPACE_H */
diff --git a/arch/sh/include/cpu-sh2a/cpu/cache.h b/arch/sh/include/cpu-sh2a/cpu/cache.h
deleted file mode 100644
index 06efb233eb35f4..00000000000000
--- a/arch/sh/include/cpu-sh2a/cpu/cache.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/cpu-sh2a/cache.h
- *
- * Copyright (C) 2004 Paul Mundt
- */
-#ifndef __ASM_CPU_SH2A_CACHE_H
-#define __ASM_CPU_SH2A_CACHE_H
-
-#define L1_CACHE_SHIFT	4
-
-#define SH_CACHE_VALID		1
-#define SH_CACHE_UPDATED	2
-#define SH_CACHE_COMBINED	4
-#define SH_CACHE_ASSOC		8
-
-#define SH_CCR		0xfffc1000 /* CCR1 */
-#define SH_CCR2		0xfffc1004
-
-/*
- * Most of the SH-2A CCR1 definitions resemble the SH-4 ones. All others not
- * listed here are reserved.
- */
-#define CCR_CACHE_CB	0x0000	/* Hack */
-#define CCR_CACHE_OCE	0x0001
-#define CCR_CACHE_WT	0x0002
-#define CCR_CACHE_OCI	0x0008	/* OCF */
-#define CCR_CACHE_ICE	0x0100
-#define CCR_CACHE_ICI	0x0800	/* ICF */
-
-#define CACHE_IC_ADDRESS_ARRAY	0xf0000000
-#define CACHE_OC_ADDRESS_ARRAY	0xf0800000
-
-#define CCR_CACHE_ENABLE	(CCR_CACHE_OCE | CCR_CACHE_ICE)
-#define CCR_CACHE_INVALIDATE	(CCR_CACHE_OCI | CCR_CACHE_ICI)
-#define CCR_ICACHE_INVALIDATE	CCR_CACHE_ICI
-#define CCR_OCACHE_INVALIDATE	CCR_CACHE_OCI
-#define CACHE_PHYSADDR_MASK	0x1ffffc00
-
-#endif /* __ASM_CPU_SH2A_CACHE_H */
diff --git a/arch/sh/include/cpu-sh2a/cpu/freq.h b/arch/sh/include/cpu-sh2a/cpu/freq.h
deleted file mode 100644
index fb0813f47043ea..00000000000000
--- a/arch/sh/include/cpu-sh2a/cpu/freq.h
+++ /dev/null
@@ -1,13 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/cpu-sh2a/freq.h
- *
- * Copyright (C) 2006  Yoshinori Sato
- */
-#ifndef __ASM_CPU_SH2A_FREQ_H
-#define __ASM_CPU_SH2A_FREQ_H
-
-#define FREQCR	0xfffe0010
-
-#endif /* __ASM_CPU_SH2A_FREQ_H */
-
diff --git a/arch/sh/include/cpu-sh2a/cpu/rtc.h b/arch/sh/include/cpu-sh2a/cpu/rtc.h
deleted file mode 100644
index 6b6c7ee752debf..00000000000000
--- a/arch/sh/include/cpu-sh2a/cpu/rtc.h
+++ /dev/null
@@ -1,9 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_CPU_SH2A_RTC_H
-#define __ASM_SH_CPU_SH2A_RTC_H
-
-#define rtc_reg_size		sizeof(u16)
-#define RTC_BIT_INVERTED	0
-#define RTC_DEF_CAPABILITIES	RTC_CAP_4_DIGIT_YEAR
-
-#endif /* __ASM_SH_CPU_SH2A_RTC_H */
diff --git a/arch/sh/include/cpu-sh2a/cpu/sh7203.h b/arch/sh/include/cpu-sh2a/cpu/sh7203.h
deleted file mode 100644
index f250adfa46c626..00000000000000
--- a/arch/sh/include/cpu-sh2a/cpu/sh7203.h
+++ /dev/null
@@ -1,144 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH7203_H__
-#define __ASM_SH7203_H__
-
-enum {
-	/* PA */
-	GPIO_PA7, GPIO_PA6, GPIO_PA5, GPIO_PA4,
-	GPIO_PA3, GPIO_PA2, GPIO_PA1, GPIO_PA0,
-
-	/* PB */
-	GPIO_PB12,
-	GPIO_PB11, GPIO_PB10, GPIO_PB9, GPIO_PB8,
-	GPIO_PB7, GPIO_PB6, GPIO_PB5, GPIO_PB4,
-	GPIO_PB3, GPIO_PB2, GPIO_PB1, GPIO_PB0,
-
-	/* PC */
-	GPIO_PC14, GPIO_PC13, GPIO_PC12,
-	GPIO_PC11, GPIO_PC10, GPIO_PC9, GPIO_PC8,
-	GPIO_PC7, GPIO_PC6, GPIO_PC5, GPIO_PC4,
-	GPIO_PC3, GPIO_PC2, GPIO_PC1, GPIO_PC0,
-
-	/* PD */
-	GPIO_PD15, GPIO_PD14, GPIO_PD13, GPIO_PD12,
-	GPIO_PD11, GPIO_PD10, GPIO_PD9, GPIO_PD8,
-	GPIO_PD7, GPIO_PD6, GPIO_PD5, GPIO_PD4,
-	GPIO_PD3, GPIO_PD2, GPIO_PD1, GPIO_PD0,
-
-	/* PE */
-	GPIO_PE15, GPIO_PE14, GPIO_PE13, GPIO_PE12,
-	GPIO_PE11, GPIO_PE10, GPIO_PE9, GPIO_PE8,
-	GPIO_PE7, GPIO_PE6, GPIO_PE5, GPIO_PE4,
-	GPIO_PE3, GPIO_PE2, GPIO_PE1, GPIO_PE0,
-
-	/* PF */
-	GPIO_PF30, GPIO_PF29, GPIO_PF28,
-	GPIO_PF27, GPIO_PF26, GPIO_PF25, GPIO_PF24,
-	GPIO_PF23, GPIO_PF22, GPIO_PF21, GPIO_PF20,
-	GPIO_PF19, GPIO_PF18, GPIO_PF17, GPIO_PF16,
-	GPIO_PF15, GPIO_PF14, GPIO_PF13, GPIO_PF12,
-	GPIO_PF11, GPIO_PF10, GPIO_PF9, GPIO_PF8,
-	GPIO_PF7, GPIO_PF6, GPIO_PF5, GPIO_PF4,
-	GPIO_PF3, GPIO_PF2, GPIO_PF1, GPIO_PF0,
-
-	/* INTC: IRQ and PINT on PB/PD/PE */
-	GPIO_FN_PINT7_PB, GPIO_FN_PINT6_PB, GPIO_FN_PINT5_PB, GPIO_FN_PINT4_PB,
-	GPIO_FN_PINT3_PB, GPIO_FN_PINT2_PB, GPIO_FN_PINT1_PB, GPIO_FN_PINT0_PB,
-	GPIO_FN_PINT7_PD, GPIO_FN_PINT6_PD, GPIO_FN_PINT5_PD, GPIO_FN_PINT4_PD,
-	GPIO_FN_PINT3_PD, GPIO_FN_PINT2_PD, GPIO_FN_PINT1_PD, GPIO_FN_PINT0_PD,
-	GPIO_FN_IRQ7_PB, GPIO_FN_IRQ6_PB, GPIO_FN_IRQ5_PB, GPIO_FN_IRQ4_PB,
-	GPIO_FN_IRQ3_PB, GPIO_FN_IRQ2_PB, GPIO_FN_IRQ1_PB, GPIO_FN_IRQ0_PB,
-	GPIO_FN_IRQ7_PD, GPIO_FN_IRQ6_PD, GPIO_FN_IRQ5_PD, GPIO_FN_IRQ4_PD,
-	GPIO_FN_IRQ3_PD, GPIO_FN_IRQ2_PD, GPIO_FN_IRQ1_PD, GPIO_FN_IRQ0_PD,
-	GPIO_FN_IRQ7_PE, GPIO_FN_IRQ6_PE, GPIO_FN_IRQ5_PE, GPIO_FN_IRQ4_PE,
-	GPIO_FN_IRQ3_PE, GPIO_FN_IRQ2_PE, GPIO_FN_IRQ1_PE, GPIO_FN_IRQ0_PE,
-
-	GPIO_FN_WDTOVF, GPIO_FN_IRQOUT, GPIO_FN_REFOUT, GPIO_FN_IRQOUT_REFOUT,
-	GPIO_FN_UBCTRG,
-
-	/* CAN */
-	GPIO_FN_CTX1, GPIO_FN_CRX1, GPIO_FN_CTX0, GPIO_FN_CTX0_CTX1,
-	GPIO_FN_CRX0, GPIO_FN_CRX0_CRX1,
-
-	/* IIC3 */
-	GPIO_FN_SDA3, GPIO_FN_SCL3,
-	GPIO_FN_SDA2, GPIO_FN_SCL2,
-	GPIO_FN_SDA1, GPIO_FN_SCL1,
-	GPIO_FN_SDA0, GPIO_FN_SCL0,
-
-	/* DMAC */
-	GPIO_FN_TEND0_PD, GPIO_FN_TEND0_PE, GPIO_FN_DACK0_PD,
-	GPIO_FN_DACK0_PE, GPIO_FN_DREQ0_PD, GPIO_FN_DREQ0_PE,
-	GPIO_FN_TEND1_PD, GPIO_FN_TEND1_PE, GPIO_FN_DACK1_PD,
-	GPIO_FN_DACK1_PE, GPIO_FN_DREQ1_PD, GPIO_FN_DREQ1_PE,
-	GPIO_FN_DACK2, GPIO_FN_DREQ2,
-	GPIO_FN_DACK3, GPIO_FN_DREQ3,
-
-	/* ADC */
-	GPIO_FN_ADTRG_PD, GPIO_FN_ADTRG_PE,
-
-	/* BSC */
-	GPIO_FN_D31, GPIO_FN_D30, GPIO_FN_D29, GPIO_FN_D28,
-	GPIO_FN_D27, GPIO_FN_D26, GPIO_FN_D25, GPIO_FN_D24,
-	GPIO_FN_D23, GPIO_FN_D22, GPIO_FN_D21, GPIO_FN_D20,
-	GPIO_FN_D19, GPIO_FN_D18, GPIO_FN_D17, GPIO_FN_D16,
-	GPIO_FN_A25, GPIO_FN_A24, GPIO_FN_A23, GPIO_FN_A22,
-	GPIO_FN_A21, GPIO_FN_CS4, GPIO_FN_MRES, GPIO_FN_BS,
-	GPIO_FN_IOIS16, GPIO_FN_CS1, GPIO_FN_CS6_CE1B,
-	GPIO_FN_CE2B, GPIO_FN_CS5_CE1A, GPIO_FN_CE2A,
-	GPIO_FN_FRAME, GPIO_FN_WAIT, GPIO_FN_RDWR,
-	GPIO_FN_CKE, GPIO_FN_CASU, GPIO_FN_BREQ, GPIO_FN_RASU,
-	GPIO_FN_BACK, GPIO_FN_CASL, GPIO_FN_RASL,
-	GPIO_FN_WE3_DQMUU_AH_ICIO_WR, GPIO_FN_WE2_DQMUL_ICIORD,
-	GPIO_FN_WE1_DQMLU_WE, GPIO_FN_WE0_DQMLL,
-	GPIO_FN_CS3, GPIO_FN_CS2, GPIO_FN_A1, GPIO_FN_A0, GPIO_FN_CS7,
-
-	/* TMU */
-	GPIO_FN_TIOC4D, GPIO_FN_TIOC4C, GPIO_FN_TIOC4B, GPIO_FN_TIOC4A,
-	GPIO_FN_TIOC3D, GPIO_FN_TIOC3C, GPIO_FN_TIOC3B, GPIO_FN_TIOC3A,
-	GPIO_FN_TIOC2B, GPIO_FN_TIOC1B, GPIO_FN_TIOC2A, GPIO_FN_TIOC1A,
-	GPIO_FN_TIOC0D, GPIO_FN_TIOC0C, GPIO_FN_TIOC0B, GPIO_FN_TIOC0A,
-	GPIO_FN_TCLKD_PD, GPIO_FN_TCLKC_PD, GPIO_FN_TCLKB_PD, GPIO_FN_TCLKA_PD,
-	GPIO_FN_TCLKD_PF, GPIO_FN_TCLKC_PF, GPIO_FN_TCLKB_PF, GPIO_FN_TCLKA_PF,
-
-	/* SSU */
-	GPIO_FN_SCS0_PD, GPIO_FN_SSO0_PD, GPIO_FN_SSI0_PD, GPIO_FN_SSCK0_PD,
-	GPIO_FN_SCS0_PF, GPIO_FN_SSO0_PF, GPIO_FN_SSI0_PF, GPIO_FN_SSCK0_PF,
-	GPIO_FN_SCS1_PD, GPIO_FN_SSO1_PD, GPIO_FN_SSI1_PD, GPIO_FN_SSCK1_PD,
-	GPIO_FN_SCS1_PF, GPIO_FN_SSO1_PF, GPIO_FN_SSI1_PF, GPIO_FN_SSCK1_PF,
-
-	/* SCIF */
-	GPIO_FN_TXD0, GPIO_FN_RXD0, GPIO_FN_SCK0,
-	GPIO_FN_TXD1, GPIO_FN_RXD1, GPIO_FN_SCK1,
-	GPIO_FN_TXD2, GPIO_FN_RXD2, GPIO_FN_SCK2,
-	GPIO_FN_RTS3, GPIO_FN_CTS3, GPIO_FN_TXD3, GPIO_FN_RXD3, GPIO_FN_SCK3,
-
-	/* SSI */
-	GPIO_FN_AUDIO_CLK,
-	GPIO_FN_SSIDATA3, GPIO_FN_SSIWS3, GPIO_FN_SSISCK3,
-	GPIO_FN_SSIDATA2, GPIO_FN_SSIWS2, GPIO_FN_SSISCK2,
-	GPIO_FN_SSIDATA1, GPIO_FN_SSIWS1, GPIO_FN_SSISCK1,
-	GPIO_FN_SSIDATA0, GPIO_FN_SSIWS0, GPIO_FN_SSISCK0,
-
-	/* FLCTL */
-	GPIO_FN_FCE, GPIO_FN_FRB,
-	GPIO_FN_NAF7, GPIO_FN_NAF6, GPIO_FN_NAF5, GPIO_FN_NAF4,
-	GPIO_FN_NAF3, GPIO_FN_NAF2, GPIO_FN_NAF1, GPIO_FN_NAF0,
-	GPIO_FN_FSC, GPIO_FN_FOE, GPIO_FN_FCDE, GPIO_FN_FWE,
-
-	/* LCDC */
-	GPIO_FN_LCD_VEPWC, GPIO_FN_LCD_VCPWC,
-	GPIO_FN_LCD_CLK, GPIO_FN_LCD_FLM,
-	GPIO_FN_LCD_M_DISP, GPIO_FN_LCD_CL2,
-	GPIO_FN_LCD_CL1, GPIO_FN_LCD_DON,
-	GPIO_FN_LCD_DATA15, GPIO_FN_LCD_DATA14,
-	GPIO_FN_LCD_DATA13, GPIO_FN_LCD_DATA12,
-	GPIO_FN_LCD_DATA11, GPIO_FN_LCD_DATA10,
-	GPIO_FN_LCD_DATA9, GPIO_FN_LCD_DATA8,
-	GPIO_FN_LCD_DATA7, GPIO_FN_LCD_DATA6,
-	GPIO_FN_LCD_DATA5, GPIO_FN_LCD_DATA4,
-	GPIO_FN_LCD_DATA3, GPIO_FN_LCD_DATA2,
-	GPIO_FN_LCD_DATA1, GPIO_FN_LCD_DATA0,
-};
-
-#endif /* __ASM_SH7203_H__ */
diff --git a/arch/sh/include/cpu-sh2a/cpu/sh7264.h b/arch/sh/include/cpu-sh2a/cpu/sh7264.h
deleted file mode 100644
index 8a1338aaf10a5c..00000000000000
--- a/arch/sh/include/cpu-sh2a/cpu/sh7264.h
+++ /dev/null
@@ -1,169 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH7264_H__
-#define __ASM_SH7264_H__
-
-enum {
-	/* Port A */
-	GPIO_PA3, GPIO_PA2, GPIO_PA1, GPIO_PA0,
-
-	/* Port B */
-	GPIO_PB22, GPIO_PB21, GPIO_PB20,
-	GPIO_PB19, GPIO_PB18, GPIO_PB17, GPIO_PB16,
-	GPIO_PB15, GPIO_PB14, GPIO_PB13, GPIO_PB12,
-	GPIO_PB11, GPIO_PB10, GPIO_PB9, GPIO_PB8,
-	GPIO_PB7, GPIO_PB6, GPIO_PB5, GPIO_PB4,
-	GPIO_PB3, GPIO_PB2, GPIO_PB1,
-
-	/* Port C */
-	GPIO_PC10, GPIO_PC9, GPIO_PC8,
-	GPIO_PC7, GPIO_PC6, GPIO_PC5, GPIO_PC4,
-	GPIO_PC3, GPIO_PC2, GPIO_PC1, GPIO_PC0,
-
-	/* Port D */
-	GPIO_PD15, GPIO_PD14, GPIO_PD13, GPIO_PD12,
-	GPIO_PD11, GPIO_PD10, GPIO_PD9, GPIO_PD8,
-	GPIO_PD7, GPIO_PD6, GPIO_PD5, GPIO_PD4,
-	GPIO_PD3, GPIO_PD2, GPIO_PD1, GPIO_PD0,
-
-	/* Port E */
-	GPIO_PE5, GPIO_PE4,
-	GPIO_PE3, GPIO_PE2, GPIO_PE1, GPIO_PE0,
-
-	/* Port F */
-	GPIO_PF12,
-	GPIO_PF11, GPIO_PF10, GPIO_PF9, GPIO_PF8,
-	GPIO_PF7, GPIO_PF6, GPIO_PF5, GPIO_PF4,
-	GPIO_PF3, GPIO_PF2, GPIO_PF1, GPIO_PF0,
-
-	/* Port G */
-	GPIO_PG24,
-	GPIO_PG23, GPIO_PG22, GPIO_PG21, GPIO_PG20,
-	GPIO_PG19, GPIO_PG18, GPIO_PG17, GPIO_PG16,
-	GPIO_PG15, GPIO_PG14, GPIO_PG13, GPIO_PG12,
-	GPIO_PG11, GPIO_PG10, GPIO_PG9, GPIO_PG8,
-	GPIO_PG7, GPIO_PG6, GPIO_PG5, GPIO_PG4,
-	GPIO_PG3, GPIO_PG2, GPIO_PG1, GPIO_PG0,
-
-	/* Port H - Port H does not have a Data Register */
-
-	/* Port I - not on device */
-
-	/* Port J */
-	GPIO_PJ11, GPIO_PJ10, GPIO_PJ9, GPIO_PJ8,
-	GPIO_PJ7, GPIO_PJ6, GPIO_PJ5, GPIO_PJ4,
-	GPIO_PJ3, GPIO_PJ2, GPIO_PJ1, GPIO_PJ0,
-
-	/* Port K */
-	GPIO_PK11, GPIO_PK10, GPIO_PK9, GPIO_PK8,
-	GPIO_PK7, GPIO_PK6, GPIO_PK5, GPIO_PK4,
-	GPIO_PK3, GPIO_PK2, GPIO_PK1, GPIO_PK0,
-
-	/* INTC: IRQ and PINT on PB/PD/PE */
-	GPIO_FN_PINT7_PG, GPIO_FN_PINT6_PG, GPIO_FN_PINT5_PG, GPIO_FN_PINT4_PG,
-	GPIO_FN_PINT3_PG, GPIO_FN_PINT2_PG, GPIO_FN_PINT1_PG,
-
-	GPIO_FN_IRQ7_PC, GPIO_FN_IRQ6_PC, GPIO_FN_IRQ5_PC, GPIO_FN_IRQ4_PC,
-	GPIO_FN_IRQ3_PG, GPIO_FN_IRQ2_PG, GPIO_FN_IRQ1_PJ, GPIO_FN_IRQ0_PJ,
-	GPIO_FN_IRQ3_PE, GPIO_FN_IRQ2_PE, GPIO_FN_IRQ1_PE, GPIO_FN_IRQ0_PE,
-
-	/* WDT */
-	GPIO_FN_WDTOVF,
-
-	/* CAN */
-	GPIO_FN_CTX1, GPIO_FN_CRX1, GPIO_FN_CTX0, GPIO_FN_CTX0_CTX1,
-	GPIO_FN_CRX0, GPIO_FN_CRX0_CRX1,
-
-	/* DMAC */
-	GPIO_FN_TEND0, GPIO_FN_DACK0, GPIO_FN_DREQ0,
-	GPIO_FN_TEND1, GPIO_FN_DACK1, GPIO_FN_DREQ1,
-
-	/* ADC */
-	GPIO_FN_ADTRG,
-
-	/* BSC */
-
-	GPIO_FN_A25, GPIO_FN_A24,
-	GPIO_FN_A23, GPIO_FN_A22, GPIO_FN_A21, GPIO_FN_A20,
-	GPIO_FN_A19, GPIO_FN_A18, GPIO_FN_A17, GPIO_FN_A16,
-	GPIO_FN_A15, GPIO_FN_A14, GPIO_FN_A13, GPIO_FN_A12,
-	GPIO_FN_A11, GPIO_FN_A10, GPIO_FN_A9, GPIO_FN_A8,
-	GPIO_FN_A7, GPIO_FN_A6, GPIO_FN_A5, GPIO_FN_A4,
-	GPIO_FN_A3, GPIO_FN_A2, GPIO_FN_A1, GPIO_FN_A0,
-	GPIO_FN_D15, GPIO_FN_D14, GPIO_FN_D13, GPIO_FN_D12,
-	GPIO_FN_D11, GPIO_FN_D10, GPIO_FN_D9, GPIO_FN_D8,
-	GPIO_FN_D7, GPIO_FN_D6, GPIO_FN_D5, GPIO_FN_D4,
-	GPIO_FN_D3, GPIO_FN_D2, GPIO_FN_D1, GPIO_FN_D0,
-
-	GPIO_FN_BS,
-	GPIO_FN_CS4, GPIO_FN_CS3, GPIO_FN_CS2, GPIO_FN_CS1, GPIO_FN_CS0,
-	GPIO_FN_CS6CE1B, GPIO_FN_CS5CE1A,
-	GPIO_FN_CE2A, GPIO_FN_CE2B,
-	GPIO_FN_RD, GPIO_FN_RDWR,
-	GPIO_FN_ICIOWRAH, GPIO_FN_ICIORD,
-	GPIO_FN_WE1DQMUWE, GPIO_FN_WE0DQML,
-	GPIO_FN_RAS, GPIO_FN_CAS, GPIO_FN_CKE,
-	GPIO_FN_WAIT, GPIO_FN_BREQ, GPIO_FN_BACK,
-	GPIO_FN_IOIS16,
-
-	/* TMU */
-	GPIO_FN_TIOC4D, GPIO_FN_TIOC4C, GPIO_FN_TIOC4B, GPIO_FN_TIOC4A,
-	GPIO_FN_TIOC3D, GPIO_FN_TIOC3C, GPIO_FN_TIOC3B, GPIO_FN_TIOC3A,
-	GPIO_FN_TIOC2B, GPIO_FN_TIOC1B, GPIO_FN_TIOC2A, GPIO_FN_TIOC1A,
-	GPIO_FN_TIOC0D, GPIO_FN_TIOC0C, GPIO_FN_TIOC0B, GPIO_FN_TIOC0A,
-	GPIO_FN_TCLKD, GPIO_FN_TCLKC, GPIO_FN_TCLKB, GPIO_FN_TCLKA,
-
-	/* SCIF */
-	GPIO_FN_SCK0, GPIO_FN_SCK1, GPIO_FN_SCK2, GPIO_FN_SCK3,
-	GPIO_FN_RXD0, GPIO_FN_RXD1, GPIO_FN_RXD2, GPIO_FN_RXD3,
-	GPIO_FN_TXD0, GPIO_FN_TXD1, GPIO_FN_TXD2, GPIO_FN_TXD3,
-	GPIO_FN_RXD4, GPIO_FN_RXD5, GPIO_FN_RXD6, GPIO_FN_RXD7,
-	GPIO_FN_TXD4, GPIO_FN_TXD5, GPIO_FN_TXD6, GPIO_FN_TXD7,
-	GPIO_FN_RTS1, GPIO_FN_RTS3, GPIO_FN_CTS1, GPIO_FN_CTS3,
-
-	/* RSPI */
-	GPIO_FN_RSPCK0, GPIO_FN_MOSI0,
-	GPIO_FN_MISO0_PF12, GPIO_FN_MISO1,
-	GPIO_FN_SSL00,
-	GPIO_FN_RSPCK1, GPIO_FN_MOSI1,
-	GPIO_FN_MISO1_PG19, GPIO_FN_SSL10,
-
-	/* IIC3 */
-	GPIO_FN_SCL0, GPIO_FN_SCL1, GPIO_FN_SCL2,
-	GPIO_FN_SDA2, GPIO_FN_SDA1, GPIO_FN_SDA0,
-
-	/* SSI */
-	GPIO_FN_SSISCK0, GPIO_FN_SSIWS0, GPIO_FN_SSITXD0, GPIO_FN_SSIRXD0,
-	GPIO_FN_SSIWS1, GPIO_FN_SSIWS2, GPIO_FN_SSIWS3,
-	GPIO_FN_SSISCK1, GPIO_FN_SSISCK2, GPIO_FN_SSISCK3,
-	GPIO_FN_SSIDATA1, GPIO_FN_SSIDATA2, GPIO_FN_SSIDATA3,
-	GPIO_FN_AUDIO_CLK,
-
-	/* SIOF */
-	GPIO_FN_SIOFTXD, GPIO_FN_SIOFRXD, GPIO_FN_SIOFSYNC, GPIO_FN_SIOFSCK,
-
-	/* SPDIF */
-	GPIO_FN_SPDIF_IN,
-	GPIO_FN_SPDIF_OUT,
-
-	/* NANDFMC */ /* NOTE Controller is not available in boot mode 0 */
-	GPIO_FN_FCE,
-	GPIO_FN_FRB,
-
-	/* VDC3 */
-	GPIO_FN_DV_CLK, GPIO_FN_DV_VSYNC, GPIO_FN_DV_HSYNC,
-	GPIO_FN_DV_DATA7, GPIO_FN_DV_DATA6, GPIO_FN_DV_DATA5, GPIO_FN_DV_DATA4,
-	GPIO_FN_DV_DATA3, GPIO_FN_DV_DATA2, GPIO_FN_DV_DATA1, GPIO_FN_DV_DATA0,
-	GPIO_FN_LCD_CLK, GPIO_FN_LCD_EXTCLK,
-	GPIO_FN_LCD_VSYNC, GPIO_FN_LCD_HSYNC, GPIO_FN_LCD_DE,
-	GPIO_FN_LCD_DATA15, GPIO_FN_LCD_DATA14,
-	GPIO_FN_LCD_DATA13, GPIO_FN_LCD_DATA12,
-	GPIO_FN_LCD_DATA11, GPIO_FN_LCD_DATA10,
-	GPIO_FN_LCD_DATA9, GPIO_FN_LCD_DATA8,
-	GPIO_FN_LCD_DATA7, GPIO_FN_LCD_DATA6,
-	GPIO_FN_LCD_DATA5, GPIO_FN_LCD_DATA4,
-	GPIO_FN_LCD_DATA3, GPIO_FN_LCD_DATA2,
-	GPIO_FN_LCD_DATA1, GPIO_FN_LCD_DATA0,
-	GPIO_FN_LCD_M_DISP,
-};
-
-#endif /* __ASM_SH7264_H__ */
diff --git a/arch/sh/include/cpu-sh2a/cpu/sh7269.h b/arch/sh/include/cpu-sh2a/cpu/sh7269.h
deleted file mode 100644
index fece521c74b30d..00000000000000
--- a/arch/sh/include/cpu-sh2a/cpu/sh7269.h
+++ /dev/null
@@ -1,213 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH7269_H__
-#define __ASM_SH7269_H__
-
-enum {
-	/* Port A */
-	GPIO_PA1, GPIO_PA0,
-
-	/* Port B */
-	GPIO_PB22, GPIO_PB21, GPIO_PB20,
-	GPIO_PB19, GPIO_PB18, GPIO_PB17, GPIO_PB16,
-	GPIO_PB15, GPIO_PB14, GPIO_PB13, GPIO_PB12,
-	GPIO_PB11, GPIO_PB10, GPIO_PB9, GPIO_PB8,
-	GPIO_PB7, GPIO_PB6, GPIO_PB5, GPIO_PB4,
-	GPIO_PB3, GPIO_PB2, GPIO_PB1,
-
-	/* Port C */
-	GPIO_PC8,
-	GPIO_PC7, GPIO_PC6, GPIO_PC5, GPIO_PC4,
-	GPIO_PC3, GPIO_PC2, GPIO_PC1, GPIO_PC0,
-
-	/* Port D */
-	GPIO_PD15, GPIO_PD14, GPIO_PD13, GPIO_PD12,
-	GPIO_PD11, GPIO_PD10, GPIO_PD9, GPIO_PD8,
-	GPIO_PD7, GPIO_PD6, GPIO_PD5, GPIO_PD4,
-	GPIO_PD3, GPIO_PD2, GPIO_PD1, GPIO_PD0,
-
-	/* Port E */
-	GPIO_PE7, GPIO_PE6, GPIO_PE5, GPIO_PE4,
-	GPIO_PE3, GPIO_PE2, GPIO_PE1, GPIO_PE0,
-
-	/* Port F */
-	GPIO_PF23, GPIO_PF22, GPIO_PF21, GPIO_PF20,
-	GPIO_PF19, GPIO_PF18, GPIO_PF17, GPIO_PF16,
-	GPIO_PF15, GPIO_PF14, GPIO_PF13, GPIO_PF12,
-	GPIO_PF11, GPIO_PF10, GPIO_PF9, GPIO_PF8,
-	GPIO_PF7, GPIO_PF6, GPIO_PF5, GPIO_PF4,
-	GPIO_PF3, GPIO_PF2, GPIO_PF1, GPIO_PF0,
-
-	/* Port G */
-	GPIO_PG27, GPIO_PG26, GPIO_PG25, GPIO_PG24,
-	GPIO_PG23, GPIO_PG22, GPIO_PG21, GPIO_PG20,
-	GPIO_PG19, GPIO_PG18, GPIO_PG17, GPIO_PG16,
-	GPIO_PG15, GPIO_PG14, GPIO_PG13, GPIO_PG12,
-	GPIO_PG11, GPIO_PG10, GPIO_PG9, GPIO_PG8,
-	GPIO_PG7, GPIO_PG6, GPIO_PG5, GPIO_PG4,
-	GPIO_PG3, GPIO_PG2, GPIO_PG1, GPIO_PG0,
-
-	/* Port H - Port H does not have a Data Register */
-
-	/* Port I - not on device */
-
-	/* Port J */
-	GPIO_PJ31, GPIO_PJ30, GPIO_PJ29, GPIO_PJ28,
-	GPIO_PJ27, GPIO_PJ26, GPIO_PJ25, GPIO_PJ24,
-	GPIO_PJ23, GPIO_PJ22, GPIO_PJ21, GPIO_PJ20,
-	GPIO_PJ19, GPIO_PJ18, GPIO_PJ17, GPIO_PJ16,
-	GPIO_PJ15, GPIO_PJ14, GPIO_PJ13, GPIO_PJ12,
-	GPIO_PJ11, GPIO_PJ10, GPIO_PJ9, GPIO_PJ8,
-	GPIO_PJ7, GPIO_PJ6, GPIO_PJ5, GPIO_PJ4,
-	GPIO_PJ3, GPIO_PJ2, GPIO_PJ1, GPIO_PJ0,
-
-	/* INTC: IRQ and PINT */
-	GPIO_FN_IRQ7_PG, GPIO_FN_IRQ6_PG, GPIO_FN_IRQ5_PG, GPIO_FN_IRQ4_PG,
-	GPIO_FN_IRQ3_PG, GPIO_FN_IRQ2_PG, GPIO_FN_IRQ1_PG, GPIO_FN_IRQ0_PG,
-	GPIO_FN_IRQ7_PF, GPIO_FN_IRQ6_PF, GPIO_FN_IRQ5_PF, GPIO_FN_IRQ4_PF,
-	GPIO_FN_IRQ3_PJ, GPIO_FN_IRQ2_PJ, GPIO_FN_IRQ1_PJ, GPIO_FN_IRQ0_PJ,
-	GPIO_FN_IRQ1_PC, GPIO_FN_IRQ0_PC,
-
-	GPIO_FN_PINT7_PG, GPIO_FN_PINT6_PG, GPIO_FN_PINT5_PG, GPIO_FN_PINT4_PG,
-	GPIO_FN_PINT3_PG, GPIO_FN_PINT2_PG, GPIO_FN_PINT1_PG, GPIO_FN_PINT0_PG,
-	GPIO_FN_PINT7_PH, GPIO_FN_PINT6_PH, GPIO_FN_PINT5_PH, GPIO_FN_PINT4_PH,
-	GPIO_FN_PINT3_PH, GPIO_FN_PINT2_PH, GPIO_FN_PINT1_PH, GPIO_FN_PINT0_PH,
-	GPIO_FN_PINT7_PJ, GPIO_FN_PINT6_PJ, GPIO_FN_PINT5_PJ, GPIO_FN_PINT4_PJ,
-	GPIO_FN_PINT3_PJ, GPIO_FN_PINT2_PJ, GPIO_FN_PINT1_PJ, GPIO_FN_PINT0_PJ,
-
-	/* WDT */
-	GPIO_FN_WDTOVF,
-
-	/* CAN */
-	GPIO_FN_CTX2, GPIO_FN_CRX2,
-	GPIO_FN_CTX1, GPIO_FN_CRX1,
-	GPIO_FN_CTX0, GPIO_FN_CRX0,
-	GPIO_FN_CTX0_CTX1, GPIO_FN_CRX0_CRX1,
-	GPIO_FN_CTX0_CTX1_CTX2, GPIO_FN_CRX0_CRX1_CRX2,
-	GPIO_FN_CTX2_PJ21, GPIO_FN_CRX2_PJ20,
-	GPIO_FN_CTX1_PJ23, GPIO_FN_CRX1_PJ22,
-	GPIO_FN_CTX0_CTX1_PJ23, GPIO_FN_CRX0_CRX1_PJ22,
-	GPIO_FN_CTX0_CTX1_CTX2_PJ21, GPIO_FN_CRX0_CRX1_CRX2_PJ20,
-
-	/* DMAC */
-	GPIO_FN_TEND0, GPIO_FN_DACK0, GPIO_FN_DREQ0,
-	GPIO_FN_TEND1, GPIO_FN_DACK1, GPIO_FN_DREQ1,
-
-	/* ADC */
-	GPIO_FN_ADTRG,
-
-	/* BSC */
-	GPIO_FN_A25, GPIO_FN_A24,
-	GPIO_FN_A23, GPIO_FN_A22, GPIO_FN_A21, GPIO_FN_A20,
-	GPIO_FN_A19, GPIO_FN_A18, GPIO_FN_A17, GPIO_FN_A16,
-	GPIO_FN_A15, GPIO_FN_A14, GPIO_FN_A13, GPIO_FN_A12,
-	GPIO_FN_A11, GPIO_FN_A10, GPIO_FN_A9, GPIO_FN_A8,
-	GPIO_FN_A7, GPIO_FN_A6, GPIO_FN_A5, GPIO_FN_A4,
-	GPIO_FN_A3, GPIO_FN_A2, GPIO_FN_A1, GPIO_FN_A0,
-	GPIO_FN_D15, GPIO_FN_D14, GPIO_FN_D13, GPIO_FN_D12,
-	GPIO_FN_D11, GPIO_FN_D10, GPIO_FN_D9, GPIO_FN_D8,
-	GPIO_FN_D7, GPIO_FN_D6, GPIO_FN_D5, GPIO_FN_D4,
-	GPIO_FN_D3, GPIO_FN_D2, GPIO_FN_D1, GPIO_FN_D0,
-
-	GPIO_FN_BS,
-	GPIO_FN_CS4, GPIO_FN_CS3, GPIO_FN_CS2, GPIO_FN_CS1, GPIO_FN_CS0,
-	GPIO_FN_CS5CE1A,
-	GPIO_FN_CE2A, GPIO_FN_CE2B,
-	GPIO_FN_RD, GPIO_FN_RDWR,
-	GPIO_FN_WE3ICIOWRAHDQMUU, GPIO_FN_WE2ICIORDDQMUL,
-	GPIO_FN_WE1DQMUWE, GPIO_FN_WE0DQML,
-	GPIO_FN_RAS, GPIO_FN_CAS, GPIO_FN_CKE,
-	GPIO_FN_WAIT, GPIO_FN_BREQ, GPIO_FN_BACK,
-	GPIO_FN_IOIS16,
-
-	/* TMU */
-	GPIO_FN_TIOC4D, GPIO_FN_TIOC4C, GPIO_FN_TIOC4B, GPIO_FN_TIOC4A,
-	GPIO_FN_TIOC3D, GPIO_FN_TIOC3C, GPIO_FN_TIOC3B, GPIO_FN_TIOC3A,
-	GPIO_FN_TIOC2B, GPIO_FN_TIOC1B, GPIO_FN_TIOC2A, GPIO_FN_TIOC1A,
-	GPIO_FN_TIOC0D, GPIO_FN_TIOC0C, GPIO_FN_TIOC0B, GPIO_FN_TIOC0A,
-	GPIO_FN_TCLKD, GPIO_FN_TCLKC, GPIO_FN_TCLKB, GPIO_FN_TCLKA,
-
-	/* SCIF */
-	GPIO_FN_SCK0, GPIO_FN_RXD0, GPIO_FN_TXD0,
-	GPIO_FN_SCK1, GPIO_FN_RXD1, GPIO_FN_TXD1, GPIO_FN_RTS1, GPIO_FN_CTS1,
-	GPIO_FN_SCK2, GPIO_FN_RXD2, GPIO_FN_TXD2,
-	GPIO_FN_SCK3, GPIO_FN_RXD3, GPIO_FN_TXD3,
-	GPIO_FN_SCK4, GPIO_FN_RXD4, GPIO_FN_TXD4,
-	GPIO_FN_SCK5, GPIO_FN_RXD5, GPIO_FN_TXD5, GPIO_FN_RTS5, GPIO_FN_CTS5,
-	GPIO_FN_SCK6, GPIO_FN_RXD6, GPIO_FN_TXD6,
-	GPIO_FN_SCK7, GPIO_FN_RXD7, GPIO_FN_TXD7, GPIO_FN_RTS7, GPIO_FN_CTS7,
-
-	/* RSPI */
-	GPIO_FN_MISO0_PJ19, GPIO_FN_MISO0_PB20,
-	GPIO_FN_MOSI0_PJ18, GPIO_FN_MOSI0_PB19,
-	GPIO_FN_SSL00_PJ17, GPIO_FN_SSL00_PB18,
-	GPIO_FN_RSPCK0_PJ16, GPIO_FN_RSPCK0_PB17,
-	GPIO_FN_RSPCK1, GPIO_FN_MOSI1,
-	GPIO_FN_MISO1, GPIO_FN_SSL10,
-
-	/* IIC3 */
-	GPIO_FN_SCL0, GPIO_FN_SCL1, GPIO_FN_SCL2,
-	GPIO_FN_SDA2, GPIO_FN_SDA1, GPIO_FN_SDA0,
-
-	/* SSI */
-	GPIO_FN_SSISCK0, GPIO_FN_SSIWS0, GPIO_FN_SSITXD0, GPIO_FN_SSIRXD0,
-	GPIO_FN_SSIWS1, GPIO_FN_SSIWS2, GPIO_FN_SSIWS3,
-	GPIO_FN_SSISCK1, GPIO_FN_SSISCK2, GPIO_FN_SSISCK3,
-	GPIO_FN_SSIDATA1, GPIO_FN_SSIDATA2, GPIO_FN_SSIDATA3,
-	GPIO_FN_AUDIO_CLK,
-	GPIO_FN_AUDIO_XOUT,
-
-	/* SIOF */
-	GPIO_FN_SIOFTXD, GPIO_FN_SIOFRXD, GPIO_FN_SIOFSYNC, GPIO_FN_SIOFSCK,
-
-	/* SPDIF */
-	GPIO_FN_SPDIF_IN,
-	GPIO_FN_SPDIF_OUT,
-
-	/* NANDFMC  */ /* NOTE Controller is not available in boot mode 0 */
-	GPIO_FN_FCE,
-	GPIO_FN_FRB,
-
-	/* VDC */
-	GPIO_FN_DV_CLK, GPIO_FN_DV_VSYNC, GPIO_FN_DV_HSYNC,
-	GPIO_FN_DV_DATA23, GPIO_FN_DV_DATA22,
-	GPIO_FN_DV_DATA21, GPIO_FN_DV_DATA20,
-	GPIO_FN_DV_DATA19, GPIO_FN_DV_DATA18,
-	GPIO_FN_DV_DATA17, GPIO_FN_DV_DATA16,
-	GPIO_FN_DV_DATA15, GPIO_FN_DV_DATA14,
-	GPIO_FN_DV_DATA13, GPIO_FN_DV_DATA12,
-	GPIO_FN_DV_DATA11, GPIO_FN_DV_DATA10,
-	GPIO_FN_DV_DATA9, GPIO_FN_DV_DATA8,
-	GPIO_FN_DV_DATA7, GPIO_FN_DV_DATA6,
-	GPIO_FN_DV_DATA5, GPIO_FN_DV_DATA4,
-	GPIO_FN_DV_DATA3, GPIO_FN_DV_DATA2,
-	GPIO_FN_DV_DATA1, GPIO_FN_DV_DATA0,
-	GPIO_FN_LCD_CLK, GPIO_FN_LCD_EXTCLK,
-	GPIO_FN_LCD_VSYNC, GPIO_FN_LCD_HSYNC, GPIO_FN_LCD_DE,
-	GPIO_FN_LCD_DATA23_PG23, GPIO_FN_LCD_DATA22_PG22,
-	GPIO_FN_LCD_DATA21_PG21, GPIO_FN_LCD_DATA20_PG20,
-	GPIO_FN_LCD_DATA19_PG19, GPIO_FN_LCD_DATA18_PG18,
-	GPIO_FN_LCD_DATA17_PG17, GPIO_FN_LCD_DATA16_PG16,
-	GPIO_FN_LCD_DATA15_PG15, GPIO_FN_LCD_DATA14_PG14,
-	GPIO_FN_LCD_DATA13_PG13, GPIO_FN_LCD_DATA12_PG12,
-	GPIO_FN_LCD_DATA11_PG11, GPIO_FN_LCD_DATA10_PG10,
-	GPIO_FN_LCD_DATA9_PG9, GPIO_FN_LCD_DATA8_PG8,
-	GPIO_FN_LCD_DATA7_PG7, GPIO_FN_LCD_DATA6_PG6,
-	GPIO_FN_LCD_DATA5_PG5, GPIO_FN_LCD_DATA4_PG4,
-	GPIO_FN_LCD_DATA3_PG3, GPIO_FN_LCD_DATA2_PG2,
-	GPIO_FN_LCD_DATA1_PG1, GPIO_FN_LCD_DATA0_PG0,
-	GPIO_FN_LCD_DATA23_PJ23, GPIO_FN_LCD_DATA22_PJ22,
-	GPIO_FN_LCD_DATA21_PJ21, GPIO_FN_LCD_DATA20_PJ20,
-	GPIO_FN_LCD_DATA19_PJ19, GPIO_FN_LCD_DATA18_PJ18,
-	GPIO_FN_LCD_DATA17_PJ17, GPIO_FN_LCD_DATA16_PJ16,
-	GPIO_FN_LCD_DATA15_PJ15, GPIO_FN_LCD_DATA14_PJ14,
-	GPIO_FN_LCD_DATA13_PJ13, GPIO_FN_LCD_DATA12_PJ12,
-	GPIO_FN_LCD_DATA11_PJ11, GPIO_FN_LCD_DATA10_PJ10,
-	GPIO_FN_LCD_DATA9_PJ9, GPIO_FN_LCD_DATA8_PJ8,
-	GPIO_FN_LCD_DATA7_PJ7, GPIO_FN_LCD_DATA6_PJ6,
-	GPIO_FN_LCD_DATA5_PJ5, GPIO_FN_LCD_DATA4_PJ4,
-	GPIO_FN_LCD_DATA3_PJ3, GPIO_FN_LCD_DATA2_PJ2,
-	GPIO_FN_LCD_DATA1_PJ1, GPIO_FN_LCD_DATA0_PJ0,
-	GPIO_FN_LCD_M_DISP,
-};
-
-#endif /* __ASM_SH7269_H__ */
diff --git a/arch/sh/include/cpu-sh2a/cpu/watchdog.h b/arch/sh/include/cpu-sh2a/cpu/watchdog.h
deleted file mode 100644
index 8f932b733c6748..00000000000000
--- a/arch/sh/include/cpu-sh2a/cpu/watchdog.h
+++ /dev/null
@@ -1,2 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <cpu-sh2/cpu/watchdog.h>
diff --git a/arch/sh/include/cpu-sh3/cpu/adc.h b/arch/sh/include/cpu-sh3/cpu/adc.h
deleted file mode 100644
index 2ee206c9bf1aa8..00000000000000
--- a/arch/sh/include/cpu-sh3/cpu/adc.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_CPU_SH3_ADC_H
-#define __ASM_CPU_SH3_ADC_H
-
-/*
- * Copyright (C) 2004  Andriy Skulysh
- */
-
-
-#define ADDRAH	0xa4000080
-#define ADDRAL	0xa4000082
-#define ADDRBH	0xa4000084
-#define ADDRBL	0xa4000086
-#define ADDRCH	0xa4000088
-#define ADDRCL	0xa400008a
-#define ADDRDH	0xa400008c
-#define ADDRDL	0xa400008e
-#define ADCSR	0xa4000090
-
-#define ADCSR_ADF	0x80
-#define ADCSR_ADIE	0x40
-#define ADCSR_ADST	0x20
-#define ADCSR_MULTI	0x10
-#define ADCSR_CKS	0x08
-#define ADCSR_CH_MASK	0x07
-
-#define ADCR	0xa4000092
-
-#endif /* __ASM_CPU_SH3_ADC_H */
diff --git a/arch/sh/include/cpu-sh3/cpu/cache.h b/arch/sh/include/cpu-sh3/cpu/cache.h
deleted file mode 100644
index f571248269430c..00000000000000
--- a/arch/sh/include/cpu-sh3/cpu/cache.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/cpu-sh3/cache.h
- *
- * Copyright (C) 1999 Niibe Yutaka
- */
-#ifndef __ASM_CPU_SH3_CACHE_H
-#define __ASM_CPU_SH3_CACHE_H
-
-#define L1_CACHE_SHIFT	4
-
-#define SH_CACHE_VALID		1
-#define SH_CACHE_UPDATED	2
-#define SH_CACHE_COMBINED	4
-#define SH_CACHE_ASSOC		8
-
-#define SH_CCR		0xffffffec	/* Address of Cache Control Register */
-
-#define CCR_CACHE_CE	0x01	/* Cache Enable */
-#define CCR_CACHE_WT	0x02	/* Write-Through (for P0,U0,P3) (else writeback) */
-#define CCR_CACHE_CB	0x04	/* Write-Back (for P1) (else writethrough) */
-#define CCR_CACHE_CF	0x08	/* Cache Flush */
-#define CCR_CACHE_ORA	0x20	/* RAM mode */
-
-#define CACHE_OC_ADDRESS_ARRAY	0xf0000000
-#define CACHE_PHYSADDR_MASK	0x1ffffc00
-
-#define CCR_CACHE_ENABLE	CCR_CACHE_CE
-#define CCR_CACHE_INVALIDATE	CCR_CACHE_CF
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7705) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7710) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7720) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7721)
-#define CCR3_REG	0xa40000b4
-#define CCR_CACHE_16KB  0x00010000
-#define CCR_CACHE_32KB	0x00020000
-#endif
-
-#endif /* __ASM_CPU_SH3_CACHE_H */
diff --git a/arch/sh/include/cpu-sh3/cpu/dac.h b/arch/sh/include/cpu-sh3/cpu/dac.h
deleted file mode 100644
index fd02331608a8d6..00000000000000
--- a/arch/sh/include/cpu-sh3/cpu/dac.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_CPU_SH3_DAC_H
-#define __ASM_CPU_SH3_DAC_H
-
-/*
- * Copyright (C) 2003  Andriy Skulysh
- */
-
-
-#define DADR0	0xa40000a0
-#define DADR1	0xa40000a2
-#define DACR	0xa40000a4
-#define DACR_DAOE1	0x80
-#define DACR_DAOE0	0x40
-#define DACR_DAE	0x20
-
-
-static __inline__ void sh_dac_enable(int channel)
-{
-	unsigned char v;
-	v = __raw_readb(DACR);
-	if(channel) v |= DACR_DAOE1;
-	else v |= DACR_DAOE0;
-	__raw_writeb(v,DACR);
-}
-
-static __inline__ void sh_dac_disable(int channel)
-{
-	unsigned char v;
-	v = __raw_readb(DACR);
-	if(channel) v &= ~DACR_DAOE1;
-	else v &= ~DACR_DAOE0;
-	__raw_writeb(v,DACR);
-}
-
-static __inline__ void sh_dac_output(u8 value, int channel)
-{
-	if(channel) __raw_writeb(value,DADR1);
-	else __raw_writeb(value,DADR0);
-}
-
-#endif /* __ASM_CPU_SH3_DAC_H */
diff --git a/arch/sh/include/cpu-sh3/cpu/dma-register.h b/arch/sh/include/cpu-sh3/cpu/dma-register.h
deleted file mode 100644
index c0f921fb4edcd1..00000000000000
--- a/arch/sh/include/cpu-sh3/cpu/dma-register.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * SH3 CPU-specific DMA definitions, used by both DMA drivers
- *
- * Copyright (C) 2010 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
- */
-#ifndef CPU_DMA_REGISTER_H
-#define CPU_DMA_REGISTER_H
-
-#define CHCR_TS_LOW_MASK	0x18
-#define CHCR_TS_LOW_SHIFT	3
-#define CHCR_TS_HIGH_MASK	0
-#define CHCR_TS_HIGH_SHIFT	0
-
-#define DMAOR_INIT	DMAOR_DME
-
-/*
- * The SuperH DMAC supports a number of transmit sizes, we list them here,
- * with their respective values as they appear in the CHCR registers.
- */
-enum {
-	XMIT_SZ_8BIT,
-	XMIT_SZ_16BIT,
-	XMIT_SZ_32BIT,
-	XMIT_SZ_128BIT,
-};
-
-/* log2(size / 8) - used to calculate number of transfers */
-#define TS_SHIFT {			\
-	[XMIT_SZ_8BIT]		= 0,	\
-	[XMIT_SZ_16BIT]		= 1,	\
-	[XMIT_SZ_32BIT]		= 2,	\
-	[XMIT_SZ_128BIT]	= 4,	\
-}
-
-#define TS_INDEX2VAL(i)	(((i) & 3) << CHCR_TS_LOW_SHIFT)
-
-#endif
diff --git a/arch/sh/include/cpu-sh3/cpu/dma.h b/arch/sh/include/cpu-sh3/cpu/dma.h
deleted file mode 100644
index cd139681af4b6f..00000000000000
--- a/arch/sh/include/cpu-sh3/cpu/dma.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_CPU_SH3_DMA_H
-#define __ASM_CPU_SH3_DMA_H
-
-#include <linux/sh_intc.h>
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7720) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7721) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7710) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7712)
-#define SH_DMAC_BASE0	0xa4010020
-#else /* SH7705/06/07/09 */
-#define SH_DMAC_BASE0	0xa4000020
-#endif
-
-#define DMTE0_IRQ	evt2irq(0x800)
-#define DMTE4_IRQ	evt2irq(0xb80)
-
-#endif /* __ASM_CPU_SH3_DMA_H */
diff --git a/arch/sh/include/cpu-sh3/cpu/freq.h b/arch/sh/include/cpu-sh3/cpu/freq.h
deleted file mode 100644
index 7290f02b717330..00000000000000
--- a/arch/sh/include/cpu-sh3/cpu/freq.h
+++ /dev/null
@@ -1,24 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/cpu-sh3/freq.h
- *
- * Copyright (C) 2002, 2003 Paul Mundt
- */
-#ifndef __ASM_CPU_SH3_FREQ_H
-#define __ASM_CPU_SH3_FREQ_H
-
-#ifdef CONFIG_CPU_SUBTYPE_SH7712
-#define FRQCR			0xA415FF80
-#else
-#define FRQCR			0xffffff80
-#endif
-
-#define MIN_DIVISOR_NR		0
-#define MAX_DIVISOR_NR		4
-
-#define FRQCR_CKOEN	0x0100
-#define FRQCR_PLLEN	0x0080
-#define FRQCR_PSTBY	0x0040
-
-#endif /* __ASM_CPU_SH3_FREQ_H */
-
diff --git a/arch/sh/include/cpu-sh3/cpu/gpio.h b/arch/sh/include/cpu-sh3/cpu/gpio.h
deleted file mode 100644
index aeb0588ace980c..00000000000000
--- a/arch/sh/include/cpu-sh3/cpu/gpio.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- *  include/asm-sh/cpu-sh3/gpio.h
- *
- *  Copyright (C) 2007  Markus Brunner, Mark Jonas
- *
- *  Addresses for the Pin Function Controller
- */
-#ifndef _CPU_SH3_GPIO_H
-#define _CPU_SH3_GPIO_H
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7720) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7721)
-
-/* Control registers */
-#define PORT_PACR	0xA4050100UL
-#define PORT_PBCR	0xA4050102UL
-#define PORT_PCCR	0xA4050104UL
-#define PORT_PDCR	0xA4050106UL
-#define PORT_PECR	0xA4050108UL
-#define PORT_PFCR	0xA405010AUL
-#define PORT_PGCR	0xA405010CUL
-#define PORT_PHCR	0xA405010EUL
-#define PORT_PJCR	0xA4050110UL
-#define PORT_PKCR	0xA4050112UL
-#define PORT_PLCR	0xA4050114UL
-#define PORT_PMCR	0xA4050116UL
-#define PORT_PPCR	0xA4050118UL
-#define PORT_PRCR	0xA405011AUL
-#define PORT_PSCR	0xA405011CUL
-#define PORT_PTCR	0xA405011EUL
-#define PORT_PUCR	0xA4050120UL
-#define PORT_PVCR	0xA4050122UL
-
-/* Data registers */
-#define PORT_PADR	0xA4050140UL
-/* Address of PORT_PBDR is wrong in the datasheet, see errata 2005-09-21 */
-#define PORT_PBDR	0xA4050142UL
-#define PORT_PCDR	0xA4050144UL
-#define PORT_PDDR	0xA4050146UL
-#define PORT_PEDR	0xA4050148UL
-#define PORT_PFDR	0xA405014AUL
-#define PORT_PGDR	0xA405014CUL
-#define PORT_PHDR	0xA405014EUL
-#define PORT_PJDR	0xA4050150UL
-#define PORT_PKDR	0xA4050152UL
-#define PORT_PLDR	0xA4050154UL
-#define PORT_PMDR	0xA4050156UL
-#define PORT_PPDR	0xA4050158UL
-#define PORT_PRDR	0xA405015AUL
-#define PORT_PSDR	0xA405015CUL
-#define PORT_PTDR	0xA405015EUL
-#define PORT_PUDR	0xA4050160UL
-#define PORT_PVDR	0xA4050162UL
-
-/* Pin Select Registers */
-#define PORT_PSELA	0xA4050124UL
-#define PORT_PSELB	0xA4050126UL
-#define PORT_PSELC	0xA4050128UL
-#define PORT_PSELD	0xA405012AUL
-
-#elif defined(CONFIG_CPU_SUBTYPE_SH7709)
-
-/* Control registers */
-#define PORT_PACR       0xa4000100UL
-#define PORT_PBCR       0xa4000102UL
-#define PORT_PCCR       0xa4000104UL
-#define PORT_PFCR       0xa400010aUL
-
-/* Data registers */
-#define PORT_PADR       0xa4000120UL
-#define PORT_PBDR       0xa4000122UL
-#define PORT_PCDR       0xa4000124UL
-#define PORT_PFDR       0xa400012aUL
-
-#endif
-
-#endif
diff --git a/arch/sh/include/cpu-sh3/cpu/mmu_context.h b/arch/sh/include/cpu-sh3/cpu/mmu_context.h
deleted file mode 100644
index ead9a6f721135d..00000000000000
--- a/arch/sh/include/cpu-sh3/cpu/mmu_context.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/cpu-sh3/mmu_context.h
- *
- * Copyright (C) 1999 Niibe Yutaka
- */
-#ifndef __ASM_CPU_SH3_MMU_CONTEXT_H
-#define __ASM_CPU_SH3_MMU_CONTEXT_H
-
-#define MMU_PTEH	0xFFFFFFF0	/* Page table entry register HIGH */
-#define MMU_PTEL	0xFFFFFFF4	/* Page table entry register LOW */
-#define MMU_TTB		0xFFFFFFF8	/* Translation table base register */
-#define MMU_TEA		0xFFFFFFFC	/* TLB Exception Address */
-
-#define MMUCR		0xFFFFFFE0	/* MMU Control Register */
-#define MMUCR_TI	(1 << 2)	/* TLB flush bit */
-
-#define MMU_TLB_ADDRESS_ARRAY	0xF2000000
-#define MMU_PAGE_ASSOC_BIT	0x80
-
-#define MMU_NTLB_ENTRIES	128	/* for 7708 */
-#define MMU_NTLB_WAYS		4
-#define MMU_CONTROL_INIT	0x007	/* SV=0, TF=1, IX=1, AT=1 */
-
-#define TRA	0xffffffd0
-#define EXPEVT	0xffffffd4
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7705) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7706) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7707) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7709) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7710) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7712) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7720) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7721)
-#define INTEVT	0xa4000000	/* INTEVTE2(0xa4000000) */
-#else
-#define INTEVT	0xffffffd8
-#endif
-
-#endif /* __ASM_CPU_SH3_MMU_CONTEXT_H */
-
diff --git a/arch/sh/include/cpu-sh3/cpu/serial.h b/arch/sh/include/cpu-sh3/cpu/serial.h
deleted file mode 100644
index 7b2ce6e3003e1e..00000000000000
--- a/arch/sh/include/cpu-sh3/cpu/serial.h
+++ /dev/null
@@ -1,11 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __CPU_SH3_SERIAL_H
-#define __CPU_SH3_SERIAL_H
-
-#include <linux/serial_sci.h>
-
-extern struct plat_sci_port_ops sh770x_sci_port_ops;
-extern struct plat_sci_port_ops sh7710_sci_port_ops;
-extern struct plat_sci_port_ops sh7720_sci_port_ops;
-
-#endif /* __CPU_SH3_SERIAL_H */
diff --git a/arch/sh/include/cpu-sh3/cpu/sh7720.h b/arch/sh/include/cpu-sh3/cpu/sh7720.h
deleted file mode 100644
index 449790c9eb77cd..00000000000000
--- a/arch/sh/include/cpu-sh3/cpu/sh7720.h
+++ /dev/null
@@ -1,175 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH7720_H__
-#define __ASM_SH7720_H__
-
-enum {
-	/* PTA */
-	GPIO_PTA7, GPIO_PTA6, GPIO_PTA5, GPIO_PTA4,
-	GPIO_PTA3, GPIO_PTA2, GPIO_PTA1, GPIO_PTA0,
-
-	/* PTB */
-	GPIO_PTB7, GPIO_PTB6, GPIO_PTB5, GPIO_PTB4,
-	GPIO_PTB3, GPIO_PTB2, GPIO_PTB1, GPIO_PTB0,
-
-	/* PTC */
-	GPIO_PTC7, GPIO_PTC6, GPIO_PTC5, GPIO_PTC4,
-	GPIO_PTC3, GPIO_PTC2, GPIO_PTC1, GPIO_PTC0,
-
-	/* PTD */
-	GPIO_PTD7, GPIO_PTD6, GPIO_PTD5, GPIO_PTD4,
-	GPIO_PTD3, GPIO_PTD2, GPIO_PTD1, GPIO_PTD0,
-
-	/* PTE */
-	GPIO_PTE6, GPIO_PTE5, GPIO_PTE4, GPIO_PTE3,
-	GPIO_PTE2, GPIO_PTE1, GPIO_PTE0,
-
-	/* PTF */
-	GPIO_PTF6, GPIO_PTF5, GPIO_PTF4, GPIO_PTF3,
-	GPIO_PTF2, GPIO_PTF1, GPIO_PTF0, GPIO_PTG6,
-
-	/* PTG */
-	GPIO_PTG5, GPIO_PTG4, GPIO_PTG3, GPIO_PTG2,
-	GPIO_PTG1, GPIO_PTG0,
-
-	/* PTH */
-	GPIO_PTH6, GPIO_PTH5, GPIO_PTH4, GPIO_PTH3,
-	GPIO_PTH2, GPIO_PTH1, GPIO_PTH0,
-
-	/* PTJ */
-	GPIO_PTJ6, GPIO_PTJ5, GPIO_PTJ4, GPIO_PTJ3,
-	GPIO_PTJ2, GPIO_PTJ1, GPIO_PTJ0,
-
-	/* PTK */
-	GPIO_PTK3, GPIO_PTK2, GPIO_PTK1, GPIO_PTK0,
-
-	/* PTL */
-	GPIO_PTL7, GPIO_PTL6, GPIO_PTL5, GPIO_PTL4, GPIO_PTL3,
-
-	/* PTM */
-	GPIO_PTM7, GPIO_PTM6, GPIO_PTM5, GPIO_PTM4,
-	GPIO_PTM3, GPIO_PTM2, GPIO_PTM1, GPIO_PTM0,
-
-	/* PTP */
-	GPIO_PTP4, GPIO_PTP3, GPIO_PTP2, GPIO_PTP1, GPIO_PTP0,
-
-	/* PTR */
-	GPIO_PTR7, GPIO_PTR6, GPIO_PTR5, GPIO_PTR4,
-	GPIO_PTR3, GPIO_PTR2, GPIO_PTR1, GPIO_PTR0,
-
-	/* PTS */
-	GPIO_PTS4, GPIO_PTS3, GPIO_PTS2, GPIO_PTS1, GPIO_PTS0,
-
-	/* PTT */
-	GPIO_PTT4, GPIO_PTT3, GPIO_PTT2, GPIO_PTT1, GPIO_PTT0,
-
-	/* PTU */
-	GPIO_PTU4, GPIO_PTU3, GPIO_PTU2, GPIO_PTU1, GPIO_PTU0,
-
-	/* PTV */
-	GPIO_PTV4, GPIO_PTV3, GPIO_PTV2, GPIO_PTV1, GPIO_PTV0,
-
-	/* BSC */
-	GPIO_FN_D31, GPIO_FN_D30, GPIO_FN_D29, GPIO_FN_D28,
-	GPIO_FN_D27, GPIO_FN_D26, GPIO_FN_D25, GPIO_FN_D24,
-	GPIO_FN_D23, GPIO_FN_D22, GPIO_FN_D21, GPIO_FN_D20,
-	GPIO_FN_D19, GPIO_FN_D18, GPIO_FN_D17, GPIO_FN_D16,
-	GPIO_FN_IOIS16, GPIO_FN_RAS, GPIO_FN_CAS, GPIO_FN_CKE,
-	GPIO_FN_CS5B_CE1A, GPIO_FN_CS6B_CE1B,
-	GPIO_FN_A25, GPIO_FN_A24, GPIO_FN_A23, GPIO_FN_A22,
-	GPIO_FN_A21, GPIO_FN_A20, GPIO_FN_A19, GPIO_FN_A0,
-	GPIO_FN_REFOUT, GPIO_FN_IRQOUT,
-
-	/* LCDC */
-	GPIO_FN_LCD_DATA15, GPIO_FN_LCD_DATA14,
-	GPIO_FN_LCD_DATA13, GPIO_FN_LCD_DATA12,
-	GPIO_FN_LCD_DATA11, GPIO_FN_LCD_DATA10,
-	GPIO_FN_LCD_DATA9, GPIO_FN_LCD_DATA8,
-	GPIO_FN_LCD_DATA7, GPIO_FN_LCD_DATA6,
-	GPIO_FN_LCD_DATA5, GPIO_FN_LCD_DATA4,
-	GPIO_FN_LCD_DATA3, GPIO_FN_LCD_DATA2,
-	GPIO_FN_LCD_DATA1, GPIO_FN_LCD_DATA0,
-	GPIO_FN_LCD_M_DISP,
-	GPIO_FN_LCD_CL1, GPIO_FN_LCD_CL2,
-	GPIO_FN_LCD_DON, GPIO_FN_LCD_FLM,
-	GPIO_FN_LCD_VEPWC, GPIO_FN_LCD_VCPWC,
-
-	/* AFEIF */
-	GPIO_FN_AFE_RXIN, GPIO_FN_AFE_RDET,
-	GPIO_FN_AFE_FS, GPIO_FN_AFE_TXOUT,
-	GPIO_FN_AFE_SCLK, GPIO_FN_AFE_RLYCNT,
-	GPIO_FN_AFE_HC1,
-
-	/* IIC */
-	GPIO_FN_IIC_SCL, GPIO_FN_IIC_SDA,
-
-	/* DAC */
-	GPIO_FN_DA1, GPIO_FN_DA0,
-
-	/* ADC */
-	GPIO_FN_AN3, GPIO_FN_AN2, GPIO_FN_AN1, GPIO_FN_AN0, GPIO_FN_ADTRG,
-
-	/* USB */
-	GPIO_FN_USB1D_RCV, GPIO_FN_USB1D_TXSE0,
-	GPIO_FN_USB1D_TXDPLS, GPIO_FN_USB1D_DMNS,
-	GPIO_FN_USB1D_DPLS, GPIO_FN_USB1D_SPEED,
-	GPIO_FN_USB1D_TXENL, GPIO_FN_USB2_PWR_EN,
-	GPIO_FN_USB1_PWR_EN_USBF_UPLUP, GPIO_FN_USB1D_SUSPEND,
-
-	/* INTC */
-	GPIO_FN_IRQ5, GPIO_FN_IRQ4,
-	GPIO_FN_IRQ3_IRL3, GPIO_FN_IRQ2_IRL2,
-	GPIO_FN_IRQ1_IRL1, GPIO_FN_IRQ0_IRL0,
-
-	/* PCC */
-	GPIO_FN_PCC_REG, GPIO_FN_PCC_DRV,
-	GPIO_FN_PCC_BVD2, GPIO_FN_PCC_BVD1,
-	GPIO_FN_PCC_CD2, GPIO_FN_PCC_CD1,
-	GPIO_FN_PCC_RESET, GPIO_FN_PCC_RDY,
-	GPIO_FN_PCC_VS2, GPIO_FN_PCC_VS1,
-
-	/* HUDI */
-	GPIO_FN_AUDATA3, GPIO_FN_AUDATA2, GPIO_FN_AUDATA1, GPIO_FN_AUDATA0,
-	GPIO_FN_AUDCK, GPIO_FN_AUDSYNC, GPIO_FN_ASEBRKAK, GPIO_FN_TRST,
-	GPIO_FN_TMS, GPIO_FN_TDO, GPIO_FN_TDI, GPIO_FN_TCK,
-
-	/* DMAC */
-	GPIO_FN_DACK1, GPIO_FN_DREQ1, GPIO_FN_DACK0, GPIO_FN_DREQ0,
-	GPIO_FN_TEND1, GPIO_FN_TEND0,
-
-	/* SIOF0 */
-	GPIO_FN_SIOF0_SYNC, GPIO_FN_SIOF0_MCLK,
-	GPIO_FN_SIOF0_TXD, GPIO_FN_SIOF0_RXD,
-	GPIO_FN_SIOF0_SCK,
-
-	/* SIOF1 */
-	GPIO_FN_SIOF1_SYNC, GPIO_FN_SIOF1_MCLK,
-	GPIO_FN_SIOF1_TXD, GPIO_FN_SIOF1_RXD,
-	GPIO_FN_SIOF1_SCK,
-
-	/* SCIF0 */
-	GPIO_FN_SCIF0_TXD, GPIO_FN_SCIF0_RXD,
-	GPIO_FN_SCIF0_RTS, GPIO_FN_SCIF0_CTS, GPIO_FN_SCIF0_SCK,
-
-	/* SCIF1 */
-	GPIO_FN_SCIF1_TXD, GPIO_FN_SCIF1_RXD,
-	GPIO_FN_SCIF1_RTS, GPIO_FN_SCIF1_CTS, GPIO_FN_SCIF1_SCK,
-
-	/* TPU */
-	GPIO_FN_TPU_TO1, GPIO_FN_TPU_TO0,
-	GPIO_FN_TPU_TI3B, GPIO_FN_TPU_TI3A,
-	GPIO_FN_TPU_TI2B, GPIO_FN_TPU_TI2A,
-	GPIO_FN_TPU_TO3, GPIO_FN_TPU_TO2,
-
-	/* SIM */
-	GPIO_FN_SIM_D, GPIO_FN_SIM_CLK, GPIO_FN_SIM_RST,
-
-	/* MMC */
-	GPIO_FN_MMC_DAT, GPIO_FN_MMC_CMD,
-	GPIO_FN_MMC_CLK, GPIO_FN_MMC_VDDON,
-	GPIO_FN_MMC_ODMOD,
-
-	/* SYSC */
-	GPIO_FN_STATUS0, GPIO_FN_STATUS1,
-};
-
-#endif /* __ASM_SH7720_H__ */
diff --git a/arch/sh/include/cpu-sh3/cpu/watchdog.h b/arch/sh/include/cpu-sh3/cpu/watchdog.h
deleted file mode 100644
index 9d7e9d98680947..00000000000000
--- a/arch/sh/include/cpu-sh3/cpu/watchdog.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/cpu-sh3/watchdog.h
- *
- * Copyright (C) 2002, 2003 Paul Mundt
- */
-#ifndef __ASM_CPU_SH3_WATCHDOG_H
-#define __ASM_CPU_SH3_WATCHDOG_H
-
-/* Register definitions */
-#define WTCNT		0xffffff84
-#define WTCSR		0xffffff86
-
-/* Bit definitions */
-#define WTCSR_TME	0x80
-#define WTCSR_WT	0x40
-#define WTCSR_RSTS	0x20
-#define WTCSR_WOVF	0x10
-#define WTCSR_IOVF	0x08
-
-#endif /* __ASM_CPU_SH3_WATCHDOG_H */
-
diff --git a/arch/sh/include/cpu-sh4/cpu/addrspace.h b/arch/sh/include/cpu-sh4/cpu/addrspace.h
deleted file mode 100644
index f006c9489f5adb..00000000000000
--- a/arch/sh/include/cpu-sh4/cpu/addrspace.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * Copyright (C) 1999 by Kaz Kojima
- *
- * Defitions for the address spaces of the SH-4 CPUs.
- */
-#ifndef __ASM_CPU_SH4_ADDRSPACE_H
-#define __ASM_CPU_SH4_ADDRSPACE_H
-
-#define P0SEG		0x00000000
-#define P1SEG		0x80000000
-#define P2SEG		0xa0000000
-#define P3SEG		0xc0000000
-#define P4SEG		0xe0000000
-
-/* Detailed P4SEG  */
-#define P4SEG_STORE_QUE	(P4SEG)
-#define P4SEG_IC_ADDR	0xf0000000
-#define P4SEG_IC_DATA	0xf1000000
-#define P4SEG_ITLB_ADDR	0xf2000000
-#define P4SEG_ITLB_DATA	0xf3000000
-#define P4SEG_OC_ADDR	0xf4000000
-#define P4SEG_OC_DATA	0xf5000000
-#define P4SEG_TLB_ADDR	0xf6000000
-#define P4SEG_TLB_DATA	0xf7000000
-#define P4SEG_REG_BASE	0xff000000
-
-#define PA_AREA0	0x00000000
-#define PA_AREA1	0x04000000
-#define PA_AREA2	0x08000000
-#define PA_AREA3	0x0c000000
-#define PA_AREA4	0x10000000
-#define PA_AREA5	0x14000000
-#define PA_AREA6	0x18000000
-#define PA_AREA7	0x1c000000
-
-#define PA_AREA5_IO	0xb4000000	/* Area 5 IO Memory */
-#define PA_AREA6_IO	0xb8000000	/* Area 6 IO Memory */
-
-#endif /* __ASM_CPU_SH4_ADDRSPACE_H */
-
diff --git a/arch/sh/include/cpu-sh4/cpu/cache.h b/arch/sh/include/cpu-sh4/cpu/cache.h
deleted file mode 100644
index 72b4d13da127cd..00000000000000
--- a/arch/sh/include/cpu-sh4/cpu/cache.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/cpu-sh4/cache.h
- *
- * Copyright (C) 1999 Niibe Yutaka
- */
-#ifndef __ASM_CPU_SH4_CACHE_H
-#define __ASM_CPU_SH4_CACHE_H
-
-#define L1_CACHE_SHIFT	5
-
-#define SH_CACHE_VALID		1
-#define SH_CACHE_UPDATED	2
-#define SH_CACHE_COMBINED	4
-#define SH_CACHE_ASSOC		8
-
-#define SH_CCR		0xff00001c	/* Address of Cache Control Register */
-#define CCR_CACHE_OCE	0x0001	/* Operand Cache Enable */
-#define CCR_CACHE_WT	0x0002	/* Write-Through (for P0,U0,P3) (else writeback)*/
-#define CCR_CACHE_CB	0x0004	/* Copy-Back (for P1) (else writethrough) */
-#define CCR_CACHE_OCI	0x0008	/* OC Invalidate */
-#define CCR_CACHE_ORA	0x0020	/* OC RAM Mode */
-#define CCR_CACHE_OIX	0x0080	/* OC Index Enable */
-#define CCR_CACHE_ICE	0x0100	/* Instruction Cache Enable */
-#define CCR_CACHE_ICI	0x0800	/* IC Invalidate */
-#define CCR_CACHE_IIX	0x8000	/* IC Index Enable */
-#ifndef CONFIG_CPU_SH4A
-#define CCR_CACHE_EMODE	0x80000000	/* EMODE Enable */
-#endif
-
-/* Default CCR setup: 8k+16k-byte cache,P1-wb,enable */
-#define CCR_CACHE_ENABLE	(CCR_CACHE_OCE|CCR_CACHE_ICE)
-#define CCR_CACHE_INVALIDATE	(CCR_CACHE_OCI|CCR_CACHE_ICI)
-
-#define CACHE_IC_ADDRESS_ARRAY	0xf0000000
-#define CACHE_OC_ADDRESS_ARRAY	0xf4000000
-
-#define RAMCR			0xFF000074
-
-#endif /* __ASM_CPU_SH4_CACHE_H */
-
diff --git a/arch/sh/include/cpu-sh4/cpu/dma-register.h b/arch/sh/include/cpu-sh4/cpu/dma-register.h
deleted file mode 100644
index 53f7ab990d8874..00000000000000
--- a/arch/sh/include/cpu-sh4/cpu/dma-register.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * SH4 CPU-specific DMA definitions, used by both DMA drivers
- *
- * Copyright (C) 2010 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
- */
-#ifndef CPU_DMA_REGISTER_H
-#define CPU_DMA_REGISTER_H
-
-/* SH7751/7760/7780 DMA IRQ sources */
-
-#ifdef CONFIG_CPU_SH4A
-
-#define DMAOR_INIT	DMAOR_DME
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7343)
-#define CHCR_TS_LOW_MASK	0x00000018
-#define CHCR_TS_LOW_SHIFT	3
-#define CHCR_TS_HIGH_MASK	0
-#define CHCR_TS_HIGH_SHIFT	0
-#elif defined(CONFIG_CPU_SUBTYPE_SH7722) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7723) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7724) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7730) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7786)
-#define CHCR_TS_LOW_MASK	0x00000018
-#define CHCR_TS_LOW_SHIFT	3
-#define CHCR_TS_HIGH_MASK	0x00300000
-#define CHCR_TS_HIGH_SHIFT	(20 - 2)	/* 2 bits for shifted low TS */
-#elif defined(CONFIG_CPU_SUBTYPE_SH7757) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7763) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7780) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7785)
-#define CHCR_TS_LOW_MASK	0x00000018
-#define CHCR_TS_LOW_SHIFT	3
-#define CHCR_TS_HIGH_MASK	0x00100000
-#define CHCR_TS_HIGH_SHIFT	(20 - 2)	/* 2 bits for shifted low TS */
-#endif
-
-/* Transmit sizes and respective CHCR register values */
-enum {
-	XMIT_SZ_8BIT		= 0,
-	XMIT_SZ_16BIT		= 1,
-	XMIT_SZ_32BIT		= 2,
-	XMIT_SZ_64BIT		= 7,
-	XMIT_SZ_128BIT		= 3,
-	XMIT_SZ_256BIT		= 4,
-	XMIT_SZ_128BIT_BLK	= 0xb,
-	XMIT_SZ_256BIT_BLK	= 0xc,
-};
-
-/* log2(size / 8) - used to calculate number of transfers */
-#define TS_SHIFT {			\
-	[XMIT_SZ_8BIT]		= 0,	\
-	[XMIT_SZ_16BIT]		= 1,	\
-	[XMIT_SZ_32BIT]		= 2,	\
-	[XMIT_SZ_64BIT]		= 3,	\
-	[XMIT_SZ_128BIT]	= 4,	\
-	[XMIT_SZ_256BIT]	= 5,	\
-	[XMIT_SZ_128BIT_BLK]	= 4,	\
-	[XMIT_SZ_256BIT_BLK]	= 5,	\
-}
-
-#define TS_INDEX2VAL(i)	((((i) & 3) << CHCR_TS_LOW_SHIFT) | \
-			 (((i) & 0xc) << CHCR_TS_HIGH_SHIFT))
-
-#else /* CONFIG_CPU_SH4A */
-
-#define DMAOR_INIT	(0x8000 | DMAOR_DME)
-
-#define CHCR_TS_LOW_MASK	0x70
-#define CHCR_TS_LOW_SHIFT	4
-#define CHCR_TS_HIGH_MASK	0
-#define CHCR_TS_HIGH_SHIFT	0
-
-/* Transmit sizes and respective CHCR register values */
-enum {
-	XMIT_SZ_8BIT	= 1,
-	XMIT_SZ_16BIT	= 2,
-	XMIT_SZ_32BIT	= 3,
-	XMIT_SZ_64BIT	= 0,
-	XMIT_SZ_256BIT	= 4,
-};
-
-/* log2(size / 8) - used to calculate number of transfers */
-#define TS_SHIFT {			\
-	[XMIT_SZ_8BIT]		= 0,	\
-	[XMIT_SZ_16BIT]		= 1,	\
-	[XMIT_SZ_32BIT]		= 2,	\
-	[XMIT_SZ_64BIT]		= 3,	\
-	[XMIT_SZ_256BIT]	= 5,	\
-}
-
-#define TS_INDEX2VAL(i)	(((i) & 7) << CHCR_TS_LOW_SHIFT)
-
-#endif /* CONFIG_CPU_SH4A */
-
-#endif
diff --git a/arch/sh/include/cpu-sh4/cpu/dma.h b/arch/sh/include/cpu-sh4/cpu/dma.h
deleted file mode 100644
index 38187d06b23433..00000000000000
--- a/arch/sh/include/cpu-sh4/cpu/dma.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_CPU_SH4_DMA_H
-#define __ASM_CPU_SH4_DMA_H
-
-#include <linux/sh_intc.h>
-
-/*
- * SH7750/SH7751/SH7760
- */
-#define DMTE0_IRQ	evt2irq(0x640)
-#define DMTE4_IRQ	evt2irq(0x780)
-#define DMTE6_IRQ	evt2irq(0x7c0)
-#define DMAE0_IRQ	evt2irq(0x6c0)
-
-#define SH_DMAC_BASE0	0xffa00000
-#define SH_DMAC_BASE1	0xffa00070
-
-#endif /* __ASM_CPU_SH4_DMA_H */
diff --git a/arch/sh/include/cpu-sh4/cpu/fpu.h b/arch/sh/include/cpu-sh4/cpu/fpu.h
deleted file mode 100644
index 29f451bfef19b4..00000000000000
--- a/arch/sh/include/cpu-sh4/cpu/fpu.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * linux/arch/sh/kernel/cpu/sh4/sh4_fpu.h
- *
- * Copyright (C) 2006 STMicroelectronics Limited
- * Author: Carl Shaw <carl.shaw@st.com>
- *
- * Definitions for SH4 FPU operations
- */
-
-#ifndef __CPU_SH4_FPU_H
-#define __CPU_SH4_FPU_H
-
-#define FPSCR_ENABLE_MASK	0x00000f80UL
-
-#define FPSCR_FMOV_DOUBLE	(1<<1)
-
-#define FPSCR_CAUSE_INEXACT	(1<<12)
-#define FPSCR_CAUSE_UNDERFLOW	(1<<13)
-#define FPSCR_CAUSE_OVERFLOW	(1<<14)
-#define FPSCR_CAUSE_DIVZERO	(1<<15)
-#define FPSCR_CAUSE_INVALID	(1<<16)
-#define FPSCR_CAUSE_ERROR 	(1<<17)
-
-#define FPSCR_DBL_PRECISION	(1<<19)
-#define FPSCR_ROUNDING_MODE(x)	((x >> 20) & 3)
-#define FPSCR_RM_NEAREST	(0)
-#define FPSCR_RM_ZERO		(1)
-
-#endif
diff --git a/arch/sh/include/cpu-sh4/cpu/freq.h b/arch/sh/include/cpu-sh4/cpu/freq.h
deleted file mode 100644
index 662f0f30e106e8..00000000000000
--- a/arch/sh/include/cpu-sh4/cpu/freq.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/cpu-sh4/freq.h
- *
- * Copyright (C) 2002, 2003 Paul Mundt
- */
-#ifndef __ASM_CPU_SH4_FREQ_H
-#define __ASM_CPU_SH4_FREQ_H
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7722) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7723) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7343) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7366)
-#define FRQCR		        0xa4150000
-#define VCLKCR			0xa4150004
-#define SCLKACR			0xa4150008
-#define SCLKBCR			0xa415000c
-#define IrDACLKCR		0xa4150010
-#define MSTPCR0			0xa4150030
-#define MSTPCR1			0xa4150034
-#define MSTPCR2			0xa4150038
-#elif defined(CONFIG_CPU_SUBTYPE_SH7757)
-#define	FRQCR			0xffc80000
-#define	OSCCR			0xffc80018
-#define	PLLCR			0xffc80024
-#elif defined(CONFIG_CPU_SUBTYPE_SH7763) || \
-      defined(CONFIG_CPU_SUBTYPE_SH7780)
-#define	FRQCR			0xffc80000
-#elif defined(CONFIG_CPU_SUBTYPE_SH7724)
-#define FRQCRA			0xa4150000
-#define FRQCRB			0xa4150004
-#define VCLKCR			0xa4150048
-
-#define FCLKACR			0xa4150008
-#define FCLKBCR			0xa415000c
-#define FRQCR			FRQCRA
-#define SCLKACR			FCLKACR
-#define SCLKBCR			FCLKBCR
-#define FCLKACR			0xa4150008
-#define FCLKBCR			0xa415000c
-#define IrDACLKCR		0xa4150018
-
-#define MSTPCR0			0xa4150030
-#define MSTPCR1			0xa4150034
-#define MSTPCR2			0xa4150038
-
-#elif defined(CONFIG_CPU_SUBTYPE_SH7734)
-#define FRQCR0			0xffc80000
-#define FRQCR2			0xffc80008
-#define FRQMR1			0xffc80014
-#define FRQMR2			0xffc80018
-#elif defined(CONFIG_CPU_SUBTYPE_SH7785)
-#define FRQCR0			0xffc80000
-#define FRQCR1			0xffc80004
-#define FRQMR1			0xffc80014
-#elif defined(CONFIG_CPU_SUBTYPE_SH7786)
-#define FRQCR0			0xffc40000
-#define FRQCR1			0xffc40004
-#define FRQMR1			0xffc40014
-#elif defined(CONFIG_CPU_SUBTYPE_SHX3)
-#define FRQCR0			0xffc00000
-#define FRQCR1			0xffc00004
-#define FRQMR1			0xffc00014
-#else
-#define FRQCR			0xffc00000
-#define FRQCR_PSTBY		0x0200
-#define FRQCR_PLLEN		0x0400
-#define FRQCR_CKOEN		0x0800
-#endif
-#define MIN_DIVISOR_NR		0
-#define MAX_DIVISOR_NR		3
-
-#endif /* __ASM_CPU_SH4_FREQ_H */
-
diff --git a/arch/sh/include/cpu-sh4/cpu/mmu_context.h b/arch/sh/include/cpu-sh4/cpu/mmu_context.h
deleted file mode 100644
index 421b56d5c59562..00000000000000
--- a/arch/sh/include/cpu-sh4/cpu/mmu_context.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/cpu-sh4/mmu_context.h
- *
- * Copyright (C) 1999 Niibe Yutaka
- */
-#ifndef __ASM_CPU_SH4_MMU_CONTEXT_H
-#define __ASM_CPU_SH4_MMU_CONTEXT_H
-
-#define MMU_PTEH	0xFF000000	/* Page table entry register HIGH */
-#define MMU_PTEL	0xFF000004	/* Page table entry register LOW */
-#define MMU_TTB		0xFF000008	/* Translation table base register */
-#define MMU_TEA		0xFF00000C	/* TLB Exception Address */
-#define MMU_PTEA	0xFF000034	/* PTE assistance register */
-#define MMU_PTEAEX	0xFF00007C	/* PTE ASID extension register */
-
-#define MMUCR		0xFF000010	/* MMU Control Register */
-
-#define MMU_TLB_ENTRY_SHIFT	8
-
-#define MMU_ITLB_ADDRESS_ARRAY  0xF2000000
-#define MMU_ITLB_ADDRESS_ARRAY2	0xF2800000
-#define MMU_ITLB_DATA_ARRAY	0xF3000000
-#define MMU_ITLB_DATA_ARRAY2	0xF3800000
-
-#define MMU_UTLB_ADDRESS_ARRAY	0xF6000000
-#define MMU_UTLB_ADDRESS_ARRAY2	0xF6800000
-#define MMU_UTLB_DATA_ARRAY	0xF7000000
-#define MMU_UTLB_DATA_ARRAY2	0xF7800000
-#define MMU_PAGE_ASSOC_BIT	0x80
-
-#ifdef CONFIG_MMU
-#define MMUCR_AT		(1 << 0)
-#else
-#define MMUCR_AT		(0)
-#endif
-
-#define MMUCR_TI		(1 << 2)
-
-#define MMUCR_URB		0x00FC0000
-#define MMUCR_URB_SHIFT		18
-#define MMUCR_URB_NENTRIES	64
-#define MMUCR_URC		0x0000FC00
-#define MMUCR_URC_SHIFT		10
-
-#if defined(CONFIG_32BIT) && defined(CONFIG_CPU_SUBTYPE_ST40)
-#define MMUCR_SE		(1 << 4)
-#else
-#define MMUCR_SE		(0)
-#endif
-
-#ifdef CONFIG_CPU_HAS_PTEAEX
-#define MMUCR_AEX		(1 << 6)
-#else
-#define MMUCR_AEX		(0)
-#endif
-
-#ifdef CONFIG_X2TLB
-#define MMUCR_ME		(1 << 7)
-#else
-#define MMUCR_ME		(0)
-#endif
-
-#ifdef CONFIG_SH_STORE_QUEUES
-#define MMUCR_SQMD		(1 << 9)
-#else
-#define MMUCR_SQMD		(0)
-#endif
-
-#define MMU_NTLB_ENTRIES	64
-#define MMU_CONTROL_INIT	(MMUCR_AT | MMUCR_TI | MMUCR_SQMD | \
-				 MMUCR_ME | MMUCR_SE | MMUCR_AEX)
-
-#define TRA	0xff000020
-#define EXPEVT	0xff000024
-#define INTEVT	0xff000028
-
-#endif /* __ASM_CPU_SH4_MMU_CONTEXT_H */
-
diff --git a/arch/sh/include/cpu-sh4/cpu/rtc.h b/arch/sh/include/cpu-sh4/cpu/rtc.h
deleted file mode 100644
index 45647566940f30..00000000000000
--- a/arch/sh/include/cpu-sh4/cpu/rtc.h
+++ /dev/null
@@ -1,14 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_CPU_SH4_RTC_H
-#define __ASM_SH_CPU_SH4_RTC_H
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7722) || defined(CONFIG_CPU_SUBTYPE_SH7723)
-#define rtc_reg_size		sizeof(u16)
-#else
-#define rtc_reg_size		sizeof(u32)
-#endif
-
-#define RTC_BIT_INVERTED	0x40	/* bug on SH7750, SH7750S */
-#define RTC_DEF_CAPABILITIES	RTC_CAP_4_DIGIT_YEAR
-
-#endif /* __ASM_SH_CPU_SH4_RTC_H */
diff --git a/arch/sh/include/cpu-sh4/cpu/sh7722.h b/arch/sh/include/cpu-sh4/cpu/sh7722.h
deleted file mode 100644
index 2306c79f4b5e26..00000000000000
--- a/arch/sh/include/cpu-sh4/cpu/sh7722.h
+++ /dev/null
@@ -1,252 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH7722_H__
-#define __ASM_SH7722_H__
-
-/* Boot Mode Pins:
- *
- * MD0: CPG - Clock Mode 0->3
- * MD1: CPG - Clock Mode 0->3
- * MD2: CPG - Reserved (L: Normal operation)
- * MD3: BSC - Area0 Bus Width (16/32-bit) [CS0BCR.9,10]
- * MD5: BSC - Endian Mode (L: Big, H: Little) [CMNCR.3]
- * MD8: Test Mode
- */
-
-/* Pin Function Controller:
- * GPIO_FN_xx - GPIO used to select pin function
- * GPIO_Pxx - GPIO mapped to real I/O pin on CPU
- */
-enum {
-	/* PTA */
-	GPIO_PTA7, GPIO_PTA6, GPIO_PTA5, GPIO_PTA4,
-	GPIO_PTA3, GPIO_PTA2, GPIO_PTA1, GPIO_PTA0,
-
-	/* PTB */
-	GPIO_PTB7, GPIO_PTB6, GPIO_PTB5, GPIO_PTB4,
-	GPIO_PTB3, GPIO_PTB2, GPIO_PTB1, GPIO_PTB0,
-
-	/* PTC */
-	GPIO_PTC7, GPIO_PTC5, GPIO_PTC4, GPIO_PTC3,
-	GPIO_PTC2, GPIO_PTC0,
-
-	/* PTD */
-	GPIO_PTD7, GPIO_PTD6, GPIO_PTD5, GPIO_PTD4,
-	GPIO_PTD3, GPIO_PTD2, GPIO_PTD1, GPIO_PTD0,
-
-	/* PTE */
-	GPIO_PTE7, GPIO_PTE6, GPIO_PTE5, GPIO_PTE4,
-	GPIO_PTE1, GPIO_PTE0,
-
-	/* PTF */
-	GPIO_PTF6, GPIO_PTF5, GPIO_PTF4, GPIO_PTF3,
-	GPIO_PTF2, GPIO_PTF1, GPIO_PTF0,
-
-	/* PTG */
-	GPIO_PTG4, GPIO_PTG3, GPIO_PTG2, GPIO_PTG1, GPIO_PTG0,
-
-	/* PTH */
-	GPIO_PTH7, GPIO_PTH6, GPIO_PTH5, GPIO_PTH4,
-	GPIO_PTH3, GPIO_PTH2, GPIO_PTH1, GPIO_PTH0,
-
-	/* PTJ */
-	GPIO_PTJ7, GPIO_PTJ6, GPIO_PTJ5, GPIO_PTJ1, GPIO_PTJ0,
-
-	/* PTK */
-	GPIO_PTK6, GPIO_PTK5, GPIO_PTK4, GPIO_PTK3,
-	GPIO_PTK2, GPIO_PTK1, GPIO_PTK0,
-
-	/* PTL */
-	GPIO_PTL7, GPIO_PTL6, GPIO_PTL5, GPIO_PTL4,
-	GPIO_PTL3, GPIO_PTL2, GPIO_PTL1, GPIO_PTL0,
-
-	/* PTM */
-	GPIO_PTM7, GPIO_PTM6, GPIO_PTM5, GPIO_PTM4,
-	GPIO_PTM3, GPIO_PTM2, GPIO_PTM1, GPIO_PTM0,
-
-	/* PTN */
-	GPIO_PTN7, GPIO_PTN6, GPIO_PTN5, GPIO_PTN4,
-	GPIO_PTN3, GPIO_PTN2, GPIO_PTN1, GPIO_PTN0,
-
-	/* PTQ */
-	GPIO_PTQ6, GPIO_PTQ5, GPIO_PTQ4,
-	GPIO_PTQ3, GPIO_PTQ2, GPIO_PTQ1, GPIO_PTQ0,
-
-	/* PTR */
-	GPIO_PTR4, GPIO_PTR3, GPIO_PTR2, GPIO_PTR1, GPIO_PTR0,
-
-	/* PTS */
-	GPIO_PTS4, GPIO_PTS3, GPIO_PTS2, GPIO_PTS1, GPIO_PTS0,
-
-	/* PTT */
-	GPIO_PTT4, GPIO_PTT3, GPIO_PTT2, GPIO_PTT1, GPIO_PTT0,
-
-	/* PTU */
-	GPIO_PTU4, GPIO_PTU3, GPIO_PTU2, GPIO_PTU1, GPIO_PTU0,
-
-	/* PTV */
-	GPIO_PTV4, GPIO_PTV3, GPIO_PTV2, GPIO_PTV1, GPIO_PTV0,
-
-	/* PTW */
-	GPIO_PTW6, GPIO_PTW5, GPIO_PTW4, GPIO_PTW3,
-	GPIO_PTW2, GPIO_PTW1, GPIO_PTW0,
-
-	/* PTX */
-	GPIO_PTX6, GPIO_PTX5, GPIO_PTX4, GPIO_PTX3,
-	GPIO_PTX2, GPIO_PTX1, GPIO_PTX0,
-
-	/* PTY */
-	GPIO_PTY5, GPIO_PTY4, GPIO_PTY3, GPIO_PTY2,
-	GPIO_PTY1, GPIO_PTY0,
-
-	/* PTZ */
-	GPIO_PTZ5, GPIO_PTZ4, GPIO_PTZ3, GPIO_PTZ2, GPIO_PTZ1,
-
-	/* SCIF0 */
-	GPIO_FN_SCIF0_TXD, GPIO_FN_SCIF0_RXD,
-	GPIO_FN_SCIF0_RTS, GPIO_FN_SCIF0_CTS, GPIO_FN_SCIF0_SCK,
-
-	/* SCIF1 */
-	GPIO_FN_SCIF1_TXD, GPIO_FN_SCIF1_RXD,
-	GPIO_FN_SCIF1_RTS, GPIO_FN_SCIF1_CTS, GPIO_FN_SCIF1_SCK,
-
-	/* SCIF2 */
-	GPIO_FN_SCIF2_TXD, GPIO_FN_SCIF2_RXD,
-	GPIO_FN_SCIF2_RTS, GPIO_FN_SCIF2_CTS, GPIO_FN_SCIF2_SCK,
-
-	/* SIO */
-	GPIO_FN_SIOTXD, GPIO_FN_SIORXD,
-	GPIO_FN_SIOD, GPIO_FN_SIOSTRB0, GPIO_FN_SIOSTRB1,
-	GPIO_FN_SIOSCK, GPIO_FN_SIOMCK,
-
-	/* CEU */
-	GPIO_FN_VIO_D15, GPIO_FN_VIO_D14, GPIO_FN_VIO_D13, GPIO_FN_VIO_D12,
-	GPIO_FN_VIO_D11, GPIO_FN_VIO_D10, GPIO_FN_VIO_D9, GPIO_FN_VIO_D8,
-	GPIO_FN_VIO_D7, GPIO_FN_VIO_D6, GPIO_FN_VIO_D5, GPIO_FN_VIO_D4,
-	GPIO_FN_VIO_D3, GPIO_FN_VIO_D2, GPIO_FN_VIO_D1, GPIO_FN_VIO_D0,
-	GPIO_FN_VIO_FLD, GPIO_FN_VIO_CKO, GPIO_FN_VIO_STEX, GPIO_FN_VIO_STEM,
-	GPIO_FN_VIO_VD, GPIO_FN_VIO_HD, GPIO_FN_VIO_CLK,
-	GPIO_FN_VIO_VD2, GPIO_FN_VIO_HD2, GPIO_FN_VIO_CLK2,
-
-	/* LCDC */
-	GPIO_FN_LCDD23, GPIO_FN_LCDD22, GPIO_FN_LCDD21, GPIO_FN_LCDD20,
-	GPIO_FN_LCDD19, GPIO_FN_LCDD18, GPIO_FN_LCDD17, GPIO_FN_LCDD16,
-	GPIO_FN_LCDD15, GPIO_FN_LCDD14, GPIO_FN_LCDD13, GPIO_FN_LCDD12,
-	GPIO_FN_LCDD11, GPIO_FN_LCDD10, GPIO_FN_LCDD9, GPIO_FN_LCDD8,
-	GPIO_FN_LCDD7, GPIO_FN_LCDD6, GPIO_FN_LCDD5, GPIO_FN_LCDD4,
-	GPIO_FN_LCDD3, GPIO_FN_LCDD2, GPIO_FN_LCDD1, GPIO_FN_LCDD0,
-	GPIO_FN_LCDLCLK,
-	/* Main LCD */
-	GPIO_FN_LCDDON, GPIO_FN_LCDVCPWC, GPIO_FN_LCDVEPWC, GPIO_FN_LCDVSYN,
-	/* Main LCD - RGB Mode */
-	GPIO_FN_LCDDCK, GPIO_FN_LCDHSYN, GPIO_FN_LCDDISP,
-	/* Main LCD - SYS Mode */
-	GPIO_FN_LCDRS, GPIO_FN_LCDCS, GPIO_FN_LCDWR, GPIO_FN_LCDRD,
-	/* Sub LCD - SYS Mode */
-	GPIO_FN_LCDDON2, GPIO_FN_LCDVCPWC2, GPIO_FN_LCDVEPWC2,
-	GPIO_FN_LCDVSYN2, GPIO_FN_LCDCS2,
-
-	/* BSC */
-	GPIO_FN_IOIS16, GPIO_FN_A25, GPIO_FN_A24, GPIO_FN_A23, GPIO_FN_A22,
-	GPIO_FN_BS, GPIO_FN_CS6B_CE1B, GPIO_FN_WAIT, GPIO_FN_CS6A_CE2B,
-
-	/* SBSC */
-	GPIO_FN_HPD63, GPIO_FN_HPD62, GPIO_FN_HPD61, GPIO_FN_HPD60,
-	GPIO_FN_HPD59, GPIO_FN_HPD58, GPIO_FN_HPD57, GPIO_FN_HPD56,
-	GPIO_FN_HPD55, GPIO_FN_HPD54, GPIO_FN_HPD53, GPIO_FN_HPD52,
-	GPIO_FN_HPD51, GPIO_FN_HPD50, GPIO_FN_HPD49, GPIO_FN_HPD48,
-	GPIO_FN_HPDQM7, GPIO_FN_HPDQM6, GPIO_FN_HPDQM5, GPIO_FN_HPDQM4,
-
-	/* IRQ */
-	GPIO_FN_IRQ0, GPIO_FN_IRQ1, GPIO_FN_IRQ2, GPIO_FN_IRQ3,
-	GPIO_FN_IRQ4, GPIO_FN_IRQ5, GPIO_FN_IRQ6, GPIO_FN_IRQ7,
-
-	/* SDHI */
-	GPIO_FN_SDHICD, GPIO_FN_SDHIWP, GPIO_FN_SDHID3, GPIO_FN_SDHID2,
-	GPIO_FN_SDHID1, GPIO_FN_SDHID0, GPIO_FN_SDHICMD, GPIO_FN_SDHICLK,
-
-	/* SIU - Port A */
-	GPIO_FN_SIUAOLR, GPIO_FN_SIUAOBT, GPIO_FN_SIUAISLD, GPIO_FN_SIUAILR,
-	GPIO_FN_SIUAIBT, GPIO_FN_SIUAOSLD, GPIO_FN_SIUMCKA, GPIO_FN_SIUFCKA,
-
-	/* SIU - Port B */
-	GPIO_FN_SIUBOLR, GPIO_FN_SIUBOBT, GPIO_FN_SIUBISLD, GPIO_FN_SIUBILR,
-	GPIO_FN_SIUBIBT, GPIO_FN_SIUBOSLD, GPIO_FN_SIUMCKB, GPIO_FN_SIUFCKB,
-
-	/* AUD */
-	GPIO_FN_AUDSYNC, GPIO_FN_AUDATA3, GPIO_FN_AUDATA2, GPIO_FN_AUDATA1,
-	GPIO_FN_AUDATA0,
-
-	/* DMAC */
-	GPIO_FN_DACK, GPIO_FN_DREQ0,
-
-	/* VOU */
-	GPIO_FN_DV_CLKI, GPIO_FN_DV_CLK, GPIO_FN_DV_HSYNC, GPIO_FN_DV_VSYNC,
-	GPIO_FN_DV_D15, GPIO_FN_DV_D14, GPIO_FN_DV_D13, GPIO_FN_DV_D12,
-	GPIO_FN_DV_D11, GPIO_FN_DV_D10, GPIO_FN_DV_D9, GPIO_FN_DV_D8,
-	GPIO_FN_DV_D7, GPIO_FN_DV_D6, GPIO_FN_DV_D5, GPIO_FN_DV_D4,
-	GPIO_FN_DV_D3, GPIO_FN_DV_D2, GPIO_FN_DV_D1, GPIO_FN_DV_D0,
-
-	/* CPG */
-	GPIO_FN_STATUS0, GPIO_FN_PDSTATUS,
-
-	/* SIOF0 */
-	GPIO_FN_SIOF0_MCK, GPIO_FN_SIOF0_SCK,
-	GPIO_FN_SIOF0_SYNC, GPIO_FN_SIOF0_SS1, GPIO_FN_SIOF0_SS2,
-	GPIO_FN_SIOF0_TXD, GPIO_FN_SIOF0_RXD,
-
-	/* SIOF1 */
-	GPIO_FN_SIOF1_MCK, GPIO_FN_SIOF1_SCK,
-	GPIO_FN_SIOF1_SYNC, GPIO_FN_SIOF1_SS1, GPIO_FN_SIOF1_SS2,
-	GPIO_FN_SIOF1_TXD, GPIO_FN_SIOF1_RXD,
-
-	/* SIM */
-	GPIO_FN_SIM_D, GPIO_FN_SIM_CLK, GPIO_FN_SIM_RST,
-
-	/* TSIF */
-	GPIO_FN_TS_SDAT, GPIO_FN_TS_SCK, GPIO_FN_TS_SDEN, GPIO_FN_TS_SPSYNC,
-
-	/* IRDA */
-	GPIO_FN_IRDA_IN, GPIO_FN_IRDA_OUT,
-
-	/* TPU */
-	GPIO_FN_TPUTO,
-
-	/* FLCTL */
-	GPIO_FN_FCE, GPIO_FN_NAF7, GPIO_FN_NAF6, GPIO_FN_NAF5, GPIO_FN_NAF4,
-	GPIO_FN_NAF3, GPIO_FN_NAF2, GPIO_FN_NAF1, GPIO_FN_NAF0, GPIO_FN_FCDE,
-	GPIO_FN_FOE, GPIO_FN_FSC, GPIO_FN_FWE, GPIO_FN_FRB,
-
-	/* KEYSC */
-	GPIO_FN_KEYIN0, GPIO_FN_KEYIN1, GPIO_FN_KEYIN2, GPIO_FN_KEYIN3,
-	GPIO_FN_KEYIN4, GPIO_FN_KEYOUT0, GPIO_FN_KEYOUT1, GPIO_FN_KEYOUT2,
-	GPIO_FN_KEYOUT3, GPIO_FN_KEYOUT4_IN6, GPIO_FN_KEYOUT5_IN5,
-};
-
-enum {
-	HWBLK_URAM, HWBLK_XYMEM,
-	HWBLK_TMU, HWBLK_CMT, HWBLK_RWDT, HWBLK_FLCTL,
-	HWBLK_SCIF0, HWBLK_SCIF1, HWBLK_SCIF2, HWBLK_IIC, HWBLK_RTC,
-	HWBLK_SDHI, HWBLK_KEYSC,
-	HWBLK_USBF, HWBLK_2DG, HWBLK_SIU, HWBLK_VOU,
-	HWBLK_JPU, HWBLK_BEU, HWBLK_CEU, HWBLK_VEU, HWBLK_VPU,
-	HWBLK_LCDC,
-	HWBLK_NR,
-};
-
-enum {
-	SHDMA_SLAVE_INVALID,
-	SHDMA_SLAVE_SCIF0_TX,
-	SHDMA_SLAVE_SCIF0_RX,
-	SHDMA_SLAVE_SCIF1_TX,
-	SHDMA_SLAVE_SCIF1_RX,
-	SHDMA_SLAVE_SCIF2_TX,
-	SHDMA_SLAVE_SCIF2_RX,
-	SHDMA_SLAVE_SIUA_TX,
-	SHDMA_SLAVE_SIUA_RX,
-	SHDMA_SLAVE_SIUB_TX,
-	SHDMA_SLAVE_SIUB_RX,
-	SHDMA_SLAVE_SDHI0_TX,
-	SHDMA_SLAVE_SDHI0_RX,
-};
-
-#endif /* __ASM_SH7722_H__ */
diff --git a/arch/sh/include/cpu-sh4/cpu/sh7723.h b/arch/sh/include/cpu-sh4/cpu/sh7723.h
deleted file mode 100644
index 41f675307503d4..00000000000000
--- a/arch/sh/include/cpu-sh4/cpu/sh7723.h
+++ /dev/null
@@ -1,285 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH7723_H__
-#define __ASM_SH7723_H__
-
-/* Boot Mode Pins:
- *
- * MD0: CPG - Clock Mode 0->3
- * MD1: CPG - Clock Mode 0->3
- * MD2: CPG - Reserved (L: Normal operation)
- * MD3: BSC - Area0 Bus Width (16/32-bit) [CS0BCR.9,10]
- * MD5: BSC - Endian Mode (L: Big, H: Little) [CMNCR.3]
- * MD8: Test Mode
- */
-
-/* Pin Function Controller:
- * GPIO_FN_xx - GPIO used to select pin function
- * GPIO_Pxx - GPIO mapped to real I/O pin on CPU
- */
-enum {
-	/* PTA */
-	GPIO_PTA7, GPIO_PTA6, GPIO_PTA5, GPIO_PTA4,
-	GPIO_PTA3, GPIO_PTA2, GPIO_PTA1, GPIO_PTA0,
-
-	/* PTB */
-	GPIO_PTB7, GPIO_PTB6, GPIO_PTB5, GPIO_PTB4,
-	GPIO_PTB3, GPIO_PTB2, GPIO_PTB1, GPIO_PTB0,
-
-	/* PTC */
-	GPIO_PTC7, GPIO_PTC6, GPIO_PTC5, GPIO_PTC4,
-	GPIO_PTC3, GPIO_PTC2, GPIO_PTC1, GPIO_PTC0,
-
-	/* PTD */
-	GPIO_PTD7, GPIO_PTD6, GPIO_PTD5, GPIO_PTD4,
-	GPIO_PTD3, GPIO_PTD2, GPIO_PTD1, GPIO_PTD0,
-
-	/* PTE */
-	GPIO_PTE5, GPIO_PTE4, GPIO_PTE3, GPIO_PTE2,
-	GPIO_PTE1, GPIO_PTE0,
-
-	/* PTF */
-	GPIO_PTF7, GPIO_PTF6, GPIO_PTF5, GPIO_PTF4,
-	GPIO_PTF3, GPIO_PTF2, GPIO_PTF1, GPIO_PTF0,
-
-	/* PTG */
-	GPIO_PTG5, GPIO_PTG4, GPIO_PTG3, GPIO_PTG2,
-	GPIO_PTG1, GPIO_PTG0,
-
-	/* PTH */
-	GPIO_PTH7, GPIO_PTH6, GPIO_PTH5, GPIO_PTH4,
-	GPIO_PTH3, GPIO_PTH2, GPIO_PTH1, GPIO_PTH0,
-
-	/* PTJ */
-	GPIO_PTJ7, GPIO_PTJ5, GPIO_PTJ3, GPIO_PTJ2,
-	GPIO_PTJ1, GPIO_PTJ0,
-
-	/* PTK */
-	GPIO_PTK7, GPIO_PTK6, GPIO_PTK5, GPIO_PTK4,
-	GPIO_PTK3, GPIO_PTK2, GPIO_PTK1, GPIO_PTK0,
-
-	/* PTL */
-	GPIO_PTL7, GPIO_PTL6, GPIO_PTL5, GPIO_PTL4,
-	GPIO_PTL3, GPIO_PTL2, GPIO_PTL1, GPIO_PTL0,
-
-	/* PTM */
-	GPIO_PTM7, GPIO_PTM6, GPIO_PTM5, GPIO_PTM4,
-	GPIO_PTM3, GPIO_PTM2, GPIO_PTM1, GPIO_PTM0,
-
-	/* PTN */
-	GPIO_PTN7, GPIO_PTN6, GPIO_PTN5, GPIO_PTN4,
-	GPIO_PTN3, GPIO_PTN2, GPIO_PTN1, GPIO_PTN0,
-
-	/* PTQ */
-	GPIO_PTQ3, GPIO_PTQ2, GPIO_PTQ1, GPIO_PTQ0,
-
-	/* PTR */
-	GPIO_PTR7, GPIO_PTR6, GPIO_PTR5, GPIO_PTR4,
-	GPIO_PTR3, GPIO_PTR2, GPIO_PTR1, GPIO_PTR0,
-
-	/* PTS */
-	GPIO_PTS7, GPIO_PTS6, GPIO_PTS5, GPIO_PTS4,
-	GPIO_PTS3, GPIO_PTS2, GPIO_PTS1, GPIO_PTS0,
-
-	/* PTT */
-	GPIO_PTT5, GPIO_PTT4, GPIO_PTT3, GPIO_PTT2,
-	GPIO_PTT1, GPIO_PTT0,
-
-	/* PTU */
-	GPIO_PTU5, GPIO_PTU4, GPIO_PTU3, GPIO_PTU2,
-	GPIO_PTU1, GPIO_PTU0,
-
-	/* PTV */
-	GPIO_PTV7, GPIO_PTV6, GPIO_PTV5, GPIO_PTV4,
-	GPIO_PTV3, GPIO_PTV2, GPIO_PTV1, GPIO_PTV0,
-
-	/* PTW */
-	GPIO_PTW7, GPIO_PTW6, GPIO_PTW5, GPIO_PTW4,
-	GPIO_PTW3, GPIO_PTW2, GPIO_PTW1, GPIO_PTW0,
-
-	/* PTX */
-	GPIO_PTX7, GPIO_PTX6, GPIO_PTX5, GPIO_PTX4,
-	GPIO_PTX3, GPIO_PTX2, GPIO_PTX1, GPIO_PTX0,
-
-	/* PTY */
-	GPIO_PTY7, GPIO_PTY6, GPIO_PTY5, GPIO_PTY4,
-	GPIO_PTY3, GPIO_PTY2, GPIO_PTY1, GPIO_PTY0,
-
-	/* PTZ */
-	GPIO_PTZ7, GPIO_PTZ6, GPIO_PTZ5, GPIO_PTZ4,
-	GPIO_PTZ3, GPIO_PTZ2, GPIO_PTZ1, GPIO_PTZ0,
-
-	/* SCIF0 (SCIF: 3 pin PTT/PTU) */
-	GPIO_FN_SCIF0_PTT_TXD, GPIO_FN_SCIF0_PTT_RXD, GPIO_FN_SCIF0_PTT_SCK,
-	GPIO_FN_SCIF0_PTU_TXD, GPIO_FN_SCIF0_PTU_RXD, GPIO_FN_SCIF0_PTU_SCK,
-
-	/* SCIF1 (SCIF: 3 pin PTS/PTV) */
-	GPIO_FN_SCIF1_PTS_TXD, GPIO_FN_SCIF1_PTS_RXD, GPIO_FN_SCIF1_PTS_SCK,
-	GPIO_FN_SCIF1_PTV_TXD, GPIO_FN_SCIF1_PTV_RXD, GPIO_FN_SCIF1_PTV_SCK,
-
-	/* SCIF2 (SCIF: 3 pin PTT/PTU) */
-	GPIO_FN_SCIF2_PTT_TXD, GPIO_FN_SCIF2_PTT_RXD, GPIO_FN_SCIF2_PTT_SCK,
-	GPIO_FN_SCIF2_PTU_TXD, GPIO_FN_SCIF2_PTU_RXD, GPIO_FN_SCIF2_PTU_SCK,
-
-	/* SCIF3 (SCIFA: 5 pin PTS/PTV) */
-	GPIO_FN_SCIF3_PTS_TXD, GPIO_FN_SCIF3_PTS_RXD, GPIO_FN_SCIF3_PTS_SCK,
-	GPIO_FN_SCIF3_PTS_RTS, GPIO_FN_SCIF3_PTS_CTS,
-	GPIO_FN_SCIF3_PTV_TXD, GPIO_FN_SCIF3_PTV_RXD, GPIO_FN_SCIF3_PTV_SCK,
-	GPIO_FN_SCIF3_PTV_RTS, GPIO_FN_SCIF3_PTV_CTS,
-
-	/* SCIF4 (SCIFA: 3 pin PTE/PTN) */
-	GPIO_FN_SCIF4_PTE_TXD, GPIO_FN_SCIF4_PTE_RXD, GPIO_FN_SCIF4_PTE_SCK,
-	GPIO_FN_SCIF4_PTN_TXD, GPIO_FN_SCIF4_PTN_RXD, GPIO_FN_SCIF4_PTN_SCK,
-
-	/* SCIF5 (SCIFA: 3 pin PTE/PTN) */
-	GPIO_FN_SCIF5_PTE_TXD, GPIO_FN_SCIF5_PTE_RXD, GPIO_FN_SCIF5_PTE_SCK,
-	GPIO_FN_SCIF5_PTN_TXD, GPIO_FN_SCIF5_PTN_RXD, GPIO_FN_SCIF5_PTN_SCK,
-
-	/* CEU */
-	GPIO_FN_VIO_D15, GPIO_FN_VIO_D14, GPIO_FN_VIO_D13, GPIO_FN_VIO_D12,
-	GPIO_FN_VIO_D11, GPIO_FN_VIO_D10, GPIO_FN_VIO_D9, GPIO_FN_VIO_D8,
-	GPIO_FN_VIO_D7, GPIO_FN_VIO_D6, GPIO_FN_VIO_D5, GPIO_FN_VIO_D4,
-	GPIO_FN_VIO_D3, GPIO_FN_VIO_D2, GPIO_FN_VIO_D1, GPIO_FN_VIO_D0,
-	GPIO_FN_VIO_FLD, GPIO_FN_VIO_CKO,
-	GPIO_FN_VIO_VD1, GPIO_FN_VIO_HD1, GPIO_FN_VIO_CLK1,
-	GPIO_FN_VIO_VD2, GPIO_FN_VIO_HD2, GPIO_FN_VIO_CLK2,
-
-	/* LCDC */
-	GPIO_FN_LCDD23, GPIO_FN_LCDD22, GPIO_FN_LCDD21, GPIO_FN_LCDD20,
-	GPIO_FN_LCDD19, GPIO_FN_LCDD18, GPIO_FN_LCDD17, GPIO_FN_LCDD16,
-	GPIO_FN_LCDD15, GPIO_FN_LCDD14, GPIO_FN_LCDD13, GPIO_FN_LCDD12,
-	GPIO_FN_LCDD11, GPIO_FN_LCDD10, GPIO_FN_LCDD9, GPIO_FN_LCDD8,
-	GPIO_FN_LCDD7, GPIO_FN_LCDD6, GPIO_FN_LCDD5, GPIO_FN_LCDD4,
-	GPIO_FN_LCDD3, GPIO_FN_LCDD2, GPIO_FN_LCDD1, GPIO_FN_LCDD0,
-	GPIO_FN_LCDLCLK_PTR, GPIO_FN_LCDLCLK_PTW,
-	/* Main LCD */
-	GPIO_FN_LCDDON, GPIO_FN_LCDVCPWC, GPIO_FN_LCDVEPWC, GPIO_FN_LCDVSYN,
-	/* Main LCD - RGB Mode */
-	GPIO_FN_LCDDCK, GPIO_FN_LCDHSYN, GPIO_FN_LCDDISP,
-	/* Main LCD - SYS Mode */
-	GPIO_FN_LCDRS, GPIO_FN_LCDCS, GPIO_FN_LCDWR, GPIO_FN_LCDRD,
-
-	/* IRQ */
-	GPIO_FN_IRQ0, GPIO_FN_IRQ1, GPIO_FN_IRQ2, GPIO_FN_IRQ3,
-	GPIO_FN_IRQ4, GPIO_FN_IRQ5, GPIO_FN_IRQ6, GPIO_FN_IRQ7,
-
-	/* AUD */
-	GPIO_FN_AUDATA3, GPIO_FN_AUDATA2, GPIO_FN_AUDATA1, GPIO_FN_AUDATA0,
-	GPIO_FN_AUDCK, GPIO_FN_AUDSYNC,
-
-	/* SDHI0 (PTD) */
-	GPIO_FN_SDHI0CD_PTD, GPIO_FN_SDHI0WP_PTD,
-	GPIO_FN_SDHI0D3_PTD, GPIO_FN_SDHI0D2_PTD,
-	GPIO_FN_SDHI0D1_PTD, GPIO_FN_SDHI0D0_PTD,
-	GPIO_FN_SDHI0CMD_PTD, GPIO_FN_SDHI0CLK_PTD,
-
-	/* SDHI0 (PTS) */
-	GPIO_FN_SDHI0CD_PTS, GPIO_FN_SDHI0WP_PTS,
-	GPIO_FN_SDHI0D3_PTS, GPIO_FN_SDHI0D2_PTS,
-	GPIO_FN_SDHI0D1_PTS, GPIO_FN_SDHI0D0_PTS,
-	GPIO_FN_SDHI0CMD_PTS, GPIO_FN_SDHI0CLK_PTS,
-
-	/* SDHI1 */
-	GPIO_FN_SDHI1CD, GPIO_FN_SDHI1WP, GPIO_FN_SDHI1D3, GPIO_FN_SDHI1D2,
-	GPIO_FN_SDHI1D1, GPIO_FN_SDHI1D0, GPIO_FN_SDHI1CMD, GPIO_FN_SDHI1CLK,
-
-	/* SIUA */
-	GPIO_FN_SIUAFCK, GPIO_FN_SIUAILR, GPIO_FN_SIUAIBT, GPIO_FN_SIUAISLD,
-	GPIO_FN_SIUAOLR, GPIO_FN_SIUAOBT, GPIO_FN_SIUAOSLD, GPIO_FN_SIUAMCK,
-	GPIO_FN_SIUAISPD, GPIO_FN_SIUAOSPD,
-
-	/* SIUB */
-	GPIO_FN_SIUBFCK, GPIO_FN_SIUBILR, GPIO_FN_SIUBIBT, GPIO_FN_SIUBISLD,
-	GPIO_FN_SIUBOLR, GPIO_FN_SIUBOBT, GPIO_FN_SIUBOSLD, GPIO_FN_SIUBMCK,
-
-	/* IRDA */
-	GPIO_FN_IRDA_IN, GPIO_FN_IRDA_OUT,
-
-	/* VOU */
-	GPIO_FN_DV_CLKI, GPIO_FN_DV_CLK, GPIO_FN_DV_HSYNC, GPIO_FN_DV_VSYNC,
-	GPIO_FN_DV_D15, GPIO_FN_DV_D14, GPIO_FN_DV_D13, GPIO_FN_DV_D12,
-	GPIO_FN_DV_D11, GPIO_FN_DV_D10, GPIO_FN_DV_D9, GPIO_FN_DV_D8,
-	GPIO_FN_DV_D7, GPIO_FN_DV_D6, GPIO_FN_DV_D5, GPIO_FN_DV_D4,
-	GPIO_FN_DV_D3, GPIO_FN_DV_D2, GPIO_FN_DV_D1, GPIO_FN_DV_D0,
-
-	/* KEYSC */
-	GPIO_FN_KEYIN0, GPIO_FN_KEYIN1, GPIO_FN_KEYIN2, GPIO_FN_KEYIN3,
-	GPIO_FN_KEYIN4, GPIO_FN_KEYOUT0, GPIO_FN_KEYOUT1, GPIO_FN_KEYOUT2,
-	GPIO_FN_KEYOUT3, GPIO_FN_KEYOUT4_IN6, GPIO_FN_KEYOUT5_IN5,
-
-	/* MSIOF0 (PTF) */
-	GPIO_FN_MSIOF0_PTF_TXD, GPIO_FN_MSIOF0_PTF_RXD, GPIO_FN_MSIOF0_PTF_MCK,
-	GPIO_FN_MSIOF0_PTF_TSYNC, GPIO_FN_MSIOF0_PTF_TSCK,
-	GPIO_FN_MSIOF0_PTF_RSYNC, GPIO_FN_MSIOF0_PTF_RSCK,
-	GPIO_FN_MSIOF0_PTF_SS1, GPIO_FN_MSIOF0_PTF_SS2,
-
-	/* MSIOF0 (PTT+PTX) */
-	GPIO_FN_MSIOF0_PTT_TXD, GPIO_FN_MSIOF0_PTT_RXD, GPIO_FN_MSIOF0_PTX_MCK,
-	GPIO_FN_MSIOF0_PTT_TSYNC, GPIO_FN_MSIOF0_PTT_TSCK,
-	GPIO_FN_MSIOF0_PTT_RSYNC, GPIO_FN_MSIOF0_PTT_RSCK,
-	GPIO_FN_MSIOF0_PTT_SS1, GPIO_FN_MSIOF0_PTT_SS2,
-
-	/* MSIOF1 */
-	GPIO_FN_MSIOF1_TXD, GPIO_FN_MSIOF1_RXD, GPIO_FN_MSIOF1_MCK,
-	GPIO_FN_MSIOF1_TSYNC, GPIO_FN_MSIOF1_TSCK,
-	GPIO_FN_MSIOF1_RSYNC, GPIO_FN_MSIOF1_RSCK,
-	GPIO_FN_MSIOF1_SS1, GPIO_FN_MSIOF1_SS2,
-
-	/* TSIF */
-	GPIO_FN_TS0_SDAT, GPIO_FN_TS0_SCK, GPIO_FN_TS0_SDEN, GPIO_FN_TS0_SPSYNC,
-
-	/* FLCTL */
-	GPIO_FN_FCE, GPIO_FN_NAF7, GPIO_FN_NAF6, GPIO_FN_NAF5, GPIO_FN_NAF4,
-	GPIO_FN_NAF3, GPIO_FN_NAF2, GPIO_FN_NAF1, GPIO_FN_NAF0, GPIO_FN_FCDE,
-	GPIO_FN_FOE, GPIO_FN_FSC, GPIO_FN_FWE, GPIO_FN_FRB,
-
-	/* DMAC */
-	GPIO_FN_DACK1, GPIO_FN_DREQ1, GPIO_FN_DACK0, GPIO_FN_DREQ0,
-
-	/* ADC */
-	GPIO_FN_AN3, GPIO_FN_AN2, GPIO_FN_AN1, GPIO_FN_AN0, GPIO_FN_ADTRG,
-
-	/* CPG */
-	GPIO_FN_STATUS0, GPIO_FN_PDSTATUS,
-
-	/* TPU */
-	GPIO_FN_TPUTO3, GPIO_FN_TPUTO2, GPIO_FN_TPUTO1, GPIO_FN_TPUTO0,
-
-	/* BSC */
-	GPIO_FN_D31, GPIO_FN_D30, GPIO_FN_D29, GPIO_FN_D28,
-	GPIO_FN_D27, GPIO_FN_D26, GPIO_FN_D25, GPIO_FN_D24,
-	GPIO_FN_D23, GPIO_FN_D22, GPIO_FN_D21, GPIO_FN_D20,
-	GPIO_FN_D19, GPIO_FN_D18, GPIO_FN_D17, GPIO_FN_D16,
-	GPIO_FN_IOIS16, GPIO_FN_WAIT, GPIO_FN_BS,
-	GPIO_FN_A25, GPIO_FN_A24, GPIO_FN_A23, GPIO_FN_A22,
-	GPIO_FN_CS6B_CE1B, GPIO_FN_CS6A_CE2B,
-	GPIO_FN_CS5B_CE1A, GPIO_FN_CS5A_CE2A,
-	GPIO_FN_WE3_ICIOWR, GPIO_FN_WE2_ICIORD,
-
-	/* ATAPI */
-	GPIO_FN_IDED15, GPIO_FN_IDED14, GPIO_FN_IDED13, GPIO_FN_IDED12,
-	GPIO_FN_IDED11, GPIO_FN_IDED10, GPIO_FN_IDED9, GPIO_FN_IDED8,
-	GPIO_FN_IDED7, GPIO_FN_IDED6, GPIO_FN_IDED5, GPIO_FN_IDED4,
-	GPIO_FN_IDED3, GPIO_FN_IDED2, GPIO_FN_IDED1, GPIO_FN_IDED0,
-	GPIO_FN_DIRECTION, GPIO_FN_EXBUF_ENB, GPIO_FN_IDERST, GPIO_FN_IODACK,
-	GPIO_FN_IODREQ, GPIO_FN_IDEIORDY, GPIO_FN_IDEINT, GPIO_FN_IDEIOWR,
-	GPIO_FN_IDEIORD, GPIO_FN_IDECS1, GPIO_FN_IDECS0, GPIO_FN_IDEA2,
-	GPIO_FN_IDEA1, GPIO_FN_IDEA0,
-};
-
-enum {
-	HWBLK_TLB, HWBLK_IC, HWBLK_OC, HWBLK_L2C, HWBLK_ILMEM, HWBLK_FPU,
-	HWBLK_INTC, HWBLK_DMAC0, HWBLK_SHYWAY,
-	HWBLK_HUDI, HWBLK_UBC,
-	HWBLK_TMU0, HWBLK_CMT, HWBLK_RWDT, HWBLK_DMAC1, HWBLK_TMU1,
-	HWBLK_FLCTL,
-	HWBLK_SCIF0, HWBLK_SCIF1, HWBLK_SCIF2,
-	HWBLK_SCIF3, HWBLK_SCIF4, HWBLK_SCIF5,
-	HWBLK_MSIOF0, HWBLK_MSIOF1, HWBLK_MERAM, HWBLK_IIC, HWBLK_RTC,
-	HWBLK_ATAPI, HWBLK_ADC, HWBLK_TPU, HWBLK_IRDA, HWBLK_TSIF, HWBLK_ICB,
-	HWBLK_SDHI0, HWBLK_SDHI1, HWBLK_KEYSC, HWBLK_USB,
-	HWBLK_2DG, HWBLK_SIU, HWBLK_VEU2H1, HWBLK_VOU, HWBLK_BEU, HWBLK_CEU,
-	HWBLK_VEU2H0, HWBLK_VPU, HWBLK_LCDC,
-	HWBLK_NR,
-};
-
-#endif /* __ASM_SH7723_H__ */
diff --git a/arch/sh/include/cpu-sh4/cpu/sh7724.h b/arch/sh/include/cpu-sh4/cpu/sh7724.h
deleted file mode 100644
index b3a7caf54c9d68..00000000000000
--- a/arch/sh/include/cpu-sh4/cpu/sh7724.h
+++ /dev/null
@@ -1,319 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH7724_H__
-#define __ASM_SH7724_H__
-
-/* Boot Mode Pins:
- *
- * MD0: CPG - Clock Mode 0->7
- * MD1: CPG - Clock Mode 0->7
- * MD2: CPG - Clock Mode 0->7
- * MD3: BSC - Area0 Bus Width (16/32-bit) [CS0BCR.9,10]
- * MD5: BSC - Endian Mode (L: Big, H: Little) [CMNCR.3]
- * MD8: Test Mode
- * BOOT: FBR - Boot Mode (L: MMCIF, H: Area0)
- */
-
-/* Pin Function Controller:
- * GPIO_FN_xx - GPIO used to select pin function
- * GPIO_Pxx - GPIO mapped to real I/O pin on CPU
- */
-enum {
-	/* PTA */
-	GPIO_PTA7, GPIO_PTA6, GPIO_PTA5, GPIO_PTA4,
-	GPIO_PTA3, GPIO_PTA2, GPIO_PTA1, GPIO_PTA0,
-
-	/* PTB */
-	GPIO_PTB7, GPIO_PTB6, GPIO_PTB5, GPIO_PTB4,
-	GPIO_PTB3, GPIO_PTB2, GPIO_PTB1, GPIO_PTB0,
-
-	/* PTC */
-	GPIO_PTC7, GPIO_PTC6, GPIO_PTC5, GPIO_PTC4,
-	GPIO_PTC3, GPIO_PTC2, GPIO_PTC1, GPIO_PTC0,
-
-	/* PTD */
-	GPIO_PTD7, GPIO_PTD6, GPIO_PTD5, GPIO_PTD4,
-	GPIO_PTD3, GPIO_PTD2, GPIO_PTD1, GPIO_PTD0,
-
-	/* PTE */
-	GPIO_PTE7, GPIO_PTE6, GPIO_PTE5, GPIO_PTE4,
-	GPIO_PTE3, GPIO_PTE2, GPIO_PTE1, GPIO_PTE0,
-
-	/* PTF */
-	GPIO_PTF7, GPIO_PTF6, GPIO_PTF5, GPIO_PTF4,
-	GPIO_PTF3, GPIO_PTF2, GPIO_PTF1, GPIO_PTF0,
-
-	/* PTG */
-			      GPIO_PTG5, GPIO_PTG4,
-	GPIO_PTG3, GPIO_PTG2, GPIO_PTG1, GPIO_PTG0,
-
-	/* PTH */
-	GPIO_PTH7, GPIO_PTH6, GPIO_PTH5, GPIO_PTH4,
-	GPIO_PTH3, GPIO_PTH2, GPIO_PTH1, GPIO_PTH0,
-
-	/* PTJ */
-	GPIO_PTJ7, GPIO_PTJ6, GPIO_PTJ5,
-	GPIO_PTJ3, GPIO_PTJ2, GPIO_PTJ1, GPIO_PTJ0,
-
-	/* PTK */
-	GPIO_PTK7, GPIO_PTK6, GPIO_PTK5, GPIO_PTK4,
-	GPIO_PTK3, GPIO_PTK2, GPIO_PTK1, GPIO_PTK0,
-
-	/* PTL */
-	GPIO_PTL7, GPIO_PTL6, GPIO_PTL5, GPIO_PTL4,
-	GPIO_PTL3, GPIO_PTL2, GPIO_PTL1, GPIO_PTL0,
-
-	/* PTM */
-	GPIO_PTM7, GPIO_PTM6, GPIO_PTM5, GPIO_PTM4,
-	GPIO_PTM3, GPIO_PTM2, GPIO_PTM1, GPIO_PTM0,
-
-	/* PTN */
-	GPIO_PTN7, GPIO_PTN6, GPIO_PTN5, GPIO_PTN4,
-	GPIO_PTN3, GPIO_PTN2, GPIO_PTN1, GPIO_PTN0,
-
-	/* PTQ */
-	GPIO_PTQ7, GPIO_PTQ6, GPIO_PTQ5, GPIO_PTQ4,
-	GPIO_PTQ3, GPIO_PTQ2, GPIO_PTQ1, GPIO_PTQ0,
-
-	/* PTR */
-	GPIO_PTR7, GPIO_PTR6, GPIO_PTR5, GPIO_PTR4,
-	GPIO_PTR3, GPIO_PTR2, GPIO_PTR1, GPIO_PTR0,
-
-	/* PTS */
-		   GPIO_PTS6, GPIO_PTS5, GPIO_PTS4,
-	GPIO_PTS3, GPIO_PTS2, GPIO_PTS1, GPIO_PTS0,
-
-	/* PTT */
-	GPIO_PTT7, GPIO_PTT6, GPIO_PTT5, GPIO_PTT4,
-	GPIO_PTT3, GPIO_PTT2, GPIO_PTT1, GPIO_PTT0,
-
-	/* PTU */
-	GPIO_PTU7, GPIO_PTU6, GPIO_PTU5, GPIO_PTU4,
-	GPIO_PTU3, GPIO_PTU2, GPIO_PTU1, GPIO_PTU0,
-
-	/* PTV */
-	GPIO_PTV7, GPIO_PTV6, GPIO_PTV5, GPIO_PTV4,
-	GPIO_PTV3, GPIO_PTV2, GPIO_PTV1, GPIO_PTV0,
-
-	/* PTW */
-	GPIO_PTW7, GPIO_PTW6, GPIO_PTW5, GPIO_PTW4,
-	GPIO_PTW3, GPIO_PTW2, GPIO_PTW1, GPIO_PTW0,
-
-	/* PTX */
-	GPIO_PTX7, GPIO_PTX6, GPIO_PTX5, GPIO_PTX4,
-	GPIO_PTX3, GPIO_PTX2, GPIO_PTX1, GPIO_PTX0,
-
-	/* PTY */
-	GPIO_PTY7, GPIO_PTY6, GPIO_PTY5, GPIO_PTY4,
-	GPIO_PTY3, GPIO_PTY2, GPIO_PTY1, GPIO_PTY0,
-
-	/* PTZ */
-	GPIO_PTZ7, GPIO_PTZ6, GPIO_PTZ5, GPIO_PTZ4,
-	GPIO_PTZ3, GPIO_PTZ2, GPIO_PTZ1, GPIO_PTZ0,
-
-	/* BSC (PTA/PTB/PTJ/PTQ/PTR/PTT) */
-	GPIO_FN_D31, GPIO_FN_D30, GPIO_FN_D29, GPIO_FN_D28,
-	GPIO_FN_D27, GPIO_FN_D26, GPIO_FN_D25, GPIO_FN_D24,
-	GPIO_FN_D23, GPIO_FN_D22, GPIO_FN_D21, GPIO_FN_D20,
-	GPIO_FN_D19, GPIO_FN_D18, GPIO_FN_D17, GPIO_FN_D16,
-	GPIO_FN_D15, GPIO_FN_D14, GPIO_FN_D13, GPIO_FN_D12,
-	GPIO_FN_D11, GPIO_FN_D10, GPIO_FN_D9,  GPIO_FN_D8,
-	GPIO_FN_D7,  GPIO_FN_D6,  GPIO_FN_D5,  GPIO_FN_D4,
-	GPIO_FN_D3,  GPIO_FN_D2,  GPIO_FN_D1,  GPIO_FN_D0,
-	GPIO_FN_A25, GPIO_FN_A24, GPIO_FN_A23, GPIO_FN_A22,
-	GPIO_FN_CS6B_CE1B,  GPIO_FN_CS6A_CE2B,
-	GPIO_FN_CS5B_CE1A,  GPIO_FN_CS5A_CE2A,
-	GPIO_FN_WE3_ICIOWR, GPIO_FN_WE2_ICIORD,
-	GPIO_FN_IOIS16,     GPIO_FN_WAIT,
-	GPIO_FN_BS,
-
-	/* KEYSC (PTA/PTB)*/
-	GPIO_FN_KEYOUT5_IN5, GPIO_FN_KEYOUT4_IN6, GPIO_FN_KEYIN4,
-	GPIO_FN_KEYIN3,  GPIO_FN_KEYIN2,  GPIO_FN_KEYIN1,  GPIO_FN_KEYIN0,
-	GPIO_FN_KEYOUT3, GPIO_FN_KEYOUT2, GPIO_FN_KEYOUT1, GPIO_FN_KEYOUT0,
-
-	/* ATAPI (PTA/PTB/PTK/PTR/PTS/PTW) */
-	GPIO_FN_IDED15, GPIO_FN_IDED14, GPIO_FN_IDED13, GPIO_FN_IDED12,
-	GPIO_FN_IDED11, GPIO_FN_IDED10, GPIO_FN_IDED9,  GPIO_FN_IDED8,
-	GPIO_FN_IDED7,  GPIO_FN_IDED6,  GPIO_FN_IDED5,  GPIO_FN_IDED4,
-	GPIO_FN_IDED3,  GPIO_FN_IDED2,  GPIO_FN_IDED1,  GPIO_FN_IDED0,
-	GPIO_FN_IDEA2,     GPIO_FN_IDEA1,     GPIO_FN_IDEA0,  GPIO_FN_IDEIOWR,
-	GPIO_FN_IODREQ,    GPIO_FN_IDECS0,    GPIO_FN_IDECS1, GPIO_FN_IDEIORD,
-	GPIO_FN_DIRECTION, GPIO_FN_EXBUF_ENB, GPIO_FN_IDERST, GPIO_FN_IODACK,
-	GPIO_FN_IDEINT,    GPIO_FN_IDEIORDY,
-
-	/* TPU (PTB/PTR/PTS) */
-	GPIO_FN_TPUTO3, GPIO_FN_TPUTO2, GPIO_FN_TPUTO1, GPIO_FN_TPUTO0,
-	GPIO_FN_TPUTI3, GPIO_FN_TPUTI2,
-
-	/* LCDC (PTC/PTD/PTE/PTF/PTM/PTR) */
-	GPIO_FN_LCDD23, GPIO_FN_LCDD22, GPIO_FN_LCDD21, GPIO_FN_LCDD20,
-	GPIO_FN_LCDD19, GPIO_FN_LCDD18, GPIO_FN_LCDD17, GPIO_FN_LCDD16,
-	GPIO_FN_LCDD15, GPIO_FN_LCDD14, GPIO_FN_LCDD13, GPIO_FN_LCDD12,
-	GPIO_FN_LCDD11, GPIO_FN_LCDD10, GPIO_FN_LCDD9,  GPIO_FN_LCDD8,
-	GPIO_FN_LCDD7,  GPIO_FN_LCDD6,  GPIO_FN_LCDD5,  GPIO_FN_LCDD4,
-	GPIO_FN_LCDD3,  GPIO_FN_LCDD2,  GPIO_FN_LCDD1,  GPIO_FN_LCDD0,
-	GPIO_FN_LCDVSYN,  GPIO_FN_LCDDISP,  GPIO_FN_LCDRS,  GPIO_FN_LCDHSYN,
-	GPIO_FN_LCDCS,    GPIO_FN_LCDDON,   GPIO_FN_LCDDCK, GPIO_FN_LCDWR,
-	GPIO_FN_LCDVEPWC, GPIO_FN_LCDVCPWC, GPIO_FN_LCDRD,  GPIO_FN_LCDLCLK,
-
-	/* SCIF0 (PTF/PTM) */
-	GPIO_FN_SCIF0_TXD, GPIO_FN_SCIF0_RXD, GPIO_FN_SCIF0_SCK,
-
-	/* SCIF1 (PTL) */
-	GPIO_FN_SCIF1_SCK, GPIO_FN_SCIF1_RXD, GPIO_FN_SCIF1_TXD,
-
-	/* SCIF2 (PTE/PTF/PTN) with LCDC, VOU */
-	GPIO_FN_SCIF2_L_TXD, GPIO_FN_SCIF2_L_SCK, GPIO_FN_SCIF2_L_RXD,
-	GPIO_FN_SCIF2_V_TXD, GPIO_FN_SCIF2_V_SCK, GPIO_FN_SCIF2_V_RXD,
-
-	/* SCIF3 (PTL/PTN/PTZ) with VOU, IRQ */
-	GPIO_FN_SCIF3_V_SCK, GPIO_FN_SCIF3_V_RXD, GPIO_FN_SCIF3_V_TXD,
-	GPIO_FN_SCIF3_V_CTS, GPIO_FN_SCIF3_V_RTS,
-	GPIO_FN_SCIF3_I_SCK, GPIO_FN_SCIF3_I_RXD, GPIO_FN_SCIF3_I_TXD,
-	GPIO_FN_SCIF3_I_CTS, GPIO_FN_SCIF3_I_RTS,
-
-	/* SCIF4 (PTE) */
-	GPIO_FN_SCIF4_SCK, GPIO_FN_SCIF4_RXD, GPIO_FN_SCIF4_TXD,
-
-	/* SCIF5 (PTS) */
-	GPIO_FN_SCIF5_SCK, GPIO_FN_SCIF5_RXD, GPIO_FN_SCIF5_TXD,
-
-	/* FSI (PTE/PTU/PTV) */
-	GPIO_FN_FSIMCKB,   GPIO_FN_FSIMCKA,    GPIO_FN_FSIOASD,
-	GPIO_FN_FSIIABCK,  GPIO_FN_FSIIALRCK,  GPIO_FN_FSIOABCK,
-	GPIO_FN_FSIOALRCK, GPIO_FN_CLKAUDIOAO, GPIO_FN_FSIIBSD,
-	GPIO_FN_FSIOBSD,   GPIO_FN_FSIIBBCK,   GPIO_FN_FSIIBLRCK,
-	GPIO_FN_FSIOBBCK,  GPIO_FN_FSIOBLRCK,  GPIO_FN_CLKAUDIOBO,
-	GPIO_FN_FSIIASD,
-
-	/* AUD (PTG) */
-	GPIO_FN_AUDCK,   GPIO_FN_AUDSYNC, GPIO_FN_AUDATA3,
-	GPIO_FN_AUDATA2, GPIO_FN_AUDATA1, GPIO_FN_AUDATA0,
-
-	/* VIO (PTS) (common?) */
-	GPIO_FN_VIO_CKO,
-
-	/* VIO0 (PTH/PTK) */
-	GPIO_FN_VIO0_D15, GPIO_FN_VIO0_D14, GPIO_FN_VIO0_D13, GPIO_FN_VIO0_D12,
-	GPIO_FN_VIO0_D11, GPIO_FN_VIO0_D10, GPIO_FN_VIO0_D9,  GPIO_FN_VIO0_D8,
-	GPIO_FN_VIO0_D7,  GPIO_FN_VIO0_D6,  GPIO_FN_VIO0_D5,  GPIO_FN_VIO0_D4,
-	GPIO_FN_VIO0_D3,  GPIO_FN_VIO0_D2,  GPIO_FN_VIO0_D1,  GPIO_FN_VIO0_D0,
-	GPIO_FN_VIO0_VD,  GPIO_FN_VIO0_CLK,
-	GPIO_FN_VIO0_FLD, GPIO_FN_VIO0_HD,
-
-	/* VIO1 (PTK/PTS) */
-	GPIO_FN_VIO1_D7,  GPIO_FN_VIO1_D6, GPIO_FN_VIO1_D5, GPIO_FN_VIO1_D4,
-	GPIO_FN_VIO1_D3,  GPIO_FN_VIO1_D2, GPIO_FN_VIO1_D1, GPIO_FN_VIO1_D0,
-	GPIO_FN_VIO1_FLD, GPIO_FN_VIO1_HD, GPIO_FN_VIO1_VD, GPIO_FN_VIO1_CLK,
-
-	/* Eth  (PTL/PTN/PTX) */
-	GPIO_FN_RMII_RXD0,    GPIO_FN_RMII_RXD1,
-	GPIO_FN_RMII_TXD0,    GPIO_FN_RMII_TXD1,
-	GPIO_FN_RMII_REF_CLK, GPIO_FN_RMII_TX_EN,
-	GPIO_FN_RMII_RX_ER,   GPIO_FN_RMII_CRS_DV,
-	GPIO_FN_LNKSTA,       GPIO_FN_MDIO,
-	GPIO_FN_MDC,
-
-	/* System (PTJ) */
-	GPIO_FN_PDSTATUS, GPIO_FN_STATUS2, GPIO_FN_STATUS0,
-
-	/* VOU (PTL/PTM/PTN*/
-	GPIO_FN_DV_D15,  GPIO_FN_DV_D14, GPIO_FN_DV_D13,   GPIO_FN_DV_D12,
-	GPIO_FN_DV_D11,  GPIO_FN_DV_D10, GPIO_FN_DV_D9,    GPIO_FN_DV_D8,
-	GPIO_FN_DV_D7,   GPIO_FN_DV_D6,  GPIO_FN_DV_D5,    GPIO_FN_DV_D4,
-	GPIO_FN_DV_D3,   GPIO_FN_DV_D2,  GPIO_FN_DV_D1,    GPIO_FN_DV_D0,
-	GPIO_FN_DV_CLKI, GPIO_FN_DV_CLK, GPIO_FN_DV_VSYNC, GPIO_FN_DV_HSYNC,
-
-	/* MSIOF0 (PTL/PTM) */
-	GPIO_FN_MSIOF0_RXD,   GPIO_FN_MSIOF0_TXD,
-	GPIO_FN_MSIOF0_MCK,   GPIO_FN_MSIOF0_TSCK,
-	GPIO_FN_MSIOF0_SS1,   GPIO_FN_MSIOF0_SS2,
-	GPIO_FN_MSIOF0_TSYNC, GPIO_FN_MSIOF0_RSCK,
-	GPIO_FN_MSIOF0_RSYNC,
-
-	/* MSIOF1 (PTV) */
-	GPIO_FN_MSIOF1_RXD,   GPIO_FN_MSIOF1_TXD,
-	GPIO_FN_MSIOF1_MCK,   GPIO_FN_MSIOF1_TSCK,
-	GPIO_FN_MSIOF1_SS1,   GPIO_FN_MSIOF1_SS2,
-	GPIO_FN_MSIOF1_TSYNC, GPIO_FN_MSIOF1_RSCK,
-	GPIO_FN_MSIOF1_RSYNC,
-
-	/* DMAC (PTU/PTX) */
-	GPIO_FN_DMAC_DACK0, GPIO_FN_DMAC_DREQ0,
-	GPIO_FN_DMAC_DACK1, GPIO_FN_DMAC_DREQ1,
-
-	/* SDHI0 (PTY) */
-	GPIO_FN_SDHI0CD, GPIO_FN_SDHI0WP, GPIO_FN_SDHI0CMD, GPIO_FN_SDHI0CLK,
-	GPIO_FN_SDHI0D3, GPIO_FN_SDHI0D2, GPIO_FN_SDHI0D1,  GPIO_FN_SDHI0D0,
-
-	/* SDHI1 (PTW) */
-	GPIO_FN_SDHI1CD, GPIO_FN_SDHI1WP, GPIO_FN_SDHI1CMD, GPIO_FN_SDHI1CLK,
-	GPIO_FN_SDHI1D3, GPIO_FN_SDHI1D2, GPIO_FN_SDHI1D1,  GPIO_FN_SDHI1D0,
-
-	/* MMC (PTW/PTX)*/
-	GPIO_FN_MMC_D7,  GPIO_FN_MMC_D6,  GPIO_FN_MMC_D5, GPIO_FN_MMC_D4,
-	GPIO_FN_MMC_D3,  GPIO_FN_MMC_D2,  GPIO_FN_MMC_D1, GPIO_FN_MMC_D0,
-	GPIO_FN_MMC_CLK, GPIO_FN_MMC_CMD,
-
-	/* IrDA (PTX) */
-	GPIO_FN_IRDA_OUT, GPIO_FN_IRDA_IN,
-
-	/* TSIF (PTX) */
-	GPIO_FN_TSIF_TS0_SDAT, GPIO_FN_TSIF_TS0_SCK,
-	GPIO_FN_TSIF_TS0_SDEN, GPIO_FN_TSIF_TS0_SPSYNC,
-
-	/* IRQ (PTZ) */
-	GPIO_FN_INTC_IRQ7, GPIO_FN_INTC_IRQ6, GPIO_FN_INTC_IRQ5,
-	GPIO_FN_INTC_IRQ4, GPIO_FN_INTC_IRQ3, GPIO_FN_INTC_IRQ2,
-	GPIO_FN_INTC_IRQ1, GPIO_FN_INTC_IRQ0,
-};
-
-enum {
-	HWBLK_TLB, HWBLK_IC, HWBLK_OC, HWBLK_RSMEM, HWBLK_ILMEM, HWBLK_L2C,
-	HWBLK_FPU, HWBLK_INTC, HWBLK_DMAC0, HWBLK_SHYWAY,
-	HWBLK_HUDI, HWBLK_UBC,
-	HWBLK_TMU0, HWBLK_CMT, HWBLK_RWDT, HWBLK_DMAC1, HWBLK_TMU1,
-	HWBLK_SCIF0, HWBLK_SCIF1, HWBLK_SCIF2, HWBLK_SCIF3,
-	HWBLK_SCIF4, HWBLK_SCIF5, HWBLK_MSIOF0, HWBLK_MSIOF1,
-	HWBLK_KEYSC, HWBLK_RTC, HWBLK_IIC0, HWBLK_IIC1,
-	HWBLK_MMC, HWBLK_ETHER, HWBLK_ATAPI, HWBLK_TPU, HWBLK_IRDA,
-	HWBLK_TSIF, HWBLK_USB1, HWBLK_USB0, HWBLK_2DG,
-	HWBLK_SDHI0, HWBLK_SDHI1, HWBLK_VEU1, HWBLK_CEU1, HWBLK_BEU1,
-	HWBLK_2DDMAC, HWBLK_SPU, HWBLK_JPU, HWBLK_VOU,
-	HWBLK_BEU0, HWBLK_CEU0,	HWBLK_VEU0, HWBLK_VPU, HWBLK_LCDC,
-	HWBLK_NR,
-};
-
-enum {
-	SHDMA_SLAVE_INVALID,
-	SHDMA_SLAVE_SCIF0_TX,
-	SHDMA_SLAVE_SCIF0_RX,
-	SHDMA_SLAVE_SCIF1_TX,
-	SHDMA_SLAVE_SCIF1_RX,
-	SHDMA_SLAVE_SCIF2_TX,
-	SHDMA_SLAVE_SCIF2_RX,
-	SHDMA_SLAVE_SCIF3_TX,
-	SHDMA_SLAVE_SCIF3_RX,
-	SHDMA_SLAVE_SCIF4_TX,
-	SHDMA_SLAVE_SCIF4_RX,
-	SHDMA_SLAVE_SCIF5_TX,
-	SHDMA_SLAVE_SCIF5_RX,
-	SHDMA_SLAVE_USB0D0_TX,
-	SHDMA_SLAVE_USB0D0_RX,
-	SHDMA_SLAVE_USB0D1_TX,
-	SHDMA_SLAVE_USB0D1_RX,
-	SHDMA_SLAVE_USB1D0_TX,
-	SHDMA_SLAVE_USB1D0_RX,
-	SHDMA_SLAVE_USB1D1_TX,
-	SHDMA_SLAVE_USB1D1_RX,
-	SHDMA_SLAVE_SDHI0_TX,
-	SHDMA_SLAVE_SDHI0_RX,
-	SHDMA_SLAVE_SDHI1_TX,
-	SHDMA_SLAVE_SDHI1_RX,
-};
-
-extern struct clk sh7724_fsimcka_clk;
-extern struct clk sh7724_fsimckb_clk;
-extern struct clk sh7724_dv_clki;
-
-#endif /* __ASM_SH7724_H__ */
diff --git a/arch/sh/include/cpu-sh4/cpu/sh7734.h b/arch/sh/include/cpu-sh4/cpu/sh7734.h
deleted file mode 100644
index 82b63208135aec..00000000000000
--- a/arch/sh/include/cpu-sh4/cpu/sh7734.h
+++ /dev/null
@@ -1,307 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH7734_H__
-#define __ASM_SH7734_H__
-
-/* Pin Function Controller:
- * GPIO_FN_xx - GPIO used to select pin function
- * GPIO_GP_x_x - GPIO mapped to real I/O pin on CPU
- */
-enum {
-	GPIO_GP_0_0, GPIO_GP_0_1, GPIO_GP_0_2, GPIO_GP_0_3,
-	GPIO_GP_0_4, GPIO_GP_0_5, GPIO_GP_0_6, GPIO_GP_0_7,
-	GPIO_GP_0_8, GPIO_GP_0_9, GPIO_GP_0_10, GPIO_GP_0_11,
-	GPIO_GP_0_12, GPIO_GP_0_13, GPIO_GP_0_14, GPIO_GP_0_15,
-	GPIO_GP_0_16, GPIO_GP_0_17, GPIO_GP_0_18, GPIO_GP_0_19,
-	GPIO_GP_0_20, GPIO_GP_0_21, GPIO_GP_0_22, GPIO_GP_0_23,
-	GPIO_GP_0_24, GPIO_GP_0_25, GPIO_GP_0_26, GPIO_GP_0_27,
-	GPIO_GP_0_28, GPIO_GP_0_29, GPIO_GP_0_30, GPIO_GP_0_31,
-
-	GPIO_GP_1_0, GPIO_GP_1_1, GPIO_GP_1_2, GPIO_GP_1_3,
-	GPIO_GP_1_4, GPIO_GP_1_5, GPIO_GP_1_6, GPIO_GP_1_7,
-	GPIO_GP_1_8, GPIO_GP_1_9, GPIO_GP_1_10, GPIO_GP_1_11,
-	GPIO_GP_1_12, GPIO_GP_1_13, GPIO_GP_1_14, GPIO_GP_1_15,
-	GPIO_GP_1_16, GPIO_GP_1_17, GPIO_GP_1_18, GPIO_GP_1_19,
-	GPIO_GP_1_20, GPIO_GP_1_21, GPIO_GP_1_22, GPIO_GP_1_23,
-	GPIO_GP_1_24, GPIO_GP_1_25, GPIO_GP_1_26, GPIO_GP_1_27,
-	GPIO_GP_1_28, GPIO_GP_1_29, GPIO_GP_1_30, GPIO_GP_1_31,
-
-	GPIO_GP_2_0, GPIO_GP_2_1, GPIO_GP_2_2, GPIO_GP_2_3,
-	GPIO_GP_2_4, GPIO_GP_2_5, GPIO_GP_2_6, GPIO_GP_2_7,
-	GPIO_GP_2_8, GPIO_GP_2_9, GPIO_GP_2_10, GPIO_GP_2_11,
-	GPIO_GP_2_12, GPIO_GP_2_13, GPIO_GP_2_14, GPIO_GP_2_15,
-	GPIO_GP_2_16, GPIO_GP_2_17, GPIO_GP_2_18, GPIO_GP_2_19,
-	GPIO_GP_2_20, GPIO_GP_2_21, GPIO_GP_2_22, GPIO_GP_2_23,
-	GPIO_GP_2_24, GPIO_GP_2_25, GPIO_GP_2_26, GPIO_GP_2_27,
-	GPIO_GP_2_28, GPIO_GP_2_29, GPIO_GP_2_30, GPIO_GP_2_31,
-
-	GPIO_GP_3_0, GPIO_GP_3_1, GPIO_GP_3_2, GPIO_GP_3_3,
-	GPIO_GP_3_4, GPIO_GP_3_5, GPIO_GP_3_6, GPIO_GP_3_7,
-	GPIO_GP_3_8, GPIO_GP_3_9, GPIO_GP_3_10, GPIO_GP_3_11,
-	GPIO_GP_3_12, GPIO_GP_3_13, GPIO_GP_3_14, GPIO_GP_3_15,
-	GPIO_GP_3_16, GPIO_GP_3_17, GPIO_GP_3_18, GPIO_GP_3_19,
-	GPIO_GP_3_20, GPIO_GP_3_21, GPIO_GP_3_22, GPIO_GP_3_23,
-	GPIO_GP_3_24, GPIO_GP_3_25, GPIO_GP_3_26, GPIO_GP_3_27,
-	GPIO_GP_3_28, GPIO_GP_3_29, GPIO_GP_3_30, GPIO_GP_3_31,
-
-	GPIO_GP_4_0, GPIO_GP_4_1, GPIO_GP_4_2, GPIO_GP_4_3,
-	GPIO_GP_4_4, GPIO_GP_4_5, GPIO_GP_4_6, GPIO_GP_4_7,
-	GPIO_GP_4_8, GPIO_GP_4_9, GPIO_GP_4_10, GPIO_GP_4_11,
-	GPIO_GP_4_12, GPIO_GP_4_13, GPIO_GP_4_14, GPIO_GP_4_15,
-	GPIO_GP_4_16, GPIO_GP_4_17, GPIO_GP_4_18, GPIO_GP_4_19,
-	GPIO_GP_4_20, GPIO_GP_4_21, GPIO_GP_4_22, GPIO_GP_4_23,
-	GPIO_GP_4_24, GPIO_GP_4_25, GPIO_GP_4_26, GPIO_GP_4_27,
-	GPIO_GP_4_28, GPIO_GP_4_29, GPIO_GP_4_30, GPIO_GP_4_31,
-
-	GPIO_GP_5_0, GPIO_GP_5_1, GPIO_GP_5_2, GPIO_GP_5_3,
-	GPIO_GP_5_4, GPIO_GP_5_5, GPIO_GP_5_6, GPIO_GP_5_7,
-	GPIO_GP_5_8, GPIO_GP_5_9, GPIO_GP_5_10, GPIO_GP_5_11,
-
-	GPIO_FN_CLKOUT, GPIO_FN_BS, GPIO_FN_CS0, GPIO_FN_EX_CS0, GPIO_FN_RD,
-		GPIO_FN_WE0, GPIO_FN_WE1,
-
-	GPIO_FN_SCL0, GPIO_FN_PENC0, GPIO_FN_USB_OVC0,
-
-	GPIO_FN_IRQ2_B, GPIO_FN_IRQ3_B,
-
-	/* IPSR0 */
-	GPIO_FN_A15, GPIO_FN_ST0_VCO_CLKIN, GPIO_FN_LCD_DATA15_A,
-		GPIO_FN_TIOC3D_C,
-	GPIO_FN_A14, GPIO_FN_LCD_DATA14_A, GPIO_FN_TIOC3C_C,
-	GPIO_FN_A13, GPIO_FN_LCD_DATA13_A, GPIO_FN_TIOC3B_C,
-	GPIO_FN_A12, GPIO_FN_LCD_DATA12_A, GPIO_FN_TIOC3A_C,
-	GPIO_FN_A11, GPIO_FN_ST0_D7, GPIO_FN_LCD_DATA11_A,
-		GPIO_FN_TIOC2B_C,
-	GPIO_FN_A10, GPIO_FN_ST0_D6, GPIO_FN_LCD_DATA10_A,
-		GPIO_FN_TIOC2A_C,
-	GPIO_FN_A9, GPIO_FN_ST0_D5, GPIO_FN_LCD_DATA9_A,
-		GPIO_FN_TIOC1B_C,
-	GPIO_FN_A8, GPIO_FN_ST0_D4, GPIO_FN_LCD_DATA8_A,
-		GPIO_FN_TIOC1A_C,
-	GPIO_FN_A7, GPIO_FN_ST0_D3, GPIO_FN_LCD_DATA7_A, GPIO_FN_TIOC0D_C,
-	GPIO_FN_A6, GPIO_FN_ST0_D2, GPIO_FN_LCD_DATA6_A, GPIO_FN_TIOC0C_C,
-	GPIO_FN_A5, GPIO_FN_ST0_D1, GPIO_FN_LCD_DATA5_A, GPIO_FN_TIOC0B_C,
-	GPIO_FN_A4, GPIO_FN_ST0_D0, GPIO_FN_LCD_DATA4_A, GPIO_FN_TIOC0A_C,
-	GPIO_FN_A3, GPIO_FN_ST0_VLD, GPIO_FN_LCD_DATA3_A, GPIO_FN_TCLKD_C,
-	GPIO_FN_A2, GPIO_FN_ST0_SYC, GPIO_FN_LCD_DATA2_A, GPIO_FN_TCLKC_C,
-	GPIO_FN_A1, GPIO_FN_ST0_REQ, GPIO_FN_LCD_DATA1_A, GPIO_FN_TCLKB_C,
-	GPIO_FN_A0, GPIO_FN_ST0_CLKIN, GPIO_FN_LCD_DATA0_A, GPIO_FN_TCLKA_C,
-
-	/* IPSR1 */
-	GPIO_FN_D3, GPIO_FN_SD0_DAT3_A, GPIO_FN_MMC_D3_A, GPIO_FN_ST1_D6,
-		GPIO_FN_FD3_A,
-	GPIO_FN_D2, GPIO_FN_SD0_DAT2_A, GPIO_FN_MMC_D2_A, GPIO_FN_ST1_D5,
-		GPIO_FN_FD2_A,
-	GPIO_FN_D1, GPIO_FN_SD0_DAT1_A, GPIO_FN_MMC_D1_A, GPIO_FN_ST1_D4,
-		GPIO_FN_FD1_A,
-	GPIO_FN_D0, GPIO_FN_SD0_DAT0_A, GPIO_FN_MMC_D0_A, GPIO_FN_ST1_D3,
-		GPIO_FN_FD0_A,
-	GPIO_FN_A25, GPIO_FN_TX2_D, GPIO_FN_ST1_D2,
-	GPIO_FN_A24, GPIO_FN_RX2_D, GPIO_FN_ST1_D1,
-	GPIO_FN_A23, GPIO_FN_ST1_D0, GPIO_FN_LCD_M_DISP_A,
-	GPIO_FN_A22, GPIO_FN_ST1_VLD, GPIO_FN_LCD_VEPWC_A,
-	GPIO_FN_A21, GPIO_FN_ST1_SYC, GPIO_FN_LCD_VCPWC_A,
-	GPIO_FN_A20, GPIO_FN_ST1_REQ, GPIO_FN_LCD_FLM_A,
-	GPIO_FN_A19, GPIO_FN_ST1_CLKIN, GPIO_FN_LCD_CLK_A, GPIO_FN_TIOC4D_C,
-	GPIO_FN_A18, GPIO_FN_ST1_PWM, GPIO_FN_LCD_CL2_A, GPIO_FN_TIOC4C_C,
-	GPIO_FN_A17, GPIO_FN_ST1_VCO_CLKIN, GPIO_FN_LCD_CL1_A, GPIO_FN_TIOC4B_C,
-	GPIO_FN_A16, GPIO_FN_ST0_PWM, GPIO_FN_LCD_DON_A, GPIO_FN_TIOC4A_C,
-
-	/* IPSR2 */
-	GPIO_FN_D14, GPIO_FN_TX2_B, GPIO_FN_FSE_A, GPIO_FN_ET0_TX_CLK_B,
-	GPIO_FN_D13, GPIO_FN_RX2_B, GPIO_FN_FRB_A,	GPIO_FN_ET0_ETXD6_B,
-	GPIO_FN_D12, GPIO_FN_FWE_A, GPIO_FN_ET0_ETXD5_B,
-	GPIO_FN_D11, GPIO_FN_RSPI_MISO_A, GPIO_FN_QMI_QIO1_A,
-		GPIO_FN_FRE_A, GPIO_FN_ET0_ETXD3_B,
-	GPIO_FN_D10, GPIO_FN_RSPI_MOSI_A, GPIO_FN_QMO_QIO0_A,
-		GPIO_FN_FALE_A, GPIO_FN_ET0_ETXD2_B,
-	GPIO_FN_D9, GPIO_FN_SD0_CMD_A, GPIO_FN_MMC_CMD_A, GPIO_FN_QIO3_A,
-		GPIO_FN_FCLE_A, GPIO_FN_ET0_ETXD1_B,
-	GPIO_FN_D8, GPIO_FN_SD0_CLK_A, GPIO_FN_MMC_CLK_A, GPIO_FN_QIO2_A,
-		GPIO_FN_FCE_A, GPIO_FN_ET0_GTX_CLK_B,
-	GPIO_FN_D7, GPIO_FN_RSPI_SSL_A, GPIO_FN_MMC_D7_A, GPIO_FN_QSSL_A,
-		GPIO_FN_FD7_A,
-	GPIO_FN_D6, GPIO_FN_RSPI_RSPCK_A, GPIO_FN_MMC_D6_A, GPIO_FN_QSPCLK_A,
-		GPIO_FN_FD6_A,
-	GPIO_FN_D5, GPIO_FN_SD0_WP_A, GPIO_FN_MMC_D5_A, GPIO_FN_FD5_A,
-	GPIO_FN_D4, GPIO_FN_SD0_CD_A, GPIO_FN_MMC_D4_A, GPIO_FN_ST1_D7,
-		GPIO_FN_FD4_A,
-
-	/* IPSR3 */
-	GPIO_FN_DRACK0, GPIO_FN_SD1_DAT2_A, GPIO_FN_ATAG, GPIO_FN_TCLK1_A,
-		GPIO_FN_ET0_ETXD7,
-	GPIO_FN_EX_WAIT2, GPIO_FN_SD1_DAT1_A, GPIO_FN_DACK2, GPIO_FN_CAN1_RX_C,
-		GPIO_FN_ET0_MAGIC_C, GPIO_FN_ET0_ETXD6_A,
-	GPIO_FN_EX_WAIT1, GPIO_FN_SD1_DAT0_A, GPIO_FN_DREQ2, GPIO_FN_CAN1_TX_C,
-		GPIO_FN_ET0_LINK_C, GPIO_FN_ET0_ETXD5_A,
-	GPIO_FN_EX_WAIT0, GPIO_FN_TCLK1_B,
-	GPIO_FN_RD_WR, GPIO_FN_TCLK0, GPIO_FN_CAN_CLK_B, GPIO_FN_ET0_ETXD4,
-	GPIO_FN_EX_CS5, GPIO_FN_SD1_CMD_A, GPIO_FN_ATADIR, GPIO_FN_QSSL_B,
-		GPIO_FN_ET0_ETXD3_A,
-	GPIO_FN_EX_CS4, GPIO_FN_SD1_WP_A, GPIO_FN_ATAWR, GPIO_FN_QMI_QIO1_B,
-		GPIO_FN_ET0_ETXD2_A,
-	GPIO_FN_EX_CS3, GPIO_FN_SD1_CD_A, GPIO_FN_ATARD, GPIO_FN_QMO_QIO0_B,
-		GPIO_FN_ET0_ETXD1_A,
-	GPIO_FN_EX_CS2, GPIO_FN_TX3_B, GPIO_FN_ATACS1, GPIO_FN_QSPCLK_B,
-		GPIO_FN_ET0_GTX_CLK_A,
-	GPIO_FN_EX_CS1, GPIO_FN_RX3_B, GPIO_FN_ATACS0, GPIO_FN_QIO2_B,
-		GPIO_FN_ET0_ETXD0,
-	GPIO_FN_CS1_A26, GPIO_FN_QIO3_B,
-	GPIO_FN_D15, GPIO_FN_SCK2_B,
-
-	/* IPSR4 */
-	GPIO_FN_SCK2_A, GPIO_FN_VI0_G3,
-	GPIO_FN_RTS1_B, GPIO_FN_VI0_G2,
-	GPIO_FN_CTS1_B, GPIO_FN_VI0_DATA7_VI0_G1,
-	GPIO_FN_TX1_B, GPIO_FN_VI0_DATA6_VI0_G0, GPIO_FN_ET0_PHY_INT_A,
-	GPIO_FN_RX1_B, GPIO_FN_VI0_DATA5_VI0_B5, GPIO_FN_ET0_MAGIC_A,
-	GPIO_FN_SCK1_B, GPIO_FN_VI0_DATA4_VI0_B4, GPIO_FN_ET0_LINK_A,
-	GPIO_FN_RTS0_B, GPIO_FN_VI0_DATA3_VI0_B3, GPIO_FN_ET0_MDIO_A,
-	GPIO_FN_CTS0_B, GPIO_FN_VI0_DATA2_VI0_B2, GPIO_FN_RMII0_MDIO_A,
-		GPIO_FN_ET0_MDC,
-	GPIO_FN_HTX0_A, GPIO_FN_TX1_A, GPIO_FN_VI0_DATA1_VI0_B1,
-		GPIO_FN_RMII0_MDC_A, GPIO_FN_ET0_COL,
-	GPIO_FN_HRX0_A, GPIO_FN_RX1_A, GPIO_FN_VI0_DATA0_VI0_B0,
-		GPIO_FN_RMII0_CRS_DV_A, GPIO_FN_ET0_CRS,
-	GPIO_FN_HSCK0_A, GPIO_FN_SCK1_A, GPIO_FN_VI0_VSYNC,
-		GPIO_FN_RMII0_RX_ER_A, GPIO_FN_ET0_RX_ER,
-	GPIO_FN_HRTS0_A, GPIO_FN_RTS1_A, GPIO_FN_VI0_HSYNC,
-		GPIO_FN_RMII0_TXD_EN_A, GPIO_FN_ET0_RX_DV,
-	GPIO_FN_HCTS0_A, GPIO_FN_CTS1_A, GPIO_FN_VI0_FIELD,
-		GPIO_FN_RMII0_RXD1_A, GPIO_FN_ET0_ERXD7,
-
-	/* IPSR5 */
-	GPIO_FN_SD2_CLK_A, GPIO_FN_RX2_A, GPIO_FN_VI0_G4, GPIO_FN_ET0_RX_CLK_B,
-	GPIO_FN_SD2_CMD_A, GPIO_FN_TX2_A, GPIO_FN_VI0_G5, GPIO_FN_ET0_ERXD2_B,
-	GPIO_FN_SD2_DAT0_A, GPIO_FN_RX3_A, GPIO_FN_VI0_R0, GPIO_FN_ET0_ERXD3_B,
-	GPIO_FN_SD2_DAT1_A, GPIO_FN_TX3_A, GPIO_FN_VI0_R1, GPIO_FN_ET0_MDIO_B,
-	GPIO_FN_SD2_DAT2_A, GPIO_FN_RX4_A, GPIO_FN_VI0_R2, GPIO_FN_ET0_LINK_B,
-	GPIO_FN_SD2_DAT3_A, GPIO_FN_TX4_A, GPIO_FN_VI0_R3, GPIO_FN_ET0_MAGIC_B,
-	GPIO_FN_SD2_CD_A, GPIO_FN_RX5_A, GPIO_FN_VI0_R4, GPIO_FN_ET0_PHY_INT_B,
-	GPIO_FN_SD2_WP_A, GPIO_FN_TX5_A, GPIO_FN_VI0_R5,
-	GPIO_FN_REF125CK, GPIO_FN_ADTRG, GPIO_FN_RX5_C,
-	GPIO_FN_REF50CK, GPIO_FN_CTS1_E, GPIO_FN_HCTS0_D,
-
-	/* IPSR6 */
-	GPIO_FN_DU0_DR0, GPIO_FN_SCIF_CLK_B, GPIO_FN_HRX0_D, GPIO_FN_IETX_A,
-		GPIO_FN_TCLKA_A, GPIO_FN_HIFD00,
-	GPIO_FN_DU0_DR1, GPIO_FN_SCK0_B, GPIO_FN_HTX0_D, GPIO_FN_IERX_A,
-		GPIO_FN_TCLKB_A, GPIO_FN_HIFD01,
-	GPIO_FN_DU0_DR2, GPIO_FN_RX0_B, GPIO_FN_TCLKC_A, GPIO_FN_HIFD02,
-	GPIO_FN_DU0_DR3, GPIO_FN_TX0_B, GPIO_FN_TCLKD_A, GPIO_FN_HIFD03,
-	GPIO_FN_DU0_DR4, GPIO_FN_CTS0_C, GPIO_FN_TIOC0A_A, GPIO_FN_HIFD04,
-	GPIO_FN_DU0_DR5, GPIO_FN_RTS0_C, GPIO_FN_TIOC0B_A, GPIO_FN_HIFD05,
-	GPIO_FN_DU0_DR6, GPIO_FN_SCK1_C, GPIO_FN_TIOC0C_A, GPIO_FN_HIFD06,
-	GPIO_FN_DU0_DR7, GPIO_FN_RX1_C, GPIO_FN_TIOC0D_A, GPIO_FN_HIFD07,
-	GPIO_FN_DU0_DG0, GPIO_FN_TX1_C, GPIO_FN_HSCK0_D, GPIO_FN_IECLK_A,
-		GPIO_FN_TIOC1A_A, GPIO_FN_HIFD08,
-	GPIO_FN_DU0_DG1, GPIO_FN_CTS1_C, GPIO_FN_HRTS0_D, GPIO_FN_TIOC1B_A,
-		GPIO_FN_HIFD09,
-
-	/* IPSR7 */
-	GPIO_FN_DU0_DG2, GPIO_FN_RTS1_C, GPIO_FN_RMII0_MDC_B, GPIO_FN_TIOC2A_A,
-		GPIO_FN_HIFD10,
-	GPIO_FN_DU0_DG3, GPIO_FN_SCK2_C, GPIO_FN_RMII0_MDIO_B, GPIO_FN_TIOC2B_A,
-		GPIO_FN_HIFD11,
-	GPIO_FN_DU0_DG4, GPIO_FN_RX2_C, GPIO_FN_RMII0_CRS_DV_B,
-		GPIO_FN_TIOC3A_A, GPIO_FN_HIFD12,
-	GPIO_FN_DU0_DG5, GPIO_FN_TX2_C, GPIO_FN_RMII0_RX_ER_B,
-		GPIO_FN_TIOC3B_A, GPIO_FN_HIFD13,
-	GPIO_FN_DU0_DG6, GPIO_FN_RX3_C, GPIO_FN_RMII0_RXD0_B,
-		GPIO_FN_TIOC3C_A, GPIO_FN_HIFD14,
-	GPIO_FN_DU0_DG7, GPIO_FN_TX3_C, GPIO_FN_RMII0_RXD1_B,
-		GPIO_FN_TIOC3D_A, GPIO_FN_HIFD15,
-	GPIO_FN_DU0_DB0, GPIO_FN_RX4_C, GPIO_FN_RMII0_TXD_EN_B,
-		GPIO_FN_TIOC4A_A, GPIO_FN_HIFCS,
-	GPIO_FN_DU0_DB1, GPIO_FN_TX4_C, GPIO_FN_RMII0_TXD0_B,
-		GPIO_FN_TIOC4B_A, GPIO_FN_HIFRS,
-	GPIO_FN_DU0_DB2, GPIO_FN_RX5_B, GPIO_FN_RMII0_TXD1_B,
-		GPIO_FN_TIOC4C_A, GPIO_FN_HIFWR,
-	GPIO_FN_DU0_DB3, GPIO_FN_TX5_B, GPIO_FN_TIOC4D_A, GPIO_FN_HIFRD,
-	GPIO_FN_DU0_DB4, GPIO_FN_HIFINT,
-
-	/* IPSR8 */
-	GPIO_FN_DU0_DB5, GPIO_FN_HIFDREQ,
-	GPIO_FN_DU0_DB6, GPIO_FN_HIFRDY,
-	GPIO_FN_DU0_DB7, GPIO_FN_SSI_SCK0_B, GPIO_FN_HIFEBL_B,
-	GPIO_FN_DU0_DOTCLKIN, GPIO_FN_HSPI_CS0_C, GPIO_FN_SSI_WS0_B,
-	GPIO_FN_DU0_DOTCLKOUT, GPIO_FN_HSPI_CLK0_C, GPIO_FN_SSI_SDATA0_B,
-	GPIO_FN_DU0_EXHSYNC_DU0_HSYNC, GPIO_FN_HSPI_TX0_C, GPIO_FN_SSI_SCK1_B,
-	GPIO_FN_DU0_EXVSYNC_DU0_VSYNC, GPIO_FN_HSPI_RX0_C, GPIO_FN_SSI_WS1_B,
-	GPIO_FN_DU0_EXODDF_DU0_ODDF, GPIO_FN_CAN0_RX_B, GPIO_FN_HSCK0_B,
-		GPIO_FN_SSI_SDATA1_B,
-	GPIO_FN_DU0_DISP, GPIO_FN_CAN0_TX_B, GPIO_FN_HRX0_B,
-		GPIO_FN_AUDIO_CLKA_B,
-	GPIO_FN_DU0_CDE, GPIO_FN_HTX0_B, GPIO_FN_AUDIO_CLKB_B,
-		GPIO_FN_LCD_VCPWC_B,
-	GPIO_FN_IRQ0_A, GPIO_FN_HSPI_TX_B, GPIO_FN_RX3_E, GPIO_FN_ET0_ERXD0,
-	GPIO_FN_IRQ1_A, GPIO_FN_HSPI_RX_B, GPIO_FN_TX3_E, GPIO_FN_ET0_ERXD1,
-	GPIO_FN_IRQ2_A, GPIO_FN_CTS0_A, GPIO_FN_HCTS0_B, GPIO_FN_ET0_ERXD2_A,
-	GPIO_FN_IRQ3_A, GPIO_FN_RTS0_A, GPIO_FN_HRTS0_B, GPIO_FN_ET0_ERXD3_A,
-
-	/* IPSR9 */
-	GPIO_FN_VI1_CLK_A, GPIO_FN_FD0_B, GPIO_FN_LCD_DATA0_B,
-	GPIO_FN_VI1_0_A, GPIO_FN_FD1_B, GPIO_FN_LCD_DATA1_B,
-	GPIO_FN_VI1_1_A, GPIO_FN_FD2_B, GPIO_FN_LCD_DATA2_B,
-	GPIO_FN_VI1_2_A, GPIO_FN_FD3_B, GPIO_FN_LCD_DATA3_B,
-	GPIO_FN_VI1_3_A, GPIO_FN_FD4_B, GPIO_FN_LCD_DATA4_B,
-	GPIO_FN_VI1_4_A, GPIO_FN_FD5_B, GPIO_FN_LCD_DATA5_B,
-	GPIO_FN_VI1_5_A, GPIO_FN_FD6_B, GPIO_FN_LCD_DATA6_B,
-	GPIO_FN_VI1_6_A, GPIO_FN_FD7_B, GPIO_FN_LCD_DATA7_B,
-	GPIO_FN_VI1_7_A, GPIO_FN_FCE_B, GPIO_FN_LCD_DATA8_B,
-	GPIO_FN_SSI_SCK0_A, GPIO_FN_TIOC1A_B, GPIO_FN_LCD_DATA9_B,
-	GPIO_FN_SSI_WS0_A, GPIO_FN_TIOC1B_B, GPIO_FN_LCD_DATA10_B,
-	GPIO_FN_SSI_SDATA0_A, GPIO_FN_VI1_0_B, GPIO_FN_TIOC2A_B,
-		GPIO_FN_LCD_DATA11_B,
-	GPIO_FN_SSI_SCK1_A, GPIO_FN_VI1_1_B, GPIO_FN_TIOC2B_B,
-		GPIO_FN_LCD_DATA12_B,
-	GPIO_FN_SSI_WS1_A, GPIO_FN_VI1_2_B, GPIO_FN_LCD_DATA13_B,
-	GPIO_FN_SSI_SDATA1_A, GPIO_FN_VI1_3_B, GPIO_FN_LCD_DATA14_B,
-
-	/* IPSR10 */
-	GPIO_FN_SSI_SCK23, GPIO_FN_VI1_4_B, GPIO_FN_RX1_D, GPIO_FN_FCLE_B,
-		GPIO_FN_LCD_DATA15_B,
-	GPIO_FN_SSI_WS23, GPIO_FN_VI1_5_B, GPIO_FN_TX1_D, GPIO_FN_HSCK0_C,
-		GPIO_FN_FALE_B, GPIO_FN_LCD_DON_B,
-	GPIO_FN_SSI_SDATA2, GPIO_FN_VI1_6_B, GPIO_FN_HRX0_C, GPIO_FN_FRE_B,
-		GPIO_FN_LCD_CL1_B,
-	GPIO_FN_SSI_SDATA3, GPIO_FN_VI1_7_B, GPIO_FN_HTX0_C, GPIO_FN_FWE_B,
-		GPIO_FN_LCD_CL2_B,
-	GPIO_FN_AUDIO_CLKA_A, GPIO_FN_VI1_CLK_B, GPIO_FN_SCK1_D,
-		GPIO_FN_IECLK_B, GPIO_FN_LCD_FLM_B,
-	GPIO_FN_AUDIO_CLKB_A, GPIO_FN_LCD_CLK_B,
-	GPIO_FN_AUDIO_CLKC, GPIO_FN_SCK1_E, GPIO_FN_HCTS0_C, GPIO_FN_FRB_B,
-		GPIO_FN_LCD_VEPWC_B,
-	GPIO_FN_AUDIO_CLKOUT, GPIO_FN_TX1_E, GPIO_FN_HRTS0_C, GPIO_FN_FSE_B,
-		GPIO_FN_LCD_M_DISP_B,
-	GPIO_FN_CAN_CLK_A, GPIO_FN_RX4_D,
-	GPIO_FN_CAN0_TX_A, GPIO_FN_TX4_D, GPIO_FN_MLB_CLK,
-	GPIO_FN_CAN1_RX_A, GPIO_FN_IRQ1_B,
-	GPIO_FN_CAN0_RX_A, GPIO_FN_IRQ0_B, GPIO_FN_MLB_SIG,
-	GPIO_FN_CAN1_TX_A, GPIO_FN_TX5_C, GPIO_FN_MLB_DAT,
-
-	/* IPSR11 */
-	GPIO_FN_SCL1, GPIO_FN_SCIF_CLK_C,
-	GPIO_FN_SDA1, GPIO_FN_RX1_E,
-	GPIO_FN_SDA0, GPIO_FN_HIFEBL_A,
-	GPIO_FN_SDSELF, GPIO_FN_RTS1_E,
-	GPIO_FN_SCIF_CLK_A, GPIO_FN_HSPI_CLK_A, GPIO_FN_VI0_CLK,
-		GPIO_FN_RMII0_TXD0_A, GPIO_FN_ET0_ERXD4,
-	GPIO_FN_SCK0_A, GPIO_FN_HSPI_CS_A, GPIO_FN_VI0_CLKENB,
-		GPIO_FN_RMII0_TXD1_A, GPIO_FN_ET0_ERXD5,
-	GPIO_FN_RX0_A, GPIO_FN_HSPI_RX_A, GPIO_FN_RMII0_RXD0_A,
-		GPIO_FN_ET0_ERXD6,
-	GPIO_FN_TX0_A, GPIO_FN_HSPI_TX_A,
-	GPIO_FN_PENC1, GPIO_FN_TX3_D, GPIO_FN_CAN1_TX_B, GPIO_FN_TX5_D,
-		GPIO_FN_IETX_B,
-	GPIO_FN_USB_OVC1, GPIO_FN_RX3_D, GPIO_FN_CAN1_RX_B, GPIO_FN_RX5_D,
-		GPIO_FN_IERX_B,
-	GPIO_FN_DREQ0, GPIO_FN_SD1_CLK_A, GPIO_FN_ET0_TX_EN,
-	GPIO_FN_DACK0, GPIO_FN_SD1_DAT3_A, GPIO_FN_ET0_TX_ER,
-	GPIO_FN_DREQ1, GPIO_FN_HSPI_CLK_B, GPIO_FN_RX4_B, GPIO_FN_ET0_PHY_INT_C,
-		GPIO_FN_ET0_TX_CLK_A,
-	GPIO_FN_DACK1, GPIO_FN_HSPI_CS_B, GPIO_FN_TX4_B, GPIO_FN_ET0_RX_CLK_A,
-	GPIO_FN_PRESETOUT, GPIO_FN_ST_CLKOUT,
-
-};
-
-#endif /* __ASM_SH7734_H__ */
diff --git a/arch/sh/include/cpu-sh4/cpu/sh7757.h b/arch/sh/include/cpu-sh4/cpu/sh7757.h
deleted file mode 100644
index 6781d41b7467d2..00000000000000
--- a/arch/sh/include/cpu-sh4/cpu/sh7757.h
+++ /dev/null
@@ -1,290 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH7757_H__
-#define __ASM_SH7757_H__
-
-enum {
-	/* PTA */
-	GPIO_PTA0, GPIO_PTA1, GPIO_PTA2, GPIO_PTA3,
-	GPIO_PTA4, GPIO_PTA5, GPIO_PTA6, GPIO_PTA7,
-
-	/* PTB */
-	GPIO_PTB0, GPIO_PTB1, GPIO_PTB2, GPIO_PTB3,
-	GPIO_PTB4, GPIO_PTB5, GPIO_PTB6, GPIO_PTB7,
-
-	/* PTC */
-	GPIO_PTC0, GPIO_PTC1, GPIO_PTC2, GPIO_PTC3,
-	GPIO_PTC4, GPIO_PTC5, GPIO_PTC6, GPIO_PTC7,
-
-	/* PTD */
-	GPIO_PTD0, GPIO_PTD1, GPIO_PTD2, GPIO_PTD3,
-	GPIO_PTD4, GPIO_PTD5, GPIO_PTD6, GPIO_PTD7,
-
-	/* PTE */
-	GPIO_PTE0, GPIO_PTE1, GPIO_PTE2, GPIO_PTE3,
-	GPIO_PTE4, GPIO_PTE5, GPIO_PTE6, GPIO_PTE7,
-
-	/* PTF */
-	GPIO_PTF0, GPIO_PTF1, GPIO_PTF2, GPIO_PTF3,
-	GPIO_PTF4, GPIO_PTF5, GPIO_PTF6, GPIO_PTF7,
-
-	/* PTG */
-	GPIO_PTG0, GPIO_PTG1, GPIO_PTG2, GPIO_PTG3,
-	GPIO_PTG4, GPIO_PTG5, GPIO_PTG6, GPIO_PTG7,
-
-	/* PTH */
-	GPIO_PTH0, GPIO_PTH1, GPIO_PTH2, GPIO_PTH3,
-	GPIO_PTH4, GPIO_PTH5, GPIO_PTH6, GPIO_PTH7,
-
-	/* PTI */
-	GPIO_PTI0, GPIO_PTI1, GPIO_PTI2, GPIO_PTI3,
-	GPIO_PTI4, GPIO_PTI5, GPIO_PTI6, GPIO_PTI7,
-
-	/* PTJ */
-	GPIO_PTJ0, GPIO_PTJ1, GPIO_PTJ2, GPIO_PTJ3,
-	GPIO_PTJ4, GPIO_PTJ5, GPIO_PTJ6,
-
-	/* PTK */
-	GPIO_PTK0, GPIO_PTK1, GPIO_PTK2, GPIO_PTK3,
-	GPIO_PTK4, GPIO_PTK5, GPIO_PTK6, GPIO_PTK7,
-
-	/* PTL */
-	GPIO_PTL0, GPIO_PTL1, GPIO_PTL2, GPIO_PTL3,
-	GPIO_PTL4, GPIO_PTL5, GPIO_PTL6,
-
-	/* PTM */
-	GPIO_PTM0, GPIO_PTM1, GPIO_PTM2, GPIO_PTM3,
-	GPIO_PTM4, GPIO_PTM5, GPIO_PTM6, GPIO_PTM7,
-
-	/* PTN */
-	GPIO_PTN0, GPIO_PTN1, GPIO_PTN2, GPIO_PTN3,
-	GPIO_PTN4, GPIO_PTN5, GPIO_PTN6,
-
-	/* PTO */
-	GPIO_PTO0, GPIO_PTO1, GPIO_PTO2, GPIO_PTO3,
-	GPIO_PTO4, GPIO_PTO5, GPIO_PTO6, GPIO_PTO7,
-
-	/* PTP */
-	GPIO_PTP0, GPIO_PTP1, GPIO_PTP2, GPIO_PTP3,
-	GPIO_PTP4, GPIO_PTP5, GPIO_PTP6, GPIO_PTP7,
-
-	/* PTQ */
-	GPIO_PTQ0, GPIO_PTQ1, GPIO_PTQ2, GPIO_PTQ3,
-	GPIO_PTQ4, GPIO_PTQ5, GPIO_PTQ6,
-
-	/* PTR */
-	GPIO_PTR0, GPIO_PTR1, GPIO_PTR2, GPIO_PTR3,
-	GPIO_PTR4, GPIO_PTR5, GPIO_PTR6, GPIO_PTR7,
-
-	/* PTS */
-	GPIO_PTS0, GPIO_PTS1, GPIO_PTS2, GPIO_PTS3,
-	GPIO_PTS4, GPIO_PTS5, GPIO_PTS6, GPIO_PTS7,
-
-	/* PTT */
-	GPIO_PTT0, GPIO_PTT1, GPIO_PTT2, GPIO_PTT3,
-	GPIO_PTT4, GPIO_PTT5, GPIO_PTT6, GPIO_PTT7,
-
-	/* PTU */
-	GPIO_PTU0, GPIO_PTU1, GPIO_PTU2, GPIO_PTU3,
-	GPIO_PTU4, GPIO_PTU5, GPIO_PTU6, GPIO_PTU7,
-
-	/* PTV */
-	GPIO_PTV0, GPIO_PTV1, GPIO_PTV2, GPIO_PTV3,
-	GPIO_PTV4, GPIO_PTV5, GPIO_PTV6, GPIO_PTV7,
-
-	/* PTW */
-	GPIO_PTW0, GPIO_PTW1, GPIO_PTW2, GPIO_PTW3,
-	GPIO_PTW4, GPIO_PTW5, GPIO_PTW6, GPIO_PTW7,
-
-	/* PTX */
-	GPIO_PTX0, GPIO_PTX1, GPIO_PTX2, GPIO_PTX3,
-	GPIO_PTX4, GPIO_PTX5, GPIO_PTX6, GPIO_PTX7,
-
-	/* PTY */
-	GPIO_PTY0, GPIO_PTY1, GPIO_PTY2, GPIO_PTY3,
-	GPIO_PTY4, GPIO_PTY5, GPIO_PTY6, GPIO_PTY7,
-
-	/* PTZ */
-	GPIO_PTZ0, GPIO_PTZ1, GPIO_PTZ2, GPIO_PTZ3,
-	GPIO_PTZ4, GPIO_PTZ5, GPIO_PTZ6, GPIO_PTZ7,
-
-
-	/* PTA (mobule: LBSC, RGMII) */
-	GPIO_FN_BS,	GPIO_FN_RDWR,	GPIO_FN_WE1,	GPIO_FN_RDY,
-	GPIO_FN_ET0_MDC,	GPIO_FN_ET0_MDIO,
-	GPIO_FN_ET1_MDC,	GPIO_FN_ET1_MDIO,
-
-	/* PTB (mobule: INTC, ONFI, TMU) */
-	GPIO_FN_IRQ15,	GPIO_FN_IRQ14,	GPIO_FN_IRQ13,	GPIO_FN_IRQ12,
-	GPIO_FN_IRQ11,	GPIO_FN_IRQ10,	GPIO_FN_IRQ9,	GPIO_FN_IRQ8,
-	GPIO_FN_ON_NRE,	GPIO_FN_ON_NWE,	GPIO_FN_ON_NWP,	GPIO_FN_ON_NCE0,
-	GPIO_FN_ON_R_B0,	GPIO_FN_ON_ALE,	GPIO_FN_ON_CLE,
-	GPIO_FN_TCLK,
-
-	/* PTC (mobule: IRQ, PWMU) */
-	GPIO_FN_IRQ7,	GPIO_FN_IRQ6,	GPIO_FN_IRQ5,	GPIO_FN_IRQ4,
-	GPIO_FN_IRQ3,	GPIO_FN_IRQ2,	GPIO_FN_IRQ1,	GPIO_FN_IRQ0,
-	GPIO_FN_PWMU0,	GPIO_FN_PWMU1,	GPIO_FN_PWMU2,	GPIO_FN_PWMU3,
-	GPIO_FN_PWMU4,	GPIO_FN_PWMU5,
-
-	/* PTD (mobule: SPI0, DMAC) */
-	GPIO_FN_SP0_MOSI,	GPIO_FN_SP0_MISO,	GPIO_FN_SP0_SCK,
-	GPIO_FN_SP0_SCK_FB,	GPIO_FN_SP0_SS0,	GPIO_FN_SP0_SS1,
-	GPIO_FN_SP0_SS2,	GPIO_FN_SP0_SS3,	GPIO_FN_DREQ0,
-	GPIO_FN_DACK0,		GPIO_FN_TEND0,
-
-	/* PTE (mobule: RMII) */
-	GPIO_FN_RMII0_CRS_DV,	GPIO_FN_RMII0_TXD1,	GPIO_FN_RMII0_TXD0,
-	GPIO_FN_RMII0_TXEN,	GPIO_FN_RMII0_REFCLK,	GPIO_FN_RMII0_RXD1,
-	GPIO_FN_RMII0_RXD0,	GPIO_FN_RMII0_RX_ER,
-
-	/* PTF (mobule: RMII, SerMux) */
-	GPIO_FN_RMII1_CRS_DV,	GPIO_FN_RMII1_TXD1,	GPIO_FN_RMII1_TXD0,
-	GPIO_FN_RMII1_TXEN,	GPIO_FN_RMII1_REFCLK,	GPIO_FN_RMII1_RXD1,
-	GPIO_FN_RMII1_RXD0,	GPIO_FN_RMII1_RX_ER,	GPIO_FN_RAC_RI,
-
-	/* PTG (mobule: system, LBSC, LPC, WDT, LPC, eMMC) */
-	GPIO_FN_BOOTFMS,		GPIO_FN_BOOTWP,
-	GPIO_FN_A25,	GPIO_FN_A24,	GPIO_FN_SERIRQ,	GPIO_FN_WDTOVF,
-	GPIO_FN_LPCPD,	GPIO_FN_LDRQ,	GPIO_FN_MMCCLK,	GPIO_FN_MMCCMD,
-
-	/* PTH (mobule: SPI1, LPC, DMAC, ADC) */
-	GPIO_FN_SP1_MOSI,		GPIO_FN_SP1_MISO,
-	GPIO_FN_SP1_SCK,		GPIO_FN_SP1_SCK_FB,
-	GPIO_FN_SP1_SS0,		GPIO_FN_SP1_SS1,
-	GPIO_FN_WP,	GPIO_FN_FMS0,	GPIO_FN_TEND1,	GPIO_FN_DREQ1,
-	GPIO_FN_DACK1,	GPIO_FN_ADTRG1,	GPIO_FN_ADTRG0,
-
-	/* PTI (mobule: LBSC, SDHI) */
-	GPIO_FN_D15,	GPIO_FN_D14,	GPIO_FN_D13,	GPIO_FN_D12,
-	GPIO_FN_D11,	GPIO_FN_D10,	GPIO_FN_D9,	GPIO_FN_D8,
-	GPIO_FN_SD_WP,	GPIO_FN_SD_CD,	GPIO_FN_SD_CLK,	GPIO_FN_SD_CMD,
-	GPIO_FN_SD_D3,	GPIO_FN_SD_D2,	GPIO_FN_SD_D1,	GPIO_FN_SD_D0,
-
-	/* PTJ (mobule: SCIF234) */
-	GPIO_FN_RTS3,	GPIO_FN_CTS3,	GPIO_FN_TXD3,	GPIO_FN_RXD3,
-	GPIO_FN_RTS4,	GPIO_FN_RXD4,	GPIO_FN_TXD4,
-
-	/* PTK (mobule: SERMUX, LBSC, SCIF) */
-	GPIO_FN_COM2_TXD,	GPIO_FN_COM2_RXD,	GPIO_FN_COM2_RTS,
-	GPIO_FN_COM2_CTS,	GPIO_FN_COM2_DTR,	GPIO_FN_COM2_DSR,
-	GPIO_FN_COM2_DCD,	GPIO_FN_CLKOUT,
-	GPIO_FN_SCK2,		GPIO_FN_SCK4,	GPIO_FN_SCK3,
-
-	/* PTL (mobule: SERMUX, SCIF, LBSC, AUD) */
-	GPIO_FN_RAC_RXD,	GPIO_FN_RAC_RTS,	GPIO_FN_RAC_CTS,
-	GPIO_FN_RAC_DTR,	GPIO_FN_RAC_DSR,	GPIO_FN_RAC_DCD,
-	GPIO_FN_RAC_TXD,	GPIO_FN_RXD2,		GPIO_FN_CS5,
-	GPIO_FN_CS6,		GPIO_FN_AUDSYNC,	GPIO_FN_AUDCK,
-	GPIO_FN_TXD2,
-
-	/* PTM (mobule: LBSC, IIC) */
-	GPIO_FN_CS4,	GPIO_FN_RD,	GPIO_FN_WE0,	GPIO_FN_CS0,
-	GPIO_FN_SDA6,	GPIO_FN_SCL6,	GPIO_FN_SDA7,	GPIO_FN_SCL7,
-
-	/* PTN (mobule: USB, JMC, SGPIO, WDT) */
-	GPIO_FN_VBUS_EN,	GPIO_FN_VBUS_OC,	GPIO_FN_JMCTCK,
-	GPIO_FN_JMCTMS,		GPIO_FN_JMCTDO,		GPIO_FN_JMCTDI,
-	GPIO_FN_JMCTRST,
-	GPIO_FN_SGPIO1_CLK,	GPIO_FN_SGPIO1_LOAD,	GPIO_FN_SGPIO1_DI,
-	GPIO_FN_SGPIO1_DO,	GPIO_FN_SUB_CLKIN,
-
-	/* PTO (mobule: SGPIO, SerMux) */
-	GPIO_FN_SGPIO0_CLK,	GPIO_FN_SGPIO0_LOAD,	GPIO_FN_SGPIO0_DI,
-	GPIO_FN_SGPIO0_DO,	GPIO_FN_SGPIO2_CLK,	GPIO_FN_SGPIO2_LOAD,
-	GPIO_FN_SGPIO2_DI,	GPIO_FN_SGPIO2_DO,	GPIO_FN_COM1_TXD,
-	GPIO_FN_COM1_RXD,	GPIO_FN_COM1_RTS,	GPIO_FN_COM1_CTS,
-
-	/* PTQ (mobule: LPC) */
-	GPIO_FN_LAD3,	GPIO_FN_LAD2,	GPIO_FN_LAD1,	GPIO_FN_LAD0,
-	GPIO_FN_LFRAME,	GPIO_FN_LRESET,	GPIO_FN_LCLK,
-
-	/* PTR (mobule: GRA, IIC) */
-	GPIO_FN_DDC3,	GPIO_FN_DDC2,	GPIO_FN_SDA2,	GPIO_FN_SCL2,
-	GPIO_FN_SDA1,	GPIO_FN_SCL1,	GPIO_FN_SDA0,	GPIO_FN_SCL0,
-	GPIO_FN_SDA8,	GPIO_FN_SCL8,
-
-	/* PTS (mobule: GRA, IIC) */
-	GPIO_FN_DDC1,	GPIO_FN_DDC0,	GPIO_FN_SDA5,	GPIO_FN_SCL5,
-	GPIO_FN_SDA4,	GPIO_FN_SCL4,	GPIO_FN_SDA3,	GPIO_FN_SCL3,
-	GPIO_FN_SDA9,	GPIO_FN_SCL9,
-
-	/* PTT (mobule: PWMX, AUD) */
-	GPIO_FN_PWMX7,	GPIO_FN_PWMX6,	GPIO_FN_PWMX5,	GPIO_FN_PWMX4,
-	GPIO_FN_PWMX3,	GPIO_FN_PWMX2,	GPIO_FN_PWMX1,	GPIO_FN_PWMX0,
-	GPIO_FN_AUDATA3,	GPIO_FN_AUDATA2,	GPIO_FN_AUDATA1,
-	GPIO_FN_AUDATA0,	GPIO_FN_STATUS1,	GPIO_FN_STATUS0,
-
-	/* PTU (mobule: LPC, APM) */
-	GPIO_FN_LGPIO7,	GPIO_FN_LGPIO6,	GPIO_FN_LGPIO5,	GPIO_FN_LGPIO4,
-	GPIO_FN_LGPIO3,	GPIO_FN_LGPIO2,	GPIO_FN_LGPIO1,	GPIO_FN_LGPIO0,
-	GPIO_FN_APMONCTL_O,	GPIO_FN_APMPWBTOUT_O,	GPIO_FN_APMSCI_O,
-	GPIO_FN_APMVDDON,	GPIO_FN_APMSLPBTN,	GPIO_FN_APMPWRBTN,
-	GPIO_FN_APMS5N,		GPIO_FN_APMS3N,
-
-	/* PTV (mobule: LBSC, SerMux, R-SPI, EVC, GRA) */
-	GPIO_FN_A23,	GPIO_FN_A22,	GPIO_FN_A21,	GPIO_FN_A20,
-	GPIO_FN_A19,	GPIO_FN_A18,	GPIO_FN_A17,	GPIO_FN_A16,
-	GPIO_FN_COM2_RI,	GPIO_FN_R_SPI_MOSI,	GPIO_FN_R_SPI_MISO,
-	GPIO_FN_R_SPI_RSPCK,	GPIO_FN_R_SPI_SSL0,	GPIO_FN_R_SPI_SSL1,
-	GPIO_FN_EVENT7,		GPIO_FN_EVENT6,		GPIO_FN_VBIOS_DI,
-	GPIO_FN_VBIOS_DO,	GPIO_FN_VBIOS_CLK,	GPIO_FN_VBIOS_CS,
-
-	/* PTW (mobule: LBSC, EVC, SCIF) */
-	GPIO_FN_A15,	GPIO_FN_A14,	GPIO_FN_A13,	GPIO_FN_A12,
-	GPIO_FN_A11,	GPIO_FN_A10,	GPIO_FN_A9,	GPIO_FN_A8,
-	GPIO_FN_EVENT5,	GPIO_FN_EVENT4,	GPIO_FN_EVENT3,	GPIO_FN_EVENT2,
-	GPIO_FN_EVENT1,	GPIO_FN_EVENT0,	GPIO_FN_CTS4,	GPIO_FN_CTS2,
-
-	/* PTX (mobule: LBSC, SCIF, SIM) */
-	GPIO_FN_A7,	GPIO_FN_A6,	GPIO_FN_A5,	GPIO_FN_A4,
-	GPIO_FN_A3,	GPIO_FN_A2,	GPIO_FN_A1,	GPIO_FN_A0,
-	GPIO_FN_RTS2,	GPIO_FN_SIM_D,	GPIO_FN_SIM_CLK, GPIO_FN_SIM_RST,
-
-	/* PTY (mobule: LBSC) */
-	GPIO_FN_D7,	GPIO_FN_D6,	GPIO_FN_D5,	GPIO_FN_D4,
-	GPIO_FN_D3,	GPIO_FN_D2,	GPIO_FN_D1,	GPIO_FN_D0,
-
-	/* PTZ (mobule: eMMC, ONFI) */
-	GPIO_FN_MMCDAT7,	GPIO_FN_MMCDAT6,	GPIO_FN_MMCDAT5,
-	GPIO_FN_MMCDAT4,	GPIO_FN_MMCDAT3,	GPIO_FN_MMCDAT2,
-	GPIO_FN_MMCDAT1,	GPIO_FN_MMCDAT0,
-	GPIO_FN_ON_DQ7,	GPIO_FN_ON_DQ6,	GPIO_FN_ON_DQ5,	GPIO_FN_ON_DQ4,
-	GPIO_FN_ON_DQ3,	GPIO_FN_ON_DQ2,	GPIO_FN_ON_DQ1,	GPIO_FN_ON_DQ0,
-};
-
-enum {
-	SHDMA_SLAVE_INVALID,
-	SHDMA_SLAVE_SDHI_TX,
-	SHDMA_SLAVE_SDHI_RX,
-	SHDMA_SLAVE_MMCIF_TX,
-	SHDMA_SLAVE_MMCIF_RX,
-	SHDMA_SLAVE_SCIF2_TX,
-	SHDMA_SLAVE_SCIF2_RX,
-	SHDMA_SLAVE_SCIF3_TX,
-	SHDMA_SLAVE_SCIF3_RX,
-	SHDMA_SLAVE_SCIF4_TX,
-	SHDMA_SLAVE_SCIF4_RX,
-	SHDMA_SLAVE_RIIC0_TX,
-	SHDMA_SLAVE_RIIC0_RX,
-	SHDMA_SLAVE_RIIC1_TX,
-	SHDMA_SLAVE_RIIC1_RX,
-	SHDMA_SLAVE_RIIC2_TX,
-	SHDMA_SLAVE_RIIC2_RX,
-	SHDMA_SLAVE_RIIC3_TX,
-	SHDMA_SLAVE_RIIC3_RX,
-	SHDMA_SLAVE_RIIC4_TX,
-	SHDMA_SLAVE_RIIC4_RX,
-	SHDMA_SLAVE_RIIC5_TX,
-	SHDMA_SLAVE_RIIC5_RX,
-	SHDMA_SLAVE_RIIC6_TX,
-	SHDMA_SLAVE_RIIC6_RX,
-	SHDMA_SLAVE_RIIC7_TX,
-	SHDMA_SLAVE_RIIC7_RX,
-	SHDMA_SLAVE_RIIC8_TX,
-	SHDMA_SLAVE_RIIC8_RX,
-	SHDMA_SLAVE_RIIC9_TX,
-	SHDMA_SLAVE_RIIC9_RX,
-	SHDMA_SLAVE_RSPI_TX,
-	SHDMA_SLAVE_RSPI_RX,
-};
-#endif /* __ASM_SH7757_H__ */
diff --git a/arch/sh/include/cpu-sh4/cpu/sh7785.h b/arch/sh/include/cpu-sh4/cpu/sh7785.h
deleted file mode 100644
index 37f42071e7d3b7..00000000000000
--- a/arch/sh/include/cpu-sh4/cpu/sh7785.h
+++ /dev/null
@@ -1,260 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH7785_H__
-#define __ASM_SH7785_H__
-
-/* Boot Mode Pins:
- *
- * MODE0: CPG - Initial Pck/Bck Frequency [FRQMR1]
- * MODE1: CPG - Initial Uck/SHck/DDRck Frequency [FRQMR1]
- * MODE2: CPG - Reserved (L: Normal operation)
- * MODE3: CPG - Reserved (L: Normal operation)
- * MODE4: CPG - Initial PLL setting (72x/36x)
- * MODE5: LBSC - Area0 Memory Type / Bus Width [CS0BCR.8]
- * MODE6: LBSC - Area0 Memory Type / Bus Width [CS0BCR.9]
- * MODE7: LBSC - Area0 Memory Type / Bus Width [CS0BCR.3]
- * MODE8: LBSC - Endian Mode (L: Big, H: Little) [BCR.31]
- * MODE9: LBSC - Master/Slave Mode (L: Slave) [BCR.30]
- * MODE10: CPG - Clock Input (L: Ext Clk, H: Crystal)
- * MODE11: PCI - Pin Mode (LL: PCI host, LH: PCI slave)
- * MODE12: PCI - Pin Mode (HL: Local bus, HH: DU)
- * MODE13: Boot Address Mode (L: 29-bit, H: 32-bit)
- * MODE14: Reserved (H: Normal operation)
- *
- * More information in sh7785 manual Rev.1.00, page 1628.
- */
-
-/* Pin Function Controller:
- * GPIO_FN_xx - GPIO used to select pin function
- * GPIO_Pxx - GPIO mapped to real I/O pin on CPU
- */
-enum {
-	/* PA */
-	GPIO_PA7, GPIO_PA6, GPIO_PA5, GPIO_PA4,
-	GPIO_PA3, GPIO_PA2, GPIO_PA1, GPIO_PA0,
-
-	/* PB */
-	GPIO_PB7, GPIO_PB6, GPIO_PB5, GPIO_PB4,
-	GPIO_PB3, GPIO_PB2, GPIO_PB1, GPIO_PB0,
-
-	/* PC */
-	GPIO_PC7, GPIO_PC6, GPIO_PC5, GPIO_PC4,
-	GPIO_PC3, GPIO_PC2, GPIO_PC1, GPIO_PC0,
-
-	/* PD */
-	GPIO_PD7, GPIO_PD6, GPIO_PD5, GPIO_PD4,
-	GPIO_PD3, GPIO_PD2, GPIO_PD1, GPIO_PD0,
-
-	/* PE */
-	GPIO_PE5, GPIO_PE4, GPIO_PE3, GPIO_PE2,
-	GPIO_PE1, GPIO_PE0,
-
-	/* PF */
-	GPIO_PF7, GPIO_PF6, GPIO_PF5, GPIO_PF4,
-	GPIO_PF3, GPIO_PF2, GPIO_PF1, GPIO_PF0,
-
-	/* PG */
-	GPIO_PG7, GPIO_PG6, GPIO_PG5, GPIO_PG4,
-	GPIO_PG3, GPIO_PG2, GPIO_PG1, GPIO_PG0,
-
-	/* PH */
-	GPIO_PH7, GPIO_PH6, GPIO_PH5, GPIO_PH4,
-	GPIO_PH3, GPIO_PH2, GPIO_PH1, GPIO_PH0,
-
-	/* PJ */
-	GPIO_PJ7, GPIO_PJ6, GPIO_PJ5, GPIO_PJ4,
-	GPIO_PJ3, GPIO_PJ2, GPIO_PJ1, GPIO_PJ0,
-
-	/* PK */
-	GPIO_PK7, GPIO_PK6, GPIO_PK5, GPIO_PK4,
-	GPIO_PK3, GPIO_PK2, GPIO_PK1, GPIO_PK0,
-
-	/* PL */
-	GPIO_PL7, GPIO_PL6, GPIO_PL5, GPIO_PL4,
-	GPIO_PL3, GPIO_PL2, GPIO_PL1, GPIO_PL0,
-
-	/* PM */
-	GPIO_PM1, GPIO_PM0,
-
-	/* PN */
-	GPIO_PN7, GPIO_PN6, GPIO_PN5, GPIO_PN4,
-	GPIO_PN3, GPIO_PN2, GPIO_PN1, GPIO_PN0,
-
-	/* PP */
-	GPIO_PP5, GPIO_PP4,
-	GPIO_PP3, GPIO_PP2, GPIO_PP1, GPIO_PP0,
-
-	/* PQ */
-	GPIO_PQ4,
-	GPIO_PQ3, GPIO_PQ2, GPIO_PQ1, GPIO_PQ0,
-
-	/* PR */
-	GPIO_PR3, GPIO_PR2, GPIO_PR1, GPIO_PR0,
-
-	GPIO_FN_D63_AD31,
-	GPIO_FN_D62_AD30,
-	GPIO_FN_D61_AD29,
-	GPIO_FN_D60_AD28,
-	GPIO_FN_D59_AD27,
-	GPIO_FN_D58_AD26,
-	GPIO_FN_D57_AD25,
-	GPIO_FN_D56_AD24,
-	GPIO_FN_D55_AD23,
-	GPIO_FN_D54_AD22,
-	GPIO_FN_D53_AD21,
-	GPIO_FN_D52_AD20,
-	GPIO_FN_D51_AD19,
-	GPIO_FN_D50_AD18,
-	GPIO_FN_D49_AD17_DB5,
-	GPIO_FN_D48_AD16_DB4,
-	GPIO_FN_D47_AD15_DB3,
-	GPIO_FN_D46_AD14_DB2,
-	GPIO_FN_D45_AD13_DB1,
-	GPIO_FN_D44_AD12_DB0,
-	GPIO_FN_D43_AD11_DG5,
-	GPIO_FN_D42_AD10_DG4,
-	GPIO_FN_D41_AD9_DG3,
-	GPIO_FN_D40_AD8_DG2,
-	GPIO_FN_D39_AD7_DG1,
-	GPIO_FN_D38_AD6_DG0,
-	GPIO_FN_D37_AD5_DR5,
-	GPIO_FN_D36_AD4_DR4,
-	GPIO_FN_D35_AD3_DR3,
-	GPIO_FN_D34_AD2_DR2,
-	GPIO_FN_D33_AD1_DR1,
-	GPIO_FN_D32_AD0_DR0,
-	GPIO_FN_REQ1,
-	GPIO_FN_REQ2,
-	GPIO_FN_REQ3,
-	GPIO_FN_GNT1,
-	GPIO_FN_GNT2,
-	GPIO_FN_GNT3,
-	GPIO_FN_MMCCLK,
-	GPIO_FN_D31,
-	GPIO_FN_D30,
-	GPIO_FN_D29,
-	GPIO_FN_D28,
-	GPIO_FN_D27,
-	GPIO_FN_D26,
-	GPIO_FN_D25,
-	GPIO_FN_D24,
-	GPIO_FN_D23,
-	GPIO_FN_D22,
-	GPIO_FN_D21,
-	GPIO_FN_D20,
-	GPIO_FN_D19,
-	GPIO_FN_D18,
-	GPIO_FN_D17,
-	GPIO_FN_D16,
-	GPIO_FN_SCIF1_SCK,
-	GPIO_FN_SCIF1_RXD,
-	GPIO_FN_SCIF1_TXD,
-	GPIO_FN_SCIF0_CTS,
-	GPIO_FN_INTD,
-	GPIO_FN_FCE,
-	GPIO_FN_SCIF0_RTS,
-	GPIO_FN_HSPI_CS,
-	GPIO_FN_FSE,
-	GPIO_FN_SCIF0_SCK,
-	GPIO_FN_HSPI_CLK,
-	GPIO_FN_FRE,
-	GPIO_FN_SCIF0_RXD,
-	GPIO_FN_HSPI_RX,
-	GPIO_FN_FRB,
-	GPIO_FN_SCIF0_TXD,
-	GPIO_FN_HSPI_TX,
-	GPIO_FN_FWE,
-	GPIO_FN_SCIF5_TXD,
-	GPIO_FN_HAC1_SYNC,
-	GPIO_FN_SSI1_WS,
-	GPIO_FN_SIOF_TXD_PJ,
-	GPIO_FN_HAC0_SDOUT,
-	GPIO_FN_SSI0_SDATA,
-	GPIO_FN_SIOF_RXD_PJ,
-	GPIO_FN_HAC0_SDIN,
-	GPIO_FN_SSI0_SCK,
-	GPIO_FN_SIOF_SYNC_PJ,
-	GPIO_FN_HAC0_SYNC,
-	GPIO_FN_SSI0_WS,
-	GPIO_FN_SIOF_MCLK_PJ,
-	GPIO_FN_HAC_RES,
-	GPIO_FN_SIOF_SCK_PJ,
-	GPIO_FN_HAC0_BITCLK,
-	GPIO_FN_SSI0_CLK,
-	GPIO_FN_HAC1_BITCLK,
-	GPIO_FN_SSI1_CLK,
-	GPIO_FN_TCLK,
-	GPIO_FN_IOIS16,
-	GPIO_FN_STATUS0,
-	GPIO_FN_DRAK0_PK3,
-	GPIO_FN_STATUS1,
-	GPIO_FN_DRAK1_PK2,
-	GPIO_FN_DACK2,
-	GPIO_FN_SCIF2_TXD,
-	GPIO_FN_MMCCMD,
-	GPIO_FN_SIOF_TXD_PK,
-	GPIO_FN_DACK3,
-	GPIO_FN_SCIF2_SCK,
-	GPIO_FN_MMCDAT,
-	GPIO_FN_SIOF_SCK_PK,
-	GPIO_FN_DREQ0,
-	GPIO_FN_DREQ1,
-	GPIO_FN_DRAK0_PK1,
-	GPIO_FN_DRAK1_PK0,
-	GPIO_FN_DREQ2,
-	GPIO_FN_INTB,
-	GPIO_FN_DREQ3,
-	GPIO_FN_INTC,
-	GPIO_FN_DRAK2,
-	GPIO_FN_CE2A,
-	GPIO_FN_IRL4,
-	GPIO_FN_FD4,
-	GPIO_FN_IRL5,
-	GPIO_FN_FD5,
-	GPIO_FN_IRL6,
-	GPIO_FN_FD6,
-	GPIO_FN_IRL7,
-	GPIO_FN_FD7,
-	GPIO_FN_DRAK3,
-	GPIO_FN_CE2B,
-	GPIO_FN_BREQ_BSACK,
-	GPIO_FN_BACK_BSREQ,
-	GPIO_FN_SCIF5_RXD,
-	GPIO_FN_HAC1_SDIN,
-	GPIO_FN_SSI1_SCK,
-	GPIO_FN_SCIF5_SCK,
-	GPIO_FN_HAC1_SDOUT,
-	GPIO_FN_SSI1_SDATA,
-	GPIO_FN_SCIF3_TXD,
-	GPIO_FN_FCLE,
-	GPIO_FN_SCIF3_RXD,
-	GPIO_FN_FALE,
-	GPIO_FN_SCIF3_SCK,
-	GPIO_FN_FD0,
-	GPIO_FN_SCIF4_TXD,
-	GPIO_FN_FD1,
-	GPIO_FN_SCIF4_RXD,
-	GPIO_FN_FD2,
-	GPIO_FN_SCIF4_SCK,
-	GPIO_FN_FD3,
-	GPIO_FN_DEVSEL_DCLKOUT,
-	GPIO_FN_STOP_CDE,
-	GPIO_FN_LOCK_ODDF,
-	GPIO_FN_TRDY_DISPL,
-	GPIO_FN_IRDY_HSYNC,
-	GPIO_FN_PCIFRAME_VSYNC,
-	GPIO_FN_INTA,
-	GPIO_FN_GNT0_GNTIN,
-	GPIO_FN_REQ0_REQOUT,
-	GPIO_FN_PERR,
-	GPIO_FN_SERR,
-	GPIO_FN_WE7_CBE3,
-	GPIO_FN_WE6_CBE2,
-	GPIO_FN_WE5_CBE1,
-	GPIO_FN_WE4_CBE0,
-	GPIO_FN_SCIF2_RXD,
-	GPIO_FN_SIOF_RXD,
-	GPIO_FN_MRESETOUT,
-	GPIO_FN_IRQOUT,
-};
-
-#endif /* __ASM_SH7785_H__ */
diff --git a/arch/sh/include/cpu-sh4/cpu/sh7786.h b/arch/sh/include/cpu-sh4/cpu/sh7786.h
deleted file mode 100644
index d6cce65b48713f..00000000000000
--- a/arch/sh/include/cpu-sh4/cpu/sh7786.h
+++ /dev/null
@@ -1,138 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * SH7786 Pinmux
- *
- * Copyright (C) 2008, 2009  Renesas Solutions Corp.
- * Kuninori Morimoto <morimoto.kuninori@renesas.com>
- *
- *  Based on sh7785.h
- */
-
-#ifndef __CPU_SH7786_H__
-#define __CPU_SH7786_H__
-
-#include <linux/io.h>
-
-enum {
-	/* PA */
-	GPIO_PA7, GPIO_PA6, GPIO_PA5, GPIO_PA4,
-	GPIO_PA3, GPIO_PA2, GPIO_PA1, GPIO_PA0,
-
-	/* PB */
-	GPIO_PB7, GPIO_PB6, GPIO_PB5, GPIO_PB4,
-	GPIO_PB3, GPIO_PB2, GPIO_PB1, GPIO_PB0,
-
-	/* PC */
-	GPIO_PC7, GPIO_PC6, GPIO_PC5, GPIO_PC4,
-	GPIO_PC3, GPIO_PC2, GPIO_PC1, GPIO_PC0,
-
-	/* PD */
-	GPIO_PD7, GPIO_PD6, GPIO_PD5, GPIO_PD4,
-	GPIO_PD3, GPIO_PD2, GPIO_PD1, GPIO_PD0,
-
-	/* PE */
-	GPIO_PE7, GPIO_PE6,
-
-	/* PF */
-	GPIO_PF7, GPIO_PF6, GPIO_PF5, GPIO_PF4,
-	GPIO_PF3, GPIO_PF2, GPIO_PF1, GPIO_PF0,
-
-	/* PG */
-	GPIO_PG7, GPIO_PG6, GPIO_PG5,
-
-	/* PH */
-	GPIO_PH7, GPIO_PH6, GPIO_PH5, GPIO_PH4,
-	GPIO_PH3, GPIO_PH2, GPIO_PH1, GPIO_PH0,
-
-	/* PJ */
-	GPIO_PJ7, GPIO_PJ6, GPIO_PJ5, GPIO_PJ4,
-	GPIO_PJ3, GPIO_PJ2, GPIO_PJ1,
-
-	/* DU */
-	GPIO_FN_DCLKIN, GPIO_FN_DCLKOUT, GPIO_FN_ODDF,
-	GPIO_FN_VSYNC, GPIO_FN_HSYNC, GPIO_FN_CDE, GPIO_FN_DISP,
-	GPIO_FN_DR0, GPIO_FN_DG0, GPIO_FN_DB0,
-	GPIO_FN_DR1, GPIO_FN_DG1, GPIO_FN_DB1,
-	GPIO_FN_DR2, GPIO_FN_DG2, GPIO_FN_DB2,
-	GPIO_FN_DR3, GPIO_FN_DG3, GPIO_FN_DB3,
-	GPIO_FN_DR4, GPIO_FN_DG4, GPIO_FN_DB4,
-	GPIO_FN_DR5, GPIO_FN_DG5, GPIO_FN_DB5,
-
-	/* Eth */
-	GPIO_FN_ETH_MAGIC, GPIO_FN_ETH_LINK, GPIO_FN_ETH_TX_ER,
-	GPIO_FN_ETH_TX_EN, GPIO_FN_ETH_MDIO, GPIO_FN_ETH_RX_CLK,
-	GPIO_FN_ETH_MDC, GPIO_FN_ETH_COL, GPIO_FN_ETH_TX_CLK,
-	GPIO_FN_ETH_CRS, GPIO_FN_ETH_RX_DV, GPIO_FN_ETH_RX_ER,
-	GPIO_FN_ETH_TXD3, GPIO_FN_ETH_TXD2, GPIO_FN_ETH_TXD1, GPIO_FN_ETH_TXD0,
-	GPIO_FN_ETH_RXD3, GPIO_FN_ETH_RXD2, GPIO_FN_ETH_RXD1, GPIO_FN_ETH_RXD0,
-
-	/* HSPI */
-	GPIO_FN_HSPI_CLK, GPIO_FN_HSPI_CS, GPIO_FN_HSPI_RX, GPIO_FN_HSPI_TX,
-
-	/* SCIF0 */
-	GPIO_FN_SCIF0_CTS, GPIO_FN_SCIF0_RTS, GPIO_FN_SCIF0_SCK,
-	GPIO_FN_SCIF0_RXD, GPIO_FN_SCIF0_TXD,
-
-	/* SCIF1 */
-	GPIO_FN_SCIF1_SCK, GPIO_FN_SCIF1_RXD, GPIO_FN_SCIF1_TXD,
-
-	/* SCIF3 */
-	GPIO_FN_SCIF3_SCK, GPIO_FN_SCIF3_RXD, GPIO_FN_SCIF3_TXD,
-
-	/* SCIF4 */
-	GPIO_FN_SCIF4_SCK, GPIO_FN_SCIF4_RXD, GPIO_FN_SCIF4_TXD,
-
-	/* SCIF5 */
-	GPIO_FN_SCIF5_SCK, GPIO_FN_SCIF5_RXD, GPIO_FN_SCIF5_TXD,
-
-	/* LBSC */
-	GPIO_FN_BREQ, GPIO_FN_IOIS16, GPIO_FN_CE2B, GPIO_FN_CE2A, GPIO_FN_BACK,
-
-	/* FLCTL */
-	GPIO_FN_FALE, GPIO_FN_FRB, GPIO_FN_FSTATUS,
-	GPIO_FN_FSE, GPIO_FN_FCLE,
-
-	/* DMAC */
-	GPIO_FN_DACK0, GPIO_FN_DREQ0, GPIO_FN_DRAK0,
-	GPIO_FN_DACK1, GPIO_FN_DREQ1, GPIO_FN_DRAK1,
-	GPIO_FN_DACK2, GPIO_FN_DREQ2, GPIO_FN_DRAK2,
-	GPIO_FN_DACK3, GPIO_FN_DREQ3, GPIO_FN_DRAK3,
-
-	/* USB */
-	GPIO_FN_USB_OVC0, GPIO_FN_USB_PENC0,
-	GPIO_FN_USB_OVC1, GPIO_FN_USB_PENC1,
-
-	/* HAC */
-	GPIO_FN_HAC_RES,
-	GPIO_FN_HAC0_SDOUT, GPIO_FN_HAC0_SDIN,
-	GPIO_FN_HAC0_SYNC, GPIO_FN_HAC0_BITCLK,
-	GPIO_FN_HAC1_SDOUT, GPIO_FN_HAC1_SDIN,
-	GPIO_FN_HAC1_SYNC, GPIO_FN_HAC1_BITCLK,
-
-	/* SSI */
-	GPIO_FN_SSI0_SDATA, GPIO_FN_SSI0_SCK, GPIO_FN_SSI0_WS, GPIO_FN_SSI0_CLK,
-	GPIO_FN_SSI1_SDATA, GPIO_FN_SSI1_SCK, GPIO_FN_SSI1_WS, GPIO_FN_SSI1_CLK,
-	GPIO_FN_SSI2_SDATA, GPIO_FN_SSI2_SCK, GPIO_FN_SSI2_WS,
-	GPIO_FN_SSI3_SDATA, GPIO_FN_SSI3_SCK, GPIO_FN_SSI3_WS,
-
-	/* SDIF1 */
-	GPIO_FN_SDIF1CMD, GPIO_FN_SDIF1CD, GPIO_FN_SDIF1WP, GPIO_FN_SDIF1CLK,
-	GPIO_FN_SDIF1D3, GPIO_FN_SDIF1D2, GPIO_FN_SDIF1D1, GPIO_FN_SDIF1D0,
-
-	/* SDIF0 */
-	GPIO_FN_SDIF0CMD, GPIO_FN_SDIF0CD, GPIO_FN_SDIF0WP, GPIO_FN_SDIF0CLK,
-	GPIO_FN_SDIF0D3, GPIO_FN_SDIF0D2, GPIO_FN_SDIF0D1, GPIO_FN_SDIF0D0,
-
-	/* TMU */
-	GPIO_FN_TCLK,
-
-	/* INTC */
-	GPIO_FN_IRL7, GPIO_FN_IRL6, GPIO_FN_IRL5, GPIO_FN_IRL4,
-};
-
-static inline u32 sh7786_mm_sel(void)
-{
-	return __raw_readl((const volatile void __iomem *)0xFC400020) & 0x7;
-}
-
-#endif /* __CPU_SH7786_H__ */
diff --git a/arch/sh/include/cpu-sh4/cpu/shx3.h b/arch/sh/include/cpu-sh4/cpu/shx3.h
deleted file mode 100644
index f356810b0bea58..00000000000000
--- a/arch/sh/include/cpu-sh4/cpu/shx3.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __CPU_SHX3_H
-#define __CPU_SHX3_H
-
-enum {
-	/* PA */
-	GPIO_PA7, GPIO_PA6, GPIO_PA5, GPIO_PA4,
-	GPIO_PA3, GPIO_PA2, GPIO_PA1, GPIO_PA0,
-
-	/* PB */
-	GPIO_PB7, GPIO_PB6, GPIO_PB5, GPIO_PB4,
-	GPIO_PB3, GPIO_PB2, GPIO_PB1, GPIO_PB0,
-
-	/* PC */
-	GPIO_PC7, GPIO_PC6, GPIO_PC5, GPIO_PC4,
-	GPIO_PC3, GPIO_PC2, GPIO_PC1, GPIO_PC0,
-
-	/* PD */
-	GPIO_PD7, GPIO_PD6, GPIO_PD5, GPIO_PD4,
-	GPIO_PD3, GPIO_PD2, GPIO_PD1, GPIO_PD0,
-
-	/* PE */
-	GPIO_PE7, GPIO_PE6, GPIO_PE5, GPIO_PE4,
-	GPIO_PE3, GPIO_PE2, GPIO_PE1, GPIO_PE0,
-
-	/* PF */
-	GPIO_PF7, GPIO_PF6, GPIO_PF5, GPIO_PF4,
-	GPIO_PF3, GPIO_PF2, GPIO_PF1, GPIO_PF0,
-
-	/* PG */
-	GPIO_PG7, GPIO_PG6, GPIO_PG5, GPIO_PG4,
-	GPIO_PG3, GPIO_PG2, GPIO_PG1, GPIO_PG0,
-
-	/* PH */
-	GPIO_PH5, GPIO_PH4,
-	GPIO_PH3, GPIO_PH2, GPIO_PH1, GPIO_PH0,
-
-	/* SCIF */
-	GPIO_FN_SCK3, GPIO_FN_TXD3, GPIO_FN_RXD3,
-	GPIO_FN_SCK2, GPIO_FN_TXD2, GPIO_FN_RXD2,
-	GPIO_FN_SCK1, GPIO_FN_TXD1, GPIO_FN_RXD1,
-	GPIO_FN_SCK0, GPIO_FN_TXD0, GPIO_FN_RXD0,
-
-	/* LBSC */
-	GPIO_FN_D31, GPIO_FN_D30, GPIO_FN_D29, GPIO_FN_D28,
-	GPIO_FN_D27, GPIO_FN_D26, GPIO_FN_D25, GPIO_FN_D24,
-	GPIO_FN_D23, GPIO_FN_D22, GPIO_FN_D21, GPIO_FN_D20,
-	GPIO_FN_D19, GPIO_FN_D18, GPIO_FN_D17, GPIO_FN_D16,
-	GPIO_FN_WE3, GPIO_FN_WE2, GPIO_FN_CS6, GPIO_FN_CS5,
-	GPIO_FN_CS4, GPIO_FN_CLKOUTENB, GPIO_FN_BREQ,
-	GPIO_FN_IOIS16, GPIO_FN_CE2B, GPIO_FN_CE2A, GPIO_FN_BACK,
-
-	/* DMAC */
-	GPIO_FN_DACK0, GPIO_FN_DREQ0, GPIO_FN_DRAK0,
-	GPIO_FN_DACK1, GPIO_FN_DREQ1, GPIO_FN_DRAK1,
-	GPIO_FN_DACK2, GPIO_FN_DREQ2, GPIO_FN_DRAK2,
-	GPIO_FN_DACK3, GPIO_FN_DREQ3, GPIO_FN_DRAK3,
-
-	/* INTC */
-	GPIO_FN_IRQ3, GPIO_FN_IRQ2, GPIO_FN_IRQ1, GPIO_FN_IRQ0,
-	GPIO_FN_IRL3, GPIO_FN_IRL2, GPIO_FN_IRL1, GPIO_FN_IRL0,
-	GPIO_FN_IRQOUT, GPIO_FN_STATUS1, GPIO_FN_STATUS0,
-};
-
-#endif /* __CPU_SHX3_H */
diff --git a/arch/sh/include/cpu-sh4/cpu/sigcontext.h b/arch/sh/include/cpu-sh4/cpu/sigcontext.h
deleted file mode 100644
index 2cc5f55dcaddf4..00000000000000
--- a/arch/sh/include/cpu-sh4/cpu/sigcontext.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_CPU_SH4_SIGCONTEXT_H
-#define __ASM_CPU_SH4_SIGCONTEXT_H
-
-struct sigcontext {
-	unsigned long	oldmask;
-
-	/* CPU registers */
-	unsigned long sc_regs[16];
-	unsigned long sc_pc;
-	unsigned long sc_pr;
-	unsigned long sc_sr;
-	unsigned long sc_gbr;
-	unsigned long sc_mach;
-	unsigned long sc_macl;
-
-	/* FPU registers */
-	unsigned long sc_fpregs[16];
-	unsigned long sc_xfpregs[16];
-	unsigned int sc_fpscr;
-	unsigned int sc_fpul;
-	unsigned int sc_ownedfp;
-};
-
-#endif /* __ASM_CPU_SH4_SIGCONTEXT_H */
diff --git a/arch/sh/include/cpu-sh4/cpu/sq.h b/arch/sh/include/cpu-sh4/cpu/sq.h
deleted file mode 100644
index 81966e41fc213b..00000000000000
--- a/arch/sh/include/cpu-sh4/cpu/sq.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/cpu-sh4/sq.h
- *
- * Copyright (C) 2001, 2002, 2003  Paul Mundt
- * Copyright (C) 2001, 2002  M. R. Brown
- */
-#ifndef __ASM_CPU_SH4_SQ_H
-#define __ASM_CPU_SH4_SQ_H
-
-#include <asm/addrspace.h>
-#include <asm/page.h>
-
-/*
- * Store queues range from e0000000-e3fffffc, allowing approx. 64MB to be
- * mapped to any physical address space. Since data is written (and aligned)
- * to 32-byte boundaries, we need to be sure that all allocations are aligned.
- */
-#define SQ_SIZE                 32
-#define SQ_ALIGN_MASK           (~(SQ_SIZE - 1))
-#define SQ_ALIGN(addr)          (((addr)+SQ_SIZE-1) & SQ_ALIGN_MASK)
-
-#define SQ_QACR0		(P4SEG_REG_BASE  + 0x38)
-#define SQ_QACR1		(P4SEG_REG_BASE  + 0x3c)
-#define SQ_ADDRMAX              (P4SEG_STORE_QUE + 0x04000000)
-
-/* arch/sh/kernel/cpu/sh4/sq.c */
-unsigned long sq_remap(unsigned long phys, unsigned int size,
-		       const char *name, pgprot_t prot);
-void sq_unmap(unsigned long vaddr);
-void sq_flush_range(unsigned long start, unsigned int len);
-
-#endif /* __ASM_CPU_SH4_SQ_H */
diff --git a/arch/sh/include/cpu-sh4/cpu/watchdog.h b/arch/sh/include/cpu-sh4/cpu/watchdog.h
deleted file mode 100644
index fa7bcb398b8cca..00000000000000
--- a/arch/sh/include/cpu-sh4/cpu/watchdog.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/cpu-sh4/watchdog.h
- *
- * Copyright (C) 2002, 2003 Paul Mundt
- * Copyright (C) 2009 Siemens AG
- * Copyright (C) 2009 Sitdikov Valentin
- */
-#ifndef __ASM_CPU_SH4_WATCHDOG_H
-#define __ASM_CPU_SH4_WATCHDOG_H
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7785) || defined(CONFIG_CPU_SUBTYPE_SH7780)
-/* Prefix definition */
-#define WTBST_HIGH	0x55
-/* Register definitions */
-#define WTCNT_R		0xffcc0010 /*WDTCNT*/
-#define WTCSR		0xffcc0004 /*WDTCSR*/
-#define WTCNT		0xffcc0000 /*WDTST*/
-#define WTST		WTCNT
-#define WTBST		0xffcc0008 /*WDTBST*/
-/* Register definitions */
-#elif	defined(CONFIG_CPU_SUBTYPE_SH7722) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7723) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7724)
-#define WTCNT		0xa4520000
-#define WTCSR		0xa4520004
-#else
-/* Register definitions */
-#define WTCNT		0xffc00008
-#define WTCSR		0xffc0000c
-#endif
-
-/* Bit definitions */
-#define WTCSR_TME	0x80
-#define WTCSR_WT	0x40
-#define WTCSR_RSTS	0x20
-#define WTCSR_WOVF	0x10
-#define WTCSR_IOVF	0x08
-
-#endif /* __ASM_CPU_SH4_WATCHDOG_H */
-
diff --git a/arch/sh/include/cpu-sh4a/cpu/dma.h b/arch/sh/include/cpu-sh4a/cpu/dma.h
deleted file mode 100644
index bdbbba8a784a7b..00000000000000
--- a/arch/sh/include/cpu-sh4a/cpu/dma.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_CPU_SH4_DMA_SH7780_H
-#define __ASM_SH_CPU_SH4_DMA_SH7780_H
-
-#include <linux/sh_intc.h>
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7343) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7730)
-#define DMTE0_IRQ	evt2irq(0x800)
-#define DMTE4_IRQ	evt2irq(0xb80)
-#define DMAE0_IRQ	evt2irq(0xbc0)	/* DMA Error IRQ*/
-#define SH_DMAC_BASE0	0xFE008020
-#elif defined(CONFIG_CPU_SUBTYPE_SH7722)
-#define DMTE0_IRQ	evt2irq(0x800)
-#define DMTE4_IRQ	evt2irq(0xb80)
-#define DMAE0_IRQ	evt2irq(0xbc0)	/* DMA Error IRQ*/
-#define SH_DMAC_BASE0	0xFE008020
-#elif defined(CONFIG_CPU_SUBTYPE_SH7763)
-#define DMTE0_IRQ	evt2irq(0x640)
-#define DMTE4_IRQ	evt2irq(0x780)
-#define DMAE0_IRQ	evt2irq(0x6c0)
-#define SH_DMAC_BASE0	0xFF608020
-#elif defined(CONFIG_CPU_SUBTYPE_SH7723)
-#define DMTE0_IRQ	evt2irq(0x800)	/* DMAC0A*/
-#define DMTE4_IRQ	evt2irq(0xb80)	/* DMAC0B */
-#define DMTE6_IRQ	evt2irq(0x700)
-#define DMTE8_IRQ	evt2irq(0x740)	/* DMAC1A */
-#define DMTE9_IRQ	evt2irq(0x760)
-#define DMTE10_IRQ	evt2irq(0xb00)	/* DMAC1B */
-#define DMTE11_IRQ	evt2irq(0xb20)
-#define DMAE0_IRQ	evt2irq(0xbc0)	/* DMA Error IRQ*/
-#define DMAE1_IRQ	evt2irq(0xb40)	/* DMA Error IRQ*/
-#define SH_DMAC_BASE0	0xFE008020
-#define SH_DMAC_BASE1	0xFDC08020
-#elif defined(CONFIG_CPU_SUBTYPE_SH7724)
-#define DMTE0_IRQ	evt2irq(0x800)	/* DMAC0A*/
-#define DMTE4_IRQ	evt2irq(0xb80)	/* DMAC0B */
-#define DMTE6_IRQ	evt2irq(0x700)
-#define DMTE8_IRQ	evt2irq(0x740)	/* DMAC1A */
-#define DMTE9_IRQ	evt2irq(0x760)
-#define DMTE10_IRQ	evt2irq(0xb00)	/* DMAC1B */
-#define DMTE11_IRQ	evt2irq(0xb20)
-#define DMAE0_IRQ	evt2irq(0xbc0)	/* DMA Error IRQ*/
-#define DMAE1_IRQ	evt2irq(0xb40)	/* DMA Error IRQ*/
-#define SH_DMAC_BASE0	0xFE008020
-#define SH_DMAC_BASE1	0xFDC08020
-#elif defined(CONFIG_CPU_SUBTYPE_SH7780)
-#define DMTE0_IRQ	evt2irq(0x640)
-#define DMTE4_IRQ	evt2irq(0x780)
-#define DMTE6_IRQ	evt2irq(0x7c0)
-#define DMTE8_IRQ	evt2irq(0xd80)
-#define DMTE9_IRQ	evt2irq(0xda0)
-#define DMTE10_IRQ	evt2irq(0xdc0)
-#define DMTE11_IRQ	evt2irq(0xde0)
-#define DMAE0_IRQ	evt2irq(0x6c0)	/* DMA Error IRQ */
-#define SH_DMAC_BASE0	0xFC808020
-#define SH_DMAC_BASE1	0xFC818020
-#else /* SH7785 */
-#define DMTE0_IRQ	evt2irq(0x620)
-#define DMTE4_IRQ	evt2irq(0x6a0)
-#define DMTE6_IRQ	evt2irq(0x880)
-#define DMTE8_IRQ	evt2irq(0x8c0)
-#define DMTE9_IRQ	evt2irq(0x8e0)
-#define DMTE10_IRQ	evt2irq(0x900)
-#define DMTE11_IRQ	evt2irq(0x920)
-#define DMAE0_IRQ	evt2irq(0x6e0)	/* DMA Error IRQ0 */
-#define DMAE1_IRQ	evt2irq(0x940)	/* DMA Error IRQ1 */
-#define SH_DMAC_BASE0	0xFC808020
-#define SH_DMAC_BASE1	0xFCC08020
-#endif
-
-#endif /* __ASM_SH_CPU_SH4_DMA_SH7780_H */
diff --git a/arch/sh/include/cpu-sh4a/cpu/serial.h b/arch/sh/include/cpu-sh4a/cpu/serial.h
deleted file mode 100644
index fc206c0bf6fb06..00000000000000
--- a/arch/sh/include/cpu-sh4a/cpu/serial.h
+++ /dev/null
@@ -1,8 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __CPU_SH4A_SERIAL_H
-#define __CPU_SH4A_SERIAL_H
-
-/* arch/sh/kernel/cpu/sh4a/serial-sh7722.c */
-extern struct plat_sci_port_ops sh7722_sci_port_ops;
-
-#endif /* __CPU_SH4A_SERIAL_H */
diff --git a/arch/sh/include/mach-common/mach/highlander.h b/arch/sh/include/mach-common/mach/highlander.h
deleted file mode 100644
index fb44c299d0337e..00000000000000
--- a/arch/sh/include/mach-common/mach/highlander.h
+++ /dev/null
@@ -1,208 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_RENESAS_R7780RP_H
-#define __ASM_SH_RENESAS_R7780RP_H
-
-/* Box specific addresses.  */
-#define PA_NORFLASH_ADDR	0x00000000
-#define PA_NORFLASH_SIZE	0x04000000
-
-#if defined(CONFIG_SH_R7780MP)
-#define PA_BCR          0xa4000000      /* FPGA */
-#define PA_SDPOW	(-1)
-
-#define PA_IRLMSK       (PA_BCR+0x0000) /* Interrupt Mask control */
-#define PA_IRLMON       (PA_BCR+0x0002) /* Interrupt Status control */
-#define PA_IRLPRI1      (PA_BCR+0x0004) /* Interrupt Priorty 1 */
-#define PA_IRLPRI2      (PA_BCR+0x0006) /* Interrupt Priorty 2 */
-#define PA_IRLPRI3      (PA_BCR+0x0008) /* Interrupt Priorty 3 */
-#define PA_IRLPRI4      (PA_BCR+0x000a) /* Interrupt Priorty 4 */
-#define PA_RSTCTL       (PA_BCR+0x000c) /* Reset Control */
-#define PA_PCIBD        (PA_BCR+0x000e) /* PCI Board detect control */
-#define PA_PCICD        (PA_BCR+0x0010) /* PCI Connector detect control */
-#define PA_EXTGIO       (PA_BCR+0x0016) /* Extension GPIO Control */
-#define PA_IVDRMON      (PA_BCR+0x0018) /* iVDR Moniter control */
-#define PA_IVDRCTL      (PA_BCR+0x001a) /* iVDR control */
-#define PA_OBLED        (PA_BCR+0x001c) /* On Board LED control */
-#define PA_OBSW         (PA_BCR+0x001e) /* On Board Switch control */
-#define PA_AUDIOSEL     (PA_BCR+0x0020) /* Sound Interface Select control */
-#define PA_EXTPLR       (PA_BCR+0x001e) /* Extension Pin Polarity control */
-#define PA_TPCTL        (PA_BCR+0x0100) /* Touch Panel Access control */
-#define PA_TPDCKCTL     (PA_BCR+0x0102) /* Touch Panel Access data control */
-#define PA_TPCTLCLR     (PA_BCR+0x0104) /* Touch Panel Access control */
-#define PA_TPXPOS       (PA_BCR+0x0106) /* Touch Panel X position control */
-#define PA_TPYPOS       (PA_BCR+0x0108) /* Touch Panel Y position control */
-#define PA_DBSW         (PA_BCR+0x0200) /* Debug Board Switch control */
-#define PA_CFCTL        (PA_BCR+0x0300) /* CF Timing control */
-#define PA_CFPOW        (PA_BCR+0x0302) /* CF Power control */
-#define PA_CFCDINTCLR   (PA_BCR+0x0304) /* CF Insert Interrupt clear */
-#define PA_SCSMR0       (PA_BCR+0x0400) /* SCIF0 Serial mode control */
-#define PA_SCBRR0       (PA_BCR+0x0404) /* SCIF0 Bit rate control */
-#define PA_SCSCR0       (PA_BCR+0x0408) /* SCIF0 Serial control */
-#define PA_SCFTDR0      (PA_BCR+0x040c) /* SCIF0 Send FIFO control */
-#define PA_SCFSR0       (PA_BCR+0x0410) /* SCIF0 Serial status control */
-#define PA_SCFRDR0      (PA_BCR+0x0414) /* SCIF0 Receive FIFO control */
-#define PA_SCFCR0       (PA_BCR+0x0418) /* SCIF0 FIFO control */
-#define PA_SCTFDR0      (PA_BCR+0x041c) /* SCIF0 Send FIFO data control */
-#define PA_SCRFDR0      (PA_BCR+0x0420) /* SCIF0 Receive FIFO data control */
-#define PA_SCSPTR0      (PA_BCR+0x0424) /* SCIF0 Serial Port control */
-#define PA_SCLSR0       (PA_BCR+0x0428) /* SCIF0 Line Status control */
-#define PA_SCRER0       (PA_BCR+0x042c) /* SCIF0 Serial Error control */
-#define PA_SCSMR1       (PA_BCR+0x0500) /* SCIF1 Serial mode control */
-#define PA_SCBRR1       (PA_BCR+0x0504) /* SCIF1 Bit rate control */
-#define PA_SCSCR1       (PA_BCR+0x0508) /* SCIF1 Serial control */
-#define PA_SCFTDR1      (PA_BCR+0x050c) /* SCIF1 Send FIFO control */
-#define PA_SCFSR1       (PA_BCR+0x0510) /* SCIF1 Serial status control */
-#define PA_SCFRDR1      (PA_BCR+0x0514) /* SCIF1 Receive FIFO control */
-#define PA_SCFCR1       (PA_BCR+0x0518) /* SCIF1 FIFO control */
-#define PA_SCTFDR1      (PA_BCR+0x051c) /* SCIF1 Send FIFO data control */
-#define PA_SCRFDR1      (PA_BCR+0x0520) /* SCIF1 Receive FIFO data control */
-#define PA_SCSPTR1      (PA_BCR+0x0524) /* SCIF1 Serial Port control */
-#define PA_SCLSR1       (PA_BCR+0x0528) /* SCIF1 Line Status control */
-#define PA_SCRER1       (PA_BCR+0x052c) /* SCIF1 Serial Error control */
-#define PA_SMCR         (PA_BCR+0x0600) /* 2-wire Serial control */
-#define PA_SMSMADR      (PA_BCR+0x0602) /* 2-wire Serial Slave control */
-#define PA_SMMR         (PA_BCR+0x0604) /* 2-wire Serial Mode control */
-#define PA_SMSADR1      (PA_BCR+0x0606) /* 2-wire Serial Address1 control */
-#define PA_SMTRDR1      (PA_BCR+0x0646) /* 2-wire Serial Data1 control */
-#define PA_VERREG       (PA_BCR+0x0700) /* FPGA Version Register */
-#define PA_POFF         (PA_BCR+0x0800) /* System Power Off control */
-#define PA_PMR          (PA_BCR+0x0900) /*  */
-
-#define IRLCNTR1        (PA_BCR + 0)    /* Interrupt Control Register1 */
-#define IVDR_CK_ON	8		/* iVDR Clock ON */
-
-#elif defined(CONFIG_SH_R7780RP)
-#define PA_POFF		(-1)
-
-#define PA_BCR		0xa5000000	/* FPGA */
-#define	PA_IRLMSK	(PA_BCR+0x0000)	/* Interrupt Mask control */
-#define PA_IRLMON	(PA_BCR+0x0002)	/* Interrupt Status control */
-#define	PA_SDPOW	(PA_BCR+0x0004)	/* SD Power control */
-#define	PA_RSTCTL	(PA_BCR+0x0006)	/* Device Reset control */
-#define	PA_PCIBD	(PA_BCR+0x0008)	/* PCI Board detect control */
-#define	PA_PCICD	(PA_BCR+0x000a)	/* PCI Connector detect control */
-#define	PA_ZIGIO1	(PA_BCR+0x000c)	/* Zigbee IO control 1 */
-#define	PA_ZIGIO2	(PA_BCR+0x000e)	/* Zigbee IO control 2 */
-#define	PA_ZIGIO3	(PA_BCR+0x0010)	/* Zigbee IO control 3 */
-#define	PA_ZIGIO4	(PA_BCR+0x0012)	/* Zigbee IO control 4 */
-#define	PA_IVDRMON	(PA_BCR+0x0014)	/* iVDR Moniter control */
-#define	PA_IVDRCTL	(PA_BCR+0x0016)	/* iVDR control */
-#define PA_OBLED	(PA_BCR+0x0018)	/* On Board LED control */
-#define PA_OBSW		(PA_BCR+0x001a)	/* On Board Switch control */
-#define PA_AUDIOSEL	(PA_BCR+0x001c)	/* Sound Interface Select control */
-#define PA_EXTPLR	(PA_BCR+0x001e)	/* Extension Pin Polarity control */
-#define PA_TPCTL	(PA_BCR+0x0100)	/* Touch Panel Access control */
-#define PA_TPDCKCTL	(PA_BCR+0x0102)	/* Touch Panel Access data control */
-#define PA_TPCTLCLR	(PA_BCR+0x0104)	/* Touch Panel Access control */
-#define PA_TPXPOS	(PA_BCR+0x0106)	/* Touch Panel X position control */
-#define PA_TPYPOS	(PA_BCR+0x0108)	/* Touch Panel Y position control */
-#define PA_DBDET	(PA_BCR+0x0200)	/* Debug Board detect control */
-#define PA_DBDISPCTL	(PA_BCR+0x0202)	/* Debug Board Dot timing control */
-#define PA_DBSW		(PA_BCR+0x0204)	/* Debug Board Switch control */
-#define PA_CFCTL	(PA_BCR+0x0300)	/* CF Timing control */
-#define PA_CFPOW	(PA_BCR+0x0302)	/* CF Power control */
-#define PA_CFCDINTCLR	(PA_BCR+0x0304)	/* CF Insert Interrupt clear */
-#define PA_SCSMR	(PA_BCR+0x0400)	/* SCIF Serial mode control */
-#define PA_SCBRR	(PA_BCR+0x0402)	/* SCIF Bit rate control */
-#define PA_SCSCR	(PA_BCR+0x0404)	/* SCIF Serial control */
-#define PA_SCFDTR	(PA_BCR+0x0406)	/* SCIF Send FIFO control */
-#define PA_SCFSR	(PA_BCR+0x0408)	/* SCIF Serial status control */
-#define PA_SCFRDR	(PA_BCR+0x040a)	/* SCIF Receive FIFO control */
-#define PA_SCFCR	(PA_BCR+0x040c)	/* SCIF FIFO control */
-#define PA_SCFDR	(PA_BCR+0x040e)	/* SCIF FIFO data control */
-#define PA_SCLSR	(PA_BCR+0x0412)	/* SCIF Line Status control */
-#define PA_SMCR		(PA_BCR+0x0500)	/* 2-wire Serial control */
-#define PA_SMSMADR	(PA_BCR+0x0502)	/* 2-wire Serial Slave control */
-#define PA_SMMR		(PA_BCR+0x0504)	/* 2-wire Serial Mode control */
-#define PA_SMSADR1	(PA_BCR+0x0506)	/* 2-wire Serial Address1 control */
-#define PA_SMTRDR1	(PA_BCR+0x0546)	/* 2-wire Serial Data1 control */
-#define PA_VERREG	(PA_BCR+0x0600)	/* FPGA Version Register */
-
-#define PA_AX88796L	0xa5800400	/* AX88796L Area */
-#define PA_SC1602BSLB	0xa6000000	/* SC1602BSLB Area */
-#define PA_IDE_OFFSET	0x1f0		/* CF IDE Offset */
-#define AX88796L_IO_BASE	0x1000	/* AX88796L IO Base Address */
-
-#define IRLCNTR1	(PA_BCR + 0)	/* Interrupt Control Register1 */
-
-#define IVDR_CK_ON	8		/* iVDR Clock ON */
-
-#elif defined(CONFIG_SH_R7785RP)
-#define PA_BCR		0xa4000000	/* FPGA */
-#define PA_SDPOW	(-1)
-
-#define	PA_PCISCR	(PA_BCR+0x0000)
-#define PA_IRLPRA	(PA_BCR+0x0002)
-#define	PA_IRLPRB	(PA_BCR+0x0004)
-#define	PA_IRLPRC	(PA_BCR+0x0006)
-#define	PA_IRLPRD	(PA_BCR+0x0008)
-#define IRLCNTR1	(PA_BCR+0x0010)
-#define	PA_IRLPRE	(PA_BCR+0x000a)
-#define	PA_IRLPRF	(PA_BCR+0x000c)
-#define	PA_EXIRLCR	(PA_BCR+0x000e)
-#define	PA_IRLMCR1	(PA_BCR+0x0010)
-#define	PA_IRLMCR2	(PA_BCR+0x0012)
-#define	PA_IRLSSR1	(PA_BCR+0x0014)
-#define	PA_IRLSSR2	(PA_BCR+0x0016)
-#define PA_CFTCR	(PA_BCR+0x0100)
-#define PA_CFPCR	(PA_BCR+0x0102)
-#define PA_PCICR	(PA_BCR+0x0110)
-#define PA_IVDRCTL	(PA_BCR+0x0112)
-#define PA_IVDRSR	(PA_BCR+0x0114)
-#define PA_PDRSTCR	(PA_BCR+0x0116)
-#define PA_POFF		(PA_BCR+0x0120)
-#define PA_LCDCR	(PA_BCR+0x0130)
-#define PA_TPCR		(PA_BCR+0x0140)
-#define PA_TPCKCR	(PA_BCR+0x0142)
-#define PA_TPRSTR	(PA_BCR+0x0144)
-#define PA_TPXPDR	(PA_BCR+0x0146)
-#define PA_TPYPDR	(PA_BCR+0x0148)
-#define PA_GPIOPFR	(PA_BCR+0x0150)
-#define PA_GPIODR	(PA_BCR+0x0152)
-#define PA_OBLED	(PA_BCR+0x0154)
-#define PA_SWSR		(PA_BCR+0x0156)
-#define PA_VERREG	(PA_BCR+0x0158)
-#define PA_SMCR		(PA_BCR+0x0200)
-#define PA_SMSMADR	(PA_BCR+0x0202)
-#define PA_SMMR		(PA_BCR+0x0204)
-#define PA_SMSADR1	(PA_BCR+0x0206)
-#define PA_SMSADR32	(PA_BCR+0x0244)
-#define PA_SMTRDR1	(PA_BCR+0x0246)
-#define PA_SMTRDR16	(PA_BCR+0x0264)
-#define PA_CU3MDR	(PA_BCR+0x0300)
-#define PA_CU5MDR	(PA_BCR+0x0302)
-#define PA_MMSR		(PA_BCR+0x0400)
-
-#define IVDR_CK_ON	4		/* iVDR Clock ON */
-#endif
-
-#define HL_FPGA_IRQ_BASE	200
-#define HL_NR_IRL		15
-
-#define IRQ_AX88796		(HL_FPGA_IRQ_BASE + 0)
-#define IRQ_CF			(HL_FPGA_IRQ_BASE + 1)
-#define IRQ_PSW			(HL_FPGA_IRQ_BASE + 2)
-#define IRQ_EXT0		(HL_FPGA_IRQ_BASE + 3)
-#define IRQ_EXT1		(HL_FPGA_IRQ_BASE + 4)
-#define IRQ_EXT2		(HL_FPGA_IRQ_BASE + 5)
-#define IRQ_EXT3		(HL_FPGA_IRQ_BASE + 6)
-#define IRQ_EXT4		(HL_FPGA_IRQ_BASE + 7)
-#define IRQ_EXT5		(HL_FPGA_IRQ_BASE + 8)
-#define IRQ_EXT6		(HL_FPGA_IRQ_BASE + 9)
-#define IRQ_EXT7		(HL_FPGA_IRQ_BASE + 10)
-#define IRQ_SMBUS		(HL_FPGA_IRQ_BASE + 11)
-#define IRQ_TP			(HL_FPGA_IRQ_BASE + 12)
-#define IRQ_RTC			(HL_FPGA_IRQ_BASE + 13)
-#define IRQ_TH_ALERT		(HL_FPGA_IRQ_BASE + 14)
-#define IRQ_SCIF0		(HL_FPGA_IRQ_BASE + 15)
-#define IRQ_SCIF1		(HL_FPGA_IRQ_BASE + 16)
-
-unsigned char *highlander_plat_irq_setup(void);
-
-#ifdef CONFIG_SH_R7785RP
-void highlander_plat_pinmux_setup(void);
-#else
-#define highlander_plat_pinmux_setup()	do { } while (0)
-#endif
-
-#endif  /* __ASM_SH_RENESAS_R7780RP */
diff --git a/arch/sh/include/mach-common/mach/hp6xx.h b/arch/sh/include/mach-common/mach/hp6xx.h
deleted file mode 100644
index 71241f0d02a19c..00000000000000
--- a/arch/sh/include/mach-common/mach/hp6xx.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * Copyright (C) 2003, 2004, 2005  Andriy Skulysh
- */
-#ifndef __ASM_SH_HP6XX_H
-#define __ASM_SH_HP6XX_H
-
-#include <linux/sh_intc.h>
-
-#define HP680_BTN_IRQ		evt2irq(0x600)	/* IRQ0_IRQ */
-#define HP680_TS_IRQ		evt2irq(0x660)	/* IRQ3_IRQ */
-#define HP680_HD64461_IRQ	evt2irq(0x680)	/* IRQ4_IRQ */
-
-#define DAC_LCD_BRIGHTNESS	0
-#define DAC_SPEAKER_VOLUME	1
-
-#define PGDR_OPENED		0x01
-#define PGDR_MAIN_BATTERY_OUT	0x04
-#define PGDR_PLAY_BUTTON	0x08
-#define PGDR_REWIND_BUTTON	0x10
-#define PGDR_RECORD_BUTTON	0x20
-
-#define PHDR_TS_PEN_DOWN	0x08
-
-#define PJDR_LED_BLINK		0x02
-
-#define PKDR_LED_GREEN		0x10
-
-/* HP Palmtop 620lx/660lx speaker on/off */
-#define PKDR_SPEAKER		0x20
-
-#define SCPDR_TS_SCAN_ENABLE	0x20
-#define SCPDR_TS_SCAN_Y		0x02
-#define SCPDR_TS_SCAN_X		0x01
-
-#define SCPCR_TS_ENABLE		0x405
-#define SCPCR_TS_MASK		0xc0f
-
-#define ADC_CHANNEL_TS_Y	1
-#define ADC_CHANNEL_TS_X	2
-#define ADC_CHANNEL_BATTERY	3
-#define ADC_CHANNEL_BACKUP	4
-#define ADC_CHANNEL_CHARGE	5
-
-/* HP Jornada 680/690 speaker on/off */
-#define HD64461_GPADR_SPEAKER	0x01
-#define HD64461_GPADR_PCMCIA0	(0x02|0x08)
-
-#define HD64461_GPBDR_LCDOFF	0x01
-#define HD64461_GPBDR_LCD_CONTRAST_MASK	0x78
-#define HD64461_GPBDR_LED_RED	0x80
-
-#include <asm/hd64461.h>
-#include <asm/io.h>
-
-#define PJDR	0xa4000130
-#define PKDR	0xa4000132
-
-#endif /* __ASM_SH_HP6XX_H */
diff --git a/arch/sh/include/mach-common/mach/lboxre2.h b/arch/sh/include/mach-common/mach/lboxre2.h
deleted file mode 100644
index 5b6bb8e3cf2847..00000000000000
--- a/arch/sh/include/mach-common/mach/lboxre2.h
+++ /dev/null
@@ -1,24 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_LBOXRE2_H
-#define __ASM_SH_LBOXRE2_H
-
-/*
- * Copyright (C) 2007 Nobuhiro Iwamatsu
- *
- * NTT COMWARE L-BOX RE2 support
- */
-#include <linux/sh_intc.h>
-
-#define IRQ_CF1		evt2irq(0x320)	/* CF1 */
-#define IRQ_CF0		evt2irq(0x340)	/* CF0 */
-#define IRQ_INTD	evt2irq(0x360)	/* INTD */
-#define IRQ_ETH1	evt2irq(0x380)	/* Ether1 */
-#define IRQ_ETH0	evt2irq(0x3a0)	/* Ether0 */
-#define IRQ_INTA	evt2irq(0x3c0)	/* INTA */
-
-void init_lboxre2_IRQ(void);
-
-#define __IO_PREFIX	lboxre2
-#include <asm/io_generic.h>
-
-#endif  /* __ASM_SH_LBOXRE2_H */
diff --git a/arch/sh/include/mach-common/mach/magicpanelr2.h b/arch/sh/include/mach-common/mach/magicpanelr2.h
deleted file mode 100644
index c2d218cea74b65..00000000000000
--- a/arch/sh/include/mach-common/mach/magicpanelr2.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- *  include/asm-sh/magicpanelr2.h
- *
- *  Copyright (C) 2007  Markus Brunner, Mark Jonas
- *
- *  I/O addresses and bitmasks for Magic Panel Release 2 board
- */
-
-#ifndef __ASM_SH_MAGICPANELR2_H
-#define __ASM_SH_MAGICPANELR2_H
-
-#include <linux/gpio.h>
-
-#define __IO_PREFIX mpr2
-#include <asm/io_generic.h>
-
-
-#define SETBITS_OUTB(mask, reg)   __raw_writeb(__raw_readb(reg) | mask, reg)
-#define SETBITS_OUTW(mask, reg)   __raw_writew(__raw_readw(reg) | mask, reg)
-#define SETBITS_OUTL(mask, reg)   __raw_writel(__raw_readl(reg) | mask, reg)
-#define CLRBITS_OUTB(mask, reg)   __raw_writeb(__raw_readb(reg) & ~mask, reg)
-#define CLRBITS_OUTW(mask, reg)   __raw_writew(__raw_readw(reg) & ~mask, reg)
-#define CLRBITS_OUTL(mask, reg)   __raw_writel(__raw_readl(reg) & ~mask, reg)
-
-
-#define PA_LED          PORT_PADR      /* LED */
-
-
-/* BSC */
-#define CMNCR           0xA4FD0000UL
-#define CS0BCR          0xA4FD0004UL
-#define CS2BCR          0xA4FD0008UL
-#define CS3BCR          0xA4FD000CUL
-#define CS4BCR          0xA4FD0010UL
-#define CS5ABCR         0xA4FD0014UL
-#define CS5BBCR         0xA4FD0018UL
-#define CS6ABCR         0xA4FD001CUL
-#define CS6BBCR         0xA4FD0020UL
-#define CS0WCR          0xA4FD0024UL
-#define CS2WCR          0xA4FD0028UL
-#define CS3WCR          0xA4FD002CUL
-#define CS4WCR          0xA4FD0030UL
-#define CS5AWCR         0xA4FD0034UL
-#define CS5BWCR         0xA4FD0038UL
-#define CS6AWCR         0xA4FD003CUL
-#define CS6BWCR         0xA4FD0040UL
-
-
-/* usb */
-
-#define PORT_UTRCTL		0xA405012CUL
-#define PORT_UCLKCR_W		0xA40A0008UL
-
-#define INTC_ICR0		0xA414FEE0UL
-#define INTC_ICR1		0xA4140010UL
-#define INTC_ICR2		0xA4140012UL
-
-/* MTD */
-
-#define MPR2_MTD_BOOTLOADER_SIZE	0x00060000UL
-#define MPR2_MTD_KERNEL_SIZE		0x00200000UL
-
-#endif  /* __ASM_SH_MAGICPANELR2_H */
diff --git a/arch/sh/include/mach-common/mach/mangle-port.h b/arch/sh/include/mach-common/mach/mangle-port.h
deleted file mode 100644
index dd5a761a52ee63..00000000000000
--- a/arch/sh/include/mach-common/mach/mangle-port.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * SH version cribbed from the MIPS copy:
- *
- * Copyright (C) 2003, 2004 Ralf Baechle
- */
-#ifndef __MACH_COMMON_MANGLE_PORT_H
-#define __MACH_COMMON_MANGLE_PORT_H
-
-/*
- * Sane hardware offers swapping of PCI/ISA I/O space accesses in hardware;
- * less sane hardware forces software to fiddle with this...
- *
- * Regardless, if the host bus endianness mismatches that of PCI/ISA, then
- * you can't have the numerical value of data and byte addresses within
- * multibyte quantities both preserved at the same time.  Hence two
- * variations of functions: non-prefixed ones that preserve the value
- * and prefixed ones that preserve byte addresses.  The latters are
- * typically used for moving raw data between a peripheral and memory (cf.
- * string I/O functions), hence the "__mem_" prefix.
- */
-#if defined(CONFIG_SWAP_IO_SPACE)
-
-# define ioswabb(x)		(x)
-# define __mem_ioswabb(x)	(x)
-# define ioswabw(x)		le16_to_cpu(x)
-# define __mem_ioswabw(x)	(x)
-# define ioswabl(x)		le32_to_cpu(x)
-# define __mem_ioswabl(x)	(x)
-# define ioswabq(x)		le64_to_cpu(x)
-# define __mem_ioswabq(x)	(x)
-
-#else
-
-# define ioswabb(x)		(x)
-# define __mem_ioswabb(x)	(x)
-# define ioswabw(x)		(x)
-# define __mem_ioswabw(x)	cpu_to_le16(x)
-# define ioswabl(x)		(x)
-# define __mem_ioswabl(x)	cpu_to_le32(x)
-# define ioswabq(x)		(x)
-# define __mem_ioswabq(x)	cpu_to_le32(x)
-
-#endif
-
-#endif /* __MACH_COMMON_MANGLE_PORT_H */
diff --git a/arch/sh/include/mach-common/mach/microdev.h b/arch/sh/include/mach-common/mach/microdev.h
deleted file mode 100644
index 0e2f9ab1197620..00000000000000
--- a/arch/sh/include/mach-common/mach/microdev.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * linux/include/asm-sh/microdev.h
- *
- * Copyright (C) 2003 Sean McGoogan (Sean.McGoogan@superh.com)
- *
- * Definitions for the SuperH SH4-202 MicroDev board.
- */
-#ifndef __ASM_SH_MICRODEV_H
-#define __ASM_SH_MICRODEV_H
-
-extern void init_microdev_irq(void);
-extern void microdev_print_fpga_intc_status(void);
-
-/*
- * The following are useful macros for manipulating the interrupt
- * controller (INTC) on the CPU-board FPGA.  should be noted that there
- * is an INTC on the FPGA, and a separate INTC on the SH4-202 core -
- * these are two different things, both of which need to be prorammed to
- * correctly route - unfortunately, they have the same name and
- * abbreviations!
- */
-#define	MICRODEV_FPGA_INTC_BASE		0xa6110000ul				/* INTC base address on CPU-board FPGA */
-#define	MICRODEV_FPGA_INTENB_REG	(MICRODEV_FPGA_INTC_BASE+0ul)		/* Interrupt Enable Register on INTC on CPU-board FPGA */
-#define	MICRODEV_FPGA_INTDSB_REG	(MICRODEV_FPGA_INTC_BASE+8ul)		/* Interrupt Disable Register on INTC on CPU-board FPGA */
-#define	MICRODEV_FPGA_INTC_MASK(n)	(1ul<<(n))				/* Interrupt mask to enable/disable INTC in CPU-board FPGA */
-#define	MICRODEV_FPGA_INTPRI_REG(n)	(MICRODEV_FPGA_INTC_BASE+0x10+((n)/8)*8)/* Interrupt Priority Register on INTC on CPU-board FPGA */
-#define	MICRODEV_FPGA_INTPRI_LEVEL(n,x)	((x)<<(((n)%8)*4))			/* MICRODEV_FPGA_INTPRI_LEVEL(int_number, int_level) */
-#define	MICRODEV_FPGA_INTPRI_MASK(n)	(MICRODEV_FPGA_INTPRI_LEVEL((n),0xful))	/* Interrupt Priority Mask on INTC on CPU-board FPGA */
-#define	MICRODEV_FPGA_INTSRC_REG	(MICRODEV_FPGA_INTC_BASE+0x30ul)	/* Interrupt Source Register on INTC on CPU-board FPGA */
-#define	MICRODEV_FPGA_INTREQ_REG	(MICRODEV_FPGA_INTC_BASE+0x38ul)	/* Interrupt Request Register on INTC on CPU-board FPGA */
-
-
-/*
- * The following are the IRQ numbers for the Linux Kernel for external
- * interrupts.  i.e. the numbers seen by 'cat /proc/interrupt'.
- */
-#define MICRODEV_LINUX_IRQ_KEYBOARD	 1	/* SuperIO Keyboard */
-#define MICRODEV_LINUX_IRQ_SERIAL1	 2	/* SuperIO Serial #1 */
-#define MICRODEV_LINUX_IRQ_ETHERNET	 3	/* on-board Ethnernet */
-#define MICRODEV_LINUX_IRQ_SERIAL2	 4	/* SuperIO Serial #2 */
-#define MICRODEV_LINUX_IRQ_USB_HC	 7	/* on-board USB HC */
-#define MICRODEV_LINUX_IRQ_MOUSE	12	/* SuperIO PS/2 Mouse */
-#define MICRODEV_LINUX_IRQ_IDE2		13	/* SuperIO IDE #2 */
-#define MICRODEV_LINUX_IRQ_IDE1		14	/* SuperIO IDE #1 */
-
-/*
- * The following are the IRQ numbers for the INTC on the FPGA for
- * external interrupts.  i.e. the bits in the INTC registers in the
- * FPGA.
- */
-#define MICRODEV_FPGA_IRQ_KEYBOARD	 1	/* SuperIO Keyboard */
-#define MICRODEV_FPGA_IRQ_SERIAL1	 3	/* SuperIO Serial #1 */
-#define MICRODEV_FPGA_IRQ_SERIAL2	 4	/* SuperIO Serial #2 */
-#define MICRODEV_FPGA_IRQ_MOUSE		12	/* SuperIO PS/2 Mouse */
-#define MICRODEV_FPGA_IRQ_IDE1		14	/* SuperIO IDE #1 */
-#define MICRODEV_FPGA_IRQ_IDE2		15	/* SuperIO IDE #2 */
-#define MICRODEV_FPGA_IRQ_USB_HC	16	/* on-board USB HC */
-#define MICRODEV_FPGA_IRQ_ETHERNET	18	/* on-board Ethnernet */
-
-#define MICRODEV_IRQ_PCI_INTA		 8
-#define MICRODEV_IRQ_PCI_INTB		 9
-#define MICRODEV_IRQ_PCI_INTC		10
-#define MICRODEV_IRQ_PCI_INTD		11
-
-#define __IO_PREFIX microdev
-#include <asm/io_generic.h>
-
-#endif /* __ASM_SH_MICRODEV_H */
diff --git a/arch/sh/include/mach-common/mach/r2d.h b/arch/sh/include/mach-common/mach/r2d.h
deleted file mode 100644
index 0d7e483c7d3f53..00000000000000
--- a/arch/sh/include/mach-common/mach/r2d.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_RENESAS_RTS7751R2D_H
-#define __ASM_SH_RENESAS_RTS7751R2D_H
-
-/*
- * linux/include/asm-sh/renesas_rts7751r2d.h
- *
- * Copyright (C) 2000  Atom Create Engineering Co., Ltd.
- *
- * Renesas Technology Sales RTS7751R2D support
- */
-
-/* Board specific addresses.  */
-
-#define PA_BCR		0xa4000000	/* FPGA */
-#define PA_IRLMON	0xa4000002	/* Interrupt Status control */
-#define PA_CFCTL	0xa4000004	/* CF Timing control */
-#define PA_CFPOW	0xa4000006	/* CF Power control */
-#define PA_DISPCTL	0xa4000008	/* Display Timing control */
-#define PA_SDMPOW	0xa400000a	/* SD Power control */
-#define PA_RTCCE	0xa400000c	/* RTC(9701) Enable control */
-#define PA_PCICD	0xa400000e	/* PCI Extension detect control */
-#define PA_VOYAGERRTS	0xa4000020	/* VOYAGER Reset control */
-
-#define PA_R2D1_AXRST		0xa4000022	/* AX_LAN Reset control */
-#define PA_R2D1_CFRST		0xa4000024	/* CF Reset control */
-#define PA_R2D1_ADMRTS		0xa4000026	/* SD Reset control */
-#define PA_R2D1_EXTRST		0xa4000028	/* Extension Reset control */
-#define PA_R2D1_CFCDINTCLR	0xa400002a	/* CF Insert Interrupt clear */
-
-#define PA_R2DPLUS_CFRST	0xa4000022	/* CF Reset control */
-#define PA_R2DPLUS_ADMRTS	0xa4000024	/* SD Reset control */
-#define PA_R2DPLUS_EXTRST	0xa4000026	/* Extension Reset control */
-#define PA_R2DPLUS_CFCDINTCLR	0xa4000028	/* CF Insert Interrupt clear */
-#define PA_R2DPLUS_KEYCTLCLR	0xa400002a	/* Key Interrupt clear */
-
-#define PA_POWOFF	0xa4000030	/* Board Power OFF control */
-#define PA_VERREG	0xa4000032	/* FPGA Version Register */
-#define PA_INPORT	0xa4000034	/* KEY Input Port control */
-#define PA_OUTPORT	0xa4000036	/* LED control */
-#define PA_BVERREG	0xa4000038	/* Board Revision Register */
-
-#define PA_AX88796L	0xaa000400	/* AX88796L Area */
-#define PA_VOYAGER	0xab000000	/* VOYAGER GX Area */
-#define PA_IDE_OFFSET	0x1f0		/* CF IDE Offset */
-#define AX88796L_IO_BASE	0x1000	/* AX88796L IO Base Address */
-
-#define IRLCNTR1	(PA_BCR + 0)	/* Interrupt Control Register1 */
-
-#define R2D_FPGA_IRQ_BASE	100
-
-#define IRQ_VOYAGER		(R2D_FPGA_IRQ_BASE + 0)
-#define IRQ_EXT			(R2D_FPGA_IRQ_BASE + 1)
-#define IRQ_TP			(R2D_FPGA_IRQ_BASE + 2)
-#define IRQ_RTC_T		(R2D_FPGA_IRQ_BASE + 3)
-#define IRQ_RTC_A		(R2D_FPGA_IRQ_BASE + 4)
-#define IRQ_SDCARD		(R2D_FPGA_IRQ_BASE + 5)
-#define IRQ_CF_CD		(R2D_FPGA_IRQ_BASE + 6)
-#define IRQ_CF_IDE		(R2D_FPGA_IRQ_BASE + 7)
-#define IRQ_AX88796		(R2D_FPGA_IRQ_BASE + 8)
-#define IRQ_KEY			(R2D_FPGA_IRQ_BASE + 9)
-#define IRQ_PCI_INTA		(R2D_FPGA_IRQ_BASE + 10)
-#define IRQ_PCI_INTB		(R2D_FPGA_IRQ_BASE + 11)
-#define IRQ_PCI_INTC		(R2D_FPGA_IRQ_BASE + 12)
-#define IRQ_PCI_INTD		(R2D_FPGA_IRQ_BASE + 13)
-
-/* arch/sh/boards/renesas/rts7751r2d/irq.c */
-void init_rts7751r2d_IRQ(void);
-int rts7751r2d_irq_demux(int);
-
-#endif  /* __ASM_SH_RENESAS_RTS7751R2D */
diff --git a/arch/sh/include/mach-common/mach/romimage.h b/arch/sh/include/mach-common/mach/romimage.h
deleted file mode 100644
index 1915714263aab0..00000000000000
--- a/arch/sh/include/mach-common/mach/romimage.h
+++ /dev/null
@@ -1,12 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifdef __ASSEMBLY__
-
-/* do nothing here by default */
-
-#else /* __ASSEMBLY__ */
-
-static inline void mmcif_update_progress(int nr)
-{
-}
-
-#endif /* __ASSEMBLY__ */
diff --git a/arch/sh/include/mach-common/mach/sdk7780.h b/arch/sh/include/mach-common/mach/sdk7780.h
deleted file mode 100644
index a27dbe4184b35b..00000000000000
--- a/arch/sh/include/mach-common/mach/sdk7780.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_RENESAS_SDK7780_H
-#define __ASM_SH_RENESAS_SDK7780_H
-
-/*
- * linux/include/asm-sh/sdk7780.h
- *
- * Renesas Solutions SH7780 SDK Support
- * Copyright (C) 2008 Nicholas Beck <nbeck@mpc-data.co.uk>
- */
-#include <linux/sh_intc.h>
-#include <asm/addrspace.h>
-
-/* Box specific addresses.  */
-#define SE_AREA0_WIDTH	4		/* Area0: 32bit */
-#define PA_ROM			0xa0000000	/* EPROM */
-#define PA_ROM_SIZE		0x00400000	/* EPROM size 4M byte */
-#define PA_FROM			0xa0800000	/* Flash-ROM */
-#define PA_FROM_SIZE	0x00400000	/* Flash-ROM size 4M byte */
-#define PA_EXT1			0xa4000000
-#define PA_EXT1_SIZE	0x04000000
-#define PA_SDRAM		0xa8000000	/* DDR-SDRAM(Area2/3) 128MB */
-#define PA_SDRAM_SIZE	0x08000000
-
-#define PA_EXT4			0xb0000000
-#define PA_EXT4_SIZE	0x04000000
-#define PA_EXT_USER		PA_EXT4		/* User Expansion Space */
-
-#define PA_PERIPHERAL	PA_AREA5_IO
-
-/* SRAM/Reserved */
-#define PA_RESERVED	(PA_PERIPHERAL + 0)
-/* FPGA base address */
-#define PA_FPGA		(PA_PERIPHERAL + 0x01000000)
-/* SMC LAN91C111 */
-#define PA_LAN		(PA_PERIPHERAL + 0x01800000)
-
-
-#define FPGA_SRSTR      (PA_FPGA + 0x000)	/* System reset */
-#define FPGA_IRQ0SR     (PA_FPGA + 0x010)	/* IRQ0 status */
-#define FPGA_IRQ0MR     (PA_FPGA + 0x020)	/* IRQ0 mask */
-#define FPGA_BDMR       (PA_FPGA + 0x030)	/* Board operating mode */
-#define FPGA_INTT0PRTR  (PA_FPGA + 0x040)	/* Interrupt test mode0 port */
-#define FPGA_INTT0SELR  (PA_FPGA + 0x050)	/* Int. test mode0 select */
-#define FPGA_INTT1POLR  (PA_FPGA + 0x060)	/* Int. test mode0 polarity */
-#define FPGA_NMIR       (PA_FPGA + 0x070)	/* NMI source */
-#define FPGA_NMIMR      (PA_FPGA + 0x080)	/* NMI mask */
-#define FPGA_IRQR       (PA_FPGA + 0x090)	/* IRQX source */
-#define FPGA_IRQMR      (PA_FPGA + 0x0A0)	/* IRQX mask */
-#define FPGA_SLEDR      (PA_FPGA + 0x0B0)	/* LED control */
-#define PA_LED			FPGA_SLEDR
-#define FPGA_MAPSWR     (PA_FPGA + 0x0C0)	/* Map switch */
-#define FPGA_FPVERR     (PA_FPGA + 0x0D0)	/* FPGA version */
-#define FPGA_FPDATER    (PA_FPGA + 0x0E0)	/* FPGA date */
-#define FPGA_RSE        (PA_FPGA + 0x100)	/* Reset source */
-#define FPGA_EASR       (PA_FPGA + 0x110)	/* External area select */
-#define FPGA_SPER       (PA_FPGA + 0x120)	/* Serial port enable */
-#define FPGA_IMSR       (PA_FPGA + 0x130)	/* Interrupt mode select */
-#define FPGA_PCIMR      (PA_FPGA + 0x140)	/* PCI Mode */
-#define FPGA_DIPSWMR    (PA_FPGA + 0x150)	/* DIPSW monitor */
-#define FPGA_FPODR      (PA_FPGA + 0x160)	/* Output port data */
-#define FPGA_ATAESR     (PA_FPGA + 0x170)	/* ATA extended bus status */
-#define FPGA_IRQPOLR    (PA_FPGA + 0x180)	/* IRQx polarity */
-
-
-#define SDK7780_NR_IRL			15
-/* IDE/ATA interrupt */
-#define IRQ_CFCARD			evt2irq(0x3c0)
-/* SMC interrupt */
-#define IRQ_ETHERNET			evt2irq(0x2c0)
-
-
-/* arch/sh/boards/renesas/sdk7780/irq.c */
-void init_sdk7780_IRQ(void);
-
-#define __IO_PREFIX		sdk7780
-#include <asm/io_generic.h>
-
-#endif  /* __ASM_SH_RENESAS_SDK7780_H */
diff --git a/arch/sh/include/mach-common/mach/secureedge5410.h b/arch/sh/include/mach-common/mach/secureedge5410.h
deleted file mode 100644
index dfc68aa910033d..00000000000000
--- a/arch/sh/include/mach-common/mach/secureedge5410.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/snapgear.h
- *
- * Modified version of io_se.h for the snapgear-specific functions.
- *
- * IO functions for a SnapGear
- */
-
-#ifndef _ASM_SH_IO_SNAPGEAR_H
-#define _ASM_SH_IO_SNAPGEAR_H
-
-#define __IO_PREFIX	snapgear
-#include <asm/io_generic.h>
-
-/*
- * We need to remember what was written to the ioport as some bits
- * are shared with other functions and you cannot read back what was
- * written :-|
- *
- * Bit        Read                   Write
- * -----------------------------------------------
- * D0         DCD on ttySC1          power
- * D1         Reset Switch           heatbeat
- * D2         ttySC0 CTS (7100)      LAN
- * D3         -                      WAN
- * D4         ttySC0 DCD (7100)      CONSOLE
- * D5         -                      ONLINE
- * D6         -                      VPN
- * D7         -                      DTR on ttySC1
- * D8         -                      ttySC0 RTS (7100)
- * D9         -                      ttySC0 DTR (7100)
- * D10        -                      RTC SCLK
- * D11        RTC DATA               RTC DATA
- * D12        -                      RTS RESET
- */
-
-#define SECUREEDGE_IOPORT_ADDR ((volatile short *) 0xb0000000)
-extern unsigned short secureedge5410_ioport;
-
-#define SECUREEDGE_WRITE_IOPORT(val, mask) (*SECUREEDGE_IOPORT_ADDR = \
-	 (secureedge5410_ioport = \
-			((secureedge5410_ioport & ~(mask)) | ((val) & (mask)))))
-#define SECUREEDGE_READ_IOPORT() \
-	 ((*SECUREEDGE_IOPORT_ADDR&0x0817) | (secureedge5410_ioport&~0x0817))
-
-#endif /* _ASM_SH_IO_SNAPGEAR_H */
diff --git a/arch/sh/include/mach-common/mach/sh2007.h b/arch/sh/include/mach-common/mach/sh2007.h
deleted file mode 100644
index eeb12901a44a1b..00000000000000
--- a/arch/sh/include/mach-common/mach/sh2007.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __MACH_SH2007_H
-#define __MACH_SH2007_H
-
-#define CS5BCR		0xff802050
-#define CS5WCR		0xff802058
-#define CS5PCR		0xff802070
-
-#define BUS_SZ8		1
-#define BUS_SZ16	2
-#define BUS_SZ32	3
-
-#define PCMCIA_IODYN	1
-#define PCMCIA_ATA	0
-#define PCMCIA_IO8	2
-#define PCMCIA_IO16	3
-#define PCMCIA_COMM8	4
-#define PCMCIA_COMM16	5
-#define PCMCIA_ATTR8	6
-#define PCMCIA_ATTR16	7
-
-#define TYPE_SRAM	0
-#define TYPE_PCMCIA	4
-
-/* write-read/write-write delay (0-7:0,1,2,3,4,5,6,7) */
-#define IWW5		0
-#define IWW6		3
-/* different area, read-write delay (0-7:0,1,2,3,4,5,6,7) */
-#define IWRWD5		2
-#define IWRWD6		2
-/* same area, read-write delay (0-7:0,1,2,3,4,5,6,7) */
-#define IWRWS5		2
-#define IWRWS6		2
-/* different area, read-read delay (0-7:0,1,2,3,4,5,6,7) */
-#define IWRRD5		2
-#define IWRRD6		2
-/* same area, read-read delay (0-7:0,1,2,3,4,5,6,7) */
-#define IWRRS5		0
-#define IWRRS6		2
-/* burst count (0-3:4,8,16,32) */
-#define BST5		0
-#define BST6		0
-/* bus size */
-#define SZ5		BUS_SZ16
-#define SZ6		BUS_SZ16
-/* RD hold for SRAM (0-1:0,1) */
-#define RDSPL5		0
-#define RDSPL6		0
-/* Burst pitch (0-7:0,1,2,3,4,5,6,7) */
-#define BW5		0
-#define BW6		0
-/* Multiplex (0-1:0,1) */
-#define MPX5		0
-#define MPX6		0
-/* device type */
-#define TYPE5		TYPE_PCMCIA
-#define TYPE6		TYPE_PCMCIA
-/* address setup before assert CSn for SRAM (0-7:0,1,2,3,4,5,6,7) */
-#define ADS5		0
-#define ADS6		0
-/* address hold after negate CSn for SRAM (0-7:0,1,2,3,4,5,6,7) */
-#define ADH5		0
-#define ADH6		0
-/* CSn assert to RD assert delay for SRAM (0-7:0,1,2,3,4,5,6,7) */
-#define RDS5		0
-#define RDS6		0
-/* RD negate to CSn negate delay for SRAM (0-7:0,1,2,3,4,5,6,7) */
-#define RDH5		0
-#define RDH6		0
-/* CSn assert to WE assert delay for SRAM (0-7:0,1,2,3,4,5,6,7) */
-#define WTS5		0
-#define WTS6		0
-/* WE negate to CSn negate delay for SRAM (0-7:0,1,2,3,4,5,6,7) */
-#define WTH5		0
-#define WTH6		0
-/* BS hold (0-1:1,2) */
-#define BSH5		0
-#define BSH6		0
-/* wait cycle (0-15:0,1,2,3,4,5,6,7,8,9,11,13,15,17,21,25) */
-#define IW5		6	/* 60ns PIO mode 4 */
-#define IW6		15	/* 250ns */
-
-#define SAA5		PCMCIA_IODYN	/* IDE area b4000000-b5ffffff */
-#define SAB5		PCMCIA_IODYN	/* CF  area b6000000-b7ffffff */
-#define PCWA5		0	/* additional wait A (0-3:0,15,30,50) */
-#define PCWB5		0	/* additional wait B (0-3:0,15,30,50) */
-/* wait B (0-15:0,1,2,3,4,5,6,7,8,9,11,13,15,17,21,25) */
-#define PCIW5		12
-/* Address->OE/WE assert delay A (0-7:0,1,2,3,6,9,12,15) */
-#define TEDA5		2
-/* Address->OE/WE assert delay B (0-7:0,1,2,3,6,9,12,15) */
-#define TEDB5		4
-/* OE/WE negate->Address delay A (0-7:0,1,2,3,6,9,12,15) */
-#define TEHA5		2
-/* OE/WE negate->Address delay B (0-7:0,1,2,3,6,9,12,15) */
-#define TEHB5		3
-
-#define CS5BCR_D	((IWW5<<28)|(IWRWD5<<24)|(IWRWS5<<20)|		\
-			(IWRRD5<<16)|(IWRRS5<<12)|(BST5<<10)|		\
-			(SZ5<<8)|(RDSPL5<<7)|(BW5<<4)|(MPX5<<3)|TYPE5)
-#define CS5WCR_D	((ADS5<<28)|(ADH5<<24)|(RDS5<<20)|	\
-			(RDH5<<16)|(WTS5<<12)|(WTH5<<8)|(BSH5<<4)|IW5)
-#define CS5PCR_D	((SAA5<<28)|(SAB5<<24)|(PCWA5<<22)|		\
-			(PCWB5<<20)|(PCIW5<<16)|(TEDA5<<12)|		\
-			(TEDB5<<8)|(TEHA5<<4)|TEHB5)
-
-#define SMC0_BASE       0xb0800000      /* eth0 */
-#define SMC1_BASE       0xb0900000      /* eth1 */
-#define CF_BASE         0xb6100000      /* Compact Flash (I/O area) */
-#define IDE_BASE        0xb4000000      /* IDE */
-#define PC104_IO_BASE   0xb8000000
-#define PC104_MEM_BASE  0xba000000
-#define SMC_IO_SIZE     0x100
-
-#define CF_OFFSET       0x1f0
-#define IDE_OFFSET      0x170
-
-#endif /* __MACH_SH2007_H */
diff --git a/arch/sh/include/mach-common/mach/sh7763rdp.h b/arch/sh/include/mach-common/mach/sh7763rdp.h
deleted file mode 100644
index 301f85a1c044d2..00000000000000
--- a/arch/sh/include/mach-common/mach/sh7763rdp.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_SH7763RDP_H
-#define __ASM_SH_SH7763RDP_H
-
-/*
- * linux/include/asm-sh/sh7763drp.h
- *
- * Copyright (C) 2008 Renesas Solutions
- * Copyright (C) 2008 Nobuhiro Iwamatsu <iwamatsu.nobuhiro@renesas.com>
- */
-#include <asm/addrspace.h>
-
-/* clock control */
-#define MSTPCR1 0xFFC80038
-
-/* PORT */
-#define PORT_PSEL0	0xFFEF0070
-#define PORT_PSEL1	0xFFEF0072
-#define PORT_PSEL2	0xFFEF0074
-#define PORT_PSEL3	0xFFEF0076
-#define PORT_PSEL4	0xFFEF0078
-
-#define PORT_PACR	0xFFEF0000
-#define PORT_PCCR	0xFFEF0004
-#define PORT_PFCR	0xFFEF000A
-#define PORT_PGCR	0xFFEF000C
-#define PORT_PHCR	0xFFEF000E
-#define PORT_PICR	0xFFEF0010
-#define PORT_PJCR	0xFFEF0012
-#define PORT_PKCR	0xFFEF0014
-#define PORT_PLCR	0xFFEF0016
-#define PORT_PMCR	0xFFEF0018
-#define PORT_PNCR	0xFFEF001A
-
-/* FPGA */
-#define CPLD_BOARD_ID_ERV_REG	0xB1000000
-#define CPLD_CPLD_CMD_REG		0xB1000006
-
-/*
- * USB SH7763RDP board can use Host only.
- */
-#define USB_USBHSC	0xFFEC80f0
-
-/* arch/sh/boards/renesas/sh7763rdp/irq.c */
-void init_sh7763rdp_IRQ(void);
-int sh7763rdp_irq_demux(int irq);
-#define __IO_PREFIX	sh7763rdp
-#include <asm/io_generic.h>
-
-#endif /* __ASM_SH_SH7763RDP_H */
diff --git a/arch/sh/include/mach-common/mach/sh7785lcr.h b/arch/sh/include/mach-common/mach/sh7785lcr.h
deleted file mode 100644
index 0f3dc3a1329e36..00000000000000
--- a/arch/sh/include/mach-common/mach/sh7785lcr.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_RENESAS_SH7785LCR_H
-#define __ASM_SH_RENESAS_SH7785LCR_H
-
-/*
- * This board has 2 physical memory maps.
- * It can be changed with DIP switch(S2-5).
- *
- * phys address			| S2-5 = OFF	| S2-5 = ON
- * -----------------------------+---------------+---------------
- * 0x00000000 - 0x03ffffff(CS0)	| NOR Flash	| NOR Flash
- * 0x04000000 - 0x05ffffff(CS1)	| PLD		| PLD
- * 0x06000000 - 0x07ffffff(CS1)	| I2C		| I2C
- * 0x08000000 - 0x0bffffff(CS2)	| USB		| DDR SDRAM
- * 0x0c000000 - 0x0fffffff(CS3)	| SD		| DDR SDRAM
- * 0x10000000 - 0x13ffffff(CS4)	| SM107		| SM107
- * 0x14000000 - 0x17ffffff(CS5)	| reserved	| USB
- * 0x18000000 - 0x1bffffff(CS6)	| reserved	| SD
- * 0x40000000 - 0x5fffffff	| DDR SDRAM	| (cannot use)
- *
- */
-
-#define NOR_FLASH_ADDR		0x00000000
-#define NOR_FLASH_SIZE		0x04000000
-
-#define PLD_BASE_ADDR		0x04000000
-#define PLD_PCICR		(PLD_BASE_ADDR + 0x00)
-#define PLD_LCD_BK_CONTR	(PLD_BASE_ADDR + 0x02)
-#define PLD_LOCALCR		(PLD_BASE_ADDR + 0x04)
-#define PLD_POFCR		(PLD_BASE_ADDR + 0x06)
-#define PLD_LEDCR		(PLD_BASE_ADDR + 0x08)
-#define PLD_SWSR		(PLD_BASE_ADDR + 0x0a)
-#define PLD_VERSR		(PLD_BASE_ADDR + 0x0c)
-#define PLD_MMSR		(PLD_BASE_ADDR + 0x0e)
-
-#define PCA9564_ADDR		0x06000000	/* I2C */
-#define PCA9564_SIZE		0x00000100
-
-#define PCA9564_PROTO_32BIT_ADDR	0x14000000
-
-#define SM107_MEM_ADDR		0x10000000
-#define SM107_MEM_SIZE		0x00e00000
-#define SM107_REG_ADDR		0x13e00000
-#define SM107_REG_SIZE		0x00200000
-
-#if defined(CONFIG_SH_SH7785LCR_29BIT_PHYSMAPS)
-#define R8A66597_ADDR		0x14000000	/* USB */
-#define CG200_ADDR		0x18000000	/* SD */
-#else
-#define R8A66597_ADDR		0x08000000
-#define CG200_ADDR		0x0c000000
-#endif
-
-#define R8A66597_SIZE		0x00000100
-#define CG200_SIZE		0x00010000
-
-#endif  /* __ASM_SH_RENESAS_SH7785LCR_H */
-
diff --git a/arch/sh/include/mach-common/mach/shmin.h b/arch/sh/include/mach-common/mach/shmin.h
deleted file mode 100644
index c2c3e26d145312..00000000000000
--- a/arch/sh/include/mach-common/mach/shmin.h
+++ /dev/null
@@ -1,10 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_SHMIN_H
-#define __ASM_SH_SHMIN_H
-
-#define SHMIN_IO_BASE 0xb0000000UL
-
-#define SHMIN_NE_IRQ IRQ2_IRQ
-#define SHMIN_NE_BASE 0x300
-
-#endif
diff --git a/arch/sh/include/mach-common/mach/titan.h b/arch/sh/include/mach-common/mach/titan.h
deleted file mode 100644
index 54df351de5e40d..00000000000000
--- a/arch/sh/include/mach-common/mach/titan.h
+++ /dev/null
@@ -1,20 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Platform definitions for Titan
- */
-#ifndef _ASM_SH_TITAN_H
-#define _ASM_SH_TITAN_H
-
-#include <linux/sh_intc.h>
-
-#define __IO_PREFIX titan
-#include <asm/io_generic.h>
-
-/* IRQ assignments */
-#define TITAN_IRQ_WAN		evt2irq(0x240)	/* eth0 (WAN) */
-#define TITAN_IRQ_LAN		evt2irq(0x2a0)	/* eth1 (LAN) */
-#define TITAN_IRQ_MPCIA		evt2irq(0x300)	/* mPCI A */
-#define TITAN_IRQ_MPCIB		evt2irq(0x360)	/* mPCI B */
-#define TITAN_IRQ_USB		evt2irq(0x360)	/* USB */
-
-#endif /* __ASM_SH_TITAN_H */
diff --git a/arch/sh/include/mach-common/mach/urquell.h b/arch/sh/include/mach-common/mach/urquell.h
deleted file mode 100644
index 6c9bff3f93f143..00000000000000
--- a/arch/sh/include/mach-common/mach/urquell.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __MACH_URQUELL_H
-#define __MACH_URQUELL_H
-
-/*
- * ------ 0x00000000 ------------------------------------
- *  CS0 | (SW1,SW47)    EEPROM, SRAM, NOR FLASH
- * -----+ 0x04000000 ------------------------------------
- *  CS1 | (SW47)        SRAM, SRAM-LAN-PCMCIA, NOR FLASH
- * -----+ 0x08000000 ------------------------------------
- *  CS2 |               DDR3
- *  CS3 |
- * -----+ 0x10000000 ------------------------------------
- *  CS4 |               PCIe
- * -----+ 0x14000000 ------------------------------------
- *  CS5 | (SW47)        LRAM/URAM, SRAM-LAN-PCMCIA
- * -----+ 0x18000000 ------------------------------------
- *  CS6 |               ATA, NAND FLASH
- * -----+ 0x1c000000 ------------------------------------
- *  CS7 |               SH7786 register
- * -----+------------------------------------------------
- */
-
-#define NOR_FLASH_ADDR	0x00000000
-#define NOR_FLASH_SIZE	0x04000000
-
-#define CS1_BASE	0x05000000
-#define CS5_BASE	0x15000000
-#define FPGA_BASE	CS1_BASE
-
-#define BOARDREG(ofs)	(FPGA_BASE + ofs##_OFS)
-#define UBOARDREG(ofs)	(0xa0000000 + FPGA_BASE + ofs##_OFS)
-
-#define SRSTR_OFS	0x0000 /* System reset register */
-#define BDMR_OFS	0x0010 /* Board operating mode resister */
-#define IRL0SR_OFS	0x0020 /* IRL0 Status register */
-#define IRL0MSKR_OFS	0x0030 /* IRL0 Mask register */
-#define IRL1SR_OFS	0x0040 /* IRL1 Status register */
-#define IRL1MSKR_OFS	0x0050 /* IRL1 Mask register */
-#define IRL2SR_OFS	0x0060 /* IRL2 Status register */
-#define IRL2MSKR_OFS	0x0070 /* IRL2 Mask register */
-#define IRL3SR_OFS	0x0080 /* IRL3 Status register */
-#define IRL3MSKR_OFS	0x0090 /* IRL3 Mask register */
-#define SOFTINTR_OFS	0x0120 /* Softwear Interrupt register */
-#define SLEDR_OFS	0x0130 /* LED control resister */
-#define MAPSCIFSWR_OFS	0x0140 /* Map/SCIF Switch register */
-#define FPVERR_OFS	0x0150 /* FPGA Version register */
-#define FPDATER_OFS	0x0160 /* FPGA Date register */
-#define FPYEARR_OFS	0x0170 /* FPGA Year register */
-#define TCLKCR_OFS	0x0180 /* TCLK Control register */
-#define DIPSWMR_OFS	0x1000 /* DIPSW monitor register */
-#define FPODR_OFS	0x1010 /* Output port data register */
-#define ATACNR_OFS	0x1020 /* ATA-CN Control/status register */
-#define FPINDR_OFS	0x1030 /* Input port data register */
-#define MDSWMR_OFS	0x1040 /* MODE SW monitor register */
-#define DDR3BUPCR_OFS	0x1050 /* DDR3 Backup control register */
-#define SSICODECCR_OFS	0x1060 /* SSI-CODEC control register */
-#define PCIESLOTSR_OFS	0x1070 /* PCIexpress Slot status register */
-#define ETHERPORTSR_OFS	0x1080 /* EtherPhy Port status register */
-#define LATCHCR_OFS	0x3000 /* Latch control register */
-#define LATCUAR_OFS	0x3010 /* Latch upper address register */
-#define LATCLAR_OFS	0x3012 /* Latch lower address register */
-#define LATCLUDR_OFS	0x3024 /* Latch D31-16 register */
-#define LATCLLDR_OFS	0x3026 /* Latch D15-0 register */
-
-#define CHARLED_OFS	0x2000 /* Character LED */
-
-#endif  /* __MACH_URQUELL_H */
-
diff --git a/arch/sh/include/mach-dreamcast/mach/dma.h b/arch/sh/include/mach-dreamcast/mach/dma.h
deleted file mode 100644
index a773a763843aaa..00000000000000
--- a/arch/sh/include/mach-dreamcast/mach/dma.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/dreamcast/dma.h
- *
- * Copyright (C) 2003 Paul Mundt
- */
-#ifndef __ASM_SH_DREAMCAST_DMA_H
-#define __ASM_SH_DREAMCAST_DMA_H
-
-/* Number of DMA channels */
-#define G2_NR_DMA_CHANNELS	4
-
-/* Channels for cascading */
-#define PVR2_CASCADE_CHAN	2
-#define G2_CASCADE_CHAN		3
-
-/* PVR2 DMA Registers */
-#define PVR2_DMA_BASE		0xa05f6800
-#define PVR2_DMA_ADDR		(PVR2_DMA_BASE + 0)
-#define PVR2_DMA_COUNT		(PVR2_DMA_BASE + 4)
-#define PVR2_DMA_MODE		(PVR2_DMA_BASE + 8)
-#define PVR2_DMA_LMMODE0	(PVR2_DMA_BASE + 132)
-#define PVR2_DMA_LMMODE1	(PVR2_DMA_BASE + 136)
-
-/* G2 DMA Register */
-#define G2_DMA_BASE		0xa05f7800
-
-#endif /* __ASM_SH_DREAMCAST_DMA_H */
-
diff --git a/arch/sh/include/mach-dreamcast/mach/maple.h b/arch/sh/include/mach-dreamcast/mach/maple.h
deleted file mode 100644
index 169bdf415d89aa..00000000000000
--- a/arch/sh/include/mach-dreamcast/mach/maple.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_MAPLE_H
-#define __ASM_MAPLE_H
-
-#define MAPLE_PORTS 4
-#define MAPLE_PNP_INTERVAL HZ
-#define MAPLE_MAXPACKETS 8
-#define MAPLE_DMA_ORDER 14
-#define MAPLE_DMA_SIZE (1 << MAPLE_DMA_ORDER)
-#define MAPLE_DMA_PAGES ((MAPLE_DMA_ORDER > PAGE_SHIFT) ? \
-			  MAPLE_DMA_ORDER - PAGE_SHIFT : 0)
-
-/* Maple Bus registers */
-#define MAPLE_BASE     0xa05f6c00
-#define MAPLE_DMAADDR  (MAPLE_BASE+0x04)
-#define MAPLE_TRIGTYPE (MAPLE_BASE+0x10)
-#define MAPLE_ENABLE   (MAPLE_BASE+0x14)
-#define MAPLE_STATE    (MAPLE_BASE+0x18)
-#define MAPLE_SPEED    (MAPLE_BASE+0x80)
-#define MAPLE_RESET    (MAPLE_BASE+0x8c)
-
-#define MAPLE_MAGIC    0x6155404f
-#define MAPLE_2MBPS    0
-#define MAPLE_TIMEOUT(n) ((n)<<15)
-
-/* Function codes */
-#define MAPLE_FUNC_CONTROLLER 0x001
-#define MAPLE_FUNC_MEMCARD    0x002
-#define MAPLE_FUNC_LCD        0x004
-#define MAPLE_FUNC_CLOCK      0x008
-#define MAPLE_FUNC_MICROPHONE 0x010
-#define MAPLE_FUNC_ARGUN      0x020
-#define MAPLE_FUNC_KEYBOARD   0x040
-#define MAPLE_FUNC_LIGHTGUN   0x080
-#define MAPLE_FUNC_PURUPURU   0x100
-#define MAPLE_FUNC_MOUSE      0x200
-
-#endif /* __ASM_MAPLE_H */
diff --git a/arch/sh/include/mach-dreamcast/mach/pci.h b/arch/sh/include/mach-dreamcast/mach/pci.h
deleted file mode 100644
index c037c1ec63a928..00000000000000
--- a/arch/sh/include/mach-dreamcast/mach/pci.h
+++ /dev/null
@@ -1,24 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/dreamcast/pci.h
- *
- * Copyright (C) 2001, 2002  M. R. Brown
- * Copyright (C) 2002, 2003  Paul Mundt
- */
-#ifndef __ASM_SH_DREAMCAST_PCI_H
-#define __ASM_SH_DREAMCAST_PCI_H
-
-#include <mach-dreamcast/mach/sysasic.h>
-
-#define	GAPSPCI_REGS		0x01001400
-#define GAPSPCI_DMA_BASE	0x01840000
-#define GAPSPCI_DMA_SIZE	32768
-#define GAPSPCI_BBA_CONFIG	0x01001600
-#define GAPSPCI_BBA_CONFIG_SIZE	0x2000
-
-#define	GAPSPCI_IRQ		HW_EVENT_EXTERNAL
-
-extern struct pci_ops gapspci_pci_ops;
-
-#endif /* __ASM_SH_DREAMCAST_PCI_H */
-
diff --git a/arch/sh/include/mach-dreamcast/mach/sysasic.h b/arch/sh/include/mach-dreamcast/mach/sysasic.h
deleted file mode 100644
index ed69ce7f203012..00000000000000
--- a/arch/sh/include/mach-dreamcast/mach/sysasic.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * include/asm-sh/dreamcast/sysasic.h
- *
- * Definitions for the Dreamcast System ASIC and related peripherals.
- *
- * Copyright (c) 2001 M. R. Brown <mrbrown@linuxdc.org>
- * Copyright (C) 2003 Paul Mundt <lethal@linux-sh.org>
- *
- * This file is part of the LinuxDC project (www.linuxdc.org)
- */
-#ifndef __ASM_SH_DREAMCAST_SYSASIC_H
-#define __ASM_SH_DREAMCAST_SYSASIC_H
-
-#include <asm/irq.h>
-
-/* Hardware events -
-
-   Each of these events correspond to a bit within the Event Mask Registers/
-   Event Status Registers.  Because of the virtual IRQ numbering scheme, a
-   base offset must be used when calculating the virtual IRQ that each event
-   takes.
-*/
-
-#define HW_EVENT_IRQ_BASE  48
-
-/* IRQ 13 */
-#define HW_EVENT_VSYNC     (HW_EVENT_IRQ_BASE +  5) /* VSync */
-#define HW_EVENT_MAPLE_DMA (HW_EVENT_IRQ_BASE + 12) /* Maple DMA complete */
-#define HW_EVENT_GDROM_DMA (HW_EVENT_IRQ_BASE + 14) /* GD-ROM DMA complete */
-#define HW_EVENT_G2_DMA    (HW_EVENT_IRQ_BASE + 15) /* G2 DMA complete */
-#define HW_EVENT_PVR2_DMA  (HW_EVENT_IRQ_BASE + 19) /* PVR2 DMA complete */
-
-/* IRQ 11 */
-#define HW_EVENT_GDROM_CMD (HW_EVENT_IRQ_BASE + 32) /* GD-ROM cmd. complete */
-#define HW_EVENT_AICA_SYS  (HW_EVENT_IRQ_BASE + 33) /* AICA-related */
-#define HW_EVENT_EXTERNAL  (HW_EVENT_IRQ_BASE + 35) /* Ext. (expansion) */
-
-#define HW_EVENT_IRQ_MAX (HW_EVENT_IRQ_BASE + 95)
-
-/* arch/sh/boards/mach-dreamcast/irq.c */
-extern int systemasic_irq_demux(int);
-extern void systemasic_irq_init(void);
-
-#endif /* __ASM_SH_DREAMCAST_SYSASIC_H */
-
diff --git a/arch/sh/include/mach-ecovec24/mach/partner-jet-setup.txt b/arch/sh/include/mach-ecovec24/mach/partner-jet-setup.txt
deleted file mode 100644
index 2d685cc2d54ced..00000000000000
--- a/arch/sh/include/mach-ecovec24/mach/partner-jet-setup.txt
+++ /dev/null
@@ -1,82 +0,0 @@
-LIST "SPDX-License-Identifier: GPL-2.0"
-LIST "partner-jet-setup.txt"
-LIST "(C) Copyright 2009 Renesas Solutions Corp"
-LIST "Kuninori Morimoto <morimoto.kuninori@renesas.com>"
-LIST "--------------------------------"
-LIST "zImage (RAM boot)"
-LIST "This script can be used to boot the kernel from RAM via JTAG:"
-LIST "> < partner-jet-setup.txt"
-LIST "> RD zImage, 0xa8800000"
-LIST "> G=0xa8800000"
-LIST "--------------------------------"
-LIST "romImage (Flash boot)"
-LIST "Use the following command to burn the zImage to flash via JTAG:"
-LIST "> RD romImage, 0"
-LIST "--------------------------------"
-
-LIST "disable watchdog"
-EW 0xa4520004, 0xa507
-
-LIST "MMU"
-ED 0xff000010, 0x00000004
-
-LIST "setup clocks"
-ED 0xa4150024, 0x00004000
-ED 0xa4150000, 0x8E003508
-
-WAIT 1
-
-LIST "BSC"
-ED 0xff800020, 0xa5a50000
-ED 0xfec10000, 0x00001013
-ED 0xfec10004, 0x11110400
-ED 0xfec10024, 0x00000440
-
-WAIT 1
-
-LIST "setup sdram"
-ED 0xfd000108, 0x00000181
-ED 0xfd000020, 0x015B0002
-ED 0xfd000030, 0x03061502
-ED 0xfd000034, 0x02020102
-ED 0xfd000038, 0x01090305
-ED 0xfd00003c, 0x00000002
-ED 0xfd000008, 0x00000005
-ED 0xfd000018, 0x00000001
-
-WAIT 1
-
-ED 0xfd000014, 0x00000002
-ED 0xfd000060, 0x00020000
-ED 0xfd000060, 0x00030000
-ED 0xfd000060, 0x00010040
-ED 0xfd000060, 0x00000532
-ED 0xfd000014, 0x00000002
-ED 0xfd000014, 0x00000004
-ED 0xfd000014, 0x00000004
-ED 0xfd000060, 0x00000432
-ED 0xfd000060, 0x000103C0
-ED 0xfd000060, 0x00010040
-
-WAIT 1
-
-ED 0xfd000010, 0x00000001
-ED 0xfd000044, 0x00000613
-ED 0xfd000048, 0x238C003A
-ED 0xfd000014, 0x00000002
-
-LIST "Dummy read"
-DD 0x0c400000, 0x0c400000
-
-ED 0xfd000014, 0x00000002
-ED 0xfd000014, 0x00000004
-ED 0xfd000108, 0x00000080
-ED 0xfd000040, 0x00010000
-
-WAIT 1
-
-LIST "setup cache"
-ED 0xff00001c, 0x0000090b
-
-LIST "disable USB"
-EW 0xA4D80000, 0x0000
diff --git a/arch/sh/include/mach-ecovec24/mach/romimage.h b/arch/sh/include/mach-ecovec24/mach/romimage.h
deleted file mode 100644
index 2da6ff326cbd0a..00000000000000
--- a/arch/sh/include/mach-ecovec24/mach/romimage.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifdef __ASSEMBLY__
-
-/* EcoVec board specific boot code:
- * converts the "partner-jet-script.txt" script into assembly
- * the assembly code is the first code to be executed in the romImage
- */
-
-#include <asm/romimage-macros.h>
-#include <mach/partner-jet-setup.txt>
-
-	/* execute icbi after enabling cache */
-	mov.l	1f, r0
-	icbi	@r0
-
-	/* jump to cached area */
-	mova	2f, r0
-	jmp	@r0
-	nop
-
-	.align 2
-1 :	.long 0xa8000000
-2 :
-
-#else /* __ASSEMBLY__ */
-
-/* Ecovec board specific information:
- *
- * Set the following to enable MMCIF boot from the MMC card in CN12:
- *
- * DS1.5 = OFF (SH BOOT pin set to L)
- * DS2.6 = OFF (Select MMCIF on CN12 instead of SDHI1)
- * DS2.7 = ON  (Select MMCIF on CN12 instead of SDHI1)
- *
- */
-#define HIZCRA		0xa4050158
-#define PGDR		0xa405012c
-
-static inline void mmcif_update_progress(int nr)
-{
-	/* disable Hi-Z for LED pins */
-	__raw_writew(__raw_readw(HIZCRA) & ~(1 << 1), HIZCRA);
-
-	/* update progress on LED4, LED5, LED6 and LED7 */
-	__raw_writeb(1 << (nr - 1), PGDR);
-}
-
-#endif /* __ASSEMBLY__ */
diff --git a/arch/sh/include/mach-kfr2r09/mach/kfr2r09.h b/arch/sh/include/mach-kfr2r09/mach/kfr2r09.h
deleted file mode 100644
index 0e97473afe0bb9..00000000000000
--- a/arch/sh/include/mach-kfr2r09/mach/kfr2r09.h
+++ /dev/null
@@ -1,24 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_KFR2R09_H
-#define __ASM_SH_KFR2R09_H
-
-#include <video/sh_mobile_lcdc.h>
-
-#if defined(CONFIG_FB_SH_MOBILE_LCDC) || defined(CONFIG_FB_SH_MOBILE_LCDC_MODULE)
-int kfr2r09_lcd_setup(void *sys_ops_handle,
-		      struct sh_mobile_lcdc_sys_bus_ops *sys_ops);
-void kfr2r09_lcd_start(void *sys_ops_handle,
-		       struct sh_mobile_lcdc_sys_bus_ops *sys_ops);
-#else
-static int kfr2r09_lcd_setup(void *sys_ops_handle,
-				struct sh_mobile_lcdc_sys_bus_ops *sys_ops)
-{
-	return -ENODEV;
-}
-static void kfr2r09_lcd_start(void *sys_ops_handle,
-				struct sh_mobile_lcdc_sys_bus_ops *sys_ops)
-{
-}
-#endif
-
-#endif /* __ASM_SH_KFR2R09_H */
diff --git a/arch/sh/include/mach-kfr2r09/mach/partner-jet-setup.txt b/arch/sh/include/mach-kfr2r09/mach/partner-jet-setup.txt
deleted file mode 100644
index a67b1926be222e..00000000000000
--- a/arch/sh/include/mach-kfr2r09/mach/partner-jet-setup.txt
+++ /dev/null
@@ -1,144 +0,0 @@
-LIST "SPDX-License-Identifier: GPL-2.0"
-LIST "partner-jet-setup.txt - 20090729 Magnus Damm"
-LIST "set up enough of the kfr2r09 hardware to boot the kernel"
-
-LIST "zImage (RAM boot)"
-LIST "This script can be used to boot the kernel from RAM via JTAG:"
-LIST "> < partner-jet-setup.txt"
-LIST "> RD zImage, 0xa8800000"
-LIST "> G=0xa8800000"
-
-LIST "romImage (Flash boot)"
-LIST "Use the following command to burn the zImage to flash via JTAG:"
-LIST "> RD romImage, 0"
-
-LIST "--------------------------------"
-
-LIST "disable watchdog"
-EW 0xa4520004, 0xa507
-
-LIST "invalidate instruction cache"
-ED 0xff00001c, 0x00000800
-
-LIST "invalidate TLBs"
-ED 0xff000010, 0x00000004
-
-LIST "select mode for cs5 + cs6"
-ED 0xff800020, 0xa5a50001
-ED 0xfec10000, 0x0000001b
-
-LIST "setup clocks"
-LIST "The PLL and FLL values are updated here for the optimal"
-LIST "RF frequency and improved reception sensitivity."
-ED 0xa4150004, 0x00000050
-ED 0xa4150000, 0x91053508
-WAIT 1
-ED 0xa4150050, 0x00000340
-ED 0xa4150024, 0x00005000
-
-LIST "setup pins"
-EB 0xa4050120, 0x00
-EB 0xa4050122, 0x00
-EB 0xa4050124, 0x00
-EB 0xa4050126, 0x00
-EB 0xa4050128, 0xA0
-EB 0xa405012A, 0x10
-EB 0xa405012C, 0x00
-EB 0xa405012E, 0x00
-EB 0xa4050130, 0x00
-EB 0xa4050132, 0x00
-EB 0xa4050134, 0x01
-EB 0xa4050136, 0x40
-EB 0xa4050138, 0x00
-EB 0xa405013A, 0x00
-EB 0xa405013C, 0x00
-EB 0xa405013E, 0x20
-EB 0xa4050160, 0x00
-EB 0xa4050162, 0x40
-EB 0xa4050164, 0x03
-EB 0xa4050166, 0x00
-EB 0xa4050168, 0x00
-EB 0xa405016A, 0x00
-EB 0xa405016C, 0x00
-
-EW 0xa405014E, 0x5660
-EW 0xa4050150, 0x0145
-EW 0xa4050152, 0x1550
-EW 0xa4050154, 0x0200
-EW 0xa4050156, 0x0040
-
-EW 0xa4050158, 0x0000
-EW 0xa405015a, 0x0000
-EW 0xa405015c, 0x0000
-EW 0xa405015e, 0x0000
-
-EW 0xa4050180, 0x0000
-EW 0xa4050182, 0x8002
-EW 0xa4050184, 0x0000
-
-EW 0xa405018a, 0x9991
-EW 0xa405018c, 0x8011
-EW 0xa405018e, 0x9550
-
-EW 0xa4050100, 0x0000
-EW 0xa4050102, 0x5540
-EW 0xa4050104, 0x0000
-EW 0xa4050106, 0x0000
-EW 0xa4050108, 0x4550
-EW 0xa405010a, 0x0130
-EW 0xa405010c, 0x0555
-EW 0xa405010e, 0x0000
-EW 0xa4050110, 0x0000
-EW 0xa4050112, 0xAAA8
-EW 0xa4050114, 0x8305
-EW 0xa4050116, 0x10F0
-EW 0xa4050118, 0x0F50
-EW 0xa405011a, 0x0000
-EW 0xa405011c, 0x0000
-EW 0xa405011e, 0x0555
-EW 0xa4050140, 0x0000
-EW 0xa4050142, 0x5141
-EW 0xa4050144, 0x5005
-EW 0xa4050146, 0xAAA9
-EW 0xa4050148, 0xFAA9
-EW 0xa405014a, 0x3000
-EW 0xa405014c, 0x0000
-
-LIST "setup sdram"
-ED 0xFD000108, 0x40000301
-ED 0xFD000020, 0x011B0002
-ED 0xFD000030, 0x03060E02
-ED 0xFD000034, 0x01020102
-ED 0xFD000038, 0x01090406
-ED 0xFD000008, 0x00000004
-ED 0xFD000040, 0x00000001
-ED 0xFD000040, 0x00000000
-ED 0xFD000018, 0x00000001
-
-WAIT 1
-
-ED 0xFD000014, 0x00000002
-ED 0xFD000060, 0x00000032
-ED 0xFD000060, 0x00020000
-ED 0xFD000014, 0x00000004
-ED 0xFD000014, 0x00000004
-ED 0xFD000010, 0x00000001
-ED 0xFD000044, 0x000004AF
-ED 0xFD000048, 0x20CF0037
-
-LIST "read 16 bytes from sdram"
-DD 0xa8000000, 0xa8000000, 1
-DD 0xa8000004, 0xa8000004, 1
-DD 0xa8000008, 0xa8000008, 1
-DD 0xa800000c, 0xa800000c, 1
-
-ED 0xFD000014, 0x00000002
-ED 0xFD000014, 0x00000004
-ED 0xFD000108, 0x40000300
-ED 0xFD000040, 0x00010000
-
-LIST "write to internal ram"
-ED 0xfd8007fc, 0
-
-LIST "setup cache"
-ED 0xff00001c, 0x0000090b
diff --git a/arch/sh/include/mach-kfr2r09/mach/romimage.h b/arch/sh/include/mach-kfr2r09/mach/romimage.h
deleted file mode 100644
index 209275872ff06e..00000000000000
--- a/arch/sh/include/mach-kfr2r09/mach/romimage.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifdef __ASSEMBLY__
-
-/* kfr2r09 board specific boot code:
- * converts the "partner-jet-script.txt" script into assembly
- * the assembly code is the first code to be executed in the romImage
- */
-
-#include <asm/romimage-macros.h>
-#include <mach/partner-jet-setup.txt>
-
-	/* execute icbi after enabling cache */
-	mov.l	1f, r0
-	icbi	@r0
-
-	/* jump to cached area */
-	mova	2f, r0
-	jmp	@r0
-	 nop
-
-	.align 2
-1:	.long 0xa8000000
-2:
-
-#else /* __ASSEMBLY__ */
-
-static inline void mmcif_update_progress(int nr)
-{
-}
-
-#endif /* __ASSEMBLY__ */
diff --git a/arch/sh/include/mach-landisk/mach/gio.h b/arch/sh/include/mach-landisk/mach/gio.h
deleted file mode 100644
index b954de617b4970..00000000000000
--- a/arch/sh/include/mach-landisk/mach/gio.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_LANDISK_GIO_H
-#define __ASM_SH_LANDISK_GIO_H
-
-#include <linux/ioctl.h>
-
-/* version */
-#define VERSION_STR	"1.00"
-
-/* Driver name */
-#define GIO_DRIVER_NAME		"/dev/giodrv"
-
-/* Use 'k' as magic number */
-#define GIODRV_IOC_MAGIC  'k'
-
-#define GIODRV_IOCRESET    _IO(GIODRV_IOC_MAGIC, 0)
-/*
- * S means "Set" through a ptr,
- * T means "Tell" directly
- * G means "Get" (to a pointed var)
- * Q means "Query", response is on the return value
- * X means "eXchange": G and S atomically
- * H means "sHift": T and Q atomically
- */
-#define GIODRV_IOCSGIODATA1   _IOW(GIODRV_IOC_MAGIC,  1, unsigned char *)
-#define GIODRV_IOCGGIODATA1   _IOR(GIODRV_IOC_MAGIC,  2, unsigned char *)
-#define GIODRV_IOCSGIODATA2   _IOW(GIODRV_IOC_MAGIC,  3, unsigned short *)
-#define GIODRV_IOCGGIODATA2   _IOR(GIODRV_IOC_MAGIC,  4, unsigned short *)
-#define GIODRV_IOCSGIODATA4   _IOW(GIODRV_IOC_MAGIC,  5, unsigned long *)
-#define GIODRV_IOCGGIODATA4   _IOR(GIODRV_IOC_MAGIC,  6, unsigned long *)
-#define GIODRV_IOCSGIOSETADDR _IOW(GIODRV_IOC_MAGIC,  7, unsigned long *)
-#define GIODRV_IOCHARDRESET   _IO(GIODRV_IOC_MAGIC, 8) /* debugging tool */
-#define GIODRV_IOC_MAXNR 8
-
-#define GIO_READ 0x00000000
-#define GIO_WRITE 0x00000001
-
-#endif /* __ASM_SH_LANDISK_GIO_H  */
diff --git a/arch/sh/include/mach-landisk/mach/iodata_landisk.h b/arch/sh/include/mach-landisk/mach/iodata_landisk.h
deleted file mode 100644
index b41308c94d1e94..00000000000000
--- a/arch/sh/include/mach-landisk/mach/iodata_landisk.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_IODATA_LANDISK_H
-#define __ASM_SH_IODATA_LANDISK_H
-
-/*
- * arch/sh/include/mach-landisk/mach/iodata_landisk.h
- *
- * Copyright (C) 2000  Atom Create Engineering Co., Ltd.
- *
- * IO-DATA LANDISK support
- */
-#include <linux/sh_intc.h>
-
-/* Box specific addresses.  */
-
-#define PA_USB		0xa4000000	/* USB Controller M66590 */
-
-#define PA_ATARST	0xb0000000	/* ATA/FATA Access Control Register */
-#define PA_LED		0xb0000001	/* LED Control Register */
-#define PA_STATUS	0xb0000002	/* Switch Status Register */
-#define PA_SHUTDOWN	0xb0000003	/* Shutdown Control Register */
-#define PA_PCIPME	0xb0000004	/* PCI PME Status Register */
-#define PA_IMASK	0xb0000005	/* Interrupt Mask Register */
-/* 2003.10.31 I-O DATA NSD NWG	add.	for shutdown port clear */
-#define PA_PWRINT_CLR	0xb0000006	/* Shutdown Interrupt clear Register */
-
-#define PA_PIDE_OFFSET	0x40		/* CF IDE Offset */
-#define PA_SIDE_OFFSET	0x40		/* HDD IDE Offset */
-
-#define IRQ_PCIINTA	evt2irq(0x2a0)	/* PCI INTA IRQ */
-#define IRQ_PCIINTB	evt2irq(0x2c0)	/* PCI INTB IRQ */
-#define IRQ_PCIINTC	evt2irq(0x2e0)	/* PCI INTC IRQ */
-#define IRQ_PCIINTD	evt2irq(0x300)	/* PCI INTD IRQ */
-#define IRQ_ATA		evt2irq(0x320)	/* ATA IRQ */
-#define IRQ_FATA	evt2irq(0x340)	/* FATA IRQ */
-#define IRQ_POWER	evt2irq(0x360)	/* Power Switch IRQ */
-#define IRQ_BUTTON	evt2irq(0x380)	/* USL-5P Button IRQ */
-#define IRQ_FAULT	evt2irq(0x3a0)	/* USL-5P Fault  IRQ */
-
-void init_landisk_IRQ(void);
-
-#define __IO_PREFIX landisk
-#include <asm/io_generic.h>
-
-#endif  /* __ASM_SH_IODATA_LANDISK_H */
-
diff --git a/arch/sh/include/mach-migor/mach/migor.h b/arch/sh/include/mach-migor/mach/migor.h
deleted file mode 100644
index 2a422b778e008f..00000000000000
--- a/arch/sh/include/mach-migor/mach/migor.h
+++ /dev/null
@@ -1,16 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_MIGOR_H
-#define __ASM_SH_MIGOR_H
-
-#define PORT_MSELCRA 0xa4050180
-#define PORT_MSELCRB 0xa4050182
-#define BSC_CS4BCR 0xfec10010
-#define BSC_CS6ABCR 0xfec1001c
-#define BSC_CS4WCR 0xfec10030
-
-#include <video/sh_mobile_lcdc.h>
-
-int migor_lcd_qvga_setup(void *sys_ops_handle,
-			 struct sh_mobile_lcdc_sys_bus_ops *sys_ops);
-
-#endif /* __ASM_SH_MIGOR_H */
diff --git a/arch/sh/include/mach-sdk7786/mach/fpga.h b/arch/sh/include/mach-sdk7786/mach/fpga.h
deleted file mode 100644
index 76c2e84893cc61..00000000000000
--- a/arch/sh/include/mach-sdk7786/mach/fpga.h
+++ /dev/null
@@ -1,156 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __MACH_SDK7786_FPGA_H
-#define __MACH_SDK7786_FPGA_H
-
-#include <linux/io.h>
-#include <linux/types.h>
-#include <linux/bitops.h>
-
-#define SRSTR		0x000
-#define  SRSTR_MAGIC	0x1971	/* Fixed magical read value */
-
-#define INTASR		0x010
-#define INTAMR		0x020
-#define MODSWR		0x030
-#define INTTESTR	0x040
-#define SYSSR		0x050
-#define NRGPR		0x060
-
-#define NMISR		0x070
-#define  NMISR_MAN_NMI	BIT(0)
-#define  NMISR_AUX_NMI	BIT(1)
-#define  NMISR_MASK	(NMISR_MAN_NMI | NMISR_AUX_NMI)
-
-#define NMIMR		0x080
-#define  NMIMR_MAN_NMIM	BIT(0)	/* Manual NMI mask */
-#define  NMIMR_AUX_NMIM	BIT(1)	/* Auxiliary NMI mask */
-#define  NMIMR_MASK	(NMIMR_MAN_NMIM | NMIMR_AUX_NMIM)
-
-#define INTBSR		0x090
-#define INTBMR		0x0a0
-#define USRLEDR		0x0b0
-#define MAPSWR		0x0c0
-#define FPGAVR		0x0d0
-#define FPGADR		0x0e0
-#define PCBRR		0x0f0
-#define RSR		0x100
-#define EXTASR		0x110
-#define SPCAR		0x120
-#define INTMSR		0x130
-
-#define PCIECR		0x140
-#define  PCIECR_PCIEMUX1	BIT(15)
-#define  PCIECR_PCIEMUX0	BIT(14)
-#define  PCIECR_PRST4		BIT(12) /* slot 4 card present */
-#define  PCIECR_PRST3		BIT(11) /* slot 3 card present */
-#define  PCIECR_PRST2		BIT(10) /* slot 2 card present */
-#define  PCIECR_PRST1		BIT(9)  /* slot 1 card present */
-#define  PCIECR_CLKEN		BIT(4)	/* oscillator enable */
-
-#define FAER		0x150
-#define USRGPIR		0x160
-
-/* 0x170 reserved */
-
-#define LCLASR			0x180
-#define  LCLASR_FRAMEN		BIT(15)
-
-#define  LCLASR_FPGA_SEL_SHIFT	12
-#define  LCLASR_NAND_SEL_SHIFT	8
-#define  LCLASR_NORB_SEL_SHIFT	4
-#define  LCLASR_NORA_SEL_SHIFT	0
-
-#define  LCLASR_AREA_MASK	0x7
-
-#define  LCLASR_FPGA_SEL_MASK	(LCLASR_AREA_MASK << LCLASR_FPGA_SEL_SHIFT)
-#define  LCLASR_NAND_SEL_MASK	(LCLASR_AREA_MASK << LCLASR_NAND_SEL_SHIFT)
-#define  LCLASR_NORB_SEL_MASK	(LCLASR_AREA_MASK << LCLASR_NORB_SEL_SHIFT)
-#define  LCLASR_NORA_SEL_MASK	(LCLASR_AREA_MASK << LCLASR_NORA_SEL_SHIFT)
-
-#define SBCR		0x190
-#define  SCBR_I2CMEN	BIT(0)	/* FPGA I2C master enable */
-#define  SCBR_I2CCEN	BIT(1)	/* CPU I2C master enable */
-
-#define PWRCR		0x1a0
-#define  PWRCR_SCISEL0	BIT(0)
-#define  PWRCR_SCISEL1	BIT(1)
-#define  PWRCR_SCIEN	BIT(2)	/* Serial port enable */
-#define  PWRCR_PDWNACK	BIT(5)	/* Power down acknowledge */
-#define  PWRCR_PDWNREQ	BIT(7)	/* Power down request */
-#define  PWRCR_INT2	BIT(11)	/* INT2 connection to power manager */
-#define  PWRCR_BUPINIT	BIT(13)	/* DDR backup initialize */
-#define  PWRCR_BKPRST	BIT(15) /* Backup power reset */
-
-#define SPCBR		0x1b0
-#define SPICR		0x1c0
-#define SPIDR		0x1d0
-#define I2CCR		0x1e0
-#define I2CDR		0x1f0
-#define FPGACR		0x200
-#define IASELR1		0x210
-#define IASELR2		0x220
-#define IASELR3		0x230
-#define IASELR4		0x240
-#define IASELR5		0x250
-#define IASELR6		0x260
-#define IASELR7		0x270
-#define IASELR8		0x280
-#define IASELR9		0x290
-#define IASELR10	0x2a0
-#define IASELR11	0x2b0
-#define IASELR12	0x2c0
-#define IASELR13	0x2d0
-#define IASELR14	0x2e0
-#define IASELR15	0x2f0
-/* 0x300 reserved */
-#define IBSELR1		0x310
-#define IBSELR2		0x320
-#define IBSELR3		0x330
-#define IBSELR4		0x340
-#define IBSELR5		0x350
-#define IBSELR6		0x360
-#define IBSELR7		0x370
-#define IBSELR8		0x380
-#define IBSELR9		0x390
-#define IBSELR10	0x3a0
-#define IBSELR11	0x3b0
-#define IBSELR12	0x3c0
-#define IBSELR13	0x3d0
-#define IBSELR14	0x3e0
-#define IBSELR15	0x3f0
-#define USRACR		0x400
-#define BEEPR		0x410
-#define USRLCDR		0x420
-#define SMBCR		0x430
-#define SMBDR		0x440
-#define USBCR		0x450
-#define AMSR		0x460
-#define ACCR		0x470
-#define SDIFCR		0x480
-
-/* arch/sh/boards/mach-sdk7786/fpga.c */
-extern void __iomem *sdk7786_fpga_base;
-extern void sdk7786_fpga_init(void);
-
-/* arch/sh/boards/mach-sdk7786/nmi.c */
-extern void sdk7786_nmi_init(void);
-
-#define SDK7786_FPGA_REGADDR(reg)	(sdk7786_fpga_base + (reg))
-
-/*
- * A convenience wrapper from register offset to internal I2C address,
- * when the FPGA is in I2C slave mode.
- */
-#define SDK7786_FPGA_I2CADDR(reg)	((reg) >> 3)
-
-static inline u16 fpga_read_reg(unsigned int reg)
-{
-	return ioread16(sdk7786_fpga_base + reg);
-}
-
-static inline void fpga_write_reg(u16 val, unsigned int reg)
-{
-	iowrite16(val, sdk7786_fpga_base + reg);
-}
-
-#endif /* __MACH_SDK7786_FPGA_H */
diff --git a/arch/sh/include/mach-sdk7786/mach/irq.h b/arch/sh/include/mach-sdk7786/mach/irq.h
deleted file mode 100644
index 3343380907b2db..00000000000000
--- a/arch/sh/include/mach-sdk7786/mach/irq.h
+++ /dev/null
@@ -1,8 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __MACH_SDK7786_IRQ_H
-#define __MACH_SDK7786_IRQ_H
-
-/* arch/sh/boards/mach-sdk7786/irq.c */
-extern void sdk7786_init_irq(void);
-
-#endif /* __MACH_SDK7786_IRQ_H */
diff --git a/arch/sh/include/mach-se/mach/mrshpc.h b/arch/sh/include/mach-se/mach/mrshpc.h
deleted file mode 100644
index 4e260f399b79c3..00000000000000
--- a/arch/sh/include/mach-se/mach/mrshpc.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __MACH_SE_MRSHPC_H
-#define __MACH_SE_MRSHPC_H
-
-#include <linux/io.h>
-
-static inline void __init mrshpc_setup_windows(void)
-{
-	if ((__raw_readw(MRSHPC_CSR) & 0x000c) != 0)
-		return;	/* Not detected */
-
-	if ((__raw_readw(MRSHPC_CSR) & 0x0080) == 0) {
-		__raw_writew(0x0674, MRSHPC_CPWCR); /* Card Vcc is 3.3v? */
-	} else {
-		__raw_writew(0x0678, MRSHPC_CPWCR); /* Card Vcc is 5V */
-	}
-
-	/*
-	 *  PC-Card window open
-	 *  flag == COMMON/ATTRIBUTE/IO
-	 */
-	/* common window open */
-	__raw_writew(0x8a84, MRSHPC_MW0CR1);
-	if((__raw_readw(MRSHPC_CSR) & 0x4000) != 0)
-		/* common mode & bus width 16bit SWAP = 1*/
-		__raw_writew(0x0b00, MRSHPC_MW0CR2);
-	else
-		/* common mode & bus width 16bit SWAP = 0*/
-		__raw_writew(0x0300, MRSHPC_MW0CR2);
-
-	/* attribute window open */
-	__raw_writew(0x8a85, MRSHPC_MW1CR1);
-	if ((__raw_readw(MRSHPC_CSR) & 0x4000) != 0)
-		/* attribute mode & bus width 16bit SWAP = 1*/
-		__raw_writew(0x0a00, MRSHPC_MW1CR2);
-	else
-		/* attribute mode & bus width 16bit SWAP = 0*/
-		__raw_writew(0x0200, MRSHPC_MW1CR2);
-
-	/* I/O window open */
-	__raw_writew(0x8a86, MRSHPC_IOWCR1);
-	__raw_writew(0x0008, MRSHPC_CDCR);	 /* I/O card mode */
-	if ((__raw_readw(MRSHPC_CSR) & 0x4000) != 0)
-		__raw_writew(0x0a00, MRSHPC_IOWCR2); /* bus width 16bit SWAP = 1*/
-	else
-		__raw_writew(0x0200, MRSHPC_IOWCR2); /* bus width 16bit SWAP = 0*/
-
-	__raw_writew(0x2000, MRSHPC_ICR);
-	__raw_writeb(0x00, PA_MRSHPC_MW2 + 0x206);
-	__raw_writeb(0x42, PA_MRSHPC_MW2 + 0x200);
-}
-
-#endif /* __MACH_SE_MRSHPC_H */
diff --git a/arch/sh/include/mach-se/mach/se.h b/arch/sh/include/mach-se/mach/se.h
deleted file mode 100644
index aa83fe1ff0b124..00000000000000
--- a/arch/sh/include/mach-se/mach/se.h
+++ /dev/null
@@ -1,120 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_HITACHI_SE_H
-#define __ASM_SH_HITACHI_SE_H
-
-/*
- * linux/include/asm-sh/hitachi_se.h
- *
- * Copyright (C) 2000  Kazumoto Kojima
- *
- * Hitachi SolutionEngine support
- */
-#include <linux/sh_intc.h>
-
-/* Box specific addresses.  */
-
-#define PA_ROM		0x00000000	/* EPROM */
-#define PA_ROM_SIZE	0x00400000	/* EPROM size 4M byte */
-#define PA_FROM		0x01000000	/* EPROM */
-#define PA_FROM_SIZE	0x00400000	/* EPROM size 4M byte */
-#define PA_EXT1		0x04000000
-#define PA_EXT1_SIZE	0x04000000
-#define PA_EXT2		0x08000000
-#define PA_EXT2_SIZE	0x04000000
-#define PA_SDRAM	0x0c000000
-#define PA_SDRAM_SIZE	0x04000000
-
-#define PA_EXT4		0x12000000
-#define PA_EXT4_SIZE	0x02000000
-#define PA_EXT5		0x14000000
-#define PA_EXT5_SIZE	0x04000000
-#define PA_PCIC		0x18000000	/* MR-SHPC-01 PCMCIA */
-
-#define PA_83902	0xb0000000	/* DP83902A */
-#define PA_83902_IF	0xb0040000	/* DP83902A remote io port */
-#define PA_83902_RST	0xb0080000	/* DP83902A reset port */
-
-#define PA_SUPERIO	0xb0400000	/* SMC37C935A super io chip */
-#define PA_DIPSW0	0xb0800000	/* Dip switch 5,6 */
-#define PA_DIPSW1	0xb0800002	/* Dip switch 7,8 */
-#define PA_LED		0xb0c00000	/* LED */
-#if defined(CONFIG_CPU_SUBTYPE_SH7705)
-#define PA_BCR		0xb0e00000
-#else
-#define PA_BCR		0xb1400000	/* FPGA */
-#endif
-
-#define PA_MRSHPC	0xb83fffe0	/* MR-SHPC-01 PCMCIA controller */
-#define PA_MRSHPC_MW1	0xb8400000	/* MR-SHPC-01 memory window base */
-#define PA_MRSHPC_MW2	0xb8500000	/* MR-SHPC-01 attribute window base */
-#define PA_MRSHPC_IO	0xb8600000	/* MR-SHPC-01 I/O window base */
-#define MRSHPC_OPTION   (PA_MRSHPC + 6)
-#define MRSHPC_CSR      (PA_MRSHPC + 8)
-#define MRSHPC_ISR      (PA_MRSHPC + 10)
-#define MRSHPC_ICR      (PA_MRSHPC + 12)
-#define MRSHPC_CPWCR    (PA_MRSHPC + 14)
-#define MRSHPC_MW0CR1   (PA_MRSHPC + 16)
-#define MRSHPC_MW1CR1   (PA_MRSHPC + 18)
-#define MRSHPC_IOWCR1   (PA_MRSHPC + 20)
-#define MRSHPC_MW0CR2   (PA_MRSHPC + 22)
-#define MRSHPC_MW1CR2   (PA_MRSHPC + 24)
-#define MRSHPC_IOWCR2   (PA_MRSHPC + 26)
-#define MRSHPC_CDCR     (PA_MRSHPC + 28)
-#define MRSHPC_PCIC_INFO (PA_MRSHPC + 30)
-
-#define BCR_ILCRA	(PA_BCR + 0)
-#define BCR_ILCRB	(PA_BCR + 2)
-#define BCR_ILCRC	(PA_BCR + 4)
-#define BCR_ILCRD	(PA_BCR + 6)
-#define BCR_ILCRE	(PA_BCR + 8)
-#define BCR_ILCRF	(PA_BCR + 10)
-#define BCR_ILCRG	(PA_BCR + 12)
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7709)
-#define INTC_IRR0       0xa4000004UL
-#define INTC_IRR1       0xa4000006UL
-#define INTC_IRR2       0xa4000008UL
-
-#define INTC_ICR0       0xfffffee0UL
-#define INTC_ICR1       0xa4000010UL
-#define INTC_ICR2       0xa4000012UL
-#define INTC_INTER      0xa4000014UL
-
-#define INTC_IPRC       0xa4000016UL
-#define INTC_IPRD       0xa4000018UL
-#define INTC_IPRE       0xa400001aUL
-
-#define IRQ0_IRQ        evt2irq(0x600)
-#define IRQ1_IRQ        evt2irq(0x620)
-#endif
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7705)
-#define IRQ_STNIC	evt2irq(0x380)
-#define IRQ_CFCARD	evt2irq(0x3c0)
-#else
-#define IRQ_STNIC	evt2irq(0x340)
-#define IRQ_CFCARD	evt2irq(0x2e0)
-#endif
-
-/* SH Ether support (SH7710/SH7712) */
-/* Base address */
-#define SH_ETH0_BASE 0xA7000000
-#define SH_ETH1_BASE 0xA7000400
-#define SH_TSU_BASE  0xA7000800
-/* PHY ID */
-#if defined(CONFIG_CPU_SUBTYPE_SH7710)
-# define PHY_ID 0x00
-#elif defined(CONFIG_CPU_SUBTYPE_SH7712)
-# define PHY_ID 0x01
-#endif
-/* Ether IRQ */
-#define SH_ETH0_IRQ	evt2irq(0xc00)
-#define SH_ETH1_IRQ	evt2irq(0xc20)
-#define SH_TSU_IRQ	evt2irq(0xc40)
-
-void init_se_IRQ(void);
-
-#define __IO_PREFIX	se
-#include <asm/io_generic.h>
-
-#endif  /* __ASM_SH_HITACHI_SE_H */
diff --git a/arch/sh/include/mach-se/mach/se7206.h b/arch/sh/include/mach-se/mach/se7206.h
deleted file mode 100644
index cf190279bb1d7e..00000000000000
--- a/arch/sh/include/mach-se/mach/se7206.h
+++ /dev/null
@@ -1,14 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_SE7206_H
-#define __ASM_SH_SE7206_H
-
-#define PA_SMSC		0x30000000
-#define PA_MRSHPC	0x34000000
-#define PA_LED		0x31400000
-
-void init_se7206_IRQ(void);
-
-#define __IO_PREFIX	se7206
-#include <asm/io_generic.h>
-
-#endif /* __ASM_SH_SE7206_H */
diff --git a/arch/sh/include/mach-se/mach/se7343.h b/arch/sh/include/mach-se/mach/se7343.h
deleted file mode 100644
index 107fb5f3ef8056..00000000000000
--- a/arch/sh/include/mach-se/mach/se7343.h
+++ /dev/null
@@ -1,143 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_HITACHI_SE7343_H
-#define __ASM_SH_HITACHI_SE7343_H
-
-/*
- * include/asm-sh/se/se7343.h
- *
- * Copyright (C) 2003 Takashi Kusuda <kusuda-takashi@hitachi-ul.co.jp>
- *
- * SH-Mobile SolutionEngine 7343 support
- */
-#include <linux/sh_intc.h>
-
-/* Box specific addresses.  */
-
-/* Area 0 */
-#define PA_ROM		0x00000000	/* EPROM */
-#define PA_ROM_SIZE	0x00400000	/* EPROM size 4M byte(Actually 2MB) */
-#define PA_FROM		0x00400000	/* Flash ROM */
-#define PA_FROM_SIZE	0x00400000	/* Flash size 4M byte */
-#define PA_SRAM		0x00800000	/* SRAM */
-#define PA_FROM_SIZE	0x00400000	/* SRAM size 4M byte */
-/* Area 1 */
-#define PA_EXT1		0x04000000
-#define PA_EXT1_SIZE	0x04000000
-/* Area 2 */
-#define PA_EXT2		0x08000000
-#define PA_EXT2_SIZE	0x04000000
-/* Area 3 */
-#define PA_SDRAM	0x0c000000
-#define PA_SDRAM_SIZE	0x04000000
-/* Area 4 */
-#define PA_PCIC		0x10000000	/* MR-SHPC-01 PCMCIA */
-#define PA_MRSHPC       0xb03fffe0      /* MR-SHPC-01 PCMCIA controller */
-#define PA_MRSHPC_MW1   0xb0400000      /* MR-SHPC-01 memory window base */
-#define PA_MRSHPC_MW2   0xb0500000      /* MR-SHPC-01 attribute window base */
-#define PA_MRSHPC_IO    0xb0600000      /* MR-SHPC-01 I/O window base */
-#define MRSHPC_OPTION   (PA_MRSHPC + 6)
-#define MRSHPC_CSR      (PA_MRSHPC + 8)
-#define MRSHPC_ISR      (PA_MRSHPC + 10)
-#define MRSHPC_ICR      (PA_MRSHPC + 12)
-#define MRSHPC_CPWCR    (PA_MRSHPC + 14)
-#define MRSHPC_MW0CR1   (PA_MRSHPC + 16)
-#define MRSHPC_MW1CR1   (PA_MRSHPC + 18)
-#define MRSHPC_IOWCR1   (PA_MRSHPC + 20)
-#define MRSHPC_MW0CR2   (PA_MRSHPC + 22)
-#define MRSHPC_MW1CR2   (PA_MRSHPC + 24)
-#define MRSHPC_IOWCR2   (PA_MRSHPC + 26)
-#define MRSHPC_CDCR     (PA_MRSHPC + 28)
-#define MRSHPC_PCIC_INFO (PA_MRSHPC + 30)
-#define PA_LED		0xb0C00000	/* LED */
-#define LED_SHIFT       0
-#define PA_DIPSW	0xb0900000	/* Dip switch 31 */
-/* Area 5 */
-#define PA_EXT5		0x14000000
-#define PA_EXT5_SIZE	0x04000000
-/* Area 6 */
-#define PA_LCD1		0xb8000000
-#define PA_LCD2		0xb8800000
-
-#define PORT_PACR	0xA4050100
-#define PORT_PBCR	0xA4050102
-#define PORT_PCCR	0xA4050104
-#define PORT_PDCR	0xA4050106
-#define PORT_PECR	0xA4050108
-#define PORT_PFCR	0xA405010A
-#define PORT_PGCR	0xA405010C
-#define PORT_PHCR	0xA405010E
-#define PORT_PJCR	0xA4050110
-#define PORT_PKCR	0xA4050112
-#define PORT_PLCR	0xA4050114
-#define PORT_PMCR	0xA4050116
-#define PORT_PNCR	0xA4050118
-#define PORT_PQCR	0xA405011A
-#define PORT_PRCR	0xA405011C
-#define PORT_PSCR	0xA405011E
-#define PORT_PTCR	0xA4050140
-#define PORT_PUCR	0xA4050142
-#define PORT_PVCR	0xA4050144
-#define PORT_PWCR	0xA4050146
-#define PORT_PYCR	0xA4050148
-#define PORT_PZCR	0xA405014A
-
-#define PORT_PSELA	0xA405014C
-#define PORT_PSELB	0xA405014E
-#define PORT_PSELC	0xA4050150
-#define PORT_PSELD	0xA4050152
-#define PORT_PSELE	0xA4050154
-
-#define PORT_HIZCRA	0xA4050156
-#define PORT_HIZCRB	0xA4050158
-#define PORT_HIZCRC	0xA405015C
-
-#define PORT_DRVCR	0xA4050180
-
-#define PORT_PADR	0xA4050120
-#define PORT_PBDR	0xA4050122
-#define PORT_PCDR	0xA4050124
-#define PORT_PDDR	0xA4050126
-#define PORT_PEDR	0xA4050128
-#define PORT_PFDR	0xA405012A
-#define PORT_PGDR	0xA405012C
-#define PORT_PHDR	0xA405012E
-#define PORT_PJDR	0xA4050130
-#define PORT_PKDR	0xA4050132
-#define PORT_PLDR	0xA4050134
-#define PORT_PMDR	0xA4050136
-#define PORT_PNDR	0xA4050138
-#define PORT_PQDR	0xA405013A
-#define PORT_PRDR	0xA405013C
-#define PORT_PTDR	0xA4050160
-#define PORT_PUDR	0xA4050162
-#define PORT_PVDR	0xA4050164
-#define PORT_PWDR	0xA4050166
-#define PORT_PYDR	0xA4050168
-
-#define FPGA_IN		0xb1400000
-#define FPGA_OUT	0xb1400002
-
-#define IRQ0_IRQ        evt2irq(0x600)
-#define IRQ1_IRQ        evt2irq(0x620)
-#define IRQ4_IRQ        evt2irq(0x680)
-#define IRQ5_IRQ        evt2irq(0x6a0)
-
-#define SE7343_FPGA_IRQ_MRSHPC0	0
-#define SE7343_FPGA_IRQ_MRSHPC1	1
-#define SE7343_FPGA_IRQ_MRSHPC2	2
-#define SE7343_FPGA_IRQ_MRSHPC3	3
-#define SE7343_FPGA_IRQ_SMC	6	/* EXT_IRQ2 */
-#define SE7343_FPGA_IRQ_USB	8
-#define SE7343_FPGA_IRQ_UARTA	10
-#define SE7343_FPGA_IRQ_UARTB	11
-
-#define SE7343_FPGA_IRQ_NR	12
-
-struct irq_domain;
-
-/* arch/sh/boards/se/7343/irq.c */
-extern struct irq_domain *se7343_irq_domain;
-
-void init_7343se_IRQ(void);
-
-#endif  /* __ASM_SH_HITACHI_SE7343_H */
diff --git a/arch/sh/include/mach-se/mach/se7721.h b/arch/sh/include/mach-se/mach/se7721.h
deleted file mode 100644
index 82226d40faf528..00000000000000
--- a/arch/sh/include/mach-se/mach/se7721.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * Copyright (C) 2008 Renesas Solutions Corp.
- *
- * Hitachi UL SolutionEngine 7721 Support.
- */
-
-#ifndef __ASM_SH_SE7721_H
-#define __ASM_SH_SE7721_H
-
-#include <linux/sh_intc.h>
-#include <asm/addrspace.h>
-
-/* Box specific addresses. */
-#define SE_AREA0_WIDTH	2		/* Area0: 32bit */
-#define PA_ROM		0xa0000000	/* EPROM */
-#define PA_ROM_SIZE	0x00200000	/* EPROM size 2M byte */
-#define PA_FROM		0xa1000000	/* Flash-ROM */
-#define PA_FROM_SIZE	0x01000000	/* Flash-ROM size 16M byte */
-#define PA_EXT1		0xa4000000
-#define PA_EXT1_SIZE	0x04000000
-#define PA_SDRAM	0xaC000000	/* SDRAM(Area3) 64MB */
-#define PA_SDRAM_SIZE	0x04000000
-
-#define PA_EXT4		0xb0000000
-#define PA_EXT4_SIZE	0x04000000
-
-#define PA_PERIPHERAL	0xB8000000
-
-#define PA_PCIC		PA_PERIPHERAL
-#define PA_MRSHPC	(PA_PERIPHERAL + 0x003fffe0)
-#define PA_MRSHPC_MW1	(PA_PERIPHERAL + 0x00400000)
-#define PA_MRSHPC_MW2	(PA_PERIPHERAL + 0x00500000)
-#define PA_MRSHPC_IO	(PA_PERIPHERAL + 0x00600000)
-#define MRSHPC_OPTION	(PA_MRSHPC + 6)
-#define MRSHPC_CSR	(PA_MRSHPC + 8)
-#define MRSHPC_ISR	(PA_MRSHPC + 10)
-#define MRSHPC_ICR	(PA_MRSHPC + 12)
-#define MRSHPC_CPWCR	(PA_MRSHPC + 14)
-#define MRSHPC_MW0CR1	(PA_MRSHPC + 16)
-#define MRSHPC_MW1CR1	(PA_MRSHPC + 18)
-#define MRSHPC_IOWCR1	(PA_MRSHPC + 20)
-#define MRSHPC_MW0CR2	(PA_MRSHPC + 22)
-#define MRSHPC_MW1CR2	(PA_MRSHPC + 24)
-#define MRSHPC_IOWCR2	(PA_MRSHPC + 26)
-#define MRSHPC_CDCR	(PA_MRSHPC + 28)
-#define MRSHPC_PCIC_INFO	(PA_MRSHPC + 30)
-
-#define PA_LED		0xB6800000	/* 8bit LED */
-#define PA_FPGA		0xB7000000	/* FPGA base address */
-
-#define MRSHPC_IRQ0	evt2irq(0x340)
-
-#define FPGA_ILSR1	(PA_FPGA + 0x02)
-#define FPGA_ILSR2	(PA_FPGA + 0x03)
-#define FPGA_ILSR3	(PA_FPGA + 0x04)
-#define FPGA_ILSR4	(PA_FPGA + 0x05)
-#define FPGA_ILSR5	(PA_FPGA + 0x06)
-#define FPGA_ILSR6	(PA_FPGA + 0x07)
-#define FPGA_ILSR7	(PA_FPGA + 0x08)
-#define FPGA_ILSR8	(PA_FPGA + 0x09)
-
-void init_se7721_IRQ(void);
-
-#define __IO_PREFIX		se7721
-#include <asm/io_generic.h>
-
-#endif  /* __ASM_SH_SE7721_H */
diff --git a/arch/sh/include/mach-se/mach/se7722.h b/arch/sh/include/mach-se/mach/se7722.h
deleted file mode 100644
index efb761f9f6e0e8..00000000000000
--- a/arch/sh/include/mach-se/mach/se7722.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_SE7722_H
-#define __ASM_SH_SE7722_H
-
-/*
- * linux/include/asm-sh/se7722.h
- *
- * Copyright (C) 2007  Nobuhiro Iwamatsu
- *
- * Hitachi UL SolutionEngine 7722 Support.
- */
-#include <linux/sh_intc.h>
-#include <asm/addrspace.h>
-
-/* Box specific addresses.  */
-#define SE_AREA0_WIDTH	4		/* Area0: 32bit */
-#define PA_ROM		0xa0000000	/* EPROM */
-#define PA_ROM_SIZE	0x00200000	/* EPROM size 2M byte */
-#define PA_FROM		0xa1000000	/* Flash-ROM */
-#define PA_FROM_SIZE	0x01000000	/* Flash-ROM size 16M byte */
-#define PA_EXT1		0xa4000000
-#define PA_EXT1_SIZE	0x04000000
-#define PA_SDRAM	0xaC000000	/* DDR-SDRAM(Area3) 64MB */
-#define PA_SDRAM_SIZE	0x04000000
-
-#define PA_EXT4		0xb0000000
-#define PA_EXT4_SIZE	0x04000000
-
-#define PA_PERIPHERAL	0xB0000000
-
-#define PA_PCIC         PA_PERIPHERAL		/* MR-SHPC-01 PCMCIA */
-#define PA_MRSHPC       (PA_PERIPHERAL + 0x003fffe0)    /* MR-SHPC-01 PCMCIA controller */
-#define PA_MRSHPC_MW1   (PA_PERIPHERAL + 0x00400000)    /* MR-SHPC-01 memory window base */
-#define PA_MRSHPC_MW2   (PA_PERIPHERAL + 0x00500000)    /* MR-SHPC-01 attribute window base */
-#define PA_MRSHPC_IO    (PA_PERIPHERAL + 0x00600000)    /* MR-SHPC-01 I/O window base */
-#define MRSHPC_OPTION   (PA_MRSHPC + 6)
-#define MRSHPC_CSR      (PA_MRSHPC + 8)
-#define MRSHPC_ISR      (PA_MRSHPC + 10)
-#define MRSHPC_ICR      (PA_MRSHPC + 12)
-#define MRSHPC_CPWCR    (PA_MRSHPC + 14)
-#define MRSHPC_MW0CR1   (PA_MRSHPC + 16)
-#define MRSHPC_MW1CR1   (PA_MRSHPC + 18)
-#define MRSHPC_IOWCR1   (PA_MRSHPC + 20)
-#define MRSHPC_MW0CR2   (PA_MRSHPC + 22)
-#define MRSHPC_MW1CR2   (PA_MRSHPC + 24)
-#define MRSHPC_IOWCR2   (PA_MRSHPC + 26)
-#define MRSHPC_CDCR     (PA_MRSHPC + 28)
-#define MRSHPC_PCIC_INFO (PA_MRSHPC + 30)
-
-#define PA_LED		(PA_PERIPHERAL + 0x00800000)	/* 8bit LED */
-#define PA_FPGA		(PA_PERIPHERAL + 0x01800000)	/* FPGA base address */
-
-#define PA_LAN		(PA_AREA6_IO + 0)		/* SMC LAN91C111 */
-/* GPIO */
-#define FPGA_IN         0xb1840000UL
-#define FPGA_OUT        0xb1840004UL
-
-#define PORT_PECR       0xA4050108UL
-#define PORT_PJCR       0xA4050110UL
-#define PORT_PSELD      0xA4050154UL
-#define PORT_PSELB      0xA4050150UL
-
-#define PORT_PSELC      0xA4050152UL
-#define PORT_PKCR       0xA4050112UL
-#define PORT_PHCR       0xA405010EUL
-#define PORT_PLCR       0xA4050114UL
-#define PORT_PMCR       0xA4050116UL
-#define PORT_PRCR       0xA405011CUL
-#define PORT_PXCR       0xA4050148UL
-#define PORT_PSELA      0xA405014EUL
-#define PORT_PYCR       0xA405014AUL
-#define PORT_PZCR       0xA405014CUL
-#define PORT_HIZCRA     0xA4050158UL
-#define PORT_HIZCRC     0xA405015CUL
-
-/* IRQ */
-#define IRQ0_IRQ        evt2irq(0x600)
-#define IRQ1_IRQ        evt2irq(0x620)
-
-#define SE7722_FPGA_IRQ_USB	0 /* IRQ0 */
-#define SE7722_FPGA_IRQ_SMC	1 /* IRQ0 */
-#define SE7722_FPGA_IRQ_MRSHPC0	2 /* IRQ1 */
-#define SE7722_FPGA_IRQ_MRSHPC1	3 /* IRQ1 */
-#define SE7722_FPGA_IRQ_MRSHPC2	4 /* IRQ1 */
-#define SE7722_FPGA_IRQ_MRSHPC3	5 /* IRQ1 */
-#define SE7722_FPGA_IRQ_NR	6
-
-struct irq_domain;
-
-/* arch/sh/boards/se/7722/irq.c */
-extern struct irq_domain *se7722_irq_domain;
-
-void init_se7722_IRQ(void);
-
-#define __IO_PREFIX		se7722
-#include <asm/io_generic.h>
-
-#endif  /* __ASM_SH_SE7722_H */
diff --git a/arch/sh/include/mach-se/mach/se7724.h b/arch/sh/include/mach-se/mach/se7724.h
deleted file mode 100644
index 1fe28820dfa953..00000000000000
--- a/arch/sh/include/mach-se/mach/se7724.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_SE7724_H
-#define __ASM_SH_SE7724_H
-
-/*
- * linux/include/asm-sh/se7724.h
- *
- * Copyright (C) 2009 Renesas Solutions Corp.
- *
- * Kuninori Morimoto <morimoto.kuninori@renesas.com>
- *
- * Hitachi UL SolutionEngine 7724 Support.
- *
- * Based on se7722.h
- * Copyright (C) 2007  Nobuhiro Iwamatsu
- */
-#include <linux/sh_intc.h>
-#include <asm/addrspace.h>
-
-/* SH Eth */
-#define SH_ETH_ADDR	(0xA4600000)
-#define SH_ETH_MAHR	(SH_ETH_ADDR + 0x1C0)
-#define SH_ETH_MALR	(SH_ETH_ADDR + 0x1C8)
-
-#define PA_LED		(0xba203000)	/* 8bit LED */
-#define IRQ_MODE	(0xba200010)
-#define IRQ0_SR		(0xba200014)
-#define IRQ1_SR		(0xba200018)
-#define IRQ2_SR		(0xba20001c)
-#define IRQ0_MR		(0xba200020)
-#define IRQ1_MR		(0xba200024)
-#define IRQ2_MR		(0xba200028)
-
-/* IRQ */
-#define IRQ0_IRQ        evt2irq(0x600)
-#define IRQ1_IRQ        evt2irq(0x620)
-#define IRQ2_IRQ        evt2irq(0x640)
-
-/* Bits in IRQ012 registers */
-#define SE7724_FPGA_IRQ_BASE	220
-
-/* IRQ0 */
-#define IRQ0_BASE	SE7724_FPGA_IRQ_BASE
-#define IRQ0_KEY	(IRQ0_BASE + 12)
-#define IRQ0_RMII	(IRQ0_BASE + 13)
-#define IRQ0_SMC	(IRQ0_BASE + 14)
-#define IRQ0_MASK	0x7fff
-#define IRQ0_END	IRQ0_SMC
-/* IRQ1 */
-#define IRQ1_BASE	(IRQ0_END + 1)
-#define IRQ1_TS		(IRQ1_BASE + 0)
-#define IRQ1_MASK	0x0001
-#define IRQ1_END	IRQ1_TS
-/* IRQ2 */
-#define IRQ2_BASE	(IRQ1_END + 1)
-#define IRQ2_USB0	(IRQ1_BASE + 0)
-#define IRQ2_USB1	(IRQ1_BASE + 1)
-#define IRQ2_MASK	0x0003
-#define IRQ2_END	IRQ2_USB1
-
-#define SE7724_FPGA_IRQ_NR	(IRQ2_END - IRQ0_BASE)
-
-/* arch/sh/boards/se/7724/irq.c */
-void init_se7724_IRQ(void);
-
-#define __IO_PREFIX		se7724
-#include <asm/io_generic.h>
-
-#endif  /* __ASM_SH_SE7724_H */
diff --git a/arch/sh/include/mach-se/mach/se7751.h b/arch/sh/include/mach-se/mach/se7751.h
deleted file mode 100644
index ee5b5e6e597970..00000000000000
--- a/arch/sh/include/mach-se/mach/se7751.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_HITACHI_7751SE_H
-#define __ASM_SH_HITACHI_7751SE_H
-
-/*
- * linux/include/asm-sh/hitachi_7751se.h
- *
- * Copyright (C) 2000  Kazumoto Kojima
- *
- * Hitachi SolutionEngine support
-
- * Modified for 7751 Solution Engine by
- * Ian da Silva and Jeremy Siegel, 2001.
- */
-#include <linux/sh_intc.h>
-
-/* Box specific addresses.  */
-
-#define PA_ROM		0x00000000	/* EPROM */
-#define PA_ROM_SIZE	0x00400000	/* EPROM size 4M byte */
-#define PA_FROM		0x01000000	/* EPROM */
-#define PA_FROM_SIZE	0x00400000	/* EPROM size 4M byte */
-#define PA_EXT1		0x04000000
-#define PA_EXT1_SIZE	0x04000000
-#define PA_EXT2		0x08000000
-#define PA_EXT2_SIZE	0x04000000
-#define PA_SDRAM	0x0c000000
-#define PA_SDRAM_SIZE	0x04000000
-
-#define PA_EXT4		0x12000000
-#define PA_EXT4_SIZE	0x02000000
-#define PA_EXT5		0x14000000
-#define PA_EXT5_SIZE	0x04000000
-#define PA_PCIC		0x18000000	/* MR-SHPC-01 PCMCIA */
-
-#define PA_DIPSW0	0xb9000000	/* Dip switch 5,6 */
-#define PA_DIPSW1	0xb9000002	/* Dip switch 7,8 */
-#define PA_LED		0xba000000	/* LED */
-#define	PA_BCR		0xbb000000	/* FPGA on the MS7751SE01 */
-
-#define PA_MRSHPC	0xb83fffe0	/* MR-SHPC-01 PCMCIA controller */
-#define PA_MRSHPC_MW1	0xb8400000	/* MR-SHPC-01 memory window base */
-#define PA_MRSHPC_MW2	0xb8500000	/* MR-SHPC-01 attribute window base */
-#define PA_MRSHPC_IO	0xb8600000	/* MR-SHPC-01 I/O window base */
-#define MRSHPC_MODE     (PA_MRSHPC + 4)
-#define MRSHPC_OPTION   (PA_MRSHPC + 6)
-#define MRSHPC_CSR      (PA_MRSHPC + 8)
-#define MRSHPC_ISR      (PA_MRSHPC + 10)
-#define MRSHPC_ICR      (PA_MRSHPC + 12)
-#define MRSHPC_CPWCR    (PA_MRSHPC + 14)
-#define MRSHPC_MW0CR1   (PA_MRSHPC + 16)
-#define MRSHPC_MW1CR1   (PA_MRSHPC + 18)
-#define MRSHPC_IOWCR1   (PA_MRSHPC + 20)
-#define MRSHPC_MW0CR2   (PA_MRSHPC + 22)
-#define MRSHPC_MW1CR2   (PA_MRSHPC + 24)
-#define MRSHPC_IOWCR2   (PA_MRSHPC + 26)
-#define MRSHPC_CDCR     (PA_MRSHPC + 28)
-#define MRSHPC_PCIC_INFO (PA_MRSHPC + 30)
-
-#define BCR_ILCRA	(PA_BCR + 0)
-#define BCR_ILCRB	(PA_BCR + 2)
-#define BCR_ILCRC	(PA_BCR + 4)
-#define BCR_ILCRD	(PA_BCR + 6)
-#define BCR_ILCRE	(PA_BCR + 8)
-#define BCR_ILCRF	(PA_BCR + 10)
-#define BCR_ILCRG	(PA_BCR + 12)
-
-#define IRQ_79C973	evt2irq(0x3a0)
-
-void init_7751se_IRQ(void);
-
-#define __IO_PREFIX	sh7751se
-#include <asm/io_generic.h>
-
-#endif  /* __ASM_SH_HITACHI_7751SE_H */
diff --git a/arch/sh/include/mach-se/mach/se7780.h b/arch/sh/include/mach-se/mach/se7780.h
deleted file mode 100644
index 24f0ac82f8b330..00000000000000
--- a/arch/sh/include/mach-se/mach/se7780.h
+++ /dev/null
@@ -1,106 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_SE7780_H
-#define __ASM_SH_SE7780_H
-
-/*
- * linux/include/asm-sh/se7780.h
- *
- * Copyright (C) 2006,2007  Nobuhiro Iwamatsu
- *
- * Hitachi UL SolutionEngine 7780 Support.
- */
-#include <linux/sh_intc.h>
-#include <asm/addrspace.h>
-
-/* Box specific addresses.  */
-#define SE_AREA0_WIDTH	4		/* Area0: 32bit */
-#define PA_ROM		0xa0000000	/* EPROM */
-#define PA_ROM_SIZE	0x00400000	/* EPROM size 4M byte */
-#define PA_FROM		0xa1000000	/* Flash-ROM */
-#define PA_FROM_SIZE	0x01000000	/* Flash-ROM size 16M byte */
-#define PA_EXT1		0xa4000000
-#define PA_EXT1_SIZE	0x04000000
-#define PA_SM501	PA_EXT1		/* Graphic IC (SM501) */
-#define PA_SM501_SIZE	PA_EXT1_SIZE	/* Graphic IC (SM501) */
-#define PA_SDRAM	0xa8000000	/* DDR-SDRAM(Area2/3) 128MB */
-#define PA_SDRAM_SIZE	0x08000000
-
-#define PA_EXT4		0xb0000000
-#define PA_EXT4_SIZE	0x04000000
-#define PA_EXT_FLASH	PA_EXT4		/* Expansion Flash-ROM */
-
-#define PA_PERIPHERAL	PA_AREA6_IO	/* SW6-6=ON */
-
-#define PA_LAN		(PA_PERIPHERAL + 0)		/* SMC LAN91C111 */
-#define PA_LED_DISP	(PA_PERIPHERAL + 0x02000000)	/* 8words LED Display */
-#define DISP_CHAR_RAM	(7 << 3)
-#define DISP_SEL0_ADDR	(DISP_CHAR_RAM + 0)
-#define DISP_SEL1_ADDR	(DISP_CHAR_RAM + 1)
-#define DISP_SEL2_ADDR	(DISP_CHAR_RAM + 2)
-#define DISP_SEL3_ADDR	(DISP_CHAR_RAM + 3)
-#define DISP_SEL4_ADDR	(DISP_CHAR_RAM + 4)
-#define DISP_SEL5_ADDR	(DISP_CHAR_RAM + 5)
-#define DISP_SEL6_ADDR	(DISP_CHAR_RAM + 6)
-#define DISP_SEL7_ADDR	(DISP_CHAR_RAM + 7)
-
-#define DISP_UDC_RAM	(5 << 3)
-#define PA_FPGA		(PA_PERIPHERAL + 0x03000000) /* FPGA base address */
-
-/* FPGA register address and bit */
-#define FPGA_SFTRST		(PA_FPGA + 0)	/* Soft reset register */
-#define FPGA_INTMSK1		(PA_FPGA + 2)	/* Interrupt Mask register 1 */
-#define FPGA_INTMSK2		(PA_FPGA + 4)	/* Interrupt Mask register 2 */
-#define FPGA_INTSEL1		(PA_FPGA + 6)	/* Interrupt select register 1 */
-#define FPGA_INTSEL2		(PA_FPGA + 8)	/* Interrupt select register 2 */
-#define FPGA_INTSEL3		(PA_FPGA + 10)	/* Interrupt select register 3 */
-#define FPGA_PCI_INTSEL1	(PA_FPGA + 12)	/* PCI Interrupt select register 1 */
-#define FPGA_PCI_INTSEL2	(PA_FPGA + 14)	/* PCI Interrupt select register 2 */
-#define FPGA_INTSET		(PA_FPGA + 16)	/* IRQ/IRL select register */
-#define FPGA_INTSTS1		(PA_FPGA + 18)	/* Interrupt status register 1 */
-#define FPGA_INTSTS2		(PA_FPGA + 20)	/* Interrupt status register 2 */
-#define FPGA_REQSEL		(PA_FPGA + 22)	/* REQ/GNT select register */
-#define FPGA_DBG_LED		(PA_FPGA + 32)	/* Debug LED(D-LED[8:1] */
-#define PA_LED			FPGA_DBG_LED
-#define FPGA_IVDRID		(PA_FPGA + 36)	/* iVDR ID Register */
-#define FPGA_IVDRPW		(PA_FPGA + 38)	/* iVDR Power ON Register */
-#define FPGA_MMCID		(PA_FPGA + 40)	/* MMC ID Register */
-
-/* FPGA INTSEL position */
-/* INTSEL1 */
-#define IRQPOS_SMC91CX          (0 * 4)
-#define IRQPOS_SM501            (1 * 4)
-/* INTSEL2 */
-#define IRQPOS_EXTINT1          (0 * 4)
-#define IRQPOS_EXTINT2          (1 * 4)
-#define IRQPOS_EXTINT3          (2 * 4)
-#define IRQPOS_EXTINT4          (3 * 4)
-/* INTSEL3 */
-#define IRQPOS_PCCPW            (0 * 4)
-
-/* IDE interrupt */
-#define IRQ_IDE0                evt2irq(0xa60) /* iVDR */
-
-/* SMC interrupt */
-#define SMC_IRQ                 evt2irq(0x300)
-
-/* SM501 interrupt */
-#define SM501_IRQ               evt2irq(0x200)
-
-/* interrupt pin */
-#define IRQPIN_EXTINT1          0 /* IRQ0 pin */
-#define IRQPIN_EXTINT2          1 /* IRQ1 pin */
-#define IRQPIN_EXTINT3          2 /* IRQ2 pin */
-#define IRQPIN_SMC91CX          3 /* IRQ3 pin */
-#define IRQPIN_EXTINT4          4 /* IRQ4 pin */
-#define IRQPIN_PCC0             5 /* IRQ5 pin */
-#define IRQPIN_PCC2             6 /* IRQ6 pin */
-#define IRQPIN_SM501            7 /* IRQ7 pin */
-#define IRQPIN_PCCPW            7 /* IRQ7 pin */
-
-/* arch/sh/boards/se/7780/irq.c */
-void init_se7780_IRQ(void);
-
-#define __IO_PREFIX		se7780
-#include <asm/io_generic.h>
-
-#endif  /* __ASM_SH_SE7780_H */
diff --git a/arch/sh/include/mach-sh03/mach/io.h b/arch/sh/include/mach-sh03/mach/io.h
deleted file mode 100644
index 5eacdabd71b6cb..00000000000000
--- a/arch/sh/include/mach-sh03/mach/io.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * include/asm-sh/sh03/io.h
- *
- * Copyright 2004 Interface Co.,Ltd. Saito.K
- *
- * IO functions for an Interface CTP/PCI-SH03
- */
-
-#ifndef _ASM_SH_IO_SH03_H
-#define _ASM_SH_IO_SH03_H
-
-#include <linux/time.h>
-
-#define IRL0_IRQ	2
-#define IRL0_PRIORITY	13
-#define IRL1_IRQ	5
-#define IRL1_PRIORITY	10
-#define IRL2_IRQ	8
-#define IRL2_PRIORITY	7
-#define IRL3_IRQ	11
-#define IRL3_PRIORITY	4
-
-void heartbeat_sh03(void);
-
-#endif /* _ASM_SH_IO_SH03_H */
diff --git a/arch/sh/include/mach-sh03/mach/sh03.h b/arch/sh/include/mach-sh03/mach/sh03.h
deleted file mode 100644
index 4ced684b16a4d4..00000000000000
--- a/arch/sh/include/mach-sh03/mach/sh03.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_SH03_H
-#define __ASM_SH_SH03_H
-
-/*
- * linux/include/asm-sh/sh03/sh03.h
- *
- * Copyright (C) 2004  Interface Co., Ltd. Saito.K
- *
- * Interface CTP/PCI-SH03 support
- */
-
-#define PA_PCI_IO       (0xbe240000)    /* PCI I/O space */
-#define PA_PCI_MEM      (0xbd000000)    /* PCI MEM space */
-
-#define PCIPAR          (0xa4000cf8)    /* PCI Config address */
-#define PCIPDR          (0xa4000cfc)    /* PCI Config data    */
-
-#endif  /* __ASM_SH_SH03_H */
diff --git a/arch/sh/include/mach-x3proto/mach/hardware.h b/arch/sh/include/mach-x3proto/mach/hardware.h
deleted file mode 100644
index 57ea4a5cca359d..00000000000000
--- a/arch/sh/include/mach-x3proto/mach/hardware.h
+++ /dev/null
@@ -1,13 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __MACH_X3PROTO_HARDWARE_H
-#define __MACH_X3PROTO_HARDWARE_H
-
-struct gpio_chip;
-
-/* arch/sh/boards/mach-x3proto/gpio.c */
-int x3proto_gpio_setup(void);
-extern struct gpio_chip x3proto_gpio_chip;
-
-#define NR_BASEBOARD_GPIOS	16
-
-#endif /* __MACH_X3PROTO_HARDWARE_H */
diff --git a/arch/sh/include/mach-x3proto/mach/ilsel.h b/arch/sh/include/mach-x3proto/mach/ilsel.h
deleted file mode 100644
index 47aeb4b55ea17b..00000000000000
--- a/arch/sh/include/mach-x3proto/mach/ilsel.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __ASM_SH_ILSEL_H
-#define __ASM_SH_ILSEL_H
-
-typedef enum {
-	ILSEL_NONE,
-	ILSEL_LAN,
-	ILSEL_USBH_I,
-	ILSEL_USBH_S,
-	ILSEL_USBH_V,
-	ILSEL_RTC,
-	ILSEL_USBP_I,
-	ILSEL_USBP_S,
-	ILSEL_USBP_V,
-	ILSEL_KEY,
-
-	/*
-	 * ILSEL Aliases - corner cases for interleaved level tables.
-	 *
-	 * Someone thought this was a good idea and less hassle than
-	 * demuxing a shared vector, really.
-	 */
-
-	/* ILSEL0 and 2 */
-	ILSEL_FPGA0,
-	ILSEL_FPGA1,
-	ILSEL_EX1,
-	ILSEL_EX2,
-	ILSEL_EX3,
-	ILSEL_EX4,
-
-	/* ILSEL1 and 3 */
-	ILSEL_FPGA2 = ILSEL_FPGA0,
-	ILSEL_FPGA3 = ILSEL_FPGA1,
-	ILSEL_EX5 = ILSEL_EX1,
-	ILSEL_EX6 = ILSEL_EX2,
-	ILSEL_EX7 = ILSEL_EX3,
-	ILSEL_EX8 = ILSEL_EX4,
-} ilsel_source_t;
-
-/* arch/sh/boards/renesas/x3proto/ilsel.c */
-int ilsel_enable(ilsel_source_t set);
-int ilsel_enable_fixed(ilsel_source_t set, unsigned int level);
-void ilsel_disable(unsigned int irq);
-
-#endif /* __ASM_SH_ILSEL_H */
diff --git a/arch/sh/include/uapi/asm/Kbuild b/arch/sh/include/uapi/asm/Kbuild
deleted file mode 100644
index b8812c74c1dee1..00000000000000
--- a/arch/sh/include/uapi/asm/Kbuild
+++ /dev/null
@@ -1,4 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-
-generated-y += unistd_32.h
-generic-y += ucontext.h
diff --git a/arch/sh/include/uapi/asm/auxvec.h b/arch/sh/include/uapi/asm/auxvec.h
deleted file mode 100644
index 8eb47ede7193c1..00000000000000
--- a/arch/sh/include/uapi/asm/auxvec.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
-#ifndef __ASM_SH_AUXVEC_H
-#define __ASM_SH_AUXVEC_H
-
-/*
- * Architecture-neutral AT_ values in 0-17, leave some room
- * for more of them.
- */
-
-/*
- * This entry gives some information about the FPU initialization
- * performed by the kernel.
- */
-#define AT_FPUCW		18	/* Used FPU control word.  */
-
-#if defined(CONFIG_VSYSCALL) || !defined(__KERNEL__)
-/*
- * Only define this in the vsyscall case, the entry point to
- * the vsyscall page gets placed here. The kernel will attempt
- * to build a gate VMA we don't care about otherwise..
- */
-#define AT_SYSINFO_EHDR		33
-#endif
-
-/*
- * More complete cache descriptions than AT_[DIU]CACHEBSIZE.  If the
- * value is -1, then the cache doesn't exist.  Otherwise:
- *
- *    bit 0-3:	  Cache set-associativity; 0 means fully associative.
- *    bit 4-7:	  Log2 of cacheline size.
- *    bit 8-31:	  Size of the entire cache >> 8.
- */
-#define AT_L1I_CACHESHAPE	34
-#define AT_L1D_CACHESHAPE	35
-#define AT_L2_CACHESHAPE	36
-
-#define AT_VECTOR_SIZE_ARCH 5 /* entries in ARCH_DLINFO */
-
-#endif /* __ASM_SH_AUXVEC_H */
diff --git a/arch/sh/include/uapi/asm/byteorder.h b/arch/sh/include/uapi/asm/byteorder.h
deleted file mode 100644
index e27d6da3212ca1..00000000000000
--- a/arch/sh/include/uapi/asm/byteorder.h
+++ /dev/null
@@ -1,11 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
-#ifndef __ASM_SH_BYTEORDER_H
-#define __ASM_SH_BYTEORDER_H
-
-#ifdef __LITTLE_ENDIAN__
-#include <linux/byteorder/little_endian.h>
-#else
-#include <linux/byteorder/big_endian.h>
-#endif
-
-#endif /* __ASM_SH_BYTEORDER_H */
diff --git a/arch/sh/include/uapi/asm/cachectl.h b/arch/sh/include/uapi/asm/cachectl.h
deleted file mode 100644
index 79c5663251a528..00000000000000
--- a/arch/sh/include/uapi/asm/cachectl.h
+++ /dev/null
@@ -1,20 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
-#ifndef _SH_CACHECTL_H
-#define _SH_CACHECTL_H
-
-/* Definitions for the cacheflush system call.  */
-
-#define CACHEFLUSH_D_INVAL	0x1	/* invalidate (without write back) */
-#define CACHEFLUSH_D_WB		0x2	/* write back (without invalidate) */
-#define CACHEFLUSH_D_PURGE	0x3	/* writeback and invalidate */
-
-#define CACHEFLUSH_I		0x4
-
-/*
- * Options for cacheflush system call
- */
-#define ICACHE	CACHEFLUSH_I		/* flush instruction cache */
-#define DCACHE	CACHEFLUSH_D_PURGE	/* writeback and flush data cache */
-#define BCACHE	(ICACHE|DCACHE)		/* flush both caches */
-
-#endif /* _SH_CACHECTL_H */
diff --git a/arch/sh/include/uapi/asm/cpu-features.h b/arch/sh/include/uapi/asm/cpu-features.h
deleted file mode 100644
index 6de5f65194e634..00000000000000
--- a/arch/sh/include/uapi/asm/cpu-features.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
-#ifndef __ASM_SH_CPU_FEATURES_H
-#define __ASM_SH_CPU_FEATURES_H
-
-/*
- * Processor flags
- *
- * Note: When adding a new flag, keep cpu_flags[] in
- * arch/sh/kernel/setup.c in sync so symbolic name
- * mapping of the processor flags has a chance of being
- * reasonably accurate.
- *
- * These flags are also available through the ELF
- * auxiliary vector as AT_HWCAP.
- */
-#define CPU_HAS_FPU		0x0001	/* Hardware FPU support */
-#define CPU_HAS_P2_FLUSH_BUG	0x0002	/* Need to flush the cache in P2 area */
-#define CPU_HAS_MMU_PAGE_ASSOC	0x0004	/* SH3: TLB way selection bit support */
-#define CPU_HAS_DSP		0x0008	/* SH-DSP: DSP support */
-#define CPU_HAS_PERF_COUNTER	0x0010	/* Hardware performance counters */
-#define CPU_HAS_PTEA		0x0020	/* PTEA register */
-#define CPU_HAS_LLSC		0x0040	/* movli.l/movco.l */
-#define CPU_HAS_L2_CACHE	0x0080	/* Secondary cache / URAM */
-#define CPU_HAS_OP32		0x0100	/* 32-bit instruction support */
-#define CPU_HAS_PTEAEX		0x0200	/* PTE ASID Extension support */
-#define CPU_HAS_CAS_L		0x0400	/* cas.l atomic compare-and-swap */
-
-#endif /* __ASM_SH_CPU_FEATURES_H */
diff --git a/arch/sh/include/uapi/asm/hw_breakpoint.h b/arch/sh/include/uapi/asm/hw_breakpoint.h
deleted file mode 100644
index 043dd4b9202630..00000000000000
--- a/arch/sh/include/uapi/asm/hw_breakpoint.h
+++ /dev/null
@@ -1,5 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
-/*
- * There isn't anything here anymore, but the file must not be empty or patch
- * will delete it.
- */
diff --git a/arch/sh/include/uapi/asm/ioctls.h b/arch/sh/include/uapi/asm/ioctls.h
deleted file mode 100644
index 11866d4f60e167..00000000000000
--- a/arch/sh/include/uapi/asm/ioctls.h
+++ /dev/null
@@ -1,116 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
-#ifndef __ASM_SH_IOCTLS_H
-#define __ASM_SH_IOCTLS_H
-
-#include <asm/ioctl.h>
-
-#define FIOCLEX		_IO('f', 1)
-#define FIONCLEX	_IO('f', 2)
-#define FIOASYNC	_IOW('f', 125, int)
-#define FIONBIO		_IOW('f', 126, int)
-#define FIONREAD	_IOR('f', 127, int)
-#define TIOCINQ		FIONREAD
-#define FIOQSIZE	_IOR('f', 128, loff_t)
-
-#define TCGETS		0x5401
-#define TCSETS		0x5402
-#define TCSETSW		0x5403
-#define TCSETSF		0x5404
-
-#define TCGETA		0x80127417	/* _IOR('t', 23, struct termio) */
-#define TCSETA		0x40127418	/* _IOW('t', 24, struct termio) */
-#define TCSETAW		0x40127419	/* _IOW('t', 25, struct termio) */
-#define TCSETAF		0x4012741C	/* _IOW('t', 28, struct termio) */
-
-#define TCSBRK		_IO('t', 29)
-#define TCXONC		_IO('t', 30)
-#define TCFLSH		_IO('t', 31)
-
-#define TIOCSWINSZ	0x40087467	/* _IOW('t', 103, struct winsize) */
-#define TIOCGWINSZ	0x80087468	/* _IOR('t', 104, struct winsize) */
-#define	TIOCSTART	_IO('t', 110)		/* start output, like ^Q */
-#define	TIOCSTOP	_IO('t', 111)		/* stop output, like ^S */
-#define TIOCOUTQ        _IOR('t', 115, int)     /* output queue size */
-
-#define TIOCSPGRP	_IOW('t', 118, int)
-#define TIOCGPGRP	_IOR('t', 119, int)
-
-#define TIOCEXCL	_IO('T', 12) /* 0x540C */
-#define TIOCNXCL	_IO('T', 13) /* 0x540D */
-#define TIOCSCTTY	_IO('T', 14) /* 0x540E */
-
-#define TIOCSTI		_IOW('T', 18, char) /* 0x5412 */
-#define TIOCMGET	_IOR('T', 21, unsigned int) /* 0x5415 */
-#define TIOCMBIS	_IOW('T', 22, unsigned int) /* 0x5416 */
-#define TIOCMBIC	_IOW('T', 23, unsigned int) /* 0x5417 */
-#define TIOCMSET	_IOW('T', 24, unsigned int) /* 0x5418 */
-# define TIOCM_LE	0x001
-# define TIOCM_DTR	0x002
-# define TIOCM_RTS	0x004
-# define TIOCM_ST	0x008
-# define TIOCM_SR	0x010
-# define TIOCM_CTS	0x020
-# define TIOCM_CAR	0x040
-# define TIOCM_RNG	0x080
-# define TIOCM_DSR	0x100
-# define TIOCM_CD	TIOCM_CAR
-# define TIOCM_RI	TIOCM_RNG
-
-#define TIOCGSOFTCAR	_IOR('T', 25, unsigned int) /* 0x5419 */
-#define TIOCSSOFTCAR	_IOW('T', 26, unsigned int) /* 0x541A */
-#define TIOCLINUX	_IOW('T', 28, char) /* 0x541C */
-#define TIOCCONS	_IO('T', 29) /* 0x541D */
-#define TIOCGSERIAL	0x803C541E	/* _IOR('T', 30, struct serial_struct) 0x541E */
-#define TIOCSSERIAL	0x403C541F	/* _IOW('T', 31, struct serial_struct) 0x541F */
-#define TIOCPKT		_IOW('T', 32, int) /* 0x5420 */
-# define TIOCPKT_DATA		 0
-# define TIOCPKT_FLUSHREAD	 1
-# define TIOCPKT_FLUSHWRITE	 2
-# define TIOCPKT_STOP		 4
-# define TIOCPKT_START		 8
-# define TIOCPKT_NOSTOP		16
-# define TIOCPKT_DOSTOP		32
-# define TIOCPKT_IOCTL		64
-
-
-#define TIOCNOTTY	_IO('T', 34) /* 0x5422 */
-#define TIOCSETD	_IOW('T', 35, int) /* 0x5423 */
-#define TIOCGETD	_IOR('T', 36, int) /* 0x5424 */
-#define TCSBRKP		_IOW('T', 37, int) /* 0x5425 */	/* Needed for POSIX tcsendbreak() */
-#define TIOCSBRK	_IO('T', 39) /* 0x5427 */ /* BSD compatibility */
-#define TIOCCBRK	_IO('T', 40) /* 0x5428 */ /* BSD compatibility */
-#define TIOCGSID	_IOR('T', 41, pid_t) /* 0x5429 */ /* Return the session ID of FD */
-#define TCGETS2		_IOR('T', 42, struct termios2)
-#define TCSETS2		_IOW('T', 43, struct termios2)
-#define TCSETSW2	_IOW('T', 44, struct termios2)
-#define TCSETSF2	_IOW('T', 45, struct termios2)
-#define TIOCGRS485	_IOR('T', 46, struct serial_rs485)
-#define TIOCSRS485	_IOWR('T', 47, struct serial_rs485)
-#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
-#define TIOCSPTLCK	_IOW('T',0x31, int)  /* Lock/unlock Pty */
-#define TIOCGDEV	_IOR('T',0x32, unsigned int) /* Get primary device node of /dev/console */
-#define TIOCSIG		_IOW('T',0x36, int)  /* Generate signal on Pty slave */
-#define TIOCVHANGUP	_IO('T', 0x37)
-#define TIOCGPKT	_IOR('T', 0x38, int) /* Get packet mode state */
-#define TIOCGPTLCK	_IOR('T', 0x39, int) /* Get Pty lock state */
-#define TIOCGEXCL	_IOR('T', 0x40, int) /* Get exclusive mode state */
-#define TIOCGPTPEER	_IO('T', 0x41) /* Safely open the slave */
-#define TIOCGISO7816	_IOR('T', 0x42, struct serial_iso7816)
-#define TIOCSISO7816	_IOWR('T', 0x43, struct serial_iso7816)
-
-#define TIOCSERCONFIG	_IO('T', 83) /* 0x5453 */
-#define TIOCSERGWILD	_IOR('T', 84,  int) /* 0x5454 */
-#define TIOCSERSWILD	_IOW('T', 85,  int) /* 0x5455 */
-#define TIOCGLCKTRMIOS	0x5456
-#define TIOCSLCKTRMIOS	0x5457
-#define TIOCSERGSTRUCT	0x80d85458	/* _IOR('T', 88, struct async_struct) 0x5458 */ /* For debugging only */
-#define TIOCSERGETLSR   _IOR('T', 89, unsigned int) /* 0x5459 */ /* Get line status register */
-  /* ioctl (fd, TIOCSERGETLSR, &result) where result may be as below */
-# define TIOCSER_TEMT    0x01	/* Transmitter physically empty */
-#define TIOCSERGETMULTI 0x80A8545A	/* _IOR('T', 90, struct serial_multiport_struct) 0x545A */ /* Get multiport config */
-#define TIOCSERSETMULTI 0x40A8545B	/* _IOW('T', 91, struct serial_multiport_struct) 0x545B */ /* Set multiport config */
-
-#define TIOCMIWAIT	_IO('T', 92) /* 0x545C */	/* wait for a change on serial input line(s) */
-#define TIOCGICOUNT	0x545D	/* read serial port inline interrupt counts */
-
-#endif /* __ASM_SH_IOCTLS_H */
diff --git a/arch/sh/include/uapi/asm/posix_types.h b/arch/sh/include/uapi/asm/posix_types.h
deleted file mode 100644
index adc998a64c769f..00000000000000
--- a/arch/sh/include/uapi/asm/posix_types.h
+++ /dev/null
@@ -1,2 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
-#include <asm/posix_types_32.h>
diff --git a/arch/sh/include/uapi/asm/posix_types_32.h b/arch/sh/include/uapi/asm/posix_types_32.h
deleted file mode 100644
index ea0f51d1ac554b..00000000000000
--- a/arch/sh/include/uapi/asm/posix_types_32.h
+++ /dev/null
@@ -1,23 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
-#ifndef __ASM_SH_POSIX_TYPES_32_H
-#define __ASM_SH_POSIX_TYPES_32_H
-
-typedef unsigned short	__kernel_mode_t;
-#define __kernel_mode_t __kernel_mode_t
-typedef unsigned short	__kernel_ipc_pid_t;
-#define __kernel_ipc_pid_t __kernel_ipc_pid_t
-typedef unsigned short	__kernel_uid_t;
-#define __kernel_uid_t __kernel_uid_t
-typedef unsigned short	__kernel_gid_t;
-#define __kernel_gid_t __kernel_gid_t
-
-typedef unsigned short	__kernel_old_uid_t;
-#define __kernel_old_uid_t __kernel_old_uid_t
-typedef unsigned short	__kernel_old_gid_t;
-#define __kernel_old_gid_t __kernel_old_gid_t
-typedef unsigned short	__kernel_old_dev_t;
-#define __kernel_old_dev_t __kernel_old_dev_t
-
-#include <asm-generic/posix_types.h>
-
-#endif /* __ASM_SH_POSIX_TYPES_32_H */
diff --git a/arch/sh/include/uapi/asm/ptrace.h b/arch/sh/include/uapi/asm/ptrace.h
deleted file mode 100644
index 5c88e46b77731a..00000000000000
--- a/arch/sh/include/uapi/asm/ptrace.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
-/*
- * Copyright (C) 1999, 2000  Niibe Yutaka
- */
-#ifndef _UAPI__ASM_SH_PTRACE_H
-#define _UAPI__ASM_SH_PTRACE_H
-
-
-#define PTRACE_GETREGS		12	/* General registers */
-#define PTRACE_SETREGS		13
-
-#define PTRACE_GETFPREGS	14	/* FPU registers */
-#define PTRACE_SETFPREGS	15
-
-#define PTRACE_GETFDPIC		31	/* get the ELF fdpic loadmap address */
-
-#define PTRACE_GETFDPIC_EXEC	0	/* [addr] request the executable loadmap */
-#define PTRACE_GETFDPIC_INTERP	1	/* [addr] request the interpreter loadmap */
-
-#define	PTRACE_GETDSPREGS	55	/* DSP registers */
-#define	PTRACE_SETDSPREGS	56
-
-#define PT_TEXT_END_ADDR	240
-#define PT_TEXT_ADDR		244	/* &(struct user)->start_code */
-#define PT_DATA_ADDR		248	/* &(struct user)->start_data */
-#define PT_TEXT_LEN		252
-
-#include <asm/ptrace_32.h>
-
-#endif /* _UAPI__ASM_SH_PTRACE_H */
diff --git a/arch/sh/include/uapi/asm/ptrace_32.h b/arch/sh/include/uapi/asm/ptrace_32.h
deleted file mode 100644
index dc8a26015018af..00000000000000
--- a/arch/sh/include/uapi/asm/ptrace_32.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
-#ifndef _UAPI__ASM_SH_PTRACE_32_H
-#define _UAPI__ASM_SH_PTRACE_32_H
-
-/*
- * GCC defines register number like this:
- * -----------------------------
- *	 0 - 15 are integer registers
- *	17 - 22 are control/special registers
- *	24 - 39 fp registers
- *	40 - 47 xd registers
- *	48 -    fpscr register
- * -----------------------------
- *
- * We follows above, except:
- *	16 --- program counter (PC)
- *	22 --- syscall #
- *	23 --- floating point communication register
- */
-#define REG_REG0	 0
-#define REG_REG15	15
-
-#define REG_PC		16
-
-#define REG_PR		17
-#define REG_SR		18
-#define REG_GBR		19
-#define REG_MACH	20
-#define REG_MACL	21
-
-#define REG_SYSCALL	22
-
-#define REG_FPREG0	23
-#define REG_FPREG15	38
-#define REG_XFREG0	39
-#define REG_XFREG15	54
-
-#define REG_FPSCR	55
-#define REG_FPUL	56
-
-/*
- * This struct defines the way the registers are stored on the
- * kernel stack during a system call or other kernel entry.
- */
-struct pt_regs {
-	unsigned long regs[16];
-	unsigned long pc;
-	unsigned long pr;
-	unsigned long sr;
-	unsigned long gbr;
-	unsigned long mach;
-	unsigned long macl;
-	long tra;
-};
-
-/*
- * This struct defines the way the DSP registers are stored on the
- * kernel stack during a system call or other kernel entry.
- */
-struct pt_dspregs {
-	unsigned long	a1;
-	unsigned long	a0g;
-	unsigned long	a1g;
-	unsigned long	m0;
-	unsigned long	m1;
-	unsigned long	a0;
-	unsigned long	x0;
-	unsigned long	x1;
-	unsigned long	y0;
-	unsigned long	y1;
-	unsigned long	dsr;
-	unsigned long	rs;
-	unsigned long	re;
-	unsigned long	mod;
-};
-
-
-#endif /* _UAPI__ASM_SH_PTRACE_32_H */
diff --git a/arch/sh/include/uapi/asm/sigcontext.h b/arch/sh/include/uapi/asm/sigcontext.h
deleted file mode 100644
index a9cc8bad0f36df..00000000000000
--- a/arch/sh/include/uapi/asm/sigcontext.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
-#ifndef __ASM_SH_SIGCONTEXT_H
-#define __ASM_SH_SIGCONTEXT_H
-
-struct sigcontext {
-	unsigned long	oldmask;
-
-	/* CPU registers */
-	unsigned long sc_regs[16];
-	unsigned long sc_pc;
-	unsigned long sc_pr;
-	unsigned long sc_sr;
-	unsigned long sc_gbr;
-	unsigned long sc_mach;
-	unsigned long sc_macl;
-
-	/* FPU registers */
-	unsigned long sc_fpregs[16];
-	unsigned long sc_xfpregs[16];
-	unsigned int sc_fpscr;
-	unsigned int sc_fpul;
-	unsigned int sc_ownedfp;
-};
-
-#endif /* __ASM_SH_SIGCONTEXT_H */
diff --git a/arch/sh/include/uapi/asm/signal.h b/arch/sh/include/uapi/asm/signal.h
deleted file mode 100644
index 97299daddef5dc..00000000000000
--- a/arch/sh/include/uapi/asm/signal.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
-#ifndef __ASM_SH_SIGNAL_H
-#define __ASM_SH_SIGNAL_H
-
-#define SA_RESTORER	0x04000000
-
-#include <asm-generic/signal.h>
-
-#ifndef __KERNEL__
-struct old_sigaction {
-	__sighandler_t sa_handler;
-	old_sigset_t sa_mask;
-	unsigned long sa_flags;
-	void (*sa_restorer)(void);
-};
-#endif
-
-#endif /* __ASM_SH_SIGNAL_H */
diff --git a/arch/sh/include/uapi/asm/sockios.h b/arch/sh/include/uapi/asm/sockios.h
deleted file mode 100644
index ef01ced9e16963..00000000000000
--- a/arch/sh/include/uapi/asm/sockios.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
-#ifndef __ASM_SH_SOCKIOS_H
-#define __ASM_SH_SOCKIOS_H
-
-#include <linux/time_types.h>
-
-/* Socket-level I/O control calls. */
-#define FIOGETOWN	_IOR('f', 123, int)
-#define FIOSETOWN 	_IOW('f', 124, int)
-
-#define SIOCATMARK	_IOR('s', 7, int)
-#define SIOCSPGRP	_IOW('s', 8, pid_t)
-#define SIOCGPGRP	_IOR('s', 9, pid_t)
-
-#define SIOCGSTAMP_OLD	_IOR('s', 100, struct __kernel_old_timeval) /* Get stamp (timeval) */
-#define SIOCGSTAMPNS_OLD _IOR('s', 101, struct __kernel_old_timespec) /* Get stamp (timespec) */
-
-#endif /* __ASM_SH_SOCKIOS_H */
diff --git a/arch/sh/include/uapi/asm/stat.h b/arch/sh/include/uapi/asm/stat.h
deleted file mode 100644
index b0ca755ea08d99..00000000000000
--- a/arch/sh/include/uapi/asm/stat.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
-#ifndef __ASM_SH_STAT_H
-#define __ASM_SH_STAT_H
-
-struct __old_kernel_stat {
-	unsigned short st_dev;
-	unsigned short st_ino;
-	unsigned short st_mode;
-	unsigned short st_nlink;
-	unsigned short st_uid;
-	unsigned short st_gid;
-	unsigned short st_rdev;
-	unsigned long  st_size;
-	unsigned long  st_atime;
-	unsigned long  st_mtime;
-	unsigned long  st_ctime;
-};
-
-struct stat {
-	unsigned long  st_dev;
-	unsigned long  st_ino;
-	unsigned short st_mode;
-	unsigned short st_nlink;
-	unsigned short st_uid;
-	unsigned short st_gid;
-	unsigned long  st_rdev;
-	unsigned long  st_size;
-	unsigned long  st_blksize;
-	unsigned long  st_blocks;
-	unsigned long  st_atime;
-	unsigned long  st_atime_nsec;
-	unsigned long  st_mtime;
-	unsigned long  st_mtime_nsec;
-	unsigned long  st_ctime;
-	unsigned long  st_ctime_nsec;
-	unsigned long  __unused4;
-	unsigned long  __unused5;
-};
-
-/* This matches struct stat64 in glibc2.1, hence the absolutely
- * insane amounts of padding around dev_t's.
- */
-struct stat64 {
-	unsigned long long	st_dev;
-	unsigned char	__pad0[4];
-
-#define STAT64_HAS_BROKEN_ST_INO	1
-	unsigned long	__st_ino;
-
-	unsigned int	st_mode;
-	unsigned int	st_nlink;
-
-	unsigned long	st_uid;
-	unsigned long	st_gid;
-
-	unsigned long long	st_rdev;
-	unsigned char	__pad3[4];
-
-	long long	st_size;
-	unsigned long	st_blksize;
-
-	unsigned long long	st_blocks;	/* Number 512-byte blocks allocated. */
-
-	unsigned long	st_atime;
-	unsigned long	st_atime_nsec;
-
-	unsigned long	st_mtime;
-	unsigned long	st_mtime_nsec;
-
-	unsigned long	st_ctime;
-	unsigned long	st_ctime_nsec;
-
-	unsigned long long	st_ino;
-};
-
-#define STAT_HAVE_NSEC 1
-
-#endif /* __ASM_SH_STAT_H */
diff --git a/arch/sh/include/uapi/asm/swab.h b/arch/sh/include/uapi/asm/swab.h
deleted file mode 100644
index c727d381a30aff..00000000000000
--- a/arch/sh/include/uapi/asm/swab.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
-#ifndef __ASM_SH_SWAB_H
-#define __ASM_SH_SWAB_H
-
-/*
- * Copyright (C) 1999  Niibe Yutaka
- * Copyright (C) 2000, 2001  Paolo Alberelli
- */
-#include <linux/compiler.h>
-#include <linux/types.h>
-#include <asm-generic/swab.h>
-
-static inline __attribute_const__ __u32 __arch_swab32(__u32 x)
-{
-	__asm__(
-		"swap.b		%1, %0\n\t"
-		"swap.w		%0, %0\n\t"
-		"swap.b		%0, %0"
-		: "=r" (x)
-		: "r" (x));
-
-	return x;
-}
-#define __arch_swab32 __arch_swab32
-
-static inline __attribute_const__ __u16 __arch_swab16(__u16 x)
-{
-	__asm__(
-		"swap.b		%1, %0"
-		: "=r" (x)
-		:  "r" (x));
-
-	return x;
-}
-#define __arch_swab16 __arch_swab16
-
-static inline __u64 __arch_swab64(__u64 val)
-{
-	union {
-		struct { __u32 a,b; } s;
-		__u64 u;
-	} v, w;
-	v.u = val;
-	w.s.b = __arch_swab32(v.s.a);
-	w.s.a = __arch_swab32(v.s.b);
-	return w.u;
-}
-#define __arch_swab64 __arch_swab64
-
-#endif /* __ASM_SH_SWAB_H */
diff --git a/arch/sh/include/uapi/asm/unistd.h b/arch/sh/include/uapi/asm/unistd.h
deleted file mode 100644
index 0f7c7772a2fbfc..00000000000000
--- a/arch/sh/include/uapi/asm/unistd.h
+++ /dev/null
@@ -1,2 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
-#include <asm/unistd_32.h>
diff --git a/arch/sh/kernel/.gitignore b/arch/sh/kernel/.gitignore
deleted file mode 100644
index bbb90f92d05182..00000000000000
--- a/arch/sh/kernel/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-only
-vmlinux.lds
diff --git a/arch/sh/kernel/Makefile b/arch/sh/kernel/Makefile
deleted file mode 100644
index 69cd9ac4b2ab8a..00000000000000
--- a/arch/sh/kernel/Makefile
+++ /dev/null
@@ -1,49 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the Linux/SuperH kernel.
-#
-
-extra-y	:= vmlinux.lds
-
-ifdef CONFIG_FUNCTION_TRACER
-# Do not profile debug and lowlevel utilities
-CFLAGS_REMOVE_ftrace.o = -pg
-endif
-
-CFLAGS_REMOVE_return_address.o = -pg
-
-obj-y	:= head_32.o debugtraps.o dumpstack.o				\
-	   idle.o io.o irq.o irq_32.o kdebugfs.o			\
-	   machvec.o nmi_debug.o process.o				\
-	   process_32.o ptrace.o ptrace_32.o				\
-	   reboot.o return_address.o					\
-	   setup.o signal_32.o sys_sh.o 				\
-	   syscalls_32.o time.o topology.o traps.o			\
-	   traps_32.o unwinder.o
-
-ifndef CONFIG_GENERIC_IOMAP
-obj-y				+= iomap.o
-obj-$(CONFIG_HAS_IOPORT_MAP)	+= ioport.o
-endif
-
-obj-y				+= sys_sh32.o
-obj-y				+= cpu/
-obj-$(CONFIG_VSYSCALL)		+= vsyscall/
-obj-$(CONFIG_SMP)		+= smp.o
-obj-$(CONFIG_SH_STANDARD_BIOS)	+= sh_bios.o
-obj-$(CONFIG_KGDB)		+= kgdb.o
-obj-$(CONFIG_MODULES)		+= sh_ksyms_32.o module.o
-obj-$(CONFIG_KEXEC)		+= machine_kexec.o relocate_kernel.o
-obj-$(CONFIG_CRASH_DUMP)	+= crash_dump.o
-obj-$(CONFIG_STACKTRACE)	+= stacktrace.o
-obj-$(CONFIG_IO_TRAPPED)	+= io_trapped.o
-obj-$(CONFIG_KPROBES)		+= kprobes.o
-obj-$(CONFIG_DYNAMIC_FTRACE)	+= ftrace.o
-obj-$(CONFIG_FTRACE_SYSCALLS)	+= ftrace.o
-obj-$(CONFIG_FUNCTION_GRAPH_TRACER) += ftrace.o
-obj-$(CONFIG_DUMP_CODE)		+= disassemble.o
-obj-$(CONFIG_HIBERNATION)	+= swsusp.o
-obj-$(CONFIG_DWARF_UNWINDER)	+= dwarf.o
-obj-$(CONFIG_PERF_EVENTS)	+= perf_event.o perf_callchain.o
-obj-$(CONFIG_DMA_NONCOHERENT)	+= dma-coherent.o
-obj-$(CONFIG_HAVE_HW_BREAKPOINT)		+= hw_breakpoint.o
diff --git a/arch/sh/kernel/asm-offsets.c b/arch/sh/kernel/asm-offsets.c
deleted file mode 100644
index a0322e8328456e..00000000000000
--- a/arch/sh/kernel/asm-offsets.c
+++ /dev/null
@@ -1,60 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * This program is used to generate definitions needed by
- * assembly language modules.
- *
- * We use the technique used in the OSF Mach kernel code:
- * generate asm statements containing #defines,
- * compile this file to assembler, and then extract the
- * #defines from the assembly-language output.
- */
-
-#include <linux/stddef.h>
-#include <linux/types.h>
-#include <linux/mm.h>
-#include <linux/kbuild.h>
-#include <linux/suspend.h>
-
-#include <asm/thread_info.h>
-#include <asm/suspend.h>
-
-int main(void)
-{
-	/* offsets into the thread_info struct */
-	DEFINE(TI_TASK,		offsetof(struct thread_info, task));
-	DEFINE(TI_FLAGS,	offsetof(struct thread_info, flags));
-	DEFINE(TI_CPU,		offsetof(struct thread_info, cpu));
-	DEFINE(TI_PRE_COUNT,	offsetof(struct thread_info, preempt_count));
-	DEFINE(TI_SIZE,		sizeof(struct thread_info));
-
-#ifdef CONFIG_HIBERNATION
-	DEFINE(PBE_ADDRESS, offsetof(struct pbe, address));
-	DEFINE(PBE_ORIG_ADDRESS, offsetof(struct pbe, orig_address));
-	DEFINE(PBE_NEXT, offsetof(struct pbe, next));
-	DEFINE(SWSUSP_ARCH_REGS_SIZE, sizeof(struct swsusp_arch_regs));
-#endif
-
-	DEFINE(SH_SLEEP_MODE, offsetof(struct sh_sleep_data, mode));
-	DEFINE(SH_SLEEP_SF_PRE, offsetof(struct sh_sleep_data, sf_pre));
-	DEFINE(SH_SLEEP_SF_POST, offsetof(struct sh_sleep_data, sf_post));
-	DEFINE(SH_SLEEP_RESUME, offsetof(struct sh_sleep_data, resume));
-	DEFINE(SH_SLEEP_VBR, offsetof(struct sh_sleep_data, vbr));
-	DEFINE(SH_SLEEP_SPC, offsetof(struct sh_sleep_data, spc));
-	DEFINE(SH_SLEEP_SR, offsetof(struct sh_sleep_data, sr));
-	DEFINE(SH_SLEEP_SP, offsetof(struct sh_sleep_data, sp));
-	DEFINE(SH_SLEEP_BASE_ADDR, offsetof(struct sh_sleep_data, addr));
-	DEFINE(SH_SLEEP_BASE_DATA, offsetof(struct sh_sleep_data, data));
-	DEFINE(SH_SLEEP_REG_STBCR, offsetof(struct sh_sleep_regs, stbcr));
-	DEFINE(SH_SLEEP_REG_BAR, offsetof(struct sh_sleep_regs, bar));
-	DEFINE(SH_SLEEP_REG_PTEH, offsetof(struct sh_sleep_regs, pteh));
-	DEFINE(SH_SLEEP_REG_PTEL, offsetof(struct sh_sleep_regs, ptel));
-	DEFINE(SH_SLEEP_REG_TTB, offsetof(struct sh_sleep_regs, ttb));
-	DEFINE(SH_SLEEP_REG_TEA, offsetof(struct sh_sleep_regs, tea));
-	DEFINE(SH_SLEEP_REG_MMUCR, offsetof(struct sh_sleep_regs, mmucr));
-	DEFINE(SH_SLEEP_REG_PTEA, offsetof(struct sh_sleep_regs, ptea));
-	DEFINE(SH_SLEEP_REG_PASCR, offsetof(struct sh_sleep_regs, pascr));
-	DEFINE(SH_SLEEP_REG_IRMCR, offsetof(struct sh_sleep_regs, irmcr));
-	DEFINE(SH_SLEEP_REG_CCR, offsetof(struct sh_sleep_regs, ccr));
-	DEFINE(SH_SLEEP_REG_RAMCR, offsetof(struct sh_sleep_regs, ramcr));
-	return 0;
-}
diff --git a/arch/sh/kernel/cpu/Makefile b/arch/sh/kernel/cpu/Makefile
deleted file mode 100644
index 46118236bf0499..00000000000000
--- a/arch/sh/kernel/cpu/Makefile
+++ /dev/null
@@ -1,21 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the Linux/SuperH CPU-specific backends.
-#
-
-obj-$(CONFIG_CPU_SH2)		= sh2/
-obj-$(CONFIG_CPU_SH2A)		= sh2a/
-obj-$(CONFIG_CPU_SH3)		= sh3/
-obj-$(CONFIG_CPU_SH4)		= sh4/
-
-# Special cases for family ancestry.
-
-obj-$(CONFIG_CPU_SH4A)		+= sh4a/
-obj-$(CONFIG_ARCH_SHMOBILE)	+= shmobile/
-
-# Common interfaces.
-
-obj-$(CONFIG_SH_ADC)		+= adc.o
-obj-$(CONFIG_SH_CLK_CPG_LEGACY)	+= clock-cpg.o
-
-obj-y	+= irq/ init.o clock.o fpu.o pfc.o proc.o
diff --git a/arch/sh/kernel/cpu/adc.c b/arch/sh/kernel/cpu/adc.c
deleted file mode 100644
index 509136715ed53c..00000000000000
--- a/arch/sh/kernel/cpu/adc.c
+++ /dev/null
@@ -1,37 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/kernel/adc.c -- SH3 on-chip ADC support
- *
- *  Copyright (C) 2004  Andriy Skulysh <askulysh@image.kiev.ua>
- */
-
-#include <linux/module.h>
-#include <asm/adc.h>
-#include <asm/io.h>
-
-
-int adc_single(unsigned int channel)
-{
-	int off;
-	unsigned char csr;
-
-	if (channel >= 8) return -1;
-
-	off = (channel & 0x03) << 2;
-
-	csr = __raw_readb(ADCSR);
-	csr = channel | ADCSR_ADST | ADCSR_CKS;
-	__raw_writeb(csr, ADCSR);
-
-	do {
-		csr = __raw_readb(ADCSR);
-	} while ((csr & ADCSR_ADF) == 0);
-
-	csr &= ~(ADCSR_ADF | ADCSR_ADST);
-	__raw_writeb(csr, ADCSR);
-
-	return (((__raw_readb(ADDRAH + off) << 8) |
-		__raw_readb(ADDRAL + off)) >> 6);
-}
-
-EXPORT_SYMBOL(adc_single);
diff --git a/arch/sh/kernel/cpu/clock-cpg.c b/arch/sh/kernel/cpu/clock-cpg.c
deleted file mode 100644
index 5b75a384cbf349..00000000000000
--- a/arch/sh/kernel/cpu/clock-cpg.c
+++ /dev/null
@@ -1,78 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/clk.h>
-#include <linux/compiler.h>
-#include <linux/slab.h>
-#include <linux/io.h>
-#include <linux/clkdev.h>
-#include <asm/clock.h>
-
-static struct clk master_clk = {
-	.flags		= CLK_ENABLE_ON_INIT,
-	.rate		= CONFIG_SH_PCLK_FREQ,
-};
-
-static struct clk peripheral_clk = {
-	.parent		= &master_clk,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-static struct clk bus_clk = {
-	.parent		= &master_clk,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-static struct clk cpu_clk = {
-	.parent		= &master_clk,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-/*
- * The ordering of these clocks matters, do not change it.
- */
-static struct clk *onchip_clocks[] = {
-	&master_clk,
-	&peripheral_clk,
-	&bus_clk,
-	&cpu_clk,
-};
-
-static struct clk_lookup lookups[] = {
-	/* main clocks */
-	CLKDEV_CON_ID("master_clk", &master_clk),
-	CLKDEV_CON_ID("peripheral_clk", &peripheral_clk),
-	CLKDEV_CON_ID("bus_clk", &bus_clk),
-	CLKDEV_CON_ID("cpu_clk", &cpu_clk),
-};
-
-int __init __deprecated cpg_clk_init(void)
-{
-	int i, ret = 0;
-
-	for (i = 0; i < ARRAY_SIZE(onchip_clocks); i++) {
-		struct clk *clk = onchip_clocks[i];
-		arch_init_clk_ops(&clk->ops, i);
-		if (clk->ops)
-			ret |= clk_register(clk);
-	}
-
-	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
-
-	clk_add_alias("fck", "sh-tmu-sh3.0", "peripheral_clk", NULL);
-	clk_add_alias("fck", "sh-tmu.0", "peripheral_clk", NULL);
-	clk_add_alias("fck", "sh-tmu.1", "peripheral_clk", NULL);
-	clk_add_alias("fck", "sh-tmu.2", "peripheral_clk", NULL);
-	clk_add_alias("fck", "sh-mtu2", "peripheral_clk", NULL);
-	clk_add_alias("fck", "sh-cmt-16.0", "peripheral_clk", NULL);
-	clk_add_alias("fck", "sh-cmt-32.0", "peripheral_clk", NULL);
-
-	return ret;
-}
-
-/*
- * Placeholder for compatibility, until the lazy CPUs do this
- * on their own.
- */
-int __init __weak arch_clk_init(void)
-{
-	return cpg_clk_init();
-}
diff --git a/arch/sh/kernel/cpu/clock.c b/arch/sh/kernel/cpu/clock.c
deleted file mode 100644
index 6fb34410d630a5..00000000000000
--- a/arch/sh/kernel/cpu/clock.c
+++ /dev/null
@@ -1,52 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/clock.c - SuperH clock framework
- *
- *  Copyright (C) 2005 - 2009  Paul Mundt
- *
- * This clock framework is derived from the OMAP version by:
- *
- *	Copyright (C) 2004 - 2008 Nokia Corporation
- *	Written by Tuukka Tikkanen <tuukka.tikkanen@elektrobit.com>
- *
- *  Modified for omap shared clock framework by Tony Lindgren <tony@atomide.com>
- */
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/clk.h>
-#include <asm/clock.h>
-#include <asm/machvec.h>
-
-int __init clk_init(void)
-{
-	int ret;
-
-#ifndef CONFIG_COMMON_CLK
-	ret = arch_clk_init();
-	if (unlikely(ret)) {
-		pr_err("%s: CPU clock registration failed.\n", __func__);
-		return ret;
-	}
-#endif
-
-	if (sh_mv.mv_clk_init) {
-		ret = sh_mv.mv_clk_init();
-		if (unlikely(ret)) {
-			pr_err("%s: machvec clock initialization failed.\n",
-			       __func__);
-			return ret;
-		}
-	}
-
-#ifndef CONFIG_COMMON_CLK
-	/* Kick the child clocks.. */
-	recalculate_root_clocks();
-
-	/* Enable the necessary init clocks */
-	clk_enable_init_clocks();
-#endif
-
-	return ret;
-}
-
-
diff --git a/arch/sh/kernel/cpu/fpu.c b/arch/sh/kernel/cpu/fpu.c
deleted file mode 100644
index fd6db0ab19288f..00000000000000
--- a/arch/sh/kernel/cpu/fpu.c
+++ /dev/null
@@ -1,92 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/sched/signal.h>
-#include <linux/sched/task.h>
-#include <linux/sched/task_stack.h>
-#include <linux/slab.h>
-#include <asm/processor.h>
-#include <asm/fpu.h>
-#include <asm/traps.h>
-#include <asm/ptrace.h>
-
-int init_fpu(struct task_struct *tsk)
-{
-	if (tsk_used_math(tsk)) {
-		if ((boot_cpu_data.flags & CPU_HAS_FPU) && tsk == current)
-			unlazy_fpu(tsk, task_pt_regs(tsk));
-		return 0;
-	}
-
-	/*
-	 * Memory allocation at the first usage of the FPU and other state.
-	 */
-	if (!tsk->thread.xstate) {
-		tsk->thread.xstate = kmem_cache_alloc(task_xstate_cachep,
-						      GFP_KERNEL);
-		if (!tsk->thread.xstate)
-			return -ENOMEM;
-	}
-
-	if (boot_cpu_data.flags & CPU_HAS_FPU) {
-		struct sh_fpu_hard_struct *fp = &tsk->thread.xstate->hardfpu;
-		memset(fp, 0, xstate_size);
-		fp->fpscr = FPSCR_INIT;
-	} else {
-		struct sh_fpu_soft_struct *fp = &tsk->thread.xstate->softfpu;
-		memset(fp, 0, xstate_size);
-		fp->fpscr = FPSCR_INIT;
-	}
-
-	set_stopped_child_used_math(tsk);
-	return 0;
-}
-
-#ifdef CONFIG_SH_FPU
-void __fpu_state_restore(void)
-{
-	struct task_struct *tsk = current;
-
-	restore_fpu(tsk);
-
-	task_thread_info(tsk)->status |= TS_USEDFPU;
-	tsk->thread.fpu_counter++;
-}
-
-void fpu_state_restore(struct pt_regs *regs)
-{
-	struct task_struct *tsk = current;
-
-	if (unlikely(!user_mode(regs))) {
-		printk(KERN_ERR "BUG: FPU is used in kernel mode.\n");
-		BUG();
-		return;
-	}
-
-	if (!tsk_used_math(tsk)) {
-		int ret;
-		/*
-		 * does a slab alloc which can sleep
-		 */
-		local_irq_enable();
-		ret = init_fpu(tsk);
-		local_irq_disable();
-		if (ret) {
-			/*
-			 * ran out of memory!
-			 */
-			force_sig(SIGKILL);
-			return;
-		}
-	}
-
-	grab_fpu(regs);
-
-	__fpu_state_restore();
-}
-
-BUILD_TRAP_HANDLER(fpu_state_restore)
-{
-	TRAP_HANDLER_DECL;
-
-	fpu_state_restore(regs);
-}
-#endif /* CONFIG_SH_FPU */
diff --git a/arch/sh/kernel/cpu/init.c b/arch/sh/kernel/cpu/init.c
deleted file mode 100644
index 1d008745877ff8..00000000000000
--- a/arch/sh/kernel/cpu/init.c
+++ /dev/null
@@ -1,366 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/init.c
- *
- * CPU init code
- *
- * Copyright (C) 2002 - 2009  Paul Mundt
- * Copyright (C) 2003  Richard Curnow
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/mm.h>
-#include <linux/log2.h>
-#include <asm/mmu_context.h>
-#include <asm/processor.h>
-#include <linux/uaccess.h>
-#include <asm/page.h>
-#include <asm/cacheflush.h>
-#include <asm/cache.h>
-#include <asm/elf.h>
-#include <asm/io.h>
-#include <asm/smp.h>
-#include <asm/sh_bios.h>
-#include <asm/setup.h>
-
-#ifdef CONFIG_SH_FPU
-#define cpu_has_fpu	1
-#else
-#define cpu_has_fpu	0
-#endif
-
-#ifdef CONFIG_SH_DSP
-#define cpu_has_dsp	1
-#else
-#define cpu_has_dsp	0
-#endif
-
-/*
- * Generic wrapper for command line arguments to disable on-chip
- * peripherals (nofpu, nodsp, and so forth).
- */
-#define onchip_setup(x)					\
-static int x##_disabled = !cpu_has_##x;			\
-							\
-static int x##_setup(char *opts)			\
-{							\
-	x##_disabled = 1;				\
-	return 1;					\
-}							\
-__setup("no" __stringify(x), x##_setup);
-
-onchip_setup(fpu);
-onchip_setup(dsp);
-
-#ifdef CONFIG_SPECULATIVE_EXECUTION
-#define CPUOPM		0xff2f0000
-#define CPUOPM_RABD	(1 << 5)
-
-static void speculative_execution_init(void)
-{
-	/* Clear RABD */
-	__raw_writel(__raw_readl(CPUOPM) & ~CPUOPM_RABD, CPUOPM);
-
-	/* Flush the update */
-	(void)__raw_readl(CPUOPM);
-	ctrl_barrier();
-}
-#else
-#define speculative_execution_init()	do { } while (0)
-#endif
-
-#ifdef CONFIG_CPU_SH4A
-#define EXPMASK			0xff2f0004
-#define EXPMASK_RTEDS		(1 << 0)
-#define EXPMASK_BRDSSLP		(1 << 1)
-#define EXPMASK_MMCAW		(1 << 4)
-
-static void expmask_init(void)
-{
-	unsigned long expmask = __raw_readl(EXPMASK);
-
-	/*
-	 * Future proofing.
-	 *
-	 * Disable support for slottable sleep instruction, non-nop
-	 * instructions in the rte delay slot, and associative writes to
-	 * the memory-mapped cache array.
-	 */
-	expmask &= ~(EXPMASK_RTEDS | EXPMASK_BRDSSLP | EXPMASK_MMCAW);
-
-	__raw_writel(expmask, EXPMASK);
-	ctrl_barrier();
-}
-#else
-#define expmask_init()	do { } while (0)
-#endif
-
-/* 2nd-level cache init */
-void __attribute__ ((weak)) l2_cache_init(void)
-{
-}
-
-/*
- * Generic first-level cache init
- */
-#if !defined(CONFIG_CPU_J2)
-static void cache_init(void)
-{
-	unsigned long ccr, flags;
-
-	jump_to_uncached();
-	ccr = __raw_readl(SH_CCR);
-
-	/*
-	 * At this point we don't know whether the cache is enabled or not - a
-	 * bootloader may have enabled it.  There are at least 2 things that
-	 * could be dirty in the cache at this point:
-	 * 1. kernel command line set up by boot loader
-	 * 2. spilled registers from the prolog of this function
-	 * => before re-initialising the cache, we must do a purge of the whole
-	 * cache out to memory for safety.  As long as nothing is spilled
-	 * during the loop to lines that have already been done, this is safe.
-	 * - RPC
-	 */
-	if (ccr & CCR_CACHE_ENABLE) {
-		unsigned long ways, waysize, addrstart;
-
-		waysize = current_cpu_data.dcache.sets;
-
-#ifdef CCR_CACHE_ORA
-		/*
-		 * If the OC is already in RAM mode, we only have
-		 * half of the entries to flush..
-		 */
-		if (ccr & CCR_CACHE_ORA)
-			waysize >>= 1;
-#endif
-
-		waysize <<= current_cpu_data.dcache.entry_shift;
-
-#ifdef CCR_CACHE_EMODE
-		/* If EMODE is not set, we only have 1 way to flush. */
-		if (!(ccr & CCR_CACHE_EMODE))
-			ways = 1;
-		else
-#endif
-			ways = current_cpu_data.dcache.ways;
-
-		addrstart = CACHE_OC_ADDRESS_ARRAY;
-		do {
-			unsigned long addr;
-
-			for (addr = addrstart;
-			     addr < addrstart + waysize;
-			     addr += current_cpu_data.dcache.linesz)
-				__raw_writel(0, addr);
-
-			addrstart += current_cpu_data.dcache.way_incr;
-		} while (--ways);
-	}
-
-	/*
-	 * Default CCR values .. enable the caches
-	 * and invalidate them immediately..
-	 */
-	flags = CCR_CACHE_ENABLE | CCR_CACHE_INVALIDATE;
-
-#ifdef CCR_CACHE_EMODE
-	/* Force EMODE if possible */
-	if (current_cpu_data.dcache.ways > 1)
-		flags |= CCR_CACHE_EMODE;
-	else
-		flags &= ~CCR_CACHE_EMODE;
-#endif
-
-#if defined(CONFIG_CACHE_WRITETHROUGH)
-	/* Write-through */
-	flags |= CCR_CACHE_WT;
-#elif defined(CONFIG_CACHE_WRITEBACK)
-	/* Write-back */
-	flags |= CCR_CACHE_CB;
-#else
-	/* Off */
-	flags &= ~CCR_CACHE_ENABLE;
-#endif
-
-	l2_cache_init();
-
-	__raw_writel(flags, SH_CCR);
-	back_to_cached();
-}
-#else
-#define cache_init()	do { } while (0)
-#endif
-
-#define CSHAPE(totalsize, linesize, assoc) \
-	((totalsize & ~0xff) | (linesize << 4) | assoc)
-
-#define CACHE_DESC_SHAPE(desc)	\
-	CSHAPE((desc).way_size * (desc).ways, ilog2((desc).linesz), (desc).ways)
-
-static void detect_cache_shape(void)
-{
-	l1d_cache_shape = CACHE_DESC_SHAPE(current_cpu_data.dcache);
-
-	if (current_cpu_data.dcache.flags & SH_CACHE_COMBINED)
-		l1i_cache_shape = l1d_cache_shape;
-	else
-		l1i_cache_shape = CACHE_DESC_SHAPE(current_cpu_data.icache);
-
-	if (current_cpu_data.flags & CPU_HAS_L2_CACHE)
-		l2_cache_shape = CACHE_DESC_SHAPE(current_cpu_data.scache);
-	else
-		l2_cache_shape = -1; /* No S-cache */
-}
-
-static void fpu_init(void)
-{
-	/* Disable the FPU */
-	if (fpu_disabled && (current_cpu_data.flags & CPU_HAS_FPU)) {
-		printk("FPU Disabled\n");
-		current_cpu_data.flags &= ~CPU_HAS_FPU;
-	}
-
-	disable_fpu();
-	clear_used_math();
-}
-
-#ifdef CONFIG_SH_DSP
-static void release_dsp(void)
-{
-	unsigned long sr;
-
-	/* Clear SR.DSP bit */
-	__asm__ __volatile__ (
-		"stc\tsr, %0\n\t"
-		"and\t%1, %0\n\t"
-		"ldc\t%0, sr\n\t"
-		: "=&r" (sr)
-		: "r" (~SR_DSP)
-	);
-}
-
-static void dsp_init(void)
-{
-	unsigned long sr;
-
-	/*
-	 * Set the SR.DSP bit, wait for one instruction, and then read
-	 * back the SR value.
-	 */
-	__asm__ __volatile__ (
-		"stc\tsr, %0\n\t"
-		"or\t%1, %0\n\t"
-		"ldc\t%0, sr\n\t"
-		"nop\n\t"
-		"stc\tsr, %0\n\t"
-		: "=&r" (sr)
-		: "r" (SR_DSP)
-	);
-
-	/* If the DSP bit is still set, this CPU has a DSP */
-	if (sr & SR_DSP)
-		current_cpu_data.flags |= CPU_HAS_DSP;
-
-	/* Disable the DSP */
-	if (dsp_disabled && (current_cpu_data.flags & CPU_HAS_DSP)) {
-		printk("DSP Disabled\n");
-		current_cpu_data.flags &= ~CPU_HAS_DSP;
-	}
-
-	/* Now that we've determined the DSP status, clear the DSP bit. */
-	release_dsp();
-}
-#else
-static inline void dsp_init(void) { }
-#endif /* CONFIG_SH_DSP */
-
-/**
- * cpu_init
- *
- * This is our initial entry point for each CPU, and is invoked on the
- * boot CPU prior to calling start_kernel(). For SMP, a combination of
- * this and start_secondary() will bring up each processor to a ready
- * state prior to hand forking the idle loop.
- *
- * We do all of the basic processor init here, including setting up
- * the caches, FPU, DSP, etc. By the time start_kernel() is hit (and
- * subsequently platform_setup()) things like determining the CPU
- * subtype and initial configuration will all be done.
- *
- * Each processor family is still responsible for doing its own probing
- * and cache configuration in cpu_probe().
- */
-asmlinkage void cpu_init(void)
-{
-	current_thread_info()->cpu = hard_smp_processor_id();
-
-	/* First, probe the CPU */
-	cpu_probe();
-
-	if (current_cpu_data.type == CPU_SH_NONE)
-		panic("Unknown CPU");
-
-	/* First setup the rest of the I-cache info */
-	current_cpu_data.icache.entry_mask = current_cpu_data.icache.way_incr -
-				      current_cpu_data.icache.linesz;
-
-	current_cpu_data.icache.way_size = current_cpu_data.icache.sets *
-				    current_cpu_data.icache.linesz;
-
-	/* And the D-cache too */
-	current_cpu_data.dcache.entry_mask = current_cpu_data.dcache.way_incr -
-				      current_cpu_data.dcache.linesz;
-
-	current_cpu_data.dcache.way_size = current_cpu_data.dcache.sets *
-				    current_cpu_data.dcache.linesz;
-
-	/* Init the cache */
-	cache_init();
-
-	if (raw_smp_processor_id() == 0) {
-#ifdef CONFIG_MMU
-		shm_align_mask = max_t(unsigned long,
-				       current_cpu_data.dcache.way_size - 1,
-				       PAGE_SIZE - 1);
-#else
-		shm_align_mask = PAGE_SIZE - 1;
-#endif
-
-		/* Boot CPU sets the cache shape */
-		detect_cache_shape();
-	}
-
-	fpu_init();
-	dsp_init();
-
-	/*
-	 * Initialize the per-CPU ASID cache very early, since the
-	 * TLB flushing routines depend on this being setup.
-	 */
-	current_cpu_data.asid_cache = NO_CONTEXT;
-
-	current_cpu_data.phys_bits = __in_29bit_mode() ? 29 : 32;
-
-	speculative_execution_init();
-	expmask_init();
-
-	/* Do the rest of the boot processor setup */
-	if (raw_smp_processor_id() == 0) {
-		/* Save off the BIOS VBR, if there is one */
-		sh_bios_vbr_init();
-
-		/*
-		 * Setup VBR for boot CPU. Secondary CPUs do this through
-		 * start_secondary().
-		 */
-		per_cpu_trap_init();
-
-		/*
-		 * Boot processor to setup the FP and extended state
-		 * context info.
-		 */
-		init_thread_xstate();
-	}
-}
diff --git a/arch/sh/kernel/cpu/irq/Makefile b/arch/sh/kernel/cpu/irq/Makefile
deleted file mode 100644
index e4578cde46ba26..00000000000000
--- a/arch/sh/kernel/cpu/irq/Makefile
+++ /dev/null
@@ -1,6 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the Linux/SuperH CPU-specific IRQ handlers.
-#
-obj-y					+= imask.o
-obj-$(CONFIG_CPU_HAS_IPR_IRQ)		+= ipr.o
diff --git a/arch/sh/kernel/cpu/irq/imask.c b/arch/sh/kernel/cpu/irq/imask.c
deleted file mode 100644
index 572585c3f2fd8c..00000000000000
--- a/arch/sh/kernel/cpu/irq/imask.c
+++ /dev/null
@@ -1,85 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/irq/imask.c
- *
- * Copyright (C) 1999, 2000  Niibe Yutaka
- *
- * Simple interrupt handling using IMASK of SR register.
- *
- */
-/* NOTE: Will not work on level 15 */
-#include <linux/ptrace.h>
-#include <linux/errno.h>
-#include <linux/kernel_stat.h>
-#include <linux/signal.h>
-#include <linux/sched.h>
-#include <linux/interrupt.h>
-#include <linux/init.h>
-#include <linux/bitops.h>
-#include <linux/spinlock.h>
-#include <linux/cache.h>
-#include <linux/irq.h>
-#include <linux/bitmap.h>
-#include <asm/irq.h>
-
-/* Bitmap of IRQ masked */
-#define IMASK_PRIORITY	15
-
-static DECLARE_BITMAP(imask_mask, IMASK_PRIORITY);
-static int interrupt_priority;
-
-static inline void set_interrupt_registers(int ip)
-{
-	unsigned long __dummy;
-
-	asm volatile(
-#ifdef CONFIG_CPU_HAS_SR_RB
-		     "ldc	%2, r6_bank\n\t"
-#endif
-		     "stc	sr, %0\n\t"
-		     "and	#0xf0, %0\n\t"
-		     "shlr2	%0\n\t"
-		     "cmp/eq	#0x3c, %0\n\t"
-		     "bt/s	1f	! CLI-ed\n\t"
-		     " stc	sr, %0\n\t"
-		     "and	%1, %0\n\t"
-		     "or	%2, %0\n\t"
-		     "ldc	%0, sr\n"
-		     "1:"
-		     : "=&z" (__dummy)
-		     : "r" (~0xf0), "r" (ip << 4)
-		     : "t");
-}
-
-static void mask_imask_irq(struct irq_data *data)
-{
-	unsigned int irq = data->irq;
-
-	clear_bit(irq, imask_mask);
-	if (interrupt_priority < IMASK_PRIORITY - irq)
-		interrupt_priority = IMASK_PRIORITY - irq;
-	set_interrupt_registers(interrupt_priority);
-}
-
-static void unmask_imask_irq(struct irq_data *data)
-{
-	unsigned int irq = data->irq;
-
-	set_bit(irq, imask_mask);
-	interrupt_priority = IMASK_PRIORITY -
-		find_first_zero_bit(imask_mask, IMASK_PRIORITY);
-	set_interrupt_registers(interrupt_priority);
-}
-
-static struct irq_chip imask_irq_chip = {
-	.name		= "SR.IMASK",
-	.irq_mask	= mask_imask_irq,
-	.irq_unmask	= unmask_imask_irq,
-	.irq_mask_ack	= mask_imask_irq,
-};
-
-void make_imask_irq(unsigned int irq)
-{
-	irq_set_chip_and_handler_name(irq, &imask_irq_chip, handle_level_irq,
-				      "level");
-}
diff --git a/arch/sh/kernel/cpu/irq/ipr.c b/arch/sh/kernel/cpu/irq/ipr.c
deleted file mode 100644
index d41bce71f211fd..00000000000000
--- a/arch/sh/kernel/cpu/irq/ipr.c
+++ /dev/null
@@ -1,80 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Interrupt handling for IPR-based IRQ.
- *
- * Copyright (C) 1999  Niibe Yutaka & Takeshi Yaegashi
- * Copyright (C) 2000  Kazumoto Kojima
- * Copyright (C) 2003  Takashi Kusuda <kusuda-takashi@hitachi-ul.co.jp>
- * Copyright (C) 2006  Paul Mundt
- *
- * Supported system:
- *	On-chip supporting modules (TMU, RTC, etc.).
- *	On-chip supporting modules for SH7709/SH7709A/SH7729.
- *	Hitachi SolutionEngine external I/O:
- *		MS7709SE01, MS7709ASE01, and MS7750SE01
- */
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/io.h>
-#include <linux/irq.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/topology.h>
-
-static inline struct ipr_desc *get_ipr_desc(struct irq_data *data)
-{
-	struct irq_chip *chip = irq_data_get_irq_chip(data);
-	return container_of(chip, struct ipr_desc, chip);
-}
-
-static void disable_ipr_irq(struct irq_data *data)
-{
-	struct ipr_data *p = irq_data_get_irq_chip_data(data);
-	unsigned long addr = get_ipr_desc(data)->ipr_offsets[p->ipr_idx];
-	/* Set the priority in IPR to 0 */
-	__raw_writew(__raw_readw(addr) & (0xffff ^ (0xf << p->shift)), addr);
-	(void)__raw_readw(addr);	/* Read back to flush write posting */
-}
-
-static void enable_ipr_irq(struct irq_data *data)
-{
-	struct ipr_data *p = irq_data_get_irq_chip_data(data);
-	unsigned long addr = get_ipr_desc(data)->ipr_offsets[p->ipr_idx];
-	/* Set priority in IPR back to original value */
-	__raw_writew(__raw_readw(addr) | (p->priority << p->shift), addr);
-}
-
-/*
- * The shift value is now the number of bits to shift, not the number of
- * bits/4. This is to make it easier to read the value directly from the
- * datasheets. The IPR address is calculated using the ipr_offset table.
- */
-void register_ipr_controller(struct ipr_desc *desc)
-{
-	int i;
-
-	desc->chip.irq_mask = disable_ipr_irq;
-	desc->chip.irq_unmask = enable_ipr_irq;
-
-	for (i = 0; i < desc->nr_irqs; i++) {
-		struct ipr_data *p = desc->ipr_data + i;
-		int res;
-
-		BUG_ON(p->ipr_idx >= desc->nr_offsets);
-		BUG_ON(!desc->ipr_offsets[p->ipr_idx]);
-
-		res = irq_alloc_desc_at(p->irq, numa_node_id());
-		if (unlikely(res != p->irq && res != -EEXIST)) {
-			printk(KERN_INFO "can not get irq_desc for %d\n",
-			       p->irq);
-			continue;
-		}
-
-		disable_irq_nosync(p->irq);
-		irq_set_chip_and_handler_name(p->irq, &desc->chip,
-					      handle_level_irq, "level");
-		irq_set_chip_data(p->irq, p);
-		disable_ipr_irq(irq_get_irq_data(p->irq));
-	}
-}
-EXPORT_SYMBOL(register_ipr_controller);
diff --git a/arch/sh/kernel/cpu/pfc.c b/arch/sh/kernel/cpu/pfc.c
deleted file mode 100644
index 062056ede88de4..00000000000000
--- a/arch/sh/kernel/cpu/pfc.c
+++ /dev/null
@@ -1,25 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH Pin Function Control Initialization
- *
- * Copyright (C) 2012  Renesas Solutions Corp.
- */
-
-#include <linux/init.h>
-#include <linux/platform_device.h>
-
-#include <cpu/pfc.h>
-
-static struct platform_device sh_pfc_device = {
-	.id		= -1,
-};
-
-int __init sh_pfc_register(const char *name,
-			   struct resource *resource, u32 num_resources)
-{
-	sh_pfc_device.name = name;
-	sh_pfc_device.num_resources = num_resources;
-	sh_pfc_device.resource = resource;
-
-	return platform_device_register(&sh_pfc_device);
-}
diff --git a/arch/sh/kernel/cpu/proc.c b/arch/sh/kernel/cpu/proc.c
deleted file mode 100644
index a306bcd6b34130..00000000000000
--- a/arch/sh/kernel/cpu/proc.c
+++ /dev/null
@@ -1,151 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/seq_file.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <asm/machvec.h>
-#include <asm/processor.h>
-
-static const char *cpu_name[] = {
-	[CPU_SH7201]	= "SH7201",
-	[CPU_SH7203]	= "SH7203",	[CPU_SH7263]	= "SH7263",
-	[CPU_SH7264]	= "SH7264",	[CPU_SH7269]	= "SH7269",
-	[CPU_SH7206]	= "SH7206",	[CPU_SH7619]	= "SH7619",
-	[CPU_SH7705]	= "SH7705",	[CPU_SH7706]	= "SH7706",
-	[CPU_SH7707]	= "SH7707",	[CPU_SH7708]	= "SH7708",
-	[CPU_SH7709]	= "SH7709",	[CPU_SH7710]	= "SH7710",
-	[CPU_SH7712]	= "SH7712",	[CPU_SH7720]	= "SH7720",
-	[CPU_SH7721]	= "SH7721",	[CPU_SH7729]	= "SH7729",
-	[CPU_SH7750]	= "SH7750",	[CPU_SH7750S]	= "SH7750S",
-	[CPU_SH7750R]	= "SH7750R",	[CPU_SH7751]	= "SH7751",
-	[CPU_SH7751R]	= "SH7751R",	[CPU_SH7760]	= "SH7760",
-	[CPU_SH4_202]	= "SH4-202",	[CPU_SH4_501]	= "SH4-501",
-	[CPU_SH7763]	= "SH7763",	[CPU_SH7770]	= "SH7770",
-	[CPU_SH7780]	= "SH7780",	[CPU_SH7781]	= "SH7781",
-	[CPU_SH7343]	= "SH7343",	[CPU_SH7785]	= "SH7785",
-	[CPU_SH7786]	= "SH7786",	[CPU_SH7757]	= "SH7757",
-	[CPU_SH7722]	= "SH7722",	[CPU_SHX3]	= "SH-X3",
-	[CPU_MXG]	= "MX-G",	[CPU_SH7723]	= "SH7723",
-	[CPU_SH7366]	= "SH7366",	[CPU_SH7724]	= "SH7724",
-	[CPU_SH7372]	= "SH7372",	[CPU_SH7734]	= "SH7734",
-	[CPU_J2]	= "J2",
-	[CPU_SH_NONE]	= "Unknown"
-};
-
-const char *get_cpu_subtype(struct sh_cpuinfo *c)
-{
-	return cpu_name[c->type];
-}
-EXPORT_SYMBOL(get_cpu_subtype);
-
-#ifdef CONFIG_PROC_FS
-/* Symbolic CPU flags, keep in sync with asm/cpu-features.h */
-static const char *cpu_flags[] = {
-	"none", "fpu", "p2flush", "mmuassoc", "dsp", "perfctr",
-	"ptea", "llsc", "l2", "op32", "pteaex", NULL
-};
-
-static void show_cpuflags(struct seq_file *m, struct sh_cpuinfo *c)
-{
-	unsigned long i;
-
-	seq_printf(m, "cpu flags\t:");
-
-	if (!c->flags) {
-		seq_printf(m, " %s\n", cpu_flags[0]);
-		return;
-	}
-
-	for (i = 0; cpu_flags[i]; i++)
-		if ((c->flags & (1 << i)))
-			seq_printf(m, " %s", cpu_flags[i+1]);
-
-	seq_printf(m, "\n");
-}
-
-static void show_cacheinfo(struct seq_file *m, const char *type,
-			   struct cache_info info)
-{
-	unsigned int cache_size;
-
-	cache_size = info.ways * info.sets * info.linesz;
-
-	seq_printf(m, "%s size\t: %2dKiB (%d-way)\n",
-		   type, cache_size >> 10, info.ways);
-}
-
-/*
- *	Get CPU information for use by the procfs.
- */
-static int show_cpuinfo(struct seq_file *m, void *v)
-{
-	struct sh_cpuinfo *c = v;
-	unsigned int cpu = c - cpu_data;
-
-	if (!cpu_online(cpu))
-		return 0;
-
-	if (cpu == 0)
-		seq_printf(m, "machine\t\t: %s\n", get_system_type());
-	else
-		seq_printf(m, "\n");
-
-	seq_printf(m, "processor\t: %d\n", cpu);
-	seq_printf(m, "cpu family\t: %s\n", init_utsname()->machine);
-	seq_printf(m, "cpu type\t: %s\n", get_cpu_subtype(c));
-	if (c->cut_major == -1)
-		seq_printf(m, "cut\t\t: unknown\n");
-	else if (c->cut_minor == -1)
-		seq_printf(m, "cut\t\t: %d.x\n", c->cut_major);
-	else
-		seq_printf(m, "cut\t\t: %d.%d\n", c->cut_major, c->cut_minor);
-
-	show_cpuflags(m, c);
-
-	seq_printf(m, "cache type\t: ");
-
-	/*
-	 * Check for what type of cache we have, we support both the
-	 * unified cache on the SH-2 and SH-3, as well as the harvard
-	 * style cache on the SH-4.
-	 */
-	if (c->icache.flags & SH_CACHE_COMBINED) {
-		seq_printf(m, "unified\n");
-		show_cacheinfo(m, "cache", c->icache);
-	} else {
-		seq_printf(m, "split (harvard)\n");
-		show_cacheinfo(m, "icache", c->icache);
-		show_cacheinfo(m, "dcache", c->dcache);
-	}
-
-	/* Optional secondary cache */
-	if (c->flags & CPU_HAS_L2_CACHE)
-		show_cacheinfo(m, "scache", c->scache);
-
-	seq_printf(m, "address sizes\t: %u bits physical\n", c->phys_bits);
-
-	seq_printf(m, "bogomips\t: %lu.%02lu\n",
-		     c->loops_per_jiffy/(500000/HZ),
-		     (c->loops_per_jiffy/(5000/HZ)) % 100);
-
-	return 0;
-}
-
-static void *c_start(struct seq_file *m, loff_t *pos)
-{
-	return *pos < NR_CPUS ? cpu_data + *pos : NULL;
-}
-static void *c_next(struct seq_file *m, void *v, loff_t *pos)
-{
-	++*pos;
-	return c_start(m, pos);
-}
-static void c_stop(struct seq_file *m, void *v)
-{
-}
-const struct seq_operations cpuinfo_op = {
-	.start	= c_start,
-	.next	= c_next,
-	.stop	= c_stop,
-	.show	= show_cpuinfo,
-};
-#endif /* CONFIG_PROC_FS */
diff --git a/arch/sh/kernel/cpu/sh2/Makefile b/arch/sh/kernel/cpu/sh2/Makefile
deleted file mode 100644
index 214c3a5b184ace..00000000000000
--- a/arch/sh/kernel/cpu/sh2/Makefile
+++ /dev/null
@@ -1,12 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the Linux/SuperH SH-2 backends.
-#
-
-obj-y	:= ex.o probe.o entry.o
-
-obj-$(CONFIG_CPU_SUBTYPE_SH7619) += setup-sh7619.o clock-sh7619.o
-
-# SMP setup
-smp-$(CONFIG_CPU_J2)			:= smp-j2.o
-obj-$(CONFIG_SMP)			+= $(smp-y)
diff --git a/arch/sh/kernel/cpu/sh2/clock-sh7619.c b/arch/sh/kernel/cpu/sh2/clock-sh7619.c
deleted file mode 100644
index d66d194c7731b9..00000000000000
--- a/arch/sh/kernel/cpu/sh2/clock-sh7619.c
+++ /dev/null
@@ -1,74 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh2/clock-sh7619.c
- *
- * SH7619 support for the clock framework
- *
- *  Copyright (C) 2006  Yoshinori Sato
- *
- * Based on clock-sh4.c
- *  Copyright (C) 2005  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <asm/clock.h>
-#include <asm/freq.h>
-#include <asm/processor.h>
-
-static const int pll1rate[] = {1,2};
-static const int pfc_divisors[] = {1,2,0,4};
-static unsigned int pll2_mult;
-
-static void master_clk_init(struct clk *clk)
-{
-	clk->rate *= pll2_mult * pll1rate[(__raw_readw(FREQCR) >> 8) & 7];
-}
-
-static struct sh_clk_ops sh7619_master_clk_ops = {
-	.init		= master_clk_init,
-};
-
-static unsigned long module_clk_recalc(struct clk *clk)
-{
-	int idx = (__raw_readw(FREQCR) & 0x0007);
-	return clk->parent->rate / pfc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7619_module_clk_ops = {
-	.recalc		= module_clk_recalc,
-};
-
-static unsigned long bus_clk_recalc(struct clk *clk)
-{
-	return clk->parent->rate / pll1rate[(__raw_readw(FREQCR) >> 8) & 7];
-}
-
-static struct sh_clk_ops sh7619_bus_clk_ops = {
-	.recalc		= bus_clk_recalc,
-};
-
-static struct sh_clk_ops sh7619_cpu_clk_ops = {
-	.recalc		= followparent_recalc,
-};
-
-static struct sh_clk_ops *sh7619_clk_ops[] = {
-	&sh7619_master_clk_ops,
-	&sh7619_module_clk_ops,
-	&sh7619_bus_clk_ops,
-	&sh7619_cpu_clk_ops,
-};
-
-void __init arch_init_clk_ops(struct sh_clk_ops **ops, int idx)
-{
-	if (test_mode_pin(MODE_PIN2 | MODE_PIN0) ||
-	    test_mode_pin(MODE_PIN2 | MODE_PIN1))
-		pll2_mult = 2;
-	else if (test_mode_pin(MODE_PIN0) || test_mode_pin(MODE_PIN1))
-		pll2_mult = 4;
-
-	BUG_ON(!pll2_mult);
-
-	if (idx < ARRAY_SIZE(sh7619_clk_ops))
-		*ops = sh7619_clk_ops[idx];
-}
diff --git a/arch/sh/kernel/cpu/sh2/entry.S b/arch/sh/kernel/cpu/sh2/entry.S
deleted file mode 100644
index 0a1c2bf216bc03..00000000000000
--- a/arch/sh/kernel/cpu/sh2/entry.S
+++ /dev/null
@@ -1,373 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * arch/sh/kernel/cpu/sh2/entry.S
- *
- * The SH-2 exception entry
- *
- * Copyright (C) 2005-2008 Yoshinori Sato
- * Copyright (C) 2005  AXE,Inc.
- */
-
-#include <linux/linkage.h>
-#include <asm/asm-offsets.h>
-#include <asm/thread_info.h>
-#include <cpu/mmu_context.h>
-#include <asm/unistd.h>
-#include <asm/errno.h>
-#include <asm/page.h>
-	
-/* Offsets to the stack */
-OFF_R0  =  0		/* Return value. New ABI also arg4 */
-OFF_R1  =  4     	/* New ABI: arg5 */
-OFF_R2  =  8     	/* New ABI: arg6 */
-OFF_R3  =  12     	/* New ABI: syscall_nr */
-OFF_R4  =  16     	/* New ABI: arg0 */
-OFF_R5  =  20     	/* New ABI: arg1 */
-OFF_R6  =  24     	/* New ABI: arg2 */
-OFF_R7  =  28     	/* New ABI: arg3 */
-OFF_SP	=  (15*4)
-OFF_PC  =  (16*4)
-OFF_SR	=  (16*4+2*4)
-OFF_TRA	=  (16*4+6*4)
-
-#include <asm/entry-macros.S>
-
-ENTRY(exception_handler)
-	! stack
-	! r0 <- point sp
-	! r1
-	! pc
-	! sr
-	! r0 = temporary
-	! r1 = vector (pseudo EXPEVT / INTEVT / TRA)
-	mov.l	r2,@-sp
-	mov.l	r3,@-sp
-	cli
-	mov.l	$cpu_mode,r2
-#ifdef CONFIG_SMP
-	mov.l	$cpuid,r3
-	mov.l	@r3,r3
-	mov.l	@r3,r3
-	shll2	r3
-	add	r3,r2
-#endif
-	mov.l	@r2,r0
-	mov.l	@(5*4,r15),r3	! previous SR
-	or	r0,r3		! set MD
-	tst	r0,r0
-	bf/s	1f		! previous mode check
-	 mov.l	r3,@(5*4,r15)	! update SR
-	! switch to kernel mode
-	mov.l	__md_bit,r0
-	mov.l	r0,@r2		! enter kernel mode
-	mov.l	$current_thread_info,r2
-#ifdef CONFIG_SMP
-	mov.l	$cpuid,r0
-	mov.l	@r0,r0
-	mov.l	@r0,r0
-	shll2	r0
-	add	r0,r2
-#endif
-	mov.l	@r2,r2
-	mov	#(THREAD_SIZE >> 8),r0
-	shll8	r0
-	add	r2,r0
-	mov	r15,r2		! r2 = user stack top
-	mov	r0,r15		! switch kernel stack
-	mov.l	r1,@-r15	! TRA
-	sts.l	macl, @-r15
-	sts.l	mach, @-r15
-	stc.l	gbr, @-r15
-	mov.l	@(5*4,r2),r0
-	mov.l	r0,@-r15	! original SR
-	sts.l	pr,@-r15
-	mov.l	@(4*4,r2),r0
-	mov.l	r0,@-r15	! original PC
-	mov	r2,r3
-	add	#(4+2)*4,r3	! rewind r0 - r3 + exception frame
-	mov.l	r3,@-r15	! original SP
-	mov.l	r14,@-r15
-	mov.l	r13,@-r15
-	mov.l	r12,@-r15
-	mov.l	r11,@-r15
-	mov.l	r10,@-r15
-	mov.l	r9,@-r15
-	mov.l	r8,@-r15
-	mov.l	r7,@-r15
-	mov.l	r6,@-r15
-	mov.l	r5,@-r15
-	mov.l	r4,@-r15
-	mov	r1,r9		! save TRA
-	mov	r2,r8		! copy user -> kernel stack
-	mov.l	@(0,r8),r3
-	mov.l	r3,@-r15
-	mov.l	@(4,r8),r2
-	mov.l	r2,@-r15
-	mov.l	@(12,r8),r1
-	mov.l	r1,@-r15
-	mov.l	@(8,r8),r0
-	bra	2f
-	 mov.l	r0,@-r15
-1:
-	! in kernel exception
-	mov	#(22-4-4-1)*4+4,r0
-	mov	r15,r2
-	sub	r0,r15
-	mov.l	@r2+,r0		! old R3
-	mov.l	r0,@-r15	
-	mov.l	@r2+,r0		! old R2
-	mov.l	r0,@-r15	
-	mov.l	@(4,r2),r0	! old R1
-	mov.l	r0,@-r15	
-	mov.l	@r2,r0		! old R0
-	mov.l	r0,@-r15
-	add	#8,r2
-	mov.l	@r2+,r3		! old PC
-	mov.l	@r2+,r0		! old SR
-	add	#-4,r2		! exception frame stub (sr)
-	mov.l	r1,@-r2		! TRA
-	sts.l	macl, @-r2
-	sts.l	mach, @-r2
-	stc.l	gbr, @-r2
-	mov.l	r0,@-r2		! save old SR
-	sts.l	pr,@-r2
-	mov.l	r3,@-r2		! save old PC
-	mov	r2,r0
-	add	#8*4,r0
-	mov.l	r0,@-r2		! save old SP
-	mov.l	r14,@-r2
-	mov.l	r13,@-r2
-	mov.l	r12,@-r2
-	mov.l	r11,@-r2
-	mov.l	r10,@-r2
-	mov.l	r9,@-r2
-	mov.l	r8,@-r2
-	mov.l	r7,@-r2
-	mov.l	r6,@-r2
-	mov.l	r5,@-r2
-	mov.l	r4,@-r2
-	mov	r1,r9
-	mov.l	@(OFF_R0,r15),r0
-	mov.l	@(OFF_R1,r15),r1
-	mov.l	@(OFF_R2,r15),r2
-	mov.l	@(OFF_R3,r15),r3
-2:
-	mov	#64,r8
-	cmp/hs	r8,r9
-	bt	interrupt_entry	! vec >= 64 is interrupt
-	mov	#31,r8
-	cmp/hs	r8,r9
-	bt	trap_entry	! 64 > vec >= 31  is trap
-#ifdef CONFIG_CPU_J2
-	mov	#16,r8
-	cmp/hs	r8,r9
-	bt	interrupt_entry	! 31 > vec >= 16 is interrupt
-#endif
-
-	mov.l	4f,r8
-	mov	r9,r4
-	shll2	r9
-	add	r9,r8
-	mov.l	@r8,r8		! exception handler address
-	tst	r8,r8
-	bf	3f
-	mov.l	8f,r8		! unhandled exception
-3:
-	mov.l	5f,r10
-	jmp	@r8
-	 lds	r10,pr
-
-interrupt_entry:
-	mov	r9,r4
-	mov	r15,r5
-	mov.l	6f,r9
-	mov.l	7f,r8
-	jmp	@r8
-	 lds	r9,pr
-
-	.align	2
-4:	.long	exception_handling_table
-5:	.long	ret_from_exception
-6:	.long	ret_from_irq
-7:	.long	do_IRQ
-8:	.long	exception_error
-
-trap_entry:
-	mov	#0x30,r8
-	cmp/ge	r8,r9		! vector 0x1f-0x2f is systemcall
-	bt	1f
-	mov     #0x1f,r9	! convert to unified SH2/3/4 trap number
-1:	
-	shll2	r9			! TRA
-	bra	system_call	! jump common systemcall entry
-	 mov	r9,r8
-	
-#if defined(CONFIG_SH_STANDARD_BIOS)
-	/* Unwind the stack and jmp to the debug entry */
-ENTRY(sh_bios_handler)
-	mov	r15,r0
-	add	#(22-4)*4-4,r0
-	ldc.l	@r0+,gbr
-	lds.l	@r0+,mach
-	lds.l	@r0+,macl
-	mov	r15,r0
-	mov.l	@(OFF_SP,r0),r1
-	mov	#OFF_SR,r2
-	mov.l	@(r0,r2),r3
-	mov.l	r3,@-r1
-	mov	#OFF_SP,r2
-	mov.l	@(r0,r2),r3
-	mov.l	r3,@-r1
-	mov	r15,r0
-	add	#(22-4)*4-8,r0
-	mov.l	1f,r2
-	mov.l	@r2,r2
-	stc	sr,r3
-	mov.l	r2,@r0
-	mov.l	r3,@(4,r0)
-	mov.l	r1,@(8,r0)	
-	mov.l	@r15+, r0
-	mov.l	@r15+, r1
-	mov.l	@r15+, r2
-	mov.l	@r15+, r3
-	mov.l	@r15+, r4
-	mov.l	@r15+, r5
-	mov.l	@r15+, r6
-	mov.l	@r15+, r7
-	mov.l	@r15+, r8
-	mov.l	@r15+, r9
-	mov.l	@r15+, r10
-	mov.l	@r15+, r11
-	mov.l	@r15+, r12
-	mov.l	@r15+, r13
-	mov.l	@r15+, r14
-	add	#8,r15
-	lds.l	@r15+, pr
-	mov.l	@r15+,r15
-	rte
-	 nop
-	.align	2
-1:	.long	gdb_vbr_vector
-#endif /* CONFIG_SH_STANDARD_BIOS */
-
-ENTRY(address_error_trap_handler)
-	mov	r15,r4				! regs
-	mov	#OFF_PC,r0
-	mov.l	@(r0,r15),r6			! pc
-	mov.l	1f,r0
-	jmp	@r0
-	 mov	#0,r5				! writeaccess is unknown
-
-	.align	2
-1:	.long	do_address_error
-
-restore_all:
-	stc	sr,r0
-	or	#0xf0,r0
-	ldc	r0,sr				! all interrupt block (same BL = 1)
-	! restore special register
-	! overlap exception frame
-	mov	r15,r0
-	add	#17*4,r0
-	lds.l	@r0+,pr
-	add	#4,r0
-	ldc.l	@r0+,gbr
-	lds.l	@r0+,mach
-	lds.l	@r0+,macl
-	mov	r15,r0
-	mov.l	$cpu_mode,r2
-#ifdef CONFIG_SMP
-	mov.l	$cpuid,r3
-	mov.l	@r3,r3
-	mov.l	@r3,r3
-	shll2	r3
-	add	r3,r2
-#endif
-	mov	#OFF_SR,r3
-	mov.l	@(r0,r3),r1
-	mov.l	__md_bit,r3
-	and	r1,r3				! copy MD bit
-	mov.l	r3,@r2
-	shll2	r1				! clear MD bit
-	shlr2	r1
-	mov.l	@(OFF_SP,r0),r2
-	add	#-8,r2
-	mov.l	r2,@(OFF_SP,r0)			! point exception frame top
-	mov.l	r1,@(4,r2)			! set sr
-	mov	#OFF_PC,r3
-	mov.l	@(r0,r3),r1
-	mov.l	r1,@r2				! set pc
-	get_current_thread_info r0, r1
-	mov.l	$current_thread_info,r1
-#ifdef CONFIG_SMP
-	mov.l	$cpuid,r3
-	mov.l	@r3,r3
-	mov.l	@r3,r3
-	shll2	r3
-	add	r3,r1
-#endif
-	mov.l	r0,@r1
-	mov.l	@r15+,r0
-	mov.l	@r15+,r1
-	mov.l	@r15+,r2
-	mov.l	@r15+,r3
-	mov.l	@r15+,r4
-	mov.l	@r15+,r5
-	mov.l	@r15+,r6
-	mov.l	@r15+,r7
-	mov.l	@r15+,r8
-	mov.l	@r15+,r9
-	mov.l	@r15+,r10
-	mov.l	@r15+,r11
-	mov.l	@r15+,r12
-	mov.l	@r15+,r13
-	mov.l	@r15+,r14
-	mov.l	@r15,r15
-	rte
-	 nop
-
-	.align 2
-__md_bit:
-	.long	0x40000000
-$current_thread_info:
-	.long	__current_thread_info
-$cpu_mode:	
-	.long	__cpu_mode
-#ifdef CONFIG_SMP
-$cpuid:
-	.long sh2_cpuid_addr
-#endif
-		
-! common exception handler
-#include "../../entry-common.S"
-
-#ifdef CONFIG_NR_CPUS
-#define NR_CPUS CONFIG_NR_CPUS
-#else
-#define NR_CPUS 1
-#endif
-	
-	.data
-! cpu operation mode 
-! bit30 = MD (compatible SH3/4)
-__cpu_mode:
-	.rept	NR_CPUS
-	.long	0x40000000
-	.endr
-
-#ifdef CONFIG_SMP
-.global sh2_cpuid_addr
-sh2_cpuid_addr:
-	.long	dummy_cpuid
-dummy_cpuid:
-	.long	0
-#endif
-		
-	.section	.bss
-__current_thread_info:
-	.rept	NR_CPUS
-	.long	0
-	.endr
-
-ENTRY(exception_handling_table)
-	.space	4*32
diff --git a/arch/sh/kernel/cpu/sh2/ex.S b/arch/sh/kernel/cpu/sh2/ex.S
deleted file mode 100644
index dd0cc887a3ca2c..00000000000000
--- a/arch/sh/kernel/cpu/sh2/ex.S
+++ /dev/null
@@ -1,44 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * arch/sh/kernel/cpu/sh2/ex.S
- *
- * The SH-2 exception vector table
- *
- * Copyright (C) 2005 Yoshinori Sato
- */
-
-#include <linux/linkage.h>
-
-!
-! convert Exception Vector to Exception Number
-!
-exception_entry:	
-no	=	0
-	.rept	256
-	mov.l	r1,@-sp
-	bra	exception_trampoline
-	mov	#no,r1
-no	=	no + 1
-	.endr
-exception_trampoline:
-	mov.l	r0,@-sp
-	mov.l	$exception_handler,r0
-	extu.b	r1,r1
-	jmp	@r0
-	  extu.w	r1,r1
-
-	.align	2
-$exception_entry:
-	.long	exception_entry
-$exception_handler:
-	.long	exception_handler
-!
-! Exception Vector Base
-!
-	.align	2
-ENTRY(vbr_base)
-vector	=	0
-	.rept	256
-	.long	exception_entry + vector * 6
-vector	=	vector + 1
-	.endr
diff --git a/arch/sh/kernel/cpu/sh2/probe.c b/arch/sh/kernel/cpu/sh2/probe.c
deleted file mode 100644
index d342ea08843f6a..00000000000000
--- a/arch/sh/kernel/cpu/sh2/probe.c
+++ /dev/null
@@ -1,71 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh2/probe.c
- *
- * CPU Subtype Probing for SH-2.
- *
- * Copyright (C) 2002 Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/of_fdt.h>
-#include <linux/smp.h>
-#include <linux/io.h>
-#include <asm/processor.h>
-#include <asm/cache.h>
-
-#if defined(CONFIG_CPU_J2)
-extern u32 __iomem *j2_ccr_base;
-static int __init scan_cache(unsigned long node, const char *uname,
-			     int depth, void *data)
-{
-	if (!of_flat_dt_is_compatible(node, "jcore,cache"))
-		return 0;
-
-	j2_ccr_base = (u32 __iomem *)of_flat_dt_translate_address(node);
-
-	return 1;
-}
-#endif
-
-void __ref cpu_probe(void)
-{
-#if defined(CONFIG_CPU_SUBTYPE_SH7619)
-	boot_cpu_data.type			= CPU_SH7619;
-	boot_cpu_data.dcache.ways		= 4;
-	boot_cpu_data.dcache.way_incr	= (1<<12);
-	boot_cpu_data.dcache.sets		= 256;
-	boot_cpu_data.dcache.entry_shift	= 4;
-	boot_cpu_data.dcache.linesz		= L1_CACHE_BYTES;
-	boot_cpu_data.dcache.flags		= 0;
-#endif
-
-#if defined(CONFIG_CPU_J2)
-#if defined(CONFIG_SMP)
-	unsigned cpu = hard_smp_processor_id();
-#else
-	unsigned cpu = 0;
-#endif
-	if (cpu == 0) of_scan_flat_dt(scan_cache, NULL);
-	if (j2_ccr_base) __raw_writel(0x80000303, j2_ccr_base + 4*cpu);
-	if (cpu != 0) return;
-	boot_cpu_data.type			= CPU_J2;
-
-	/* These defaults are appropriate for the original/current
-	 * J2 cache. Once there is a proper framework for getting cache
-	 * info from device tree, we should switch to that. */
-	boot_cpu_data.dcache.ways		= 1;
-	boot_cpu_data.dcache.sets		= 256;
-	boot_cpu_data.dcache.entry_shift	= 5;
-	boot_cpu_data.dcache.linesz		= 32;
-	boot_cpu_data.dcache.flags		= 0;
-
-	boot_cpu_data.flags |= CPU_HAS_CAS_L;
-#else
-	/*
-	 * SH-2 doesn't have separate caches
-	 */
-	boot_cpu_data.dcache.flags |= SH_CACHE_COMBINED;
-#endif
-	boot_cpu_data.icache = boot_cpu_data.dcache;
-	boot_cpu_data.family = CPU_FAMILY_SH2;
-}
diff --git a/arch/sh/kernel/cpu/sh2/setup-sh7619.c b/arch/sh/kernel/cpu/sh2/setup-sh7619.c
deleted file mode 100644
index b1c877b6a4207f..00000000000000
--- a/arch/sh/kernel/cpu/sh2/setup-sh7619.c
+++ /dev/null
@@ -1,205 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7619 Setup
- *
- *  Copyright (C) 2006  Yoshinori Sato
- *  Copyright (C) 2009  Paul Mundt
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/serial_sci.h>
-#include <linux/sh_eth.h>
-#include <linux/sh_timer.h>
-#include <linux/io.h>
-#include <asm/platform_early.h>
-
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-	IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7,
-	WDT, EDMAC, CMT0, CMT1,
-	SCIF0, SCIF1, SCIF2,
-	HIF_HIFI, HIF_HIFBI,
-	DMAC0, DMAC1, DMAC2, DMAC3,
-	SIOF,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_IRQ(IRQ0, 64), INTC_IRQ(IRQ1, 65),
-	INTC_IRQ(IRQ2, 66), INTC_IRQ(IRQ3, 67),
-	INTC_IRQ(IRQ4, 80), INTC_IRQ(IRQ5, 81),
-	INTC_IRQ(IRQ6, 82), INTC_IRQ(IRQ7, 83),
-	INTC_IRQ(WDT, 84), INTC_IRQ(EDMAC, 85),
-	INTC_IRQ(CMT0, 86), INTC_IRQ(CMT1, 87),
-	INTC_IRQ(SCIF0, 88), INTC_IRQ(SCIF0, 89),
-	INTC_IRQ(SCIF0, 90), INTC_IRQ(SCIF0, 91),
-	INTC_IRQ(SCIF1, 92), INTC_IRQ(SCIF1, 93),
-	INTC_IRQ(SCIF1, 94), INTC_IRQ(SCIF1, 95),
-	INTC_IRQ(SCIF2, 96), INTC_IRQ(SCIF2, 97),
-	INTC_IRQ(SCIF2, 98), INTC_IRQ(SCIF2, 99),
-	INTC_IRQ(HIF_HIFI, 100), INTC_IRQ(HIF_HIFBI, 101),
-	INTC_IRQ(DMAC0, 104), INTC_IRQ(DMAC1, 105),
-	INTC_IRQ(DMAC2, 106), INTC_IRQ(DMAC3, 107),
-	INTC_IRQ(SIOF, 108),
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xf8140006, 0, 16, 4, /* IPRA */ { IRQ0, IRQ1, IRQ2, IRQ3 } },
-	{ 0xf8140008, 0, 16, 4, /* IPRB */ { IRQ4, IRQ5, IRQ6, IRQ7 } },
-	{ 0xf8080000, 0, 16, 4, /* IPRC */ { WDT, EDMAC, CMT0, CMT1 } },
-	{ 0xf8080002, 0, 16, 4, /* IPRD */ { SCIF0, SCIF1, SCIF2 } },
-	{ 0xf8080004, 0, 16, 4, /* IPRE */ { HIF_HIFI, HIF_HIFBI } },
-	{ 0xf8080006, 0, 16, 4, /* IPRF */ { DMAC0, DMAC1, DMAC2, DMAC3 } },
-	{ 0xf8080008, 0, 16, 4, /* IPRG */ { SIOF } },
-};
-
-static DECLARE_INTC_DESC(intc_desc, "sh7619", vectors, NULL,
-			 NULL, prio_registers, NULL);
-
-static struct plat_sci_port scif0_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xf8400000, 0x100),
-	DEFINE_RES_IRQ(88),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct plat_sci_port scif1_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif1_resources[] = {
-	DEFINE_RES_MEM(0xf8410000, 0x100),
-	DEFINE_RES_IRQ(92),
-};
-
-static struct platform_device scif1_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif1_resources,
-	.num_resources	= ARRAY_SIZE(scif1_resources),
-	.dev		= {
-		.platform_data	= &scif1_platform_data,
-	},
-};
-
-static struct plat_sci_port scif2_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif2_resources[] = {
-	DEFINE_RES_MEM(0xf8420000, 0x100),
-	DEFINE_RES_IRQ(96),
-};
-
-static struct platform_device scif2_device = {
-	.name		= "sh-sci",
-	.id		= 2,
-	.resource	= scif2_resources,
-	.num_resources	= ARRAY_SIZE(scif2_resources),
-	.dev		= {
-		.platform_data	= &scif2_platform_data,
-	},
-};
-
-static struct sh_eth_plat_data eth_platform_data = {
-	.phy		= 1,
-	.phy_interface	= PHY_INTERFACE_MODE_MII,
-};
-
-static struct resource eth_resources[] = {
-	[0] = {
-		.start = 0xfb000000,
-		.end = 0xfb0001c7,
-		.flags = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start = 85,
-		.end = 85,
-		.flags = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device eth_device = {
-	.name = "sh7619-ether",
-	.id = -1,
-	.dev = {
-		.platform_data = &eth_platform_data,
-	},
-	.num_resources = ARRAY_SIZE(eth_resources),
-	.resource = eth_resources,
-};
-
-static struct sh_timer_config cmt_platform_data = {
-	.channels_mask = 3,
-};
-
-static struct resource cmt_resources[] = {
-	DEFINE_RES_MEM(0xf84a0070, 0x10),
-	DEFINE_RES_IRQ(86),
-	DEFINE_RES_IRQ(87),
-};
-
-static struct platform_device cmt_device = {
-	.name		= "sh-cmt-16",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &cmt_platform_data,
-	},
-	.resource	= cmt_resources,
-	.num_resources	= ARRAY_SIZE(cmt_resources),
-};
-
-static struct platform_device *sh7619_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&eth_device,
-	&cmt_device,
-};
-
-static int __init sh7619_devices_setup(void)
-{
-	return platform_add_devices(sh7619_devices,
-				    ARRAY_SIZE(sh7619_devices));
-}
-arch_initcall(sh7619_devices_setup);
-
-void __init plat_irq_setup(void)
-{
-	register_intc_controller(&intc_desc);
-}
-
-static struct platform_device *sh7619_early_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&cmt_device,
-};
-
-#define STBCR3 0xf80a0000
-
-void __init plat_early_device_setup(void)
-{
-	/* enable CMT clock */
-	__raw_writeb(__raw_readb(STBCR3) & ~0x10, STBCR3);
-
-	sh_early_platform_add_devices(sh7619_early_devices,
-				   ARRAY_SIZE(sh7619_early_devices));
-}
diff --git a/arch/sh/kernel/cpu/sh2/smp-j2.c b/arch/sh/kernel/cpu/sh2/smp-j2.c
deleted file mode 100644
index d0d5d81455ae1e..00000000000000
--- a/arch/sh/kernel/cpu/sh2/smp-j2.c
+++ /dev/null
@@ -1,136 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SMP support for J2 processor
- *
- * Copyright (C) 2015-2016 Smart Energy Instruments, Inc.
- */
-
-#include <linux/smp.h>
-#include <linux/interrupt.h>
-#include <linux/io.h>
-#include <linux/of_address.h>
-#include <linux/of_irq.h>
-#include <asm/cmpxchg.h>
-
-DEFINE_PER_CPU(unsigned, j2_ipi_messages);
-
-extern u32 *sh2_cpuid_addr;
-static u32 *j2_ipi_trigger;
-static int j2_ipi_irq;
-
-static irqreturn_t j2_ipi_interrupt_handler(int irq, void *arg)
-{
-	unsigned cpu = hard_smp_processor_id();
-	volatile unsigned *pmsg = &per_cpu(j2_ipi_messages, cpu);
-	unsigned messages, i;
-
-	do messages = *pmsg;
-	while (cmpxchg(pmsg, messages, 0) != messages);
-
-	if (!messages) return IRQ_NONE;
-
-	for (i=0; i<SMP_MSG_NR; i++)
-		if (messages & (1U<<i))
-			smp_message_recv(i);
-
-	return IRQ_HANDLED;
-}
-
-static void j2_smp_setup(void)
-{
-}
-
-static void j2_prepare_cpus(unsigned int max_cpus)
-{
-	struct device_node *np;
-	unsigned i, max = 1;
-
-	np = of_find_compatible_node(NULL, NULL, "jcore,ipi-controller");
-	if (!np)
-		goto out;
-
-	j2_ipi_irq = irq_of_parse_and_map(np, 0);
-	j2_ipi_trigger = of_iomap(np, 0);
-	if (!j2_ipi_irq || !j2_ipi_trigger)
-		goto out;
-
-	np = of_find_compatible_node(NULL, NULL, "jcore,cpuid-mmio");
-	if (!np)
-		goto out;
-
-	sh2_cpuid_addr = of_iomap(np, 0);
-	if (!sh2_cpuid_addr)
-		goto out;
-
-	if (request_irq(j2_ipi_irq, j2_ipi_interrupt_handler, IRQF_PERCPU,
-			"ipi", (void *)j2_ipi_interrupt_handler) != 0)
-		goto out;
-
-	max = max_cpus;
-out:
-	/* Disable any cpus past max_cpus, or all secondaries if we didn't
-	 * get the necessary resources to support SMP. */
-	for (i=max; i<NR_CPUS; i++) {
-		set_cpu_possible(i, false);
-		set_cpu_present(i, false);
-	}
-}
-
-static void j2_start_cpu(unsigned int cpu, unsigned long entry_point)
-{
-	struct device_node *np;
-	u32 regs[2];
-	void __iomem *release, *initpc;
-
-	if (!cpu) return;
-
-	np = of_get_cpu_node(cpu, NULL);
-	if (!np) return;
-
-	if (of_property_read_u32_array(np, "cpu-release-addr", regs, 2)) return;
-	release = ioremap(regs[0], sizeof(u32));
-	initpc = ioremap(regs[1], sizeof(u32));
-
-	__raw_writel(entry_point, initpc);
-	__raw_writel(1, release);
-
-	iounmap(initpc);
-	iounmap(release);
-
-	pr_info("J2 SMP: requested start of cpu %u\n", cpu);
-}
-
-static unsigned int j2_smp_processor_id(void)
-{
-	return __raw_readl(sh2_cpuid_addr);
-}
-
-static void j2_send_ipi(unsigned int cpu, unsigned int message)
-{
-	volatile unsigned *pmsg;
-	unsigned old;
-	unsigned long val;
-
-	/* There is only one IPI interrupt shared by all messages, so
-	 * we keep a separate interrupt flag per message type in sw. */
-	pmsg = &per_cpu(j2_ipi_messages, cpu);
-	do old = *pmsg;
-	while (cmpxchg(pmsg, old, old|(1U<<message)) != old);
-
-	/* Generate the actual interrupt by writing to CCRn bit 28. */
-	val = __raw_readl(j2_ipi_trigger + cpu);
-	__raw_writel(val | (1U<<28), j2_ipi_trigger + cpu);
-}
-
-static struct plat_smp_ops j2_smp_ops = {
-	.smp_setup		= j2_smp_setup,
-	.prepare_cpus		= j2_prepare_cpus,
-	.start_cpu		= j2_start_cpu,
-	.smp_processor_id	= j2_smp_processor_id,
-	.send_ipi		= j2_send_ipi,
-	.cpu_die		= native_cpu_die,
-	.cpu_disable		= native_cpu_disable,
-	.play_dead		= native_play_dead,
-};
-
-CPU_METHOD_OF_DECLARE(j2_cpu_method, "jcore,spin-table", &j2_smp_ops);
diff --git a/arch/sh/kernel/cpu/sh2a/Makefile b/arch/sh/kernel/cpu/sh2a/Makefile
deleted file mode 100644
index 2a7515b658fd38..00000000000000
--- a/arch/sh/kernel/cpu/sh2a/Makefile
+++ /dev/null
@@ -1,25 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the Linux/SuperH SH-2A backends.
-#
-
-obj-y	:= common.o probe.o opcode_helper.o
-
-common-y	+= ex.o entry.o
-
-obj-$(CONFIG_SH_FPU)	+= fpu.o
-
-obj-$(CONFIG_CPU_SUBTYPE_SH7201)	+= setup-sh7201.o clock-sh7201.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7203)	+= setup-sh7203.o clock-sh7203.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7263)	+= setup-sh7203.o clock-sh7203.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7264)	+= setup-sh7264.o clock-sh7264.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7206)	+= setup-sh7206.o clock-sh7206.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7269)	+= setup-sh7269.o clock-sh7269.o
-obj-$(CONFIG_CPU_SUBTYPE_MXG)		+= setup-mxg.o clock-sh7206.o
-
-# Pinmux setup
-pinmux-$(CONFIG_CPU_SUBTYPE_SH7203)	:= pinmux-sh7203.o
-pinmux-$(CONFIG_CPU_SUBTYPE_SH7264)	:= pinmux-sh7264.o
-pinmux-$(CONFIG_CPU_SUBTYPE_SH7269)	:= pinmux-sh7269.o
-
-obj-$(CONFIG_GPIOLIB)			+= $(pinmux-y)
diff --git a/arch/sh/kernel/cpu/sh2a/clock-sh7201.c b/arch/sh/kernel/cpu/sh2a/clock-sh7201.c
deleted file mode 100644
index 5a5daaafb27a49..00000000000000
--- a/arch/sh/kernel/cpu/sh2a/clock-sh7201.c
+++ /dev/null
@@ -1,82 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh2a/clock-sh7201.c
- *
- * SH7201 support for the clock framework
- *
- *  Copyright (C) 2008 Peter Griffin  <pgriffin@mpc-data.co.uk>
- *
- * Based on clock-sh4.c
- *  Copyright (C) 2005  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <asm/clock.h>
-#include <asm/freq.h>
-#include <asm/io.h>
-
-static const int pll1rate[]={1,2,3,4,6,8};
-static const int pfc_divisors[]={1,2,3,4,6,8,12};
-#define ifc_divisors pfc_divisors
-
-static unsigned int pll2_mult;
-
-static void master_clk_init(struct clk *clk)
-{
-	clk->rate = 10000000 * pll2_mult *
-	       pll1rate[(__raw_readw(FREQCR) >> 8) & 0x0007];
-}
-
-static struct sh_clk_ops sh7201_master_clk_ops = {
-	.init		= master_clk_init,
-};
-
-static unsigned long module_clk_recalc(struct clk *clk)
-{
-	int idx = (__raw_readw(FREQCR) & 0x0007);
-	return clk->parent->rate / pfc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7201_module_clk_ops = {
-	.recalc		= module_clk_recalc,
-};
-
-static unsigned long bus_clk_recalc(struct clk *clk)
-{
-	int idx = (__raw_readw(FREQCR) & 0x0007);
-	return clk->parent->rate / pfc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7201_bus_clk_ops = {
-	.recalc		= bus_clk_recalc,
-};
-
-static unsigned long cpu_clk_recalc(struct clk *clk)
-{
-	int idx = ((__raw_readw(FREQCR) >> 4) & 0x0007);
-	return clk->parent->rate / ifc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7201_cpu_clk_ops = {
-	.recalc		= cpu_clk_recalc,
-};
-
-static struct sh_clk_ops *sh7201_clk_ops[] = {
-	&sh7201_master_clk_ops,
-	&sh7201_module_clk_ops,
-	&sh7201_bus_clk_ops,
-	&sh7201_cpu_clk_ops,
-};
-
-void __init arch_init_clk_ops(struct sh_clk_ops **ops, int idx)
-{
-	if (test_mode_pin(MODE_PIN1 | MODE_PIN0))
-		pll2_mult = 1;
-	else if (test_mode_pin(MODE_PIN1))
-		pll2_mult = 2;
-	else
-		pll2_mult = 4;
-
-	if (idx < ARRAY_SIZE(sh7201_clk_ops))
-		*ops = sh7201_clk_ops[idx];
-}
diff --git a/arch/sh/kernel/cpu/sh2a/clock-sh7203.c b/arch/sh/kernel/cpu/sh2a/clock-sh7203.c
deleted file mode 100644
index c6205394566441..00000000000000
--- a/arch/sh/kernel/cpu/sh2a/clock-sh7203.c
+++ /dev/null
@@ -1,78 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh2a/clock-sh7203.c
- *
- * SH7203 support for the clock framework
- *
- *  Copyright (C) 2007 Kieran Bingham (MPC-Data Ltd)
- *
- * Based on clock-sh7263.c
- *  Copyright (C) 2006  Yoshinori Sato
- *
- * Based on clock-sh4.c
- *  Copyright (C) 2005  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <asm/clock.h>
-#include <asm/freq.h>
-#include <asm/io.h>
-
-static const int pll1rate[]={8,12,16,0};
-static const int pfc_divisors[]={1,2,3,4,6,8,12};
-#define ifc_divisors pfc_divisors
-
-static unsigned int pll2_mult;
-
-static void master_clk_init(struct clk *clk)
-{
-	clk->rate *= pll1rate[(__raw_readw(FREQCR) >> 8) & 0x0003] * pll2_mult;
-}
-
-static struct sh_clk_ops sh7203_master_clk_ops = {
-	.init		= master_clk_init,
-};
-
-static unsigned long module_clk_recalc(struct clk *clk)
-{
-	int idx = (__raw_readw(FREQCR) & 0x0007);
-	return clk->parent->rate / pfc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7203_module_clk_ops = {
-	.recalc		= module_clk_recalc,
-};
-
-static unsigned long bus_clk_recalc(struct clk *clk)
-{
-	int idx = (__raw_readw(FREQCR) & 0x0007);
-	return clk->parent->rate / pfc_divisors[idx-2];
-}
-
-static struct sh_clk_ops sh7203_bus_clk_ops = {
-	.recalc		= bus_clk_recalc,
-};
-
-static struct sh_clk_ops sh7203_cpu_clk_ops = {
-	.recalc		= followparent_recalc,
-};
-
-static struct sh_clk_ops *sh7203_clk_ops[] = {
-	&sh7203_master_clk_ops,
-	&sh7203_module_clk_ops,
-	&sh7203_bus_clk_ops,
-	&sh7203_cpu_clk_ops,
-};
-
-void __init arch_init_clk_ops(struct sh_clk_ops **ops, int idx)
-{
-	if (test_mode_pin(MODE_PIN1))
-		pll2_mult = 4;
-	else if (test_mode_pin(MODE_PIN0))
-		pll2_mult = 2;
-	else
-		pll2_mult = 1;
-
-	if (idx < ARRAY_SIZE(sh7203_clk_ops))
-		*ops = sh7203_clk_ops[idx];
-}
diff --git a/arch/sh/kernel/cpu/sh2a/clock-sh7206.c b/arch/sh/kernel/cpu/sh2a/clock-sh7206.c
deleted file mode 100644
index d286d7b918d5e3..00000000000000
--- a/arch/sh/kernel/cpu/sh2a/clock-sh7206.c
+++ /dev/null
@@ -1,80 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh2a/clock-sh7206.c
- *
- * SH7206 support for the clock framework
- *
- *  Copyright (C) 2006  Yoshinori Sato
- *
- * Based on clock-sh4.c
- *  Copyright (C) 2005  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <asm/clock.h>
-#include <asm/freq.h>
-#include <asm/io.h>
-
-static const int pll1rate[]={1,2,3,4,6,8};
-static const int pfc_divisors[]={1,2,3,4,6,8,12};
-#define ifc_divisors pfc_divisors
-
-static unsigned int pll2_mult;
-
-static void master_clk_init(struct clk *clk)
-{
-	clk->rate *= pll2_mult * pll1rate[(__raw_readw(FREQCR) >> 8) & 0x0007];
-}
-
-static struct sh_clk_ops sh7206_master_clk_ops = {
-	.init		= master_clk_init,
-};
-
-static unsigned long module_clk_recalc(struct clk *clk)
-{
-	int idx = (__raw_readw(FREQCR) & 0x0007);
-	return clk->parent->rate / pfc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7206_module_clk_ops = {
-	.recalc		= module_clk_recalc,
-};
-
-static unsigned long bus_clk_recalc(struct clk *clk)
-{
-	return clk->parent->rate / pll1rate[(__raw_readw(FREQCR) >> 8) & 0x0007];
-}
-
-static struct sh_clk_ops sh7206_bus_clk_ops = {
-	.recalc		= bus_clk_recalc,
-};
-
-static unsigned long cpu_clk_recalc(struct clk *clk)
-{
-	int idx = (__raw_readw(FREQCR) & 0x0007);
-	return clk->parent->rate / ifc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7206_cpu_clk_ops = {
-	.recalc		= cpu_clk_recalc,
-};
-
-static struct sh_clk_ops *sh7206_clk_ops[] = {
-	&sh7206_master_clk_ops,
-	&sh7206_module_clk_ops,
-	&sh7206_bus_clk_ops,
-	&sh7206_cpu_clk_ops,
-};
-
-void __init arch_init_clk_ops(struct sh_clk_ops **ops, int idx)
-{
-	if (test_mode_pin(MODE_PIN2 | MODE_PIN1 | MODE_PIN0))
-		pll2_mult = 1;
-	else if (test_mode_pin(MODE_PIN2 | MODE_PIN1))
-		pll2_mult = 2;
-	else if (test_mode_pin(MODE_PIN1))
-		pll2_mult = 4;
-
-	if (idx < ARRAY_SIZE(sh7206_clk_ops))
-		*ops = sh7206_clk_ops[idx];
-}
diff --git a/arch/sh/kernel/cpu/sh2a/clock-sh7264.c b/arch/sh/kernel/cpu/sh2a/clock-sh7264.c
deleted file mode 100644
index d9acc1ed79817c..00000000000000
--- a/arch/sh/kernel/cpu/sh2a/clock-sh7264.c
+++ /dev/null
@@ -1,157 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh2a/clock-sh7264.c
- *
- * SH7264 clock framework support
- *
- * Copyright (C) 2012  Phil Edworthy
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/clkdev.h>
-#include <asm/clock.h>
-
-/* SH7264 registers */
-#define FRQCR		0xfffe0010
-#define STBCR3		0xfffe0408
-#define STBCR4		0xfffe040c
-#define STBCR5		0xfffe0410
-#define STBCR6		0xfffe0414
-#define STBCR7		0xfffe0418
-#define STBCR8		0xfffe041c
-
-static const unsigned int pll1rate[] = {8, 12};
-
-static unsigned int pll1_div;
-
-/* Fixed 32 KHz root clock for RTC */
-static struct clk r_clk = {
-	.rate           = 32768,
-};
-
-/*
- * Default rate for the root input clock, reset this with clk_set_rate()
- * from the platform code.
- */
-static struct clk extal_clk = {
-	.rate		= 18000000,
-};
-
-static unsigned long pll_recalc(struct clk *clk)
-{
-	unsigned long rate = clk->parent->rate / pll1_div;
-	return rate * pll1rate[(__raw_readw(FRQCR) >> 8) & 1];
-}
-
-static struct sh_clk_ops pll_clk_ops = {
-	.recalc		= pll_recalc,
-};
-
-static struct clk pll_clk = {
-	.ops		= &pll_clk_ops,
-	.parent		= &extal_clk,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-struct clk *main_clks[] = {
-	&r_clk,
-	&extal_clk,
-	&pll_clk,
-};
-
-static int div2[] = { 1, 2, 3, 4, 6, 8, 12 };
-
-static struct clk_div_mult_table div4_div_mult_table = {
-	.divisors = div2,
-	.nr_divisors = ARRAY_SIZE(div2),
-};
-
-static struct clk_div4_table div4_table = {
-	.div_mult_table = &div4_div_mult_table,
-};
-
-enum { DIV4_I, DIV4_P,
-       DIV4_NR };
-
-#define DIV4(_reg, _bit, _mask, _flags) \
-  SH_CLK_DIV4(&pll_clk, _reg, _bit, _mask, _flags)
-
-/* The mask field specifies the div2 entries that are valid */
-struct clk div4_clks[DIV4_NR] = {
-	[DIV4_I] = DIV4(FRQCR, 4, 0x7,  CLK_ENABLE_REG_16BIT
-					| CLK_ENABLE_ON_INIT),
-	[DIV4_P] = DIV4(FRQCR, 0, 0x78, CLK_ENABLE_REG_16BIT),
-};
-
-enum {	MSTP77, MSTP74, MSTP72,
-	MSTP60,
-	MSTP35, MSTP34, MSTP33, MSTP32, MSTP30,
-	MSTP_NR };
-
-static struct clk mstp_clks[MSTP_NR] = {
-	[MSTP77] = SH_CLK_MSTP8(&div4_clks[DIV4_P], STBCR7, 7, 0), /* SCIF */
-	[MSTP74] = SH_CLK_MSTP8(&div4_clks[DIV4_P], STBCR7, 4, 0), /* VDC */
-	[MSTP72] = SH_CLK_MSTP8(&div4_clks[DIV4_P], STBCR7, 2, 0), /* CMT */
-	[MSTP60] = SH_CLK_MSTP8(&div4_clks[DIV4_P], STBCR6, 0, 0), /* USB */
-	[MSTP35] = SH_CLK_MSTP8(&div4_clks[DIV4_P], STBCR3, 6, 0), /* MTU2 */
-	[MSTP34] = SH_CLK_MSTP8(&div4_clks[DIV4_P], STBCR3, 4, 0), /* SDHI0 */
-	[MSTP33] = SH_CLK_MSTP8(&div4_clks[DIV4_P], STBCR3, 3, 0), /* SDHI1 */
-	[MSTP32] = SH_CLK_MSTP8(&div4_clks[DIV4_P], STBCR3, 2, 0), /* ADC */
-	[MSTP30] = SH_CLK_MSTP8(&r_clk, STBCR3, 0, 0),	/* RTC */
-};
-
-static struct clk_lookup lookups[] = {
-	/* main clocks */
-	CLKDEV_CON_ID("rclk", &r_clk),
-	CLKDEV_CON_ID("extal", &extal_clk),
-	CLKDEV_CON_ID("pll_clk", &pll_clk),
-
-	/* DIV4 clocks */
-	CLKDEV_CON_ID("cpu_clk", &div4_clks[DIV4_I]),
-	CLKDEV_CON_ID("peripheral_clk", &div4_clks[DIV4_P]),
-
-	/* MSTP clocks */
-	CLKDEV_ICK_ID("fck", "sh-sci.0", &mstp_clks[MSTP77]),
-	CLKDEV_ICK_ID("fck", "sh-sci.1", &mstp_clks[MSTP77]),
-	CLKDEV_ICK_ID("fck", "sh-sci.2", &mstp_clks[MSTP77]),
-	CLKDEV_ICK_ID("fck", "sh-sci.3", &mstp_clks[MSTP77]),
-	CLKDEV_ICK_ID("fck", "sh-sci.4", &mstp_clks[MSTP77]),
-	CLKDEV_ICK_ID("fck", "sh-sci.5", &mstp_clks[MSTP77]),
-	CLKDEV_ICK_ID("fck", "sh-sci.6", &mstp_clks[MSTP77]),
-	CLKDEV_ICK_ID("fck", "sh-sci.7", &mstp_clks[MSTP77]),
-	CLKDEV_CON_ID("vdc3", &mstp_clks[MSTP74]),
-	CLKDEV_ICK_ID("fck", "sh-cmt-16.0", &mstp_clks[MSTP72]),
-	CLKDEV_CON_ID("usb0", &mstp_clks[MSTP60]),
-	CLKDEV_ICK_ID("fck", "sh-mtu2", &mstp_clks[MSTP35]),
-	CLKDEV_CON_ID("sdhi0", &mstp_clks[MSTP34]),
-	CLKDEV_CON_ID("sdhi1", &mstp_clks[MSTP33]),
-	CLKDEV_CON_ID("adc0", &mstp_clks[MSTP32]),
-	CLKDEV_CON_ID("rtc0", &mstp_clks[MSTP30]),
-};
-
-int __init arch_clk_init(void)
-{
-	int k, ret = 0;
-
-	if (test_mode_pin(MODE_PIN0)) {
-		if (test_mode_pin(MODE_PIN1))
-			pll1_div = 3;
-		else
-			pll1_div = 4;
-	} else
-		pll1_div = 1;
-
-	for (k = 0; !ret && (k < ARRAY_SIZE(main_clks)); k++)
-		ret = clk_register(main_clks[k]);
-
-	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
-
-	if (!ret)
-		ret = sh_clk_div4_register(div4_clks, DIV4_NR, &div4_table);
-
-	if (!ret)
-		ret = sh_clk_mstp_register(mstp_clks, MSTP_NR);
-
-	return ret;
-}
diff --git a/arch/sh/kernel/cpu/sh2a/clock-sh7269.c b/arch/sh/kernel/cpu/sh2a/clock-sh7269.c
deleted file mode 100644
index c17ab0d7653888..00000000000000
--- a/arch/sh/kernel/cpu/sh2a/clock-sh7269.c
+++ /dev/null
@@ -1,181 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh2a/clock-sh7269.c
- *
- * SH7269 clock framework support
- *
- * Copyright (C) 2012  Phil Edworthy
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/clkdev.h>
-#include <asm/clock.h>
-
-/* SH7269 registers */
-#define FRQCR		0xfffe0010
-#define STBCR3 		0xfffe0408
-#define STBCR4 		0xfffe040c
-#define STBCR5 		0xfffe0410
-#define STBCR6 		0xfffe0414
-#define STBCR7 		0xfffe0418
-
-#define PLL_RATE 20
-
-/* Fixed 32 KHz root clock for RTC */
-static struct clk r_clk = {
-	.rate           = 32768,
-};
-
-/*
- * Default rate for the root input clock, reset this with clk_set_rate()
- * from the platform code.
- */
-static struct clk extal_clk = {
-	.rate		= 13340000,
-};
-
-static unsigned long pll_recalc(struct clk *clk)
-{
-	return clk->parent->rate * PLL_RATE;
-}
-
-static struct sh_clk_ops pll_clk_ops = {
-	.recalc		= pll_recalc,
-};
-
-static struct clk pll_clk = {
-	.ops		= &pll_clk_ops,
-	.parent		= &extal_clk,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-static unsigned long peripheral0_recalc(struct clk *clk)
-{
-	return clk->parent->rate / 8;
-}
-
-static struct sh_clk_ops peripheral0_clk_ops = {
-	.recalc		= peripheral0_recalc,
-};
-
-static struct clk peripheral0_clk = {
-	.ops		= &peripheral0_clk_ops,
-	.parent		= &pll_clk,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-static unsigned long peripheral1_recalc(struct clk *clk)
-{
-	return clk->parent->rate / 4;
-}
-
-static struct sh_clk_ops peripheral1_clk_ops = {
-	.recalc		= peripheral1_recalc,
-};
-
-static struct clk peripheral1_clk = {
-	.ops		= &peripheral1_clk_ops,
-	.parent		= &pll_clk,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-struct clk *main_clks[] = {
-	&r_clk,
-	&extal_clk,
-	&pll_clk,
-	&peripheral0_clk,
-	&peripheral1_clk,
-};
-
-static int div2[] = { 1, 2, 0, 4 };
-
-static struct clk_div_mult_table div4_div_mult_table = {
-	.divisors = div2,
-	.nr_divisors = ARRAY_SIZE(div2),
-};
-
-static struct clk_div4_table div4_table = {
-	.div_mult_table = &div4_div_mult_table,
-};
-
-enum { DIV4_I, DIV4_B,
-       DIV4_NR };
-
-#define DIV4(_reg, _bit, _mask, _flags) \
-  SH_CLK_DIV4(&pll_clk, _reg, _bit, _mask, _flags)
-
-/* The mask field specifies the div2 entries that are valid */
-struct clk div4_clks[DIV4_NR] = {
-	[DIV4_I]  = DIV4(FRQCR, 8, 0xB, CLK_ENABLE_REG_16BIT
-					| CLK_ENABLE_ON_INIT),
-	[DIV4_B]  = DIV4(FRQCR, 4, 0xA, CLK_ENABLE_REG_16BIT
-					| CLK_ENABLE_ON_INIT),
-};
-
-enum { MSTP72,
-	MSTP60,
-	MSTP47, MSTP46, MSTP45, MSTP44, MSTP43, MSTP42, MSTP41, MSTP40,
-	MSTP35, MSTP32, MSTP30,
-	MSTP_NR };
-
-static struct clk mstp_clks[MSTP_NR] = {
-	[MSTP72] = SH_CLK_MSTP8(&peripheral0_clk, STBCR7, 2, 0), /* CMT */
-	[MSTP60] = SH_CLK_MSTP8(&peripheral1_clk, STBCR6, 0, 0), /* USB */
-	[MSTP47] = SH_CLK_MSTP8(&peripheral1_clk, STBCR4, 7, 0), /* SCIF0 */
-	[MSTP46] = SH_CLK_MSTP8(&peripheral1_clk, STBCR4, 6, 0), /* SCIF1 */
-	[MSTP45] = SH_CLK_MSTP8(&peripheral1_clk, STBCR4, 5, 0), /* SCIF2 */
-	[MSTP44] = SH_CLK_MSTP8(&peripheral1_clk, STBCR4, 4, 0), /* SCIF3 */
-	[MSTP43] = SH_CLK_MSTP8(&peripheral1_clk, STBCR4, 3, 0), /* SCIF4 */
-	[MSTP42] = SH_CLK_MSTP8(&peripheral1_clk, STBCR4, 2, 0), /* SCIF5 */
-	[MSTP41] = SH_CLK_MSTP8(&peripheral1_clk, STBCR4, 1, 0), /* SCIF6 */
-	[MSTP40] = SH_CLK_MSTP8(&peripheral1_clk, STBCR4, 0, 0), /* SCIF7 */
-	[MSTP35] = SH_CLK_MSTP8(&peripheral0_clk, STBCR3, 5, 0), /* MTU2 */
-	[MSTP32] = SH_CLK_MSTP8(&peripheral1_clk, STBCR3, 2, 0), /* ADC */
-	[MSTP30] = SH_CLK_MSTP8(&r_clk, STBCR3, 0, 0), /* RTC */
-};
-
-static struct clk_lookup lookups[] = {
-	/* main clocks */
-	CLKDEV_CON_ID("rclk", &r_clk),
-	CLKDEV_CON_ID("extal", &extal_clk),
-	CLKDEV_CON_ID("pll_clk", &pll_clk),
-	CLKDEV_CON_ID("peripheral_clk", &peripheral1_clk),
-
-	/* DIV4 clocks */
-	CLKDEV_CON_ID("cpu_clk", &div4_clks[DIV4_I]),
-	CLKDEV_CON_ID("bus_clk", &div4_clks[DIV4_B]),
-
-	/* MSTP clocks */
-	CLKDEV_ICK_ID("fck", "sh-sci.0", &mstp_clks[MSTP47]),
-	CLKDEV_ICK_ID("fck", "sh-sci.1", &mstp_clks[MSTP46]),
-	CLKDEV_ICK_ID("fck", "sh-sci.2", &mstp_clks[MSTP45]),
-	CLKDEV_ICK_ID("fck", "sh-sci.3", &mstp_clks[MSTP44]),
-	CLKDEV_ICK_ID("fck", "sh-sci.4", &mstp_clks[MSTP43]),
-	CLKDEV_ICK_ID("fck", "sh-sci.5", &mstp_clks[MSTP42]),
-	CLKDEV_ICK_ID("fck", "sh-sci.6", &mstp_clks[MSTP41]),
-	CLKDEV_ICK_ID("fck", "sh-sci.7", &mstp_clks[MSTP40]),
-	CLKDEV_ICK_ID("fck", "sh-cmt-16.0", &mstp_clks[MSTP72]),
-	CLKDEV_CON_ID("usb0", &mstp_clks[MSTP60]),
-	CLKDEV_ICK_ID("fck", "sh-mtu2", &mstp_clks[MSTP35]),
-	CLKDEV_CON_ID("adc0", &mstp_clks[MSTP32]),
-	CLKDEV_CON_ID("rtc0", &mstp_clks[MSTP30]),
-};
-
-int __init arch_clk_init(void)
-{
-	int k, ret = 0;
-
-	for (k = 0; !ret && (k < ARRAY_SIZE(main_clks)); k++)
-		ret = clk_register(main_clks[k]);
-
-	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
-
-	if (!ret)
-		ret = sh_clk_div4_register(div4_clks, DIV4_NR, &div4_table);
-
-	if (!ret)
-		ret = sh_clk_mstp_register(mstp_clks, MSTP_NR);
-
-	return ret;
-}
diff --git a/arch/sh/kernel/cpu/sh2a/entry.S b/arch/sh/kernel/cpu/sh2a/entry.S
deleted file mode 100644
index 9f11fc8b505251..00000000000000
--- a/arch/sh/kernel/cpu/sh2a/entry.S
+++ /dev/null
@@ -1,247 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * arch/sh/kernel/cpu/sh2a/entry.S
- *
- * The SH-2A exception entry
- *
- * Copyright (C) 2008 Yoshinori Sato
- * Based on arch/sh/kernel/cpu/sh2/entry.S
- */
-
-#include <linux/linkage.h>
-#include <asm/asm-offsets.h>
-#include <asm/thread_info.h>
-#include <cpu/mmu_context.h>
-#include <asm/unistd.h>
-#include <asm/errno.h>
-#include <asm/page.h>
-	
-/* Offsets to the stack */
-OFF_R0  =  0		/* Return value. New ABI also arg4 */
-OFF_R1  =  4     	/* New ABI: arg5 */
-OFF_R2  =  8     	/* New ABI: arg6 */
-OFF_R3  =  12     	/* New ABI: syscall_nr */
-OFF_R4  =  16     	/* New ABI: arg0 */
-OFF_R5  =  20     	/* New ABI: arg1 */
-OFF_R6  =  24     	/* New ABI: arg2 */
-OFF_R7  =  28     	/* New ABI: arg3 */
-OFF_SP	=  (15*4)
-OFF_PC  =  (16*4)
-OFF_SR	=  (16*4+2*4)
-OFF_TRA	=  (16*4+6*4)
-
-#include <asm/entry-macros.S>
-
-ENTRY(exception_handler)
-	! stack
-	! r0 <- point sp
-	! r1
-	! pc
-	! sr
-	! r0 = temporary
-	! r1 = vector (pseudo EXPEVT / INTEVT / TRA)
-	mov.l	r2,@-sp
-	cli
-	mov.l	$cpu_mode,r2
-	bld.b	#6,@(0,r2)	!previus SR.MD
-	bst.b	#6,@(4*4,r15)	!set cpu mode to SR.MD
-	bt	1f
-	! switch to kernel mode
-	bset.b	#6,@(0,r2)	!set SR.MD
-	mov.l	$current_thread_info,r2
-	mov.l	@r2,r2
-	mov	#(THREAD_SIZE >> 8),r0
-	shll8	r0
-	add	r2,r0		! r0 = kernel stack tail
-	mov	r15,r2		! r2 = user stack top
-	mov	r0,r15		! switch kernel stack
-	mov.l	r1,@-r15	! TRA
-	sts.l	macl, @-r15
-	sts.l	mach, @-r15
-	stc.l	gbr, @-r15
-	mov.l	@(4*4,r2),r0
-	mov.l	r0,@-r15	! original SR
-	sts.l	pr,@-r15
-	mov.l	@(3*4,r2),r0
-	mov.l	r0,@-r15	! original PC
-	mov	r2,r0
-	add	#(3+2)*4,r0	! rewind r0 - r3 + exception frame
-	lds	r0,pr		! pr = original SP
-	movmu.l	r3,@-r15	! save regs
-	mov	r2,r8		! r8 =  previus stack top
-	mov	r1,r9		! r9 = interrupt vector
-	! restore previous stack
-	mov.l	@r8+,r2
-	mov.l	@r8+,r0
-	mov.l	@r8+,r1
-	bra	2f
-	 movml.l r2,@-r15
-1:
-	! in kernel exception
-	mov	r15,r2
-	add	#-((OFF_TRA + 4) - OFF_PC) + 5*4,r15
-	movmu.l	r3,@-r15
-	mov	r2,r8		! r8 = previous stack top
-	mov	r1,r9		! r9 = interrupt vector
-	! restore exception frame & regs
-	mov.l	@r8+,r2		! old R2
-	mov.l	@r8+,r0		! old R0
-	mov.l	@r8+,r1		! old R1
-	mov.l	@r8+,r10	! old PC
-	mov.l	@r8+,r11	! old SR
-	movml.l	r2,@-r15
-	mov.l	r10,@(OFF_PC,r15)
-	mov.l	r11,@(OFF_SR,r15)
-	mov.l	r8,@(OFF_SP,r15)	! save old sp
-	mov	r15,r8
-	add	#OFF_TRA + 4,r8
-	mov.l	r9,@-r8
-	sts.l	macl,@-r8
-	sts.l	mach,@-r8
-	stc.l	gbr,@-r8
-	add	#-4,r8
-	sts.l	pr,@-r8
-2:
-	! dispatch exception / interrupt
-	mov	#64,r8
-	cmp/hs	r8,r9
-	bt	interrupt_entry	! vec >= 64 is interrupt
-	mov	#31,r8
-	cmp/hs	r8,r9
-	bt	trap_entry	! 64 > vec >= 31  is trap
-
-	mov.l	4f,r8
-	mov	r9,r4
-	shll2	r9
-	add	r9,r8
-	mov.l	@r8,r8		! exception handler address
-	tst	r8,r8
-	bf	3f
-	mov.l	8f,r8		! unhandled exception
-3:
-	mov.l	5f,r10
-	jmp	@r8
-	 lds	r10,pr
-
-interrupt_entry:
-	mov	r9,r4
-	mov	r15,r5
-	mov.l	7f,r8
-	mov.l	6f,r9
-	jmp	@r8
-	 lds	r9,pr
-
-	.align	2
-4:	.long	exception_handling_table
-5:	.long	ret_from_exception
-6:	.long	ret_from_irq
-7:	.long	do_IRQ
-8:	.long	exception_error
-
-trap_entry:
-	mov	#0x30,r8
-	cmp/ge	r8,r9		! vector 0x1f-0x2f is systemcall
-	bt	1f
-	mov     #0x1f,r9	! convert to unified SH2/3/4 trap number
-1:	
-	shll2	r9			! TRA
-	bra	system_call	! jump common systemcall entry
-	 mov	r9,r8
-	
-#if defined(CONFIG_SH_STANDARD_BIOS)
-	/* Unwind the stack and jmp to the debug entry */
-ENTRY(sh_bios_handler)
-	mov	r15,r0
-	add	#(22-4)*4-4,r0
-	ldc.l	@r0+,gbr
-	lds.l	@r0+,mach
-	lds.l	@r0+,macl
-	mov	r15,r0
-	mov.l	@(OFF_SP,r0),r1
-	mov.l	@(OFF_SR,r2),r3
-	mov.l	r3,@-r1
-	mov.l	@(OFF_SP,r2),r3
-	mov.l	r3,@-r1
-	mov	r15,r0
-	add	#(22-4)*4-8,r0
-	mov.l	1f,r2
-	mov.l	@r2,r2
-	stc	sr,r3
-	mov.l	r2,@r0
-	mov.l	r3,@(4,r0)
-	mov.l	r1,@(8,r0)
-	movml.l	@r15+,r14
-	add	#8,r15
-	lds.l	@r15+, pr
-	mov.l	@r15+,r15
-	rte
-	 nop
-	.align	2
-1:	.long	gdb_vbr_vector
-#endif /* CONFIG_SH_STANDARD_BIOS */
-
-ENTRY(address_error_trap_handler)
-	mov	r15,r4				! regs
-	mov.l	@(OFF_PC,r15),r6		! pc
-	mov.l	1f,r0
-	jmp	@r0
-	 mov	#0,r5				! writeaccess is unknown
-
-	.align	2
-1:	.long	do_address_error
-
-restore_all:
-	stc	sr,r0
-	or	#0xf0,r0
-	ldc	r0,sr				! all interrupt block (same BL = 1)
-	! restore special register
-	! overlap exception frame
-	mov	r15,r0
-	add	#17*4,r0
-	lds.l	@r0+,pr
-	add	#4,r0
-	ldc.l	@r0+,gbr
-	lds.l	@r0+,mach
-	lds.l	@r0+,macl
-	mov	r15,r0
-	mov.l	$cpu_mode,r2
-	bld.b	#6,@(OFF_SR,r15)
-	bst.b	#6,@(0,r2)			! save CPU mode
-	mov.l	@(OFF_SR,r0),r1
-	shll2	r1
-	shlr2	r1				! clear MD bit
-	mov.l	@(OFF_SP,r0),r2
-	add	#-8,r2
-	mov.l	r2,@(OFF_SP,r0)			! point exception frame top
-	mov.l	r1,@(4,r2)			! set sr
-	mov.l	@(OFF_PC,r0),r1
-	mov.l	r1,@r2				! set pc
-	get_current_thread_info r0, r1
-	mov.l	$current_thread_info,r1
-	mov.l	r0,@r1
-	movml.l	@r15+,r14
-	mov.l	@r15,r15
-	rte
-	 nop
-
-	.align 2
-$current_thread_info:
-	.long	__current_thread_info
-$cpu_mode:	
-	.long	__cpu_mode
-		
-! common exception handler
-#include "../../entry-common.S"
-	
-	.data
-! cpu operation mode 
-! bit30 = MD (compatible SH3/4)
-__cpu_mode:
-	.long	0x40000000
-		
-	.section	.bss
-__current_thread_info:
-	.long	0
-
-ENTRY(exception_handling_table)
-	.space	4*32
diff --git a/arch/sh/kernel/cpu/sh2a/ex.S b/arch/sh/kernel/cpu/sh2a/ex.S
deleted file mode 100644
index ed91996287c7d9..00000000000000
--- a/arch/sh/kernel/cpu/sh2a/ex.S
+++ /dev/null
@@ -1,70 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * arch/sh/kernel/cpu/sh2a/ex.S
- *
- * The SH-2A exception vector table
- *
- * Copyright (C) 2008 Yoshinori Sato
- */
-
-#include <linux/linkage.h>
-
-!
-! convert Exception Vector to Exception Number
-!
-
-! exception no 0 to 255
-exception_entry0:
-no	=	0
-	.rept	256
-	mov.l	r1,@-sp
-	bra	exception_trampoline0
-	mov	#no,r1
-no	=	no + 1
-	.endr
-exception_trampoline0:
-	mov.l	r0,@-sp
-	mov.l	1f,r0
-	extu.b	r1,r1
-	jmp	@r0
-	  extu.w	r1,r1
-	 
-	.align	2
-1:	.long	exception_handler
-
-! exception no 256 to 511
-exception_entry1:
-no	=	0
-	.rept	256
-	mov.l	r1,@-sp
-	bra	exception_trampoline1
-	mov	#no,r1
-no	=	no + 1
-	.endr
-exception_trampoline1:
-	mov.l	r0,@-sp
-	extu.b	r1,r1
-	movi20	#0x100,r0
-	add	r0,r1
-	mov.l	1f,r0
-	jmp	@r0
-	  extu.w	r1,r1
-	
-	.align	2
-1:	.long	exception_handler
-
-	!
-! Exception Vector Base
-!
-	.align	2
-ENTRY(vbr_base)
-vector	=	0
-	.rept	256
-	.long	exception_entry0 + vector * 6
-vector	=	vector + 1
-	.endr
-vector	=	0
-	.rept	256
-	.long	exception_entry1 + vector * 6
-vector	=	vector + 1
-	.endr
diff --git a/arch/sh/kernel/cpu/sh2a/fpu.c b/arch/sh/kernel/cpu/sh2a/fpu.c
deleted file mode 100644
index 0bcff11a4843d3..00000000000000
--- a/arch/sh/kernel/cpu/sh2a/fpu.c
+++ /dev/null
@@ -1,572 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Save/restore floating point context for signal handlers.
- *
- * Copyright (C) 1999, 2000  Kaz Kojima & Niibe Yutaka
- *
- * FIXME! These routines can be optimized in big endian case.
- */
-#include <linux/sched/signal.h>
-#include <linux/signal.h>
-#include <asm/processor.h>
-#include <asm/io.h>
-#include <asm/fpu.h>
-#include <asm/traps.h>
-
-/* The PR (precision) bit in the FP Status Register must be clear when
- * an frchg instruction is executed, otherwise the instruction is undefined.
- * Executing frchg with PR set causes a trap on some SH4 implementations.
- */
-
-#define FPSCR_RCHG 0x00000000
-
-
-/*
- * Save FPU registers onto task structure.
- */
-void save_fpu(struct task_struct *tsk)
-{
-	unsigned long dummy;
-
-	enable_fpu();
-	asm volatile("sts.l	fpul, @-%0\n\t"
-		     "sts.l	fpscr, @-%0\n\t"
-		     "fmov.s	fr15, @-%0\n\t"
-		     "fmov.s	fr14, @-%0\n\t"
-		     "fmov.s	fr13, @-%0\n\t"
-		     "fmov.s	fr12, @-%0\n\t"
-		     "fmov.s	fr11, @-%0\n\t"
-		     "fmov.s	fr10, @-%0\n\t"
-		     "fmov.s	fr9, @-%0\n\t"
-		     "fmov.s	fr8, @-%0\n\t"
-		     "fmov.s	fr7, @-%0\n\t"
-		     "fmov.s	fr6, @-%0\n\t"
-		     "fmov.s	fr5, @-%0\n\t"
-		     "fmov.s	fr4, @-%0\n\t"
-		     "fmov.s	fr3, @-%0\n\t"
-		     "fmov.s	fr2, @-%0\n\t"
-		     "fmov.s	fr1, @-%0\n\t"
-		     "fmov.s	fr0, @-%0\n\t"
-		     "lds	%3, fpscr\n\t"
-		     : "=r" (dummy)
-		     : "0" ((char *)(&tsk->thread.xstate->hardfpu.status)),
-		       "r" (FPSCR_RCHG),
-		       "r" (FPSCR_INIT)
-		     : "memory");
-
-	disable_fpu();
-}
-
-void restore_fpu(struct task_struct *tsk)
-{
-	unsigned long dummy;
-
-	enable_fpu();
-	asm volatile("fmov.s	@%0+, fr0\n\t"
-		     "fmov.s	@%0+, fr1\n\t"
-		     "fmov.s	@%0+, fr2\n\t"
-		     "fmov.s	@%0+, fr3\n\t"
-		     "fmov.s	@%0+, fr4\n\t"
-		     "fmov.s	@%0+, fr5\n\t"
-		     "fmov.s	@%0+, fr6\n\t"
-		     "fmov.s	@%0+, fr7\n\t"
-		     "fmov.s	@%0+, fr8\n\t"
-		     "fmov.s	@%0+, fr9\n\t"
-		     "fmov.s	@%0+, fr10\n\t"
-		     "fmov.s	@%0+, fr11\n\t"
-		     "fmov.s	@%0+, fr12\n\t"
-		     "fmov.s	@%0+, fr13\n\t"
-		     "fmov.s	@%0+, fr14\n\t"
-		     "fmov.s	@%0+, fr15\n\t"
-		     "lds.l	@%0+, fpscr\n\t"
-		     "lds.l	@%0+, fpul\n\t"
-		     : "=r" (dummy)
-		     : "0" (tsk->thread.xstate), "r" (FPSCR_RCHG)
-		     : "memory");
-	disable_fpu();
-}
-
-/*
- *	Emulate arithmetic ops on denormalized number for some FPU insns.
- */
-
-/* denormalized float * float */
-static int denormal_mulf(int hx, int hy)
-{
-	unsigned int ix, iy;
-	unsigned long long m, n;
-	int exp, w;
-
-	ix = hx & 0x7fffffff;
-	iy = hy & 0x7fffffff;
-	if (iy < 0x00800000 || ix == 0)
-		return ((hx ^ hy) & 0x80000000);
-
-	exp = (iy & 0x7f800000) >> 23;
-	ix &= 0x007fffff;
-	iy = (iy & 0x007fffff) | 0x00800000;
-	m = (unsigned long long)ix * iy;
-	n = m;
-	w = -1;
-	while (n) { n >>= 1; w++; }
-
-	/* FIXME: use guard bits */
-	exp += w - 126 - 46;
-	if (exp > 0)
-		ix = ((int) (m >> (w - 23)) & 0x007fffff) | (exp << 23);
-	else if (exp + 22 >= 0)
-		ix = (int) (m >> (w - 22 - exp)) & 0x007fffff;
-	else
-		ix = 0;
-
-	ix |= (hx ^ hy) & 0x80000000;
-	return ix;
-}
-
-/* denormalized double * double */
-static void mult64(unsigned long long x, unsigned long long y,
-		unsigned long long *highp, unsigned long long *lowp)
-{
-	unsigned long long sub0, sub1, sub2, sub3;
-	unsigned long long high, low;
-
-	sub0 = (x >> 32) * (unsigned long) (y >> 32);
-	sub1 = (x & 0xffffffffLL) * (unsigned long) (y >> 32);
-	sub2 = (x >> 32) * (unsigned long) (y & 0xffffffffLL);
-	sub3 = (x & 0xffffffffLL) * (unsigned long) (y & 0xffffffffLL);
-	low = sub3;
-	high = 0LL;
-	sub3 += (sub1 << 32);
-	if (low > sub3)
-		high++;
-	low = sub3;
-	sub3 += (sub2 << 32);
-	if (low > sub3)
-		high++;
-	low = sub3;
-	high += (sub1 >> 32) + (sub2 >> 32);
-	high += sub0;
-	*lowp = low;
-	*highp = high;
-}
-
-static inline long long rshift64(unsigned long long mh,
-		unsigned long long ml, int n)
-{
-	if (n >= 64)
-		return mh >> (n - 64);
-	return (mh << (64 - n)) | (ml >> n);
-}
-
-static long long denormal_muld(long long hx, long long hy)
-{
-	unsigned long long ix, iy;
-	unsigned long long mh, ml, nh, nl;
-	int exp, w;
-
-	ix = hx & 0x7fffffffffffffffLL;
-	iy = hy & 0x7fffffffffffffffLL;
-	if (iy < 0x0010000000000000LL || ix == 0)
-		return ((hx ^ hy) & 0x8000000000000000LL);
-
-	exp = (iy & 0x7ff0000000000000LL) >> 52;
-	ix &= 0x000fffffffffffffLL;
-	iy = (iy & 0x000fffffffffffffLL) | 0x0010000000000000LL;
-	mult64(ix, iy, &mh, &ml);
-	nh = mh;
-	nl = ml;
-	w = -1;
-	if (nh) {
-		while (nh) { nh >>= 1; w++;}
-		w += 64;
-	} else
-		while (nl) { nl >>= 1; w++;}
-
-	/* FIXME: use guard bits */
-	exp += w - 1022 - 52 * 2;
-	if (exp > 0)
-		ix = (rshift64(mh, ml, w - 52) & 0x000fffffffffffffLL)
-			| ((long long)exp << 52);
-	else if (exp + 51 >= 0)
-		ix = rshift64(mh, ml, w - 51 - exp) & 0x000fffffffffffffLL;
-	else
-		ix = 0;
-
-	ix |= (hx ^ hy) & 0x8000000000000000LL;
-	return ix;
-}
-
-/* ix - iy where iy: denormal and ix, iy >= 0 */
-static int denormal_subf1(unsigned int ix, unsigned int iy)
-{
-	int frac;
-	int exp;
-
-	if (ix < 0x00800000)
-		return ix - iy;
-
-	exp = (ix & 0x7f800000) >> 23;
-	if (exp - 1 > 31)
-		return ix;
-	iy >>= exp - 1;
-	if (iy == 0)
-		return ix;
-
-	frac = (ix & 0x007fffff) | 0x00800000;
-	frac -= iy;
-	while (frac < 0x00800000) {
-		if (--exp == 0)
-			return frac;
-		frac <<= 1;
-	}
-
-	return (exp << 23) | (frac & 0x007fffff);
-}
-
-/* ix + iy where iy: denormal and ix, iy >= 0 */
-static int denormal_addf1(unsigned int ix, unsigned int iy)
-{
-	int frac;
-	int exp;
-
-	if (ix < 0x00800000)
-		return ix + iy;
-
-	exp = (ix & 0x7f800000) >> 23;
-	if (exp - 1 > 31)
-		return ix;
-	iy >>= exp - 1;
-	if (iy == 0)
-	  return ix;
-
-	frac = (ix & 0x007fffff) | 0x00800000;
-	frac += iy;
-	if (frac >= 0x01000000) {
-		frac >>= 1;
-		++exp;
-	}
-
-	return (exp << 23) | (frac & 0x007fffff);
-}
-
-static int denormal_addf(int hx, int hy)
-{
-	unsigned int ix, iy;
-	int sign;
-
-	if ((hx ^ hy) & 0x80000000) {
-		sign = hx & 0x80000000;
-		ix = hx & 0x7fffffff;
-		iy = hy & 0x7fffffff;
-		if (iy < 0x00800000) {
-			ix = denormal_subf1(ix, iy);
-			if ((int) ix < 0) {
-				ix = -ix;
-				sign ^= 0x80000000;
-			}
-		} else {
-			ix = denormal_subf1(iy, ix);
-			sign ^= 0x80000000;
-		}
-	} else {
-		sign = hx & 0x80000000;
-		ix = hx & 0x7fffffff;
-		iy = hy & 0x7fffffff;
-		if (iy < 0x00800000)
-			ix = denormal_addf1(ix, iy);
-		else
-			ix = denormal_addf1(iy, ix);
-	}
-
-	return sign | ix;
-}
-
-/* ix - iy where iy: denormal and ix, iy >= 0 */
-static long long denormal_subd1(unsigned long long ix, unsigned long long iy)
-{
-	long long frac;
-	int exp;
-
-	if (ix < 0x0010000000000000LL)
-		return ix - iy;
-
-	exp = (ix & 0x7ff0000000000000LL) >> 52;
-	if (exp - 1 > 63)
-		return ix;
-	iy >>= exp - 1;
-	if (iy == 0)
-		return ix;
-
-	frac = (ix & 0x000fffffffffffffLL) | 0x0010000000000000LL;
-	frac -= iy;
-	while (frac < 0x0010000000000000LL) {
-		if (--exp == 0)
-			return frac;
-		frac <<= 1;
-	}
-
-	return ((long long)exp << 52) | (frac & 0x000fffffffffffffLL);
-}
-
-/* ix + iy where iy: denormal and ix, iy >= 0 */
-static long long denormal_addd1(unsigned long long ix, unsigned long long iy)
-{
-	long long frac;
-	long long exp;
-
-	if (ix < 0x0010000000000000LL)
-		return ix + iy;
-
-	exp = (ix & 0x7ff0000000000000LL) >> 52;
-	if (exp - 1 > 63)
-		return ix;
-	iy >>= exp - 1;
-	if (iy == 0)
-	  return ix;
-
-	frac = (ix & 0x000fffffffffffffLL) | 0x0010000000000000LL;
-	frac += iy;
-	if (frac >= 0x0020000000000000LL) {
-		frac >>= 1;
-		++exp;
-	}
-
-	return (exp << 52) | (frac & 0x000fffffffffffffLL);
-}
-
-static long long denormal_addd(long long hx, long long hy)
-{
-	unsigned long long ix, iy;
-	long long sign;
-
-	if ((hx ^ hy) & 0x8000000000000000LL) {
-		sign = hx & 0x8000000000000000LL;
-		ix = hx & 0x7fffffffffffffffLL;
-		iy = hy & 0x7fffffffffffffffLL;
-		if (iy < 0x0010000000000000LL) {
-			ix = denormal_subd1(ix, iy);
-			if ((int) ix < 0) {
-				ix = -ix;
-				sign ^= 0x8000000000000000LL;
-			}
-		} else {
-			ix = denormal_subd1(iy, ix);
-			sign ^= 0x8000000000000000LL;
-		}
-	} else {
-		sign = hx & 0x8000000000000000LL;
-		ix = hx & 0x7fffffffffffffffLL;
-		iy = hy & 0x7fffffffffffffffLL;
-		if (iy < 0x0010000000000000LL)
-			ix = denormal_addd1(ix, iy);
-		else
-			ix = denormal_addd1(iy, ix);
-	}
-
-	return sign | ix;
-}
-
-/**
- *	denormal_to_double - Given denormalized float number,
- *	                     store double float
- *
- *	@fpu: Pointer to sh_fpu_hard structure
- *	@n: Index to FP register
- */
-static void
-denormal_to_double (struct sh_fpu_hard_struct *fpu, int n)
-{
-	unsigned long du, dl;
-	unsigned long x = fpu->fpul;
-	int exp = 1023 - 126;
-
-	if (x != 0 && (x & 0x7f800000) == 0) {
-		du = (x & 0x80000000);
-		while ((x & 0x00800000) == 0) {
-			x <<= 1;
-			exp--;
-		}
-		x &= 0x007fffff;
-		du |= (exp << 20) | (x >> 3);
-		dl = x << 29;
-
-		fpu->fp_regs[n] = du;
-		fpu->fp_regs[n+1] = dl;
-	}
-}
-
-/**
- *	ieee_fpe_handler - Handle denormalized number exception
- *
- *	@regs: Pointer to register structure
- *
- *	Returns 1 when it's handled (should not cause exception).
- */
-static int
-ieee_fpe_handler (struct pt_regs *regs)
-{
-	unsigned short insn = *(unsigned short *) regs->pc;
-	unsigned short finsn;
-	unsigned long nextpc;
-	int nib[4] = {
-		(insn >> 12) & 0xf,
-		(insn >> 8) & 0xf,
-		(insn >> 4) & 0xf,
-		insn & 0xf};
-
-	if (nib[0] == 0xb ||
-	    (nib[0] == 0x4 && nib[2] == 0x0 && nib[3] == 0xb)) /* bsr & jsr */
-		regs->pr = regs->pc + 4;
-	if (nib[0] == 0xa || nib[0] == 0xb) { /* bra & bsr */
-		nextpc = regs->pc + 4 + ((short) ((insn & 0xfff) << 4) >> 3);
-		finsn = *(unsigned short *) (regs->pc + 2);
-	} else if (nib[0] == 0x8 && nib[1] == 0xd) { /* bt/s */
-		if (regs->sr & 1)
-			nextpc = regs->pc + 4 + ((char) (insn & 0xff) << 1);
-		else
-			nextpc = regs->pc + 4;
-		finsn = *(unsigned short *) (regs->pc + 2);
-	} else if (nib[0] == 0x8 && nib[1] == 0xf) { /* bf/s */
-		if (regs->sr & 1)
-			nextpc = regs->pc + 4;
-		else
-			nextpc = regs->pc + 4 + ((char) (insn & 0xff) << 1);
-		finsn = *(unsigned short *) (regs->pc + 2);
-	} else if (nib[0] == 0x4 && nib[3] == 0xb &&
-		 (nib[2] == 0x0 || nib[2] == 0x2)) { /* jmp & jsr */
-		nextpc = regs->regs[nib[1]];
-		finsn = *(unsigned short *) (regs->pc + 2);
-	} else if (nib[0] == 0x0 && nib[3] == 0x3 &&
-		 (nib[2] == 0x0 || nib[2] == 0x2)) { /* braf & bsrf */
-		nextpc = regs->pc + 4 + regs->regs[nib[1]];
-		finsn = *(unsigned short *) (regs->pc + 2);
-	} else if (insn == 0x000b) { /* rts */
-		nextpc = regs->pr;
-		finsn = *(unsigned short *) (regs->pc + 2);
-	} else {
-		nextpc = regs->pc + 2;
-		finsn = insn;
-	}
-
-#define FPSCR_FPU_ERROR (1 << 17)
-
-	if ((finsn & 0xf1ff) == 0xf0ad) { /* fcnvsd */
-		struct task_struct *tsk = current;
-
-		if ((tsk->thread.xstate->hardfpu.fpscr & FPSCR_FPU_ERROR)) {
-			/* FPU error */
-			denormal_to_double (&tsk->thread.xstate->hardfpu,
-					    (finsn >> 8) & 0xf);
-		} else
-			return 0;
-
-		regs->pc = nextpc;
-		return 1;
-	} else if ((finsn & 0xf00f) == 0xf002) { /* fmul */
-		struct task_struct *tsk = current;
-		int fpscr;
-		int n, m, prec;
-		unsigned int hx, hy;
-
-		n = (finsn >> 8) & 0xf;
-		m = (finsn >> 4) & 0xf;
-		hx = tsk->thread.xstate->hardfpu.fp_regs[n];
-		hy = tsk->thread.xstate->hardfpu.fp_regs[m];
-		fpscr = tsk->thread.xstate->hardfpu.fpscr;
-		prec = fpscr & (1 << 19);
-
-		if ((fpscr & FPSCR_FPU_ERROR)
-		     && (prec && ((hx & 0x7fffffff) < 0x00100000
-				   || (hy & 0x7fffffff) < 0x00100000))) {
-			long long llx, lly;
-
-			/* FPU error because of denormal */
-			llx = ((long long) hx << 32)
-			       | tsk->thread.xstate->hardfpu.fp_regs[n+1];
-			lly = ((long long) hy << 32)
-			       | tsk->thread.xstate->hardfpu.fp_regs[m+1];
-			if ((hx & 0x7fffffff) >= 0x00100000)
-				llx = denormal_muld(lly, llx);
-			else
-				llx = denormal_muld(llx, lly);
-			tsk->thread.xstate->hardfpu.fp_regs[n] = llx >> 32;
-			tsk->thread.xstate->hardfpu.fp_regs[n+1] = llx & 0xffffffff;
-		} else if ((fpscr & FPSCR_FPU_ERROR)
-		     && (!prec && ((hx & 0x7fffffff) < 0x00800000
-				   || (hy & 0x7fffffff) < 0x00800000))) {
-			/* FPU error because of denormal */
-			if ((hx & 0x7fffffff) >= 0x00800000)
-				hx = denormal_mulf(hy, hx);
-			else
-				hx = denormal_mulf(hx, hy);
-			tsk->thread.xstate->hardfpu.fp_regs[n] = hx;
-		} else
-			return 0;
-
-		regs->pc = nextpc;
-		return 1;
-	} else if ((finsn & 0xf00e) == 0xf000) { /* fadd, fsub */
-		struct task_struct *tsk = current;
-		int fpscr;
-		int n, m, prec;
-		unsigned int hx, hy;
-
-		n = (finsn >> 8) & 0xf;
-		m = (finsn >> 4) & 0xf;
-		hx = tsk->thread.xstate->hardfpu.fp_regs[n];
-		hy = tsk->thread.xstate->hardfpu.fp_regs[m];
-		fpscr = tsk->thread.xstate->hardfpu.fpscr;
-		prec = fpscr & (1 << 19);
-
-		if ((fpscr & FPSCR_FPU_ERROR)
-		     && (prec && ((hx & 0x7fffffff) < 0x00100000
-				   || (hy & 0x7fffffff) < 0x00100000))) {
-			long long llx, lly;
-
-			/* FPU error because of denormal */
-			llx = ((long long) hx << 32)
-			       | tsk->thread.xstate->hardfpu.fp_regs[n+1];
-			lly = ((long long) hy << 32)
-			       | tsk->thread.xstate->hardfpu.fp_regs[m+1];
-			if ((finsn & 0xf00f) == 0xf000)
-				llx = denormal_addd(llx, lly);
-			else
-				llx = denormal_addd(llx, lly ^ (1LL << 63));
-			tsk->thread.xstate->hardfpu.fp_regs[n] = llx >> 32;
-			tsk->thread.xstate->hardfpu.fp_regs[n+1] = llx & 0xffffffff;
-		} else if ((fpscr & FPSCR_FPU_ERROR)
-		     && (!prec && ((hx & 0x7fffffff) < 0x00800000
-				   || (hy & 0x7fffffff) < 0x00800000))) {
-			/* FPU error because of denormal */
-			if ((finsn & 0xf00f) == 0xf000)
-				hx = denormal_addf(hx, hy);
-			else
-				hx = denormal_addf(hx, hy ^ 0x80000000);
-			tsk->thread.xstate->hardfpu.fp_regs[n] = hx;
-		} else
-			return 0;
-
-		regs->pc = nextpc;
-		return 1;
-	}
-
-	return 0;
-}
-
-BUILD_TRAP_HANDLER(fpu_error)
-{
-	struct task_struct *tsk = current;
-	TRAP_HANDLER_DECL;
-
-	__unlazy_fpu(tsk, regs);
-	if (ieee_fpe_handler(regs)) {
-		tsk->thread.xstate->hardfpu.fpscr &=
-			~(FPSCR_CAUSE_MASK | FPSCR_FLAG_MASK);
-		grab_fpu(regs);
-		restore_fpu(tsk);
-		task_thread_info(tsk)->status |= TS_USEDFPU;
-		return;
-	}
-
-	force_sig(SIGFPE);
-}
diff --git a/arch/sh/kernel/cpu/sh2a/opcode_helper.c b/arch/sh/kernel/cpu/sh2a/opcode_helper.c
deleted file mode 100644
index c509081d90b9af..00000000000000
--- a/arch/sh/kernel/cpu/sh2a/opcode_helper.c
+++ /dev/null
@@ -1,51 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh2a/opcode_helper.c
- *
- * Helper for the SH-2A 32-bit opcodes.
- *
- *  Copyright (C) 2007  Paul Mundt
- */
-#include <linux/kernel.h>
-
-/*
- * Instructions on SH are generally fixed at 16-bits, however, SH-2A
- * introduces some 32-bit instructions. Since there are no real
- * constraints on their use (and they can be mixed and matched), we need
- * to check the instruction encoding to work out if it's a true 32-bit
- * instruction or not.
- *
- * Presently, 32-bit opcodes have only slight variations in what the
- * actual encoding looks like in the first-half of the instruction, which
- * makes it fairly straightforward to differentiate from the 16-bit ones.
- *
- * First 16-bits of encoding		Used by
- *
- *	0011nnnnmmmm0001	mov.b, mov.w, mov.l, fmov.d,
- *				fmov.s, movu.b, movu.w
- *
- *	0011nnnn0iii1001        bclr.b, bld.b, bset.b, bst.b, band.b,
- *				bandnot.b, bldnot.b, bor.b, bornot.b,
- *				bxor.b
- *
- *	0000nnnniiii0000        movi20
- *	0000nnnniiii0001        movi20s
- */
-unsigned int instruction_size(unsigned int insn)
-{
-	/* Look for the common cases */
-	switch ((insn & 0xf00f)) {
-	case 0x0000:	/* movi20 */
-	case 0x0001:	/* movi20s */
-	case 0x3001:	/* 32-bit mov/fmov/movu variants */
-		return 4;
-	}
-
-	/* And the special cases.. */
-	switch ((insn & 0xf08f)) {
-	case 0x3009:	/* 32-bit b*.b bit operations */
-		return 4;
-	}
-
-	return 2;
-}
diff --git a/arch/sh/kernel/cpu/sh2a/pinmux-sh7203.c b/arch/sh/kernel/cpu/sh2a/pinmux-sh7203.c
deleted file mode 100644
index a6777e6fc8cdc2..00000000000000
--- a/arch/sh/kernel/cpu/sh2a/pinmux-sh7203.c
+++ /dev/null
@@ -1,27 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7203 Pinmux
- *
- *  Copyright (C) 2008  Magnus Damm
- */
-
-#include <linux/bug.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/ioport.h>
-#include <cpu/pfc.h>
-
-static struct resource sh7203_pfc_resources[] = {
-	[0] = {
-		.start	= 0xfffe3800,
-		.end	= 0xfffe3a9f,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static int __init plat_pinmux_setup(void)
-{
-	return sh_pfc_register("pfc-sh7203", sh7203_pfc_resources,
-			       ARRAY_SIZE(sh7203_pfc_resources));
-}
-arch_initcall(plat_pinmux_setup);
diff --git a/arch/sh/kernel/cpu/sh2a/pinmux-sh7264.c b/arch/sh/kernel/cpu/sh2a/pinmux-sh7264.c
deleted file mode 100644
index 7a103e16cf01b0..00000000000000
--- a/arch/sh/kernel/cpu/sh2a/pinmux-sh7264.c
+++ /dev/null
@@ -1,27 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7264 Pinmux
- *
- *  Copyright (C) 2012  Renesas Electronics Europe Ltd
- */
-
-#include <linux/bug.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/ioport.h>
-#include <cpu/pfc.h>
-
-static struct resource sh7264_pfc_resources[] = {
-	[0] = {
-		.start	= 0xfffe3800,
-		.end	= 0xfffe393f,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static int __init plat_pinmux_setup(void)
-{
-	return sh_pfc_register("pfc-sh7264", sh7264_pfc_resources,
-			       ARRAY_SIZE(sh7264_pfc_resources));
-}
-arch_initcall(plat_pinmux_setup);
diff --git a/arch/sh/kernel/cpu/sh2a/pinmux-sh7269.c b/arch/sh/kernel/cpu/sh2a/pinmux-sh7269.c
deleted file mode 100644
index 4da432ef1b40a9..00000000000000
--- a/arch/sh/kernel/cpu/sh2a/pinmux-sh7269.c
+++ /dev/null
@@ -1,28 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7269 Pinmux
- *
- * Copyright (C) 2012  Renesas Electronics Europe Ltd
- * Copyright (C) 2012  Phil Edworthy
- */
-
-#include <linux/bug.h>
-#include <linux/init.h>
-#include <linux/ioport.h>
-#include <linux/kernel.h>
-#include <cpu/pfc.h>
-
-static struct resource sh7269_pfc_resources[] = {
-	[0] = {
-		.start	= 0xfffe3800,
-		.end	= 0xfffe391f,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static int __init plat_pinmux_setup(void)
-{
-	return sh_pfc_register("pfc-sh7269", sh7269_pfc_resources,
-			       ARRAY_SIZE(sh7269_pfc_resources));
-}
-arch_initcall(plat_pinmux_setup);
diff --git a/arch/sh/kernel/cpu/sh2a/probe.c b/arch/sh/kernel/cpu/sh2a/probe.c
deleted file mode 100644
index c66a3bc882bf9a..00000000000000
--- a/arch/sh/kernel/cpu/sh2a/probe.c
+++ /dev/null
@@ -1,57 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh2a/probe.c
- *
- * CPU Subtype Probing for SH-2A.
- *
- * Copyright (C) 2004 - 2007  Paul Mundt
- */
-#include <linux/init.h>
-#include <asm/processor.h>
-#include <asm/cache.h>
-
-void cpu_probe(void)
-{
-	boot_cpu_data.family			= CPU_FAMILY_SH2A;
-
-	/* All SH-2A CPUs have support for 16 and 32-bit opcodes.. */
-	boot_cpu_data.flags			|= CPU_HAS_OP32;
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7201)
-	boot_cpu_data.type			= CPU_SH7201;
-	boot_cpu_data.flags			|= CPU_HAS_FPU;
-#elif defined(CONFIG_CPU_SUBTYPE_SH7203)
-	boot_cpu_data.type			= CPU_SH7203;
-	boot_cpu_data.flags			|= CPU_HAS_FPU;
-#elif defined(CONFIG_CPU_SUBTYPE_SH7263)
-	boot_cpu_data.type			= CPU_SH7263;
-	boot_cpu_data.flags			|= CPU_HAS_FPU;
-#elif defined(CONFIG_CPU_SUBTYPE_SH7264)
-	boot_cpu_data.type			= CPU_SH7264;
-	boot_cpu_data.flags			|= CPU_HAS_FPU;
-#elif defined(CONFIG_CPU_SUBTYPE_SH7269)
-	boot_cpu_data.type			= CPU_SH7269;
-	boot_cpu_data.flags			|= CPU_HAS_FPU;
-#elif defined(CONFIG_CPU_SUBTYPE_SH7206)
-	boot_cpu_data.type			= CPU_SH7206;
-	boot_cpu_data.flags			|= CPU_HAS_DSP;
-#elif defined(CONFIG_CPU_SUBTYPE_MXG)
-	boot_cpu_data.type			= CPU_MXG;
-	boot_cpu_data.flags			|= CPU_HAS_DSP;
-#endif
-
-	boot_cpu_data.dcache.ways		= 4;
-	boot_cpu_data.dcache.way_incr		= (1 << 11);
-	boot_cpu_data.dcache.sets		= 128;
-	boot_cpu_data.dcache.entry_shift	= 4;
-	boot_cpu_data.dcache.linesz		= L1_CACHE_BYTES;
-	boot_cpu_data.dcache.flags		= 0;
-
-	/*
-	 * The icache is the same as the dcache as far as this setup is
-	 * concerned. The only real difference in hardware is that the icache
-	 * lacks the U bit that the dcache has, none of this has any bearing
-	 * on the cache info.
-	 */
-	boot_cpu_data.icache		= boot_cpu_data.dcache;
-}
diff --git a/arch/sh/kernel/cpu/sh2a/setup-mxg.c b/arch/sh/kernel/cpu/sh2a/setup-mxg.c
deleted file mode 100644
index cefa07924c16db..00000000000000
--- a/arch/sh/kernel/cpu/sh2a/setup-mxg.c
+++ /dev/null
@@ -1,175 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Renesas MX-G (R8A03022BG) Setup
- *
- *  Copyright (C) 2008, 2009  Paul Mundt
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/serial_sci.h>
-#include <linux/sh_timer.h>
-#include <asm/platform_early.h>
-
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-	IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7,
-	IRQ8, IRQ9, IRQ10, IRQ11, IRQ12, IRQ13, IRQ14, IRQ15,
-
-	PINT0, PINT1, PINT2, PINT3, PINT4, PINT5, PINT6, PINT7,
-	SINT8, SINT7, SINT6, SINT5, SINT4, SINT3, SINT2, SINT1,
-
-	SCIF0, SCIF1,
-
-	MTU2_GROUP1, MTU2_GROUP2, MTU2_GROUP3, MTU2_GROUP4, MTU2_GROUP5,
-	MTU2_TGI3B, MTU2_TGI3C,
-
-	/* interrupt groups */
-	PINT,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_IRQ(IRQ0, 64), INTC_IRQ(IRQ1, 65),
-	INTC_IRQ(IRQ2, 66), INTC_IRQ(IRQ3, 67),
-	INTC_IRQ(IRQ4, 68), INTC_IRQ(IRQ5, 69),
-	INTC_IRQ(IRQ6, 70), INTC_IRQ(IRQ7, 71),
-	INTC_IRQ(IRQ8, 72), INTC_IRQ(IRQ9, 73),
-	INTC_IRQ(IRQ10, 74), INTC_IRQ(IRQ11, 75),
-	INTC_IRQ(IRQ12, 76), INTC_IRQ(IRQ13, 77),
-	INTC_IRQ(IRQ14, 78), INTC_IRQ(IRQ15, 79),
-
-	INTC_IRQ(PINT0, 80), INTC_IRQ(PINT1, 81),
-	INTC_IRQ(PINT2, 82), INTC_IRQ(PINT3, 83),
-	INTC_IRQ(PINT4, 84), INTC_IRQ(PINT5, 85),
-	INTC_IRQ(PINT6, 86), INTC_IRQ(PINT7, 87),
-
-	INTC_IRQ(SINT8, 94), INTC_IRQ(SINT7, 95),
-	INTC_IRQ(SINT6, 96), INTC_IRQ(SINT5, 97),
-	INTC_IRQ(SINT4, 98), INTC_IRQ(SINT3, 99),
-	INTC_IRQ(SINT2, 100), INTC_IRQ(SINT1, 101),
-
-	INTC_IRQ(SCIF0, 220), INTC_IRQ(SCIF0, 221),
-	INTC_IRQ(SCIF0, 222), INTC_IRQ(SCIF0, 223),
-	INTC_IRQ(SCIF1, 224), INTC_IRQ(SCIF1, 225),
-	INTC_IRQ(SCIF1, 226), INTC_IRQ(SCIF1, 227),
-
-	INTC_IRQ(MTU2_GROUP1, 228), INTC_IRQ(MTU2_GROUP1, 229),
-	INTC_IRQ(MTU2_GROUP1, 230), INTC_IRQ(MTU2_GROUP1, 231),
-	INTC_IRQ(MTU2_GROUP1, 232), INTC_IRQ(MTU2_GROUP1, 233),
-
-	INTC_IRQ(MTU2_GROUP2, 234), INTC_IRQ(MTU2_GROUP2, 235),
-	INTC_IRQ(MTU2_GROUP2, 236), INTC_IRQ(MTU2_GROUP2, 237),
-	INTC_IRQ(MTU2_GROUP2, 238), INTC_IRQ(MTU2_GROUP2, 239),
-
-	INTC_IRQ(MTU2_GROUP3, 240), INTC_IRQ(MTU2_GROUP3, 241),
-	INTC_IRQ(MTU2_GROUP3, 242), INTC_IRQ(MTU2_GROUP3, 243),
-
-	INTC_IRQ(MTU2_TGI3B, 244),
-	INTC_IRQ(MTU2_TGI3C, 245),
-
-	INTC_IRQ(MTU2_GROUP4, 246), INTC_IRQ(MTU2_GROUP4, 247),
-	INTC_IRQ(MTU2_GROUP4, 248), INTC_IRQ(MTU2_GROUP4, 249),
-	INTC_IRQ(MTU2_GROUP4, 250), INTC_IRQ(MTU2_GROUP4, 251),
-
-	INTC_IRQ(MTU2_GROUP5, 252), INTC_IRQ(MTU2_GROUP5, 253),
-	INTC_IRQ(MTU2_GROUP5, 254), INTC_IRQ(MTU2_GROUP5, 255),
-};
-
-static struct intc_group groups[] __initdata = {
-	INTC_GROUP(PINT, PINT0, PINT1, PINT2, PINT3,
-		   PINT4, PINT5, PINT6, PINT7),
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xfffd9418, 0, 16, 4, /* IPR01 */ { IRQ0, IRQ1, IRQ2, IRQ3 } },
-	{ 0xfffd941a, 0, 16, 4, /* IPR02 */ { IRQ4, IRQ5, IRQ6, IRQ7 } },
-	{ 0xfffd941c, 0, 16, 4, /* IPR03 */ { IRQ8, IRQ9, IRQ10, IRQ11 } },
-	{ 0xfffd941e, 0, 16, 4, /* IPR04 */ { IRQ12, IRQ13, IRQ14, IRQ15 } },
-	{ 0xfffd9420, 0, 16, 4, /* IPR05 */ { PINT, 0, 0, 0 } },
-	{ 0xfffd9800, 0, 16, 4, /* IPR06 */ { } },
-	{ 0xfffd9802, 0, 16, 4, /* IPR07 */ { } },
-	{ 0xfffd9804, 0, 16, 4, /* IPR08 */ { } },
-	{ 0xfffd9806, 0, 16, 4, /* IPR09 */ { } },
-	{ 0xfffd9808, 0, 16, 4, /* IPR10 */ { } },
-	{ 0xfffd980a, 0, 16, 4, /* IPR11 */ { } },
-	{ 0xfffd980c, 0, 16, 4, /* IPR12 */ { } },
-	{ 0xfffd980e, 0, 16, 4, /* IPR13 */ { } },
-	{ 0xfffd9810, 0, 16, 4, /* IPR14 */ { 0, 0, 0, SCIF0 } },
-	{ 0xfffd9812, 0, 16, 4, /* IPR15 */
-		{ SCIF1, MTU2_GROUP1, MTU2_GROUP2, MTU2_GROUP3 } },
-	{ 0xfffd9814, 0, 16, 4, /* IPR16 */
-		{ MTU2_TGI3B, MTU2_TGI3C, MTU2_GROUP4, MTU2_GROUP5 } },
-};
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xfffd9408, 0, 16, /* PINTER */
-	  { 0, 0, 0, 0, 0, 0, 0, 0,
-	    PINT7, PINT6, PINT5, PINT4, PINT3, PINT2, PINT1, PINT0 } },
-};
-
-static DECLARE_INTC_DESC(intc_desc, "mxg", vectors, groups,
-			 mask_registers, prio_registers, NULL);
-
-static struct resource mtu2_resources[] = {
-	DEFINE_RES_MEM(0xff801000, 0x400),
-	DEFINE_RES_IRQ_NAMED(228, "tgi0a"),
-	DEFINE_RES_IRQ_NAMED(234, "tgi1a"),
-	DEFINE_RES_IRQ_NAMED(240, "tgi2a"),
-};
-
-static struct platform_device mtu2_device = {
-	.name		= "sh-mtu2",
-	.id		= -1,
-	.resource	= mtu2_resources,
-	.num_resources	= ARRAY_SIZE(mtu2_resources),
-};
-
-static struct plat_sci_port scif0_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xff804000, 0x100),
-	DEFINE_RES_IRQ(220),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct platform_device *mxg_devices[] __initdata = {
-	&scif0_device,
-	&mtu2_device,
-};
-
-static int __init mxg_devices_setup(void)
-{
-	return platform_add_devices(mxg_devices,
-				    ARRAY_SIZE(mxg_devices));
-}
-arch_initcall(mxg_devices_setup);
-
-void __init plat_irq_setup(void)
-{
-	register_intc_controller(&intc_desc);
-}
-
-static struct platform_device *mxg_early_devices[] __initdata = {
-	&scif0_device,
-	&mtu2_device,
-};
-
-void __init plat_early_device_setup(void)
-{
-	sh_early_platform_add_devices(mxg_early_devices,
-				   ARRAY_SIZE(mxg_early_devices));
-}
diff --git a/arch/sh/kernel/cpu/sh2a/setup-sh7201.c b/arch/sh/kernel/cpu/sh2a/setup-sh7201.c
deleted file mode 100644
index 28f1bebf340565..00000000000000
--- a/arch/sh/kernel/cpu/sh2a/setup-sh7201.c
+++ /dev/null
@@ -1,418 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- *  SH7201 setup
- *
- *  Copyright (C) 2008  Peter Griffin pgriffin@mpc-data.co.uk
- *  Copyright (C) 2009  Paul Mundt
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/serial_sci.h>
-#include <linux/sh_timer.h>
-#include <linux/io.h>
-#include <asm/platform_early.h>
-
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-	IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7,
-	PINT0, PINT1, PINT2, PINT3, PINT4, PINT5, PINT6, PINT7,
-
-	ADC_ADI,
-
-	MTU20_ABCD, MTU20_VEF, MTU21_AB, MTU21_VU, MTU22_AB, MTU22_VU,
-	MTU23_ABCD, MTU24_ABCD, MTU25_UVW, MTU2_TCI3V, MTU2_TCI4V,
-
-	RTC, WDT,
-
-	IIC30, IIC31, IIC32,
-
-	DMAC0_DMINT0, DMAC1_DMINT1,
-	DMAC2_DMINT2, DMAC3_DMINT3,
-
-	SCIF0, SCIF1, SCIF2, SCIF3, SCIF4, SCIF5, SCIF6, SCIF7,
-
-	DMAC0_DMINTA, DMAC4_DMINT4, DMAC5_DMINT5, DMAC6_DMINT6,
-	DMAC7_DMINT7,
-
-	RCAN0, RCAN1,
-
-	SSI0_SSII, SSI1_SSII,
-
-	TMR0, TMR1,
-
-	/* interrupt groups */
-	PINT,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_IRQ(IRQ0, 64), INTC_IRQ(IRQ1, 65),
-	INTC_IRQ(IRQ2, 66), INTC_IRQ(IRQ3, 67),
-	INTC_IRQ(IRQ4, 68), INTC_IRQ(IRQ5, 69),
-	INTC_IRQ(IRQ6, 70), INTC_IRQ(IRQ7, 71),
-
-	INTC_IRQ(PINT0, 80), INTC_IRQ(PINT1, 81),
-	INTC_IRQ(PINT2, 82), INTC_IRQ(PINT3, 83),
-	INTC_IRQ(PINT4, 84), INTC_IRQ(PINT5, 85),
-	INTC_IRQ(PINT6, 86), INTC_IRQ(PINT7, 87),
-
-	INTC_IRQ(ADC_ADI, 92),
-
-	INTC_IRQ(MTU20_ABCD, 108), INTC_IRQ(MTU20_ABCD, 109),
-	INTC_IRQ(MTU20_ABCD, 110), INTC_IRQ(MTU20_ABCD, 111),
-
-	INTC_IRQ(MTU20_VEF, 112), INTC_IRQ(MTU20_VEF, 113),
-	INTC_IRQ(MTU20_VEF, 114),
-
-	INTC_IRQ(MTU21_AB, 116), INTC_IRQ(MTU21_AB, 117),
-	INTC_IRQ(MTU21_VU, 120), INTC_IRQ(MTU21_VU, 121),
-
-	INTC_IRQ(MTU22_AB, 124), INTC_IRQ(MTU22_AB, 125),
-	INTC_IRQ(MTU22_VU, 128), INTC_IRQ(MTU22_VU, 129),
-
-	INTC_IRQ(MTU23_ABCD, 132), INTC_IRQ(MTU23_ABCD, 133),
-	INTC_IRQ(MTU23_ABCD, 134), INTC_IRQ(MTU23_ABCD, 135),
-
-	INTC_IRQ(MTU2_TCI3V, 136),
-
-	INTC_IRQ(MTU24_ABCD, 140), INTC_IRQ(MTU24_ABCD, 141),
-	INTC_IRQ(MTU24_ABCD, 142), INTC_IRQ(MTU24_ABCD, 143),
-
-	INTC_IRQ(MTU2_TCI4V, 144),
-
-	INTC_IRQ(MTU25_UVW, 148), INTC_IRQ(MTU25_UVW, 149),
-	INTC_IRQ(MTU25_UVW, 150),
-
-	INTC_IRQ(RTC, 152), INTC_IRQ(RTC, 153),
-	INTC_IRQ(RTC, 154),
-
-	INTC_IRQ(WDT, 156),
-
-	INTC_IRQ(IIC30, 157), INTC_IRQ(IIC30, 158),
-	INTC_IRQ(IIC30, 159), INTC_IRQ(IIC30, 160),
-	INTC_IRQ(IIC30, 161),
-
-	INTC_IRQ(IIC31, 164), INTC_IRQ(IIC31, 165),
-	INTC_IRQ(IIC31, 166), INTC_IRQ(IIC31, 167),
-	INTC_IRQ(IIC31, 168),
-
-	INTC_IRQ(IIC32, 170), INTC_IRQ(IIC32, 171),
-	INTC_IRQ(IIC32, 172), INTC_IRQ(IIC32, 173),
-	INTC_IRQ(IIC32, 174),
-
-	INTC_IRQ(DMAC0_DMINT0, 176), INTC_IRQ(DMAC1_DMINT1, 177),
-	INTC_IRQ(DMAC2_DMINT2, 178), INTC_IRQ(DMAC3_DMINT3, 179),
-
-	INTC_IRQ(SCIF0, 180), INTC_IRQ(SCIF0, 181),
-	INTC_IRQ(SCIF0, 182), INTC_IRQ(SCIF0, 183),
-	INTC_IRQ(SCIF1, 184), INTC_IRQ(SCIF1, 185),
-	INTC_IRQ(SCIF1, 186), INTC_IRQ(SCIF1, 187),
-	INTC_IRQ(SCIF2, 188), INTC_IRQ(SCIF2, 189),
-	INTC_IRQ(SCIF2, 190), INTC_IRQ(SCIF2, 191),
-	INTC_IRQ(SCIF3, 192), INTC_IRQ(SCIF3, 193),
-	INTC_IRQ(SCIF3, 194), INTC_IRQ(SCIF3, 195),
-	INTC_IRQ(SCIF4, 196), INTC_IRQ(SCIF4, 197),
-	INTC_IRQ(SCIF4, 198), INTC_IRQ(SCIF4, 199),
-	INTC_IRQ(SCIF5, 200), INTC_IRQ(SCIF5, 201),
-	INTC_IRQ(SCIF5, 202), INTC_IRQ(SCIF5, 203),
-	INTC_IRQ(SCIF6, 204), INTC_IRQ(SCIF6, 205),
-	INTC_IRQ(SCIF6, 206), INTC_IRQ(SCIF6, 207),
-	INTC_IRQ(SCIF7, 208), INTC_IRQ(SCIF7, 209),
-	INTC_IRQ(SCIF7, 210), INTC_IRQ(SCIF7, 211),
-
-	INTC_IRQ(DMAC0_DMINTA, 212), INTC_IRQ(DMAC4_DMINT4, 216),
-	INTC_IRQ(DMAC5_DMINT5, 217), INTC_IRQ(DMAC6_DMINT6, 218),
-	INTC_IRQ(DMAC7_DMINT7, 219),
-
-	INTC_IRQ(RCAN0, 228), INTC_IRQ(RCAN0, 229),
-	INTC_IRQ(RCAN0, 230),
-	INTC_IRQ(RCAN0, 231), INTC_IRQ(RCAN0, 232),
-
-	INTC_IRQ(RCAN1, 234), INTC_IRQ(RCAN1, 235),
-	INTC_IRQ(RCAN1, 236),
-	INTC_IRQ(RCAN1, 237), INTC_IRQ(RCAN1, 238),
-
-	INTC_IRQ(SSI0_SSII, 244), INTC_IRQ(SSI1_SSII, 245),
-
-	INTC_IRQ(TMR0, 246), INTC_IRQ(TMR0, 247),
-	INTC_IRQ(TMR0, 248),
-
-	INTC_IRQ(TMR1, 252), INTC_IRQ(TMR1, 253),
-	INTC_IRQ(TMR1, 254),
-};
-
-static struct intc_group groups[] __initdata = {
-	INTC_GROUP(PINT, PINT0, PINT1, PINT2, PINT3,
-		   PINT4, PINT5, PINT6, PINT7),
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xfffe9418, 0, 16, 4, /* IPR01 */ { IRQ0, IRQ1, IRQ2, IRQ3 } },
-	{ 0xfffe941a, 0, 16, 4, /* IPR02 */ { IRQ4, IRQ5, IRQ6, IRQ7 } },
-	{ 0xfffe9420, 0, 16, 4, /* IPR05 */ { PINT, 0, ADC_ADI, 0 } },
-	{ 0xfffe9800, 0, 16, 4, /* IPR06 */ { 0, MTU20_ABCD, MTU20_VEF, MTU21_AB } },
-	{ 0xfffe9802, 0, 16, 4, /* IPR07 */ { MTU21_VU, MTU22_AB, MTU22_VU,  MTU23_ABCD } },
-	{ 0xfffe9804, 0, 16, 4, /* IPR08 */ { MTU2_TCI3V, MTU24_ABCD, MTU2_TCI4V, MTU25_UVW } },
-
-	{ 0xfffe9806, 0, 16, 4, /* IPR09 */ { RTC, WDT, IIC30, 0 } },
-	{ 0xfffe9808, 0, 16, 4, /* IPR10 */ { IIC31, IIC32, DMAC0_DMINT0, DMAC1_DMINT1 } },
-	{ 0xfffe980a, 0, 16, 4, /* IPR11 */ { DMAC2_DMINT2, DMAC3_DMINT3, SCIF0, SCIF1 } },
-	{ 0xfffe980c, 0, 16, 4, /* IPR12 */ { SCIF2, SCIF3, SCIF4, SCIF5 } },
-	{ 0xfffe980e, 0, 16, 4, /* IPR13 */ { SCIF6, SCIF7, DMAC0_DMINTA, DMAC4_DMINT4  } },
-	{ 0xfffe9810, 0, 16, 4, /* IPR14 */ { DMAC5_DMINT5, DMAC6_DMINT6, DMAC7_DMINT7, 0 } },
-	{ 0xfffe9812, 0, 16, 4, /* IPR15 */ { 0, RCAN0, RCAN1, 0 } },
-	{ 0xfffe9814, 0, 16, 4, /* IPR16 */ { SSI0_SSII, SSI1_SSII, TMR0, TMR1 } },
-};
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xfffe9408, 0, 16, /* PINTER */
-	  { 0, 0, 0, 0, 0, 0, 0, 0,
-	    PINT7, PINT6, PINT5, PINT4, PINT3, PINT2, PINT1, PINT0 } },
-};
-
-static DECLARE_INTC_DESC(intc_desc, "sh7201", vectors, groups,
-			 mask_registers, prio_registers, NULL);
-
-static struct plat_sci_port scif0_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xfffe8000, 0x100),
-	DEFINE_RES_IRQ(180),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct plat_sci_port scif1_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif1_resources[] = {
-	DEFINE_RES_MEM(0xfffe8800, 0x100),
-	DEFINE_RES_IRQ(184),
-};
-
-static struct platform_device scif1_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif1_resources,
-	.num_resources	= ARRAY_SIZE(scif1_resources),
-	.dev		= {
-		.platform_data	= &scif1_platform_data,
-	},
-};
-
-static struct plat_sci_port scif2_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif2_resources[] = {
-	DEFINE_RES_MEM(0xfffe9000, 0x100),
-	DEFINE_RES_IRQ(188),
-};
-
-static struct platform_device scif2_device = {
-	.name		= "sh-sci",
-	.id		= 2,
-	.resource	= scif2_resources,
-	.num_resources	= ARRAY_SIZE(scif2_resources),
-	.dev		= {
-		.platform_data	= &scif2_platform_data,
-	},
-};
-
-static struct plat_sci_port scif3_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif3_resources[] = {
-	DEFINE_RES_MEM(0xfffe9800, 0x100),
-	DEFINE_RES_IRQ(192),
-};
-
-static struct platform_device scif3_device = {
-	.name		= "sh-sci",
-	.id		= 3,
-	.resource	= scif3_resources,
-	.num_resources	= ARRAY_SIZE(scif3_resources),
-	.dev		= {
-		.platform_data	= &scif3_platform_data,
-	},
-};
-
-static struct plat_sci_port scif4_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif4_resources[] = {
-	DEFINE_RES_MEM(0xfffea000, 0x100),
-	DEFINE_RES_IRQ(196),
-};
-
-static struct platform_device scif4_device = {
-	.name		= "sh-sci",
-	.id		= 4,
-	.resource	= scif4_resources,
-	.num_resources	= ARRAY_SIZE(scif4_resources),
-	.dev		= {
-		.platform_data	= &scif4_platform_data,
-	},
-};
-
-static struct plat_sci_port scif5_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif5_resources[] = {
-	DEFINE_RES_MEM(0xfffea800, 0x100),
-	DEFINE_RES_IRQ(200),
-};
-
-static struct platform_device scif5_device = {
-	.name		= "sh-sci",
-	.id		= 5,
-	.resource	= scif5_resources,
-	.num_resources	= ARRAY_SIZE(scif5_resources),
-	.dev		= {
-		.platform_data	= &scif5_platform_data,
-	},
-};
-
-static struct plat_sci_port scif6_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif6_resources[] = {
-	DEFINE_RES_MEM(0xfffeb000, 0x100),
-	DEFINE_RES_IRQ(204),
-};
-
-static struct platform_device scif6_device = {
-	.name		= "sh-sci",
-	.id		= 6,
-	.resource	= scif6_resources,
-	.num_resources	= ARRAY_SIZE(scif6_resources),
-	.dev		= {
-		.platform_data	= &scif6_platform_data,
-	},
-};
-
-static struct plat_sci_port scif7_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif7_resources[] = {
-	DEFINE_RES_MEM(0xfffeb800, 0x100),
-	DEFINE_RES_IRQ(208),
-};
-
-static struct platform_device scif7_device = {
-	.name		= "sh-sci",
-	.id		= 7,
-	.resource	= scif7_resources,
-	.num_resources	= ARRAY_SIZE(scif7_resources),
-	.dev		= {
-		.platform_data	= &scif7_platform_data,
-	},
-};
-
-static struct resource rtc_resources[] = {
-	[0] = {
-		.start	= 0xffff0800,
-		.end	= 0xffff2000 + 0x58 - 1,
-		.flags	= IORESOURCE_IO,
-	},
-	[1] = {
-		/* Shared Period/Carry/Alarm IRQ */
-		.start	= 152,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device rtc_device = {
-	.name		= "sh-rtc",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(rtc_resources),
-	.resource	= rtc_resources,
-};
-
-static struct resource mtu2_resources[] = {
-	DEFINE_RES_MEM(0xfffe4000, 0x400),
-	DEFINE_RES_IRQ_NAMED(108, "tgi0a"),
-	DEFINE_RES_IRQ_NAMED(116, "tgi1a"),
-	DEFINE_RES_IRQ_NAMED(124, "tgi1b"),
-};
-
-static struct platform_device mtu2_device = {
-	.name		= "sh-mtu2",
-	.id		= -1,
-	.resource	= mtu2_resources,
-	.num_resources	= ARRAY_SIZE(mtu2_resources),
-};
-
-static struct platform_device *sh7201_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&scif4_device,
-	&scif5_device,
-	&scif6_device,
-	&scif7_device,
-	&rtc_device,
-	&mtu2_device,
-};
-
-static int __init sh7201_devices_setup(void)
-{
-	return platform_add_devices(sh7201_devices,
-				    ARRAY_SIZE(sh7201_devices));
-}
-arch_initcall(sh7201_devices_setup);
-
-void __init plat_irq_setup(void)
-{
-	register_intc_controller(&intc_desc);
-}
-
-static struct platform_device *sh7201_early_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&scif4_device,
-	&scif5_device,
-	&scif6_device,
-	&scif7_device,
-	&mtu2_device,
-};
-
-#define STBCR3 0xfffe0408
-
-void __init plat_early_device_setup(void)
-{
-	/* enable MTU2 clock */
-	__raw_writeb(__raw_readb(STBCR3) & ~0x20, STBCR3);
-
-	sh_early_platform_add_devices(sh7201_early_devices,
-				   ARRAY_SIZE(sh7201_early_devices));
-}
diff --git a/arch/sh/kernel/cpu/sh2a/setup-sh7203.c b/arch/sh/kernel/cpu/sh2a/setup-sh7203.c
deleted file mode 100644
index 4839f3aaeb4c21..00000000000000
--- a/arch/sh/kernel/cpu/sh2a/setup-sh7203.c
+++ /dev/null
@@ -1,355 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7203 and SH7263 Setup
- *
- *  Copyright (C) 2007 - 2009  Paul Mundt
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/serial_sci.h>
-#include <linux/sh_timer.h>
-#include <linux/io.h>
-#include <asm/platform_early.h>
-
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-	IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7,
-	PINT0, PINT1, PINT2, PINT3, PINT4, PINT5, PINT6, PINT7,
-	DMAC0, DMAC1, DMAC2, DMAC3, DMAC4, DMAC5, DMAC6, DMAC7,
-	USB, LCDC, CMT0, CMT1, BSC, WDT,
-
-	MTU0_ABCD, MTU0_VEF, MTU1_AB, MTU1_VU, MTU2_AB, MTU2_VU,
-	MTU3_ABCD, MTU4_ABCD, MTU2_TCI3V, MTU2_TCI4V,
-
-	ADC_ADI,
-
-	IIC30, IIC31, IIC32, IIC33,
-	SCIF0, SCIF1, SCIF2, SCIF3,
-
-	SSU0, SSU1,
-
-	SSI0_SSII, SSI1_SSII, SSI2_SSII, SSI3_SSII,
-
-	/* ROM-DEC, SDHI, SRC, and IEB are SH7263 specific */
-	ROMDEC, FLCTL, SDHI, RTC, RCAN0, RCAN1,
-	SRC, IEBI,
-
-	/* interrupt groups */
-	PINT,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_IRQ(IRQ0, 64), INTC_IRQ(IRQ1, 65),
-	INTC_IRQ(IRQ2, 66), INTC_IRQ(IRQ3, 67),
-	INTC_IRQ(IRQ4, 68), INTC_IRQ(IRQ5, 69),
-	INTC_IRQ(IRQ6, 70), INTC_IRQ(IRQ7, 71),
-	INTC_IRQ(PINT0, 80), INTC_IRQ(PINT1, 81),
-	INTC_IRQ(PINT2, 82), INTC_IRQ(PINT3, 83),
-	INTC_IRQ(PINT4, 84), INTC_IRQ(PINT5, 85),
-	INTC_IRQ(PINT6, 86), INTC_IRQ(PINT7, 87),
-	INTC_IRQ(DMAC0, 108), INTC_IRQ(DMAC0, 109),
-	INTC_IRQ(DMAC1, 112), INTC_IRQ(DMAC1, 113),
-	INTC_IRQ(DMAC2, 116), INTC_IRQ(DMAC2, 117),
-	INTC_IRQ(DMAC3, 120), INTC_IRQ(DMAC3, 121),
-	INTC_IRQ(DMAC4, 124), INTC_IRQ(DMAC4, 125),
-	INTC_IRQ(DMAC5, 128), INTC_IRQ(DMAC5, 129),
-	INTC_IRQ(DMAC6, 132), INTC_IRQ(DMAC6, 133),
-	INTC_IRQ(DMAC7, 136), INTC_IRQ(DMAC7, 137),
-	INTC_IRQ(USB, 140), INTC_IRQ(LCDC, 141),
-	INTC_IRQ(CMT0, 142), INTC_IRQ(CMT1, 143),
-	INTC_IRQ(BSC, 144), INTC_IRQ(WDT, 145),
-	INTC_IRQ(MTU0_ABCD, 146), INTC_IRQ(MTU0_ABCD, 147),
-	INTC_IRQ(MTU0_ABCD, 148), INTC_IRQ(MTU0_ABCD, 149),
-	INTC_IRQ(MTU0_VEF, 150),
-	INTC_IRQ(MTU0_VEF, 151), INTC_IRQ(MTU0_VEF, 152),
-	INTC_IRQ(MTU1_AB, 153), INTC_IRQ(MTU1_AB, 154),
-	INTC_IRQ(MTU1_VU, 155), INTC_IRQ(MTU1_VU, 156),
-	INTC_IRQ(MTU2_AB, 157), INTC_IRQ(MTU2_AB, 158),
-	INTC_IRQ(MTU2_VU, 159), INTC_IRQ(MTU2_VU, 160),
-	INTC_IRQ(MTU3_ABCD, 161), INTC_IRQ(MTU3_ABCD, 162),
-	INTC_IRQ(MTU3_ABCD, 163), INTC_IRQ(MTU3_ABCD, 164),
-	INTC_IRQ(MTU2_TCI3V, 165),
-	INTC_IRQ(MTU4_ABCD, 166), INTC_IRQ(MTU4_ABCD, 167),
-	INTC_IRQ(MTU4_ABCD, 168), INTC_IRQ(MTU4_ABCD, 169),
-	INTC_IRQ(MTU2_TCI4V, 170),
-	INTC_IRQ(ADC_ADI, 171),
-	INTC_IRQ(IIC30, 172), INTC_IRQ(IIC30, 173),
-	INTC_IRQ(IIC30, 174), INTC_IRQ(IIC30, 175),
-	INTC_IRQ(IIC30, 176),
-	INTC_IRQ(IIC31, 177), INTC_IRQ(IIC31, 178),
-	INTC_IRQ(IIC31, 179), INTC_IRQ(IIC31, 180),
-	INTC_IRQ(IIC31, 181),
-	INTC_IRQ(IIC32, 182), INTC_IRQ(IIC32, 183),
-	INTC_IRQ(IIC32, 184), INTC_IRQ(IIC32, 185),
-	INTC_IRQ(IIC32, 186),
-	INTC_IRQ(IIC33, 187), INTC_IRQ(IIC33, 188),
-	INTC_IRQ(IIC33, 189), INTC_IRQ(IIC33, 190),
-	INTC_IRQ(IIC33, 191),
-	INTC_IRQ(SCIF0, 192), INTC_IRQ(SCIF0, 193),
-	INTC_IRQ(SCIF0, 194), INTC_IRQ(SCIF0, 195),
-	INTC_IRQ(SCIF1, 196), INTC_IRQ(SCIF1, 197),
-	INTC_IRQ(SCIF1, 198), INTC_IRQ(SCIF1, 199),
-	INTC_IRQ(SCIF2, 200), INTC_IRQ(SCIF2, 201),
-	INTC_IRQ(SCIF2, 202), INTC_IRQ(SCIF2, 203),
-	INTC_IRQ(SCIF3, 204), INTC_IRQ(SCIF3, 205),
-	INTC_IRQ(SCIF3, 206), INTC_IRQ(SCIF3, 207),
-	INTC_IRQ(SSU0, 208), INTC_IRQ(SSU0, 209),
-	INTC_IRQ(SSU0, 210),
-	INTC_IRQ(SSU1, 211), INTC_IRQ(SSU1, 212),
-	INTC_IRQ(SSU1, 213),
-	INTC_IRQ(SSI0_SSII, 214), INTC_IRQ(SSI1_SSII, 215),
-	INTC_IRQ(SSI2_SSII, 216), INTC_IRQ(SSI3_SSII, 217),
-	INTC_IRQ(FLCTL, 224), INTC_IRQ(FLCTL, 225),
-	INTC_IRQ(FLCTL, 226), INTC_IRQ(FLCTL, 227),
-	INTC_IRQ(RTC, 231), INTC_IRQ(RTC, 232),
-	INTC_IRQ(RTC, 233),
-	INTC_IRQ(RCAN0, 234), INTC_IRQ(RCAN0, 235),
-	INTC_IRQ(RCAN0, 236), INTC_IRQ(RCAN0, 237),
-	INTC_IRQ(RCAN0, 238),
-	INTC_IRQ(RCAN1, 239), INTC_IRQ(RCAN1, 240),
-	INTC_IRQ(RCAN1, 241), INTC_IRQ(RCAN1, 242),
-	INTC_IRQ(RCAN1, 243),
-
-	/* SH7263-specific trash */
-#ifdef CONFIG_CPU_SUBTYPE_SH7263
-	INTC_IRQ(ROMDEC, 218), INTC_IRQ(ROMDEC, 219),
-	INTC_IRQ(ROMDEC, 220), INTC_IRQ(ROMDEC, 221),
-	INTC_IRQ(ROMDEC, 222), INTC_IRQ(ROMDEC, 223),
-
-	INTC_IRQ(SDHI, 228), INTC_IRQ(SDHI, 229),
-	INTC_IRQ(SDHI, 230),
-
-	INTC_IRQ(SRC, 244), INTC_IRQ(SRC, 245),
-	INTC_IRQ(SRC, 246),
-
-	INTC_IRQ(IEBI, 247),
-#endif
-};
-
-static struct intc_group groups[] __initdata = {
-	INTC_GROUP(PINT, PINT0, PINT1, PINT2, PINT3,
-		   PINT4, PINT5, PINT6, PINT7),
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xfffe0818, 0, 16, 4, /* IPR01 */ { IRQ0, IRQ1, IRQ2, IRQ3 } },
-	{ 0xfffe081a, 0, 16, 4, /* IPR02 */ { IRQ4, IRQ5, IRQ6, IRQ7 } },
-	{ 0xfffe0820, 0, 16, 4, /* IPR05 */ { PINT, 0, 0, 0 } },
-	{ 0xfffe0c00, 0, 16, 4, /* IPR06 */ { DMAC0, DMAC1, DMAC2, DMAC3 } },
-	{ 0xfffe0c02, 0, 16, 4, /* IPR07 */ { DMAC4, DMAC5, DMAC6, DMAC7 } },
-	{ 0xfffe0c04, 0, 16, 4, /* IPR08 */ { USB, LCDC, CMT0, CMT1 } },
-	{ 0xfffe0c06, 0, 16, 4, /* IPR09 */ { BSC, WDT, MTU0_ABCD, MTU0_VEF } },
-	{ 0xfffe0c08, 0, 16, 4, /* IPR10 */ { MTU1_AB, MTU1_VU, MTU2_AB,
-					      MTU2_VU } },
-	{ 0xfffe0c0a, 0, 16, 4, /* IPR11 */ { MTU3_ABCD, MTU2_TCI3V, MTU4_ABCD,
-					      MTU2_TCI4V } },
-	{ 0xfffe0c0c, 0, 16, 4, /* IPR12 */ { ADC_ADI, IIC30, IIC31, IIC32 } },
-	{ 0xfffe0c0e, 0, 16, 4, /* IPR13 */ { IIC33, SCIF0, SCIF1, SCIF2 } },
-	{ 0xfffe0c10, 0, 16, 4, /* IPR14 */ { SCIF3, SSU0, SSU1, SSI0_SSII } },
-#ifdef CONFIG_CPU_SUBTYPE_SH7203
-	{ 0xfffe0c12, 0, 16, 4, /* IPR15 */ { SSI1_SSII, SSI2_SSII,
-					      SSI3_SSII, 0 } },
-	{ 0xfffe0c14, 0, 16, 4, /* IPR16 */ { FLCTL, 0, RTC, RCAN0 } },
-	{ 0xfffe0c16, 0, 16, 4, /* IPR17 */ { RCAN1, 0, 0, 0 } },
-#else
-	{ 0xfffe0c12, 0, 16, 4, /* IPR15 */ { SSI1_SSII, SSI2_SSII,
-					      SSI3_SSII, ROMDEC } },
-	{ 0xfffe0c14, 0, 16, 4, /* IPR16 */ { FLCTL, SDHI, RTC, RCAN0 } },
-	{ 0xfffe0c16, 0, 16, 4, /* IPR17 */ { RCAN1, SRC, IEBI, 0 } },
-#endif
-};
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xfffe0808, 0, 16, /* PINTER */
-	  { 0, 0, 0, 0, 0, 0, 0, 0,
-	    PINT7, PINT6, PINT5, PINT4, PINT3, PINT2, PINT1, PINT0 } },
-};
-
-static DECLARE_INTC_DESC(intc_desc, "sh7203", vectors, groups,
-			 mask_registers, prio_registers, NULL);
-
-static struct plat_sci_port scif0_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xfffe8000, 0x100),
-	DEFINE_RES_IRQ(192),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct plat_sci_port scif1_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif1_resources[] = {
-	DEFINE_RES_MEM(0xfffe8800, 0x100),
-	DEFINE_RES_IRQ(196),
-};
-
-static struct platform_device scif1_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif1_resources,
-	.num_resources	= ARRAY_SIZE(scif1_resources),
-	.dev		= {
-		.platform_data	= &scif1_platform_data,
-	},
-};
-
-static struct plat_sci_port scif2_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif2_resources[] = {
-	DEFINE_RES_MEM(0xfffe9000, 0x100),
-	DEFINE_RES_IRQ(200),
-};
-
-static struct platform_device scif2_device = {
-	.name		= "sh-sci",
-	.id		= 2,
-	.resource	= scif2_resources,
-	.num_resources	= ARRAY_SIZE(scif2_resources),
-	.dev		= {
-		.platform_data	= &scif2_platform_data,
-	},
-};
-
-static struct plat_sci_port scif3_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif3_resources[] = {
-	DEFINE_RES_MEM(0xfffe9800, 0x100),
-	DEFINE_RES_IRQ(204),
-};
-
-static struct platform_device scif3_device = {
-	.name		= "sh-sci",
-	.id		= 3,
-	.resource	= scif3_resources,
-	.num_resources	= ARRAY_SIZE(scif3_resources),
-	.dev		= {
-		.platform_data	= &scif3_platform_data,
-	},
-};
-
-static struct sh_timer_config cmt_platform_data = {
-	.channels_mask = 3,
-};
-
-static struct resource cmt_resources[] = {
-	DEFINE_RES_MEM(0xfffec000, 0x10),
-	DEFINE_RES_IRQ(142),
-	DEFINE_RES_IRQ(143),
-};
-
-static struct platform_device cmt_device = {
-	.name		= "sh-cmt-16",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &cmt_platform_data,
-	},
-	.resource	= cmt_resources,
-	.num_resources	= ARRAY_SIZE(cmt_resources),
-};
-
-static struct resource mtu2_resources[] = {
-	DEFINE_RES_MEM(0xfffe4000, 0x400),
-	DEFINE_RES_IRQ_NAMED(146, "tgi0a"),
-	DEFINE_RES_IRQ_NAMED(153, "tgi1a"),
-};
-
-static struct platform_device mtu2_device = {
-	.name		= "sh-mtu2",
-	.id		= -1,
-	.resource	= mtu2_resources,
-	.num_resources	= ARRAY_SIZE(mtu2_resources),
-};
-
-static struct resource rtc_resources[] = {
-	[0] = {
-		.start	= 0xffff2000,
-		.end	= 0xffff2000 + 0x58 - 1,
-		.flags	= IORESOURCE_IO,
-	},
-	[1] = {
-		/* Shared Period/Carry/Alarm IRQ */
-		.start	= 231,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device rtc_device = {
-	.name		= "sh-rtc",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(rtc_resources),
-	.resource	= rtc_resources,
-};
-
-static struct platform_device *sh7203_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&cmt_device,
-	&mtu2_device,
-	&rtc_device,
-};
-
-static int __init sh7203_devices_setup(void)
-{
-	return platform_add_devices(sh7203_devices,
-				    ARRAY_SIZE(sh7203_devices));
-}
-arch_initcall(sh7203_devices_setup);
-
-void __init plat_irq_setup(void)
-{
-	register_intc_controller(&intc_desc);
-}
-
-static struct platform_device *sh7203_early_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&cmt_device,
-	&mtu2_device,
-};
-
-#define STBCR3 0xfffe0408
-#define STBCR4 0xfffe040c
-
-void __init plat_early_device_setup(void)
-{
-	/* enable CMT clock */
-	__raw_writeb(__raw_readb(STBCR4) & ~0x04, STBCR4);
-
-	/* enable MTU2 clock */
-	__raw_writeb(__raw_readb(STBCR3) & ~0x20, STBCR3);
-
-	sh_early_platform_add_devices(sh7203_early_devices,
-				   ARRAY_SIZE(sh7203_early_devices));
-}
diff --git a/arch/sh/kernel/cpu/sh2a/setup-sh7206.c b/arch/sh/kernel/cpu/sh2a/setup-sh7206.c
deleted file mode 100644
index 68add5af4cc56e..00000000000000
--- a/arch/sh/kernel/cpu/sh2a/setup-sh7206.c
+++ /dev/null
@@ -1,291 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7206 Setup
- *
- *  Copyright (C) 2006  Yoshinori Sato
- *  Copyright (C) 2009  Paul Mundt
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/serial_sci.h>
-#include <linux/sh_timer.h>
-#include <linux/io.h>
-#include <asm/platform_early.h>
-
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-	IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7,
-	PINT0, PINT1, PINT2, PINT3, PINT4, PINT5, PINT6, PINT7,
-	ADC_ADI0, ADC_ADI1,
-
-	DMAC0, DMAC1, DMAC2, DMAC3, DMAC4, DMAC5, DMAC6, DMAC7,
-
-	MTU0_ABCD, MTU0_VEF, MTU1_AB, MTU1_VU, MTU2_AB, MTU2_VU,
-	MTU3_ABCD, MTU4_ABCD, MTU5, POE2_12, MTU3S_ABCD, MTU4S_ABCD, MTU5S,
-	IIC3,
-
-	CMT0, CMT1, BSC, WDT,
-
-	MTU2_TCI3V, MTU2_TCI4V, MTU2S_TCI3V, MTU2S_TCI4V,
-
-	POE2_OEI3,
-
-	SCIF0, SCIF1, SCIF2, SCIF3,
-
-	/* interrupt groups */
-	PINT,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_IRQ(IRQ0, 64), INTC_IRQ(IRQ1, 65),
-	INTC_IRQ(IRQ2, 66), INTC_IRQ(IRQ3, 67),
-	INTC_IRQ(IRQ4, 68), INTC_IRQ(IRQ5, 69),
-	INTC_IRQ(IRQ6, 70), INTC_IRQ(IRQ7, 71),
-	INTC_IRQ(PINT0, 80), INTC_IRQ(PINT1, 81),
-	INTC_IRQ(PINT2, 82), INTC_IRQ(PINT3, 83),
-	INTC_IRQ(PINT4, 84), INTC_IRQ(PINT5, 85),
-	INTC_IRQ(PINT6, 86), INTC_IRQ(PINT7, 87),
-	INTC_IRQ(ADC_ADI0, 92), INTC_IRQ(ADC_ADI1, 96),
-	INTC_IRQ(DMAC0, 108), INTC_IRQ(DMAC0, 109),
-	INTC_IRQ(DMAC1, 112), INTC_IRQ(DMAC1, 113),
-	INTC_IRQ(DMAC2, 116), INTC_IRQ(DMAC2, 117),
-	INTC_IRQ(DMAC3, 120), INTC_IRQ(DMAC3, 121),
-	INTC_IRQ(DMAC4, 124), INTC_IRQ(DMAC4, 125),
-	INTC_IRQ(DMAC5, 128), INTC_IRQ(DMAC5, 129),
-	INTC_IRQ(DMAC6, 132), INTC_IRQ(DMAC6, 133),
-	INTC_IRQ(DMAC7, 136), INTC_IRQ(DMAC7, 137),
-	INTC_IRQ(CMT0, 140), INTC_IRQ(CMT1, 144),
-	INTC_IRQ(BSC, 148), INTC_IRQ(WDT, 152),
-	INTC_IRQ(MTU0_ABCD, 156), INTC_IRQ(MTU0_ABCD, 157),
-	INTC_IRQ(MTU0_ABCD, 158), INTC_IRQ(MTU0_ABCD, 159),
-	INTC_IRQ(MTU0_VEF, 160), INTC_IRQ(MTU0_VEF, 161),
-	INTC_IRQ(MTU0_VEF, 162),
-	INTC_IRQ(MTU1_AB, 164), INTC_IRQ(MTU1_AB, 165),
-	INTC_IRQ(MTU1_VU, 168), INTC_IRQ(MTU1_VU, 169),
-	INTC_IRQ(MTU2_AB, 172), INTC_IRQ(MTU2_AB, 173),
-	INTC_IRQ(MTU2_VU, 176), INTC_IRQ(MTU2_VU, 177),
-	INTC_IRQ(MTU3_ABCD, 180), INTC_IRQ(MTU3_ABCD, 181),
-	INTC_IRQ(MTU3_ABCD, 182), INTC_IRQ(MTU3_ABCD, 183),
-	INTC_IRQ(MTU2_TCI3V, 184),
-	INTC_IRQ(MTU4_ABCD, 188), INTC_IRQ(MTU4_ABCD, 189),
-	INTC_IRQ(MTU4_ABCD, 190), INTC_IRQ(MTU4_ABCD, 191),
-	INTC_IRQ(MTU2_TCI4V, 192),
-	INTC_IRQ(MTU5, 196), INTC_IRQ(MTU5, 197),
-	INTC_IRQ(MTU5, 198),
-	INTC_IRQ(POE2_12, 200), INTC_IRQ(POE2_12, 201),
-	INTC_IRQ(MTU3S_ABCD, 204), INTC_IRQ(MTU3S_ABCD, 205),
-	INTC_IRQ(MTU3S_ABCD, 206), INTC_IRQ(MTU3S_ABCD, 207),
-	INTC_IRQ(MTU2S_TCI3V, 208),
-	INTC_IRQ(MTU4S_ABCD, 212), INTC_IRQ(MTU4S_ABCD, 213),
-	INTC_IRQ(MTU4S_ABCD, 214), INTC_IRQ(MTU4S_ABCD, 215),
-	INTC_IRQ(MTU2S_TCI4V, 216),
-	INTC_IRQ(MTU5S, 220), INTC_IRQ(MTU5S, 221),
-	INTC_IRQ(MTU5S, 222),
-	INTC_IRQ(POE2_OEI3, 224),
-	INTC_IRQ(IIC3, 228), INTC_IRQ(IIC3, 229),
-	INTC_IRQ(IIC3, 230), INTC_IRQ(IIC3, 231),
-	INTC_IRQ(IIC3, 232),
-	INTC_IRQ(SCIF0, 240), INTC_IRQ(SCIF0, 241),
-	INTC_IRQ(SCIF0, 242), INTC_IRQ(SCIF0, 243),
-	INTC_IRQ(SCIF1, 244), INTC_IRQ(SCIF1, 245),
-	INTC_IRQ(SCIF1, 246), INTC_IRQ(SCIF1, 247),
-	INTC_IRQ(SCIF2, 248), INTC_IRQ(SCIF2, 249),
-	INTC_IRQ(SCIF2, 250), INTC_IRQ(SCIF2, 251),
-	INTC_IRQ(SCIF3, 252), INTC_IRQ(SCIF3, 253),
-	INTC_IRQ(SCIF3, 254), INTC_IRQ(SCIF3, 255),
-};
-
-static struct intc_group groups[] __initdata = {
-	INTC_GROUP(PINT, PINT0, PINT1, PINT2, PINT3,
-		   PINT4, PINT5, PINT6, PINT7),
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xfffe0818, 0, 16, 4, /* IPR01 */ { IRQ0, IRQ1, IRQ2, IRQ3 } },
-	{ 0xfffe081a, 0, 16, 4, /* IPR02 */ { IRQ4, IRQ5, IRQ6, IRQ7 } },
-	{ 0xfffe0820, 0, 16, 4, /* IPR05 */ { PINT, 0, ADC_ADI0, ADC_ADI1 } },
-	{ 0xfffe0c00, 0, 16, 4, /* IPR06 */ { DMAC0, DMAC1, DMAC2, DMAC3 } },
-	{ 0xfffe0c02, 0, 16, 4, /* IPR07 */ { DMAC4, DMAC5, DMAC6, DMAC7 } },
-	{ 0xfffe0c04, 0, 16, 4, /* IPR08 */ { CMT0, CMT1, BSC, WDT } },
-	{ 0xfffe0c06, 0, 16, 4, /* IPR09 */ { MTU0_ABCD, MTU0_VEF,
-					      MTU1_AB, MTU1_VU } },
-	{ 0xfffe0c08, 0, 16, 4, /* IPR10 */ { MTU2_AB, MTU2_VU,
-					      MTU3_ABCD, MTU2_TCI3V } },
-	{ 0xfffe0c0a, 0, 16, 4, /* IPR11 */ { MTU4_ABCD, MTU2_TCI4V,
-					      MTU5, POE2_12 } },
-	{ 0xfffe0c0c, 0, 16, 4, /* IPR12 */ { MTU3S_ABCD, MTU2S_TCI3V,
-					      MTU4S_ABCD, MTU2S_TCI4V } },
-	{ 0xfffe0c0e, 0, 16, 4, /* IPR13 */ { MTU5S, POE2_OEI3, IIC3, 0 } },
-	{ 0xfffe0c10, 0, 16, 4, /* IPR14 */ { SCIF0, SCIF1, SCIF2, SCIF3 } },
-};
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xfffe0808, 0, 16, /* PINTER */
-	  { 0, 0, 0, 0, 0, 0, 0, 0,
-	    PINT7, PINT6, PINT5, PINT4, PINT3, PINT2, PINT1, PINT0 } },
-};
-
-static DECLARE_INTC_DESC(intc_desc, "sh7206", vectors, groups,
-			 mask_registers, prio_registers, NULL);
-
-static struct plat_sci_port scif0_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xfffe8000, 0x100),
-	DEFINE_RES_IRQ(240),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct plat_sci_port scif1_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif1_resources[] = {
-	DEFINE_RES_MEM(0xfffe8800, 0x100),
-	DEFINE_RES_IRQ(244),
-};
-
-static struct platform_device scif1_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif1_resources,
-	.num_resources	= ARRAY_SIZE(scif1_resources),
-	.dev		= {
-		.platform_data	= &scif1_platform_data,
-	},
-};
-
-static struct plat_sci_port scif2_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif2_resources[] = {
-	DEFINE_RES_MEM(0xfffe9000, 0x100),
-	DEFINE_RES_IRQ(248),
-};
-
-static struct platform_device scif2_device = {
-	.name		= "sh-sci",
-	.id		= 2,
-	.resource	= scif2_resources,
-	.num_resources	= ARRAY_SIZE(scif2_resources),
-	.dev		= {
-		.platform_data	= &scif2_platform_data,
-	},
-};
-
-static struct plat_sci_port scif3_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif3_resources[] = {
-	DEFINE_RES_MEM(0xfffe9800, 0x100),
-	DEFINE_RES_IRQ(252),
-};
-
-static struct platform_device scif3_device = {
-	.name		= "sh-sci",
-	.id		= 3,
-	.resource	= scif3_resources,
-	.num_resources	= ARRAY_SIZE(scif3_resources),
-	.dev		= {
-		.platform_data	= &scif3_platform_data,
-	},
-};
-
-static struct sh_timer_config cmt_platform_data = {
-	.channels_mask = 3,
-};
-
-static struct resource cmt_resources[] = {
-	DEFINE_RES_MEM(0xfffec000, 0x10),
-	DEFINE_RES_IRQ(140),
-	DEFINE_RES_IRQ(144),
-};
-
-static struct platform_device cmt_device = {
-	.name		= "sh-cmt-16",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &cmt_platform_data,
-	},
-	.resource	= cmt_resources,
-	.num_resources	= ARRAY_SIZE(cmt_resources),
-};
-
-static struct resource mtu2_resources[] = {
-	DEFINE_RES_MEM(0xfffe4000, 0x400),
-	DEFINE_RES_IRQ_NAMED(156, "tgi0a"),
-	DEFINE_RES_IRQ_NAMED(164, "tgi1a"),
-	DEFINE_RES_IRQ_NAMED(180, "tgi2a"),
-};
-
-static struct platform_device mtu2_device = {
-	.name		= "sh-mtu2s",
-	.id		= -1,
-	.resource	= mtu2_resources,
-	.num_resources	= ARRAY_SIZE(mtu2_resources),
-};
-
-static struct platform_device *sh7206_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&cmt_device,
-	&mtu2_device,
-};
-
-static int __init sh7206_devices_setup(void)
-{
-	return platform_add_devices(sh7206_devices,
-				    ARRAY_SIZE(sh7206_devices));
-}
-arch_initcall(sh7206_devices_setup);
-
-void __init plat_irq_setup(void)
-{
-	register_intc_controller(&intc_desc);
-}
-
-static struct platform_device *sh7206_early_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&cmt_device,
-	&mtu2_device,
-};
-
-#define STBCR3 0xfffe0408
-#define STBCR4 0xfffe040c
-
-void __init plat_early_device_setup(void)
-{
-	/* enable CMT clock */
-	__raw_writeb(__raw_readb(STBCR4) & ~0x04, STBCR4);
-
-	/* enable MTU2 clock */
-	__raw_writeb(__raw_readb(STBCR3) & ~0x20, STBCR3);
-
-	sh_early_platform_add_devices(sh7206_early_devices,
-				   ARRAY_SIZE(sh7206_early_devices));
-}
diff --git a/arch/sh/kernel/cpu/sh2a/setup-sh7264.c b/arch/sh/kernel/cpu/sh2a/setup-sh7264.c
deleted file mode 100644
index 8a1cb613dd2e04..00000000000000
--- a/arch/sh/kernel/cpu/sh2a/setup-sh7264.c
+++ /dev/null
@@ -1,552 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7264 Setup
- *
- * Copyright (C) 2012  Renesas Electronics Europe Ltd
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/serial_sci.h>
-#include <linux/usb/r8a66597.h>
-#include <linux/sh_timer.h>
-#include <linux/io.h>
-#include <asm/platform_early.h>
-
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-	IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7,
-	PINT0, PINT1, PINT2, PINT3, PINT4, PINT5, PINT6, PINT7,
-
-	DMAC0, DMAC1, DMAC2, DMAC3, DMAC4, DMAC5, DMAC6, DMAC7,
-	DMAC8, DMAC9, DMAC10, DMAC11, DMAC12, DMAC13, DMAC14, DMAC15,
-	USB, VDC3, CMT0, CMT1, BSC, WDT,
-	MTU0_ABCD, MTU0_VEF, MTU1_AB, MTU1_VU, MTU2_AB, MTU2_VU,
-	MTU3_ABCD, MTU3_TCI3V, MTU4_ABCD, MTU4_TCI4V,
-	PWMT1, PWMT2, ADC_ADI,
-	SSIF0, SSII1, SSII2, SSII3,
-	RSPDIF,
-	IIC30, IIC31, IIC32, IIC33,
-	SCIF0_BRI, SCIF0_ERI, SCIF0_RXI, SCIF0_TXI,
-	SCIF1_BRI, SCIF1_ERI, SCIF1_RXI, SCIF1_TXI,
-	SCIF2_BRI, SCIF2_ERI, SCIF2_RXI, SCIF2_TXI,
-	SCIF3_BRI, SCIF3_ERI, SCIF3_RXI, SCIF3_TXI,
-	SCIF4_BRI, SCIF4_ERI, SCIF4_RXI, SCIF4_TXI,
-	SCIF5_BRI, SCIF5_ERI, SCIF5_RXI, SCIF5_TXI,
-	SCIF6_BRI, SCIF6_ERI, SCIF6_RXI, SCIF6_TXI,
-	SCIF7_BRI, SCIF7_ERI, SCIF7_RXI, SCIF7_TXI,
-	SIO_FIFO, RSPIC0, RSPIC1,
-	RCAN0, RCAN1, IEBC, CD_ROMD,
-	NFMC, SDHI, RTC,
-	SRCC0, SRCC1, DCOMU, OFFI, IFEI,
-
-	/* interrupt groups */
-	PINT, SCIF0, SCIF1, SCIF2, SCIF3, SCIF4, SCIF5, SCIF6, SCIF7,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_IRQ(IRQ0, 64), INTC_IRQ(IRQ1, 65),
-	INTC_IRQ(IRQ2, 66), INTC_IRQ(IRQ3, 67),
-	INTC_IRQ(IRQ4, 68), INTC_IRQ(IRQ5, 69),
-	INTC_IRQ(IRQ6, 70), INTC_IRQ(IRQ7, 71),
-
-	INTC_IRQ(PINT0, 80), INTC_IRQ(PINT1, 81),
-	INTC_IRQ(PINT2, 82), INTC_IRQ(PINT3, 83),
-	INTC_IRQ(PINT4, 84), INTC_IRQ(PINT5, 85),
-	INTC_IRQ(PINT6, 86), INTC_IRQ(PINT7, 87),
-
-	INTC_IRQ(DMAC0, 108), INTC_IRQ(DMAC0, 109),
-	INTC_IRQ(DMAC1, 112), INTC_IRQ(DMAC1, 113),
-	INTC_IRQ(DMAC2, 116), INTC_IRQ(DMAC2, 117),
-	INTC_IRQ(DMAC3, 120), INTC_IRQ(DMAC3, 121),
-	INTC_IRQ(DMAC4, 124), INTC_IRQ(DMAC4, 125),
-	INTC_IRQ(DMAC5, 128), INTC_IRQ(DMAC5, 129),
-	INTC_IRQ(DMAC6, 132), INTC_IRQ(DMAC6, 133),
-	INTC_IRQ(DMAC7, 136), INTC_IRQ(DMAC7, 137),
-	INTC_IRQ(DMAC8, 140), INTC_IRQ(DMAC8, 141),
-	INTC_IRQ(DMAC9, 144), INTC_IRQ(DMAC9, 145),
-	INTC_IRQ(DMAC10, 148), INTC_IRQ(DMAC10, 149),
-	INTC_IRQ(DMAC11, 152), INTC_IRQ(DMAC11, 153),
-	INTC_IRQ(DMAC12, 156), INTC_IRQ(DMAC12, 157),
-	INTC_IRQ(DMAC13, 160), INTC_IRQ(DMAC13, 161),
-	INTC_IRQ(DMAC14, 164), INTC_IRQ(DMAC14, 165),
-	INTC_IRQ(DMAC15, 168), INTC_IRQ(DMAC15, 169),
-
-	INTC_IRQ(USB, 170),
-	INTC_IRQ(VDC3, 171), INTC_IRQ(VDC3, 172),
-	INTC_IRQ(VDC3, 173), INTC_IRQ(VDC3, 174),
-	INTC_IRQ(CMT0, 175), INTC_IRQ(CMT1, 176),
-	INTC_IRQ(BSC, 177), INTC_IRQ(WDT, 178),
-
-	INTC_IRQ(MTU0_ABCD, 179), INTC_IRQ(MTU0_ABCD, 180),
-	INTC_IRQ(MTU0_ABCD, 181), INTC_IRQ(MTU0_ABCD, 182),
-	INTC_IRQ(MTU0_VEF, 183),
-	INTC_IRQ(MTU0_VEF, 184), INTC_IRQ(MTU0_VEF, 185),
-	INTC_IRQ(MTU1_AB, 186), INTC_IRQ(MTU1_AB, 187),
-	INTC_IRQ(MTU1_VU, 188), INTC_IRQ(MTU1_VU, 189),
-	INTC_IRQ(MTU2_AB, 190), INTC_IRQ(MTU2_AB, 191),
-	INTC_IRQ(MTU2_VU, 192), INTC_IRQ(MTU2_VU, 193),
-	INTC_IRQ(MTU3_ABCD, 194), INTC_IRQ(MTU3_ABCD, 195),
-	INTC_IRQ(MTU3_ABCD, 196), INTC_IRQ(MTU3_ABCD, 197),
-	INTC_IRQ(MTU3_TCI3V, 198),
-	INTC_IRQ(MTU4_ABCD, 199), INTC_IRQ(MTU4_ABCD, 200),
-	INTC_IRQ(MTU4_ABCD, 201), INTC_IRQ(MTU4_ABCD, 202),
-	INTC_IRQ(MTU4_TCI4V, 203),
-
-	INTC_IRQ(PWMT1, 204), INTC_IRQ(PWMT2, 205),
-
-	INTC_IRQ(ADC_ADI, 206),
-
-	INTC_IRQ(SSIF0, 207), INTC_IRQ(SSIF0, 208),
-	INTC_IRQ(SSIF0, 209),
-	INTC_IRQ(SSII1, 210), INTC_IRQ(SSII1, 211),
-	INTC_IRQ(SSII2, 212), INTC_IRQ(SSII2, 213),
-	INTC_IRQ(SSII3, 214), INTC_IRQ(SSII3, 215),
-
-	INTC_IRQ(RSPDIF, 216),
-
-	INTC_IRQ(IIC30, 217), INTC_IRQ(IIC30, 218),
-	INTC_IRQ(IIC30, 219), INTC_IRQ(IIC30, 220),
-	INTC_IRQ(IIC30, 221),
-	INTC_IRQ(IIC31, 222), INTC_IRQ(IIC31, 223),
-	INTC_IRQ(IIC31, 224), INTC_IRQ(IIC31, 225),
-	INTC_IRQ(IIC31, 226),
-	INTC_IRQ(IIC32, 227), INTC_IRQ(IIC32, 228),
-	INTC_IRQ(IIC32, 229), INTC_IRQ(IIC32, 230),
-	INTC_IRQ(IIC32, 231),
-
-	INTC_IRQ(SCIF0_BRI, 232), INTC_IRQ(SCIF0_ERI, 233),
-	INTC_IRQ(SCIF0_RXI, 234), INTC_IRQ(SCIF0_TXI, 235),
-	INTC_IRQ(SCIF1_BRI, 236), INTC_IRQ(SCIF1_ERI, 237),
-	INTC_IRQ(SCIF1_RXI, 238), INTC_IRQ(SCIF1_TXI, 239),
-	INTC_IRQ(SCIF2_BRI, 240), INTC_IRQ(SCIF2_ERI, 241),
-	INTC_IRQ(SCIF2_RXI, 242), INTC_IRQ(SCIF2_TXI, 243),
-	INTC_IRQ(SCIF3_BRI, 244), INTC_IRQ(SCIF3_ERI, 245),
-	INTC_IRQ(SCIF3_RXI, 246), INTC_IRQ(SCIF3_TXI, 247),
-	INTC_IRQ(SCIF4_BRI, 248), INTC_IRQ(SCIF4_ERI, 249),
-	INTC_IRQ(SCIF4_RXI, 250), INTC_IRQ(SCIF4_TXI, 251),
-	INTC_IRQ(SCIF5_BRI, 252), INTC_IRQ(SCIF5_ERI, 253),
-	INTC_IRQ(SCIF5_RXI, 254), INTC_IRQ(SCIF5_TXI, 255),
-	INTC_IRQ(SCIF6_BRI, 256), INTC_IRQ(SCIF6_ERI, 257),
-	INTC_IRQ(SCIF6_RXI, 258), INTC_IRQ(SCIF6_TXI, 259),
-	INTC_IRQ(SCIF7_BRI, 260), INTC_IRQ(SCIF7_ERI, 261),
-	INTC_IRQ(SCIF7_RXI, 262), INTC_IRQ(SCIF7_TXI, 263),
-
-	INTC_IRQ(SIO_FIFO, 264),
-
-	INTC_IRQ(RSPIC0, 265), INTC_IRQ(RSPIC0, 266),
-	INTC_IRQ(RSPIC0, 267),
-	INTC_IRQ(RSPIC1, 268), INTC_IRQ(RSPIC1, 269),
-	INTC_IRQ(RSPIC1, 270),
-
-	INTC_IRQ(RCAN0, 271), INTC_IRQ(RCAN0, 272),
-	INTC_IRQ(RCAN0, 273), INTC_IRQ(RCAN0, 274),
-	INTC_IRQ(RCAN0, 275),
-	INTC_IRQ(RCAN1, 276), INTC_IRQ(RCAN1, 277),
-	INTC_IRQ(RCAN1, 278), INTC_IRQ(RCAN1, 279),
-	INTC_IRQ(RCAN1, 280),
-
-	INTC_IRQ(IEBC, 281),
-
-	INTC_IRQ(CD_ROMD, 282), INTC_IRQ(CD_ROMD, 283),
-	INTC_IRQ(CD_ROMD, 284), INTC_IRQ(CD_ROMD, 285),
-	INTC_IRQ(CD_ROMD, 286), INTC_IRQ(CD_ROMD, 287),
-
-	INTC_IRQ(NFMC, 288), INTC_IRQ(NFMC, 289),
-	INTC_IRQ(NFMC, 290), INTC_IRQ(NFMC, 291),
-
-	INTC_IRQ(SDHI, 292), INTC_IRQ(SDHI, 293),
-	INTC_IRQ(SDHI, 294),
-
-	INTC_IRQ(RTC, 296), INTC_IRQ(RTC, 297),
-	INTC_IRQ(RTC, 298),
-
-	INTC_IRQ(SRCC0, 299), INTC_IRQ(SRCC0, 300),
-	INTC_IRQ(SRCC0, 301), INTC_IRQ(SRCC0, 302),
-	INTC_IRQ(SRCC0, 303),
-	INTC_IRQ(SRCC1, 304), INTC_IRQ(SRCC1, 305),
-	INTC_IRQ(SRCC1, 306), INTC_IRQ(SRCC1, 307),
-	INTC_IRQ(SRCC1, 308),
-
-	INTC_IRQ(DCOMU, 310), INTC_IRQ(DCOMU, 311),
-	INTC_IRQ(DCOMU, 312),
-};
-
-static struct intc_group groups[] __initdata = {
-	INTC_GROUP(PINT, PINT0, PINT1, PINT2, PINT3,
-		   PINT4, PINT5, PINT6, PINT7),
-	INTC_GROUP(SCIF0, SCIF0_BRI, SCIF0_ERI, SCIF0_RXI, SCIF0_TXI),
-	INTC_GROUP(SCIF1, SCIF1_BRI, SCIF1_ERI, SCIF1_RXI, SCIF1_TXI),
-	INTC_GROUP(SCIF2, SCIF2_BRI, SCIF2_ERI, SCIF2_RXI, SCIF2_TXI),
-	INTC_GROUP(SCIF3, SCIF3_BRI, SCIF3_ERI, SCIF3_RXI, SCIF3_TXI),
-	INTC_GROUP(SCIF4, SCIF4_BRI, SCIF4_ERI, SCIF4_RXI, SCIF4_TXI),
-	INTC_GROUP(SCIF5, SCIF5_BRI, SCIF5_ERI, SCIF5_RXI, SCIF5_TXI),
-	INTC_GROUP(SCIF6, SCIF6_BRI, SCIF6_ERI, SCIF6_RXI, SCIF6_TXI),
-	INTC_GROUP(SCIF7, SCIF7_BRI, SCIF7_ERI, SCIF7_RXI, SCIF7_TXI),
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xfffe0818, 0, 16, 4, /* IPR01 */ { IRQ0, IRQ1, IRQ2, IRQ3 } },
-	{ 0xfffe081a, 0, 16, 4, /* IPR02 */ { IRQ4, IRQ5, IRQ6, IRQ7 } },
-	{ 0xfffe0820, 0, 16, 4, /* IPR05 */ { PINT, 0, 0, 0 } },
-	{ 0xfffe0c00, 0, 16, 4, /* IPR06 */ { DMAC0,  DMAC1,  DMAC2,  DMAC3 } },
-	{ 0xfffe0c02, 0, 16, 4, /* IPR07 */ { DMAC4,  DMAC5,  DMAC6,  DMAC7 } },
-	{ 0xfffe0c04, 0, 16, 4, /* IPR08 */ { DMAC8,  DMAC9,
-					      DMAC10, DMAC11 } },
-	{ 0xfffe0c06, 0, 16, 4, /* IPR09 */ { DMAC12, DMAC13,
-					      DMAC14, DMAC15 } },
-	{ 0xfffe0c08, 0, 16, 4, /* IPR10 */ { USB, VDC3, CMT0, CMT1 } },
-	{ 0xfffe0c0a, 0, 16, 4, /* IPR11 */ { BSC, WDT, MTU0_ABCD, MTU0_VEF } },
-	{ 0xfffe0c0c, 0, 16, 4, /* IPR12 */ { MTU1_AB, MTU1_VU,
-					      MTU2_AB, MTU2_VU } },
-	{ 0xfffe0c0e, 0, 16, 4, /* IPR13 */ { MTU3_ABCD, MTU3_TCI3V,
-					      MTU4_ABCD, MTU4_TCI4V } },
-	{ 0xfffe0c10, 0, 16, 4, /* IPR14 */ { PWMT1, PWMT2, ADC_ADI, 0 } },
-	{ 0xfffe0c12, 0, 16, 4, /* IPR15 */ { SSIF0, SSII1, SSII2, SSII3 } },
-	{ 0xfffe0c14, 0, 16, 4, /* IPR16 */ { RSPDIF, IIC30, IIC31, IIC32 } },
-	{ 0xfffe0c16, 0, 16, 4, /* IPR17 */ { SCIF0, SCIF1, SCIF2, SCIF3 } },
-	{ 0xfffe0c18, 0, 16, 4, /* IPR18 */ { SCIF4, SCIF5, SCIF6, SCIF7 } },
-	{ 0xfffe0c1a, 0, 16, 4, /* IPR19 */ { SIO_FIFO, 0, RSPIC0, RSPIC1, } },
-	{ 0xfffe0c1c, 0, 16, 4, /* IPR20 */ { RCAN0, RCAN1, IEBC, CD_ROMD } },
-	{ 0xfffe0c1e, 0, 16, 4, /* IPR21 */ { NFMC, SDHI, RTC, 0 } },
-	{ 0xfffe0c20, 0, 16, 4, /* IPR22 */ { SRCC0, SRCC1, 0, DCOMU } },
-};
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xfffe0808, 0, 16, /* PINTER */
-	  { 0, 0, 0, 0, 0, 0, 0, 0,
-	    PINT7, PINT6, PINT5, PINT4, PINT3, PINT2, PINT1, PINT0 } },
-};
-
-static DECLARE_INTC_DESC(intc_desc, "sh7264", vectors, groups,
-			 mask_registers, prio_registers, NULL);
-
-static struct plat_sci_port scif0_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xfffe8000, 0x100),
-	DEFINE_RES_IRQ(233),
-	DEFINE_RES_IRQ(234),
-	DEFINE_RES_IRQ(235),
-	DEFINE_RES_IRQ(232),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct plat_sci_port scif1_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif1_resources[] = {
-	DEFINE_RES_MEM(0xfffe8800, 0x100),
-	DEFINE_RES_IRQ(237),
-	DEFINE_RES_IRQ(238),
-	DEFINE_RES_IRQ(239),
-	DEFINE_RES_IRQ(236),
-};
-
-static struct platform_device scif1_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif1_resources,
-	.num_resources	= ARRAY_SIZE(scif1_resources),
-	.dev		= {
-		.platform_data	= &scif1_platform_data,
-	},
-};
-
-static struct plat_sci_port scif2_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif2_resources[] = {
-	DEFINE_RES_MEM(0xfffe9000, 0x100),
-	DEFINE_RES_IRQ(241),
-	DEFINE_RES_IRQ(242),
-	DEFINE_RES_IRQ(243),
-	DEFINE_RES_IRQ(240),
-};
-
-static struct platform_device scif2_device = {
-	.name		= "sh-sci",
-	.id		= 2,
-	.resource	= scif2_resources,
-	.num_resources	= ARRAY_SIZE(scif2_resources),
-	.dev		= {
-		.platform_data	= &scif2_platform_data,
-	},
-};
-
-static struct plat_sci_port scif3_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif3_resources[] = {
-	DEFINE_RES_MEM(0xfffe9800, 0x100),
-	DEFINE_RES_IRQ(245),
-	DEFINE_RES_IRQ(246),
-	DEFINE_RES_IRQ(247),
-	DEFINE_RES_IRQ(244),
-};
-
-static struct platform_device scif3_device = {
-	.name		= "sh-sci",
-	.id		= 3,
-	.resource	= scif3_resources,
-	.num_resources	= ARRAY_SIZE(scif3_resources),
-	.dev		= {
-		.platform_data	= &scif3_platform_data,
-	},
-};
-
-static struct plat_sci_port scif4_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif4_resources[] = {
-	DEFINE_RES_MEM(0xfffea000, 0x100),
-	DEFINE_RES_IRQ(249),
-	DEFINE_RES_IRQ(250),
-	DEFINE_RES_IRQ(251),
-	DEFINE_RES_IRQ(248),
-};
-
-static struct platform_device scif4_device = {
-	.name		= "sh-sci",
-	.id		= 4,
-	.resource	= scif4_resources,
-	.num_resources	= ARRAY_SIZE(scif4_resources),
-	.dev		= {
-		.platform_data	= &scif4_platform_data,
-	},
-};
-
-static struct plat_sci_port scif5_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif5_resources[] = {
-	DEFINE_RES_MEM(0xfffea800, 0x100),
-	DEFINE_RES_IRQ(253),
-	DEFINE_RES_IRQ(254),
-	DEFINE_RES_IRQ(255),
-	DEFINE_RES_IRQ(252),
-};
-
-static struct platform_device scif5_device = {
-	.name		= "sh-sci",
-	.id		= 5,
-	.resource	= scif5_resources,
-	.num_resources	= ARRAY_SIZE(scif5_resources),
-	.dev		= {
-		.platform_data	= &scif5_platform_data,
-	},
-};
-
-static struct plat_sci_port scif6_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif6_resources[] = {
-	DEFINE_RES_MEM(0xfffeb000, 0x100),
-	DEFINE_RES_IRQ(257),
-	DEFINE_RES_IRQ(258),
-	DEFINE_RES_IRQ(259),
-	DEFINE_RES_IRQ(256),
-};
-
-static struct platform_device scif6_device = {
-	.name		= "sh-sci",
-	.id		= 6,
-	.resource	= scif6_resources,
-	.num_resources	= ARRAY_SIZE(scif6_resources),
-	.dev		= {
-		.platform_data	= &scif6_platform_data,
-	},
-};
-
-static struct plat_sci_port scif7_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif7_resources[] = {
-	DEFINE_RES_MEM(0xfffeb800, 0x100),
-	DEFINE_RES_IRQ(261),
-	DEFINE_RES_IRQ(262),
-	DEFINE_RES_IRQ(263),
-	DEFINE_RES_IRQ(260),
-};
-
-static struct platform_device scif7_device = {
-	.name		= "sh-sci",
-	.id		= 7,
-	.resource	= scif7_resources,
-	.num_resources	= ARRAY_SIZE(scif7_resources),
-	.dev		= {
-		.platform_data	= &scif7_platform_data,
-	},
-};
-
-static struct sh_timer_config cmt_platform_data = {
-	.channels_mask = 3,
-};
-
-static struct resource cmt_resources[] = {
-	DEFINE_RES_MEM(0xfffec000, 0x10),
-	DEFINE_RES_IRQ(175),
-	DEFINE_RES_IRQ(176),
-};
-
-static struct platform_device cmt_device = {
-	.name		= "sh-cmt-16",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &cmt_platform_data,
-	},
-	.resource	= cmt_resources,
-	.num_resources	= ARRAY_SIZE(cmt_resources),
-};
-
-static struct resource mtu2_resources[] = {
-	DEFINE_RES_MEM(0xfffe4000, 0x400),
-	DEFINE_RES_IRQ_NAMED(179, "tgi0a"),
-	DEFINE_RES_IRQ_NAMED(186, "tgi1a"),
-};
-
-static struct platform_device mtu2_device = {
-	.name		= "sh-mtu2",
-	.id		= -1,
-	.resource	= mtu2_resources,
-	.num_resources	= ARRAY_SIZE(mtu2_resources),
-};
-
-static struct resource rtc_resources[] = {
-	[0] = {
-		.start	= 0xfffe6000,
-		.end	= 0xfffe6000 + 0x30 - 1,
-		.flags	= IORESOURCE_IO,
-	},
-	[1] = {
-		/* Shared Period/Carry/Alarm IRQ */
-		.start	= 296,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device rtc_device = {
-	.name		= "sh-rtc",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(rtc_resources),
-	.resource	= rtc_resources,
-};
-
-/* USB Host */
-static void usb_port_power(int port, int power)
-{
-	__raw_writew(0x200 , 0xffffc0c2) ; /* Initialise UACS25 */
-}
-
-static struct r8a66597_platdata r8a66597_data = {
-	.on_chip = 1,
-	.endian = 1,
-	.port_power = usb_port_power,
-};
-
-static struct resource r8a66597_usb_host_resources[] = {
-	[0] = {
-		.start	= 0xffffc000,
-		.end	= 0xffffc0e4,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= 170,
-		.end	= 170,
-		.flags	= IORESOURCE_IRQ | IRQF_TRIGGER_LOW,
-	},
-};
-
-static struct platform_device r8a66597_usb_host_device = {
-	.name		= "r8a66597_hcd",
-	.id		= 0,
-	.dev = {
-		.dma_mask		= NULL,         /*  not use dma */
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &r8a66597_data,
-	},
-	.num_resources	= ARRAY_SIZE(r8a66597_usb_host_resources),
-	.resource	= r8a66597_usb_host_resources,
-};
-
-static struct platform_device *sh7264_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&scif4_device,
-	&scif5_device,
-	&scif6_device,
-	&scif7_device,
-	&cmt_device,
-	&mtu2_device,
-	&rtc_device,
-	&r8a66597_usb_host_device,
-};
-
-static int __init sh7264_devices_setup(void)
-{
-	return platform_add_devices(sh7264_devices,
-				    ARRAY_SIZE(sh7264_devices));
-}
-arch_initcall(sh7264_devices_setup);
-
-void __init plat_irq_setup(void)
-{
-	register_intc_controller(&intc_desc);
-}
-
-static struct platform_device *sh7264_early_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&scif4_device,
-	&scif5_device,
-	&scif6_device,
-	&scif7_device,
-	&cmt_device,
-	&mtu2_device,
-};
-
-void __init plat_early_device_setup(void)
-{
-	sh_early_platform_add_devices(sh7264_early_devices,
-				   ARRAY_SIZE(sh7264_early_devices));
-}
diff --git a/arch/sh/kernel/cpu/sh2a/setup-sh7269.c b/arch/sh/kernel/cpu/sh2a/setup-sh7269.c
deleted file mode 100644
index 8b1ef3028320c7..00000000000000
--- a/arch/sh/kernel/cpu/sh2a/setup-sh7269.c
+++ /dev/null
@@ -1,568 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7269 Setup
- *
- * Copyright (C) 2012  Renesas Electronics Europe Ltd
- * Copyright (C) 2012  Phil Edworthy
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/serial_sci.h>
-#include <linux/usb/r8a66597.h>
-#include <linux/sh_timer.h>
-#include <linux/io.h>
-#include <asm/platform_early.h>
-
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-	IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7,
-	PINT0, PINT1, PINT2, PINT3, PINT4, PINT5, PINT6, PINT7,
-
-	DMAC0, DMAC1, DMAC2, DMAC3, DMAC4, DMAC5, DMAC6, DMAC7,
-	DMAC8, DMAC9, DMAC10, DMAC11, DMAC12, DMAC13, DMAC14, DMAC15,
-	USB, VDC4, CMT0, CMT1, BSC, WDT,
-	MTU0_ABCD, MTU0_VEF, MTU1_AB, MTU1_VU, MTU2_AB, MTU2_VU,
-	MTU3_ABCD, MTU3_TCI3V, MTU4_ABCD, MTU4_TCI4V,
-	PWMT1, PWMT2, ADC_ADI,
-	SSIF0, SSII1, SSII2, SSII3, SSII4, SSII5,
-	RSPDIF,
-	IIC30, IIC31, IIC32, IIC33,
-	SCIF0_BRI, SCIF0_ERI, SCIF0_RXI, SCIF0_TXI,
-	SCIF1_BRI, SCIF1_ERI, SCIF1_RXI, SCIF1_TXI,
-	SCIF2_BRI, SCIF2_ERI, SCIF2_RXI, SCIF2_TXI,
-	SCIF3_BRI, SCIF3_ERI, SCIF3_RXI, SCIF3_TXI,
-	SCIF4_BRI, SCIF4_ERI, SCIF4_RXI, SCIF4_TXI,
-	SCIF5_BRI, SCIF5_ERI, SCIF5_RXI, SCIF5_TXI,
-	SCIF6_BRI, SCIF6_ERI, SCIF6_RXI, SCIF6_TXI,
-	SCIF7_BRI, SCIF7_ERI, SCIF7_RXI, SCIF7_TXI,
-	RCAN0, RCAN1, RCAN2,
-	RSPIC0, RSPIC1,
-	IEBC, CD_ROMD,
-	NFMC,
-	SDHI0, SDHI1,
-	RTC,
-	SRCC0, SRCC1, SRCC2,
-
-	/* interrupt groups */
-	PINT, SCIF0, SCIF1, SCIF2, SCIF3, SCIF4, SCIF5, SCIF6, SCIF7,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_IRQ(IRQ0, 64), INTC_IRQ(IRQ1, 65),
-	INTC_IRQ(IRQ2, 66), INTC_IRQ(IRQ3, 67),
-	INTC_IRQ(IRQ4, 68), INTC_IRQ(IRQ5, 69),
-	INTC_IRQ(IRQ6, 70), INTC_IRQ(IRQ7, 71),
-
-	INTC_IRQ(PINT0, 80), INTC_IRQ(PINT1, 81),
-	INTC_IRQ(PINT2, 82), INTC_IRQ(PINT3, 83),
-	INTC_IRQ(PINT4, 84), INTC_IRQ(PINT5, 85),
-	INTC_IRQ(PINT6, 86), INTC_IRQ(PINT7, 87),
-
-	INTC_IRQ(DMAC0, 108), INTC_IRQ(DMAC0, 109),
-	INTC_IRQ(DMAC1, 112), INTC_IRQ(DMAC1, 113),
-	INTC_IRQ(DMAC2, 116), INTC_IRQ(DMAC2, 117),
-	INTC_IRQ(DMAC3, 120), INTC_IRQ(DMAC3, 121),
-	INTC_IRQ(DMAC4, 124), INTC_IRQ(DMAC4, 125),
-	INTC_IRQ(DMAC5, 128), INTC_IRQ(DMAC5, 129),
-	INTC_IRQ(DMAC6, 132), INTC_IRQ(DMAC6, 133),
-	INTC_IRQ(DMAC7, 136), INTC_IRQ(DMAC7, 137),
-	INTC_IRQ(DMAC8, 140), INTC_IRQ(DMAC8, 141),
-	INTC_IRQ(DMAC9, 144), INTC_IRQ(DMAC9, 145),
-	INTC_IRQ(DMAC10, 148), INTC_IRQ(DMAC10, 149),
-	INTC_IRQ(DMAC11, 152), INTC_IRQ(DMAC11, 153),
-	INTC_IRQ(DMAC12, 156), INTC_IRQ(DMAC12, 157),
-	INTC_IRQ(DMAC13, 160), INTC_IRQ(DMAC13, 161),
-	INTC_IRQ(DMAC14, 164), INTC_IRQ(DMAC14, 165),
-	INTC_IRQ(DMAC15, 168), INTC_IRQ(DMAC15, 169),
-
-	INTC_IRQ(USB, 170),
-
-	INTC_IRQ(VDC4, 171), INTC_IRQ(VDC4, 172),
-	INTC_IRQ(VDC4, 173), INTC_IRQ(VDC4, 174),
-	INTC_IRQ(VDC4, 175), INTC_IRQ(VDC4, 176),
-	INTC_IRQ(VDC4, 177), INTC_IRQ(VDC4, 177),
-
-	INTC_IRQ(CMT0, 188), INTC_IRQ(CMT1, 189),
-
-	INTC_IRQ(BSC, 190), INTC_IRQ(WDT, 191),
-
-	INTC_IRQ(MTU0_ABCD, 192), INTC_IRQ(MTU0_ABCD, 193),
-	INTC_IRQ(MTU0_ABCD, 194), INTC_IRQ(MTU0_ABCD, 195),
-	INTC_IRQ(MTU0_VEF, 196), INTC_IRQ(MTU0_VEF, 197),
-	INTC_IRQ(MTU0_VEF, 198),
-	INTC_IRQ(MTU1_AB, 199), INTC_IRQ(MTU1_AB, 200),
-	INTC_IRQ(MTU1_VU, 201), INTC_IRQ(MTU1_VU, 202),
-	INTC_IRQ(MTU2_AB, 203), INTC_IRQ(MTU2_AB, 204),
-	INTC_IRQ(MTU2_VU, 205), INTC_IRQ(MTU2_VU, 206),
-	INTC_IRQ(MTU3_ABCD, 207), INTC_IRQ(MTU3_ABCD, 208),
-	INTC_IRQ(MTU3_ABCD, 209), INTC_IRQ(MTU3_ABCD, 210),
-	INTC_IRQ(MTU3_TCI3V, 211),
-	INTC_IRQ(MTU4_ABCD, 212), INTC_IRQ(MTU4_ABCD, 213),
-	INTC_IRQ(MTU4_ABCD, 214), INTC_IRQ(MTU4_ABCD, 215),
-	INTC_IRQ(MTU4_TCI4V, 216),
-
-	INTC_IRQ(PWMT1, 217), INTC_IRQ(PWMT2, 218),
-
-	INTC_IRQ(ADC_ADI, 223),
-
-	INTC_IRQ(SSIF0, 224), INTC_IRQ(SSIF0, 225),
-	INTC_IRQ(SSIF0, 226),
-	INTC_IRQ(SSII1, 227), INTC_IRQ(SSII1, 228),
-	INTC_IRQ(SSII2, 229), INTC_IRQ(SSII2, 230),
-	INTC_IRQ(SSII3, 231), INTC_IRQ(SSII3, 232),
-	INTC_IRQ(SSII4, 233), INTC_IRQ(SSII4, 234),
-	INTC_IRQ(SSII5, 235), INTC_IRQ(SSII5, 236),
-
-	INTC_IRQ(RSPDIF, 237),
-
-	INTC_IRQ(IIC30, 238), INTC_IRQ(IIC30, 239),
-	INTC_IRQ(IIC30, 240), INTC_IRQ(IIC30, 241),
-	INTC_IRQ(IIC30, 242),
-	INTC_IRQ(IIC31, 243), INTC_IRQ(IIC31, 244),
-	INTC_IRQ(IIC31, 245), INTC_IRQ(IIC31, 246),
-	INTC_IRQ(IIC31, 247),
-	INTC_IRQ(IIC32, 248), INTC_IRQ(IIC32, 249),
-	INTC_IRQ(IIC32, 250), INTC_IRQ(IIC32, 251),
-	INTC_IRQ(IIC32, 252),
-	INTC_IRQ(IIC33, 253), INTC_IRQ(IIC33, 254),
-	INTC_IRQ(IIC33, 255), INTC_IRQ(IIC33, 256),
-	INTC_IRQ(IIC33, 257),
-
-	INTC_IRQ(SCIF0_BRI, 258), INTC_IRQ(SCIF0_ERI, 259),
-	INTC_IRQ(SCIF0_RXI, 260), INTC_IRQ(SCIF0_TXI, 261),
-	INTC_IRQ(SCIF1_BRI, 262), INTC_IRQ(SCIF1_ERI, 263),
-	INTC_IRQ(SCIF1_RXI, 264), INTC_IRQ(SCIF1_TXI, 265),
-	INTC_IRQ(SCIF2_BRI, 266), INTC_IRQ(SCIF2_ERI, 267),
-	INTC_IRQ(SCIF2_RXI, 268), INTC_IRQ(SCIF2_TXI, 269),
-	INTC_IRQ(SCIF3_BRI, 270), INTC_IRQ(SCIF3_ERI, 271),
-	INTC_IRQ(SCIF3_RXI, 272), INTC_IRQ(SCIF3_TXI, 273),
-	INTC_IRQ(SCIF4_BRI, 274), INTC_IRQ(SCIF4_ERI, 275),
-	INTC_IRQ(SCIF4_RXI, 276), INTC_IRQ(SCIF4_TXI, 277),
-	INTC_IRQ(SCIF5_BRI, 278), INTC_IRQ(SCIF5_ERI, 279),
-	INTC_IRQ(SCIF5_RXI, 280), INTC_IRQ(SCIF5_TXI, 281),
-	INTC_IRQ(SCIF6_BRI, 282), INTC_IRQ(SCIF6_ERI, 283),
-	INTC_IRQ(SCIF6_RXI, 284), INTC_IRQ(SCIF6_TXI, 285),
-	INTC_IRQ(SCIF7_BRI, 286), INTC_IRQ(SCIF7_ERI, 287),
-	INTC_IRQ(SCIF7_RXI, 288), INTC_IRQ(SCIF7_TXI, 289),
-
-	INTC_IRQ(RCAN0, 291), INTC_IRQ(RCAN0, 292),
-	INTC_IRQ(RCAN0, 293), INTC_IRQ(RCAN0, 294),
-	INTC_IRQ(RCAN0, 295),
-	INTC_IRQ(RCAN1, 296), INTC_IRQ(RCAN1, 297),
-	INTC_IRQ(RCAN1, 298), INTC_IRQ(RCAN1, 299),
-	INTC_IRQ(RCAN1, 300),
-	INTC_IRQ(RCAN2, 301), INTC_IRQ(RCAN2, 302),
-	INTC_IRQ(RCAN2, 303), INTC_IRQ(RCAN2, 304),
-	INTC_IRQ(RCAN2, 305),
-
-	INTC_IRQ(RSPIC0, 306), INTC_IRQ(RSPIC0, 307),
-	INTC_IRQ(RSPIC0, 308),
-	INTC_IRQ(RSPIC1, 309), INTC_IRQ(RSPIC1, 310),
-	INTC_IRQ(RSPIC1, 311),
-
-	INTC_IRQ(IEBC, 318),
-
-	INTC_IRQ(CD_ROMD, 319), INTC_IRQ(CD_ROMD, 320),
-	INTC_IRQ(CD_ROMD, 321), INTC_IRQ(CD_ROMD, 322),
-	INTC_IRQ(CD_ROMD, 323), INTC_IRQ(CD_ROMD, 324),
-
-	INTC_IRQ(NFMC, 325), INTC_IRQ(NFMC, 326),
-	INTC_IRQ(NFMC, 327), INTC_IRQ(NFMC, 328),
-
-	INTC_IRQ(SDHI0, 332), INTC_IRQ(SDHI0, 333),
-	INTC_IRQ(SDHI0, 334),
-	INTC_IRQ(SDHI1, 335), INTC_IRQ(SDHI1, 336),
-	INTC_IRQ(SDHI1, 337),
-
-	INTC_IRQ(RTC, 338), INTC_IRQ(RTC, 339),
-	INTC_IRQ(RTC, 340),
-
-	INTC_IRQ(SRCC0, 341), INTC_IRQ(SRCC0, 342),
-	INTC_IRQ(SRCC0, 343), INTC_IRQ(SRCC0, 344),
-	INTC_IRQ(SRCC0, 345),
-	INTC_IRQ(SRCC1, 346), INTC_IRQ(SRCC1, 347),
-	INTC_IRQ(SRCC1, 348), INTC_IRQ(SRCC1, 349),
-	INTC_IRQ(SRCC1, 350),
-	INTC_IRQ(SRCC2, 351), INTC_IRQ(SRCC2, 352),
-	INTC_IRQ(SRCC2, 353), INTC_IRQ(SRCC2, 354),
-	INTC_IRQ(SRCC2, 355),
-};
-
-static struct intc_group groups[] __initdata = {
-	INTC_GROUP(PINT, PINT0, PINT1, PINT2, PINT3,
-		   PINT4, PINT5, PINT6, PINT7),
-	INTC_GROUP(SCIF0, SCIF0_BRI, SCIF0_ERI, SCIF0_RXI, SCIF0_TXI),
-	INTC_GROUP(SCIF1, SCIF1_BRI, SCIF1_ERI, SCIF1_RXI, SCIF1_TXI),
-	INTC_GROUP(SCIF2, SCIF2_BRI, SCIF2_ERI, SCIF2_RXI, SCIF2_TXI),
-	INTC_GROUP(SCIF3, SCIF3_BRI, SCIF3_ERI, SCIF3_RXI, SCIF3_TXI),
-	INTC_GROUP(SCIF4, SCIF4_BRI, SCIF4_ERI, SCIF4_RXI, SCIF4_TXI),
-	INTC_GROUP(SCIF5, SCIF5_BRI, SCIF5_ERI, SCIF5_RXI, SCIF5_TXI),
-	INTC_GROUP(SCIF6, SCIF6_BRI, SCIF6_ERI, SCIF6_RXI, SCIF6_TXI),
-	INTC_GROUP(SCIF7, SCIF7_BRI, SCIF7_ERI, SCIF7_RXI, SCIF7_TXI),
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xfffe0818, 0, 16, 4, /* IPR01 */ { IRQ0, IRQ1, IRQ2, IRQ3 } },
-	{ 0xfffe081a, 0, 16, 4, /* IPR02 */ { IRQ4, IRQ5, IRQ6, IRQ7 } },
-	{ 0xfffe0820, 0, 16, 4, /* IPR05 */ { PINT, 0, 0, 0 } },
-	{ 0xfffe0c00, 0, 16, 4, /* IPR06 */ { DMAC0,  DMAC1, DMAC2,  DMAC3 } },
-	{ 0xfffe0c02, 0, 16, 4, /* IPR07 */ { DMAC4,  DMAC5, DMAC6,  DMAC7 } },
-	{ 0xfffe0c04, 0, 16, 4, /* IPR08 */ { DMAC8,  DMAC9,
-					      DMAC10, DMAC11 } },
-	{ 0xfffe0c06, 0, 16, 4, /* IPR09 */ { DMAC12, DMAC13,
-					      DMAC14, DMAC15 } },
-	{ 0xfffe0c08, 0, 16, 4, /* IPR10 */ { USB, VDC4, VDC4, VDC4 } },
-	{ 0xfffe0c0a, 0, 16, 4, /* IPR11 */ { 0, 0, 0, 0 } },
-	{ 0xfffe0c0c, 0, 16, 4, /* IPR12 */ { CMT0, CMT1, BSC, WDT } },
-	{ 0xfffe0c0e, 0, 16, 4, /* IPR13 */ { MTU0_ABCD, MTU0_VEF,
-					      MTU1_AB, MTU1_VU } },
-	{ 0xfffe0c10, 0, 16, 4, /* IPR14 */ { MTU2_AB, MTU2_VU,
-					      MTU3_ABCD, MTU3_TCI3V } },
-	{ 0xfffe0c12, 0, 16, 4, /* IPR15 */ { MTU4_ABCD, MTU4_TCI4V,
-					      PWMT1, PWMT2 } },
-	{ 0xfffe0c14, 0, 16, 4, /* IPR16 */ { 0, 0, 0, 0 } },
-	{ 0xfffe0c16, 0, 16, 4, /* IPR17 */ { ADC_ADI, SSIF0, SSII1, SSII2 } },
-	{ 0xfffe0c18, 0, 16, 4, /* IPR18 */ { SSII3, SSII4, SSII5,  RSPDIF} },
-	{ 0xfffe0c1a, 0, 16, 4, /* IPR19 */ { IIC30, IIC31, IIC32, IIC33 } },
-	{ 0xfffe0c1c, 0, 16, 4, /* IPR20 */ { SCIF0, SCIF1, SCIF2, SCIF3 } },
-	{ 0xfffe0c1e, 0, 16, 4, /* IPR21 */ { SCIF4, SCIF5, SCIF6, SCIF7 } },
-	{ 0xfffe0c20, 0, 16, 4, /* IPR22 */ { 0, RCAN0, RCAN1, RCAN2 } },
-	{ 0xfffe0c22, 0, 16, 4, /* IPR23 */ { RSPIC0, RSPIC1, 0, 0 } },
-	{ 0xfffe0c24, 0, 16, 4, /* IPR24 */ { IEBC, CD_ROMD, NFMC, 0 } },
-	{ 0xfffe0c26, 0, 16, 4, /* IPR25 */ { SDHI0, SDHI1, RTC, 0 } },
-	{ 0xfffe0c28, 0, 16, 4, /* IPR26 */ { SRCC0, SRCC1, SRCC2, 0 } },
-};
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xfffe0808, 0, 16, /* PINTER */
-	  { 0, 0, 0, 0, 0, 0, 0, 0,
-	    PINT7, PINT6, PINT5, PINT4, PINT3, PINT2, PINT1, PINT0 } },
-};
-
-static DECLARE_INTC_DESC(intc_desc, "sh7269", vectors, groups,
-			 mask_registers, prio_registers, NULL);
-
-static struct plat_sci_port scif0_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xe8007000, 0x100),
-	DEFINE_RES_IRQ(259),
-	DEFINE_RES_IRQ(260),
-	DEFINE_RES_IRQ(261),
-	DEFINE_RES_IRQ(258),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct plat_sci_port scif1_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif1_resources[] = {
-	DEFINE_RES_MEM(0xe8007800, 0x100),
-	DEFINE_RES_IRQ(263),
-	DEFINE_RES_IRQ(264),
-	DEFINE_RES_IRQ(265),
-	DEFINE_RES_IRQ(262),
-};
-
-static struct platform_device scif1_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif1_resources,
-	.num_resources	= ARRAY_SIZE(scif1_resources),
-	.dev		= {
-		.platform_data	= &scif1_platform_data,
-	},
-};
-
-static struct plat_sci_port scif2_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif2_resources[] = {
-	DEFINE_RES_MEM(0xe8008000, 0x100),
-	DEFINE_RES_IRQ(267),
-	DEFINE_RES_IRQ(268),
-	DEFINE_RES_IRQ(269),
-	DEFINE_RES_IRQ(266),
-};
-
-static struct platform_device scif2_device = {
-	.name		= "sh-sci",
-	.id		= 2,
-	.resource	= scif2_resources,
-	.num_resources	= ARRAY_SIZE(scif2_resources),
-	.dev		= {
-		.platform_data	= &scif2_platform_data,
-	},
-};
-
-static struct plat_sci_port scif3_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif3_resources[] = {
-	DEFINE_RES_MEM(0xe8008800, 0x100),
-	DEFINE_RES_IRQ(271),
-	DEFINE_RES_IRQ(272),
-	DEFINE_RES_IRQ(273),
-	DEFINE_RES_IRQ(270),
-};
-
-static struct platform_device scif3_device = {
-	.name		= "sh-sci",
-	.id		= 3,
-	.resource	= scif3_resources,
-	.num_resources	= ARRAY_SIZE(scif3_resources),
-	.dev		= {
-		.platform_data	= &scif3_platform_data,
-	},
-};
-
-static struct plat_sci_port scif4_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif4_resources[] = {
-	DEFINE_RES_MEM(0xe8009000, 0x100),
-	DEFINE_RES_IRQ(275),
-	DEFINE_RES_IRQ(276),
-	DEFINE_RES_IRQ(277),
-	DEFINE_RES_IRQ(274),
-};
-
-static struct platform_device scif4_device = {
-	.name		= "sh-sci",
-	.id		= 4,
-	.resource	= scif4_resources,
-	.num_resources	= ARRAY_SIZE(scif4_resources),
-	.dev		= {
-		.platform_data	= &scif4_platform_data,
-	},
-};
-
-static struct plat_sci_port scif5_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif5_resources[] = {
-	DEFINE_RES_MEM(0xe8009800, 0x100),
-	DEFINE_RES_IRQ(279),
-	DEFINE_RES_IRQ(280),
-	DEFINE_RES_IRQ(281),
-	DEFINE_RES_IRQ(278),
-};
-
-static struct platform_device scif5_device = {
-	.name		= "sh-sci",
-	.id		= 5,
-	.resource	= scif5_resources,
-	.num_resources	= ARRAY_SIZE(scif5_resources),
-	.dev		= {
-		.platform_data	= &scif5_platform_data,
-	},
-};
-
-static struct plat_sci_port scif6_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif6_resources[] = {
-	DEFINE_RES_MEM(0xe800a000, 0x100),
-	DEFINE_RES_IRQ(283),
-	DEFINE_RES_IRQ(284),
-	DEFINE_RES_IRQ(285),
-	DEFINE_RES_IRQ(282),
-};
-
-static struct platform_device scif6_device = {
-	.name		= "sh-sci",
-	.id		= 6,
-	.resource	= scif6_resources,
-	.num_resources	= ARRAY_SIZE(scif6_resources),
-	.dev		= {
-		.platform_data	= &scif6_platform_data,
-	},
-};
-
-static struct plat_sci_port scif7_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH2_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif7_resources[] = {
-	DEFINE_RES_MEM(0xe800a800, 0x100),
-	DEFINE_RES_IRQ(287),
-	DEFINE_RES_IRQ(288),
-	DEFINE_RES_IRQ(289),
-	DEFINE_RES_IRQ(286),
-};
-
-static struct platform_device scif7_device = {
-	.name		= "sh-sci",
-	.id		= 7,
-	.resource	= scif7_resources,
-	.num_resources	= ARRAY_SIZE(scif7_resources),
-	.dev		= {
-		.platform_data	= &scif7_platform_data,
-	},
-};
-
-static struct sh_timer_config cmt_platform_data = {
-	.channels_mask = 3,
-};
-
-static struct resource cmt_resources[] = {
-	DEFINE_RES_MEM(0xfffec000, 0x10),
-	DEFINE_RES_IRQ(188),
-	DEFINE_RES_IRQ(189),
-};
-
-static struct platform_device cmt_device = {
-	.name		= "sh-cmt-16",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &cmt_platform_data,
-	},
-	.resource	= cmt_resources,
-	.num_resources	= ARRAY_SIZE(cmt_resources),
-};
-
-static struct resource mtu2_resources[] = {
-	DEFINE_RES_MEM(0xfffe4000, 0x400),
-	DEFINE_RES_IRQ_NAMED(192, "tgi0a"),
-	DEFINE_RES_IRQ_NAMED(203, "tgi1a"),
-};
-
-static struct platform_device mtu2_device = {
-	.name		= "sh-mtu2",
-	.id		= -1,
-	.resource	= mtu2_resources,
-	.num_resources	= ARRAY_SIZE(mtu2_resources),
-};
-
-static struct resource rtc_resources[] = {
-	[0] = {
-		.start	= 0xfffe6000,
-		.end	= 0xfffe6000 + 0x30 - 1,
-		.flags	= IORESOURCE_IO,
-	},
-	[1] = {
-		/* Shared Period/Carry/Alarm IRQ */
-		.start	= 338,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device rtc_device = {
-	.name		= "sh-rtc",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(rtc_resources),
-	.resource	= rtc_resources,
-};
-
-/* USB Host */
-static struct r8a66597_platdata r8a66597_data = {
-	.on_chip = 1,
-	.endian = 1,
-};
-
-static struct resource r8a66597_usb_host_resources[] = {
-	[0] = {
-		.start	= 0xe8010000,
-		.end	= 0xe80100e4,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= 170,
-		.end	= 170,
-		.flags	= IORESOURCE_IRQ | IRQF_TRIGGER_LOW,
-	},
-};
-
-static struct platform_device r8a66597_usb_host_device = {
-	.name		= "r8a66597_hcd",
-	.id		= 0,
-	.dev = {
-		.dma_mask		= NULL,         /*  not use dma */
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &r8a66597_data,
-	},
-	.num_resources	= ARRAY_SIZE(r8a66597_usb_host_resources),
-	.resource	= r8a66597_usb_host_resources,
-};
-
-static struct platform_device *sh7269_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&scif4_device,
-	&scif5_device,
-	&scif6_device,
-	&scif7_device,
-	&cmt_device,
-	&mtu2_device,
-	&rtc_device,
-	&r8a66597_usb_host_device,
-};
-
-static int __init sh7269_devices_setup(void)
-{
-	return platform_add_devices(sh7269_devices,
-				    ARRAY_SIZE(sh7269_devices));
-}
-arch_initcall(sh7269_devices_setup);
-
-void __init plat_irq_setup(void)
-{
-	register_intc_controller(&intc_desc);
-}
-
-static struct platform_device *sh7269_early_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&scif4_device,
-	&scif5_device,
-	&scif6_device,
-	&scif7_device,
-	&cmt_device,
-	&mtu2_device,
-};
-
-void __init plat_early_device_setup(void)
-{
-	sh_early_platform_add_devices(sh7269_early_devices,
-				   ARRAY_SIZE(sh7269_early_devices));
-}
diff --git a/arch/sh/kernel/cpu/sh3/Makefile b/arch/sh/kernel/cpu/sh3/Makefile
deleted file mode 100644
index 1dcb43d93c8632..00000000000000
--- a/arch/sh/kernel/cpu/sh3/Makefile
+++ /dev/null
@@ -1,34 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the Linux/SuperH SH-3 backends.
-#
-
-obj-y	:= ex.o probe.o entry.o setup-sh3.o
-
-obj-$(CONFIG_HIBERNATION)		+= swsusp.o
-
-# CPU subtype setup
-obj-$(CONFIG_CPU_SUBTYPE_SH7705)	+= setup-sh7705.o serial-sh770x.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7706)	+= setup-sh770x.o serial-sh770x.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7707)	+= setup-sh770x.o serial-sh770x.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7708)	+= setup-sh770x.o serial-sh770x.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7709)	+= setup-sh770x.o serial-sh770x.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7710)	+= setup-sh7710.o serial-sh7710.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7712)	+= setup-sh7710.o serial-sh7710.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7720)	+= setup-sh7720.o serial-sh7720.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7721)	+= setup-sh7720.o serial-sh7720.o
-
-# Primary on-chip clocks (common)
-clock-$(CONFIG_CPU_SH3)			:= clock-sh3.o
-clock-$(CONFIG_CPU_SUBTYPE_SH7705)	:= clock-sh7705.o
-clock-$(CONFIG_CPU_SUBTYPE_SH7706)	:= clock-sh7706.o
-clock-$(CONFIG_CPU_SUBTYPE_SH7709)	:= clock-sh7709.o
-clock-$(CONFIG_CPU_SUBTYPE_SH7710)	:= clock-sh7710.o
-clock-$(CONFIG_CPU_SUBTYPE_SH7720)	:= clock-sh7710.o
-clock-$(CONFIG_CPU_SUBTYPE_SH7712)	:= clock-sh7712.o
-
-# Pinmux setup
-pinmux-$(CONFIG_CPU_SUBTYPE_SH7720)	:= pinmux-sh7720.o
-
-obj-y	+= $(clock-y)
-obj-$(CONFIG_GPIOLIB)			+= $(pinmux-y)
diff --git a/arch/sh/kernel/cpu/sh3/clock-sh3.c b/arch/sh/kernel/cpu/sh3/clock-sh3.c
deleted file mode 100644
index d7765728cadf5a..00000000000000
--- a/arch/sh/kernel/cpu/sh3/clock-sh3.c
+++ /dev/null
@@ -1,86 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh3/clock-sh3.c
- *
- * Generic SH-3 support for the clock framework
- *
- *  Copyright (C) 2005  Paul Mundt
- *
- * FRQCR parsing hacked out of arch/sh/kernel/time.c
- *
- *  Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
- *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
- *  Copyright (C) 2002, 2003, 2004  Paul Mundt
- *  Copyright (C) 2002  M. R. Brown  <mrbrown@linux-sh.org>
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <asm/clock.h>
-#include <asm/freq.h>
-#include <asm/io.h>
-
-static int stc_multipliers[] = { 1, 2, 3, 4, 6, 1, 1, 1 };
-static int ifc_divisors[]    = { 1, 2, 3, 4, 1, 1, 1, 1 };
-static int pfc_divisors[]    = { 1, 2, 3, 4, 6, 1, 1, 1 };
-
-static void master_clk_init(struct clk *clk)
-{
-	int frqcr = __raw_readw(FRQCR);
-	int idx = ((frqcr & 0x2000) >> 11) | (frqcr & 0x0003);
-
-	clk->rate *= pfc_divisors[idx];
-}
-
-static struct sh_clk_ops sh3_master_clk_ops = {
-	.init		= master_clk_init,
-};
-
-static unsigned long module_clk_recalc(struct clk *clk)
-{
-	int frqcr = __raw_readw(FRQCR);
-	int idx = ((frqcr & 0x2000) >> 11) | (frqcr & 0x0003);
-
-	return clk->parent->rate / pfc_divisors[idx];
-}
-
-static struct sh_clk_ops sh3_module_clk_ops = {
-	.recalc		= module_clk_recalc,
-};
-
-static unsigned long bus_clk_recalc(struct clk *clk)
-{
-	int frqcr = __raw_readw(FRQCR);
-	int idx = ((frqcr & 0x8000) >> 13) | ((frqcr & 0x0030) >> 4);
-
-	return clk->parent->rate / stc_multipliers[idx];
-}
-
-static struct sh_clk_ops sh3_bus_clk_ops = {
-	.recalc		= bus_clk_recalc,
-};
-
-static unsigned long cpu_clk_recalc(struct clk *clk)
-{
-	int frqcr = __raw_readw(FRQCR);
-	int idx = ((frqcr & 0x4000) >> 12) | ((frqcr & 0x000c) >> 2);
-
-	return clk->parent->rate / ifc_divisors[idx];
-}
-
-static struct sh_clk_ops sh3_cpu_clk_ops = {
-	.recalc		= cpu_clk_recalc,
-};
-
-static struct sh_clk_ops *sh3_clk_ops[] = {
-	&sh3_master_clk_ops,
-	&sh3_module_clk_ops,
-	&sh3_bus_clk_ops,
-	&sh3_cpu_clk_ops,
-};
-
-void __init arch_init_clk_ops(struct sh_clk_ops **ops, int idx)
-{
-	if (idx < ARRAY_SIZE(sh3_clk_ops))
-		*ops = sh3_clk_ops[idx];
-}
-
diff --git a/arch/sh/kernel/cpu/sh3/clock-sh7705.c b/arch/sh/kernel/cpu/sh3/clock-sh7705.c
deleted file mode 100644
index 4947114af0901b..00000000000000
--- a/arch/sh/kernel/cpu/sh3/clock-sh7705.c
+++ /dev/null
@@ -1,81 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh3/clock-sh7705.c
- *
- * SH7705 support for the clock framework
- *
- *  Copyright (C) 2005  Paul Mundt
- *
- * FRQCR parsing hacked out of arch/sh/kernel/time.c
- *
- *  Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
- *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
- *  Copyright (C) 2002, 2003, 2004  Paul Mundt
- *  Copyright (C) 2002  M. R. Brown  <mrbrown@linux-sh.org>
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <asm/clock.h>
-#include <asm/freq.h>
-#include <asm/io.h>
-
-/*
- * SH7705 uses the same divisors as the generic SH-3 case, it's just the
- * FRQCR layout that is a bit different..
- */
-static int stc_multipliers[] = { 1, 2, 3, 4, 6, 1, 1, 1 };
-static int ifc_divisors[]    = { 1, 2, 3, 4, 1, 1, 1, 1 };
-static int pfc_divisors[]    = { 1, 2, 3, 4, 6, 1, 1, 1 };
-
-static void master_clk_init(struct clk *clk)
-{
-	clk->rate *= pfc_divisors[__raw_readw(FRQCR) & 0x0003];
-}
-
-static struct sh_clk_ops sh7705_master_clk_ops = {
-	.init		= master_clk_init,
-};
-
-static unsigned long module_clk_recalc(struct clk *clk)
-{
-	int idx = __raw_readw(FRQCR) & 0x0003;
-	return clk->parent->rate / pfc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7705_module_clk_ops = {
-	.recalc		= module_clk_recalc,
-};
-
-static unsigned long bus_clk_recalc(struct clk *clk)
-{
-	int idx = (__raw_readw(FRQCR) & 0x0300) >> 8;
-	return clk->parent->rate / stc_multipliers[idx];
-}
-
-static struct sh_clk_ops sh7705_bus_clk_ops = {
-	.recalc		= bus_clk_recalc,
-};
-
-static unsigned long cpu_clk_recalc(struct clk *clk)
-{
-	int idx = (__raw_readw(FRQCR) & 0x0030) >> 4;
-	return clk->parent->rate / ifc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7705_cpu_clk_ops = {
-	.recalc		= cpu_clk_recalc,
-};
-
-static struct sh_clk_ops *sh7705_clk_ops[] = {
-	&sh7705_master_clk_ops,
-	&sh7705_module_clk_ops,
-	&sh7705_bus_clk_ops,
-	&sh7705_cpu_clk_ops,
-};
-
-void __init arch_init_clk_ops(struct sh_clk_ops **ops, int idx)
-{
-	if (idx < ARRAY_SIZE(sh7705_clk_ops))
-		*ops = sh7705_clk_ops[idx];
-}
-
diff --git a/arch/sh/kernel/cpu/sh3/clock-sh7706.c b/arch/sh/kernel/cpu/sh3/clock-sh7706.c
deleted file mode 100644
index 17855022c118f5..00000000000000
--- a/arch/sh/kernel/cpu/sh3/clock-sh7706.c
+++ /dev/null
@@ -1,81 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh3/clock-sh7706.c
- *
- * SH7706 support for the clock framework
- *
- *  Copyright (C) 2006  Takashi YOSHII
- *
- * Based on arch/sh/kernel/cpu/sh3/clock-sh7709.c
- *  Copyright (C) 2005  Andriy Skulysh
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <asm/clock.h>
-#include <asm/freq.h>
-#include <asm/io.h>
-
-static int stc_multipliers[] = { 1, 2, 4, 1, 3, 6, 1, 1 };
-static int ifc_divisors[]    = { 1, 2, 4, 1, 3, 1, 1, 1 };
-static int pfc_divisors[]    = { 1, 2, 4, 1, 3, 6, 1, 1 };
-
-static void master_clk_init(struct clk *clk)
-{
-	int frqcr = __raw_readw(FRQCR);
-	int idx = ((frqcr & 0x2000) >> 11) | (frqcr & 0x0003);
-
-	clk->rate *= pfc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7706_master_clk_ops = {
-	.init		= master_clk_init,
-};
-
-static unsigned long module_clk_recalc(struct clk *clk)
-{
-	int frqcr = __raw_readw(FRQCR);
-	int idx = ((frqcr & 0x2000) >> 11) | (frqcr & 0x0003);
-
-	return clk->parent->rate / pfc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7706_module_clk_ops = {
-	.recalc		= module_clk_recalc,
-};
-
-static unsigned long bus_clk_recalc(struct clk *clk)
-{
-	int frqcr = __raw_readw(FRQCR);
-	int idx = ((frqcr & 0x8000) >> 13) | ((frqcr & 0x0030) >> 4);
-
-	return clk->parent->rate / stc_multipliers[idx];
-}
-
-static struct sh_clk_ops sh7706_bus_clk_ops = {
-	.recalc		= bus_clk_recalc,
-};
-
-static unsigned long cpu_clk_recalc(struct clk *clk)
-{
-	int frqcr = __raw_readw(FRQCR);
-	int idx = ((frqcr & 0x4000) >> 12) | ((frqcr & 0x000c) >> 2);
-
-	return clk->parent->rate / ifc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7706_cpu_clk_ops = {
-	.recalc		= cpu_clk_recalc,
-};
-
-static struct sh_clk_ops *sh7706_clk_ops[] = {
-	&sh7706_master_clk_ops,
-	&sh7706_module_clk_ops,
-	&sh7706_bus_clk_ops,
-	&sh7706_cpu_clk_ops,
-};
-
-void __init arch_init_clk_ops(struct sh_clk_ops **ops, int idx)
-{
-	if (idx < ARRAY_SIZE(sh7706_clk_ops))
-		*ops = sh7706_clk_ops[idx];
-}
diff --git a/arch/sh/kernel/cpu/sh3/clock-sh7709.c b/arch/sh/kernel/cpu/sh3/clock-sh7709.c
deleted file mode 100644
index 54701bbf7caae7..00000000000000
--- a/arch/sh/kernel/cpu/sh3/clock-sh7709.c
+++ /dev/null
@@ -1,82 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh3/clock-sh7709.c
- *
- * SH7709 support for the clock framework
- *
- *  Copyright (C) 2005  Andriy Skulysh
- *
- * Based on arch/sh/kernel/cpu/sh3/clock-sh7705.c
- *  Copyright (C) 2005  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <asm/clock.h>
-#include <asm/freq.h>
-#include <asm/io.h>
-
-static int stc_multipliers[] = { 1, 2, 4, 8, 3, 6, 1, 1 };
-static int ifc_divisors[]    = { 1, 2, 4, 1, 3, 1, 1, 1 };
-static int pfc_divisors[]    = { 1, 2, 4, 1, 3, 6, 1, 1 };
-
-static void master_clk_init(struct clk *clk)
-{
-	int frqcr = __raw_readw(FRQCR);
-	int idx = ((frqcr & 0x2000) >> 11) | (frqcr & 0x0003);
-
-	clk->rate *= pfc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7709_master_clk_ops = {
-	.init		= master_clk_init,
-};
-
-static unsigned long module_clk_recalc(struct clk *clk)
-{
-	int frqcr = __raw_readw(FRQCR);
-	int idx = ((frqcr & 0x2000) >> 11) | (frqcr & 0x0003);
-
-	return clk->parent->rate / pfc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7709_module_clk_ops = {
-	.recalc		= module_clk_recalc,
-};
-
-static unsigned long bus_clk_recalc(struct clk *clk)
-{
-	int frqcr = __raw_readw(FRQCR);
-	int idx = (frqcr & 0x0080) ?
-		((frqcr & 0x8000) >> 13) | ((frqcr & 0x0030) >> 4) : 1;
-
-	return clk->parent->rate * stc_multipliers[idx];
-}
-
-static struct sh_clk_ops sh7709_bus_clk_ops = {
-	.recalc		= bus_clk_recalc,
-};
-
-static unsigned long cpu_clk_recalc(struct clk *clk)
-{
-	int frqcr = __raw_readw(FRQCR);
-	int idx = ((frqcr & 0x4000) >> 12) | ((frqcr & 0x000c) >> 2);
-
-	return clk->parent->rate / ifc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7709_cpu_clk_ops = {
-	.recalc		= cpu_clk_recalc,
-};
-
-static struct sh_clk_ops *sh7709_clk_ops[] = {
-	&sh7709_master_clk_ops,
-	&sh7709_module_clk_ops,
-	&sh7709_bus_clk_ops,
-	&sh7709_cpu_clk_ops,
-};
-
-void __init arch_init_clk_ops(struct sh_clk_ops **ops, int idx)
-{
-	if (idx < ARRAY_SIZE(sh7709_clk_ops))
-		*ops = sh7709_clk_ops[idx];
-}
diff --git a/arch/sh/kernel/cpu/sh3/clock-sh7710.c b/arch/sh/kernel/cpu/sh3/clock-sh7710.c
deleted file mode 100644
index e60d0bc19cbe96..00000000000000
--- a/arch/sh/kernel/cpu/sh3/clock-sh7710.c
+++ /dev/null
@@ -1,75 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh3/clock-sh7710.c
- *
- * SH7710 support for the clock framework
- *
- *  Copyright (C) 2005  Paul Mundt
- *
- * FRQCR parsing hacked out of arch/sh/kernel/time.c
- *
- *  Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
- *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
- *  Copyright (C) 2002, 2003, 2004  Paul Mundt
- *  Copyright (C) 2002  M. R. Brown  <mrbrown@linux-sh.org>
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <asm/clock.h>
-#include <asm/freq.h>
-#include <asm/io.h>
-
-static int md_table[] = { 1, 2, 3, 4, 6, 8, 12 };
-
-static void master_clk_init(struct clk *clk)
-{
-	clk->rate *= md_table[__raw_readw(FRQCR) & 0x0007];
-}
-
-static struct sh_clk_ops sh7710_master_clk_ops = {
-	.init		= master_clk_init,
-};
-
-static unsigned long module_clk_recalc(struct clk *clk)
-{
-	int idx = (__raw_readw(FRQCR) & 0x0007);
-	return clk->parent->rate / md_table[idx];
-}
-
-static struct sh_clk_ops sh7710_module_clk_ops = {
-	.recalc		= module_clk_recalc,
-};
-
-static unsigned long bus_clk_recalc(struct clk *clk)
-{
-	int idx = (__raw_readw(FRQCR) & 0x0700) >> 8;
-	return clk->parent->rate / md_table[idx];
-}
-
-static struct sh_clk_ops sh7710_bus_clk_ops = {
-	.recalc		= bus_clk_recalc,
-};
-
-static unsigned long cpu_clk_recalc(struct clk *clk)
-{
-	int idx = (__raw_readw(FRQCR) & 0x0070) >> 4;
-	return clk->parent->rate / md_table[idx];
-}
-
-static struct sh_clk_ops sh7710_cpu_clk_ops = {
-	.recalc		= cpu_clk_recalc,
-};
-
-static struct sh_clk_ops *sh7710_clk_ops[] = {
-	&sh7710_master_clk_ops,
-	&sh7710_module_clk_ops,
-	&sh7710_bus_clk_ops,
-	&sh7710_cpu_clk_ops,
-};
-
-void __init arch_init_clk_ops(struct sh_clk_ops **ops, int idx)
-{
-	if (idx < ARRAY_SIZE(sh7710_clk_ops))
-		*ops = sh7710_clk_ops[idx];
-}
-
diff --git a/arch/sh/kernel/cpu/sh3/clock-sh7712.c b/arch/sh/kernel/cpu/sh3/clock-sh7712.c
deleted file mode 100644
index 5af553f38d3a59..00000000000000
--- a/arch/sh/kernel/cpu/sh3/clock-sh7712.c
+++ /dev/null
@@ -1,68 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh3/clock-sh7712.c
- *
- * SH7712 support for the clock framework
- *
- *  Copyright (C) 2007  Andrew Murray <amurray@mpc-data.co.uk>
- *
- * Based on arch/sh/kernel/cpu/sh3/clock-sh3.c
- *  Copyright (C) 2005  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <asm/clock.h>
-#include <asm/freq.h>
-#include <asm/io.h>
-
-static int multipliers[] = { 1, 2, 3 };
-static int divisors[]    = { 1, 2, 3, 4, 6 };
-
-static void master_clk_init(struct clk *clk)
-{
-	int frqcr = __raw_readw(FRQCR);
-	int idx = (frqcr & 0x0300) >> 8;
-
-	clk->rate *= multipliers[idx];
-}
-
-static struct sh_clk_ops sh7712_master_clk_ops = {
-	.init		= master_clk_init,
-};
-
-static unsigned long module_clk_recalc(struct clk *clk)
-{
-	int frqcr = __raw_readw(FRQCR);
-	int idx = frqcr & 0x0007;
-
-	return clk->parent->rate / divisors[idx];
-}
-
-static struct sh_clk_ops sh7712_module_clk_ops = {
-	.recalc		= module_clk_recalc,
-};
-
-static unsigned long cpu_clk_recalc(struct clk *clk)
-{
-	int frqcr = __raw_readw(FRQCR);
-	int idx = (frqcr & 0x0030) >> 4;
-
-	return clk->parent->rate / divisors[idx];
-}
-
-static struct sh_clk_ops sh7712_cpu_clk_ops = {
-	.recalc		= cpu_clk_recalc,
-};
-
-static struct sh_clk_ops *sh7712_clk_ops[] = {
-	&sh7712_master_clk_ops,
-	&sh7712_module_clk_ops,
-	&sh7712_cpu_clk_ops,
-};
-
-void __init arch_init_clk_ops(struct sh_clk_ops **ops, int idx)
-{
-	if (idx < ARRAY_SIZE(sh7712_clk_ops))
-		*ops = sh7712_clk_ops[idx];
-}
-
diff --git a/arch/sh/kernel/cpu/sh3/entry.S b/arch/sh/kernel/cpu/sh3/entry.S
deleted file mode 100644
index e48b3dd996f58d..00000000000000
--- a/arch/sh/kernel/cpu/sh3/entry.S
+++ /dev/null
@@ -1,509 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * arch/sh/kernel/cpu/sh3/entry.S
- *
- *  Copyright (C) 1999, 2000, 2002  Niibe Yutaka
- *  Copyright (C) 2003 - 2012  Paul Mundt
- */
-#include <linux/sys.h>
-#include <linux/errno.h>
-#include <linux/linkage.h>
-#include <asm/asm-offsets.h>
-#include <asm/thread_info.h>
-#include <asm/unistd.h>
-#include <cpu/mmu_context.h>
-#include <asm/page.h>
-#include <asm/cache.h>
-
-! NOTE:
-! GNU as (as of 2.9.1) changes bf/s into bt/s and bra, when the address
-! to be jumped is too far, but it causes illegal slot exception.
-
-/*	
- * entry.S contains the system-call and fault low-level handling routines.
- * This also contains the timer-interrupt handler, as well as all interrupts
- * and faults that can result in a task-switch.
- *
- * NOTE: This code handles signal-recognition, which happens every time
- * after a timer-interrupt and after each system call.
- *
- * NOTE: This code uses a convention that instructions in the delay slot
- * of a transfer-control instruction are indented by an extra space, thus:
- *
- *    jmp	@k0	    ! control-transfer instruction
- *     ldc	k1, ssr     ! delay slot
- *
- * Stack layout in 'ret_from_syscall':
- * 	ptrace needs to have all regs on the stack.
- *	if the order here is changed, it needs to be
- *	updated in ptrace.c and ptrace.h
- *
- *	r0
- *      ...
- *	r15 = stack pointer
- *	spc
- *	pr
- *	ssr
- *	gbr
- *	mach
- *	macl
- *	syscall #
- *
- */
-/* Offsets to the stack */
-OFF_R0  =  0		/* Return value. New ABI also arg4 */
-OFF_R1  =  4     	/* New ABI: arg5 */
-OFF_R2  =  8     	/* New ABI: arg6 */
-OFF_R3  =  12     	/* New ABI: syscall_nr */
-OFF_R4  =  16     	/* New ABI: arg0 */
-OFF_R5  =  20     	/* New ABI: arg1 */
-OFF_R6  =  24     	/* New ABI: arg2 */
-OFF_R7  =  28     	/* New ABI: arg3 */
-OFF_SP	=  (15*4)
-OFF_PC  =  (16*4)
-OFF_SR	=  (16*4+8)
-OFF_TRA	=  (16*4+6*4)
-
-#define k0	r0
-#define k1	r1
-#define k2	r2
-#define k3	r3
-#define k4	r4
-
-#define g_imask		r6	/* r6_bank1 */
-#define k_g_imask	r6_bank	/* r6_bank1 */
-#define current		r7	/* r7_bank1 */
-
-#include <asm/entry-macros.S>
-	
-/*
- * Kernel mode register usage:
- *	k0	scratch
- *	k1	scratch
- *	k2	scratch (Exception code)
- *	k3	scratch (Return address)
- *	k4	scratch
- *	k5	reserved
- *	k6	Global Interrupt Mask (0--15 << 4)
- *	k7	CURRENT_THREAD_INFO (pointer to current thread info)
- */
-
-!
-! TLB Miss / Initial Page write exception handling
-!			_and_
-! TLB hits, but the access violate the protection.
-! It can be valid access, such as stack grow and/or C-O-W.
-!
-!
-! Find the pmd/pte entry and loadtlb
-! If it's not found, cause address error (SEGV)
-!
-! Although this could be written in assembly language (and it'd be faster),
-! this first version depends *much* on C implementation.
-!
-
-#if defined(CONFIG_MMU)
-	.align	2
-ENTRY(tlb_miss_load)
-	bra	call_handle_tlbmiss
-	 mov	#0, r5
-
-	.align	2
-ENTRY(tlb_miss_store)
-	bra	call_handle_tlbmiss
-	 mov	#FAULT_CODE_WRITE, r5
-
-	.align	2
-ENTRY(initial_page_write)
-	bra	call_handle_tlbmiss
-	 mov	#FAULT_CODE_INITIAL, r5
-
-	.align	2
-ENTRY(tlb_protection_violation_load)
-	bra	call_do_page_fault
-	 mov	#FAULT_CODE_PROT, r5
-
-	.align	2
-ENTRY(tlb_protection_violation_store)
-	bra	call_do_page_fault
-	 mov	#(FAULT_CODE_PROT | FAULT_CODE_WRITE), r5
-
-call_handle_tlbmiss:
-	mov.l	1f, r0
-	mov	r5, r8
-	mov.l	@r0, r6
-	mov.l	2f, r0
-	sts	pr, r10
-	jsr	@r0
-	 mov	r15, r4
-	!
-	tst	r0, r0
-	bf/s	0f
-	 lds	r10, pr
-	rts
-	 nop
-0:
-	mov	r8, r5
-call_do_page_fault:
-	mov.l	1f, r0
-	mov.l	@r0, r6
-
-	mov.l	3f, r0
-	mov.l	4f, r1
-	mov	r15, r4
-	jmp	@r0
-	 lds	r1, pr
-
-	.align 2
-1:	.long	MMU_TEA
-2:	.long	handle_tlbmiss
-3:	.long	do_page_fault
-4:	.long	ret_from_exception
-
-	.align	2
-ENTRY(address_error_load)
-	bra	call_dae
-	 mov	#0,r5		! writeaccess = 0
-
-	.align	2
-ENTRY(address_error_store)
-	bra	call_dae
-	 mov	#1,r5		! writeaccess = 1
-
-	.align	2
-call_dae:
-	mov.l	1f, r0
-	mov.l	@r0, r6		! address
-	mov.l	2f, r0
-	jmp	@r0
-	 mov	r15, r4		! regs
-
-	.align 2
-1:	.long	MMU_TEA
-2:	.long   do_address_error
-#endif /* CONFIG_MMU */
-
-#if defined(CONFIG_SH_STANDARD_BIOS)
-	/* Unwind the stack and jmp to the debug entry */
-ENTRY(sh_bios_handler)
-	mov.l	1f, r8
-	bsr	restore_regs
-	 nop
-
-	lds	k2, pr			! restore pr
-	mov	k4, r15
-	!
-	mov.l	2f, k0
-	mov.l	@k0, k0
-	jmp	@k0
-	 ldc	k3, ssr
-	.align	2
-1:	.long	0x300000f0
-2:	.long	gdb_vbr_vector
-#endif /* CONFIG_SH_STANDARD_BIOS */
-
-! restore_regs()
-! - restore r0, r1, r2, r3, r4, r5, r6, r7 from the stack
-! - switch bank
-! - restore r8, r9, r10, r11, r12, r13, r14, r15 from the stack
-! - restore spc, pr*, ssr, gbr, mach, macl, skip default tra
-! k2 returns original pr
-! k3 returns original sr
-! k4 returns original stack pointer
-! r8 passes SR bitmask, overwritten with restored data on return
-! r9 trashed
-! BL=0 on entry, on exit BL=1 (depending on r8).
-
-ENTRY(restore_regs)
-	mov.l	@r15+, r0
-	mov.l	@r15+, r1
-	mov.l	@r15+, r2
-	mov.l	@r15+, r3
-	mov.l	@r15+, r4
-	mov.l	@r15+, r5
-	mov.l	@r15+, r6
-	mov.l	@r15+, r7
-	!
-	stc	sr, r9
-	or	r8, r9
-	ldc	r9, sr
-	!
-	mov.l	@r15+, r8
-	mov.l	@r15+, r9
-	mov.l	@r15+, r10
-	mov.l	@r15+, r11
-	mov.l	@r15+, r12
-	mov.l	@r15+, r13
-	mov.l	@r15+, r14
-	mov.l	@r15+, k4		! original stack pointer
-	ldc.l	@r15+, spc
-	mov.l	@r15+, k2		! original PR
-	mov.l	@r15+, k3		! original SR
-	ldc.l	@r15+, gbr
-	lds.l	@r15+, mach
-	lds.l	@r15+, macl
-	rts
-	 add	#4, r15			! Skip syscall number
-
-restore_all:
-	mov.l	7f, r8
-	bsr	restore_regs
-	 nop
-
-	lds	k2, pr			! restore pr
-	!
-	! Calculate new SR value
-	mov	k3, k2			! original SR value
-	mov	#0xfffffff0, k1
-	extu.b	k1, k1
-	not	k1, k1
-	and	k1, k2			! Mask original SR value
-	!
-	mov	k3, k0			! Calculate IMASK-bits
-	shlr2	k0
-	and	#0x3c, k0
-	cmp/eq	#0x3c, k0
-	bt/s	6f
-	 shll2	k0
-	mov	g_imask, k0
-	!
-6:	or	k0, k2			! Set the IMASK-bits
-	ldc	k2, ssr
-	!
-	mov	k4, r15
-	rte
-	 nop
-
-	.align	2
-5:	.long	0x00001000	! DSP
-7:	.long	0x30000000
-
-! common exception handler
-#include "../../entry-common.S"
-	
-! Exception Vector Base
-!
-!	Should be aligned page boundary.
-!
-	.balign 	4096,0,4096
-ENTRY(vbr_base)
-	.long	0
-!
-! 0x100: General exception vector
-!
-	.balign 	256,0,256
-general_exception:
-	bra	handle_exception
-	 sts	pr, k3		! save original pr value in k3
-
-! prepare_stack()
-! - roll back gRB
-! - switch to kernel stack
-! k0 returns original sp (after roll back)
-! k1 trashed
-! k2 trashed
-
-prepare_stack:
-#ifdef CONFIG_GUSA
-	! Check for roll back gRB (User and Kernel)
-	mov	r15, k0
-	shll	k0
-	bf/s	1f
-	 shll	k0
-	bf/s	1f
-	 stc	spc, k1
-	stc	r0_bank, k0
-	cmp/hs	k0, k1		! test k1 (saved PC) >= k0 (saved r0)
-	bt/s	2f
-	 stc	r1_bank, k1
-
-	add	#-2, k0
-	add	r15, k0
-	ldc	k0, spc		! PC = saved r0 + r15 - 2
-2:	mov	k1, r15		! SP = r1
-1:
-#endif
-	! Switch to kernel stack if needed
-	stc	ssr, k0		! Is it from kernel space?
-	shll	k0		! Check MD bit (bit30) by shifting it into...
-	shll	k0		!       ...the T bit
-	bt/s	1f		! It's a kernel to kernel transition.
-	 mov	r15, k0		! save original stack to k0
-	/* User space to kernel */
-	mov	#(THREAD_SIZE >> 10), k1
-	shll8	k1		! k1 := THREAD_SIZE
-	shll2	k1
-	add	current, k1
-	mov	k1, r15		! change to kernel stack
-	!
-1:
-	rts
-	 nop
-
-!
-! 0x400: Instruction and Data TLB miss exception vector
-!
-	.balign 	1024,0,1024
-tlb_miss:
-	sts	pr, k3		! save original pr value in k3
-
-handle_exception:
-	mova	exception_data, k0
-
-	! Setup stack and save DSP context (k0 contains original r15 on return)
-	bsr	prepare_stack
-	 PREF(k0)
-
-	! Save registers / Switch to bank 0
-	mov.l	5f, k2		! vector register address
-	mov.l	1f, k4		! SR bits to clear in k4
-	bsr	save_regs	! needs original pr value in k3
-	 mov.l	@k2, k2		! read out vector and keep in k2
-
-handle_exception_special:
-	setup_frame_reg
-
-	! Setup return address and jump to exception handler
-	mov.l	7f, r9		! fetch return address
-	stc	r2_bank, r0	! k2 (vector)
-	mov.l	6f, r10
-	shlr2	r0
-	shlr	r0
-	mov.l	@(r0, r10), r10
-	jmp	@r10
-	 lds	r9, pr		! put return address in pr
-
-	.align	L1_CACHE_SHIFT
-
-! save_regs()
-! - save default tra, macl, mach, gbr, ssr, pr* and spc on the stack
-! - save r15*, r14, r13, r12, r11, r10, r9, r8 on the stack
-! - switch bank
-! - save r7, r6, r5, r4, r3, r2, r1, r0 on the stack
-! k0 contains original stack pointer*
-! k1 trashed
-! k3 passes original pr*
-! k4 passes SR bitmask
-! BL=1 on entry, on exit BL=0.
-
-ENTRY(save_regs)
-	mov	#-1, r1
-	mov.l	k1, @-r15	! set TRA (default: -1)
-	sts.l	macl, @-r15
-	sts.l	mach, @-r15
-	stc.l	gbr, @-r15
-	stc.l	ssr, @-r15
-	mov.l	k3, @-r15	! original pr in k3
-	stc.l	spc, @-r15
-
-	mov.l	k0, @-r15	! original stack pointer in k0
-	mov.l	r14, @-r15
-	mov.l	r13, @-r15
-	mov.l	r12, @-r15
-	mov.l	r11, @-r15
-	mov.l	r10, @-r15
-	mov.l	r9, @-r15
-	mov.l	r8, @-r15
-
-	mov.l	0f, k3		! SR bits to set in k3
-
-	! fall-through
-
-! save_low_regs()
-! - modify SR for bank switch
-! - save r7, r6, r5, r4, r3, r2, r1, r0 on the stack
-! k3 passes bits to set in SR
-! k4 passes bits to clear in SR
-
-ENTRY(save_low_regs)
-	stc	sr, r8
-	or	k3, r8
-	and	k4, r8
-	ldc	r8, sr
-
-	mov.l	r7, @-r15
-	mov.l	r6, @-r15
-	mov.l	r5, @-r15
-	mov.l	r4, @-r15
-	mov.l	r3, @-r15
-	mov.l	r2, @-r15
-	mov.l	r1, @-r15
-	rts
-	 mov.l	r0, @-r15
-
-!
-! 0x600: Interrupt / NMI vector
-!
-	.balign 	512,0,512
-ENTRY(handle_interrupt)
-	sts	pr, k3		! save original pr value in k3
-	mova	exception_data, k0
-
-	! Setup stack and save DSP context (k0 contains original r15 on return)
-	bsr	prepare_stack
-	 PREF(k0)
-
-	! Save registers / Switch to bank 0
-	mov.l	1f, k4		! SR bits to clear in k4
-	bsr	save_regs	! needs original pr value in k3
-	 mov	#-1, k2		! default vector kept in k2
-
-	setup_frame_reg
-
-	stc	sr, r0	! get status register
-	shlr2	r0
-	and	#0x3c, r0
-	cmp/eq	#0x3c, r0
-	bf	9f
-	TRACE_IRQS_OFF
-9:
-
-	! Setup return address and jump to do_IRQ
-	mov.l	4f, r9		! fetch return address
-	lds	r9, pr		! put return address in pr
-	mov.l	2f, r4
-	mov.l	3f, r9
-	mov.l	@r4, r4		! pass INTEVT vector as arg0
-
-	shlr2	r4
-	shlr	r4
-	mov	r4, r0		! save vector->jmp table offset for later
-
-	shlr2	r4		! vector to IRQ# conversion
-	add	#-0x10, r4
-
-	cmp/pz	r4		! is it a valid IRQ?
-	bt	10f
-
-	/*
-	 * We got here as a result of taking the INTEVT path for something
-	 * that isn't a valid hard IRQ, therefore we bypass the do_IRQ()
-	 * path and special case the event dispatch instead.  This is the
-	 * expected path for the NMI (and any other brilliantly implemented
-	 * exception), which effectively wants regular exception dispatch
-	 * but is unfortunately reported through INTEVT rather than
-	 * EXPEVT.  Grr.
-	 */
-	mov.l	6f, r9
-	mov.l	@(r0, r9), r9
-	jmp	@r9
-	 mov	r15, r8		! trap handlers take saved regs in r8
-
-10:
-	jmp	@r9		! Off to do_IRQ() we go.
-	 mov	r15, r5		! pass saved registers as arg1
-
-ENTRY(exception_none)
-	rts
-	 nop
-
-	.align	L1_CACHE_SHIFT
-exception_data:
-0:	.long	0x000080f0	! FD=1, IMASK=15
-1:	.long	0xcfffffff	! RB=0, BL=0
-2:	.long	INTEVT
-3:	.long	do_IRQ
-4:	.long	ret_from_irq
-5:	.long	EXPEVT
-6:	.long	exception_handling_table
-7:	.long	ret_from_exception
diff --git a/arch/sh/kernel/cpu/sh3/ex.S b/arch/sh/kernel/cpu/sh3/ex.S
deleted file mode 100644
index ee2113f4215cb3..00000000000000
--- a/arch/sh/kernel/cpu/sh3/ex.S
+++ /dev/null
@@ -1,56 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- *  arch/sh/kernel/cpu/sh3/ex.S
- *
- *  The SH-3 and SH-4 exception vector table.
- *
- *  Copyright (C) 1999, 2000, 2002  Niibe Yutaka
- *  Copyright (C) 2003 - 2008  Paul Mundt
- */
-#include <linux/linkage.h>
-
-#if !defined(CONFIG_MMU)
-#define	tlb_miss_load			exception_error
-#define tlb_miss_store			exception_error
-#define initial_page_write		exception_error
-#define tlb_protection_violation_load	exception_error
-#define tlb_protection_violation_store	exception_error
-#define address_error_load		exception_error
-#define address_error_store		exception_error
-#endif
-
-#if !defined(CONFIG_SH_FPU)
-#define	fpu_error_trap_handler		exception_error
-#endif
-
-#if !defined(CONFIG_KGDB)
-#define kgdb_handle_exception		exception_error
-#endif
-
-	.align 2
-	.data
-
-ENTRY(exception_handling_table)
-	.long	exception_error		/* 000 */
-	.long	exception_error
-	.long	tlb_miss_load		/* 040 */
-	.long	tlb_miss_store
-	.long	initial_page_write
-	.long	tlb_protection_violation_load
-	.long	tlb_protection_violation_store
-	.long	address_error_load
-	.long	address_error_store	/* 100 */
-	.long	fpu_error_trap_handler	/* 120 */
-	.long	exception_error		/* 140 */
-	.long	system_call	! Unconditional Trap	 /* 160 */
-	.long	exception_error	! reserved_instruction (filled by trap_init) /* 180 */
-	.long	exception_error	! illegal_slot_instruction (filled by trap_init) /*1A0*/
-	.long	nmi_trap_handler	/* 1C0 */	! Allow trap to debugger
-	.long	breakpoint_trap_handler	/* 1E0 */
-
-	/*
-	 * Pad the remainder of the table out, exceptions residing in far
-	 * away offsets can be manually inserted in to their appropriate
-	 * location via set_exception_table_{evt,vec}().
-	 */
-	.balign	4096,0,4096
diff --git a/arch/sh/kernel/cpu/sh3/pinmux-sh7720.c b/arch/sh/kernel/cpu/sh3/pinmux-sh7720.c
deleted file mode 100644
index 34015e608ee931..00000000000000
--- a/arch/sh/kernel/cpu/sh3/pinmux-sh7720.c
+++ /dev/null
@@ -1,27 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7720 Pinmux
- *
- *  Copyright (C) 2008  Magnus Damm
- */
-
-#include <linux/bug.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/ioport.h>
-#include <cpu/pfc.h>
-
-static struct resource sh7720_pfc_resources[] = {
-	[0] = {
-		.start	= 0xa4050100,
-		.end	= 0xa405016f,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static int __init plat_pinmux_setup(void)
-{
-	return sh_pfc_register("pfc-sh7720", sh7720_pfc_resources,
-			       ARRAY_SIZE(sh7720_pfc_resources));
-}
-arch_initcall(plat_pinmux_setup);
diff --git a/arch/sh/kernel/cpu/sh3/probe.c b/arch/sh/kernel/cpu/sh3/probe.c
deleted file mode 100644
index 5e7ad591ab1651..00000000000000
--- a/arch/sh/kernel/cpu/sh3/probe.c
+++ /dev/null
@@ -1,108 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh3/probe.c
- *
- * CPU Subtype Probing for SH-3.
- *
- * Copyright (C) 1999, 2000  Niibe Yutaka
- * Copyright (C) 2002  Paul Mundt
- */
-
-#include <linux/init.h>
-#include <asm/processor.h>
-#include <asm/cache.h>
-#include <asm/io.h>
-
-void cpu_probe(void)
-{
-	unsigned long addr0, addr1, data0, data1, data2, data3;
-
-	jump_to_uncached();
-	/*
-	 * Check if the entry shadows or not.
-	 * When shadowed, it's 128-entry system.
-	 * Otherwise, it's 256-entry system.
-	 */
-	addr0 = CACHE_OC_ADDRESS_ARRAY + (3 << 12);
-	addr1 = CACHE_OC_ADDRESS_ARRAY + (1 << 12);
-
-	/* First, write back & invalidate */
-	data0  = __raw_readl(addr0);
-	__raw_writel(data0&~(SH_CACHE_VALID|SH_CACHE_UPDATED), addr0);
-	data1  = __raw_readl(addr1);
-	__raw_writel(data1&~(SH_CACHE_VALID|SH_CACHE_UPDATED), addr1);
-
-	/* Next, check if there's shadow or not */
-	data0 = __raw_readl(addr0);
-	data0 ^= SH_CACHE_VALID;
-	__raw_writel(data0, addr0);
-	data1 = __raw_readl(addr1);
-	data2 = data1 ^ SH_CACHE_VALID;
-	__raw_writel(data2, addr1);
-	data3 = __raw_readl(addr0);
-
-	/* Lastly, invaliate them. */
-	__raw_writel(data0&~SH_CACHE_VALID, addr0);
-	__raw_writel(data2&~SH_CACHE_VALID, addr1);
-
-	back_to_cached();
-
-	boot_cpu_data.dcache.ways		= 4;
-	boot_cpu_data.dcache.entry_shift	= 4;
-	boot_cpu_data.dcache.linesz		= L1_CACHE_BYTES;
-	boot_cpu_data.dcache.flags		= 0;
-
-	/*
-	 * 7709A/7729 has 16K cache (256-entry), while 7702 has only
-	 * 2K(direct) 7702 is not supported (yet)
-	 */
-	if (data0 == data1 && data2 == data3) {	/* Shadow */
-		boot_cpu_data.dcache.way_incr	= (1 << 11);
-		boot_cpu_data.dcache.entry_mask	= 0x7f0;
-		boot_cpu_data.dcache.sets	= 128;
-		boot_cpu_data.type = CPU_SH7708;
-
-		boot_cpu_data.flags |= CPU_HAS_MMU_PAGE_ASSOC;
-	} else {				/* 7709A or 7729  */
-		boot_cpu_data.dcache.way_incr	= (1 << 12);
-		boot_cpu_data.dcache.entry_mask	= 0xff0;
-		boot_cpu_data.dcache.sets	= 256;
-		boot_cpu_data.type = CPU_SH7729;
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7706)
-		boot_cpu_data.type = CPU_SH7706;
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_SH7710)
-		boot_cpu_data.type = CPU_SH7710;
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_SH7712)
-		boot_cpu_data.type = CPU_SH7712;
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_SH7720)
-		boot_cpu_data.type = CPU_SH7720;
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_SH7721)
-		boot_cpu_data.type = CPU_SH7721;
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_SH7705)
-		boot_cpu_data.type = CPU_SH7705;
-
-#if defined(CONFIG_SH7705_CACHE_32KB)
-		boot_cpu_data.dcache.way_incr	= (1 << 13);
-		boot_cpu_data.dcache.entry_mask	= 0x1ff0;
-		boot_cpu_data.dcache.sets	= 512;
-		__raw_writel(CCR_CACHE_32KB, CCR3_REG);
-#else
-		__raw_writel(CCR_CACHE_16KB, CCR3_REG);
-#endif
-#endif
-	}
-
-	/*
-	 * SH-3 doesn't have separate caches
-	 */
-	boot_cpu_data.dcache.flags |= SH_CACHE_COMBINED;
-	boot_cpu_data.icache = boot_cpu_data.dcache;
-
-	boot_cpu_data.family = CPU_FAMILY_SH3;
-}
diff --git a/arch/sh/kernel/cpu/sh3/serial-sh770x.c b/arch/sh/kernel/cpu/sh3/serial-sh770x.c
deleted file mode 100644
index dec027f233f22e..00000000000000
--- a/arch/sh/kernel/cpu/sh3/serial-sh770x.c
+++ /dev/null
@@ -1,34 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/serial_sci.h>
-#include <linux/serial_core.h>
-#include <linux/io.h>
-#include <cpu/serial.h>
-
-#define SCPCR 0xA4000116
-#define SCPDR 0xA4000136
-
-static void sh770x_sci_init_pins(struct uart_port *port, unsigned int cflag)
-{
-	unsigned short data;
-
-	/* We need to set SCPCR to enable RTS/CTS */
-	data = __raw_readw(SCPCR);
-	/* Clear out SCP7MD1,0, SCP6MD1,0, SCP4MD1,0*/
-	__raw_writew(data & 0x0fcf, SCPCR);
-
-	if (!(cflag & CRTSCTS)) {
-		/* We need to set SCPCR to enable RTS/CTS */
-		data = __raw_readw(SCPCR);
-		/* Clear out SCP7MD1,0, SCP4MD1,0,
-		   Set SCP6MD1,0 = {01} (output)  */
-		__raw_writew((data & 0x0fcf) | 0x1000, SCPCR);
-
-		data = __raw_readb(SCPDR);
-		/* Set /RTS2 (bit6) = 0 */
-		__raw_writeb(data & 0xbf, SCPDR);
-	}
-}
-
-struct plat_sci_port_ops sh770x_sci_port_ops = {
-	.init_pins	= sh770x_sci_init_pins,
-};
diff --git a/arch/sh/kernel/cpu/sh3/serial-sh7710.c b/arch/sh/kernel/cpu/sh3/serial-sh7710.c
deleted file mode 100644
index ee04052e5bdde2..00000000000000
--- a/arch/sh/kernel/cpu/sh3/serial-sh7710.c
+++ /dev/null
@@ -1,21 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/serial_sci.h>
-#include <linux/serial_core.h>
-#include <linux/io.h>
-#include <cpu/serial.h>
-
-#define PACR 0xa4050100
-#define PBCR 0xa4050102
-
-static void sh7710_sci_init_pins(struct uart_port *port, unsigned int cflag)
-{
-	if (port->mapbase == 0xA4400000) {
-		__raw_writew(__raw_readw(PACR) & 0xffc0, PACR);
-		__raw_writew(__raw_readw(PBCR) & 0x0fff, PBCR);
-	} else if (port->mapbase == 0xA4410000)
-		__raw_writew(__raw_readw(PBCR) & 0xf003, PBCR);
-}
-
-struct plat_sci_port_ops sh7710_sci_port_ops = {
-	.init_pins	= sh7710_sci_init_pins,
-};
diff --git a/arch/sh/kernel/cpu/sh3/serial-sh7720.c b/arch/sh/kernel/cpu/sh3/serial-sh7720.c
deleted file mode 100644
index 75aaea49de4317..00000000000000
--- a/arch/sh/kernel/cpu/sh3/serial-sh7720.c
+++ /dev/null
@@ -1,38 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/serial_sci.h>
-#include <linux/serial_core.h>
-#include <linux/io.h>
-#include <cpu/serial.h>
-#include <cpu/gpio.h>
-
-static void sh7720_sci_init_pins(struct uart_port *port, unsigned int cflag)
-{
-	unsigned short data;
-
-	if (cflag & CRTSCTS) {
-		/* enable RTS/CTS */
-		if (port->mapbase == 0xa4430000) { /* SCIF0 */
-			/* Clear PTCR bit 9-2; enable all scif pins but sck */
-			data = __raw_readw(PORT_PTCR);
-			__raw_writew((data & 0xfc03), PORT_PTCR);
-		} else if (port->mapbase == 0xa4438000) { /* SCIF1 */
-			/* Clear PVCR bit 9-2 */
-			data = __raw_readw(PORT_PVCR);
-			__raw_writew((data & 0xfc03), PORT_PVCR);
-		}
-	} else {
-		if (port->mapbase == 0xa4430000) { /* SCIF0 */
-			/* Clear PTCR bit 5-2; enable only tx and rx  */
-			data = __raw_readw(PORT_PTCR);
-			__raw_writew((data & 0xffc3), PORT_PTCR);
-		} else if (port->mapbase == 0xa4438000) { /* SCIF1 */
-			/* Clear PVCR bit 5-2 */
-			data = __raw_readw(PORT_PVCR);
-			__raw_writew((data & 0xffc3), PORT_PVCR);
-		}
-	}
-}
-
-struct plat_sci_port_ops sh7720_sci_port_ops = {
-	.init_pins	= sh7720_sci_init_pins,
-};
diff --git a/arch/sh/kernel/cpu/sh3/setup-sh3.c b/arch/sh/kernel/cpu/sh3/setup-sh3.c
deleted file mode 100644
index cf2a3f09fee443..00000000000000
--- a/arch/sh/kernel/cpu/sh3/setup-sh3.c
+++ /dev/null
@@ -1,69 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Shared SH3 Setup code
- *
- *  Copyright (C) 2008  Magnus Damm
- */
-
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/io.h>
-#include <asm/platform_early.h>
-
-/* All SH3 devices are equipped with IRQ0->5 (except sh7708) */
-
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-	IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5,
-};
-
-static struct intc_vect vectors_irq0123[] __initdata = {
-	INTC_VECT(IRQ0, 0x600), INTC_VECT(IRQ1, 0x620),
-	INTC_VECT(IRQ2, 0x640), INTC_VECT(IRQ3, 0x660),
-};
-
-static struct intc_vect vectors_irq45[] __initdata = {
-	INTC_VECT(IRQ4, 0x680), INTC_VECT(IRQ5, 0x6a0),
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xa4000016, 0, 16, 4, /* IPRC */ { IRQ3, IRQ2, IRQ1, IRQ0 } },
-	{ 0xa4000018, 0, 16, 4, /* IPRD */ { 0, 0, IRQ5, IRQ4 } },
-};
-
-static struct intc_mask_reg ack_registers[] __initdata = {
-	{ 0xa4000004, 0, 8, /* IRR0 */
-	  { 0, 0, IRQ5, IRQ4, IRQ3, IRQ2, IRQ1, IRQ0 } },
-};
-
-static struct intc_sense_reg sense_registers[] __initdata = {
-	{ 0xa4000010, 16, 2, { 0, 0, IRQ5, IRQ4, IRQ3, IRQ2, IRQ1, IRQ0 } },
-};
-
-static DECLARE_INTC_DESC_ACK(intc_desc_irq0123, "sh3-irq0123",
-			     vectors_irq0123, NULL, NULL,
-			     prio_registers, sense_registers, ack_registers);
-
-static DECLARE_INTC_DESC_ACK(intc_desc_irq45, "sh3-irq45",
-			     vectors_irq45, NULL, NULL,
-			     prio_registers, sense_registers, ack_registers);
-
-#define INTC_ICR1		0xa4000010UL
-#define INTC_ICR1_IRQLVL	(1<<14)
-
-void __init plat_irq_setup_pins(int mode)
-{
-	if (mode == IRQ_MODE_IRQ) {
-		__raw_writew(__raw_readw(INTC_ICR1) & ~INTC_ICR1_IRQLVL, INTC_ICR1);
-		register_intc_controller(&intc_desc_irq0123);
-		return;
-	}
-	BUG();
-}
-
-void __init plat_irq_setup_sh3(void)
-{
-	register_intc_controller(&intc_desc_irq45);
-}
diff --git a/arch/sh/kernel/cpu/sh3/setup-sh7705.c b/arch/sh/kernel/cpu/sh3/setup-sh7705.c
deleted file mode 100644
index 0544134b3f20c6..00000000000000
--- a/arch/sh/kernel/cpu/sh3/setup-sh7705.c
+++ /dev/null
@@ -1,190 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7705 Setup
- *
- *  Copyright (C) 2006 - 2009  Paul Mundt
- *  Copyright (C) 2007  Nobuhiro Iwamatsu
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/serial.h>
-#include <linux/serial_sci.h>
-#include <linux/sh_timer.h>
-#include <linux/sh_intc.h>
-#include <asm/rtc.h>
-#include <cpu/serial.h>
-#include <asm/platform_early.h>
-
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-	IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5,
-	PINT07, PINT815,
-
-	DMAC, SCIF0, SCIF2, ADC_ADI, USB,
-
-	TPU0, TPU1, TPU2, TPU3,
-	TMU0, TMU1, TMU2,
-
-	RTC, WDT, REF_RCMI,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	/* IRQ0->5 are handled in setup-sh3.c */
-	INTC_VECT(PINT07, 0x700), INTC_VECT(PINT815, 0x720),
-	INTC_VECT(DMAC, 0x800), INTC_VECT(DMAC, 0x820),
-	INTC_VECT(DMAC, 0x840), INTC_VECT(DMAC, 0x860),
-	INTC_VECT(SCIF0, 0x880), INTC_VECT(SCIF0, 0x8a0),
-	INTC_VECT(SCIF0, 0x8e0),
-	INTC_VECT(SCIF2, 0x900), INTC_VECT(SCIF2, 0x920),
-	INTC_VECT(SCIF2, 0x960),
-	INTC_VECT(ADC_ADI, 0x980),
-	INTC_VECT(USB, 0xa20), INTC_VECT(USB, 0xa40),
-	INTC_VECT(TPU0, 0xc00), INTC_VECT(TPU1, 0xc20),
-	INTC_VECT(TPU2, 0xc80), INTC_VECT(TPU3, 0xca0),
-	INTC_VECT(TMU0, 0x400), INTC_VECT(TMU1, 0x420),
-	INTC_VECT(TMU2, 0x440), INTC_VECT(TMU2, 0x460),
-	INTC_VECT(RTC, 0x480), INTC_VECT(RTC, 0x4a0),
-	INTC_VECT(RTC, 0x4c0),
-	INTC_VECT(WDT, 0x560),
-	INTC_VECT(REF_RCMI, 0x580),
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xfffffee2, 0, 16, 4, /* IPRA */ { TMU0, TMU1, TMU2, RTC } },
-	{ 0xfffffee4, 0, 16, 4, /* IPRB */ { WDT, REF_RCMI, 0, 0 } },
-	{ 0xa4000016, 0, 16, 4, /* IPRC */ { IRQ3, IRQ2, IRQ1, IRQ0 } },
-	{ 0xa4000018, 0, 16, 4, /* IPRD */ { PINT07, PINT815, IRQ5, IRQ4 } },
-	{ 0xa400001a, 0, 16, 4, /* IPRE */ { DMAC, SCIF0, SCIF2, ADC_ADI } },
-	{ 0xa4080000, 0, 16, 4, /* IPRF */ { 0, 0, USB } },
-	{ 0xa4080002, 0, 16, 4, /* IPRG */ { TPU0, TPU1 } },
-	{ 0xa4080004, 0, 16, 4, /* IPRH */ { TPU2, TPU3 } },
-
-};
-
-static DECLARE_INTC_DESC(intc_desc, "sh7705", vectors, NULL,
-			 NULL, prio_registers, NULL);
-
-static struct plat_sci_port scif0_platform_data = {
-	.scscr		= SCSCR_CKE1,
-	.type		= PORT_SCIF,
-	.ops		= &sh770x_sci_port_ops,
-	.regtype	= SCIx_SH7705_SCIF_REGTYPE,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xa4410000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x900)),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct plat_sci_port scif1_platform_data = {
-	.type		= PORT_SCIF,
-	.ops		= &sh770x_sci_port_ops,
-	.regtype	= SCIx_SH7705_SCIF_REGTYPE,
-};
-
-static struct resource scif1_resources[] = {
-	DEFINE_RES_MEM(0xa4400000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x880)),
-};
-
-static struct platform_device scif1_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif1_resources,
-	.num_resources	= ARRAY_SIZE(scif1_resources),
-	.dev		= {
-		.platform_data	= &scif1_platform_data,
-	},
-};
-
-static struct resource rtc_resources[] = {
-	[0] =	{
-		.start	= 0xfffffec0,
-		.end	= 0xfffffec0 + 0x1e,
-		.flags  = IORESOURCE_IO,
-	},
-	[1] =	{
-		.start  = evt2irq(0x480),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct sh_rtc_platform_info rtc_info = {
-	.capabilities	= RTC_CAP_4_DIGIT_YEAR,
-};
-
-static struct platform_device rtc_device = {
-	.name		= "sh-rtc",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(rtc_resources),
-	.resource	= rtc_resources,
-	.dev		= {
-		.platform_data = &rtc_info,
-	},
-};
-
-static struct sh_timer_config tmu0_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu0_resources[] = {
-	DEFINE_RES_MEM(0xfffffe90, 0x2c),
-	DEFINE_RES_IRQ(evt2irq(0x400)),
-	DEFINE_RES_IRQ(evt2irq(0x420)),
-	DEFINE_RES_IRQ(evt2irq(0x440)),
-};
-
-static struct platform_device tmu0_device = {
-	.name		= "sh-tmu-sh3",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &tmu0_platform_data,
-	},
-	.resource	= tmu0_resources,
-	.num_resources	= ARRAY_SIZE(tmu0_resources),
-};
-
-static struct platform_device *sh7705_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&tmu0_device,
-	&rtc_device,
-};
-
-static int __init sh7705_devices_setup(void)
-{
-	return platform_add_devices(sh7705_devices,
-				    ARRAY_SIZE(sh7705_devices));
-}
-arch_initcall(sh7705_devices_setup);
-
-static struct platform_device *sh7705_early_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&tmu0_device,
-};
-
-void __init plat_early_device_setup(void)
-{
-	sh_early_platform_add_devices(sh7705_early_devices,
-				   ARRAY_SIZE(sh7705_early_devices));
-}
-
-void __init plat_irq_setup(void)
-{
-	register_intc_controller(&intc_desc);
-	plat_irq_setup_sh3();
-}
diff --git a/arch/sh/kernel/cpu/sh3/setup-sh770x.c b/arch/sh/kernel/cpu/sh3/setup-sh770x.c
deleted file mode 100644
index 4947f57748bc12..00000000000000
--- a/arch/sh/kernel/cpu/sh3/setup-sh770x.c
+++ /dev/null
@@ -1,246 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH3 Setup code for SH7706, SH7707, SH7708, SH7709
- *
- *  Copyright (C) 2007  Magnus Damm
- *  Copyright (C) 2009  Paul Mundt
- *
- * Based on setup-sh7709.c
- *
- *  Copyright (C) 2006  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/irq.h>
-#include <linux/platform_device.h>
-#include <linux/serial.h>
-#include <linux/serial_sci.h>
-#include <linux/sh_timer.h>
-#include <linux/sh_intc.h>
-#include <cpu/serial.h>
-#include <asm/platform_early.h>
-
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-	IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5,
-	PINT07, PINT815,
-	DMAC, SCIF0, SCIF2, SCI, ADC_ADI,
-	LCDC, PCC0, PCC1,
-	TMU0, TMU1, TMU2,
-	RTC, WDT, REF,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_VECT(TMU0, 0x400), INTC_VECT(TMU1, 0x420),
-	INTC_VECT(TMU2, 0x440), INTC_VECT(TMU2, 0x460),
-	INTC_VECT(RTC, 0x480), INTC_VECT(RTC, 0x4a0),
-	INTC_VECT(RTC, 0x4c0),
-	INTC_VECT(SCI, 0x4e0), INTC_VECT(SCI, 0x500),
-	INTC_VECT(SCI, 0x520), INTC_VECT(SCI, 0x540),
-	INTC_VECT(WDT, 0x560),
-	INTC_VECT(REF, 0x580),
-	INTC_VECT(REF, 0x5a0),
-#if defined(CONFIG_CPU_SUBTYPE_SH7706) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7707) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7709)
-	/* IRQ0->5 are handled in setup-sh3.c */
-	INTC_VECT(DMAC, 0x800), INTC_VECT(DMAC, 0x820),
-	INTC_VECT(DMAC, 0x840), INTC_VECT(DMAC, 0x860),
-	INTC_VECT(ADC_ADI, 0x980),
-	INTC_VECT(SCIF2, 0x900), INTC_VECT(SCIF2, 0x920),
-	INTC_VECT(SCIF2, 0x940), INTC_VECT(SCIF2, 0x960),
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_SH7707) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7709)
-	INTC_VECT(PINT07, 0x700), INTC_VECT(PINT815, 0x720),
-	INTC_VECT(SCIF0, 0x880), INTC_VECT(SCIF0, 0x8a0),
-	INTC_VECT(SCIF0, 0x8c0), INTC_VECT(SCIF0, 0x8e0),
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_SH7707)
-	INTC_VECT(LCDC, 0x9a0),
-	INTC_VECT(PCC0, 0x9c0), INTC_VECT(PCC1, 0x9e0),
-#endif
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xfffffee2, 0, 16, 4, /* IPRA */ { TMU0, TMU1, TMU2, RTC } },
-	{ 0xfffffee4, 0, 16, 4, /* IPRB */ { WDT, REF, SCI, 0 } },
-#if defined(CONFIG_CPU_SUBTYPE_SH7706) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7707) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7709)
-	{ 0xa4000016, 0, 16, 4, /* IPRC */ { IRQ3, IRQ2, IRQ1, IRQ0 } },
-	{ 0xa4000018, 0, 16, 4, /* IPRD */ { 0, 0, IRQ5, IRQ4 } },
-	{ 0xa400001a, 0, 16, 4, /* IPRE */ { DMAC, 0, SCIF2, ADC_ADI } },
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_SH7707) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7709)
-	{ 0xa4000018, 0, 16, 4, /* IPRD */ { PINT07, PINT815, } },
-	{ 0xa400001a, 0, 16, 4, /* IPRE */ { 0, SCIF0 } },
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_SH7707)
-	{ 0xa400001c, 0, 16, 4, /* IPRF */ { 0, LCDC, PCC0, PCC1, } },
-#endif
-};
-
-static DECLARE_INTC_DESC(intc_desc, "sh770x", vectors, NULL,
-			 NULL, prio_registers, NULL);
-
-static struct resource rtc_resources[] = {
-	[0] =	{
-		.start	= 0xfffffec0,
-		.end	= 0xfffffec0 + 0x1e,
-		.flags  = IORESOURCE_IO,
-	},
-	[1] =	{
-		.start	= evt2irq(0x480),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device rtc_device = {
-	.name		= "sh-rtc",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(rtc_resources),
-	.resource	= rtc_resources,
-};
-
-static struct plat_sci_port scif0_platform_data = {
-	.type		= PORT_SCI,
-	.ops		= &sh770x_sci_port_ops,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xfffffe80, 0x10),
-	DEFINE_RES_IRQ(evt2irq(0x4e0)),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-#if defined(CONFIG_CPU_SUBTYPE_SH7706) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7707) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7709)
-static struct plat_sci_port scif1_platform_data = {
-	.type		= PORT_SCIF,
-	.ops		= &sh770x_sci_port_ops,
-	.regtype	= SCIx_SH3_SCIF_REGTYPE,
-};
-
-static struct resource scif1_resources[] = {
-	DEFINE_RES_MEM(0xa4000150, 0x10),
-	DEFINE_RES_IRQ(evt2irq(0x900)),
-};
-
-static struct platform_device scif1_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif1_resources,
-	.num_resources	= ARRAY_SIZE(scif1_resources),
-	.dev		= {
-		.platform_data	= &scif1_platform_data,
-	},
-};
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_SH7707) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7709)
-static struct plat_sci_port scif2_platform_data = {
-	.type		= PORT_IRDA,
-	.ops		= &sh770x_sci_port_ops,
-};
-
-static struct resource scif2_resources[] = {
-	DEFINE_RES_MEM(0xa4000140, 0x10),
-	DEFINE_RES_IRQ(evt2irq(0x880)),
-};
-
-static struct platform_device scif2_device = {
-	.name		= "sh-sci",
-	.id		= 2,
-	.resource	= scif2_resources,
-	.num_resources	= ARRAY_SIZE(scif2_resources),
-	.dev		= {
-		.platform_data	= &scif2_platform_data,
-	},
-};
-#endif
-
-static struct sh_timer_config tmu0_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu0_resources[] = {
-	DEFINE_RES_MEM(0xfffffe90, 0x2c),
-	DEFINE_RES_IRQ(evt2irq(0x400)),
-	DEFINE_RES_IRQ(evt2irq(0x420)),
-	DEFINE_RES_IRQ(evt2irq(0x440)),
-};
-
-static struct platform_device tmu0_device = {
-	.name		= "sh-tmu-sh3",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &tmu0_platform_data,
-	},
-	.resource	= tmu0_resources,
-	.num_resources	= ARRAY_SIZE(tmu0_resources),
-};
-
-static struct platform_device *sh770x_devices[] __initdata = {
-	&scif0_device,
-#if defined(CONFIG_CPU_SUBTYPE_SH7706) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7707) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7709)
-	&scif1_device,
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_SH7707) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7709)
-	&scif2_device,
-#endif
-	&tmu0_device,
-	&rtc_device,
-};
-
-static int __init sh770x_devices_setup(void)
-{
-	return platform_add_devices(sh770x_devices,
-		ARRAY_SIZE(sh770x_devices));
-}
-arch_initcall(sh770x_devices_setup);
-
-static struct platform_device *sh770x_early_devices[] __initdata = {
-	&scif0_device,
-#if defined(CONFIG_CPU_SUBTYPE_SH7706) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7707) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7709)
-	&scif1_device,
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_SH7707) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7709)
-	&scif2_device,
-#endif
-	&tmu0_device,
-};
-
-void __init plat_early_device_setup(void)
-{
-	sh_early_platform_add_devices(sh770x_early_devices,
-				   ARRAY_SIZE(sh770x_early_devices));
-}
-
-void __init plat_irq_setup(void)
-{
-	register_intc_controller(&intc_desc);
-#if defined(CONFIG_CPU_SUBTYPE_SH7706) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7707) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7709)
-	plat_irq_setup_sh3();
-#endif
-}
diff --git a/arch/sh/kernel/cpu/sh3/setup-sh7710.c b/arch/sh/kernel/cpu/sh3/setup-sh7710.c
deleted file mode 100644
index 3819107615794b..00000000000000
--- a/arch/sh/kernel/cpu/sh3/setup-sh7710.c
+++ /dev/null
@@ -1,189 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH3 Setup code for SH7710, SH7712
- *
- *  Copyright (C) 2006 - 2009  Paul Mundt
- *  Copyright (C) 2007  Nobuhiro Iwamatsu
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/serial.h>
-#include <linux/serial_sci.h>
-#include <linux/sh_timer.h>
-#include <linux/sh_intc.h>
-#include <asm/rtc.h>
-#include <asm/platform_early.h>
-
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-	IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5,
-	DMAC1, SCIF0, SCIF1, DMAC2, IPSEC,
-	EDMAC0, EDMAC1, EDMAC2,
-	SIOF0, SIOF1,
-
-	TMU0, TMU1, TMU2,
-	RTC, WDT, REF,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	/* IRQ0->5 are handled in setup-sh3.c */
-	INTC_VECT(DMAC1, 0x800), INTC_VECT(DMAC1, 0x820),
-	INTC_VECT(DMAC1, 0x840), INTC_VECT(DMAC1, 0x860),
-	INTC_VECT(SCIF0, 0x880), INTC_VECT(SCIF0, 0x8a0),
-	INTC_VECT(SCIF0, 0x8c0), INTC_VECT(SCIF0, 0x8e0),
-	INTC_VECT(SCIF1, 0x900), INTC_VECT(SCIF1, 0x920),
-	INTC_VECT(SCIF1, 0x940), INTC_VECT(SCIF1, 0x960),
-	INTC_VECT(DMAC2, 0xb80), INTC_VECT(DMAC2, 0xba0),
-#ifdef CONFIG_CPU_SUBTYPE_SH7710
-	INTC_VECT(IPSEC, 0xbe0),
-#endif
-	INTC_VECT(EDMAC0, 0xc00), INTC_VECT(EDMAC1, 0xc20),
-	INTC_VECT(EDMAC2, 0xc40),
-	INTC_VECT(SIOF0, 0xe00), INTC_VECT(SIOF0, 0xe20),
-	INTC_VECT(SIOF0, 0xe40), INTC_VECT(SIOF0, 0xe60),
-	INTC_VECT(SIOF1, 0xe80), INTC_VECT(SIOF1, 0xea0),
-	INTC_VECT(SIOF1, 0xec0), INTC_VECT(SIOF1, 0xee0),
-	INTC_VECT(TMU0, 0x400), INTC_VECT(TMU1, 0x420),
-	INTC_VECT(TMU2, 0x440),
-	INTC_VECT(RTC, 0x480), INTC_VECT(RTC, 0x4a0),
-	INTC_VECT(RTC, 0x4c0),
-	INTC_VECT(WDT, 0x560),
-	INTC_VECT(REF, 0x580),
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xfffffee2, 0, 16, 4, /* IPRA */ { TMU0, TMU1, TMU2, RTC } },
-	{ 0xfffffee4, 0, 16, 4, /* IPRB */ { WDT, REF, 0, 0 } },
-	{ 0xa4000016, 0, 16, 4, /* IPRC */ { IRQ3, IRQ2, IRQ1, IRQ0 } },
-	{ 0xa4000018, 0, 16, 4, /* IPRD */ { 0, 0, IRQ5, IRQ4 } },
-	{ 0xa400001a, 0, 16, 4, /* IPRE */ { DMAC1, SCIF0, SCIF1 } },
-	{ 0xa4080000, 0, 16, 4, /* IPRF */ { IPSEC, DMAC2 } },
-	{ 0xa4080002, 0, 16, 4, /* IPRG */ { EDMAC0, EDMAC1, EDMAC2 } },
-	{ 0xa4080004, 0, 16, 4, /* IPRH */ { 0, 0, 0, SIOF0 } },
-	{ 0xa4080006, 0, 16, 4, /* IPRI */ { 0, 0, SIOF1 } },
-};
-
-static DECLARE_INTC_DESC(intc_desc, "sh7710", vectors, NULL,
-			 NULL, prio_registers, NULL);
-
-static struct resource rtc_resources[] = {
-	[0] =	{
-		.start	= 0xa413fec0,
-		.end	= 0xa413fec0 + 0x1e,
-		.flags  = IORESOURCE_IO,
-	},
-	[1] =	{
-		.start  = evt2irq(0x480),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct sh_rtc_platform_info rtc_info = {
-	.capabilities	= RTC_CAP_4_DIGIT_YEAR,
-};
-
-static struct platform_device rtc_device = {
-	.name		= "sh-rtc",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(rtc_resources),
-	.resource	= rtc_resources,
-	.dev		= {
-		.platform_data = &rtc_info,
-	},
-};
-
-static struct plat_sci_port scif0_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_CKE1,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xa4400000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x880)),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct plat_sci_port scif1_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_CKE1,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif1_resources[] = {
-	DEFINE_RES_MEM(0xa4410000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x900)),
-};
-
-static struct platform_device scif1_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif1_resources,
-	.num_resources	= ARRAY_SIZE(scif1_resources),
-	.dev		= {
-		.platform_data	= &scif1_platform_data,
-	},
-};
-
-static struct sh_timer_config tmu0_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu0_resources[] = {
-	DEFINE_RES_MEM(0xa412fe90, 0x28),
-	DEFINE_RES_IRQ(evt2irq(0x400)),
-	DEFINE_RES_IRQ(evt2irq(0x420)),
-	DEFINE_RES_IRQ(evt2irq(0x440)),
-};
-
-static struct platform_device tmu0_device = {
-	.name		= "sh-tmu-sh3",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &tmu0_platform_data,
-	},
-	.resource	= tmu0_resources,
-	.num_resources	= ARRAY_SIZE(tmu0_resources),
-};
-
-static struct platform_device *sh7710_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&tmu0_device,
-	&rtc_device,
-};
-
-static int __init sh7710_devices_setup(void)
-{
-	return platform_add_devices(sh7710_devices,
-				    ARRAY_SIZE(sh7710_devices));
-}
-arch_initcall(sh7710_devices_setup);
-
-static struct platform_device *sh7710_early_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&tmu0_device,
-};
-
-void __init plat_early_device_setup(void)
-{
-	sh_early_platform_add_devices(sh7710_early_devices,
-				   ARRAY_SIZE(sh7710_early_devices));
-}
-
-void __init plat_irq_setup(void)
-{
-	register_intc_controller(&intc_desc);
-	plat_irq_setup_sh3();
-}
diff --git a/arch/sh/kernel/cpu/sh3/setup-sh7720.c b/arch/sh/kernel/cpu/sh3/setup-sh7720.c
deleted file mode 100644
index 425d067dae9baf..00000000000000
--- a/arch/sh/kernel/cpu/sh3/setup-sh7720.c
+++ /dev/null
@@ -1,286 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Setup code for SH7720, SH7721.
- *
- *  Copyright (C) 2007  Markus Brunner, Mark Jonas
- *  Copyright (C) 2009  Paul Mundt
- *
- *  Based on arch/sh/kernel/cpu/sh4/setup-sh7750.c:
- *
- *  Copyright (C) 2006  Paul Mundt
- *  Copyright (C) 2006  Jamie Lenehan
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/io.h>
-#include <linux/serial_sci.h>
-#include <linux/sh_timer.h>
-#include <linux/sh_intc.h>
-#include <linux/usb/ohci_pdriver.h>
-#include <asm/rtc.h>
-#include <asm/platform_early.h>
-#include <cpu/serial.h>
-
-static struct resource rtc_resources[] = {
-	[0] = {
-		.start	= 0xa413fec0,
-		.end	= 0xa413fec0 + 0x28 - 1,
-		.flags	= IORESOURCE_IO,
-	},
-	[1] = {
-		/* Shared Period/Carry/Alarm IRQ */
-		.start	= evt2irq(0x480),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct sh_rtc_platform_info rtc_info = {
-	.capabilities	= RTC_CAP_4_DIGIT_YEAR,
-};
-
-static struct platform_device rtc_device = {
-	.name		= "sh-rtc",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(rtc_resources),
-	.resource	= rtc_resources,
-	.dev		= {
-		.platform_data = &rtc_info,
-	},
-};
-
-static struct plat_sci_port scif0_platform_data = {
-	.type		= PORT_SCIF,
-	.ops		= &sh7720_sci_port_ops,
-	.regtype	= SCIx_SH7705_SCIF_REGTYPE,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xa4430000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xc00)),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct plat_sci_port scif1_platform_data = {
-	.type		= PORT_SCIF,
-	.ops		= &sh7720_sci_port_ops,
-	.regtype	= SCIx_SH7705_SCIF_REGTYPE,
-};
-
-static struct resource scif1_resources[] = {
-	DEFINE_RES_MEM(0xa4438000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xc20)),
-};
-
-static struct platform_device scif1_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif1_resources,
-	.num_resources	= ARRAY_SIZE(scif1_resources),
-	.dev		= {
-		.platform_data	= &scif1_platform_data,
-	},
-};
-
-static struct resource usb_ohci_resources[] = {
-	[0] = {
-		.start	= 0xA4428000,
-		.end	= 0xA44280FF,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0xa60),
-		.end	= evt2irq(0xa60),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static u64 usb_ohci_dma_mask = 0xffffffffUL;
-
-static struct usb_ohci_pdata usb_ohci_pdata;
-
-static struct platform_device usb_ohci_device = {
-	.name		= "ohci-platform",
-	.id		= -1,
-	.dev = {
-		.dma_mask		= &usb_ohci_dma_mask,
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &usb_ohci_pdata,
-	},
-	.num_resources	= ARRAY_SIZE(usb_ohci_resources),
-	.resource	= usb_ohci_resources,
-};
-
-static struct resource usbf_resources[] = {
-	[0] = {
-		.name	= "sh_udc",
-		.start	= 0xA4420000,
-		.end	= 0xA44200FF,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.name	= "sh_udc",
-		.start	= evt2irq(0xa20),
-		.end	= evt2irq(0xa20),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device usbf_device = {
-	.name		= "sh_udc",
-	.id		= -1,
-	.dev = {
-		.dma_mask		= NULL,
-		.coherent_dma_mask	= 0xffffffff,
-	},
-	.num_resources	= ARRAY_SIZE(usbf_resources),
-	.resource	= usbf_resources,
-};
-
-static struct sh_timer_config cmt_platform_data = {
-	.channels_mask = 0x1f,
-};
-
-static struct resource cmt_resources[] = {
-	DEFINE_RES_MEM(0x044a0000, 0x60),
-	DEFINE_RES_IRQ(evt2irq(0xf00)),
-};
-
-static struct platform_device cmt_device = {
-	.name		= "sh-cmt-32",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &cmt_platform_data,
-	},
-	.resource	= cmt_resources,
-	.num_resources	= ARRAY_SIZE(cmt_resources),
-};
-
-static struct sh_timer_config tmu0_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu0_resources[] = {
-	DEFINE_RES_MEM(0xa412fe90, 0x28),
-	DEFINE_RES_IRQ(evt2irq(0x400)),
-	DEFINE_RES_IRQ(evt2irq(0x420)),
-	DEFINE_RES_IRQ(evt2irq(0x440)),
-};
-
-static struct platform_device tmu0_device = {
-	.name		= "sh-tmu-sh3",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &tmu0_platform_data,
-	},
-	.resource	= tmu0_resources,
-	.num_resources	= ARRAY_SIZE(tmu0_resources),
-};
-
-static struct platform_device *sh7720_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&cmt_device,
-	&tmu0_device,
-	&rtc_device,
-	&usb_ohci_device,
-	&usbf_device,
-};
-
-static int __init sh7720_devices_setup(void)
-{
-	return platform_add_devices(sh7720_devices,
-				    ARRAY_SIZE(sh7720_devices));
-}
-arch_initcall(sh7720_devices_setup);
-
-static struct platform_device *sh7720_early_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&cmt_device,
-	&tmu0_device,
-};
-
-void __init plat_early_device_setup(void)
-{
-	sh_early_platform_add_devices(sh7720_early_devices,
-				   ARRAY_SIZE(sh7720_early_devices));
-}
-
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-	TMU0, TMU1, TMU2, RTC,
-	WDT, REF_RCMI, SIM,
-	IRQ0, IRQ1, IRQ2, IRQ3,
-	USBF_SPD, TMU_SUNI, IRQ5, IRQ4,
-	DMAC1, LCDC, SSL,
-	ADC, DMAC2, USBFI, CMT,
-	SCIF0, SCIF1,
-	PINT07, PINT815, TPU, IIC,
-	SIOF0, SIOF1, MMC, PCC,
-	USBHI, AFEIF,
-	H_UDI,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	/* IRQ0->5 are handled in setup-sh3.c */
-	INTC_VECT(TMU0, 0x400),       INTC_VECT(TMU1, 0x420),
-	INTC_VECT(TMU2, 0x440),       INTC_VECT(RTC, 0x480),
-	INTC_VECT(RTC, 0x4a0),	      INTC_VECT(RTC, 0x4c0),
-	INTC_VECT(SIM, 0x4e0),	      INTC_VECT(SIM, 0x500),
-	INTC_VECT(SIM, 0x520),	      INTC_VECT(SIM, 0x540),
-	INTC_VECT(WDT, 0x560),        INTC_VECT(REF_RCMI, 0x580),
-	/* H_UDI cannot be masked */  INTC_VECT(TMU_SUNI, 0x6c0),
-	INTC_VECT(USBF_SPD, 0x6e0),   INTC_VECT(DMAC1, 0x800),
-	INTC_VECT(DMAC1, 0x820),      INTC_VECT(DMAC1, 0x840),
-	INTC_VECT(DMAC1, 0x860),      INTC_VECT(LCDC, 0x900),
-#if defined(CONFIG_CPU_SUBTYPE_SH7720)
-	INTC_VECT(SSL, 0x980),
-#endif
-	INTC_VECT(USBFI, 0xa20),      INTC_VECT(USBFI, 0xa40),
-	INTC_VECT(USBHI, 0xa60),
-	INTC_VECT(DMAC2, 0xb80),      INTC_VECT(DMAC2, 0xba0),
-	INTC_VECT(ADC, 0xbe0),        INTC_VECT(SCIF0, 0xc00),
-	INTC_VECT(SCIF1, 0xc20),      INTC_VECT(PINT07, 0xc80),
-	INTC_VECT(PINT815, 0xca0),    INTC_VECT(SIOF0, 0xd00),
-	INTC_VECT(SIOF1, 0xd20),      INTC_VECT(TPU, 0xd80),
-	INTC_VECT(TPU, 0xda0),        INTC_VECT(TPU, 0xdc0),
-	INTC_VECT(TPU, 0xde0),        INTC_VECT(IIC, 0xe00),
-	INTC_VECT(MMC, 0xe80),        INTC_VECT(MMC, 0xea0),
-	INTC_VECT(MMC, 0xec0),        INTC_VECT(MMC, 0xee0),
-	INTC_VECT(CMT, 0xf00),        INTC_VECT(PCC, 0xf60),
-	INTC_VECT(AFEIF, 0xfe0),
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xA414FEE2UL, 0, 16, 4, /* IPRA */ { TMU0, TMU1, TMU2, RTC } },
-	{ 0xA414FEE4UL, 0, 16, 4, /* IPRB */ { WDT, REF_RCMI, SIM, 0 } },
-	{ 0xA4140016UL, 0, 16, 4, /* IPRC */ { IRQ3, IRQ2, IRQ1, IRQ0 } },
-	{ 0xA4140018UL, 0, 16, 4, /* IPRD */ { USBF_SPD, TMU_SUNI, IRQ5, IRQ4 } },
-	{ 0xA414001AUL, 0, 16, 4, /* IPRE */ { DMAC1, 0, LCDC, SSL } },
-	{ 0xA4080000UL, 0, 16, 4, /* IPRF */ { ADC, DMAC2, USBFI, CMT } },
-	{ 0xA4080002UL, 0, 16, 4, /* IPRG */ { SCIF0, SCIF1, 0, 0 } },
-	{ 0xA4080004UL, 0, 16, 4, /* IPRH */ { PINT07, PINT815, TPU, IIC } },
-	{ 0xA4080006UL, 0, 16, 4, /* IPRI */ { SIOF0, SIOF1, MMC, PCC } },
-	{ 0xA4080008UL, 0, 16, 4, /* IPRJ */ { 0, USBHI, 0, AFEIF } },
-};
-
-static DECLARE_INTC_DESC(intc_desc, "sh7720", vectors, NULL,
-		NULL, prio_registers, NULL);
-
-void __init plat_irq_setup(void)
-{
-	register_intc_controller(&intc_desc);
-	plat_irq_setup_sh3();
-}
diff --git a/arch/sh/kernel/cpu/sh3/swsusp.S b/arch/sh/kernel/cpu/sh3/swsusp.S
deleted file mode 100644
index dc111c4ccf2199..00000000000000
--- a/arch/sh/kernel/cpu/sh3/swsusp.S
+++ /dev/null
@@ -1,144 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * arch/sh/kernel/cpu/sh3/swsusp.S
- *
- * Copyright (C) 2009 Magnus Damm
- */
-#include <linux/sys.h>
-#include <linux/errno.h>
-#include <linux/linkage.h>
-#include <asm/asm-offsets.h>
-#include <asm/page.h>
-
-#define k0	r0
-#define k1	r1
-#define k2	r2
-#define k3	r3
-#define k4	r4
-
-! swsusp_arch_resume()
-! - copy restore_pblist pages
-! - restore registers from swsusp_arch_regs_cpu0
-
-ENTRY(swsusp_arch_resume)
-	mov.l	1f, r15
-	mov.l	2f, r4
-	mov.l	@r4, r4
-
-swsusp_copy_loop:
-	mov	r4, r0
-	cmp/eq	#0, r0
-	bt	swsusp_restore_regs
-
-	mov.l	@(PBE_ADDRESS, r4), r2
-	mov.l	@(PBE_ORIG_ADDRESS, r4), r5
-
-	mov	#(PAGE_SIZE >> 10), r3
-	shll8	r3
-	shlr2	r3 /* PAGE_SIZE / 16 */
-swsusp_copy_page:
-	dt	r3
-	mov.l	@r2+,r1   /*  16n+0 */
-	mov.l	r1,@r5
-	add	#4,r5
-	mov.l	@r2+,r1	  /*  16n+4 */
-	mov.l	r1,@r5
-	add	#4,r5
-	mov.l	@r2+,r1   /*  16n+8 */
-	mov.l	r1,@r5
-	add	#4,r5
-	mov.l	@r2+,r1   /*  16n+12 */
-	mov.l	r1,@r5
-	bf/s	swsusp_copy_page
-	 add	#4,r5
-
-	bra	swsusp_copy_loop
-	 mov.l	@(PBE_NEXT, r4), r4
-
-swsusp_restore_regs:
-	! BL=0: R7->R0 is bank0
-	mov.l	3f, r8
-	mov.l	4f, r5
-	jsr	@r5
-	 nop
-
-	! BL=1: R7->R0 is bank1
-	lds	k2, pr
-	ldc	k3, ssr
-
-	mov.l	@r15+, r0
-	mov.l	@r15+, r1
-	mov.l	@r15+, r2
-	mov.l	@r15+, r3
-	mov.l	@r15+, r4
-	mov.l	@r15+, r5
-	mov.l	@r15+, r6
-	mov.l	@r15+, r7
-
-	rte
-	 nop
-	! BL=0: R7->R0 is bank0
-
-	.align	2
-1:	.long	swsusp_arch_regs_cpu0
-2:	.long	restore_pblist
-3:	.long	0x20000000 ! RB=1
-4:	.long	restore_regs
-
-! swsusp_arch_suspend()
-! - prepare pc for resume, return from function without swsusp_save on resume
-! - save registers in swsusp_arch_regs_cpu0
-! - call swsusp_save write suspend image
-
-ENTRY(swsusp_arch_suspend)
-	sts	pr, r0		! save pr in r0
-	mov	r15, r2		! save sp in r2
-	mov	r8, r5		! save r8 in r5
-	stc	sr, r1
-	ldc	r1, ssr		! save sr in ssr
-	mov.l	1f, r1
-	ldc	r1, spc		! setup pc value for resuming
-	mov.l	5f, r15		! use swsusp_arch_regs_cpu0 as stack
-	mov.l	6f, r3
-	add	r3, r15		! save from top of structure
-
-	! BL=0: R7->R0 is bank0
-	mov.l	2f, r3		! get new SR value for bank1
-	mov	#0, r4
-	mov.l	7f, r1
-	jsr	@r1		! switch to bank1 and save bank1 r7->r0
-	 not	r4, r4
-
-	! BL=1: R7->R0 is bank1
-	stc	r2_bank, k0	! fetch old sp from r2_bank0
-	mov.l	3f, k4		! SR bits to clear in k4
-	mov.l	8f, k1
-	jsr	@k1		! switch to bank0 and save all regs
-	 stc	r0_bank, k3	! fetch old pr from r0_bank0
-
-	! BL=0: R7->R0 is bank0
-	mov	r2, r15		! restore old sp
-	mov	r5, r8		! restore old r8
-	stc	ssr, r1
-	ldc	r1, sr		! restore old sr
-	lds	r0, pr		! restore old pr
-	mov.l	4f, r0
-	jmp	@r0
-	 nop
-
-swsusp_call_save:
-	mov	r2, r15		! restore old sp
-	mov	r5, r8		! restore old r8
-	lds	r0, pr		! restore old pr
-	rts
-	 mov	#0, r0
-
-	.align	2
-1:	.long	swsusp_call_save
-2:	.long	0x20000000 ! RB=1
-3:	.long	0xdfffffff ! RB=0
-4:	.long	swsusp_save
-5:	.long	swsusp_arch_regs_cpu0
-6:	.long	SWSUSP_ARCH_REGS_SIZE
-7:	.long	save_low_regs
-8:	.long	save_regs
diff --git a/arch/sh/kernel/cpu/sh4/Makefile b/arch/sh/kernel/cpu/sh4/Makefile
deleted file mode 100644
index 00c16331e07e5b..00000000000000
--- a/arch/sh/kernel/cpu/sh4/Makefile
+++ /dev/null
@@ -1,37 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the Linux/SuperH SH-4 backends.
-#
-
-obj-y	:= probe.o common.o
-common-y	+= $(addprefix ../sh3/, entry.o ex.o)
-
-obj-$(CONFIG_HIBERNATION)		+= $(addprefix ../sh3/, swsusp.o)
-obj-$(CONFIG_SH_FPU)			+= fpu.o softfloat.o
-obj-$(CONFIG_SH_STORE_QUEUES)		+= sq.o
-
-# Perf events
-perf-$(CONFIG_CPU_SUBTYPE_SH7750)	:= perf_event.o
-perf-$(CONFIG_CPU_SUBTYPE_SH7750S)	:= perf_event.o
-perf-$(CONFIG_CPU_SUBTYPE_SH7091)	:= perf_event.o
-
-# CPU subtype setup
-obj-$(CONFIG_CPU_SUBTYPE_SH7750)	+= setup-sh7750.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7750R)	+= setup-sh7750.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7750S)	+= setup-sh7750.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7091)	+= setup-sh7750.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7751)	+= setup-sh7750.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7751R)	+= setup-sh7750.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7760)	+= setup-sh7760.o
-obj-$(CONFIG_CPU_SUBTYPE_SH4_202)	+= setup-sh4-202.o
-
-# Primary on-chip clocks (common)
-ifndef CONFIG_CPU_SH4A
-clock-$(CONFIG_CPU_SH4)			:= clock-sh4.o
-endif
-
-# Additional clocks by subtype
-clock-$(CONFIG_CPU_SUBTYPE_SH4_202)	+= clock-sh4-202.o
-
-obj-y					+= $(clock-y)
-obj-$(CONFIG_PERF_EVENTS)		+= $(perf-y)
diff --git a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c b/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
deleted file mode 100644
index c1cdef763cb256..00000000000000
--- a/arch/sh/kernel/cpu/sh4/clock-sh4-202.c
+++ /dev/null
@@ -1,174 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh4/clock-sh4-202.c
- *
- * Additional SH4-202 support for the clock framework
- *
- *  Copyright (C) 2005  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/err.h>
-#include <linux/io.h>
-#include <linux/clkdev.h>
-#include <asm/clock.h>
-#include <asm/freq.h>
-
-#define CPG2_FRQCR3	0xfe0a0018
-
-static int frqcr3_divisors[] = { 1, 2, 3, 4, 6, 8, 16 };
-static int frqcr3_values[]   = { 0, 1, 2, 3, 4, 5, 6  };
-
-static unsigned long emi_clk_recalc(struct clk *clk)
-{
-	int idx = __raw_readl(CPG2_FRQCR3) & 0x0007;
-	return clk->parent->rate / frqcr3_divisors[idx];
-}
-
-static inline int frqcr3_lookup(struct clk *clk, unsigned long rate)
-{
-	int divisor = clk->parent->rate / rate;
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(frqcr3_divisors); i++)
-		if (frqcr3_divisors[i] == divisor)
-			return frqcr3_values[i];
-
-	/* Safe fallback */
-	return 5;
-}
-
-static struct sh_clk_ops sh4202_emi_clk_ops = {
-	.recalc		= emi_clk_recalc,
-};
-
-static struct clk sh4202_emi_clk = {
-	.flags		= CLK_ENABLE_ON_INIT,
-	.ops		= &sh4202_emi_clk_ops,
-};
-
-static unsigned long femi_clk_recalc(struct clk *clk)
-{
-	int idx = (__raw_readl(CPG2_FRQCR3) >> 3) & 0x0007;
-	return clk->parent->rate / frqcr3_divisors[idx];
-}
-
-static struct sh_clk_ops sh4202_femi_clk_ops = {
-	.recalc		= femi_clk_recalc,
-};
-
-static struct clk sh4202_femi_clk = {
-	.flags		= CLK_ENABLE_ON_INIT,
-	.ops		= &sh4202_femi_clk_ops,
-};
-
-static void shoc_clk_init(struct clk *clk)
-{
-	int i;
-
-	/*
-	 * For some reason, the shoc_clk seems to be set to some really
-	 * insane value at boot (values outside of the allowable frequency
-	 * range for instance). We deal with this by scaling it back down
-	 * to something sensible just in case.
-	 *
-	 * Start scaling from the high end down until we find something
-	 * that passes rate verification..
-	 */
-	for (i = 0; i < ARRAY_SIZE(frqcr3_divisors); i++) {
-		int divisor = frqcr3_divisors[i];
-
-		if (clk->ops->set_rate(clk, clk->parent->rate / divisor) == 0)
-			break;
-	}
-
-	WARN_ON(i == ARRAY_SIZE(frqcr3_divisors));	/* Undefined clock */
-}
-
-static unsigned long shoc_clk_recalc(struct clk *clk)
-{
-	int idx = (__raw_readl(CPG2_FRQCR3) >> 6) & 0x0007;
-	return clk->parent->rate / frqcr3_divisors[idx];
-}
-
-static int shoc_clk_verify_rate(struct clk *clk, unsigned long rate)
-{
-	struct clk *bclk = clk_get(NULL, "bus_clk");
-	unsigned long bclk_rate = clk_get_rate(bclk);
-
-	clk_put(bclk);
-
-	if (rate > bclk_rate)
-		return 1;
-	if (rate > 66000000)
-		return 1;
-
-	return 0;
-}
-
-static int shoc_clk_set_rate(struct clk *clk, unsigned long rate)
-{
-	unsigned long frqcr3;
-	unsigned int tmp;
-
-	/* Make sure we have something sensible to switch to */
-	if (shoc_clk_verify_rate(clk, rate) != 0)
-		return -EINVAL;
-
-	tmp = frqcr3_lookup(clk, rate);
-
-	frqcr3 = __raw_readl(CPG2_FRQCR3);
-	frqcr3 &= ~(0x0007 << 6);
-	frqcr3 |= tmp << 6;
-	__raw_writel(frqcr3, CPG2_FRQCR3);
-
-	clk->rate = clk->parent->rate / frqcr3_divisors[tmp];
-
-	return 0;
-}
-
-static struct sh_clk_ops sh4202_shoc_clk_ops = {
-	.init		= shoc_clk_init,
-	.recalc		= shoc_clk_recalc,
-	.set_rate	= shoc_clk_set_rate,
-};
-
-static struct clk sh4202_shoc_clk = {
-	.flags		= CLK_ENABLE_ON_INIT,
-	.ops		= &sh4202_shoc_clk_ops,
-};
-
-static struct clk *sh4202_onchip_clocks[] = {
-	&sh4202_emi_clk,
-	&sh4202_femi_clk,
-	&sh4202_shoc_clk,
-};
-
-static struct clk_lookup lookups[] = {
-	/* main clocks */
-	CLKDEV_CON_ID("emi_clk", &sh4202_emi_clk),
-	CLKDEV_CON_ID("femi_clk", &sh4202_femi_clk),
-	CLKDEV_CON_ID("shoc_clk", &sh4202_shoc_clk),
-};
-
-int __init arch_clk_init(void)
-{
-	struct clk *clk;
-	int i, ret = 0;
-
-	cpg_clk_init();
-
-	clk = clk_get(NULL, "master_clk");
-	for (i = 0; i < ARRAY_SIZE(sh4202_onchip_clocks); i++) {
-		struct clk *clkp = sh4202_onchip_clocks[i];
-
-		clkp->parent = clk;
-		ret |= clk_register(clkp);
-	}
-
-	clk_put(clk);
-
-	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
-
-	return ret;
-}
diff --git a/arch/sh/kernel/cpu/sh4/clock-sh4.c b/arch/sh/kernel/cpu/sh4/clock-sh4.c
deleted file mode 100644
index ee3c5537a9d81a..00000000000000
--- a/arch/sh/kernel/cpu/sh4/clock-sh4.c
+++ /dev/null
@@ -1,77 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh4/clock-sh4.c
- *
- * Generic SH-4 support for the clock framework
- *
- *  Copyright (C) 2005  Paul Mundt
- *
- * FRQCR parsing hacked out of arch/sh/kernel/time.c
- *
- *  Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
- *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
- *  Copyright (C) 2002, 2003, 2004  Paul Mundt
- *  Copyright (C) 2002  M. R. Brown  <mrbrown@linux-sh.org>
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <asm/clock.h>
-#include <asm/freq.h>
-#include <asm/io.h>
-
-static int ifc_divisors[] = { 1, 2, 3, 4, 6, 8, 1, 1 };
-#define bfc_divisors ifc_divisors	/* Same */
-static int pfc_divisors[] = { 2, 3, 4, 6, 8, 2, 2, 2 };
-
-static void master_clk_init(struct clk *clk)
-{
-	clk->rate *= pfc_divisors[__raw_readw(FRQCR) & 0x0007];
-}
-
-static struct sh_clk_ops sh4_master_clk_ops = {
-	.init		= master_clk_init,
-};
-
-static unsigned long module_clk_recalc(struct clk *clk)
-{
-	int idx = (__raw_readw(FRQCR) & 0x0007);
-	return clk->parent->rate / pfc_divisors[idx];
-}
-
-static struct sh_clk_ops sh4_module_clk_ops = {
-	.recalc		= module_clk_recalc,
-};
-
-static unsigned long bus_clk_recalc(struct clk *clk)
-{
-	int idx = (__raw_readw(FRQCR) >> 3) & 0x0007;
-	return clk->parent->rate / bfc_divisors[idx];
-}
-
-static struct sh_clk_ops sh4_bus_clk_ops = {
-	.recalc		= bus_clk_recalc,
-};
-
-static unsigned long cpu_clk_recalc(struct clk *clk)
-{
-	int idx = (__raw_readw(FRQCR) >> 6) & 0x0007;
-	return clk->parent->rate / ifc_divisors[idx];
-}
-
-static struct sh_clk_ops sh4_cpu_clk_ops = {
-	.recalc		= cpu_clk_recalc,
-};
-
-static struct sh_clk_ops *sh4_clk_ops[] = {
-	&sh4_master_clk_ops,
-	&sh4_module_clk_ops,
-	&sh4_bus_clk_ops,
-	&sh4_cpu_clk_ops,
-};
-
-void __init arch_init_clk_ops(struct sh_clk_ops **ops, int idx)
-{
-	if (idx < ARRAY_SIZE(sh4_clk_ops))
-		*ops = sh4_clk_ops[idx];
-}
-
diff --git a/arch/sh/kernel/cpu/sh4/fpu.c b/arch/sh/kernel/cpu/sh4/fpu.c
deleted file mode 100644
index 03ffd8cdf54244..00000000000000
--- a/arch/sh/kernel/cpu/sh4/fpu.c
+++ /dev/null
@@ -1,425 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Save/restore floating point context for signal handlers.
- *
- * Copyright (C) 1999, 2000  Kaz Kojima & Niibe Yutaka
- * Copyright (C) 2006  ST Microelectronics Ltd. (denorm support)
- *
- * FIXME! These routines have not been tested for big endian case.
- */
-#include <linux/sched/signal.h>
-#include <linux/io.h>
-#include <cpu/fpu.h>
-#include <asm/processor.h>
-#include <asm/fpu.h>
-#include <asm/traps.h>
-
-/* The PR (precision) bit in the FP Status Register must be clear when
- * an frchg instruction is executed, otherwise the instruction is undefined.
- * Executing frchg with PR set causes a trap on some SH4 implementations.
- */
-
-#define FPSCR_RCHG 0x00000000
-extern unsigned long long float64_div(unsigned long long a,
-				      unsigned long long b);
-extern unsigned long int float32_div(unsigned long int a, unsigned long int b);
-extern unsigned long long float64_mul(unsigned long long a,
-				      unsigned long long b);
-extern unsigned long int float32_mul(unsigned long int a, unsigned long int b);
-extern unsigned long long float64_add(unsigned long long a,
-				      unsigned long long b);
-extern unsigned long int float32_add(unsigned long int a, unsigned long int b);
-extern unsigned long long float64_sub(unsigned long long a,
-				      unsigned long long b);
-extern unsigned long int float32_sub(unsigned long int a, unsigned long int b);
-extern unsigned long int float64_to_float32(unsigned long long a);
-static unsigned int fpu_exception_flags;
-
-/*
- * Save FPU registers onto task structure.
- */
-void save_fpu(struct task_struct *tsk)
-{
-	unsigned long dummy;
-
-	enable_fpu();
-	asm volatile ("sts.l	fpul, @-%0\n\t"
-		      "sts.l	fpscr, @-%0\n\t"
-		      "lds	%2, fpscr\n\t"
-		      "frchg\n\t"
-		      "fmov.s	fr15, @-%0\n\t"
-		      "fmov.s	fr14, @-%0\n\t"
-		      "fmov.s	fr13, @-%0\n\t"
-		      "fmov.s	fr12, @-%0\n\t"
-		      "fmov.s	fr11, @-%0\n\t"
-		      "fmov.s	fr10, @-%0\n\t"
-		      "fmov.s	fr9, @-%0\n\t"
-		      "fmov.s	fr8, @-%0\n\t"
-		      "fmov.s	fr7, @-%0\n\t"
-		      "fmov.s	fr6, @-%0\n\t"
-		      "fmov.s	fr5, @-%0\n\t"
-		      "fmov.s	fr4, @-%0\n\t"
-		      "fmov.s	fr3, @-%0\n\t"
-		      "fmov.s	fr2, @-%0\n\t"
-		      "fmov.s	fr1, @-%0\n\t"
-		      "fmov.s	fr0, @-%0\n\t"
-		      "frchg\n\t"
-		      "fmov.s	fr15, @-%0\n\t"
-		      "fmov.s	fr14, @-%0\n\t"
-		      "fmov.s	fr13, @-%0\n\t"
-		      "fmov.s	fr12, @-%0\n\t"
-		      "fmov.s	fr11, @-%0\n\t"
-		      "fmov.s	fr10, @-%0\n\t"
-		      "fmov.s	fr9, @-%0\n\t"
-		      "fmov.s	fr8, @-%0\n\t"
-		      "fmov.s	fr7, @-%0\n\t"
-		      "fmov.s	fr6, @-%0\n\t"
-		      "fmov.s	fr5, @-%0\n\t"
-		      "fmov.s	fr4, @-%0\n\t"
-		      "fmov.s	fr3, @-%0\n\t"
-		      "fmov.s	fr2, @-%0\n\t"
-		      "fmov.s	fr1, @-%0\n\t"
-		      "fmov.s	fr0, @-%0\n\t"
-		      "lds	%3, fpscr\n\t":"=r" (dummy)
-		      :"0"((char *)(&tsk->thread.xstate->hardfpu.status)),
-		      "r"(FPSCR_RCHG), "r"(FPSCR_INIT)
-		      :"memory");
-
-	disable_fpu();
-}
-
-void restore_fpu(struct task_struct *tsk)
-{
-	unsigned long dummy;
-
-	enable_fpu();
-	asm volatile ("lds	%2, fpscr\n\t"
-		      "fmov.s	@%0+, fr0\n\t"
-		      "fmov.s	@%0+, fr1\n\t"
-		      "fmov.s	@%0+, fr2\n\t"
-		      "fmov.s	@%0+, fr3\n\t"
-		      "fmov.s	@%0+, fr4\n\t"
-		      "fmov.s	@%0+, fr5\n\t"
-		      "fmov.s	@%0+, fr6\n\t"
-		      "fmov.s	@%0+, fr7\n\t"
-		      "fmov.s	@%0+, fr8\n\t"
-		      "fmov.s	@%0+, fr9\n\t"
-		      "fmov.s	@%0+, fr10\n\t"
-		      "fmov.s	@%0+, fr11\n\t"
-		      "fmov.s	@%0+, fr12\n\t"
-		      "fmov.s	@%0+, fr13\n\t"
-		      "fmov.s	@%0+, fr14\n\t"
-		      "fmov.s	@%0+, fr15\n\t"
-		      "frchg\n\t"
-		      "fmov.s	@%0+, fr0\n\t"
-		      "fmov.s	@%0+, fr1\n\t"
-		      "fmov.s	@%0+, fr2\n\t"
-		      "fmov.s	@%0+, fr3\n\t"
-		      "fmov.s	@%0+, fr4\n\t"
-		      "fmov.s	@%0+, fr5\n\t"
-		      "fmov.s	@%0+, fr6\n\t"
-		      "fmov.s	@%0+, fr7\n\t"
-		      "fmov.s	@%0+, fr8\n\t"
-		      "fmov.s	@%0+, fr9\n\t"
-		      "fmov.s	@%0+, fr10\n\t"
-		      "fmov.s	@%0+, fr11\n\t"
-		      "fmov.s	@%0+, fr12\n\t"
-		      "fmov.s	@%0+, fr13\n\t"
-		      "fmov.s	@%0+, fr14\n\t"
-		      "fmov.s	@%0+, fr15\n\t"
-		      "frchg\n\t"
-		      "lds.l	@%0+, fpscr\n\t"
-		      "lds.l	@%0+, fpul\n\t"
-		      :"=r" (dummy)
-		      :"0" (tsk->thread.xstate), "r" (FPSCR_RCHG)
-		      :"memory");
-	disable_fpu();
-}
-
-/**
- *      denormal_to_double - Given denormalized float number,
- *                           store double float
- *
- *      @fpu: Pointer to sh_fpu_hard structure
- *      @n: Index to FP register
- */
-static void denormal_to_double(struct sh_fpu_hard_struct *fpu, int n)
-{
-	unsigned long du, dl;
-	unsigned long x = fpu->fpul;
-	int exp = 1023 - 126;
-
-	if (x != 0 && (x & 0x7f800000) == 0) {
-		du = (x & 0x80000000);
-		while ((x & 0x00800000) == 0) {
-			x <<= 1;
-			exp--;
-		}
-		x &= 0x007fffff;
-		du |= (exp << 20) | (x >> 3);
-		dl = x << 29;
-
-		fpu->fp_regs[n] = du;
-		fpu->fp_regs[n + 1] = dl;
-	}
-}
-
-/**
- *	ieee_fpe_handler - Handle denormalized number exception
- *
- *	@regs: Pointer to register structure
- *
- *	Returns 1 when it's handled (should not cause exception).
- */
-static int ieee_fpe_handler(struct pt_regs *regs)
-{
-	unsigned short insn = *(unsigned short *)regs->pc;
-	unsigned short finsn;
-	unsigned long nextpc;
-	int nib[4] = {
-		(insn >> 12) & 0xf,
-		(insn >> 8) & 0xf,
-		(insn >> 4) & 0xf,
-		insn & 0xf
-	};
-
-	if (nib[0] == 0xb || (nib[0] == 0x4 && nib[2] == 0x0 && nib[3] == 0xb))
-		regs->pr = regs->pc + 4;  /* bsr & jsr */
-
-	if (nib[0] == 0xa || nib[0] == 0xb) {
-		/* bra & bsr */
-		nextpc = regs->pc + 4 + ((short)((insn & 0xfff) << 4) >> 3);
-		finsn = *(unsigned short *)(regs->pc + 2);
-	} else if (nib[0] == 0x8 && nib[1] == 0xd) {
-		/* bt/s */
-		if (regs->sr & 1)
-			nextpc = regs->pc + 4 + ((char)(insn & 0xff) << 1);
-		else
-			nextpc = regs->pc + 4;
-		finsn = *(unsigned short *)(regs->pc + 2);
-	} else if (nib[0] == 0x8 && nib[1] == 0xf) {
-		/* bf/s */
-		if (regs->sr & 1)
-			nextpc = regs->pc + 4;
-		else
-			nextpc = regs->pc + 4 + ((char)(insn & 0xff) << 1);
-		finsn = *(unsigned short *)(regs->pc + 2);
-	} else if (nib[0] == 0x4 && nib[3] == 0xb &&
-		   (nib[2] == 0x0 || nib[2] == 0x2)) {
-		/* jmp & jsr */
-		nextpc = regs->regs[nib[1]];
-		finsn = *(unsigned short *)(regs->pc + 2);
-	} else if (nib[0] == 0x0 && nib[3] == 0x3 &&
-		   (nib[2] == 0x0 || nib[2] == 0x2)) {
-		/* braf & bsrf */
-		nextpc = regs->pc + 4 + regs->regs[nib[1]];
-		finsn = *(unsigned short *)(regs->pc + 2);
-	} else if (insn == 0x000b) {
-		/* rts */
-		nextpc = regs->pr;
-		finsn = *(unsigned short *)(regs->pc + 2);
-	} else {
-		nextpc = regs->pc + instruction_size(insn);
-		finsn = insn;
-	}
-
-	if ((finsn & 0xf1ff) == 0xf0ad) {
-		/* fcnvsd */
-		struct task_struct *tsk = current;
-
-		if ((tsk->thread.xstate->hardfpu.fpscr & FPSCR_CAUSE_ERROR))
-			/* FPU error */
-			denormal_to_double(&tsk->thread.xstate->hardfpu,
-					   (finsn >> 8) & 0xf);
-		else
-			return 0;
-
-		regs->pc = nextpc;
-		return 1;
-	} else if ((finsn & 0xf00f) == 0xf002) {
-		/* fmul */
-		struct task_struct *tsk = current;
-		int fpscr;
-		int n, m, prec;
-		unsigned int hx, hy;
-
-		n = (finsn >> 8) & 0xf;
-		m = (finsn >> 4) & 0xf;
-		hx = tsk->thread.xstate->hardfpu.fp_regs[n];
-		hy = tsk->thread.xstate->hardfpu.fp_regs[m];
-		fpscr = tsk->thread.xstate->hardfpu.fpscr;
-		prec = fpscr & FPSCR_DBL_PRECISION;
-
-		if ((fpscr & FPSCR_CAUSE_ERROR)
-		    && (prec && ((hx & 0x7fffffff) < 0x00100000
-				 || (hy & 0x7fffffff) < 0x00100000))) {
-			long long llx, lly;
-
-			/* FPU error because of denormal (doubles) */
-			llx = ((long long)hx << 32)
-			    | tsk->thread.xstate->hardfpu.fp_regs[n + 1];
-			lly = ((long long)hy << 32)
-			    | tsk->thread.xstate->hardfpu.fp_regs[m + 1];
-			llx = float64_mul(llx, lly);
-			tsk->thread.xstate->hardfpu.fp_regs[n] = llx >> 32;
-			tsk->thread.xstate->hardfpu.fp_regs[n + 1] = llx & 0xffffffff;
-		} else if ((fpscr & FPSCR_CAUSE_ERROR)
-			   && (!prec && ((hx & 0x7fffffff) < 0x00800000
-					 || (hy & 0x7fffffff) < 0x00800000))) {
-			/* FPU error because of denormal (floats) */
-			hx = float32_mul(hx, hy);
-			tsk->thread.xstate->hardfpu.fp_regs[n] = hx;
-		} else
-			return 0;
-
-		regs->pc = nextpc;
-		return 1;
-	} else if ((finsn & 0xf00e) == 0xf000) {
-		/* fadd, fsub */
-		struct task_struct *tsk = current;
-		int fpscr;
-		int n, m, prec;
-		unsigned int hx, hy;
-
-		n = (finsn >> 8) & 0xf;
-		m = (finsn >> 4) & 0xf;
-		hx = tsk->thread.xstate->hardfpu.fp_regs[n];
-		hy = tsk->thread.xstate->hardfpu.fp_regs[m];
-		fpscr = tsk->thread.xstate->hardfpu.fpscr;
-		prec = fpscr & FPSCR_DBL_PRECISION;
-
-		if ((fpscr & FPSCR_CAUSE_ERROR)
-		    && (prec && ((hx & 0x7fffffff) < 0x00100000
-				 || (hy & 0x7fffffff) < 0x00100000))) {
-			long long llx, lly;
-
-			/* FPU error because of denormal (doubles) */
-			llx = ((long long)hx << 32)
-			    | tsk->thread.xstate->hardfpu.fp_regs[n + 1];
-			lly = ((long long)hy << 32)
-			    | tsk->thread.xstate->hardfpu.fp_regs[m + 1];
-			if ((finsn & 0xf00f) == 0xf000)
-				llx = float64_add(llx, lly);
-			else
-				llx = float64_sub(llx, lly);
-			tsk->thread.xstate->hardfpu.fp_regs[n] = llx >> 32;
-			tsk->thread.xstate->hardfpu.fp_regs[n + 1] = llx & 0xffffffff;
-		} else if ((fpscr & FPSCR_CAUSE_ERROR)
-			   && (!prec && ((hx & 0x7fffffff) < 0x00800000
-					 || (hy & 0x7fffffff) < 0x00800000))) {
-			/* FPU error because of denormal (floats) */
-			if ((finsn & 0xf00f) == 0xf000)
-				hx = float32_add(hx, hy);
-			else
-				hx = float32_sub(hx, hy);
-			tsk->thread.xstate->hardfpu.fp_regs[n] = hx;
-		} else
-			return 0;
-
-		regs->pc = nextpc;
-		return 1;
-	} else if ((finsn & 0xf003) == 0xf003) {
-		/* fdiv */
-		struct task_struct *tsk = current;
-		int fpscr;
-		int n, m, prec;
-		unsigned int hx, hy;
-
-		n = (finsn >> 8) & 0xf;
-		m = (finsn >> 4) & 0xf;
-		hx = tsk->thread.xstate->hardfpu.fp_regs[n];
-		hy = tsk->thread.xstate->hardfpu.fp_regs[m];
-		fpscr = tsk->thread.xstate->hardfpu.fpscr;
-		prec = fpscr & FPSCR_DBL_PRECISION;
-
-		if ((fpscr & FPSCR_CAUSE_ERROR)
-		    && (prec && ((hx & 0x7fffffff) < 0x00100000
-				 || (hy & 0x7fffffff) < 0x00100000))) {
-			long long llx, lly;
-
-			/* FPU error because of denormal (doubles) */
-			llx = ((long long)hx << 32)
-			    | tsk->thread.xstate->hardfpu.fp_regs[n + 1];
-			lly = ((long long)hy << 32)
-			    | tsk->thread.xstate->hardfpu.fp_regs[m + 1];
-
-			llx = float64_div(llx, lly);
-
-			tsk->thread.xstate->hardfpu.fp_regs[n] = llx >> 32;
-			tsk->thread.xstate->hardfpu.fp_regs[n + 1] = llx & 0xffffffff;
-		} else if ((fpscr & FPSCR_CAUSE_ERROR)
-			   && (!prec && ((hx & 0x7fffffff) < 0x00800000
-					 || (hy & 0x7fffffff) < 0x00800000))) {
-			/* FPU error because of denormal (floats) */
-			hx = float32_div(hx, hy);
-			tsk->thread.xstate->hardfpu.fp_regs[n] = hx;
-		} else
-			return 0;
-
-		regs->pc = nextpc;
-		return 1;
-	} else if ((finsn & 0xf0bd) == 0xf0bd) {
-		/* fcnvds - double to single precision convert */
-		struct task_struct *tsk = current;
-		int m;
-		unsigned int hx;
-
-		m = (finsn >> 8) & 0x7;
-		hx = tsk->thread.xstate->hardfpu.fp_regs[m];
-
-		if ((tsk->thread.xstate->hardfpu.fpscr & FPSCR_CAUSE_ERROR)
-			&& ((hx & 0x7fffffff) < 0x00100000)) {
-			/* subnormal double to float conversion */
-			long long llx;
-
-			llx = ((long long)tsk->thread.xstate->hardfpu.fp_regs[m] << 32)
-			    | tsk->thread.xstate->hardfpu.fp_regs[m + 1];
-
-			tsk->thread.xstate->hardfpu.fpul = float64_to_float32(llx);
-		} else
-			return 0;
-
-		regs->pc = nextpc;
-		return 1;
-	}
-
-	return 0;
-}
-
-void float_raise(unsigned int flags)
-{
-	fpu_exception_flags |= flags;
-}
-
-int float_rounding_mode(void)
-{
-	struct task_struct *tsk = current;
-	int roundingMode = FPSCR_ROUNDING_MODE(tsk->thread.xstate->hardfpu.fpscr);
-	return roundingMode;
-}
-
-BUILD_TRAP_HANDLER(fpu_error)
-{
-	struct task_struct *tsk = current;
-	TRAP_HANDLER_DECL;
-
-	__unlazy_fpu(tsk, regs);
-	fpu_exception_flags = 0;
-	if (ieee_fpe_handler(regs)) {
-		tsk->thread.xstate->hardfpu.fpscr &=
-		    ~(FPSCR_CAUSE_MASK | FPSCR_FLAG_MASK);
-		tsk->thread.xstate->hardfpu.fpscr |= fpu_exception_flags;
-		/* Set the FPSCR flag as well as cause bits - simply
-		 * replicate the cause */
-		tsk->thread.xstate->hardfpu.fpscr |= (fpu_exception_flags >> 10);
-		grab_fpu(regs);
-		restore_fpu(tsk);
-		task_thread_info(tsk)->status |= TS_USEDFPU;
-		if ((((tsk->thread.xstate->hardfpu.fpscr & FPSCR_ENABLE_MASK) >> 7) &
-		     (fpu_exception_flags >> 2)) == 0) {
-			return;
-		}
-	}
-
-	force_sig(SIGFPE);
-}
diff --git a/arch/sh/kernel/cpu/sh4/perf_event.c b/arch/sh/kernel/cpu/sh4/perf_event.c
deleted file mode 100644
index db5847bb733069..00000000000000
--- a/arch/sh/kernel/cpu/sh4/perf_event.c
+++ /dev/null
@@ -1,265 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Performance events support for SH7750-style performance counters
- *
- *  Copyright (C) 2009  Paul Mundt
- */
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/irq.h>
-#include <linux/perf_event.h>
-#include <asm/processor.h>
-
-#define PM_CR_BASE	0xff000084	/* 16-bit */
-#define PM_CTR_BASE	0xff100004	/* 32-bit */
-
-#define PMCR(n)		(PM_CR_BASE + ((n) * 0x04))
-#define PMCTRH(n)	(PM_CTR_BASE + 0x00 + ((n) * 0x08))
-#define PMCTRL(n)	(PM_CTR_BASE + 0x04 + ((n) * 0x08))
-
-#define PMCR_PMM_MASK	0x0000003f
-
-#define PMCR_CLKF	0x00000100
-#define PMCR_PMCLR	0x00002000
-#define PMCR_PMST	0x00004000
-#define PMCR_PMEN	0x00008000
-
-static struct sh_pmu sh7750_pmu;
-
-/*
- * There are a number of events supported by each counter (33 in total).
- * Since we have 2 counters, each counter will take the event code as it
- * corresponds to the PMCR PMM setting. Each counter can be configured
- * independently.
- *
- *	Event Code	Description
- *	----------	-----------
- *
- *	0x01		Operand read access
- *	0x02		Operand write access
- *	0x03		UTLB miss
- *	0x04		Operand cache read miss
- *	0x05		Operand cache write miss
- *	0x06		Instruction fetch (w/ cache)
- *	0x07		Instruction TLB miss
- *	0x08		Instruction cache miss
- *	0x09		All operand accesses
- *	0x0a		All instruction accesses
- *	0x0b		OC RAM operand access
- *	0x0d		On-chip I/O space access
- *	0x0e		Operand access (r/w)
- *	0x0f		Operand cache miss (r/w)
- *	0x10		Branch instruction
- *	0x11		Branch taken
- *	0x12		BSR/BSRF/JSR
- *	0x13		Instruction execution
- *	0x14		Instruction execution in parallel
- *	0x15		FPU Instruction execution
- *	0x16		Interrupt
- *	0x17		NMI
- *	0x18		trapa instruction execution
- *	0x19		UBCA match
- *	0x1a		UBCB match
- *	0x21		Instruction cache fill
- *	0x22		Operand cache fill
- *	0x23		Elapsed time
- *	0x24		Pipeline freeze by I-cache miss
- *	0x25		Pipeline freeze by D-cache miss
- *	0x27		Pipeline freeze by branch instruction
- *	0x28		Pipeline freeze by CPU register
- *	0x29		Pipeline freeze by FPU
- */
-
-static const int sh7750_general_events[] = {
-	[PERF_COUNT_HW_CPU_CYCLES]		= 0x0023,
-	[PERF_COUNT_HW_INSTRUCTIONS]		= 0x000a,
-	[PERF_COUNT_HW_CACHE_REFERENCES]	= 0x0006,	/* I-cache */
-	[PERF_COUNT_HW_CACHE_MISSES]		= 0x0008,	/* I-cache */
-	[PERF_COUNT_HW_BRANCH_INSTRUCTIONS]	= 0x0010,
-	[PERF_COUNT_HW_BRANCH_MISSES]		= -1,
-	[PERF_COUNT_HW_BUS_CYCLES]		= -1,
-};
-
-#define C(x)	PERF_COUNT_HW_CACHE_##x
-
-static const int sh7750_cache_events
-			[PERF_COUNT_HW_CACHE_MAX]
-			[PERF_COUNT_HW_CACHE_OP_MAX]
-			[PERF_COUNT_HW_CACHE_RESULT_MAX] =
-{
-	[ C(L1D) ] = {
-		[ C(OP_READ) ] = {
-			[ C(RESULT_ACCESS) ] = 0x0001,
-			[ C(RESULT_MISS)   ] = 0x0004,
-		},
-		[ C(OP_WRITE) ] = {
-			[ C(RESULT_ACCESS) ] = 0x0002,
-			[ C(RESULT_MISS)   ] = 0x0005,
-		},
-		[ C(OP_PREFETCH) ] = {
-			[ C(RESULT_ACCESS) ] = 0,
-			[ C(RESULT_MISS)   ] = 0,
-		},
-	},
-
-	[ C(L1I) ] = {
-		[ C(OP_READ) ] = {
-			[ C(RESULT_ACCESS) ] = 0x0006,
-			[ C(RESULT_MISS)   ] = 0x0008,
-		},
-		[ C(OP_WRITE) ] = {
-			[ C(RESULT_ACCESS) ] = -1,
-			[ C(RESULT_MISS)   ] = -1,
-		},
-		[ C(OP_PREFETCH) ] = {
-			[ C(RESULT_ACCESS) ] = 0,
-			[ C(RESULT_MISS)   ] = 0,
-		},
-	},
-
-	[ C(LL) ] = {
-		[ C(OP_READ) ] = {
-			[ C(RESULT_ACCESS) ] = 0,
-			[ C(RESULT_MISS)   ] = 0,
-		},
-		[ C(OP_WRITE) ] = {
-			[ C(RESULT_ACCESS) ] = 0,
-			[ C(RESULT_MISS)   ] = 0,
-		},
-		[ C(OP_PREFETCH) ] = {
-			[ C(RESULT_ACCESS) ] = 0,
-			[ C(RESULT_MISS)   ] = 0,
-		},
-	},
-
-	[ C(DTLB) ] = {
-		[ C(OP_READ) ] = {
-			[ C(RESULT_ACCESS) ] = 0,
-			[ C(RESULT_MISS)   ] = 0x0003,
-		},
-		[ C(OP_WRITE) ] = {
-			[ C(RESULT_ACCESS) ] = 0,
-			[ C(RESULT_MISS)   ] = 0,
-		},
-		[ C(OP_PREFETCH) ] = {
-			[ C(RESULT_ACCESS) ] = 0,
-			[ C(RESULT_MISS)   ] = 0,
-		},
-	},
-
-	[ C(ITLB) ] = {
-		[ C(OP_READ) ] = {
-			[ C(RESULT_ACCESS) ] = 0,
-			[ C(RESULT_MISS)   ] = 0x0007,
-		},
-		[ C(OP_WRITE) ] = {
-			[ C(RESULT_ACCESS) ] = -1,
-			[ C(RESULT_MISS)   ] = -1,
-		},
-		[ C(OP_PREFETCH) ] = {
-			[ C(RESULT_ACCESS) ] = -1,
-			[ C(RESULT_MISS)   ] = -1,
-		},
-	},
-
-	[ C(BPU) ] = {
-		[ C(OP_READ) ] = {
-			[ C(RESULT_ACCESS) ] = -1,
-			[ C(RESULT_MISS)   ] = -1,
-		},
-		[ C(OP_WRITE) ] = {
-			[ C(RESULT_ACCESS) ] = -1,
-			[ C(RESULT_MISS)   ] = -1,
-		},
-		[ C(OP_PREFETCH) ] = {
-			[ C(RESULT_ACCESS) ] = -1,
-			[ C(RESULT_MISS)   ] = -1,
-		},
-	},
-
-	[ C(NODE) ] = {
-		[ C(OP_READ) ] = {
-			[ C(RESULT_ACCESS) ] = -1,
-			[ C(RESULT_MISS)   ] = -1,
-		},
-		[ C(OP_WRITE) ] = {
-			[ C(RESULT_ACCESS) ] = -1,
-			[ C(RESULT_MISS)   ] = -1,
-		},
-		[ C(OP_PREFETCH) ] = {
-			[ C(RESULT_ACCESS) ] = -1,
-			[ C(RESULT_MISS)   ] = -1,
-		},
-	},
-};
-
-static int sh7750_event_map(int event)
-{
-	return sh7750_general_events[event];
-}
-
-static u64 sh7750_pmu_read(int idx)
-{
-	return (u64)((u64)(__raw_readl(PMCTRH(idx)) & 0xffff) << 32) |
-			   __raw_readl(PMCTRL(idx));
-}
-
-static void sh7750_pmu_disable(struct hw_perf_event *hwc, int idx)
-{
-	unsigned int tmp;
-
-	tmp = __raw_readw(PMCR(idx));
-	tmp &= ~(PMCR_PMM_MASK | PMCR_PMEN);
-	__raw_writew(tmp, PMCR(idx));
-}
-
-static void sh7750_pmu_enable(struct hw_perf_event *hwc, int idx)
-{
-	__raw_writew(__raw_readw(PMCR(idx)) | PMCR_PMCLR, PMCR(idx));
-	__raw_writew(hwc->config | PMCR_PMEN | PMCR_PMST, PMCR(idx));
-}
-
-static void sh7750_pmu_disable_all(void)
-{
-	int i;
-
-	for (i = 0; i < sh7750_pmu.num_events; i++)
-		__raw_writew(__raw_readw(PMCR(i)) & ~PMCR_PMEN, PMCR(i));
-}
-
-static void sh7750_pmu_enable_all(void)
-{
-	int i;
-
-	for (i = 0; i < sh7750_pmu.num_events; i++)
-		__raw_writew(__raw_readw(PMCR(i)) | PMCR_PMEN, PMCR(i));
-}
-
-static struct sh_pmu sh7750_pmu = {
-	.name		= "sh7750",
-	.num_events	= 2,
-	.event_map	= sh7750_event_map,
-	.max_events	= ARRAY_SIZE(sh7750_general_events),
-	.raw_event_mask	= PMCR_PMM_MASK,
-	.cache_events	= &sh7750_cache_events,
-	.read		= sh7750_pmu_read,
-	.disable	= sh7750_pmu_disable,
-	.enable		= sh7750_pmu_enable,
-	.disable_all	= sh7750_pmu_disable_all,
-	.enable_all	= sh7750_pmu_enable_all,
-};
-
-static int __init sh7750_pmu_init(void)
-{
-	/*
-	 * Make sure this CPU actually has perf counters.
-	 */
-	if (!(boot_cpu_data.flags & CPU_HAS_PERF_COUNTER)) {
-		pr_notice("HW perf events unsupported, software events only.\n");
-		return -ENODEV;
-	}
-
-	return register_sh_pmu(&sh7750_pmu);
-}
-early_initcall(sh7750_pmu_init);
diff --git a/arch/sh/kernel/cpu/sh4/probe.c b/arch/sh/kernel/cpu/sh4/probe.c
deleted file mode 100644
index ef4dd6295263dd..00000000000000
--- a/arch/sh/kernel/cpu/sh4/probe.c
+++ /dev/null
@@ -1,260 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh4/probe.c
- *
- * CPU Subtype Probing for SH-4.
- *
- * Copyright (C) 2001 - 2007  Paul Mundt
- * Copyright (C) 2003  Richard Curnow
- */
-#include <linux/init.h>
-#include <linux/io.h>
-#include <asm/processor.h>
-#include <asm/cache.h>
-
-void cpu_probe(void)
-{
-	unsigned long pvr, prr, cvr;
-	unsigned long size;
-
-	static unsigned long sizes[16] = {
-		[1] = (1 << 12),
-		[2] = (1 << 13),
-		[4] = (1 << 14),
-		[8] = (1 << 15),
-		[9] = (1 << 16)
-	};
-
-	pvr = (__raw_readl(CCN_PVR) >> 8) & 0xffffff;
-	prr = (__raw_readl(CCN_PRR) >> 4) & 0xff;
-	cvr = (__raw_readl(CCN_CVR));
-
-	/*
-	 * Setup some sane SH-4 defaults for the icache
-	 */
-	boot_cpu_data.icache.way_incr		= (1 << 13);
-	boot_cpu_data.icache.entry_shift	= 5;
-	boot_cpu_data.icache.sets		= 256;
-	boot_cpu_data.icache.ways		= 1;
-	boot_cpu_data.icache.linesz		= L1_CACHE_BYTES;
-
-	/*
-	 * And again for the dcache ..
-	 */
-	boot_cpu_data.dcache.way_incr		= (1 << 14);
-	boot_cpu_data.dcache.entry_shift	= 5;
-	boot_cpu_data.dcache.sets		= 512;
-	boot_cpu_data.dcache.ways		= 1;
-	boot_cpu_data.dcache.linesz		= L1_CACHE_BYTES;
-
-	/* We don't know the chip cut */
-	boot_cpu_data.cut_major = boot_cpu_data.cut_minor = -1;
-
-	/*
-	 * Setup some generic flags we can probe on SH-4A parts
-	 */
-	if (((pvr >> 16) & 0xff) == 0x10) {
-		boot_cpu_data.family = CPU_FAMILY_SH4A;
-
-		if ((cvr & 0x10000000) == 0) {
-			boot_cpu_data.flags |= CPU_HAS_DSP;
-			boot_cpu_data.family = CPU_FAMILY_SH4AL_DSP;
-		}
-
-		boot_cpu_data.flags |= CPU_HAS_LLSC | CPU_HAS_PERF_COUNTER;
-		boot_cpu_data.cut_major = pvr & 0x7f;
-
-		boot_cpu_data.icache.ways = 4;
-		boot_cpu_data.dcache.ways = 4;
-	} else {
-		/* And some SH-4 defaults.. */
-		boot_cpu_data.flags |= CPU_HAS_PTEA | CPU_HAS_FPU;
-		boot_cpu_data.family = CPU_FAMILY_SH4;
-	}
-
-	/* FPU detection works for almost everyone */
-	if ((cvr & 0x20000000))
-		boot_cpu_data.flags |= CPU_HAS_FPU;
-
-	/* Mask off the upper chip ID */
-	pvr &= 0xffff;
-
-	/*
-	 * Probe the underlying processor version/revision and
-	 * adjust cpu_data setup accordingly.
-	 */
-	switch (pvr) {
-	case 0x205:
-		boot_cpu_data.type = CPU_SH7750;
-		boot_cpu_data.flags |= CPU_HAS_P2_FLUSH_BUG |
-				       CPU_HAS_PERF_COUNTER;
-		break;
-	case 0x206:
-		boot_cpu_data.type = CPU_SH7750S;
-		boot_cpu_data.flags |= CPU_HAS_P2_FLUSH_BUG |
-				       CPU_HAS_PERF_COUNTER;
-		break;
-	case 0x1100:
-		boot_cpu_data.type = CPU_SH7751;
-		break;
-	case 0x2001:
-	case 0x2004:
-		boot_cpu_data.type = CPU_SH7770;
-		break;
-	case 0x2006:
-	case 0x200A:
-		if (prr == 0x61)
-			boot_cpu_data.type = CPU_SH7781;
-		else if (prr == 0xa1)
-			boot_cpu_data.type = CPU_SH7763;
-		else
-			boot_cpu_data.type = CPU_SH7780;
-
-		break;
-	case 0x3000:
-	case 0x3003:
-	case 0x3009:
-		boot_cpu_data.type = CPU_SH7343;
-		break;
-	case 0x3004:
-	case 0x3007:
-		boot_cpu_data.type = CPU_SH7785;
-		break;
-	case 0x4004:
-	case 0x4005:
-		boot_cpu_data.type = CPU_SH7786;
-		boot_cpu_data.flags |= CPU_HAS_PTEAEX | CPU_HAS_L2_CACHE;
-		break;
-	case 0x3008:
-		switch (prr) {
-		case 0x50:
-		case 0x51:
-			boot_cpu_data.type = CPU_SH7723;
-			boot_cpu_data.flags |= CPU_HAS_L2_CACHE;
-			break;
-		case 0x70:
-			boot_cpu_data.type = CPU_SH7366;
-			break;
-		case 0xa0:
-		case 0xa1:
-			boot_cpu_data.type = CPU_SH7722;
-			break;
-		}
-		break;
-	case 0x300b:
-		switch (prr) {
-		case 0x20:
-			boot_cpu_data.type = CPU_SH7724;
-			boot_cpu_data.flags |= CPU_HAS_L2_CACHE;
-			break;
-		case 0x10:
-		case 0x11:
-			boot_cpu_data.type = CPU_SH7757;
-			break;
-		case 0xd0:
-		case 0x40: /* yon-ten-go */
-			boot_cpu_data.type = CPU_SH7372;
-			break;
-		case 0xE0: /* 0x4E0 */
-			boot_cpu_data.type = CPU_SH7734; /* SH7733/SH7734 */
-			break;
-
-		}
-		break;
-	case 0x4000:	/* 1st cut */
-	case 0x4001:	/* 2nd cut */
-		boot_cpu_data.type = CPU_SHX3;
-		break;
-	case 0x700:
-		boot_cpu_data.type = CPU_SH4_501;
-		boot_cpu_data.flags &= ~CPU_HAS_FPU;
-		boot_cpu_data.icache.ways = 2;
-		boot_cpu_data.dcache.ways = 2;
-		break;
-	case 0x600:
-		boot_cpu_data.type = CPU_SH4_202;
-		boot_cpu_data.icache.ways = 2;
-		boot_cpu_data.dcache.ways = 2;
-		break;
-	case 0x500 ... 0x501:
-		switch (prr) {
-		case 0x10:
-			boot_cpu_data.type = CPU_SH7750R;
-			break;
-		case 0x11:
-			boot_cpu_data.type = CPU_SH7751R;
-			break;
-		case 0x50 ... 0x5f:
-			boot_cpu_data.type = CPU_SH7760;
-			break;
-		}
-
-		boot_cpu_data.icache.ways = 2;
-		boot_cpu_data.dcache.ways = 2;
-
-		break;
-	}
-
-	/*
-	 * On anything that's not a direct-mapped cache, look to the CVR
-	 * for I/D-cache specifics.
-	 */
-	if (boot_cpu_data.icache.ways > 1) {
-		size = sizes[(cvr >> 20) & 0xf];
-		boot_cpu_data.icache.way_incr	= (size >> 1);
-		boot_cpu_data.icache.sets	= (size >> 6);
-
-	}
-
-	/* And the rest of the D-cache */
-	if (boot_cpu_data.dcache.ways > 1) {
-		size = sizes[(cvr >> 16) & 0xf];
-		boot_cpu_data.dcache.way_incr	= (size >> 1);
-		boot_cpu_data.dcache.sets	= (size >> 6);
-	}
-
-	/*
-	 * SH-4A's have an optional PIPT L2.
-	 */
-	if (boot_cpu_data.flags & CPU_HAS_L2_CACHE) {
-		/*
-		 * Verify that it really has something hooked up, this
-		 * is the safety net for CPUs that have optional L2
-		 * support yet do not implement it.
-		 */
-		if ((cvr & 0xf) == 0)
-			boot_cpu_data.flags &= ~CPU_HAS_L2_CACHE;
-		else {
-			/*
-			 * Silicon and specifications have clearly never
-			 * met..
-			 */
-			cvr ^= 0xf;
-
-			/*
-			 * Size calculation is much more sensible
-			 * than it is for the L1.
-			 *
-			 * Sizes are 128KB, 256KB, 512KB, and 1MB.
-			 */
-			size = (cvr & 0xf) << 17;
-
-			boot_cpu_data.scache.way_incr		= (1 << 16);
-			boot_cpu_data.scache.entry_shift	= 5;
-			boot_cpu_data.scache.ways		= 4;
-			boot_cpu_data.scache.linesz		= L1_CACHE_BYTES;
-
-			boot_cpu_data.scache.entry_mask	=
-				(boot_cpu_data.scache.way_incr -
-				 boot_cpu_data.scache.linesz);
-
-			boot_cpu_data.scache.sets	= size /
-				(boot_cpu_data.scache.linesz *
-				 boot_cpu_data.scache.ways);
-
-			boot_cpu_data.scache.way_size	=
-				(boot_cpu_data.scache.sets *
-				 boot_cpu_data.scache.linesz);
-		}
-	}
-}
diff --git a/arch/sh/kernel/cpu/sh4/setup-sh4-202.c b/arch/sh/kernel/cpu/sh4/setup-sh4-202.c
deleted file mode 100644
index e6737f3d0df252..00000000000000
--- a/arch/sh/kernel/cpu/sh4/setup-sh4-202.c
+++ /dev/null
@@ -1,139 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH4-202 Setup
- *
- *  Copyright (C) 2006  Paul Mundt
- *  Copyright (C) 2009  Magnus Damm
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/serial_sci.h>
-#include <linux/sh_timer.h>
-#include <linux/sh_intc.h>
-#include <linux/io.h>
-#include <asm/platform_early.h>
-
-static struct plat_sci_port scif0_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xffe80000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x700)),
-	DEFINE_RES_IRQ(evt2irq(0x720)),
-	DEFINE_RES_IRQ(evt2irq(0x760)),
-	DEFINE_RES_IRQ(evt2irq(0x740)),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct sh_timer_config tmu0_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu0_resources[] = {
-	DEFINE_RES_MEM(0xffd80000, 0x30),
-	DEFINE_RES_IRQ(evt2irq(0x400)),
-	DEFINE_RES_IRQ(evt2irq(0x420)),
-	DEFINE_RES_IRQ(evt2irq(0x440)),
-};
-
-static struct platform_device tmu0_device = {
-	.name		= "sh-tmu",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &tmu0_platform_data,
-	},
-	.resource	= tmu0_resources,
-	.num_resources	= ARRAY_SIZE(tmu0_resources),
-};
-
-static struct platform_device *sh4202_devices[] __initdata = {
-	&scif0_device,
-	&tmu0_device,
-};
-
-static int __init sh4202_devices_setup(void)
-{
-	return platform_add_devices(sh4202_devices,
-				    ARRAY_SIZE(sh4202_devices));
-}
-arch_initcall(sh4202_devices_setup);
-
-static struct platform_device *sh4202_early_devices[] __initdata = {
-	&scif0_device,
-	&tmu0_device,
-};
-
-void __init plat_early_device_setup(void)
-{
-	sh_early_platform_add_devices(sh4202_early_devices,
-				   ARRAY_SIZE(sh4202_early_devices));
-}
-
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-	IRL0, IRL1, IRL2, IRL3, /* only IRLM mode supported */
-	HUDI, TMU0, TMU1, TMU2, RTC, SCIF, WDT,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_VECT(HUDI, 0x600),
-	INTC_VECT(TMU0, 0x400), INTC_VECT(TMU1, 0x420),
-	INTC_VECT(TMU2, 0x440), INTC_VECT(TMU2, 0x460),
-	INTC_VECT(RTC, 0x480), INTC_VECT(RTC, 0x4a0),
-	INTC_VECT(RTC, 0x4c0),
-	INTC_VECT(SCIF, 0x700), INTC_VECT(SCIF, 0x720),
-	INTC_VECT(SCIF, 0x740), INTC_VECT(SCIF, 0x760),
-	INTC_VECT(WDT, 0x560),
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xffd00004, 0, 16, 4, /* IPRA */ { TMU0, TMU1, TMU2, RTC } },
-	{ 0xffd00008, 0, 16, 4, /* IPRB */ { WDT, 0, 0, 0 } },
-	{ 0xffd0000c, 0, 16, 4, /* IPRC */ { 0, 0, SCIF, HUDI } },
-	{ 0xffd00010, 0, 16, 4, /* IPRD */ { IRL0, IRL1, IRL2, IRL3 } },
-};
-
-static DECLARE_INTC_DESC(intc_desc, "sh4-202", vectors, NULL,
-			 NULL, prio_registers, NULL);
-
-static struct intc_vect vectors_irlm[] __initdata = {
-	INTC_VECT(IRL0, 0x240), INTC_VECT(IRL1, 0x2a0),
-	INTC_VECT(IRL2, 0x300), INTC_VECT(IRL3, 0x360),
-};
-
-static DECLARE_INTC_DESC(intc_desc_irlm, "sh4-202_irlm", vectors_irlm, NULL,
-			 NULL, prio_registers, NULL);
-
-void __init plat_irq_setup(void)
-{
-	register_intc_controller(&intc_desc);
-}
-
-#define INTC_ICR	0xffd00000UL
-#define INTC_ICR_IRLM   (1<<7)
-
-void __init plat_irq_setup_pins(int mode)
-{
-	switch (mode) {
-	case IRQ_MODE_IRQ: /* individual interrupt mode for IRL3-0 */
-		__raw_writew(__raw_readw(INTC_ICR) | INTC_ICR_IRLM, INTC_ICR);
-		register_intc_controller(&intc_desc_irlm);
-		break;
-	default:
-		BUG();
-	}
-}
diff --git a/arch/sh/kernel/cpu/sh4/setup-sh7750.c b/arch/sh/kernel/cpu/sh4/setup-sh7750.c
deleted file mode 100644
index 19c8f1d69071c3..00000000000000
--- a/arch/sh/kernel/cpu/sh4/setup-sh7750.c
+++ /dev/null
@@ -1,359 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7091/SH7750/SH7750S/SH7750R/SH7751/SH7751R Setup
- *
- *  Copyright (C) 2006  Paul Mundt
- *  Copyright (C) 2006  Jamie Lenehan
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/io.h>
-#include <linux/sh_timer.h>
-#include <linux/sh_intc.h>
-#include <linux/serial_sci.h>
-#include <generated/machtypes.h>
-#include <asm/platform_early.h>
-
-static struct resource rtc_resources[] = {
-	[0] = {
-		.start	= 0xffc80000,
-		.end	= 0xffc80000 + 0x58 - 1,
-		.flags	= IORESOURCE_IO,
-	},
-	[1] = {
-		/* Shared Period/Carry/Alarm IRQ */
-		.start	= evt2irq(0x480),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device rtc_device = {
-	.name		= "sh-rtc",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(rtc_resources),
-	.resource	= rtc_resources,
-};
-
-static struct plat_sci_port sci_platform_data = {
-	.type		= PORT_SCI,
-};
-
-static struct resource sci_resources[] = {
-	DEFINE_RES_MEM(0xffe00000, 0x20),
-	DEFINE_RES_IRQ(evt2irq(0x4e0)),
-};
-
-static struct platform_device sci_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= sci_resources,
-	.num_resources	= ARRAY_SIZE(sci_resources),
-	.dev		= {
-		.platform_data	= &sci_platform_data,
-	},
-};
-
-static struct plat_sci_port scif_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif_resources[] = {
-	DEFINE_RES_MEM(0xffe80000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x700)),
-};
-
-static struct platform_device scif_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif_resources,
-	.num_resources	= ARRAY_SIZE(scif_resources),
-	.dev		= {
-		.platform_data	= &scif_platform_data,
-	},
-};
-
-static struct sh_timer_config tmu0_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu0_resources[] = {
-	DEFINE_RES_MEM(0xffd80000, 0x30),
-	DEFINE_RES_IRQ(evt2irq(0x400)),
-	DEFINE_RES_IRQ(evt2irq(0x420)),
-	DEFINE_RES_IRQ(evt2irq(0x440)),
-};
-
-static struct platform_device tmu0_device = {
-	.name		= "sh-tmu",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &tmu0_platform_data,
-	},
-	.resource	= tmu0_resources,
-	.num_resources	= ARRAY_SIZE(tmu0_resources),
-};
-
-/* SH7750R, SH7751 and SH7751R all have two extra timer channels */
-#if defined(CONFIG_CPU_SUBTYPE_SH7750R) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7751) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7751R)
-
-static struct sh_timer_config tmu1_platform_data = {
-	.channels_mask = 3,
-};
-
-static struct resource tmu1_resources[] = {
-	DEFINE_RES_MEM(0xfe100000, 0x20),
-	DEFINE_RES_IRQ(evt2irq(0xb00)),
-	DEFINE_RES_IRQ(evt2irq(0xb80)),
-};
-
-static struct platform_device tmu1_device = {
-	.name		= "sh-tmu",
-	.id		= 1,
-	.dev = {
-		.platform_data	= &tmu1_platform_data,
-	},
-	.resource	= tmu1_resources,
-	.num_resources	= ARRAY_SIZE(tmu1_resources),
-};
-
-#endif
-
-static struct platform_device *sh7750_devices[] __initdata = {
-	&rtc_device,
-	&tmu0_device,
-#if defined(CONFIG_CPU_SUBTYPE_SH7750R) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7751) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7751R)
-	&tmu1_device,
-#endif
-};
-
-static int __init sh7750_devices_setup(void)
-{
-	if (mach_is_rts7751r2d()) {
-		platform_device_register(&scif_device);
-	} else {
-		platform_device_register(&sci_device);
-		platform_device_register(&scif_device);
-	}
-
-	return platform_add_devices(sh7750_devices,
-				    ARRAY_SIZE(sh7750_devices));
-}
-arch_initcall(sh7750_devices_setup);
-
-static struct platform_device *sh7750_early_devices[] __initdata = {
-	&tmu0_device,
-#if defined(CONFIG_CPU_SUBTYPE_SH7750R) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7751) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7751R)
-	&tmu1_device,
-#endif
-};
-
-void __init plat_early_device_setup(void)
-{
-	struct platform_device *dev[1];
-
-	if (mach_is_rts7751r2d()) {
-		scif_platform_data.scscr |= SCSCR_CKE1;
-		dev[0] = &scif_device;
-		sh_early_platform_add_devices(dev, 1);
-	} else {
-		dev[0] = &sci_device;
-		sh_early_platform_add_devices(dev, 1);
-		dev[0] = &scif_device;
-		sh_early_platform_add_devices(dev, 1);
-	}
-
-	sh_early_platform_add_devices(sh7750_early_devices,
-				   ARRAY_SIZE(sh7750_early_devices));
-}
-
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-	IRL0, IRL1, IRL2, IRL3, /* only IRLM mode supported */
-	HUDI, GPIOI, DMAC,
-	PCIC0_PCISERR, PCIC1_PCIERR, PCIC1_PCIPWDWN, PCIC1_PCIPWON,
-	PCIC1_PCIDMA0, PCIC1_PCIDMA1, PCIC1_PCIDMA2, PCIC1_PCIDMA3,
-	TMU3, TMU4, TMU0, TMU1, TMU2, RTC, SCI1, SCIF, WDT, REF,
-
-	/* interrupt groups */
-	PCIC1,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_VECT(HUDI, 0x600), INTC_VECT(GPIOI, 0x620),
-	INTC_VECT(TMU0, 0x400), INTC_VECT(TMU1, 0x420),
-	INTC_VECT(TMU2, 0x440), INTC_VECT(TMU2, 0x460),
-	INTC_VECT(RTC, 0x480), INTC_VECT(RTC, 0x4a0),
-	INTC_VECT(RTC, 0x4c0),
-	INTC_VECT(SCI1, 0x4e0), INTC_VECT(SCI1, 0x500),
-	INTC_VECT(SCI1, 0x520), INTC_VECT(SCI1, 0x540),
-	INTC_VECT(SCIF, 0x700), INTC_VECT(SCIF, 0x720),
-	INTC_VECT(SCIF, 0x740), INTC_VECT(SCIF, 0x760),
-	INTC_VECT(WDT, 0x560),
-	INTC_VECT(REF, 0x580), INTC_VECT(REF, 0x5a0),
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xffd00004, 0, 16, 4, /* IPRA */ { TMU0, TMU1, TMU2, RTC } },
-	{ 0xffd00008, 0, 16, 4, /* IPRB */ { WDT, REF, SCI1, 0 } },
-	{ 0xffd0000c, 0, 16, 4, /* IPRC */ { GPIOI, DMAC, SCIF, HUDI } },
-	{ 0xffd00010, 0, 16, 4, /* IPRD */ { IRL0, IRL1, IRL2, IRL3 } },
-	{ 0xfe080000, 0, 32, 4, /* INTPRI00 */ { 0, 0, 0, 0,
-						 TMU4, TMU3,
-						 PCIC1, PCIC0_PCISERR } },
-};
-
-static DECLARE_INTC_DESC(intc_desc, "sh7750", vectors, NULL,
-			 NULL, prio_registers, NULL);
-
-/* SH7750, SH7750S, SH7751 and SH7091 all have 4-channel DMA controllers */
-#if defined(CONFIG_CPU_SUBTYPE_SH7750) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7750S) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7751) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7091)
-static struct intc_vect vectors_dma4[] __initdata = {
-	INTC_VECT(DMAC, 0x640), INTC_VECT(DMAC, 0x660),
-	INTC_VECT(DMAC, 0x680), INTC_VECT(DMAC, 0x6a0),
-	INTC_VECT(DMAC, 0x6c0),
-};
-
-static DECLARE_INTC_DESC(intc_desc_dma4, "sh7750_dma4",
-			 vectors_dma4, NULL,
-			 NULL, prio_registers, NULL);
-#endif
-
-/* SH7750R and SH7751R both have 8-channel DMA controllers */
-#if defined(CONFIG_CPU_SUBTYPE_SH7750R) || defined(CONFIG_CPU_SUBTYPE_SH7751R)
-static struct intc_vect vectors_dma8[] __initdata = {
-	INTC_VECT(DMAC, 0x640), INTC_VECT(DMAC, 0x660),
-	INTC_VECT(DMAC, 0x680), INTC_VECT(DMAC, 0x6a0),
-	INTC_VECT(DMAC, 0x780), INTC_VECT(DMAC, 0x7a0),
-	INTC_VECT(DMAC, 0x7c0), INTC_VECT(DMAC, 0x7e0),
-	INTC_VECT(DMAC, 0x6c0),
-};
-
-static DECLARE_INTC_DESC(intc_desc_dma8, "sh7750_dma8",
-			 vectors_dma8, NULL,
-			 NULL, prio_registers, NULL);
-#endif
-
-/* SH7750R, SH7751 and SH7751R all have two extra timer channels */
-#if defined(CONFIG_CPU_SUBTYPE_SH7750R) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7751) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7751R)
-static struct intc_vect vectors_tmu34[] __initdata = {
-	INTC_VECT(TMU3, 0xb00), INTC_VECT(TMU4, 0xb80),
-};
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xfe080040, 0xfe080060, 32, /* INTMSK00 / INTMSKCLR00 */
-	  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	    0, 0, 0, 0, 0, 0, TMU4, TMU3,
-	    PCIC1_PCIERR, PCIC1_PCIPWDWN, PCIC1_PCIPWON,
-	    PCIC1_PCIDMA0, PCIC1_PCIDMA1, PCIC1_PCIDMA2,
-	    PCIC1_PCIDMA3, PCIC0_PCISERR } },
-};
-
-static DECLARE_INTC_DESC(intc_desc_tmu34, "sh7750_tmu34",
-			 vectors_tmu34, NULL,
-			 mask_registers, prio_registers, NULL);
-#endif
-
-/* SH7750S, SH7750R, SH7751 and SH7751R all have IRLM priority registers */
-static struct intc_vect vectors_irlm[] __initdata = {
-	INTC_VECT(IRL0, 0x240), INTC_VECT(IRL1, 0x2a0),
-	INTC_VECT(IRL2, 0x300), INTC_VECT(IRL3, 0x360),
-};
-
-static DECLARE_INTC_DESC(intc_desc_irlm, "sh7750_irlm", vectors_irlm, NULL,
-			 NULL, prio_registers, NULL);
-
-/* SH7751 and SH7751R both have PCI */
-#if defined(CONFIG_CPU_SUBTYPE_SH7751) || defined(CONFIG_CPU_SUBTYPE_SH7751R)
-static struct intc_vect vectors_pci[] __initdata = {
-	INTC_VECT(PCIC0_PCISERR, 0xa00), INTC_VECT(PCIC1_PCIERR, 0xae0),
-	INTC_VECT(PCIC1_PCIPWDWN, 0xac0), INTC_VECT(PCIC1_PCIPWON, 0xaa0),
-	INTC_VECT(PCIC1_PCIDMA0, 0xa80), INTC_VECT(PCIC1_PCIDMA1, 0xa60),
-	INTC_VECT(PCIC1_PCIDMA2, 0xa40), INTC_VECT(PCIC1_PCIDMA3, 0xa20),
-};
-
-static struct intc_group groups_pci[] __initdata = {
-	INTC_GROUP(PCIC1, PCIC1_PCIERR, PCIC1_PCIPWDWN, PCIC1_PCIPWON,
-		   PCIC1_PCIDMA0, PCIC1_PCIDMA1, PCIC1_PCIDMA2, PCIC1_PCIDMA3),
-};
-
-static DECLARE_INTC_DESC(intc_desc_pci, "sh7750_pci", vectors_pci, groups_pci,
-			 mask_registers, prio_registers, NULL);
-#endif
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7750) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7750S) || \
-	defined(CONFIG_CPU_SUBTYPE_SH7091)
-void __init plat_irq_setup(void)
-{
-	/*
-	 * same vectors for SH7750, SH7750S and SH7091 except for IRLM,
-	 * see below..
-	 */
-	register_intc_controller(&intc_desc);
-	register_intc_controller(&intc_desc_dma4);
-}
-#endif
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7750R)
-void __init plat_irq_setup(void)
-{
-	register_intc_controller(&intc_desc);
-	register_intc_controller(&intc_desc_dma8);
-	register_intc_controller(&intc_desc_tmu34);
-}
-#endif
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7751)
-void __init plat_irq_setup(void)
-{
-	register_intc_controller(&intc_desc);
-	register_intc_controller(&intc_desc_dma4);
-	register_intc_controller(&intc_desc_tmu34);
-	register_intc_controller(&intc_desc_pci);
-}
-#endif
-
-#if defined(CONFIG_CPU_SUBTYPE_SH7751R)
-void __init plat_irq_setup(void)
-{
-	register_intc_controller(&intc_desc);
-	register_intc_controller(&intc_desc_dma8);
-	register_intc_controller(&intc_desc_tmu34);
-	register_intc_controller(&intc_desc_pci);
-}
-#endif
-
-#define INTC_ICR	0xffd00000UL
-#define INTC_ICR_IRLM   (1<<7)
-
-void __init plat_irq_setup_pins(int mode)
-{
-#if defined(CONFIG_CPU_SUBTYPE_SH7750) || defined(CONFIG_CPU_SUBTYPE_SH7091)
-	BUG(); /* impossible to mask interrupts on SH7750 and SH7091 */
-	return;
-#endif
-
-	switch (mode) {
-	case IRQ_MODE_IRQ: /* individual interrupt mode for IRL3-0 */
-		__raw_writew(__raw_readw(INTC_ICR) | INTC_ICR_IRLM, INTC_ICR);
-		register_intc_controller(&intc_desc_irlm);
-		break;
-	default:
-		BUG();
-	}
-}
diff --git a/arch/sh/kernel/cpu/sh4/setup-sh7760.c b/arch/sh/kernel/cpu/sh4/setup-sh7760.c
deleted file mode 100644
index 14212f5d803cd4..00000000000000
--- a/arch/sh/kernel/cpu/sh4/setup-sh7760.c
+++ /dev/null
@@ -1,297 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7760 Setup
- *
- *  Copyright (C) 2006  Paul Mundt
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/sh_timer.h>
-#include <linux/sh_intc.h>
-#include <linux/serial_sci.h>
-#include <linux/io.h>
-#include <asm/platform_early.h>
-
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-	IRL0, IRL1, IRL2, IRL3,
-	HUDI, GPIOI, DMAC,
-	IRQ4, IRQ5, IRQ6, IRQ7,
-	HCAN20, HCAN21,
-	SSI0, SSI1,
-	HAC0, HAC1,
-	I2C0, I2C1,
-	USB, LCDC,
-	DMABRG0, DMABRG1, DMABRG2,
-	SCIF0_ERI, SCIF0_RXI, SCIF0_BRI, SCIF0_TXI,
-	SCIF1_ERI, SCIF1_RXI, SCIF1_BRI, SCIF1_TXI,
-	SCIF2_ERI, SCIF2_RXI, SCIF2_BRI, SCIF2_TXI,
-	SIM_ERI, SIM_RXI, SIM_TXI, SIM_TEI,
-	HSPI,
-	MMCIF0, MMCIF1, MMCIF2, MMCIF3,
-	MFI, ADC, CMT,
-	TMU0, TMU1, TMU2,
-	WDT, REF,
-
-	/* interrupt groups */
-	DMABRG, SCIF0, SCIF1, SCIF2, SIM, MMCIF,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_VECT(HUDI, 0x600), INTC_VECT(GPIOI, 0x620),
-	INTC_VECT(DMAC, 0x640), INTC_VECT(DMAC, 0x660),
-	INTC_VECT(DMAC, 0x680), INTC_VECT(DMAC, 0x6a0),
-	INTC_VECT(DMAC, 0x780), INTC_VECT(DMAC, 0x7a0),
-	INTC_VECT(DMAC, 0x7c0), INTC_VECT(DMAC, 0x7e0),
-	INTC_VECT(DMAC, 0x6c0),
-	INTC_VECT(IRQ4, 0x800), INTC_VECT(IRQ5, 0x820),
-	INTC_VECT(IRQ6, 0x840), INTC_VECT(IRQ6, 0x860),
-	INTC_VECT(HCAN20, 0x900), INTC_VECT(HCAN21, 0x920),
-	INTC_VECT(SSI0, 0x940), INTC_VECT(SSI1, 0x960),
-	INTC_VECT(HAC0, 0x980), INTC_VECT(HAC1, 0x9a0),
-	INTC_VECT(I2C0, 0x9c0), INTC_VECT(I2C1, 0x9e0),
-	INTC_VECT(USB, 0xa00), INTC_VECT(LCDC, 0xa20),
-	INTC_VECT(DMABRG0, 0xa80), INTC_VECT(DMABRG1, 0xaa0),
-	INTC_VECT(DMABRG2, 0xac0),
-	INTC_VECT(SCIF0_ERI, 0x880), INTC_VECT(SCIF0_RXI, 0x8a0),
-	INTC_VECT(SCIF0_BRI, 0x8c0), INTC_VECT(SCIF0_TXI, 0x8e0),
-	INTC_VECT(SCIF1_ERI, 0xb00), INTC_VECT(SCIF1_RXI, 0xb20),
-	INTC_VECT(SCIF1_BRI, 0xb40), INTC_VECT(SCIF1_TXI, 0xb60),
-	INTC_VECT(SCIF2_ERI, 0xb80), INTC_VECT(SCIF2_RXI, 0xba0),
-	INTC_VECT(SCIF2_BRI, 0xbc0), INTC_VECT(SCIF2_TXI, 0xbe0),
-	INTC_VECT(SIM_ERI, 0xc00), INTC_VECT(SIM_RXI, 0xc20),
-	INTC_VECT(SIM_TXI, 0xc40), INTC_VECT(SIM_TEI, 0xc60),
-	INTC_VECT(HSPI, 0xc80),
-	INTC_VECT(MMCIF0, 0xd00), INTC_VECT(MMCIF1, 0xd20),
-	INTC_VECT(MMCIF2, 0xd40), INTC_VECT(MMCIF3, 0xd60),
-	INTC_VECT(MFI, 0xe80), /* 0xf80 according to data sheet */
-	INTC_VECT(ADC, 0xf80), INTC_VECT(CMT, 0xfa0),
-	INTC_VECT(TMU0, 0x400), INTC_VECT(TMU1, 0x420),
-	INTC_VECT(TMU2, 0x440), INTC_VECT(TMU2, 0x460),
-	INTC_VECT(WDT, 0x560),
-	INTC_VECT(REF, 0x580), INTC_VECT(REF, 0x5a0),
-};
-
-static struct intc_group groups[] __initdata = {
-	INTC_GROUP(DMABRG, DMABRG0, DMABRG1, DMABRG2),
-	INTC_GROUP(SCIF0, SCIF0_ERI, SCIF0_RXI, SCIF0_BRI, SCIF0_TXI),
-	INTC_GROUP(SCIF1, SCIF1_ERI, SCIF1_RXI, SCIF1_BRI, SCIF1_TXI),
-	INTC_GROUP(SCIF2, SCIF2_ERI, SCIF2_RXI, SCIF2_BRI, SCIF2_TXI),
-	INTC_GROUP(SIM, SIM_ERI, SIM_RXI, SIM_TXI, SIM_TEI),
-	INTC_GROUP(MMCIF, MMCIF0, MMCIF1, MMCIF2, MMCIF3),
-};
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xfe080040, 0xfe080060, 32, /* INTMSK00 / INTMSKCLR00 */
-	  { IRQ4, IRQ5, IRQ6, IRQ7, 0, 0, HCAN20, HCAN21,
-	    SSI0, SSI1, HAC0, HAC1, I2C0, I2C1, USB, LCDC,
-	    0, DMABRG0, DMABRG1, DMABRG2,
-	    SCIF0_ERI, SCIF0_RXI, SCIF0_BRI, SCIF0_TXI,
-	    SCIF1_ERI, SCIF1_RXI, SCIF1_BRI, SCIF1_TXI,
-	    SCIF2_ERI, SCIF2_RXI, SCIF2_BRI, SCIF2_TXI, } },
-	{ 0xfe080044, 0xfe080064, 32, /* INTMSK04 / INTMSKCLR04 */
-	  { 0, 0, 0, 0, 0, 0, 0, 0,
-	    SIM_ERI, SIM_RXI, SIM_TXI, SIM_TEI,
-	    HSPI, MMCIF0, MMCIF1, MMCIF2,
-	    MMCIF3, 0, 0, 0, 0, 0, 0, 0,
-	    0, MFI, 0, 0, 0, 0, ADC, CMT, } },
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xffd00004, 0, 16, 4, /* IPRA */ { TMU0, TMU1, TMU2 } },
-	{ 0xffd00008, 0, 16, 4, /* IPRB */ { WDT, REF, 0, 0 } },
-	{ 0xffd0000c, 0, 16, 4, /* IPRC */ { GPIOI, DMAC, 0, HUDI } },
-	{ 0xffd00010, 0, 16, 4, /* IPRD */ { IRL0, IRL1, IRL2, IRL3 } },
-	{ 0xfe080000, 0, 32, 4, /* INTPRI00 */ { IRQ4, IRQ5, IRQ6, IRQ7 } },
-	{ 0xfe080004, 0, 32, 4, /* INTPRI04 */ { HCAN20, HCAN21, SSI0, SSI1,
-						 HAC0, HAC1, I2C0, I2C1 } },
-	{ 0xfe080008, 0, 32, 4, /* INTPRI08 */ { USB, LCDC, DMABRG, SCIF0,
-						 SCIF1, SCIF2, SIM, HSPI } },
-	{ 0xfe08000c, 0, 32, 4, /* INTPRI0C */ { 0, 0, MMCIF, 0,
-						 MFI, 0, ADC, CMT } },
-};
-
-static DECLARE_INTC_DESC(intc_desc, "sh7760", vectors, groups,
-			 mask_registers, prio_registers, NULL);
-
-static struct intc_vect vectors_irq[] __initdata = {
-	INTC_VECT(IRL0, 0x240), INTC_VECT(IRL1, 0x2a0),
-	INTC_VECT(IRL2, 0x300), INTC_VECT(IRL3, 0x360),
-};
-
-static DECLARE_INTC_DESC(intc_desc_irq, "sh7760-irq", vectors_irq, groups,
-			 mask_registers, prio_registers, NULL);
-
-static struct plat_sci_port scif0_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xfe600000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x880)),
-	DEFINE_RES_IRQ(evt2irq(0x8a0)),
-	DEFINE_RES_IRQ(evt2irq(0x8e0)),
-	DEFINE_RES_IRQ(evt2irq(0x8c0)),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct plat_sci_port scif1_platform_data = {
-	.type		= PORT_SCIF,
-	.scscr		= SCSCR_REIE,
-	.regtype	= SCIx_SH4_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif1_resources[] = {
-	DEFINE_RES_MEM(0xfe610000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xb00)),
-	DEFINE_RES_IRQ(evt2irq(0xb20)),
-	DEFINE_RES_IRQ(evt2irq(0xb60)),
-	DEFINE_RES_IRQ(evt2irq(0xb40)),
-};
-
-static struct platform_device scif1_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif1_resources,
-	.num_resources	= ARRAY_SIZE(scif1_resources),
-	.dev		= {
-		.platform_data	= &scif1_platform_data,
-	},
-};
-
-static struct plat_sci_port scif2_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif2_resources[] = {
-	DEFINE_RES_MEM(0xfe620000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xb80)),
-	DEFINE_RES_IRQ(evt2irq(0xba0)),
-	DEFINE_RES_IRQ(evt2irq(0xbe0)),
-	DEFINE_RES_IRQ(evt2irq(0xbc0)),
-};
-
-static struct platform_device scif2_device = {
-	.name		= "sh-sci",
-	.id		= 2,
-	.resource	= scif2_resources,
-	.num_resources	= ARRAY_SIZE(scif2_resources),
-	.dev		= {
-		.platform_data	= &scif2_platform_data,
-	},
-};
-
-static struct plat_sci_port scif3_platform_data = {
-	/*
-	 * This is actually a SIM card module serial port, based on an SCI with
-	 * additional registers. The sh-sci driver doesn't support the SIM port
-	 * type, declare it as a SCI. Don't declare the additional registers in
-	 * the memory resource or the driver will compute an incorrect regshift
-	 * value.
-	 */
-	.type		= PORT_SCI,
-};
-
-static struct resource scif3_resources[] = {
-	DEFINE_RES_MEM(0xfe480000, 0x10),
-	DEFINE_RES_IRQ(evt2irq(0xc00)),
-	DEFINE_RES_IRQ(evt2irq(0xc20)),
-	DEFINE_RES_IRQ(evt2irq(0xc40)),
-};
-
-static struct platform_device scif3_device = {
-	.name		= "sh-sci",
-	.id		= 3,
-	.resource	= scif3_resources,
-	.num_resources	= ARRAY_SIZE(scif3_resources),
-	.dev		= {
-		.platform_data	= &scif3_platform_data,
-	},
-};
-
-static struct sh_timer_config tmu0_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu0_resources[] = {
-	DEFINE_RES_MEM(0xffd80000, 0x30),
-	DEFINE_RES_IRQ(evt2irq(0x400)),
-	DEFINE_RES_IRQ(evt2irq(0x420)),
-	DEFINE_RES_IRQ(evt2irq(0x440)),
-};
-
-static struct platform_device tmu0_device = {
-	.name		= "sh-tmu",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &tmu0_platform_data,
-	},
-	.resource	= tmu0_resources,
-	.num_resources	= ARRAY_SIZE(tmu0_resources),
-};
-
-
-static struct platform_device *sh7760_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&tmu0_device,
-};
-
-static int __init sh7760_devices_setup(void)
-{
-	return platform_add_devices(sh7760_devices,
-				    ARRAY_SIZE(sh7760_devices));
-}
-arch_initcall(sh7760_devices_setup);
-
-static struct platform_device *sh7760_early_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&tmu0_device,
-};
-
-void __init plat_early_device_setup(void)
-{
-	sh_early_platform_add_devices(sh7760_early_devices,
-				   ARRAY_SIZE(sh7760_early_devices));
-}
-
-#define INTC_ICR	0xffd00000UL
-#define INTC_ICR_IRLM	(1 << 7)
-
-void __init plat_irq_setup_pins(int mode)
-{
-	switch (mode) {
-	case IRQ_MODE_IRQ:
-		__raw_writew(__raw_readw(INTC_ICR) | INTC_ICR_IRLM, INTC_ICR);
-		register_intc_controller(&intc_desc_irq);
-		break;
-	default:
-		BUG();
-	}
-}
-
-void __init plat_irq_setup(void)
-{
-	register_intc_controller(&intc_desc);
-}
diff --git a/arch/sh/kernel/cpu/sh4/softfloat.c b/arch/sh/kernel/cpu/sh4/softfloat.c
deleted file mode 100644
index 42edf2e54e8543..00000000000000
--- a/arch/sh/kernel/cpu/sh4/softfloat.c
+++ /dev/null
@@ -1,930 +0,0 @@
-/*
- * Floating point emulation support for subnormalised numbers on SH4
- * architecture This file is derived from the SoftFloat IEC/IEEE
- * Floating-point Arithmetic Package, Release 2 the original license of
- * which is reproduced below.
- *
- * ========================================================================
- *
- * This C source file is part of the SoftFloat IEC/IEEE Floating-point
- * Arithmetic Package, Release 2.
- *
- * Written by John R. Hauser.  This work was made possible in part by the
- * International Computer Science Institute, located at Suite 600, 1947 Center
- * Street, Berkeley, California 94704.  Funding was partially provided by the
- * National Science Foundation under grant MIP-9311980.  The original version
- * of this code was written as part of a project to build a fixed-point vector
- * processor in collaboration with the University of California at Berkeley,
- * overseen by Profs. Nelson Morgan and John Wawrzynek.  More information
- * is available through the web page `http://HTTP.CS.Berkeley.EDU/~jhauser/
- * arithmetic/softfloat.html'.
- *
- * THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort
- * has been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT
- * TIMES RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO
- * PERSONS AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ANY
- * AND ALL LOSSES, COSTS, OR OTHER PROBLEMS ARISING FROM ITS USE.
- *
- * Derivative works are acceptable, even for commercial purposes, so long as
- * (1) they include prominent notice that the work is derivative, and (2) they
- * include prominent notice akin to these three paragraphs for those parts of
- * this code that are retained.
- *
- * ========================================================================
- *
- * SH4 modifications by Ismail Dhaoui <ismail.dhaoui@st.com>
- * and Kamel Khelifi <kamel.khelifi@st.com>
- */
-#include <linux/kernel.h>
-#include <cpu/fpu.h>
-#include <asm/div64.h>
-
-#define LIT64( a ) a##LL
-
-typedef char flag;
-typedef unsigned char uint8;
-typedef signed char int8;
-typedef int uint16;
-typedef int int16;
-typedef unsigned int uint32;
-typedef signed int int32;
-
-typedef unsigned long long int bits64;
-typedef signed long long int sbits64;
-
-typedef unsigned char bits8;
-typedef signed char sbits8;
-typedef unsigned short int bits16;
-typedef signed short int sbits16;
-typedef unsigned int bits32;
-typedef signed int sbits32;
-
-typedef unsigned long long int uint64;
-typedef signed long long int int64;
-
-typedef unsigned long int float32;
-typedef unsigned long long float64;
-
-extern void float_raise(unsigned int flags);	/* in fpu.c */
-extern int float_rounding_mode(void);	/* in fpu.c */
-
-bits64 extractFloat64Frac(float64 a);
-flag extractFloat64Sign(float64 a);
-int16 extractFloat64Exp(float64 a);
-int16 extractFloat32Exp(float32 a);
-flag extractFloat32Sign(float32 a);
-bits32 extractFloat32Frac(float32 a);
-float64 packFloat64(flag zSign, int16 zExp, bits64 zSig);
-void shift64RightJamming(bits64 a, int16 count, bits64 * zPtr);
-float32 packFloat32(flag zSign, int16 zExp, bits32 zSig);
-void shift32RightJamming(bits32 a, int16 count, bits32 * zPtr);
-float64 float64_sub(float64 a, float64 b);
-float32 float32_sub(float32 a, float32 b);
-float32 float32_add(float32 a, float32 b);
-float64 float64_add(float64 a, float64 b);
-float64 float64_div(float64 a, float64 b);
-float32 float32_div(float32 a, float32 b);
-float32 float32_mul(float32 a, float32 b);
-float64 float64_mul(float64 a, float64 b);
-float32 float64_to_float32(float64 a);
-void add128(bits64 a0, bits64 a1, bits64 b0, bits64 b1, bits64 * z0Ptr,
-		   bits64 * z1Ptr);
-void sub128(bits64 a0, bits64 a1, bits64 b0, bits64 b1, bits64 * z0Ptr,
-		   bits64 * z1Ptr);
-void mul64To128(bits64 a, bits64 b, bits64 * z0Ptr, bits64 * z1Ptr);
-
-static int8 countLeadingZeros32(bits32 a);
-static int8 countLeadingZeros64(bits64 a);
-static float64 normalizeRoundAndPackFloat64(flag zSign, int16 zExp,
-					    bits64 zSig);
-static float64 subFloat64Sigs(float64 a, float64 b, flag zSign);
-static float64 addFloat64Sigs(float64 a, float64 b, flag zSign);
-static float32 roundAndPackFloat32(flag zSign, int16 zExp, bits32 zSig);
-static float32 normalizeRoundAndPackFloat32(flag zSign, int16 zExp,
-					    bits32 zSig);
-static float64 roundAndPackFloat64(flag zSign, int16 zExp, bits64 zSig);
-static float32 subFloat32Sigs(float32 a, float32 b, flag zSign);
-static float32 addFloat32Sigs(float32 a, float32 b, flag zSign);
-static void normalizeFloat64Subnormal(bits64 aSig, int16 * zExpPtr,
-				      bits64 * zSigPtr);
-static bits64 estimateDiv128To64(bits64 a0, bits64 a1, bits64 b);
-static void normalizeFloat32Subnormal(bits32 aSig, int16 * zExpPtr,
-				      bits32 * zSigPtr);
-
-bits64 extractFloat64Frac(float64 a)
-{
-	return a & LIT64(0x000FFFFFFFFFFFFF);
-}
-
-flag extractFloat64Sign(float64 a)
-{
-	return a >> 63;
-}
-
-int16 extractFloat64Exp(float64 a)
-{
-	return (a >> 52) & 0x7FF;
-}
-
-int16 extractFloat32Exp(float32 a)
-{
-	return (a >> 23) & 0xFF;
-}
-
-flag extractFloat32Sign(float32 a)
-{
-	return a >> 31;
-}
-
-bits32 extractFloat32Frac(float32 a)
-{
-	return a & 0x007FFFFF;
-}
-
-float64 packFloat64(flag zSign, int16 zExp, bits64 zSig)
-{
-	return (((bits64) zSign) << 63) + (((bits64) zExp) << 52) + zSig;
-}
-
-void shift64RightJamming(bits64 a, int16 count, bits64 * zPtr)
-{
-	bits64 z;
-
-	if (count == 0) {
-		z = a;
-	} else if (count < 64) {
-		z = (a >> count) | ((a << ((-count) & 63)) != 0);
-	} else {
-		z = (a != 0);
-	}
-	*zPtr = z;
-}
-
-static int8 countLeadingZeros32(bits32 a)
-{
-	static const int8 countLeadingZerosHigh[] = {
-		8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
-		3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
-	};
-	int8 shiftCount;
-
-	shiftCount = 0;
-	if (a < 0x10000) {
-		shiftCount += 16;
-		a <<= 16;
-	}
-	if (a < 0x1000000) {
-		shiftCount += 8;
-		a <<= 8;
-	}
-	shiftCount += countLeadingZerosHigh[a >> 24];
-	return shiftCount;
-
-}
-
-static int8 countLeadingZeros64(bits64 a)
-{
-	int8 shiftCount;
-
-	shiftCount = 0;
-	if (a < ((bits64) 1) << 32) {
-		shiftCount += 32;
-	} else {
-		a >>= 32;
-	}
-	shiftCount += countLeadingZeros32(a);
-	return shiftCount;
-
-}
-
-static float64 normalizeRoundAndPackFloat64(flag zSign, int16 zExp, bits64 zSig)
-{
-	int8 shiftCount;
-
-	shiftCount = countLeadingZeros64(zSig) - 1;
-	return roundAndPackFloat64(zSign, zExp - shiftCount,
-				   zSig << shiftCount);
-
-}
-
-static float64 subFloat64Sigs(float64 a, float64 b, flag zSign)
-{
-	int16 aExp, bExp, zExp;
-	bits64 aSig, bSig, zSig;
-	int16 expDiff;
-
-	aSig = extractFloat64Frac(a);
-	aExp = extractFloat64Exp(a);
-	bSig = extractFloat64Frac(b);
-	bExp = extractFloat64Exp(b);
-	expDiff = aExp - bExp;
-	aSig <<= 10;
-	bSig <<= 10;
-	if (0 < expDiff)
-		goto aExpBigger;
-	if (expDiff < 0)
-		goto bExpBigger;
-	if (aExp == 0) {
-		aExp = 1;
-		bExp = 1;
-	}
-	if (bSig < aSig)
-		goto aBigger;
-	if (aSig < bSig)
-		goto bBigger;
-	return packFloat64(float_rounding_mode() == FPSCR_RM_ZERO, 0, 0);
-      bExpBigger:
-	if (bExp == 0x7FF) {
-		return packFloat64(zSign ^ 1, 0x7FF, 0);
-	}
-	if (aExp == 0) {
-		++expDiff;
-	} else {
-		aSig |= LIT64(0x4000000000000000);
-	}
-	shift64RightJamming(aSig, -expDiff, &aSig);
-	bSig |= LIT64(0x4000000000000000);
-      bBigger:
-	zSig = bSig - aSig;
-	zExp = bExp;
-	zSign ^= 1;
-	goto normalizeRoundAndPack;
-      aExpBigger:
-	if (aExp == 0x7FF) {
-		return a;
-	}
-	if (bExp == 0) {
-		--expDiff;
-	} else {
-		bSig |= LIT64(0x4000000000000000);
-	}
-	shift64RightJamming(bSig, expDiff, &bSig);
-	aSig |= LIT64(0x4000000000000000);
-      aBigger:
-	zSig = aSig - bSig;
-	zExp = aExp;
-      normalizeRoundAndPack:
-	--zExp;
-	return normalizeRoundAndPackFloat64(zSign, zExp, zSig);
-
-}
-static float64 addFloat64Sigs(float64 a, float64 b, flag zSign)
-{
-	int16 aExp, bExp, zExp;
-	bits64 aSig, bSig, zSig;
-	int16 expDiff;
-
-	aSig = extractFloat64Frac(a);
-	aExp = extractFloat64Exp(a);
-	bSig = extractFloat64Frac(b);
-	bExp = extractFloat64Exp(b);
-	expDiff = aExp - bExp;
-	aSig <<= 9;
-	bSig <<= 9;
-	if (0 < expDiff) {
-		if (aExp == 0x7FF) {
-			return a;
-		}
-		if (bExp == 0) {
-			--expDiff;
-		} else {
-			bSig |= LIT64(0x2000000000000000);
-		}
-		shift64RightJamming(bSig, expDiff, &bSig);
-		zExp = aExp;
-	} else if (expDiff < 0) {
-		if (bExp == 0x7FF) {
-			return packFloat64(zSign, 0x7FF, 0);
-		}
-		if (aExp == 0) {
-			++expDiff;
-		} else {
-			aSig |= LIT64(0x2000000000000000);
-		}
-		shift64RightJamming(aSig, -expDiff, &aSig);
-		zExp = bExp;
-	} else {
-		if (aExp == 0x7FF) {
-			return a;
-		}
-		if (aExp == 0)
-			return packFloat64(zSign, 0, (aSig + bSig) >> 9);
-		zSig = LIT64(0x4000000000000000) + aSig + bSig;
-		zExp = aExp;
-		goto roundAndPack;
-	}
-	aSig |= LIT64(0x2000000000000000);
-	zSig = (aSig + bSig) << 1;
-	--zExp;
-	if ((sbits64) zSig < 0) {
-		zSig = aSig + bSig;
-		++zExp;
-	}
-      roundAndPack:
-	return roundAndPackFloat64(zSign, zExp, zSig);
-
-}
-
-float32 packFloat32(flag zSign, int16 zExp, bits32 zSig)
-{
-	return (((bits32) zSign) << 31) + (((bits32) zExp) << 23) + zSig;
-}
-
-void shift32RightJamming(bits32 a, int16 count, bits32 * zPtr)
-{
-	bits32 z;
-	if (count == 0) {
-		z = a;
-	} else if (count < 32) {
-		z = (a >> count) | ((a << ((-count) & 31)) != 0);
-	} else {
-		z = (a != 0);
-	}
-	*zPtr = z;
-}
-
-static float32 roundAndPackFloat32(flag zSign, int16 zExp, bits32 zSig)
-{
-	flag roundNearestEven;
-	int8 roundIncrement, roundBits;
-	flag isTiny;
-
-	/* SH4 has only 2 rounding modes - round to nearest and round to zero */
-	roundNearestEven = (float_rounding_mode() == FPSCR_RM_NEAREST);
-	roundIncrement = 0x40;
-	if (!roundNearestEven) {
-		roundIncrement = 0;
-	}
-	roundBits = zSig & 0x7F;
-	if (0xFD <= (bits16) zExp) {
-		if ((0xFD < zExp)
-		    || ((zExp == 0xFD)
-			&& ((sbits32) (zSig + roundIncrement) < 0))
-		    ) {
-			float_raise(FPSCR_CAUSE_OVERFLOW | FPSCR_CAUSE_INEXACT);
-			return packFloat32(zSign, 0xFF,
-					   0) - (roundIncrement == 0);
-		}
-		if (zExp < 0) {
-			isTiny = (zExp < -1)
-			    || (zSig + roundIncrement < 0x80000000);
-			shift32RightJamming(zSig, -zExp, &zSig);
-			zExp = 0;
-			roundBits = zSig & 0x7F;
-			if (isTiny && roundBits)
-				float_raise(FPSCR_CAUSE_UNDERFLOW);
-		}
-	}
-	if (roundBits)
-		float_raise(FPSCR_CAUSE_INEXACT);
-	zSig = (zSig + roundIncrement) >> 7;
-	zSig &= ~(((roundBits ^ 0x40) == 0) & roundNearestEven);
-	if (zSig == 0)
-		zExp = 0;
-	return packFloat32(zSign, zExp, zSig);
-
-}
-
-static float32 normalizeRoundAndPackFloat32(flag zSign, int16 zExp, bits32 zSig)
-{
-	int8 shiftCount;
-
-	shiftCount = countLeadingZeros32(zSig) - 1;
-	return roundAndPackFloat32(zSign, zExp - shiftCount,
-				   zSig << shiftCount);
-}
-
-static float64 roundAndPackFloat64(flag zSign, int16 zExp, bits64 zSig)
-{
-	flag roundNearestEven;
-	int16 roundIncrement, roundBits;
-	flag isTiny;
-
-	/* SH4 has only 2 rounding modes - round to nearest and round to zero */
-	roundNearestEven = (float_rounding_mode() == FPSCR_RM_NEAREST);
-	roundIncrement = 0x200;
-	if (!roundNearestEven) {
-		roundIncrement = 0;
-	}
-	roundBits = zSig & 0x3FF;
-	if (0x7FD <= (bits16) zExp) {
-		if ((0x7FD < zExp)
-		    || ((zExp == 0x7FD)
-			&& ((sbits64) (zSig + roundIncrement) < 0))
-		    ) {
-			float_raise(FPSCR_CAUSE_OVERFLOW | FPSCR_CAUSE_INEXACT);
-			return packFloat64(zSign, 0x7FF,
-					   0) - (roundIncrement == 0);
-		}
-		if (zExp < 0) {
-			isTiny = (zExp < -1)
-			    || (zSig + roundIncrement <
-				LIT64(0x8000000000000000));
-			shift64RightJamming(zSig, -zExp, &zSig);
-			zExp = 0;
-			roundBits = zSig & 0x3FF;
-			if (isTiny && roundBits)
-				float_raise(FPSCR_CAUSE_UNDERFLOW);
-		}
-	}
-	if (roundBits)
-		float_raise(FPSCR_CAUSE_INEXACT);
-	zSig = (zSig + roundIncrement) >> 10;
-	zSig &= ~(((roundBits ^ 0x200) == 0) & roundNearestEven);
-	if (zSig == 0)
-		zExp = 0;
-	return packFloat64(zSign, zExp, zSig);
-
-}
-
-static float32 subFloat32Sigs(float32 a, float32 b, flag zSign)
-{
-	int16 aExp, bExp, zExp;
-	bits32 aSig, bSig, zSig;
-	int16 expDiff;
-
-	aSig = extractFloat32Frac(a);
-	aExp = extractFloat32Exp(a);
-	bSig = extractFloat32Frac(b);
-	bExp = extractFloat32Exp(b);
-	expDiff = aExp - bExp;
-	aSig <<= 7;
-	bSig <<= 7;
-	if (0 < expDiff)
-		goto aExpBigger;
-	if (expDiff < 0)
-		goto bExpBigger;
-	if (aExp == 0) {
-		aExp = 1;
-		bExp = 1;
-	}
-	if (bSig < aSig)
-		goto aBigger;
-	if (aSig < bSig)
-		goto bBigger;
-	return packFloat32(float_rounding_mode() == FPSCR_RM_ZERO, 0, 0);
-      bExpBigger:
-	if (bExp == 0xFF) {
-		return packFloat32(zSign ^ 1, 0xFF, 0);
-	}
-	if (aExp == 0) {
-		++expDiff;
-	} else {
-		aSig |= 0x40000000;
-	}
-	shift32RightJamming(aSig, -expDiff, &aSig);
-	bSig |= 0x40000000;
-      bBigger:
-	zSig = bSig - aSig;
-	zExp = bExp;
-	zSign ^= 1;
-	goto normalizeRoundAndPack;
-      aExpBigger:
-	if (aExp == 0xFF) {
-		return a;
-	}
-	if (bExp == 0) {
-		--expDiff;
-	} else {
-		bSig |= 0x40000000;
-	}
-	shift32RightJamming(bSig, expDiff, &bSig);
-	aSig |= 0x40000000;
-      aBigger:
-	zSig = aSig - bSig;
-	zExp = aExp;
-      normalizeRoundAndPack:
-	--zExp;
-	return normalizeRoundAndPackFloat32(zSign, zExp, zSig);
-
-}
-
-static float32 addFloat32Sigs(float32 a, float32 b, flag zSign)
-{
-	int16 aExp, bExp, zExp;
-	bits32 aSig, bSig, zSig;
-	int16 expDiff;
-
-	aSig = extractFloat32Frac(a);
-	aExp = extractFloat32Exp(a);
-	bSig = extractFloat32Frac(b);
-	bExp = extractFloat32Exp(b);
-	expDiff = aExp - bExp;
-	aSig <<= 6;
-	bSig <<= 6;
-	if (0 < expDiff) {
-		if (aExp == 0xFF) {
-			return a;
-		}
-		if (bExp == 0) {
-			--expDiff;
-		} else {
-			bSig |= 0x20000000;
-		}
-		shift32RightJamming(bSig, expDiff, &bSig);
-		zExp = aExp;
-	} else if (expDiff < 0) {
-		if (bExp == 0xFF) {
-			return packFloat32(zSign, 0xFF, 0);
-		}
-		if (aExp == 0) {
-			++expDiff;
-		} else {
-			aSig |= 0x20000000;
-		}
-		shift32RightJamming(aSig, -expDiff, &aSig);
-		zExp = bExp;
-	} else {
-		if (aExp == 0xFF) {
-			return a;
-		}
-		if (aExp == 0)
-			return packFloat32(zSign, 0, (aSig + bSig) >> 6);
-		zSig = 0x40000000 + aSig + bSig;
-		zExp = aExp;
-		goto roundAndPack;
-	}
-	aSig |= 0x20000000;
-	zSig = (aSig + bSig) << 1;
-	--zExp;
-	if ((sbits32) zSig < 0) {
-		zSig = aSig + bSig;
-		++zExp;
-	}
-      roundAndPack:
-	return roundAndPackFloat32(zSign, zExp, zSig);
-
-}
-
-float64 float64_sub(float64 a, float64 b)
-{
-	flag aSign, bSign;
-
-	aSign = extractFloat64Sign(a);
-	bSign = extractFloat64Sign(b);
-	if (aSign == bSign) {
-		return subFloat64Sigs(a, b, aSign);
-	} else {
-		return addFloat64Sigs(a, b, aSign);
-	}
-
-}
-
-float32 float32_sub(float32 a, float32 b)
-{
-	flag aSign, bSign;
-
-	aSign = extractFloat32Sign(a);
-	bSign = extractFloat32Sign(b);
-	if (aSign == bSign) {
-		return subFloat32Sigs(a, b, aSign);
-	} else {
-		return addFloat32Sigs(a, b, aSign);
-	}
-
-}
-
-float32 float32_add(float32 a, float32 b)
-{
-	flag aSign, bSign;
-
-	aSign = extractFloat32Sign(a);
-	bSign = extractFloat32Sign(b);
-	if (aSign == bSign) {
-		return addFloat32Sigs(a, b, aSign);
-	} else {
-		return subFloat32Sigs(a, b, aSign);
-	}
-
-}
-
-float64 float64_add(float64 a, float64 b)
-{
-	flag aSign, bSign;
-
-	aSign = extractFloat64Sign(a);
-	bSign = extractFloat64Sign(b);
-	if (aSign == bSign) {
-		return addFloat64Sigs(a, b, aSign);
-	} else {
-		return subFloat64Sigs(a, b, aSign);
-	}
-}
-
-static void
-normalizeFloat64Subnormal(bits64 aSig, int16 * zExpPtr, bits64 * zSigPtr)
-{
-	int8 shiftCount;
-
-	shiftCount = countLeadingZeros64(aSig) - 11;
-	*zSigPtr = aSig << shiftCount;
-	*zExpPtr = 1 - shiftCount;
-}
-
-void add128(bits64 a0, bits64 a1, bits64 b0, bits64 b1, bits64 * z0Ptr,
-		   bits64 * z1Ptr)
-{
-	bits64 z1;
-
-	z1 = a1 + b1;
-	*z1Ptr = z1;
-	*z0Ptr = a0 + b0 + (z1 < a1);
-}
-
-void
-sub128(bits64 a0, bits64 a1, bits64 b0, bits64 b1, bits64 * z0Ptr,
-       bits64 * z1Ptr)
-{
-	*z1Ptr = a1 - b1;
-	*z0Ptr = a0 - b0 - (a1 < b1);
-}
-
-static bits64 estimateDiv128To64(bits64 a0, bits64 a1, bits64 b)
-{
-	bits64 b0, b1;
-	bits64 rem0, rem1, term0, term1;
-	bits64 z, tmp;
-	if (b <= a0)
-		return LIT64(0xFFFFFFFFFFFFFFFF);
-	b0 = b >> 32;
-	tmp = a0;
-	do_div(tmp, b0);
-
-	z = (b0 << 32 <= a0) ? LIT64(0xFFFFFFFF00000000) : tmp << 32;
-	mul64To128(b, z, &term0, &term1);
-	sub128(a0, a1, term0, term1, &rem0, &rem1);
-	while (((sbits64) rem0) < 0) {
-		z -= LIT64(0x100000000);
-		b1 = b << 32;
-		add128(rem0, rem1, b0, b1, &rem0, &rem1);
-	}
-	rem0 = (rem0 << 32) | (rem1 >> 32);
-	tmp = rem0;
-	do_div(tmp, b0);
-	z |= (b0 << 32 <= rem0) ? 0xFFFFFFFF : tmp;
-	return z;
-}
-
-void mul64To128(bits64 a, bits64 b, bits64 * z0Ptr, bits64 * z1Ptr)
-{
-	bits32 aHigh, aLow, bHigh, bLow;
-	bits64 z0, zMiddleA, zMiddleB, z1;
-
-	aLow = a;
-	aHigh = a >> 32;
-	bLow = b;
-	bHigh = b >> 32;
-	z1 = ((bits64) aLow) * bLow;
-	zMiddleA = ((bits64) aLow) * bHigh;
-	zMiddleB = ((bits64) aHigh) * bLow;
-	z0 = ((bits64) aHigh) * bHigh;
-	zMiddleA += zMiddleB;
-	z0 += (((bits64) (zMiddleA < zMiddleB)) << 32) + (zMiddleA >> 32);
-	zMiddleA <<= 32;
-	z1 += zMiddleA;
-	z0 += (z1 < zMiddleA);
-	*z1Ptr = z1;
-	*z0Ptr = z0;
-
-}
-
-static void normalizeFloat32Subnormal(bits32 aSig, int16 * zExpPtr,
-				      bits32 * zSigPtr)
-{
-	int8 shiftCount;
-
-	shiftCount = countLeadingZeros32(aSig) - 8;
-	*zSigPtr = aSig << shiftCount;
-	*zExpPtr = 1 - shiftCount;
-
-}
-
-float64 float64_div(float64 a, float64 b)
-{
-	flag aSign, bSign, zSign;
-	int16 aExp, bExp, zExp;
-	bits64 aSig, bSig, zSig;
-	bits64 rem0, rem1;
-	bits64 term0, term1;
-
-	aSig = extractFloat64Frac(a);
-	aExp = extractFloat64Exp(a);
-	aSign = extractFloat64Sign(a);
-	bSig = extractFloat64Frac(b);
-	bExp = extractFloat64Exp(b);
-	bSign = extractFloat64Sign(b);
-	zSign = aSign ^ bSign;
-	if (aExp == 0x7FF) {
-		if (bExp == 0x7FF) {
-		}
-		return packFloat64(zSign, 0x7FF, 0);
-	}
-	if (bExp == 0x7FF) {
-		return packFloat64(zSign, 0, 0);
-	}
-	if (bExp == 0) {
-		if (bSig == 0) {
-			if ((aExp | aSig) == 0) {
-				float_raise(FPSCR_CAUSE_INVALID);
-			}
-			return packFloat64(zSign, 0x7FF, 0);
-		}
-		normalizeFloat64Subnormal(bSig, &bExp, &bSig);
-	}
-	if (aExp == 0) {
-		if (aSig == 0)
-			return packFloat64(zSign, 0, 0);
-		normalizeFloat64Subnormal(aSig, &aExp, &aSig);
-	}
-	zExp = aExp - bExp + 0x3FD;
-	aSig = (aSig | LIT64(0x0010000000000000)) << 10;
-	bSig = (bSig | LIT64(0x0010000000000000)) << 11;
-	if (bSig <= (aSig + aSig)) {
-		aSig >>= 1;
-		++zExp;
-	}
-	zSig = estimateDiv128To64(aSig, 0, bSig);
-	if ((zSig & 0x1FF) <= 2) {
-		mul64To128(bSig, zSig, &term0, &term1);
-		sub128(aSig, 0, term0, term1, &rem0, &rem1);
-		while ((sbits64) rem0 < 0) {
-			--zSig;
-			add128(rem0, rem1, 0, bSig, &rem0, &rem1);
-		}
-		zSig |= (rem1 != 0);
-	}
-	return roundAndPackFloat64(zSign, zExp, zSig);
-
-}
-
-float32 float32_div(float32 a, float32 b)
-{
-	flag aSign, bSign, zSign;
-	int16 aExp, bExp, zExp;
-	bits32 aSig, bSig;
-	uint64_t zSig;
-
-	aSig = extractFloat32Frac(a);
-	aExp = extractFloat32Exp(a);
-	aSign = extractFloat32Sign(a);
-	bSig = extractFloat32Frac(b);
-	bExp = extractFloat32Exp(b);
-	bSign = extractFloat32Sign(b);
-	zSign = aSign ^ bSign;
-	if (aExp == 0xFF) {
-		if (bExp == 0xFF) {
-		}
-		return packFloat32(zSign, 0xFF, 0);
-	}
-	if (bExp == 0xFF) {
-		return packFloat32(zSign, 0, 0);
-	}
-	if (bExp == 0) {
-		if (bSig == 0) {
-			return packFloat32(zSign, 0xFF, 0);
-		}
-		normalizeFloat32Subnormal(bSig, &bExp, &bSig);
-	}
-	if (aExp == 0) {
-		if (aSig == 0)
-			return packFloat32(zSign, 0, 0);
-		normalizeFloat32Subnormal(aSig, &aExp, &aSig);
-	}
-	zExp = aExp - bExp + 0x7D;
-	aSig = (aSig | 0x00800000) << 7;
-	bSig = (bSig | 0x00800000) << 8;
-	if (bSig <= (aSig + aSig)) {
-		aSig >>= 1;
-		++zExp;
-	}
-	zSig = (((bits64) aSig) << 32);
-	do_div(zSig, bSig);
-
-	if ((zSig & 0x3F) == 0) {
-		zSig |= (((bits64) bSig) * zSig != ((bits64) aSig) << 32);
-	}
-	return roundAndPackFloat32(zSign, zExp, (bits32)zSig);
-
-}
-
-float32 float32_mul(float32 a, float32 b)
-{
-	char aSign, bSign, zSign;
-	int aExp, bExp, zExp;
-	unsigned int aSig, bSig;
-	unsigned long long zSig64;
-	unsigned int zSig;
-
-	aSig = extractFloat32Frac(a);
-	aExp = extractFloat32Exp(a);
-	aSign = extractFloat32Sign(a);
-	bSig = extractFloat32Frac(b);
-	bExp = extractFloat32Exp(b);
-	bSign = extractFloat32Sign(b);
-	zSign = aSign ^ bSign;
-	if (aExp == 0) {
-		if (aSig == 0)
-			return packFloat32(zSign, 0, 0);
-		normalizeFloat32Subnormal(aSig, &aExp, &aSig);
-	}
-	if (bExp == 0) {
-		if (bSig == 0)
-			return packFloat32(zSign, 0, 0);
-		normalizeFloat32Subnormal(bSig, &bExp, &bSig);
-	}
-	if ((bExp == 0xff && bSig == 0) || (aExp == 0xff && aSig == 0))
-		return roundAndPackFloat32(zSign, 0xff, 0);
-
-	zExp = aExp + bExp - 0x7F;
-	aSig = (aSig | 0x00800000) << 7;
-	bSig = (bSig | 0x00800000) << 8;
-	shift64RightJamming(((unsigned long long)aSig) * bSig, 32, &zSig64);
-	zSig = zSig64;
-	if (0 <= (signed int)(zSig << 1)) {
-		zSig <<= 1;
-		--zExp;
-	}
-	return roundAndPackFloat32(zSign, zExp, zSig);
-
-}
-
-float64 float64_mul(float64 a, float64 b)
-{
-	char aSign, bSign, zSign;
-	int aExp, bExp, zExp;
-	unsigned long long int aSig, bSig, zSig0, zSig1;
-
-	aSig = extractFloat64Frac(a);
-	aExp = extractFloat64Exp(a);
-	aSign = extractFloat64Sign(a);
-	bSig = extractFloat64Frac(b);
-	bExp = extractFloat64Exp(b);
-	bSign = extractFloat64Sign(b);
-	zSign = aSign ^ bSign;
-
-	if (aExp == 0) {
-		if (aSig == 0)
-			return packFloat64(zSign, 0, 0);
-		normalizeFloat64Subnormal(aSig, &aExp, &aSig);
-	}
-	if (bExp == 0) {
-		if (bSig == 0)
-			return packFloat64(zSign, 0, 0);
-		normalizeFloat64Subnormal(bSig, &bExp, &bSig);
-	}
-	if ((aExp == 0x7ff && aSig == 0) || (bExp == 0x7ff && bSig == 0))
-		return roundAndPackFloat64(zSign, 0x7ff, 0);
-
-	zExp = aExp + bExp - 0x3FF;
-	aSig = (aSig | 0x0010000000000000LL) << 10;
-	bSig = (bSig | 0x0010000000000000LL) << 11;
-	mul64To128(aSig, bSig, &zSig0, &zSig1);
-	zSig0 |= (zSig1 != 0);
-	if (0 <= (signed long long int)(zSig0 << 1)) {
-		zSig0 <<= 1;
-		--zExp;
-	}
-	return roundAndPackFloat64(zSign, zExp, zSig0);
-}
-
-/*
- * -------------------------------------------------------------------------------
- *  Returns the result of converting the double-precision floating-point value
- *  `a' to the single-precision floating-point format.  The conversion is
- *  performed according to the IEC/IEEE Standard for Binary Floating-point
- *  Arithmetic.
- *  -------------------------------------------------------------------------------
- *  */
-float32 float64_to_float32(float64 a)
-{
-    flag aSign;
-    int16 aExp;
-    bits64 aSig;
-    bits32 zSig;
-
-    aSig = extractFloat64Frac( a );
-    aExp = extractFloat64Exp( a );
-    aSign = extractFloat64Sign( a );
-
-    shift64RightJamming( aSig, 22, &aSig );
-    zSig = aSig;
-    if ( aExp || zSig ) {
-        zSig |= 0x40000000;
-        aExp -= 0x381;
-    }
-    return roundAndPackFloat32(aSign, aExp, zSig);
-}
diff --git a/arch/sh/kernel/cpu/sh4/sq.c b/arch/sh/kernel/cpu/sh4/sq.c
deleted file mode 100644
index a76b94e41e9134..00000000000000
--- a/arch/sh/kernel/cpu/sh4/sq.c
+++ /dev/null
@@ -1,414 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh4/sq.c
- *
- * General management API for SH-4 integrated Store Queues
- *
- * Copyright (C) 2001 - 2006  Paul Mundt
- * Copyright (C) 2001, 2002  M. R. Brown
- */
-#include <linux/init.h>
-#include <linux/cpu.h>
-#include <linux/bitmap.h>
-#include <linux/device.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/vmalloc.h>
-#include <linux/mm.h>
-#include <linux/io.h>
-#include <linux/prefetch.h>
-#include <asm/page.h>
-#include <asm/cacheflush.h>
-#include <cpu/sq.h>
-
-struct sq_mapping;
-
-struct sq_mapping {
-	const char *name;
-
-	unsigned long sq_addr;
-	unsigned long addr;
-	unsigned int size;
-
-	struct sq_mapping *next;
-};
-
-static struct sq_mapping *sq_mapping_list;
-static DEFINE_SPINLOCK(sq_mapping_lock);
-static struct kmem_cache *sq_cache;
-static unsigned long *sq_bitmap;
-
-#define store_queue_barrier()			\
-do {						\
-	(void)__raw_readl(P4SEG_STORE_QUE);	\
-	__raw_writel(0, P4SEG_STORE_QUE + 0);	\
-	__raw_writel(0, P4SEG_STORE_QUE + 8);	\
-} while (0);
-
-/**
- * sq_flush_range - Flush (prefetch) a specific SQ range
- * @start: the store queue address to start flushing from
- * @len: the length to flush
- *
- * Flushes the store queue cache from @start to @start + @len in a
- * linear fashion.
- */
-void sq_flush_range(unsigned long start, unsigned int len)
-{
-	unsigned long *sq = (unsigned long *)start;
-
-	/* Flush the queues */
-	for (len >>= 5; len--; sq += 8)
-		prefetchw(sq);
-
-	/* Wait for completion */
-	store_queue_barrier();
-}
-EXPORT_SYMBOL(sq_flush_range);
-
-static inline void sq_mapping_list_add(struct sq_mapping *map)
-{
-	struct sq_mapping **p, *tmp;
-
-	spin_lock_irq(&sq_mapping_lock);
-
-	p = &sq_mapping_list;
-	while ((tmp = *p) != NULL)
-		p = &tmp->next;
-
-	map->next = tmp;
-	*p = map;
-
-	spin_unlock_irq(&sq_mapping_lock);
-}
-
-static inline void sq_mapping_list_del(struct sq_mapping *map)
-{
-	struct sq_mapping **p, *tmp;
-
-	spin_lock_irq(&sq_mapping_lock);
-
-	for (p = &sq_mapping_list; (tmp = *p); p = &tmp->next)
-		if (tmp == map) {
-			*p = tmp->next;
-			break;
-		}
-
-	spin_unlock_irq(&sq_mapping_lock);
-}
-
-static int __sq_remap(struct sq_mapping *map, pgprot_t prot)
-{
-#if defined(CONFIG_MMU)
-	struct vm_struct *vma;
-
-	vma = __get_vm_area_caller(map->size, VM_ALLOC, map->sq_addr,
-			SQ_ADDRMAX, __builtin_return_address(0));
-	if (!vma)
-		return -ENOMEM;
-
-	vma->phys_addr = map->addr;
-
-	if (ioremap_page_range((unsigned long)vma->addr,
-			       (unsigned long)vma->addr + map->size,
-			       vma->phys_addr, prot)) {
-		vunmap(vma->addr);
-		return -EAGAIN;
-	}
-#else
-	/*
-	 * Without an MMU (or with it turned off), this is much more
-	 * straightforward, as we can just load up each queue's QACR with
-	 * the physical address appropriately masked.
-	 */
-	__raw_writel(((map->addr >> 26) << 2) & 0x1c, SQ_QACR0);
-	__raw_writel(((map->addr >> 26) << 2) & 0x1c, SQ_QACR1);
-#endif
-
-	return 0;
-}
-
-/**
- * sq_remap - Map a physical address through the Store Queues
- * @phys: Physical address of mapping.
- * @size: Length of mapping.
- * @name: User invoking mapping.
- * @prot: Protection bits.
- *
- * Remaps the physical address @phys through the next available store queue
- * address of @size length. @name is logged at boot time as well as through
- * the sysfs interface.
- */
-unsigned long sq_remap(unsigned long phys, unsigned int size,
-		       const char *name, pgprot_t prot)
-{
-	struct sq_mapping *map;
-	unsigned long end;
-	unsigned int psz;
-	int ret, page;
-
-	/* Don't allow wraparound or zero size */
-	end = phys + size - 1;
-	if (unlikely(!size || end < phys))
-		return -EINVAL;
-	/* Don't allow anyone to remap normal memory.. */
-	if (unlikely(phys < virt_to_phys(high_memory)))
-		return -EINVAL;
-
-	phys &= PAGE_MASK;
-	size = PAGE_ALIGN(end + 1) - phys;
-
-	map = kmem_cache_alloc(sq_cache, GFP_KERNEL);
-	if (unlikely(!map))
-		return -ENOMEM;
-
-	map->addr = phys;
-	map->size = size;
-	map->name = name;
-
-	page = bitmap_find_free_region(sq_bitmap, 0x04000000 >> PAGE_SHIFT,
-				       get_order(map->size));
-	if (unlikely(page < 0)) {
-		ret = -ENOSPC;
-		goto out;
-	}
-
-	map->sq_addr = P4SEG_STORE_QUE + (page << PAGE_SHIFT);
-
-	ret = __sq_remap(map, prot);
-	if (unlikely(ret != 0))
-		goto out;
-
-	psz = (size + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
-	pr_info("sqremap: %15s  [%4d page%s]  va 0x%08lx   pa 0x%08lx\n",
-		likely(map->name) ? map->name : "???",
-		psz, psz == 1 ? " " : "s",
-		map->sq_addr, map->addr);
-
-	sq_mapping_list_add(map);
-
-	return map->sq_addr;
-
-out:
-	kmem_cache_free(sq_cache, map);
-	return ret;
-}
-EXPORT_SYMBOL(sq_remap);
-
-/**
- * sq_unmap - Unmap a Store Queue allocation
- * @vaddr: Pre-allocated Store Queue mapping.
- *
- * Unmaps the store queue allocation @map that was previously created by
- * sq_remap(). Also frees up the pte that was previously inserted into
- * the kernel page table and discards the UTLB translation.
- */
-void sq_unmap(unsigned long vaddr)
-{
-	struct sq_mapping **p, *map;
-	int page;
-
-	for (p = &sq_mapping_list; (map = *p); p = &map->next)
-		if (map->sq_addr == vaddr)
-			break;
-
-	if (unlikely(!map)) {
-		printk("%s: bad store queue address 0x%08lx\n",
-		       __func__, vaddr);
-		return;
-	}
-
-	page = (map->sq_addr - P4SEG_STORE_QUE) >> PAGE_SHIFT;
-	bitmap_release_region(sq_bitmap, page, get_order(map->size));
-
-#ifdef CONFIG_MMU
-	{
-		/*
-		 * Tear down the VMA in the MMU case.
-		 */
-		struct vm_struct *vma;
-
-		vma = remove_vm_area((void *)(map->sq_addr & PAGE_MASK));
-		if (!vma) {
-			printk(KERN_ERR "%s: bad address 0x%08lx\n",
-			       __func__, map->sq_addr);
-			return;
-		}
-	}
-#endif
-
-	sq_mapping_list_del(map);
-
-	kmem_cache_free(sq_cache, map);
-}
-EXPORT_SYMBOL(sq_unmap);
-
-/*
- * Needlessly complex sysfs interface. Unfortunately it doesn't seem like
- * there is any other easy way to add things on a per-cpu basis without
- * putting the directory entries somewhere stupid and having to create
- * links in sysfs by hand back in to the per-cpu directories.
- *
- * Some day we may want to have an additional abstraction per store
- * queue, but considering the kobject hell we already have to deal with,
- * it's simply not worth the trouble.
- */
-static struct kobject *sq_kobject[NR_CPUS];
-
-struct sq_sysfs_attr {
-	struct attribute attr;
-	ssize_t (*show)(char *buf);
-	ssize_t (*store)(const char *buf, size_t count);
-};
-
-#define to_sq_sysfs_attr(a)	container_of(a, struct sq_sysfs_attr, attr)
-
-static ssize_t sq_sysfs_show(struct kobject *kobj, struct attribute *attr,
-			     char *buf)
-{
-	struct sq_sysfs_attr *sattr = to_sq_sysfs_attr(attr);
-
-	if (likely(sattr->show))
-		return sattr->show(buf);
-
-	return -EIO;
-}
-
-static ssize_t sq_sysfs_store(struct kobject *kobj, struct attribute *attr,
-			      const char *buf, size_t count)
-{
-	struct sq_sysfs_attr *sattr = to_sq_sysfs_attr(attr);
-
-	if (likely(sattr->store))
-		return sattr->store(buf, count);
-
-	return -EIO;
-}
-
-static ssize_t mapping_show(char *buf)
-{
-	struct sq_mapping **list, *entry;
-	char *p = buf;
-
-	for (list = &sq_mapping_list; (entry = *list); list = &entry->next)
-		p += sprintf(p, "%08lx-%08lx [%08lx]: %s\n",
-			     entry->sq_addr, entry->sq_addr + entry->size,
-			     entry->addr, entry->name);
-
-	return p - buf;
-}
-
-static ssize_t mapping_store(const char *buf, size_t count)
-{
-	unsigned long base = 0, len = 0;
-
-	sscanf(buf, "%lx %lx", &base, &len);
-	if (!base)
-		return -EIO;
-
-	if (likely(len)) {
-		int ret = sq_remap(base, len, "Userspace", PAGE_SHARED);
-		if (ret < 0)
-			return ret;
-	} else
-		sq_unmap(base);
-
-	return count;
-}
-
-static struct sq_sysfs_attr mapping_attr =
-	__ATTR(mapping, 0644, mapping_show, mapping_store);
-
-static struct attribute *sq_sysfs_attrs[] = {
-	&mapping_attr.attr,
-	NULL,
-};
-ATTRIBUTE_GROUPS(sq_sysfs);
-
-static const struct sysfs_ops sq_sysfs_ops = {
-	.show	= sq_sysfs_show,
-	.store	= sq_sysfs_store,
-};
-
-static struct kobj_type ktype_percpu_entry = {
-	.sysfs_ops	= &sq_sysfs_ops,
-	.default_groups	= sq_sysfs_groups,
-};
-
-static int sq_dev_add(struct device *dev, struct subsys_interface *sif)
-{
-	unsigned int cpu = dev->id;
-	struct kobject *kobj;
-	int error;
-
-	sq_kobject[cpu] = kzalloc(sizeof(struct kobject), GFP_KERNEL);
-	if (unlikely(!sq_kobject[cpu]))
-		return -ENOMEM;
-
-	kobj = sq_kobject[cpu];
-	error = kobject_init_and_add(kobj, &ktype_percpu_entry, &dev->kobj,
-				     "%s", "sq");
-	if (!error)
-		kobject_uevent(kobj, KOBJ_ADD);
-	return error;
-}
-
-static void sq_dev_remove(struct device *dev, struct subsys_interface *sif)
-{
-	unsigned int cpu = dev->id;
-	struct kobject *kobj = sq_kobject[cpu];
-
-	kobject_put(kobj);
-}
-
-static struct subsys_interface sq_interface = {
-	.name		= "sq",
-	.subsys		= &cpu_subsys,
-	.add_dev	= sq_dev_add,
-	.remove_dev	= sq_dev_remove,
-};
-
-static int __init sq_api_init(void)
-{
-	unsigned int nr_pages = 0x04000000 >> PAGE_SHIFT;
-	unsigned int size = (nr_pages + (BITS_PER_LONG - 1)) / BITS_PER_LONG;
-	int ret = -ENOMEM;
-
-	printk(KERN_NOTICE "sq: Registering store queue API.\n");
-
-	sq_cache = kmem_cache_create("store_queue_cache",
-				sizeof(struct sq_mapping), 0, 0, NULL);
-	if (unlikely(!sq_cache))
-		return ret;
-
-	sq_bitmap = kzalloc(size, GFP_KERNEL);
-	if (unlikely(!sq_bitmap))
-		goto out;
-
-	ret = subsys_interface_register(&sq_interface);
-	if (unlikely(ret != 0))
-		goto out;
-
-	return 0;
-
-out:
-	kfree(sq_bitmap);
-	kmem_cache_destroy(sq_cache);
-
-	return ret;
-}
-
-static void __exit sq_api_exit(void)
-{
-	subsys_interface_unregister(&sq_interface);
-	kfree(sq_bitmap);
-	kmem_cache_destroy(sq_cache);
-}
-
-module_init(sq_api_init);
-module_exit(sq_api_exit);
-
-MODULE_AUTHOR("Paul Mundt <lethal@linux-sh.org>, M. R. Brown <mrbrown@0xd6.org>");
-MODULE_DESCRIPTION("Simple API for SH-4 integrated Store Queues");
-MODULE_LICENSE("GPL");
diff --git a/arch/sh/kernel/cpu/sh4a/Makefile b/arch/sh/kernel/cpu/sh4a/Makefile
deleted file mode 100644
index baf73a8fc2a0f1..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/Makefile
+++ /dev/null
@@ -1,53 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the Linux/SuperH SH-4 backends.
-#
-
-# CPU subtype setup
-obj-$(CONFIG_CPU_SUBTYPE_SH7757)	+= setup-sh7757.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7763)	+= setup-sh7763.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7770)	+= setup-sh7770.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7780)	+= setup-sh7780.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7785)	+= setup-sh7785.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7786)	+= setup-sh7786.o intc-shx3.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7343)	+= setup-sh7343.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7722)	+= setup-sh7722.o serial-sh7722.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7723)	+= setup-sh7723.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7724)	+= setup-sh7724.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7734)	+= setup-sh7734.o
-obj-$(CONFIG_CPU_SUBTYPE_SH7366)	+= setup-sh7366.o
-obj-$(CONFIG_CPU_SUBTYPE_SHX3)		+= setup-shx3.o intc-shx3.o
-
-# SMP setup
-smp-$(CONFIG_CPU_SHX3)			:= smp-shx3.o
-
-# Primary on-chip clocks (common)
-clock-$(CONFIG_CPU_SUBTYPE_SH7757)	:= clock-sh7757.o
-clock-$(CONFIG_CPU_SUBTYPE_SH7763)	:= clock-sh7763.o
-clock-$(CONFIG_CPU_SUBTYPE_SH7770)	:= clock-sh7770.o
-clock-$(CONFIG_CPU_SUBTYPE_SH7780)	:= clock-sh7780.o
-clock-$(CONFIG_CPU_SUBTYPE_SH7785)	:= clock-sh7785.o
-clock-$(CONFIG_CPU_SUBTYPE_SH7786)	:= clock-sh7786.o
-clock-$(CONFIG_CPU_SUBTYPE_SH7343)	:= clock-sh7343.o
-clock-$(CONFIG_CPU_SUBTYPE_SH7722)	:= clock-sh7722.o
-clock-$(CONFIG_CPU_SUBTYPE_SH7723)	:= clock-sh7723.o
-clock-$(CONFIG_CPU_SUBTYPE_SH7724)	:= clock-sh7724.o
-clock-$(CONFIG_CPU_SUBTYPE_SH7734)	:= clock-sh7734.o
-clock-$(CONFIG_CPU_SUBTYPE_SH7366)	:= clock-sh7366.o
-clock-$(CONFIG_CPU_SUBTYPE_SHX3)	:= clock-shx3.o
-
-# Pinmux setup
-pinmux-$(CONFIG_CPU_SUBTYPE_SH7722)	:= pinmux-sh7722.o
-pinmux-$(CONFIG_CPU_SUBTYPE_SH7723)	:= pinmux-sh7723.o
-pinmux-$(CONFIG_CPU_SUBTYPE_SH7724)	:= pinmux-sh7724.o
-pinmux-$(CONFIG_CPU_SUBTYPE_SH7734)	:= pinmux-sh7734.o
-pinmux-$(CONFIG_CPU_SUBTYPE_SH7757)	:= pinmux-sh7757.o
-pinmux-$(CONFIG_CPU_SUBTYPE_SH7785)	:= pinmux-sh7785.o
-pinmux-$(CONFIG_CPU_SUBTYPE_SH7786)	:= pinmux-sh7786.o
-pinmux-$(CONFIG_CPU_SUBTYPE_SHX3)	:= pinmux-shx3.o
-
-obj-y					+= $(clock-y)
-obj-$(CONFIG_SMP)			+= $(smp-y)
-obj-$(CONFIG_GPIOLIB)			+= $(pinmux-y)
-obj-$(CONFIG_PERF_EVENTS)		+= perf_event.o
-obj-$(CONFIG_HAVE_HW_BREAKPOINT)	+= ubc.o
diff --git a/arch/sh/kernel/cpu/sh4a/clock-sh7343.c b/arch/sh/kernel/cpu/sh4a/clock-sh7343.c
deleted file mode 100644
index 32cb5d1fd3b32f..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/clock-sh7343.c
+++ /dev/null
@@ -1,277 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh4a/clock-sh7343.c
- *
- * SH7343 clock framework support
- *
- * Copyright (C) 2009 Magnus Damm
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/clkdev.h>
-#include <asm/clock.h>
-
-/* SH7343 registers */
-#define FRQCR		0xa4150000
-#define VCLKCR		0xa4150004
-#define SCLKACR		0xa4150008
-#define SCLKBCR		0xa415000c
-#define PLLCR		0xa4150024
-#define MSTPCR0		0xa4150030
-#define MSTPCR1		0xa4150034
-#define MSTPCR2		0xa4150038
-#define DLLFRQ		0xa4150050
-
-/* Fixed 32 KHz root clock for RTC and Power Management purposes */
-static struct clk r_clk = {
-	.rate           = 32768,
-};
-
-/*
- * Default rate for the root input clock, reset this with clk_set_rate()
- * from the platform code.
- */
-struct clk extal_clk = {
-	.rate		= 33333333,
-};
-
-/* The dll block multiplies the 32khz r_clk, may be used instead of extal */
-static unsigned long dll_recalc(struct clk *clk)
-{
-	unsigned long mult;
-
-	if (__raw_readl(PLLCR) & 0x1000)
-		mult = __raw_readl(DLLFRQ);
-	else
-		mult = 0;
-
-	return clk->parent->rate * mult;
-}
-
-static struct sh_clk_ops dll_clk_ops = {
-	.recalc		= dll_recalc,
-};
-
-static struct clk dll_clk = {
-	.ops		= &dll_clk_ops,
-	.parent		= &r_clk,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-static unsigned long pll_recalc(struct clk *clk)
-{
-	unsigned long mult = 1;
-
-	if (__raw_readl(PLLCR) & 0x4000)
-		mult = (((__raw_readl(FRQCR) >> 24) & 0x1f) + 1);
-
-	return clk->parent->rate * mult;
-}
-
-static struct sh_clk_ops pll_clk_ops = {
-	.recalc		= pll_recalc,
-};
-
-static struct clk pll_clk = {
-	.ops		= &pll_clk_ops,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-struct clk *main_clks[] = {
-	&r_clk,
-	&extal_clk,
-	&dll_clk,
-	&pll_clk,
-};
-
-static int multipliers[] = { 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
-static int divisors[] = { 1, 3, 2, 5, 3, 4, 5, 6, 8, 10, 12, 16, 20 };
-
-static struct clk_div_mult_table div4_div_mult_table = {
-	.divisors = divisors,
-	.nr_divisors = ARRAY_SIZE(divisors),
-	.multipliers = multipliers,
-	.nr_multipliers = ARRAY_SIZE(multipliers),
-};
-
-static struct clk_div4_table div4_table = {
-	.div_mult_table = &div4_div_mult_table,
-};
-
-enum { DIV4_I, DIV4_U, DIV4_SH, DIV4_B, DIV4_B3, DIV4_P,
-       DIV4_SIUA, DIV4_SIUB, DIV4_NR };
-
-#define DIV4(_reg, _bit, _mask, _flags) \
-  SH_CLK_DIV4(&pll_clk, _reg, _bit, _mask, _flags)
-
-struct clk div4_clks[DIV4_NR] = {
-	[DIV4_I] = DIV4(FRQCR, 20, 0x1fff, CLK_ENABLE_ON_INIT),
-	[DIV4_U] = DIV4(FRQCR, 16, 0x1fff, CLK_ENABLE_ON_INIT),
-	[DIV4_SH] = DIV4(FRQCR, 12, 0x1fff, CLK_ENABLE_ON_INIT),
-	[DIV4_B] = DIV4(FRQCR, 8, 0x1fff, CLK_ENABLE_ON_INIT),
-	[DIV4_B3] = DIV4(FRQCR, 4, 0x1fff, CLK_ENABLE_ON_INIT),
-	[DIV4_P] = DIV4(FRQCR, 0, 0x1fff, 0),
-	[DIV4_SIUA] = DIV4(SCLKACR, 0, 0x1fff, 0),
-	[DIV4_SIUB] = DIV4(SCLKBCR, 0, 0x1fff, 0),
-};
-
-enum { DIV6_V, DIV6_NR };
-
-struct clk div6_clks[DIV6_NR] = {
-	[DIV6_V] = SH_CLK_DIV6(&pll_clk, VCLKCR, 0),
-};
-
-#define MSTP(_parent, _reg, _bit, _flags) \
-  SH_CLK_MSTP32(_parent, _reg, _bit, _flags)
-
-enum { MSTP031, MSTP030, MSTP029, MSTP028, MSTP026,
-       MSTP023, MSTP022, MSTP021, MSTP020, MSTP019, MSTP018, MSTP017, MSTP016,
-       MSTP015, MSTP014, MSTP013, MSTP012, MSTP011, MSTP010,
-       MSTP007, MSTP006, MSTP005, MSTP004, MSTP003, MSTP002, MSTP001,
-       MSTP109, MSTP108, MSTP100,
-       MSTP225, MSTP224, MSTP218, MSTP217, MSTP216,
-       MSTP214, MSTP213, MSTP212, MSTP211, MSTP208,
-       MSTP206, MSTP205, MSTP204, MSTP203, MSTP202, MSTP201, MSTP200,
-       MSTP_NR };
-
-static struct clk mstp_clks[MSTP_NR] = {
-	[MSTP031] = MSTP(&div4_clks[DIV4_I], MSTPCR0, 31, CLK_ENABLE_ON_INIT),
-	[MSTP030] = MSTP(&div4_clks[DIV4_I], MSTPCR0, 30, CLK_ENABLE_ON_INIT),
-	[MSTP029] = MSTP(&div4_clks[DIV4_I], MSTPCR0, 29, CLK_ENABLE_ON_INIT),
-	[MSTP028] = MSTP(&div4_clks[DIV4_U], MSTPCR0, 28, CLK_ENABLE_ON_INIT),
-	[MSTP026] = MSTP(&div4_clks[DIV4_B], MSTPCR0, 26, CLK_ENABLE_ON_INIT),
-	[MSTP023] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 23, 0),
-	[MSTP022] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 22, 0),
-	[MSTP021] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 21, 0),
-	[MSTP020] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 20, 0),
-	[MSTP019] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 19, 0),
-	[MSTP017] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 17, 0),
-	[MSTP015] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 15, 0),
-	[MSTP014] = MSTP(&r_clk, MSTPCR0, 14, 0),
-	[MSTP013] = MSTP(&r_clk, MSTPCR0, 13, 0),
-	[MSTP011] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 11, 0),
-	[MSTP010] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 10, 0),
-	[MSTP007] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 7, 0),
-	[MSTP006] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 6, 0),
-	[MSTP005] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 5, 0),
-	[MSTP004] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 4, 0),
-	[MSTP003] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 3, 0),
-	[MSTP002] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 2, 0),
-	[MSTP001] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 1, 0),
-
-	[MSTP109] = MSTP(&div4_clks[DIV4_P], MSTPCR1, 9, 0),
-	[MSTP108] = MSTP(&div4_clks[DIV4_P], MSTPCR1, 8, 0),
-
-	[MSTP225] = MSTP(&div4_clks[DIV4_P], MSTPCR2, 25, 0),
-	[MSTP224] = MSTP(&div4_clks[DIV4_P], MSTPCR2, 24, 0),
-	[MSTP218] = MSTP(&div4_clks[DIV4_P], MSTPCR2, 18, 0),
-	[MSTP217] = MSTP(&div4_clks[DIV4_P], MSTPCR2, 17, 0),
-	[MSTP216] = MSTP(&div4_clks[DIV4_P], MSTPCR2, 16, 0),
-	[MSTP214] = MSTP(&r_clk, MSTPCR2, 14, 0),
-	[MSTP213] = MSTP(&div4_clks[DIV4_P], MSTPCR2, 13, 0),
-	[MSTP212] = MSTP(&div4_clks[DIV4_P], MSTPCR2, 12, 0),
-	[MSTP211] = MSTP(&div4_clks[DIV4_P], MSTPCR2, 11, 0),
-	[MSTP208] = MSTP(&div4_clks[DIV4_B], MSTPCR2, 8, 0),
-	[MSTP206] = MSTP(&div4_clks[DIV4_B], MSTPCR2, 6, CLK_ENABLE_ON_INIT),
-	[MSTP205] = MSTP(&div4_clks[DIV4_B], MSTPCR2, 5, 0),
-	[MSTP204] = MSTP(&div4_clks[DIV4_B], MSTPCR2, 4, 0),
-	[MSTP203] = MSTP(&div4_clks[DIV4_B], MSTPCR2, 3, 0),
-	[MSTP202] = MSTP(&div4_clks[DIV4_B], MSTPCR2, 2, CLK_ENABLE_ON_INIT),
-	[MSTP201] = MSTP(&div4_clks[DIV4_B], MSTPCR2, 1, CLK_ENABLE_ON_INIT),
-	[MSTP200] = MSTP(&div4_clks[DIV4_B], MSTPCR2, 0, 0),
-};
-
-static struct clk_lookup lookups[] = {
-	/* main clocks */
-	CLKDEV_CON_ID("rclk", &r_clk),
-	CLKDEV_CON_ID("extal", &extal_clk),
-	CLKDEV_CON_ID("dll_clk", &dll_clk),
-	CLKDEV_CON_ID("pll_clk", &pll_clk),
-
-	/* DIV4 clocks */
-	CLKDEV_CON_ID("cpu_clk", &div4_clks[DIV4_I]),
-	CLKDEV_CON_ID("umem_clk", &div4_clks[DIV4_U]),
-	CLKDEV_CON_ID("shyway_clk", &div4_clks[DIV4_SH]),
-	CLKDEV_CON_ID("bus_clk", &div4_clks[DIV4_B]),
-	CLKDEV_CON_ID("b3_clk", &div4_clks[DIV4_B3]),
-	CLKDEV_CON_ID("peripheral_clk", &div4_clks[DIV4_P]),
-	CLKDEV_CON_ID("siua_clk", &div4_clks[DIV4_SIUA]),
-	CLKDEV_CON_ID("siub_clk", &div4_clks[DIV4_SIUB]),
-
-	/* DIV6 clocks */
-	CLKDEV_CON_ID("video_clk", &div6_clks[DIV6_V]),
-
-	/* MSTP32 clocks */
-	CLKDEV_CON_ID("tlb0", &mstp_clks[MSTP031]),
-	CLKDEV_CON_ID("ic0", &mstp_clks[MSTP030]),
-	CLKDEV_CON_ID("oc0", &mstp_clks[MSTP029]),
-	CLKDEV_CON_ID("uram0", &mstp_clks[MSTP028]),
-	CLKDEV_CON_ID("xymem0", &mstp_clks[MSTP026]),
-	CLKDEV_CON_ID("intc3", &mstp_clks[MSTP023]),
-	CLKDEV_CON_ID("intc0", &mstp_clks[MSTP022]),
-	CLKDEV_CON_ID("dmac0", &mstp_clks[MSTP021]),
-	CLKDEV_CON_ID("sh0", &mstp_clks[MSTP020]),
-	CLKDEV_CON_ID("hudi0", &mstp_clks[MSTP019]),
-	CLKDEV_CON_ID("ubc0", &mstp_clks[MSTP017]),
-	CLKDEV_CON_ID("tmu_fck", &mstp_clks[MSTP015]),
-	CLKDEV_ICK_ID("fck", "sh-cmt-32.0", &mstp_clks[MSTP014]),
-	CLKDEV_CON_ID("rwdt0", &mstp_clks[MSTP013]),
-	CLKDEV_CON_ID("mfi0", &mstp_clks[MSTP011]),
-	CLKDEV_CON_ID("flctl0", &mstp_clks[MSTP010]),
-
-	CLKDEV_ICK_ID("fck", "sh-sci.0", &mstp_clks[MSTP007]),
-	CLKDEV_ICK_ID("fck", "sh-sci.1", &mstp_clks[MSTP006]),
-	CLKDEV_ICK_ID("fck", "sh-sci.2", &mstp_clks[MSTP005]),
-	CLKDEV_ICK_ID("fck", "sh-sci.3", &mstp_clks[MSTP004]),
-
-	CLKDEV_CON_ID("sio0", &mstp_clks[MSTP003]),
-	CLKDEV_CON_ID("siof0", &mstp_clks[MSTP002]),
-	CLKDEV_CON_ID("siof1", &mstp_clks[MSTP001]),
-	CLKDEV_DEV_ID("i2c-sh_mobile.0", &mstp_clks[MSTP109]),
-	CLKDEV_DEV_ID("i2c-sh_mobile.1", &mstp_clks[MSTP108]),
-	CLKDEV_CON_ID("tpu0", &mstp_clks[MSTP225]),
-	CLKDEV_CON_ID("irda0", &mstp_clks[MSTP224]),
-	CLKDEV_CON_ID("sdhi0", &mstp_clks[MSTP218]),
-	CLKDEV_CON_ID("mmcif0", &mstp_clks[MSTP217]),
-	CLKDEV_CON_ID("sim0", &mstp_clks[MSTP216]),
-	CLKDEV_CON_ID("keysc0", &mstp_clks[MSTP214]),
-	CLKDEV_CON_ID("tsif0", &mstp_clks[MSTP213]),
-	CLKDEV_CON_ID("s3d40", &mstp_clks[MSTP212]),
-	CLKDEV_CON_ID("usbf0", &mstp_clks[MSTP211]),
-	CLKDEV_CON_ID("siu0", &mstp_clks[MSTP208]),
-	CLKDEV_CON_ID("jpu0", &mstp_clks[MSTP206]),
-	CLKDEV_CON_ID("vou0", &mstp_clks[MSTP205]),
-	CLKDEV_CON_ID("beu0", &mstp_clks[MSTP204]),
-	CLKDEV_CON_ID("ceu0", &mstp_clks[MSTP203]),
-	CLKDEV_CON_ID("veu0", &mstp_clks[MSTP202]),
-	CLKDEV_CON_ID("vpu0", &mstp_clks[MSTP201]),
-	CLKDEV_CON_ID("lcdc0", &mstp_clks[MSTP200]),
-};
-
-int __init arch_clk_init(void)
-{
-	int k, ret = 0;
-
-	/* autodetect extal or dll configuration */
-	if (__raw_readl(PLLCR) & 0x1000)
-		pll_clk.parent = &dll_clk;
-	else
-		pll_clk.parent = &extal_clk;
-
-	for (k = 0; !ret && (k < ARRAY_SIZE(main_clks)); k++)
-		ret = clk_register(main_clks[k]);
-
-	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
-
-	if (!ret)
-		ret = sh_clk_div4_register(div4_clks, DIV4_NR, &div4_table);
-
-	if (!ret)
-		ret = sh_clk_div6_register(div6_clks, DIV6_NR);
-
-	if (!ret)
-		ret = sh_clk_mstp_register(mstp_clks, MSTP_NR);
-
-	return ret;
-}
diff --git a/arch/sh/kernel/cpu/sh4a/clock-sh7366.c b/arch/sh/kernel/cpu/sh4a/clock-sh7366.c
deleted file mode 100644
index aa3444b41e72a2..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/clock-sh7366.c
+++ /dev/null
@@ -1,270 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh4a/clock-sh7366.c
- *
- * SH7366 clock framework support
- *
- * Copyright (C) 2009 Magnus Damm
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/clkdev.h>
-#include <asm/clock.h>
-
-/* SH7366 registers */
-#define FRQCR		0xa4150000
-#define VCLKCR		0xa4150004
-#define SCLKACR		0xa4150008
-#define SCLKBCR		0xa415000c
-#define PLLCR		0xa4150024
-#define MSTPCR0		0xa4150030
-#define MSTPCR1		0xa4150034
-#define MSTPCR2		0xa4150038
-#define DLLFRQ		0xa4150050
-
-/* Fixed 32 KHz root clock for RTC and Power Management purposes */
-static struct clk r_clk = {
-	.rate           = 32768,
-};
-
-/*
- * Default rate for the root input clock, reset this with clk_set_rate()
- * from the platform code.
- */
-struct clk extal_clk = {
-	.rate		= 33333333,
-};
-
-/* The dll block multiplies the 32khz r_clk, may be used instead of extal */
-static unsigned long dll_recalc(struct clk *clk)
-{
-	unsigned long mult;
-
-	if (__raw_readl(PLLCR) & 0x1000)
-		mult = __raw_readl(DLLFRQ);
-	else
-		mult = 0;
-
-	return clk->parent->rate * mult;
-}
-
-static struct sh_clk_ops dll_clk_ops = {
-	.recalc		= dll_recalc,
-};
-
-static struct clk dll_clk = {
-	.ops		= &dll_clk_ops,
-	.parent		= &r_clk,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-static unsigned long pll_recalc(struct clk *clk)
-{
-	unsigned long mult = 1;
-	unsigned long div = 1;
-
-	if (__raw_readl(PLLCR) & 0x4000)
-		mult = (((__raw_readl(FRQCR) >> 24) & 0x1f) + 1);
-	else
-		div = 2;
-
-	return (clk->parent->rate * mult) / div;
-}
-
-static struct sh_clk_ops pll_clk_ops = {
-	.recalc		= pll_recalc,
-};
-
-static struct clk pll_clk = {
-	.ops		= &pll_clk_ops,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-struct clk *main_clks[] = {
-	&r_clk,
-	&extal_clk,
-	&dll_clk,
-	&pll_clk,
-};
-
-static int multipliers[] = { 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
-static int divisors[] = { 1, 3, 2, 5, 3, 4, 5, 6, 8, 10, 12, 16, 20 };
-
-static struct clk_div_mult_table div4_div_mult_table = {
-	.divisors = divisors,
-	.nr_divisors = ARRAY_SIZE(divisors),
-	.multipliers = multipliers,
-	.nr_multipliers = ARRAY_SIZE(multipliers),
-};
-
-static struct clk_div4_table div4_table = {
-	.div_mult_table = &div4_div_mult_table,
-};
-
-enum { DIV4_I, DIV4_U, DIV4_SH, DIV4_B, DIV4_B3, DIV4_P,
-       DIV4_SIUA, DIV4_SIUB, DIV4_NR };
-
-#define DIV4(_reg, _bit, _mask, _flags) \
-  SH_CLK_DIV4(&pll_clk, _reg, _bit, _mask, _flags)
-
-struct clk div4_clks[DIV4_NR] = {
-	[DIV4_I] = DIV4(FRQCR, 20, 0x1fef, CLK_ENABLE_ON_INIT),
-	[DIV4_U] = DIV4(FRQCR, 16, 0x1fff, CLK_ENABLE_ON_INIT),
-	[DIV4_SH] = DIV4(FRQCR, 12, 0x1fff, CLK_ENABLE_ON_INIT),
-	[DIV4_B] = DIV4(FRQCR, 8, 0x1fff, CLK_ENABLE_ON_INIT),
-	[DIV4_B3] = DIV4(FRQCR, 4, 0x1fff, CLK_ENABLE_ON_INIT),
-	[DIV4_P] = DIV4(FRQCR, 0, 0x1fff, 0),
-	[DIV4_SIUA] = DIV4(SCLKACR, 0, 0x1fff, 0),
-	[DIV4_SIUB] = DIV4(SCLKBCR, 0, 0x1fff, 0),
-};
-
-enum { DIV6_V, DIV6_NR };
-
-struct clk div6_clks[DIV6_NR] = {
-	[DIV6_V] = SH_CLK_DIV6(&pll_clk, VCLKCR, 0),
-};
-
-#define MSTP(_parent, _reg, _bit, _flags) \
-  SH_CLK_MSTP32(_parent, _reg, _bit, _flags)
-
-enum { MSTP031, MSTP030, MSTP029, MSTP028, MSTP026,
-       MSTP023, MSTP022, MSTP021, MSTP020, MSTP019, MSTP018, MSTP017, MSTP016,
-       MSTP015, MSTP014, MSTP013, MSTP012, MSTP011, MSTP010,
-       MSTP007, MSTP006, MSTP005, MSTP002, MSTP001,
-       MSTP109, MSTP100,
-       MSTP227, MSTP226, MSTP224, MSTP223, MSTP222, MSTP218, MSTP217,
-       MSTP211, MSTP207, MSTP205, MSTP204, MSTP203, MSTP202, MSTP201, MSTP200,
-       MSTP_NR };
-
-static struct clk mstp_clks[MSTP_NR] = {
-	/* See page 52 of Datasheet V0.40: Overview -> Block Diagram */
-	[MSTP031] = MSTP(&div4_clks[DIV4_I], MSTPCR0, 31, CLK_ENABLE_ON_INIT),
-	[MSTP030] = MSTP(&div4_clks[DIV4_I], MSTPCR0, 30, CLK_ENABLE_ON_INIT),
-	[MSTP029] = MSTP(&div4_clks[DIV4_I], MSTPCR0, 29, CLK_ENABLE_ON_INIT),
-	[MSTP028] = MSTP(&div4_clks[DIV4_SH], MSTPCR0, 28, CLK_ENABLE_ON_INIT),
-	[MSTP026] = MSTP(&div4_clks[DIV4_B], MSTPCR0, 26, CLK_ENABLE_ON_INIT),
-	[MSTP023] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 23, 0),
-	[MSTP022] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 22, 0),
-	[MSTP021] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 21, 0),
-	[MSTP020] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 20, 0),
-	[MSTP019] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 19, 0),
-	[MSTP017] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 17, 0),
-	[MSTP015] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 15, 0),
-	[MSTP014] = MSTP(&r_clk, MSTPCR0, 14, 0),
-	[MSTP013] = MSTP(&r_clk, MSTPCR0, 13, 0),
-	[MSTP011] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 11, 0),
-	[MSTP010] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 10, 0),
-	[MSTP007] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 7, 0),
-	[MSTP006] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 6, 0),
-	[MSTP005] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 5, 0),
-	[MSTP002] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 2, 0),
-	[MSTP001] = MSTP(&div4_clks[DIV4_P], MSTPCR0, 1, 0),
-
-	[MSTP109] = MSTP(&div4_clks[DIV4_P], MSTPCR1, 9, 0),
-
-	[MSTP227] = MSTP(&div4_clks[DIV4_P], MSTPCR2, 27, 0),
-	[MSTP226] = MSTP(&div4_clks[DIV4_P], MSTPCR2, 26, 0),
-	[MSTP224] = MSTP(&div4_clks[DIV4_P], MSTPCR2, 24, 0),
-	[MSTP223] = MSTP(&div4_clks[DIV4_P], MSTPCR2, 23, 0),
-	[MSTP222] = MSTP(&div4_clks[DIV4_P], MSTPCR2, 22, 0),
-	[MSTP218] = MSTP(&div4_clks[DIV4_P], MSTPCR2, 18, 0),
-	[MSTP217] = MSTP(&div4_clks[DIV4_P], MSTPCR2, 17, 0),
-	[MSTP211] = MSTP(&div4_clks[DIV4_P], MSTPCR2, 11, 0),
-	[MSTP207] = MSTP(&div4_clks[DIV4_B], MSTPCR2, 7, CLK_ENABLE_ON_INIT),
-	[MSTP205] = MSTP(&div4_clks[DIV4_B], MSTPCR2, 5, 0),
-	[MSTP204] = MSTP(&div4_clks[DIV4_B], MSTPCR2, 4, 0),
-	[MSTP203] = MSTP(&div4_clks[DIV4_B], MSTPCR2, 3, 0),
-	[MSTP202] = MSTP(&div4_clks[DIV4_B], MSTPCR2, 2, CLK_ENABLE_ON_INIT),
-	[MSTP201] = MSTP(&div4_clks[DIV4_B], MSTPCR2, 1, CLK_ENABLE_ON_INIT),
-	[MSTP200] = MSTP(&div4_clks[DIV4_B], MSTPCR2, 0, 0),
-};
-
-static struct clk_lookup lookups[] = {
-	/* main clocks */
-	CLKDEV_CON_ID("rclk", &r_clk),
-	CLKDEV_CON_ID("extal", &extal_clk),
-	CLKDEV_CON_ID("dll_clk", &dll_clk),
-	CLKDEV_CON_ID("pll_clk", &pll_clk),
-
-	/* DIV4 clocks */
-	CLKDEV_CON_ID("cpu_clk", &div4_clks[DIV4_I]),
-	CLKDEV_CON_ID("umem_clk", &div4_clks[DIV4_U]),
-	CLKDEV_CON_ID("shyway_clk", &div4_clks[DIV4_SH]),
-	CLKDEV_CON_ID("bus_clk", &div4_clks[DIV4_B]),
-	CLKDEV_CON_ID("b3_clk", &div4_clks[DIV4_B3]),
-	CLKDEV_CON_ID("peripheral_clk", &div4_clks[DIV4_P]),
-	CLKDEV_CON_ID("siua_clk", &div4_clks[DIV4_SIUA]),
-	CLKDEV_CON_ID("siub_clk", &div4_clks[DIV4_SIUB]),
-
-	/* DIV6 clocks */
-	CLKDEV_CON_ID("video_clk", &div6_clks[DIV6_V]),
-
-	/* MSTP32 clocks */
-	CLKDEV_CON_ID("tlb0", &mstp_clks[MSTP031]),
-	CLKDEV_CON_ID("ic0", &mstp_clks[MSTP030]),
-	CLKDEV_CON_ID("oc0", &mstp_clks[MSTP029]),
-	CLKDEV_CON_ID("rsmem0", &mstp_clks[MSTP028]),
-	CLKDEV_CON_ID("xymem0", &mstp_clks[MSTP026]),
-	CLKDEV_CON_ID("intc3", &mstp_clks[MSTP023]),
-	CLKDEV_CON_ID("intc0", &mstp_clks[MSTP022]),
-	CLKDEV_CON_ID("dmac0", &mstp_clks[MSTP021]),
-	CLKDEV_CON_ID("sh0", &mstp_clks[MSTP020]),
-	CLKDEV_CON_ID("hudi0", &mstp_clks[MSTP019]),
-	CLKDEV_CON_ID("ubc0", &mstp_clks[MSTP017]),
-	CLKDEV_CON_ID("tmu_fck", &mstp_clks[MSTP015]),
-	CLKDEV_ICK_ID("fck", "sh-cmt-32.0", &mstp_clks[MSTP014]),
-	CLKDEV_CON_ID("rwdt0", &mstp_clks[MSTP013]),
-	CLKDEV_CON_ID("mfi0", &mstp_clks[MSTP011]),
-	CLKDEV_CON_ID("flctl0", &mstp_clks[MSTP010]),
-
-	CLKDEV_ICK_ID("fck", "sh-sci.0", &mstp_clks[MSTP007]),
-	CLKDEV_ICK_ID("fck", "sh-sci.1", &mstp_clks[MSTP006]),
-	CLKDEV_ICK_ID("fck", "sh-sci.2", &mstp_clks[MSTP005]),
-
-	CLKDEV_CON_ID("msiof0", &mstp_clks[MSTP002]),
-	CLKDEV_CON_ID("sbr0", &mstp_clks[MSTP001]),
-	CLKDEV_DEV_ID("i2c-sh_mobile.0", &mstp_clks[MSTP109]),
-	CLKDEV_CON_ID("icb0", &mstp_clks[MSTP227]),
-	CLKDEV_CON_ID("meram0", &mstp_clks[MSTP226]),
-	CLKDEV_CON_ID("dacy1", &mstp_clks[MSTP224]),
-	CLKDEV_CON_ID("dacy0", &mstp_clks[MSTP223]),
-	CLKDEV_CON_ID("tsif0", &mstp_clks[MSTP222]),
-	CLKDEV_CON_ID("sdhi0", &mstp_clks[MSTP218]),
-	CLKDEV_CON_ID("mmcif0", &mstp_clks[MSTP217]),
-	CLKDEV_CON_ID("usbf0", &mstp_clks[MSTP211]),
-	CLKDEV_CON_ID("veu1", &mstp_clks[MSTP207]),
-	CLKDEV_CON_ID("vou0", &mstp_clks[MSTP205]),
-	CLKDEV_CON_ID("beu0", &mstp_clks[MSTP204]),
-	CLKDEV_CON_ID("ceu0", &mstp_clks[MSTP203]),
-	CLKDEV_CON_ID("veu0", &mstp_clks[MSTP202]),
-	CLKDEV_CON_ID("vpu0", &mstp_clks[MSTP201]),
-	CLKDEV_CON_ID("lcdc0", &mstp_clks[MSTP200]),
-};
-
-int __init arch_clk_init(void)
-{
-	int k, ret = 0;
-
-	/* autodetect extal or dll configuration */
-	if (__raw_readl(PLLCR) & 0x1000)
-		pll_clk.parent = &dll_clk;
-	else
-		pll_clk.parent = &extal_clk;
-
-	for (k = 0; !ret && (k < ARRAY_SIZE(main_clks)); k++)
-		ret = clk_register(main_clks[k]);
-
-	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
-
-	if (!ret)
-		ret = sh_clk_div4_register(div4_clks, DIV4_NR, &div4_table);
-
-	if (!ret)
-		ret = sh_clk_div6_register(div6_clks, DIV6_NR);
-
-	if (!ret)
-		ret = sh_clk_mstp_register(mstp_clks, MSTP_NR);
-
-	return ret;
-}
diff --git a/arch/sh/kernel/cpu/sh4a/clock-sh7722.c b/arch/sh/kernel/cpu/sh4a/clock-sh7722.c
deleted file mode 100644
index 38b057703eaada..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/clock-sh7722.c
+++ /dev/null
@@ -1,253 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh4a/clock-sh7722.c
- *
- * SH7722 clock framework support
- *
- * Copyright (C) 2009 Magnus Damm
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/clkdev.h>
-#include <linux/sh_clk.h>
-#include <asm/clock.h>
-#include <cpu/sh7722.h>
-
-/* SH7722 registers */
-#define FRQCR		0xa4150000
-#define VCLKCR		0xa4150004
-#define SCLKACR		0xa4150008
-#define SCLKBCR		0xa415000c
-#define IRDACLKCR	0xa4150018
-#define PLLCR		0xa4150024
-#define MSTPCR0		0xa4150030
-#define MSTPCR1		0xa4150034
-#define MSTPCR2		0xa4150038
-#define DLLFRQ		0xa4150050
-
-/* Fixed 32 KHz root clock for RTC and Power Management purposes */
-static struct clk r_clk = {
-	.rate           = 32768,
-};
-
-/*
- * Default rate for the root input clock, reset this with clk_set_rate()
- * from the platform code.
- */
-struct clk extal_clk = {
-	.rate		= 33333333,
-};
-
-/* The dll block multiplies the 32khz r_clk, may be used instead of extal */
-static unsigned long dll_recalc(struct clk *clk)
-{
-	unsigned long mult;
-
-	if (__raw_readl(PLLCR) & 0x1000)
-		mult = __raw_readl(DLLFRQ);
-	else
-		mult = 0;
-
-	return clk->parent->rate * mult;
-}
-
-static struct sh_clk_ops dll_clk_ops = {
-	.recalc		= dll_recalc,
-};
-
-static struct clk dll_clk = {
-	.ops		= &dll_clk_ops,
-	.parent		= &r_clk,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-static unsigned long pll_recalc(struct clk *clk)
-{
-	unsigned long mult = 1;
-	unsigned long div = 1;
-
-	if (__raw_readl(PLLCR) & 0x4000)
-		mult = (((__raw_readl(FRQCR) >> 24) & 0x1f) + 1);
-	else
-		div = 2;
-
-	return (clk->parent->rate * mult) / div;
-}
-
-static struct sh_clk_ops pll_clk_ops = {
-	.recalc		= pll_recalc,
-};
-
-static struct clk pll_clk = {
-	.ops		= &pll_clk_ops,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-struct clk *main_clks[] = {
-	&r_clk,
-	&extal_clk,
-	&dll_clk,
-	&pll_clk,
-};
-
-static int multipliers[] = { 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
-static int divisors[] = { 1, 3, 2, 5, 3, 4, 5, 6, 8, 10, 12, 16, 20 };
-
-static struct clk_div_mult_table div4_div_mult_table = {
-	.divisors = divisors,
-	.nr_divisors = ARRAY_SIZE(divisors),
-	.multipliers = multipliers,
-	.nr_multipliers = ARRAY_SIZE(multipliers),
-};
-
-static struct clk_div4_table div4_table = {
-	.div_mult_table = &div4_div_mult_table,
-};
-
-#define DIV4(_reg, _bit, _mask, _flags) \
-  SH_CLK_DIV4(&pll_clk, _reg, _bit, _mask, _flags)
-
-enum { DIV4_I, DIV4_U, DIV4_SH, DIV4_B, DIV4_B3, DIV4_P, DIV4_NR };
-
-struct clk div4_clks[DIV4_NR] = {
-	[DIV4_I] = DIV4(FRQCR, 20, 0x1fef, CLK_ENABLE_ON_INIT),
-	[DIV4_U] = DIV4(FRQCR, 16, 0x1fff, CLK_ENABLE_ON_INIT),
-	[DIV4_SH] = DIV4(FRQCR, 12, 0x1fff, CLK_ENABLE_ON_INIT),
-	[DIV4_B] = DIV4(FRQCR, 8, 0x1fff, CLK_ENABLE_ON_INIT),
-	[DIV4_B3] = DIV4(FRQCR, 4, 0x1fff, CLK_ENABLE_ON_INIT),
-	[DIV4_P] = DIV4(FRQCR, 0, 0x1fff, 0),
-};
-
-enum { DIV4_IRDA, DIV4_ENABLE_NR };
-
-struct clk div4_enable_clks[DIV4_ENABLE_NR] = {
-	[DIV4_IRDA] = DIV4(IRDACLKCR, 0, 0x1fff, 0),
-};
-
-enum { DIV4_SIUA, DIV4_SIUB, DIV4_REPARENT_NR };
-
-struct clk div4_reparent_clks[DIV4_REPARENT_NR] = {
-	[DIV4_SIUA] = DIV4(SCLKACR, 0, 0x1fff, 0),
-	[DIV4_SIUB] = DIV4(SCLKBCR, 0, 0x1fff, 0),
-};
-
-enum { DIV6_V, DIV6_NR };
-
-struct clk div6_clks[DIV6_NR] = {
-	[DIV6_V] = SH_CLK_DIV6(&pll_clk, VCLKCR, 0),
-};
-
-static struct clk mstp_clks[HWBLK_NR] = {
-	[HWBLK_URAM]  = SH_CLK_MSTP32(&div4_clks[DIV4_U], MSTPCR0, 28, CLK_ENABLE_ON_INIT),
-	[HWBLK_XYMEM] = SH_CLK_MSTP32(&div4_clks[DIV4_B], MSTPCR0, 26, CLK_ENABLE_ON_INIT),
-	[HWBLK_TMU]   = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 15, 0),
-	[HWBLK_CMT]   = SH_CLK_MSTP32(&r_clk,		  MSTPCR0, 14, 0),
-	[HWBLK_RWDT]  = SH_CLK_MSTP32(&r_clk,		  MSTPCR0, 13, 0),
-	[HWBLK_FLCTL] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 10, 0),
-	[HWBLK_SCIF0] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 7, 0),
-	[HWBLK_SCIF1] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 6, 0),
-	[HWBLK_SCIF2] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 5, 0),
-
-	[HWBLK_IIC]   = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR1, 9, 0),
-	[HWBLK_RTC]   = SH_CLK_MSTP32(&r_clk,		  MSTPCR1, 8, 0),
-
-	[HWBLK_SDHI]  = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR2, 18, 0),
-	[HWBLK_KEYSC] = SH_CLK_MSTP32(&r_clk,		  MSTPCR2, 14, 0),
-	[HWBLK_USBF]  = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR2, 11, 0),
-	[HWBLK_2DG]   = SH_CLK_MSTP32(&div4_clks[DIV4_B], MSTPCR2, 9, 0),
-	[HWBLK_SIU]   = SH_CLK_MSTP32(&div4_clks[DIV4_B], MSTPCR2, 8, 0),
-	[HWBLK_JPU]   = SH_CLK_MSTP32(&div4_clks[DIV4_B], MSTPCR2, 6, 0),
-	[HWBLK_VOU]   = SH_CLK_MSTP32(&div4_clks[DIV4_B], MSTPCR2, 5, 0),
-	[HWBLK_BEU]   = SH_CLK_MSTP32(&div4_clks[DIV4_B], MSTPCR2, 4, 0),
-	[HWBLK_CEU]   = SH_CLK_MSTP32(&div4_clks[DIV4_B], MSTPCR2, 3, 0),
-	[HWBLK_VEU]   = SH_CLK_MSTP32(&div4_clks[DIV4_B], MSTPCR2, 2, 0),
-	[HWBLK_VPU]   = SH_CLK_MSTP32(&div4_clks[DIV4_B], MSTPCR2, 1, 0),
-	[HWBLK_LCDC]  = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR2, 0, 0),
-};
-
-static struct clk_lookup lookups[] = {
-	/* main clocks */
-	CLKDEV_CON_ID("rclk", &r_clk),
-	CLKDEV_CON_ID("extal", &extal_clk),
-	CLKDEV_CON_ID("dll_clk", &dll_clk),
-	CLKDEV_CON_ID("pll_clk", &pll_clk),
-
-	/* DIV4 clocks */
-	CLKDEV_CON_ID("cpu_clk", &div4_clks[DIV4_I]),
-	CLKDEV_CON_ID("umem_clk", &div4_clks[DIV4_U]),
-	CLKDEV_CON_ID("shyway_clk", &div4_clks[DIV4_SH]),
-	CLKDEV_CON_ID("bus_clk", &div4_clks[DIV4_B]),
-	CLKDEV_CON_ID("b3_clk", &div4_clks[DIV4_B3]),
-	CLKDEV_CON_ID("peripheral_clk", &div4_clks[DIV4_P]),
-	CLKDEV_CON_ID("irda_clk", &div4_enable_clks[DIV4_IRDA]),
-	CLKDEV_CON_ID("siua_clk", &div4_reparent_clks[DIV4_SIUA]),
-	CLKDEV_CON_ID("siub_clk", &div4_reparent_clks[DIV4_SIUB]),
-
-	/* DIV6 clocks */
-	CLKDEV_CON_ID("video_clk", &div6_clks[DIV6_V]),
-
-	/* MSTP clocks */
-	CLKDEV_CON_ID("uram0", &mstp_clks[HWBLK_URAM]),
-	CLKDEV_CON_ID("xymem0", &mstp_clks[HWBLK_XYMEM]),
-
-	CLKDEV_ICK_ID("fck", "sh-tmu.0", &mstp_clks[HWBLK_TMU]),
-
-	CLKDEV_ICK_ID("fck", "sh-cmt-32.0", &mstp_clks[HWBLK_CMT]),
-	CLKDEV_DEV_ID("sh-wdt.0", &mstp_clks[HWBLK_RWDT]),
-	CLKDEV_CON_ID("flctl0", &mstp_clks[HWBLK_FLCTL]),
-
-	CLKDEV_DEV_ID("sh-sci.0", &mstp_clks[HWBLK_SCIF0]),
-	CLKDEV_DEV_ID("sh-sci.1", &mstp_clks[HWBLK_SCIF1]),
-	CLKDEV_DEV_ID("sh-sci.2", &mstp_clks[HWBLK_SCIF2]),
-
-	CLKDEV_DEV_ID("i2c-sh_mobile.0", &mstp_clks[HWBLK_IIC]),
-	CLKDEV_CON_ID("rtc0", &mstp_clks[HWBLK_RTC]),
-	CLKDEV_DEV_ID("sh_mobile_sdhi.0", &mstp_clks[HWBLK_SDHI]),
-	CLKDEV_DEV_ID("sh_keysc.0", &mstp_clks[HWBLK_KEYSC]),
-	CLKDEV_CON_ID("usbf0", &mstp_clks[HWBLK_USBF]),
-	CLKDEV_CON_ID("2dg0", &mstp_clks[HWBLK_2DG]),
-	CLKDEV_DEV_ID("siu-pcm-audio", &mstp_clks[HWBLK_SIU]),
-	CLKDEV_DEV_ID("sh-vou.0", &mstp_clks[HWBLK_VOU]),
-	CLKDEV_CON_ID("jpu0", &mstp_clks[HWBLK_JPU]),
-	CLKDEV_CON_ID("beu0", &mstp_clks[HWBLK_BEU]),
-	CLKDEV_DEV_ID("renesas-ceu.0", &mstp_clks[HWBLK_CEU]),
-	CLKDEV_CON_ID("veu0", &mstp_clks[HWBLK_VEU]),
-	CLKDEV_CON_ID("vpu0", &mstp_clks[HWBLK_VPU]),
-	CLKDEV_DEV_ID("sh_mobile_lcdc_fb.0", &mstp_clks[HWBLK_LCDC]),
-};
-
-int __init arch_clk_init(void)
-{
-	int k, ret = 0;
-
-	/* autodetect extal or dll configuration */
-	if (__raw_readl(PLLCR) & 0x1000)
-		pll_clk.parent = &dll_clk;
-	else
-		pll_clk.parent = &extal_clk;
-
-	for (k = 0; !ret && (k < ARRAY_SIZE(main_clks)); k++)
-		ret = clk_register(main_clks[k]);
-
-	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
-
-	if (!ret)
-		ret = sh_clk_div4_register(div4_clks, DIV4_NR, &div4_table);
-
-	if (!ret)
-		ret = sh_clk_div4_enable_register(div4_enable_clks,
-					DIV4_ENABLE_NR, &div4_table);
-
-	if (!ret)
-		ret = sh_clk_div4_reparent_register(div4_reparent_clks,
-					DIV4_REPARENT_NR, &div4_table);
-
-	if (!ret)
-		ret = sh_clk_div6_register(div6_clks, DIV6_NR);
-
-	if (!ret)
-		ret = sh_clk_mstp_register(mstp_clks, HWBLK_NR);
-
-	return ret;
-}
diff --git a/arch/sh/kernel/cpu/sh4a/clock-sh7723.c b/arch/sh/kernel/cpu/sh4a/clock-sh7723.c
deleted file mode 100644
index 9dc3a987d7cf87..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/clock-sh7723.c
+++ /dev/null
@@ -1,301 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh4a/clock-sh7723.c
- *
- * SH7723 clock framework support
- *
- * Copyright (C) 2009 Magnus Damm
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/clk.h>
-#include <linux/clkdev.h>
-#include <linux/sh_clk.h>
-#include <asm/clock.h>
-#include <cpu/sh7723.h>
-
-/* SH7723 registers */
-#define FRQCR		0xa4150000
-#define VCLKCR		0xa4150004
-#define SCLKACR		0xa4150008
-#define SCLKBCR		0xa415000c
-#define IRDACLKCR	0xa4150018
-#define PLLCR		0xa4150024
-#define MSTPCR0		0xa4150030
-#define MSTPCR1		0xa4150034
-#define MSTPCR2		0xa4150038
-#define DLLFRQ		0xa4150050
-
-/* Fixed 32 KHz root clock for RTC and Power Management purposes */
-static struct clk r_clk = {
-	.rate           = 32768,
-};
-
-/*
- * Default rate for the root input clock, reset this with clk_set_rate()
- * from the platform code.
- */
-struct clk extal_clk = {
-	.rate		= 33333333,
-};
-
-/* The dll multiplies the 32khz r_clk, may be used instead of extal */
-static unsigned long dll_recalc(struct clk *clk)
-{
-	unsigned long mult;
-
-	if (__raw_readl(PLLCR) & 0x1000)
-		mult = __raw_readl(DLLFRQ);
-	else
-		mult = 0;
-
-	return clk->parent->rate * mult;
-}
-
-static struct sh_clk_ops dll_clk_ops = {
-	.recalc		= dll_recalc,
-};
-
-static struct clk dll_clk = {
-	.ops		= &dll_clk_ops,
-	.parent		= &r_clk,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-static unsigned long pll_recalc(struct clk *clk)
-{
-	unsigned long mult = 1;
-	unsigned long div = 1;
-
-	if (__raw_readl(PLLCR) & 0x4000)
-		mult = (((__raw_readl(FRQCR) >> 24) & 0x1f) + 1);
-	else
-		div = 2;
-
-	return (clk->parent->rate * mult) / div;
-}
-
-static struct sh_clk_ops pll_clk_ops = {
-	.recalc		= pll_recalc,
-};
-
-static struct clk pll_clk = {
-	.ops		= &pll_clk_ops,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-struct clk *main_clks[] = {
-	&r_clk,
-	&extal_clk,
-	&dll_clk,
-	&pll_clk,
-};
-
-static int multipliers[] = { 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
-static int divisors[] = { 1, 3, 2, 5, 3, 4, 5, 6, 8, 10, 12, 16, 20 };
-
-static struct clk_div_mult_table div4_div_mult_table = {
-	.divisors = divisors,
-	.nr_divisors = ARRAY_SIZE(divisors),
-	.multipliers = multipliers,
-	.nr_multipliers = ARRAY_SIZE(multipliers),
-};
-
-static struct clk_div4_table div4_table = {
-	.div_mult_table = &div4_div_mult_table,
-};
-
-enum { DIV4_I, DIV4_U, DIV4_SH, DIV4_B, DIV4_B3, DIV4_P, DIV4_NR };
-
-#define DIV4(_reg, _bit, _mask, _flags) \
-  SH_CLK_DIV4(&pll_clk, _reg, _bit, _mask, _flags)
-
-struct clk div4_clks[DIV4_NR] = {
-	[DIV4_I] = DIV4(FRQCR, 20, 0x0dbf, CLK_ENABLE_ON_INIT),
-	[DIV4_U] = DIV4(FRQCR, 16, 0x0dbf, CLK_ENABLE_ON_INIT),
-	[DIV4_SH] = DIV4(FRQCR, 12, 0x0dbf, CLK_ENABLE_ON_INIT),
-	[DIV4_B] = DIV4(FRQCR, 8, 0x0dbf, CLK_ENABLE_ON_INIT),
-	[DIV4_B3] = DIV4(FRQCR, 4, 0x0db4, CLK_ENABLE_ON_INIT),
-	[DIV4_P] = DIV4(FRQCR, 0, 0x0dbf, 0),
-};
-
-enum { DIV4_IRDA, DIV4_ENABLE_NR };
-
-struct clk div4_enable_clks[DIV4_ENABLE_NR] = {
-	[DIV4_IRDA] = DIV4(IRDACLKCR, 0, 0x0dbf, 0),
-};
-
-enum { DIV4_SIUA, DIV4_SIUB, DIV4_REPARENT_NR };
-
-struct clk div4_reparent_clks[DIV4_REPARENT_NR] = {
-	[DIV4_SIUA] = DIV4(SCLKACR, 0, 0x0dbf, 0),
-	[DIV4_SIUB] = DIV4(SCLKBCR, 0, 0x0dbf, 0),
-};
-enum { DIV6_V, DIV6_NR };
-
-struct clk div6_clks[DIV6_NR] = {
-	[DIV6_V] = SH_CLK_DIV6(&pll_clk, VCLKCR, 0),
-};
-
-static struct clk mstp_clks[] = {
-	/* See page 60 of Datasheet V1.0: Overview -> Block Diagram */
-	[HWBLK_TLB]    = SH_CLK_MSTP32(&div4_clks[DIV4_I],  MSTPCR0, 31, CLK_ENABLE_ON_INIT),
-	[HWBLK_IC]     = SH_CLK_MSTP32(&div4_clks[DIV4_I],  MSTPCR0, 30, CLK_ENABLE_ON_INIT),
-	[HWBLK_OC]     = SH_CLK_MSTP32(&div4_clks[DIV4_I],  MSTPCR0, 29, CLK_ENABLE_ON_INIT),
-	[HWBLK_L2C]    = SH_CLK_MSTP32(&div4_clks[DIV4_SH], MSTPCR0, 28, CLK_ENABLE_ON_INIT),
-	[HWBLK_ILMEM]  = SH_CLK_MSTP32(&div4_clks[DIV4_I],  MSTPCR0, 27, CLK_ENABLE_ON_INIT),
-	[HWBLK_FPU]    = SH_CLK_MSTP32(&div4_clks[DIV4_I],  MSTPCR0, 24, CLK_ENABLE_ON_INIT),
-	[HWBLK_INTC]   = SH_CLK_MSTP32(&div4_clks[DIV4_I],  MSTPCR0, 22, CLK_ENABLE_ON_INIT),
-	[HWBLK_DMAC0]  = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR0, 21, 0),
-	[HWBLK_SHYWAY] = SH_CLK_MSTP32(&div4_clks[DIV4_SH], MSTPCR0, 20, CLK_ENABLE_ON_INIT),
-	[HWBLK_HUDI]   = SH_CLK_MSTP32(&div4_clks[DIV4_P],  MSTPCR0, 19, 0),
-	[HWBLK_UBC]    = SH_CLK_MSTP32(&div4_clks[DIV4_I],  MSTPCR0, 17, 0),
-	[HWBLK_TMU0]   = SH_CLK_MSTP32(&div4_clks[DIV4_P],  MSTPCR0, 15, 0),
-	[HWBLK_CMT]    = SH_CLK_MSTP32(&r_clk,		    MSTPCR0, 14, 0),
-	[HWBLK_RWDT]   = SH_CLK_MSTP32(&r_clk,		    MSTPCR0, 13, 0),
-	[HWBLK_DMAC1]  = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR0, 12, 0),
-	[HWBLK_TMU1]   = SH_CLK_MSTP32(&div4_clks[DIV4_P],  MSTPCR0, 11, 0),
-	[HWBLK_FLCTL]  = SH_CLK_MSTP32(&div4_clks[DIV4_P],  MSTPCR0, 10, 0),
-	[HWBLK_SCIF0]  = SH_CLK_MSTP32(&div4_clks[DIV4_P],  MSTPCR0, 9, 0),
-	[HWBLK_SCIF1]  = SH_CLK_MSTP32(&div4_clks[DIV4_P],  MSTPCR0, 8, 0),
-	[HWBLK_SCIF2]  = SH_CLK_MSTP32(&div4_clks[DIV4_P],  MSTPCR0, 7, 0),
-	[HWBLK_SCIF3]  = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR0, 6, 0),
-	[HWBLK_SCIF4]  = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR0, 5, 0),
-	[HWBLK_SCIF5]  = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR0, 4, 0),
-	[HWBLK_MSIOF0] = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR0, 2, 0),
-	[HWBLK_MSIOF1] = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR0, 1, 0),
-	[HWBLK_MERAM]  = SH_CLK_MSTP32(&div4_clks[DIV4_SH], MSTPCR0, 0, 0),
-
-	[HWBLK_IIC]    = SH_CLK_MSTP32(&div4_clks[DIV4_P],  MSTPCR1, 9, 0),
-	[HWBLK_RTC]    = SH_CLK_MSTP32(&r_clk,		    MSTPCR1, 8, 0),
-
-	[HWBLK_ATAPI]  = SH_CLK_MSTP32(&div4_clks[DIV4_SH], MSTPCR2, 28, 0),
-	[HWBLK_ADC]    = SH_CLK_MSTP32(&div4_clks[DIV4_P],  MSTPCR2, 27, 0),
-	[HWBLK_TPU]    = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR2, 25, 0),
-	[HWBLK_IRDA]   = SH_CLK_MSTP32(&div4_clks[DIV4_P],  MSTPCR2, 24, 0),
-	[HWBLK_TSIF]   = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR2, 22, 0),
-	[HWBLK_ICB]    = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR2, 21, CLK_ENABLE_ON_INIT),
-	[HWBLK_SDHI0]  = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR2, 18, 0),
-	[HWBLK_SDHI1]  = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR2, 17, 0),
-	[HWBLK_KEYSC]  = SH_CLK_MSTP32(&r_clk,		    MSTPCR2, 14, 0),
-	[HWBLK_USB]    = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR2, 11, 0),
-	[HWBLK_2DG]    = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR2, 10, 0),
-	[HWBLK_SIU]    = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR2, 8, 0),
-	[HWBLK_VEU2H1] = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR2, 6, 0),
-	[HWBLK_VOU]    = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR2, 5, 0),
-	[HWBLK_BEU]    = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR2, 4, 0),
-	[HWBLK_CEU]    = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR2, 3, 0),
-	[HWBLK_VEU2H0] = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR2, 2, 0),
-	[HWBLK_VPU]    = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR2, 1, 0),
-	[HWBLK_LCDC]   = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR2, 0, 0),
-};
-
-static struct clk_lookup lookups[] = {
-	/* main clocks */
-	CLKDEV_CON_ID("rclk", &r_clk),
-	CLKDEV_CON_ID("extal", &extal_clk),
-	CLKDEV_CON_ID("dll_clk", &dll_clk),
-	CLKDEV_CON_ID("pll_clk", &pll_clk),
-
-	/* DIV4 clocks */
-	CLKDEV_CON_ID("cpu_clk", &div4_clks[DIV4_I]),
-	CLKDEV_CON_ID("umem_clk", &div4_clks[DIV4_U]),
-	CLKDEV_CON_ID("shyway_clk", &div4_clks[DIV4_SH]),
-	CLKDEV_CON_ID("bus_clk", &div4_clks[DIV4_B]),
-	CLKDEV_CON_ID("b3_clk", &div4_clks[DIV4_B3]),
-	CLKDEV_CON_ID("peripheral_clk", &div4_clks[DIV4_P]),
-	CLKDEV_CON_ID("irda_clk", &div4_enable_clks[DIV4_IRDA]),
-	CLKDEV_CON_ID("siua_clk", &div4_reparent_clks[DIV4_SIUA]),
-	CLKDEV_CON_ID("siub_clk", &div4_reparent_clks[DIV4_SIUB]),
-
-	/* DIV6 clocks */
-	CLKDEV_CON_ID("video_clk", &div6_clks[DIV6_V]),
-
-	/* MSTP clocks */
-	CLKDEV_CON_ID("tlb0", &mstp_clks[HWBLK_TLB]),
-	CLKDEV_CON_ID("ic0", &mstp_clks[HWBLK_IC]),
-	CLKDEV_CON_ID("oc0", &mstp_clks[HWBLK_OC]),
-	CLKDEV_CON_ID("l2c0", &mstp_clks[HWBLK_L2C]),
-	CLKDEV_CON_ID("ilmem0", &mstp_clks[HWBLK_ILMEM]),
-	CLKDEV_CON_ID("fpu0", &mstp_clks[HWBLK_FPU]),
-	CLKDEV_CON_ID("intc0", &mstp_clks[HWBLK_INTC]),
-	CLKDEV_DEV_ID("sh-dma-engine.0", &mstp_clks[HWBLK_DMAC0]),
-	CLKDEV_CON_ID("sh0", &mstp_clks[HWBLK_SHYWAY]),
-	CLKDEV_CON_ID("hudi0", &mstp_clks[HWBLK_HUDI]),
-	CLKDEV_CON_ID("ubc0", &mstp_clks[HWBLK_UBC]),
-	CLKDEV_ICK_ID("fck", "sh-cmt-32.0", &mstp_clks[HWBLK_CMT]),
-	CLKDEV_DEV_ID("sh-wdt.0", &mstp_clks[HWBLK_RWDT]),
-	CLKDEV_DEV_ID("sh-dma-engine.1", &mstp_clks[HWBLK_DMAC1]),
-	CLKDEV_CON_ID("flctl0", &mstp_clks[HWBLK_FLCTL]),
-	CLKDEV_DEV_ID("spi_sh_msiof.0", &mstp_clks[HWBLK_MSIOF0]),
-	CLKDEV_DEV_ID("spi_sh_msiof.1", &mstp_clks[HWBLK_MSIOF1]),
-	CLKDEV_DEV_ID("sh_mobile_meram.0", &mstp_clks[HWBLK_MERAM]),
-	CLKDEV_DEV_ID("i2c-sh_mobile.0", &mstp_clks[HWBLK_IIC]),
-	CLKDEV_CON_ID("rtc0", &mstp_clks[HWBLK_RTC]),
-	CLKDEV_CON_ID("atapi0", &mstp_clks[HWBLK_ATAPI]),
-	CLKDEV_CON_ID("adc0", &mstp_clks[HWBLK_ADC]),
-	CLKDEV_CON_ID("tpu0", &mstp_clks[HWBLK_TPU]),
-	CLKDEV_CON_ID("irda0", &mstp_clks[HWBLK_IRDA]),
-	CLKDEV_CON_ID("tsif0", &mstp_clks[HWBLK_TSIF]),
-	CLKDEV_CON_ID("icb0", &mstp_clks[HWBLK_ICB]),
-	CLKDEV_DEV_ID("sh_mobile_sdhi.0", &mstp_clks[HWBLK_SDHI0]),
-	CLKDEV_DEV_ID("sh_mobile_sdhi.1", &mstp_clks[HWBLK_SDHI1]),
-	CLKDEV_DEV_ID("sh_keysc.0", &mstp_clks[HWBLK_KEYSC]),
-	CLKDEV_CON_ID("usb0", &mstp_clks[HWBLK_USB]),
-	CLKDEV_CON_ID("2dg0", &mstp_clks[HWBLK_2DG]),
-	CLKDEV_DEV_ID("siu-pcm-audio", &mstp_clks[HWBLK_SIU]),
-	CLKDEV_CON_ID("veu1", &mstp_clks[HWBLK_VEU2H1]),
-	CLKDEV_DEV_ID("sh-vou.0", &mstp_clks[HWBLK_VOU]),
-	CLKDEV_CON_ID("beu0", &mstp_clks[HWBLK_BEU]),
-	CLKDEV_DEV_ID("ceu.0", &mstp_clks[HWBLK_CEU]),
-	CLKDEV_CON_ID("veu0", &mstp_clks[HWBLK_VEU2H0]),
-	CLKDEV_CON_ID("vpu0", &mstp_clks[HWBLK_VPU]),
-
-	CLKDEV_ICK_ID("fck", "sh-tmu.0", &mstp_clks[HWBLK_TMU0]),
-	CLKDEV_ICK_ID("fck", "sh-tmu.1", &mstp_clks[HWBLK_TMU1]),
-
-	CLKDEV_ICK_ID("fck", "sh-sci.0", &mstp_clks[HWBLK_SCIF0]),
-	CLKDEV_ICK_ID("fck", "sh-sci.1", &mstp_clks[HWBLK_SCIF1]),
-	CLKDEV_ICK_ID("fck", "sh-sci.2", &mstp_clks[HWBLK_SCIF2]),
-	CLKDEV_ICK_ID("fck", "sh-sci.3", &mstp_clks[HWBLK_SCIF3]),
-	CLKDEV_ICK_ID("fck", "sh-sci.4", &mstp_clks[HWBLK_SCIF4]),
-	CLKDEV_ICK_ID("fck", "sh-sci.5", &mstp_clks[HWBLK_SCIF5]),
-
-	CLKDEV_DEV_ID("sh_mobile_lcdc_fb.0", &mstp_clks[HWBLK_LCDC]),
-};
-
-int __init arch_clk_init(void)
-{
-	int k, ret = 0;
-
-	/* autodetect extal or dll configuration */
-	if (__raw_readl(PLLCR) & 0x1000)
-		pll_clk.parent = &dll_clk;
-	else
-		pll_clk.parent = &extal_clk;
-
-	for (k = 0; !ret && (k < ARRAY_SIZE(main_clks)); k++)
-		ret |= clk_register(main_clks[k]);
-
-	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
-
-	if (!ret)
-		ret = sh_clk_div4_register(div4_clks, DIV4_NR, &div4_table);
-
-	if (!ret)
-		ret = sh_clk_div4_enable_register(div4_enable_clks,
-					DIV4_ENABLE_NR, &div4_table);
-
-	if (!ret)
-		ret = sh_clk_div4_reparent_register(div4_reparent_clks,
-					DIV4_REPARENT_NR, &div4_table);
-
-	if (!ret)
-		ret = sh_clk_div6_register(div6_clks, DIV6_NR);
-
-	if (!ret)
-		ret = sh_clk_mstp_register(mstp_clks, HWBLK_NR);
-
-	return ret;
-}
diff --git a/arch/sh/kernel/cpu/sh4a/clock-sh7724.c b/arch/sh/kernel/cpu/sh4a/clock-sh7724.c
deleted file mode 100644
index 2a1f0d847a2efb..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/clock-sh7724.c
+++ /dev/null
@@ -1,367 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh4a/clock-sh7724.c
- *
- * SH7724 clock framework support
- *
- * Copyright (C) 2009 Magnus Damm
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/clk.h>
-#include <linux/clkdev.h>
-#include <linux/sh_clk.h>
-#include <asm/clock.h>
-#include <cpu/sh7724.h>
-
-/* SH7724 registers */
-#define FRQCRA		0xa4150000
-#define FRQCRB		0xa4150004
-#define VCLKCR		0xa4150048
-#define FCLKACR		0xa4150008
-#define FCLKBCR		0xa415000c
-#define IRDACLKCR	0xa4150018
-#define PLLCR		0xa4150024
-#define MSTPCR0		0xa4150030
-#define MSTPCR1		0xa4150034
-#define MSTPCR2		0xa4150038
-#define SPUCLKCR	0xa415003c
-#define FLLFRQ		0xa4150050
-#define LSTATS		0xa4150060
-
-/* Fixed 32 KHz root clock for RTC and Power Management purposes */
-static struct clk r_clk = {
-	.rate           = 32768,
-};
-
-/*
- * Default rate for the root input clock, reset this with clk_set_rate()
- * from the platform code.
- */
-static struct clk extal_clk = {
-	.rate		= 33333333,
-};
-
-/* The fll multiplies the 32khz r_clk, may be used instead of extal */
-static unsigned long fll_recalc(struct clk *clk)
-{
-	unsigned long mult = 0;
-	unsigned long div = 1;
-
-	if (__raw_readl(PLLCR) & 0x1000)
-		mult = __raw_readl(FLLFRQ) & 0x3ff;
-
-	if (__raw_readl(FLLFRQ) & 0x4000)
-		div = 2;
-
-	return (clk->parent->rate * mult) / div;
-}
-
-static struct sh_clk_ops fll_clk_ops = {
-	.recalc		= fll_recalc,
-};
-
-static struct clk fll_clk = {
-	.ops		= &fll_clk_ops,
-	.parent		= &r_clk,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-static unsigned long pll_recalc(struct clk *clk)
-{
-	unsigned long mult = 1;
-
-	if (__raw_readl(PLLCR) & 0x4000)
-		mult = (((__raw_readl(FRQCRA) >> 24) & 0x3f) + 1) * 2;
-
-	return clk->parent->rate * mult;
-}
-
-static struct sh_clk_ops pll_clk_ops = {
-	.recalc		= pll_recalc,
-};
-
-static struct clk pll_clk = {
-	.ops		= &pll_clk_ops,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-/* A fixed divide-by-3 block use by the div6 clocks */
-static unsigned long div3_recalc(struct clk *clk)
-{
-	return clk->parent->rate / 3;
-}
-
-static struct sh_clk_ops div3_clk_ops = {
-	.recalc		= div3_recalc,
-};
-
-static struct clk div3_clk = {
-	.ops		= &div3_clk_ops,
-	.parent		= &pll_clk,
-};
-
-/* External input clock (pin name: FSIMCKA/FSIMCKB/DV_CLKI ) */
-struct clk sh7724_fsimcka_clk = {
-};
-
-struct clk sh7724_fsimckb_clk = {
-};
-
-struct clk sh7724_dv_clki = {
-};
-
-static struct clk *main_clks[] = {
-	&r_clk,
-	&extal_clk,
-	&fll_clk,
-	&pll_clk,
-	&div3_clk,
-	&sh7724_fsimcka_clk,
-	&sh7724_fsimckb_clk,
-	&sh7724_dv_clki,
-};
-
-static void div4_kick(struct clk *clk)
-{
-	unsigned long value;
-
-	/* set KICK bit in FRQCRA to update hardware setting */
-	value = __raw_readl(FRQCRA);
-	value |= (1 << 31);
-	__raw_writel(value, FRQCRA);
-}
-
-static int divisors[] = { 2, 3, 4, 6, 8, 12, 16, 0, 24, 32, 36, 48, 0, 72 };
-
-static struct clk_div_mult_table div4_div_mult_table = {
-	.divisors = divisors,
-	.nr_divisors = ARRAY_SIZE(divisors),
-};
-
-static struct clk_div4_table div4_table = {
-	.div_mult_table = &div4_div_mult_table,
-	.kick = div4_kick,
-};
-
-enum { DIV4_I, DIV4_SH, DIV4_B, DIV4_P, DIV4_M1, DIV4_NR };
-
-#define DIV4(_reg, _bit, _mask, _flags) \
-  SH_CLK_DIV4(&pll_clk, _reg, _bit, _mask, _flags)
-
-struct clk div4_clks[DIV4_NR] = {
-	[DIV4_I] = DIV4(FRQCRA, 20, 0x2f7d, CLK_ENABLE_ON_INIT),
-	[DIV4_SH] = DIV4(FRQCRA, 12, 0x2f7c, CLK_ENABLE_ON_INIT),
-	[DIV4_B] = DIV4(FRQCRA, 8, 0x2f7c, CLK_ENABLE_ON_INIT),
-	[DIV4_P] = DIV4(FRQCRA, 0, 0x2f7c, 0),
-	[DIV4_M1] = DIV4(FRQCRB, 4, 0x2f7c, CLK_ENABLE_ON_INIT),
-};
-
-enum { DIV6_V, DIV6_I, DIV6_S, DIV6_FA, DIV6_FB, DIV6_NR };
-
-/* Indices are important - they are the actual src selecting values */
-static struct clk *common_parent[] = {
-	[0] = &div3_clk,
-	[1] = NULL,
-};
-
-static struct clk *vclkcr_parent[8] = {
-	[0] = &div3_clk,
-	[2] = &sh7724_dv_clki,
-	[4] = &extal_clk,
-};
-
-static struct clk *fclkacr_parent[] = {
-	[0] = &div3_clk,
-	[1] = NULL,
-	[2] = &sh7724_fsimcka_clk,
-	[3] = NULL,
-};
-
-static struct clk *fclkbcr_parent[] = {
-	[0] = &div3_clk,
-	[1] = NULL,
-	[2] = &sh7724_fsimckb_clk,
-	[3] = NULL,
-};
-
-static struct clk div6_clks[DIV6_NR] = {
-	[DIV6_V] = SH_CLK_DIV6_EXT(VCLKCR, 0,
-			vclkcr_parent, ARRAY_SIZE(vclkcr_parent), 12, 3),
-	[DIV6_I] = SH_CLK_DIV6_EXT(IRDACLKCR, 0,
-			common_parent, ARRAY_SIZE(common_parent), 6, 1),
-	[DIV6_S] = SH_CLK_DIV6_EXT(SPUCLKCR, CLK_ENABLE_ON_INIT,
-			common_parent, ARRAY_SIZE(common_parent), 6, 1),
-	[DIV6_FA] = SH_CLK_DIV6_EXT(FCLKACR, 0,
-				      fclkacr_parent, ARRAY_SIZE(fclkacr_parent), 6, 2),
-	[DIV6_FB] = SH_CLK_DIV6_EXT(FCLKBCR, 0,
-				      fclkbcr_parent, ARRAY_SIZE(fclkbcr_parent), 6, 2),
-};
-
-static struct clk mstp_clks[HWBLK_NR] = {
-	[HWBLK_TLB] = SH_CLK_MSTP32(&div4_clks[DIV4_I],	    MSTPCR0, 31, CLK_ENABLE_ON_INIT),
-	[HWBLK_IC] = SH_CLK_MSTP32(&div4_clks[DIV4_I],	    MSTPCR0, 30, CLK_ENABLE_ON_INIT),
-	[HWBLK_OC] = SH_CLK_MSTP32(&div4_clks[DIV4_I],	    MSTPCR0, 29, CLK_ENABLE_ON_INIT),
-	[HWBLK_RSMEM] = SH_CLK_MSTP32(&div4_clks[DIV4_B],   MSTPCR0, 28, CLK_ENABLE_ON_INIT),
-	[HWBLK_ILMEM] = SH_CLK_MSTP32(&div4_clks[DIV4_I],   MSTPCR0, 27, CLK_ENABLE_ON_INIT),
-	[HWBLK_L2C] = SH_CLK_MSTP32(&div4_clks[DIV4_SH],    MSTPCR0, 26, CLK_ENABLE_ON_INIT),
-	[HWBLK_FPU] = SH_CLK_MSTP32(&div4_clks[DIV4_I],	    MSTPCR0, 24, CLK_ENABLE_ON_INIT),
-	[HWBLK_INTC] = SH_CLK_MSTP32(&div4_clks[DIV4_P],    MSTPCR0, 22, CLK_ENABLE_ON_INIT),
-	[HWBLK_DMAC0] = SH_CLK_MSTP32(&div4_clks[DIV4_B],   MSTPCR0, 21, 0),
-	[HWBLK_SHYWAY] = SH_CLK_MSTP32(&div4_clks[DIV4_SH], MSTPCR0, 20, CLK_ENABLE_ON_INIT),
-	[HWBLK_HUDI] = SH_CLK_MSTP32(&div4_clks[DIV4_P],    MSTPCR0, 19, 0),
-	[HWBLK_UBC] = SH_CLK_MSTP32(&div4_clks[DIV4_I],     MSTPCR0, 17, 0),
-	[HWBLK_TMU0] = SH_CLK_MSTP32(&div4_clks[DIV4_P],    MSTPCR0, 15, 0),
-	[HWBLK_CMT] = SH_CLK_MSTP32(&r_clk,		    MSTPCR0, 14, 0),
-	[HWBLK_RWDT] = SH_CLK_MSTP32(&r_clk,		    MSTPCR0, 13, 0),
-	[HWBLK_DMAC1] = SH_CLK_MSTP32(&div4_clks[DIV4_B],   MSTPCR0, 12, 0),
-	[HWBLK_TMU1] = SH_CLK_MSTP32(&div4_clks[DIV4_P],    MSTPCR0, 10, 0),
-	[HWBLK_SCIF0] = SH_CLK_MSTP32(&div4_clks[DIV4_P],   MSTPCR0, 9, 0),
-	[HWBLK_SCIF1] = SH_CLK_MSTP32(&div4_clks[DIV4_P],   MSTPCR0, 8, 0),
-	[HWBLK_SCIF2] = SH_CLK_MSTP32(&div4_clks[DIV4_P],   MSTPCR0, 7, 0),
-	[HWBLK_SCIF3] = SH_CLK_MSTP32(&div4_clks[DIV4_B],   MSTPCR0, 6, 0),
-	[HWBLK_SCIF4] = SH_CLK_MSTP32(&div4_clks[DIV4_B],   MSTPCR0, 5, 0),
-	[HWBLK_SCIF5] = SH_CLK_MSTP32(&div4_clks[DIV4_B],   MSTPCR0, 4, 0),
-	[HWBLK_MSIOF0] = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR0, 2, 0),
-	[HWBLK_MSIOF1] = SH_CLK_MSTP32(&div4_clks[DIV4_B],  MSTPCR0, 1, 0),
-
-	[HWBLK_KEYSC] = SH_CLK_MSTP32(&r_clk,		    MSTPCR1, 12, 0),
-	[HWBLK_RTC] = SH_CLK_MSTP32(&r_clk,		    MSTPCR1, 11, 0),
-	[HWBLK_IIC0] = SH_CLK_MSTP32(&div4_clks[DIV4_P],    MSTPCR1, 9, 0),
-	[HWBLK_IIC1] = SH_CLK_MSTP32(&div4_clks[DIV4_P],    MSTPCR1, 8, 0),
-
-	[HWBLK_MMC] = SH_CLK_MSTP32(&div4_clks[DIV4_B],	    MSTPCR2, 29, 0),
-	[HWBLK_ETHER] = SH_CLK_MSTP32(&div4_clks[DIV4_B],   MSTPCR2, 28, 0),
-	[HWBLK_ATAPI] = SH_CLK_MSTP32(&div4_clks[DIV4_B],   MSTPCR2, 26, 0),
-	[HWBLK_TPU] = SH_CLK_MSTP32(&div4_clks[DIV4_B],	    MSTPCR2, 25, 0),
-	[HWBLK_IRDA] = SH_CLK_MSTP32(&div4_clks[DIV4_P],    MSTPCR2, 24, 0),
-	[HWBLK_TSIF] = SH_CLK_MSTP32(&div4_clks[DIV4_B],    MSTPCR2, 22, 0),
-	[HWBLK_USB1] = SH_CLK_MSTP32(&div4_clks[DIV4_B],    MSTPCR2, 21, 0),
-	[HWBLK_USB0] = SH_CLK_MSTP32(&div4_clks[DIV4_B],    MSTPCR2, 20, 0),
-	[HWBLK_2DG] = SH_CLK_MSTP32(&div4_clks[DIV4_B],	    MSTPCR2, 19, 0),
-	[HWBLK_SDHI0] = SH_CLK_MSTP32(&div4_clks[DIV4_B],   MSTPCR2, 18, 0),
-	[HWBLK_SDHI1] = SH_CLK_MSTP32(&div4_clks[DIV4_B],   MSTPCR2, 17, 0),
-	[HWBLK_VEU1] = SH_CLK_MSTP32(&div4_clks[DIV4_B],    MSTPCR2, 15, 0),
-	[HWBLK_CEU1] = SH_CLK_MSTP32(&div4_clks[DIV4_B],    MSTPCR2, 13, 0),
-	[HWBLK_BEU1] = SH_CLK_MSTP32(&div4_clks[DIV4_B],    MSTPCR2, 12, 0),
-	[HWBLK_2DDMAC] = SH_CLK_MSTP32(&div4_clks[DIV4_SH], MSTPCR2, 10, 0),
-	[HWBLK_SPU] = SH_CLK_MSTP32(&div4_clks[DIV4_B],	    MSTPCR2, 9, 0),
-	[HWBLK_JPU] = SH_CLK_MSTP32(&div4_clks[DIV4_B],	    MSTPCR2, 6, 0),
-	[HWBLK_VOU] = SH_CLK_MSTP32(&div4_clks[DIV4_B],	    MSTPCR2, 5, 0),
-	[HWBLK_BEU0] = SH_CLK_MSTP32(&div4_clks[DIV4_B],    MSTPCR2, 4, 0),
-	[HWBLK_CEU0] = SH_CLK_MSTP32(&div4_clks[DIV4_B],    MSTPCR2, 3, 0),
-	[HWBLK_VEU0] = SH_CLK_MSTP32(&div4_clks[DIV4_B],    MSTPCR2, 2, 0),
-	[HWBLK_VPU] = SH_CLK_MSTP32(&div4_clks[DIV4_B],	    MSTPCR2, 1, 0),
-	[HWBLK_LCDC] = SH_CLK_MSTP32(&div4_clks[DIV4_B],    MSTPCR2, 0, 0),
-};
-
-static struct clk_lookup lookups[] = {
-	/* main clocks */
-	CLKDEV_CON_ID("rclk", &r_clk),
-	CLKDEV_CON_ID("extal", &extal_clk),
-	CLKDEV_CON_ID("fll_clk", &fll_clk),
-	CLKDEV_CON_ID("pll_clk", &pll_clk),
-	CLKDEV_CON_ID("div3_clk", &div3_clk),
-
-	/* DIV4 clocks */
-	CLKDEV_CON_ID("cpu_clk", &div4_clks[DIV4_I]),
-	CLKDEV_CON_ID("shyway_clk", &div4_clks[DIV4_SH]),
-	CLKDEV_CON_ID("bus_clk", &div4_clks[DIV4_B]),
-	CLKDEV_CON_ID("peripheral_clk", &div4_clks[DIV4_P]),
-	CLKDEV_CON_ID("vpu_clk", &div4_clks[DIV4_M1]),
-
-	/* DIV6 clocks */
-	CLKDEV_CON_ID("video_clk", &div6_clks[DIV6_V]),
-	CLKDEV_CON_ID("fsia_clk", &div6_clks[DIV6_FA]),
-	CLKDEV_CON_ID("fsib_clk", &div6_clks[DIV6_FB]),
-	CLKDEV_CON_ID("irda_clk", &div6_clks[DIV6_I]),
-	CLKDEV_CON_ID("spu_clk", &div6_clks[DIV6_S]),
-
-	/* MSTP clocks */
-	CLKDEV_CON_ID("tlb0", &mstp_clks[HWBLK_TLB]),
-	CLKDEV_CON_ID("ic0", &mstp_clks[HWBLK_IC]),
-	CLKDEV_CON_ID("oc0", &mstp_clks[HWBLK_OC]),
-	CLKDEV_CON_ID("rs0", &mstp_clks[HWBLK_RSMEM]),
-	CLKDEV_CON_ID("ilmem0", &mstp_clks[HWBLK_ILMEM]),
-	CLKDEV_CON_ID("l2c0", &mstp_clks[HWBLK_L2C]),
-	CLKDEV_CON_ID("fpu0", &mstp_clks[HWBLK_FPU]),
-	CLKDEV_CON_ID("intc0", &mstp_clks[HWBLK_INTC]),
-	CLKDEV_DEV_ID("sh-dma-engine.0", &mstp_clks[HWBLK_DMAC0]),
-	CLKDEV_CON_ID("sh0", &mstp_clks[HWBLK_SHYWAY]),
-	CLKDEV_CON_ID("hudi0", &mstp_clks[HWBLK_HUDI]),
-	CLKDEV_CON_ID("ubc0", &mstp_clks[HWBLK_UBC]),
-
-	CLKDEV_ICK_ID("fck", "sh-tmu.0", &mstp_clks[HWBLK_TMU0]),
-	CLKDEV_ICK_ID("fck", "sh-tmu.1", &mstp_clks[HWBLK_TMU1]),
-
-	CLKDEV_ICK_ID("fck", "sh-cmt-32.0", &mstp_clks[HWBLK_CMT]),
-	CLKDEV_DEV_ID("sh-wdt.0", &mstp_clks[HWBLK_RWDT]),
-	CLKDEV_DEV_ID("sh-dma-engine.1", &mstp_clks[HWBLK_DMAC1]),
-
-	CLKDEV_DEV_ID("sh-sci.0", &mstp_clks[HWBLK_SCIF0]),
-	CLKDEV_DEV_ID("sh-sci.1", &mstp_clks[HWBLK_SCIF1]),
-	CLKDEV_DEV_ID("sh-sci.2", &mstp_clks[HWBLK_SCIF2]),
-	CLKDEV_DEV_ID("sh-sci.3", &mstp_clks[HWBLK_SCIF3]),
-	CLKDEV_DEV_ID("sh-sci.4", &mstp_clks[HWBLK_SCIF4]),
-	CLKDEV_DEV_ID("sh-sci.5", &mstp_clks[HWBLK_SCIF5]),
-
-	CLKDEV_DEV_ID("spi_sh_msiof.0", &mstp_clks[HWBLK_MSIOF0]),
-	CLKDEV_DEV_ID("spi_sh_msiof.1", &mstp_clks[HWBLK_MSIOF1]),
-	CLKDEV_DEV_ID("sh_keysc.0", &mstp_clks[HWBLK_KEYSC]),
-	CLKDEV_CON_ID("rtc0", &mstp_clks[HWBLK_RTC]),
-	CLKDEV_DEV_ID("i2c-sh_mobile.0", &mstp_clks[HWBLK_IIC0]),
-	CLKDEV_DEV_ID("i2c-sh_mobile.1", &mstp_clks[HWBLK_IIC1]),
-	CLKDEV_DEV_ID("sh_mmcif.0", &mstp_clks[HWBLK_MMC]),
-	CLKDEV_DEV_ID("sh7724-ether.0", &mstp_clks[HWBLK_ETHER]),
-	CLKDEV_CON_ID("atapi0", &mstp_clks[HWBLK_ATAPI]),
-	CLKDEV_CON_ID("tpu0", &mstp_clks[HWBLK_TPU]),
-	CLKDEV_CON_ID("irda0", &mstp_clks[HWBLK_IRDA]),
-	CLKDEV_CON_ID("tsif0", &mstp_clks[HWBLK_TSIF]),
-	CLKDEV_DEV_ID("renesas_usbhs.1", &mstp_clks[HWBLK_USB1]),
-	CLKDEV_DEV_ID("renesas_usbhs.0", &mstp_clks[HWBLK_USB0]),
-	CLKDEV_CON_ID("usb1", &mstp_clks[HWBLK_USB1]),
-	CLKDEV_CON_ID("usb0", &mstp_clks[HWBLK_USB0]),
-	CLKDEV_CON_ID("2dg0", &mstp_clks[HWBLK_2DG]),
-	CLKDEV_DEV_ID("sh_mobile_sdhi.0", &mstp_clks[HWBLK_SDHI0]),
-	CLKDEV_DEV_ID("sh_mobile_sdhi.1", &mstp_clks[HWBLK_SDHI1]),
-	CLKDEV_CON_ID("veu1", &mstp_clks[HWBLK_VEU1]),
-	CLKDEV_DEV_ID("renesas-ceu.1", &mstp_clks[HWBLK_CEU1]),
-	CLKDEV_CON_ID("beu1", &mstp_clks[HWBLK_BEU1]),
-	CLKDEV_CON_ID("2ddmac0", &mstp_clks[HWBLK_2DDMAC]),
-	CLKDEV_DEV_ID("sh_fsi.0", &mstp_clks[HWBLK_SPU]),
-	CLKDEV_CON_ID("jpu0", &mstp_clks[HWBLK_JPU]),
-	CLKDEV_DEV_ID("sh-vou", &mstp_clks[HWBLK_VOU]),
-	CLKDEV_CON_ID("beu0", &mstp_clks[HWBLK_BEU0]),
-	CLKDEV_DEV_ID("renesas-ceu.0", &mstp_clks[HWBLK_CEU0]),
-	CLKDEV_CON_ID("veu0", &mstp_clks[HWBLK_VEU0]),
-	CLKDEV_CON_ID("vpu0", &mstp_clks[HWBLK_VPU]),
-	CLKDEV_DEV_ID("sh_mobile_lcdc_fb.0", &mstp_clks[HWBLK_LCDC]),
-};
-
-int __init arch_clk_init(void)
-{
-	int k, ret = 0;
-
-	/* autodetect extal or fll configuration */
-	if (__raw_readl(PLLCR) & 0x1000)
-		pll_clk.parent = &fll_clk;
-	else
-		pll_clk.parent = &extal_clk;
-
-	for (k = 0; !ret && (k < ARRAY_SIZE(main_clks)); k++)
-		ret = clk_register(main_clks[k]);
-
-	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
-
-	if (!ret)
-		ret = sh_clk_div4_register(div4_clks, DIV4_NR, &div4_table);
-
-	if (!ret)
-		ret = sh_clk_div6_reparent_register(div6_clks, DIV6_NR);
-
-	if (!ret)
-		ret = sh_clk_mstp_register(mstp_clks, HWBLK_NR);
-
-	return ret;
-}
diff --git a/arch/sh/kernel/cpu/sh4a/clock-sh7734.c b/arch/sh/kernel/cpu/sh4a/clock-sh7734.c
deleted file mode 100644
index c81ee60eddb8e7..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/clock-sh7734.c
+++ /dev/null
@@ -1,256 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh4a/clock-sh7734.c
- *
- * Clock framework for SH7734
- *
- * Copyright (C) 2011, 2012 Nobuhiro Iwamatsu <nobuhiro.iwamatsu.yj@renesas.com>
- * Copyright (C) 2011, 2012 Renesas Solutions Corp.
- */
-
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/clkdev.h>
-#include <linux/delay.h>
-#include <asm/clock.h>
-#include <asm/freq.h>
-
-static struct clk extal_clk = {
-	.rate       = 33333333,
-};
-
-#define MODEMR          (0xFFCC0020)
-#define MODEMR_MASK     (0x6)
-#define MODEMR_533MHZ   (0x2)
-
-static unsigned long pll_recalc(struct clk *clk)
-{
-	int mode = 12;
-	u32 r = __raw_readl(MODEMR);
-
-	if ((r & MODEMR_MASK) & MODEMR_533MHZ)
-		mode = 16;
-
-	return clk->parent->rate * mode;
-}
-
-static struct sh_clk_ops pll_clk_ops = {
-	.recalc		= pll_recalc,
-};
-
-static struct clk pll_clk = {
-	.ops        = &pll_clk_ops,
-	.parent     = &extal_clk,
-	.flags      = CLK_ENABLE_ON_INIT,
-};
-
-static struct clk *main_clks[] = {
-	&extal_clk,
-	&pll_clk,
-};
-
-static int multipliers[] = { 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
-static int divisors[] = { 1, 3, 2, 3, 4, 6, 8, 9, 12, 16, 18, 24 };
-
-static struct clk_div_mult_table div4_div_mult_table = {
-	.divisors = divisors,
-	.nr_divisors = ARRAY_SIZE(divisors),
-	.multipliers = multipliers,
-	.nr_multipliers = ARRAY_SIZE(multipliers),
-};
-
-static struct clk_div4_table div4_table = {
-	.div_mult_table = &div4_div_mult_table,
-};
-
-enum { DIV4_I, DIV4_S, DIV4_B, DIV4_M, DIV4_S1, DIV4_P, DIV4_NR };
-
-#define DIV4(_reg, _bit, _mask, _flags) \
-	SH_CLK_DIV4(&pll_clk, _reg, _bit, _mask, _flags)
-
-struct clk div4_clks[DIV4_NR] = {
-	[DIV4_I] = DIV4(FRQMR1, 28, 0x0003, CLK_ENABLE_ON_INIT),
-	[DIV4_S] = DIV4(FRQMR1, 20, 0x000C, CLK_ENABLE_ON_INIT),
-	[DIV4_B] = DIV4(FRQMR1, 16, 0x0140, CLK_ENABLE_ON_INIT),
-	[DIV4_M] = DIV4(FRQMR1, 12, 0x0004, CLK_ENABLE_ON_INIT),
-	[DIV4_S1] = DIV4(FRQMR1, 4, 0x0030, CLK_ENABLE_ON_INIT),
-	[DIV4_P] = DIV4(FRQMR1, 0, 0x0140, CLK_ENABLE_ON_INIT),
-};
-
-#define MSTPCR0	0xFFC80030
-#define MSTPCR1	0xFFC80034
-#define MSTPCR3	0xFFC8003C
-
-enum {
-	MSTP030, MSTP029, /* IIC */
-	MSTP026, MSTP025, MSTP024, /* SCIF */
-	MSTP023,
-	MSTP022, MSTP021,
-	MSTP019, /* HSCIF */
-	MSTP016, MSTP015, MSTP014, /* TMU / TIMER */
-	MSTP012, MSTP011, MSTP010, MSTP009, MSTP008, /* SSI */
-	MSTP007, /* HSPI */
-	MSTP115, /* ADMAC */
-	MSTP114, /* GETHER */
-	MSTP111, /* DMAC */
-	MSTP109, /* VIDEOIN1 */
-	MSTP108, /* VIDEOIN0 */
-	MSTP107, /* RGPVBG */
-	MSTP106, /* 2DG */
-	MSTP103, /* VIEW */
-	MSTP100, /* USB */
-	MSTP331, /* MMC */
-	MSTP330, /* MIMLB */
-	MSTP323, /* SDHI0 */
-	MSTP322, /* SDHI1 */
-	MSTP321, /* SDHI2 */
-	MSTP320, /* RQSPI */
-	MSTP319, /* SRC0 */
-	MSTP318, /* SRC1 */
-	MSTP317, /* RSPI */
-	MSTP316, /* RCAN0 */
-	MSTP315, /* RCAN1 */
-	MSTP314, /* FLTCL */
-	MSTP313, /* ADC */
-	MSTP312, /* MTU */
-	MSTP304, /* IE-BUS */
-	MSTP303, /* RTC */
-	MSTP302, /* HIF */
-	MSTP301, /* STIF0 */
-	MSTP300, /* STIF1 */
-	MSTP_NR };
-
-static struct clk mstp_clks[MSTP_NR] = {
-	/* MSTPCR0 */
-	[MSTP030] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 30, 0),
-	[MSTP029] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 29, 0),
-	[MSTP026] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 26, 0),
-	[MSTP025] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 25, 0),
-	[MSTP024] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 24, 0),
-	[MSTP023] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 23, 0),
-	[MSTP022] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 22, 0),
-	[MSTP021] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 21, 0),
-	[MSTP019] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 19, 0),
-	[MSTP016] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 16, 0),
-	[MSTP015] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 15, 0),
-	[MSTP014] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 14, 0),
-	[MSTP012] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 12, 0),
-	[MSTP011] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 11, 0),
-	[MSTP010] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 10, 0),
-	[MSTP009] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 9, 0),
-	[MSTP008] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 8, 0),
-	[MSTP007] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 7, 0),
-
-	/* MSTPCR1 */
-	[MSTP115] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR1, 15, 0),
-	[MSTP114] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR1, 14, 0),
-	[MSTP111] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR1, 11, 0),
-	[MSTP109] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR1, 9, 0),
-	[MSTP108] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR1, 8, 0),
-	[MSTP107] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR1, 7, 0),
-	[MSTP106] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR1, 6, 0),
-	[MSTP103] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR1, 3, 0),
-	[MSTP100] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR1, 0, 0),
-
-	/* MSTPCR3 */
-	[MSTP331] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR3, 31, 0),
-	[MSTP330] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR3, 30, 0),
-	[MSTP323] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR3, 23, 0),
-	[MSTP322] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR3, 22, 0),
-	[MSTP321] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR3, 21, 0),
-	[MSTP320] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR3, 20, 0),
-	[MSTP319] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR3, 19, 0),
-	[MSTP318] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR3, 18, 0),
-	[MSTP317] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR3, 17, 0),
-	[MSTP316] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR3, 16, 0),
-	[MSTP315] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR3, 15, 0),
-	[MSTP314] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR3, 14, 0),
-	[MSTP313] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR3, 13, 0),
-	[MSTP312] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR3, 12, 0),
-	[MSTP304] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR3,  4, 0),
-	[MSTP303] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR3,  3, 0),
-	[MSTP302] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR3,  2, 0),
-	[MSTP301] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR3,  1, 0),
-	[MSTP300] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR3,  0, 0),
-};
-
-static struct clk_lookup lookups[] = {
-	/* main clocks */
-	CLKDEV_CON_ID("extal", &extal_clk),
-	CLKDEV_CON_ID("pll_clk", &pll_clk),
-
-	/* clocks */
-	CLKDEV_CON_ID("cpu_clk", &div4_clks[DIV4_I]),
-	CLKDEV_CON_ID("shyway_clk", &div4_clks[DIV4_S]),
-	CLKDEV_CON_ID("ddr_clk", &div4_clks[DIV4_M]),
-	CLKDEV_CON_ID("bus_clk", &div4_clks[DIV4_B]),
-	CLKDEV_CON_ID("shyway_clk1", &div4_clks[DIV4_S1]),
-	CLKDEV_CON_ID("peripheral_clk", &div4_clks[DIV4_P]),
-
-	/* MSTP32 clocks */
-	CLKDEV_DEV_ID("i2c-sh7734.0", &mstp_clks[MSTP030]),
-	CLKDEV_DEV_ID("i2c-sh7734.1", &mstp_clks[MSTP029]),
-	CLKDEV_ICK_ID("fck", "sh-sci.0", &mstp_clks[MSTP026]),
-	CLKDEV_ICK_ID("fck", "sh-sci.1", &mstp_clks[MSTP025]),
-	CLKDEV_ICK_ID("fck", "sh-sci.2", &mstp_clks[MSTP024]),
-	CLKDEV_ICK_ID("fck", "sh-sci.3", &mstp_clks[MSTP023]),
-	CLKDEV_ICK_ID("fck", "sh-sci.4", &mstp_clks[MSTP022]),
-	CLKDEV_ICK_ID("fck", "sh-sci.5", &mstp_clks[MSTP021]),
-	CLKDEV_CON_ID("hscif", &mstp_clks[MSTP019]),
-	CLKDEV_ICK_ID("fck", "sh-tmu.0", &mstp_clks[MSTP016]),
-	CLKDEV_ICK_ID("fck", "sh-tmu.1", &mstp_clks[MSTP015]),
-	CLKDEV_ICK_ID("fck", "sh-tmu.2", &mstp_clks[MSTP014]),
-	CLKDEV_CON_ID("ssi0", &mstp_clks[MSTP012]),
-	CLKDEV_CON_ID("ssi1", &mstp_clks[MSTP011]),
-	CLKDEV_CON_ID("ssi2", &mstp_clks[MSTP010]),
-	CLKDEV_CON_ID("ssi3", &mstp_clks[MSTP009]),
-	CLKDEV_CON_ID("sss", &mstp_clks[MSTP008]),
-	CLKDEV_CON_ID("hspi", &mstp_clks[MSTP007]),
-	CLKDEV_CON_ID("usb_fck", &mstp_clks[MSTP100]),
-	CLKDEV_CON_ID("videoin0", &mstp_clks[MSTP109]),
-	CLKDEV_CON_ID("videoin1", &mstp_clks[MSTP108]),
-	CLKDEV_CON_ID("rgpvg", &mstp_clks[MSTP107]),
-	CLKDEV_CON_ID("2dg", &mstp_clks[MSTP106]),
-	CLKDEV_CON_ID("view", &mstp_clks[MSTP103]),
-
-	CLKDEV_CON_ID("mmc0", &mstp_clks[MSTP331]),
-	CLKDEV_CON_ID("mimlb0", &mstp_clks[MSTP330]),
-	CLKDEV_CON_ID("sdhi0", &mstp_clks[MSTP323]),
-	CLKDEV_CON_ID("sdhi1", &mstp_clks[MSTP322]),
-	CLKDEV_CON_ID("sdhi2", &mstp_clks[MSTP321]),
-	CLKDEV_CON_ID("rqspi0", &mstp_clks[MSTP320]),
-	CLKDEV_CON_ID("src0", &mstp_clks[MSTP319]),
-	CLKDEV_CON_ID("src1", &mstp_clks[MSTP318]),
-	CLKDEV_CON_ID("rsp0", &mstp_clks[MSTP317]),
-	CLKDEV_CON_ID("rcan0", &mstp_clks[MSTP316]),
-	CLKDEV_CON_ID("rcan1", &mstp_clks[MSTP315]),
-	CLKDEV_CON_ID("fltcl0", &mstp_clks[MSTP314]),
-	CLKDEV_CON_ID("adc0", &mstp_clks[MSTP313]),
-	CLKDEV_CON_ID("mtu0", &mstp_clks[MSTP312]),
-	CLKDEV_CON_ID("iebus0", &mstp_clks[MSTP304]),
-	CLKDEV_DEV_ID("sh7734-gether.0", &mstp_clks[MSTP114]),
-	CLKDEV_CON_ID("rtc0", &mstp_clks[MSTP303]),
-	CLKDEV_CON_ID("hif0", &mstp_clks[MSTP302]),
-	CLKDEV_CON_ID("stif0", &mstp_clks[MSTP301]),
-	CLKDEV_CON_ID("stif1", &mstp_clks[MSTP300]),
-};
-
-int __init arch_clk_init(void)
-{
-	int i, ret = 0;
-
-	for (i = 0; i < ARRAY_SIZE(main_clks); i++)
-		ret |= clk_register(main_clks[i]);
-
-	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
-
-	if (!ret)
-		ret = sh_clk_div4_register(div4_clks, ARRAY_SIZE(div4_clks),
-			&div4_table);
-
-	if (!ret)
-		ret = sh_clk_mstp_register(mstp_clks, MSTP_NR);
-
-	return ret;
-}
diff --git a/arch/sh/kernel/cpu/sh4a/clock-sh7757.c b/arch/sh/kernel/cpu/sh4a/clock-sh7757.c
deleted file mode 100644
index 9acb72210fed48..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/clock-sh7757.c
+++ /dev/null
@@ -1,152 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh4/clock-sh7757.c
- *
- * SH7757 support for the clock framework
- *
- *  Copyright (C) 2009-2010  Renesas Solutions Corp.
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/clkdev.h>
-#include <asm/clock.h>
-#include <asm/freq.h>
-
-/*
- * Default rate for the root input clock, reset this with clk_set_rate()
- * from the platform code.
- */
-static struct clk extal_clk = {
-	.rate		= 48000000,
-};
-
-static unsigned long pll_recalc(struct clk *clk)
-{
-	int multiplier;
-
-	multiplier = test_mode_pin(MODE_PIN0) ? 24 : 16;
-
-	return clk->parent->rate * multiplier;
-}
-
-static struct sh_clk_ops pll_clk_ops = {
-	.recalc		= pll_recalc,
-};
-
-static struct clk pll_clk = {
-	.ops		= &pll_clk_ops,
-	.parent		= &extal_clk,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-static struct clk *clks[] = {
-	&extal_clk,
-	&pll_clk,
-};
-
-static unsigned int div2[] = { 1, 1, 2, 1, 1, 4, 1, 6,
-			       1, 1, 1, 16, 1, 24, 1, 1 };
-
-static struct clk_div_mult_table div4_div_mult_table = {
-	.divisors = div2,
-	.nr_divisors = ARRAY_SIZE(div2),
-};
-
-static struct clk_div4_table div4_table = {
-	.div_mult_table = &div4_div_mult_table,
-};
-
-enum { DIV4_I, DIV4_SH, DIV4_P, DIV4_NR };
-
-#define DIV4(_bit, _mask, _flags) \
-  SH_CLK_DIV4(&pll_clk, FRQCR, _bit, _mask, _flags)
-
-struct clk div4_clks[DIV4_NR] = {
-	/*
-	 * P clock is always enable, because some P clock modules is used
-	 * by Host PC.
-	 */
-	[DIV4_P] = DIV4(0, 0x2800, CLK_ENABLE_ON_INIT),
-	[DIV4_SH] = DIV4(12, 0x00a0, CLK_ENABLE_ON_INIT),
-	[DIV4_I] = DIV4(20, 0x0004, CLK_ENABLE_ON_INIT),
-};
-
-#define MSTPCR0		0xffc80030
-#define MSTPCR1		0xffc80034
-#define MSTPCR2		0xffc10028
-
-enum { MSTP004, MSTP000, MSTP127, MSTP114, MSTP113, MSTP112,
-       MSTP111, MSTP110, MSTP103, MSTP102, MSTP220,
-       MSTP_NR };
-
-static struct clk mstp_clks[MSTP_NR] = {
-	/* MSTPCR0 */
-	[MSTP004] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 4, 0),
-	[MSTP000] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 0, 0),
-
-	/* MSTPCR1 */
-	[MSTP127] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR1, 27, 0),
-	[MSTP114] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR1, 14, 0),
-	[MSTP113] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR1, 13, 0),
-	[MSTP112] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR1, 12, 0),
-	[MSTP111] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR1, 11, 0),
-	[MSTP110] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR1, 10, 0),
-	[MSTP103] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR1, 3, 0),
-	[MSTP102] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR1, 2, 0),
-
-	/* MSTPCR2 */
-	[MSTP220] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR2, 20, 0),
-};
-
-static struct clk_lookup lookups[] = {
-	/* main clocks */
-	CLKDEV_CON_ID("extal", &extal_clk),
-	CLKDEV_CON_ID("pll_clk", &pll_clk),
-
-	/* DIV4 clocks */
-	CLKDEV_CON_ID("peripheral_clk", &div4_clks[DIV4_P]),
-	CLKDEV_CON_ID("shyway_clk", &div4_clks[DIV4_SH]),
-	CLKDEV_CON_ID("cpu_clk", &div4_clks[DIV4_I]),
-
-	/* MSTP32 clocks */
-	CLKDEV_DEV_ID("sh_mobile_sdhi.0", &mstp_clks[MSTP004]),
-	CLKDEV_CON_ID("riic0", &mstp_clks[MSTP000]),
-	CLKDEV_CON_ID("riic1", &mstp_clks[MSTP000]),
-	CLKDEV_CON_ID("riic2", &mstp_clks[MSTP000]),
-	CLKDEV_CON_ID("riic3", &mstp_clks[MSTP000]),
-	CLKDEV_CON_ID("riic4", &mstp_clks[MSTP000]),
-	CLKDEV_CON_ID("riic5", &mstp_clks[MSTP000]),
-	CLKDEV_CON_ID("riic6", &mstp_clks[MSTP000]),
-	CLKDEV_CON_ID("riic7", &mstp_clks[MSTP000]),
-
-	CLKDEV_ICK_ID("fck", "sh-tmu.0", &mstp_clks[MSTP113]),
-	CLKDEV_ICK_ID("fck", "sh-tmu.1", &mstp_clks[MSTP114]),
-	CLKDEV_ICK_ID("fck", "sh-sci.2", &mstp_clks[MSTP112]),
-	CLKDEV_ICK_ID("fck", "sh-sci.1", &mstp_clks[MSTP111]),
-	CLKDEV_ICK_ID("fck", "sh-sci.0", &mstp_clks[MSTP110]),
-
-	CLKDEV_CON_ID("usb_fck", &mstp_clks[MSTP103]),
-	CLKDEV_DEV_ID("renesas_usbhs.0", &mstp_clks[MSTP102]),
-	CLKDEV_CON_ID("mmc0", &mstp_clks[MSTP220]),
-	CLKDEV_DEV_ID("rspi.2", &mstp_clks[MSTP127]),
-};
-
-int __init arch_clk_init(void)
-{
-	int i, ret = 0;
-
-	for (i = 0; i < ARRAY_SIZE(clks); i++)
-		ret |= clk_register(clks[i]);
-
-	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
-
-	if (!ret)
-		ret = sh_clk_div4_register(div4_clks, ARRAY_SIZE(div4_clks),
-					   &div4_table);
-	if (!ret)
-		ret = sh_clk_mstp_register(mstp_clks, MSTP_NR);
-
-	return ret;
-}
-
diff --git a/arch/sh/kernel/cpu/sh4a/clock-sh7763.c b/arch/sh/kernel/cpu/sh4a/clock-sh7763.c
deleted file mode 100644
index aaff4b96812c6a..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/clock-sh7763.c
+++ /dev/null
@@ -1,116 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh4a/clock-sh7763.c
- *
- * SH7763 support for the clock framework
- *
- *  Copyright (C) 2005  Paul Mundt
- *  Copyright (C) 2007  Yoshihiro Shimoda
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/clkdev.h>
-#include <asm/clock.h>
-#include <asm/freq.h>
-#include <asm/io.h>
-
-static int bfc_divisors[] = { 1, 1, 1, 8, 1, 1, 1, 1 };
-static int p0fc_divisors[] = { 1, 1, 1, 8, 1, 1, 1, 1 };
-static int cfc_divisors[] = { 1, 1, 4, 1, 1, 1, 1, 1 };
-
-static void master_clk_init(struct clk *clk)
-{
-	clk->rate *= p0fc_divisors[(__raw_readl(FRQCR) >> 4) & 0x07];
-}
-
-static struct sh_clk_ops sh7763_master_clk_ops = {
-	.init		= master_clk_init,
-};
-
-static unsigned long module_clk_recalc(struct clk *clk)
-{
-	int idx = ((__raw_readl(FRQCR) >> 4) & 0x07);
-	return clk->parent->rate / p0fc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7763_module_clk_ops = {
-	.recalc		= module_clk_recalc,
-};
-
-static unsigned long bus_clk_recalc(struct clk *clk)
-{
-	int idx = ((__raw_readl(FRQCR) >> 16) & 0x07);
-	return clk->parent->rate / bfc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7763_bus_clk_ops = {
-	.recalc		= bus_clk_recalc,
-};
-
-static struct sh_clk_ops sh7763_cpu_clk_ops = {
-	.recalc		= followparent_recalc,
-};
-
-static struct sh_clk_ops *sh7763_clk_ops[] = {
-	&sh7763_master_clk_ops,
-	&sh7763_module_clk_ops,
-	&sh7763_bus_clk_ops,
-	&sh7763_cpu_clk_ops,
-};
-
-void __init arch_init_clk_ops(struct sh_clk_ops **ops, int idx)
-{
-	if (idx < ARRAY_SIZE(sh7763_clk_ops))
-		*ops = sh7763_clk_ops[idx];
-}
-
-static unsigned long shyway_clk_recalc(struct clk *clk)
-{
-	int idx = ((__raw_readl(FRQCR) >> 20) & 0x07);
-	return clk->parent->rate / cfc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7763_shyway_clk_ops = {
-	.recalc		= shyway_clk_recalc,
-};
-
-static struct clk sh7763_shyway_clk = {
-	.flags		= CLK_ENABLE_ON_INIT,
-	.ops		= &sh7763_shyway_clk_ops,
-};
-
-/*
- * Additional SH7763-specific on-chip clocks that aren't already part of the
- * clock framework
- */
-static struct clk *sh7763_onchip_clocks[] = {
-	&sh7763_shyway_clk,
-};
-
-static struct clk_lookup lookups[] = {
-	/* main clocks */
-	CLKDEV_CON_ID("shyway_clk", &sh7763_shyway_clk),
-};
-
-int __init arch_clk_init(void)
-{
-	struct clk *clk;
-	int i, ret = 0;
-
-	cpg_clk_init();
-
-	clk = clk_get(NULL, "master_clk");
-	for (i = 0; i < ARRAY_SIZE(sh7763_onchip_clocks); i++) {
-		struct clk *clkp = sh7763_onchip_clocks[i];
-
-		clkp->parent = clk;
-		ret |= clk_register(clkp);
-	}
-
-	clk_put(clk);
-
-	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
-
-	return ret;
-}
diff --git a/arch/sh/kernel/cpu/sh4a/clock-sh7770.c b/arch/sh/kernel/cpu/sh4a/clock-sh7770.c
deleted file mode 100644
index f356dfcd17b751..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/clock-sh7770.c
+++ /dev/null
@@ -1,70 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh4a/clock-sh7770.c
- *
- * SH7770 support for the clock framework
- *
- *  Copyright (C) 2005  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <asm/clock.h>
-#include <asm/freq.h>
-#include <asm/io.h>
-
-static int ifc_divisors[] = { 1, 1, 1, 1, 1, 1, 1, 1 };
-static int bfc_divisors[] = { 1, 1, 1, 1, 1, 8,12, 1 };
-static int pfc_divisors[] = { 1, 8, 1,10,12,16, 1, 1 };
-
-static void master_clk_init(struct clk *clk)
-{
-	clk->rate *= pfc_divisors[(__raw_readl(FRQCR) >> 28) & 0x000f];
-}
-
-static struct sh_clk_ops sh7770_master_clk_ops = {
-	.init		= master_clk_init,
-};
-
-static unsigned long module_clk_recalc(struct clk *clk)
-{
-	int idx = ((__raw_readl(FRQCR) >> 28) & 0x000f);
-	return clk->parent->rate / pfc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7770_module_clk_ops = {
-	.recalc		= module_clk_recalc,
-};
-
-static unsigned long bus_clk_recalc(struct clk *clk)
-{
-	int idx = (__raw_readl(FRQCR) & 0x000f);
-	return clk->parent->rate / bfc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7770_bus_clk_ops = {
-	.recalc		= bus_clk_recalc,
-};
-
-static unsigned long cpu_clk_recalc(struct clk *clk)
-{
-	int idx = ((__raw_readl(FRQCR) >> 24) & 0x000f);
-	return clk->parent->rate / ifc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7770_cpu_clk_ops = {
-	.recalc		= cpu_clk_recalc,
-};
-
-static struct sh_clk_ops *sh7770_clk_ops[] = {
-	&sh7770_master_clk_ops,
-	&sh7770_module_clk_ops,
-	&sh7770_bus_clk_ops,
-	&sh7770_cpu_clk_ops,
-};
-
-void __init arch_init_clk_ops(struct sh_clk_ops **ops, int idx)
-{
-	if (idx < ARRAY_SIZE(sh7770_clk_ops))
-		*ops = sh7770_clk_ops[idx];
-}
-
diff --git a/arch/sh/kernel/cpu/sh4a/clock-sh7780.c b/arch/sh/kernel/cpu/sh4a/clock-sh7780.c
deleted file mode 100644
index fc0a3efb53d5e0..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/clock-sh7780.c
+++ /dev/null
@@ -1,122 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh4a/clock-sh7780.c
- *
- * SH7780 support for the clock framework
- *
- *  Copyright (C) 2005  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/clkdev.h>
-#include <asm/clock.h>
-#include <asm/freq.h>
-#include <asm/io.h>
-
-static int ifc_divisors[] = { 2, 4 };
-static int bfc_divisors[] = { 1, 1, 1, 8, 12, 16, 24, 1 };
-static int pfc_divisors[] = { 1, 24, 24, 1 };
-static int cfc_divisors[] = { 1, 1, 4, 1, 6, 1, 1, 1 };
-
-static void master_clk_init(struct clk *clk)
-{
-	clk->rate *= pfc_divisors[__raw_readl(FRQCR) & 0x0003];
-}
-
-static struct sh_clk_ops sh7780_master_clk_ops = {
-	.init		= master_clk_init,
-};
-
-static unsigned long module_clk_recalc(struct clk *clk)
-{
-	int idx = (__raw_readl(FRQCR) & 0x0003);
-	return clk->parent->rate / pfc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7780_module_clk_ops = {
-	.recalc		= module_clk_recalc,
-};
-
-static unsigned long bus_clk_recalc(struct clk *clk)
-{
-	int idx = ((__raw_readl(FRQCR) >> 16) & 0x0007);
-	return clk->parent->rate / bfc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7780_bus_clk_ops = {
-	.recalc		= bus_clk_recalc,
-};
-
-static unsigned long cpu_clk_recalc(struct clk *clk)
-{
-	int idx = ((__raw_readl(FRQCR) >> 24) & 0x0001);
-	return clk->parent->rate / ifc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7780_cpu_clk_ops = {
-	.recalc		= cpu_clk_recalc,
-};
-
-static struct sh_clk_ops *sh7780_clk_ops[] = {
-	&sh7780_master_clk_ops,
-	&sh7780_module_clk_ops,
-	&sh7780_bus_clk_ops,
-	&sh7780_cpu_clk_ops,
-};
-
-void __init arch_init_clk_ops(struct sh_clk_ops **ops, int idx)
-{
-	if (idx < ARRAY_SIZE(sh7780_clk_ops))
-		*ops = sh7780_clk_ops[idx];
-}
-
-static unsigned long shyway_clk_recalc(struct clk *clk)
-{
-	int idx = ((__raw_readl(FRQCR) >> 20) & 0x0007);
-	return clk->parent->rate / cfc_divisors[idx];
-}
-
-static struct sh_clk_ops sh7780_shyway_clk_ops = {
-	.recalc		= shyway_clk_recalc,
-};
-
-static struct clk sh7780_shyway_clk = {
-	.flags		= CLK_ENABLE_ON_INIT,
-	.ops		= &sh7780_shyway_clk_ops,
-};
-
-/*
- * Additional SH7780-specific on-chip clocks that aren't already part of the
- * clock framework
- */
-static struct clk *sh7780_onchip_clocks[] = {
-	&sh7780_shyway_clk,
-};
-
-static struct clk_lookup lookups[] = {
-	/* main clocks */
-	CLKDEV_CON_ID("shyway_clk", &sh7780_shyway_clk),
-};
-
-int __init arch_clk_init(void)
-{
-	struct clk *clk;
-	int i, ret = 0;
-
-	cpg_clk_init();
-
-	clk = clk_get(NULL, "master_clk");
-	for (i = 0; i < ARRAY_SIZE(sh7780_onchip_clocks); i++) {
-		struct clk *clkp = sh7780_onchip_clocks[i];
-
-		clkp->parent = clk;
-		ret |= clk_register(clkp);
-	}
-
-	clk_put(clk);
-
-	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
-
-	return ret;
-}
diff --git a/arch/sh/kernel/cpu/sh4a/clock-sh7785.c b/arch/sh/kernel/cpu/sh4a/clock-sh7785.c
deleted file mode 100644
index fca351378bbce6..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/clock-sh7785.c
+++ /dev/null
@@ -1,174 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh4a/clock-sh7785.c
- *
- * SH7785 support for the clock framework
- *
- *  Copyright (C) 2007 - 2010  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/clk.h>
-#include <linux/io.h>
-#include <linux/cpufreq.h>
-#include <linux/clkdev.h>
-#include <asm/clock.h>
-#include <asm/freq.h>
-#include <cpu/sh7785.h>
-
-/*
- * Default rate for the root input clock, reset this with clk_set_rate()
- * from the platform code.
- */
-static struct clk extal_clk = {
-	.rate		= 33333333,
-};
-
-static unsigned long pll_recalc(struct clk *clk)
-{
-	int multiplier;
-
-	multiplier = test_mode_pin(MODE_PIN4) ? 36 : 72;
-
-	return clk->parent->rate * multiplier;
-}
-
-static struct sh_clk_ops pll_clk_ops = {
-	.recalc		= pll_recalc,
-};
-
-static struct clk pll_clk = {
-	.ops		= &pll_clk_ops,
-	.parent		= &extal_clk,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-static struct clk *clks[] = {
-	&extal_clk,
-	&pll_clk,
-};
-
-static unsigned int div2[] = { 1, 2, 4, 6, 8, 12, 16, 18,
-			       24, 32, 36, 48 };
-
-static struct clk_div_mult_table div4_div_mult_table = {
-	.divisors = div2,
-	.nr_divisors = ARRAY_SIZE(div2),
-};
-
-static struct clk_div4_table div4_table = {
-	.div_mult_table = &div4_div_mult_table,
-};
-
-enum { DIV4_I, DIV4_U, DIV4_SH, DIV4_B, DIV4_DDR, DIV4_GA,
-	DIV4_DU, DIV4_P, DIV4_NR };
-
-#define DIV4(_bit, _mask, _flags) \
-  SH_CLK_DIV4(&pll_clk, FRQMR1, _bit, _mask, _flags)
-
-struct clk div4_clks[DIV4_NR] = {
-	[DIV4_P] = DIV4(0, 0x0f80, 0),
-	[DIV4_DU] = DIV4(4, 0x0ff0, 0),
-	[DIV4_GA] = DIV4(8, 0x0030, 0),
-	[DIV4_DDR] = DIV4(12, 0x000c, CLK_ENABLE_ON_INIT),
-	[DIV4_B] = DIV4(16, 0x0fe0, CLK_ENABLE_ON_INIT),
-	[DIV4_SH] = DIV4(20, 0x000c, CLK_ENABLE_ON_INIT),
-	[DIV4_U] = DIV4(24, 0x000c, CLK_ENABLE_ON_INIT),
-	[DIV4_I] = DIV4(28, 0x000e, CLK_ENABLE_ON_INIT),
-};
-
-#define MSTPCR0		0xffc80030
-#define MSTPCR1		0xffc80034
-
-enum { MSTP029, MSTP028, MSTP027, MSTP026, MSTP025, MSTP024,
-       MSTP021, MSTP020, MSTP017, MSTP016,
-       MSTP013, MSTP012, MSTP009, MSTP008, MSTP003, MSTP002,
-       MSTP119, MSTP117, MSTP105, MSTP104, MSTP100,
-       MSTP_NR };
-
-static struct clk mstp_clks[MSTP_NR] = {
-	/* MSTPCR0 */
-	[MSTP029] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 29, 0),
-	[MSTP028] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 28, 0),
-	[MSTP027] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 27, 0),
-	[MSTP026] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 26, 0),
-	[MSTP025] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 25, 0),
-	[MSTP024] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 24, 0),
-	[MSTP021] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 21, 0),
-	[MSTP020] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 20, 0),
-	[MSTP017] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 17, 0),
-	[MSTP016] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 16, 0),
-	[MSTP013] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 13, 0),
-	[MSTP012] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 12, 0),
-	[MSTP009] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 9, 0),
-	[MSTP008] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 8, 0),
-	[MSTP003] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 3, 0),
-	[MSTP002] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 2, 0),
-
-	/* MSTPCR1 */
-	[MSTP119] = SH_CLK_MSTP32(NULL, MSTPCR1, 19, 0),
-	[MSTP117] = SH_CLK_MSTP32(NULL, MSTPCR1, 17, 0),
-	[MSTP105] = SH_CLK_MSTP32(NULL, MSTPCR1, 5, 0),
-	[MSTP104] = SH_CLK_MSTP32(NULL, MSTPCR1, 4, 0),
-	[MSTP100] = SH_CLK_MSTP32(NULL, MSTPCR1, 0, 0),
-};
-
-static struct clk_lookup lookups[] = {
-	/* main clocks */
-	CLKDEV_CON_ID("extal", &extal_clk),
-	CLKDEV_CON_ID("pll_clk", &pll_clk),
-
-	/* DIV4 clocks */
-	CLKDEV_CON_ID("peripheral_clk", &div4_clks[DIV4_P]),
-	CLKDEV_CON_ID("du_clk", &div4_clks[DIV4_DU]),
-	CLKDEV_CON_ID("ga_clk", &div4_clks[DIV4_GA]),
-	CLKDEV_CON_ID("ddr_clk", &div4_clks[DIV4_DDR]),
-	CLKDEV_CON_ID("bus_clk", &div4_clks[DIV4_B]),
-	CLKDEV_CON_ID("shyway_clk", &div4_clks[DIV4_SH]),
-	CLKDEV_CON_ID("umem_clk", &div4_clks[DIV4_U]),
-	CLKDEV_CON_ID("cpu_clk", &div4_clks[DIV4_I]),
-
-	/* MSTP32 clocks */
-	CLKDEV_ICK_ID("fck", "sh-sci.5", &mstp_clks[MSTP029]),
-	CLKDEV_ICK_ID("fck", "sh-sci.4", &mstp_clks[MSTP028]),
-	CLKDEV_ICK_ID("fck", "sh-sci.3", &mstp_clks[MSTP027]),
-	CLKDEV_ICK_ID("fck", "sh-sci.2", &mstp_clks[MSTP026]),
-	CLKDEV_ICK_ID("fck", "sh-sci.1", &mstp_clks[MSTP025]),
-	CLKDEV_ICK_ID("fck", "sh-sci.0", &mstp_clks[MSTP024]),
-
-	CLKDEV_CON_ID("ssi1_fck", &mstp_clks[MSTP021]),
-	CLKDEV_CON_ID("ssi0_fck", &mstp_clks[MSTP020]),
-	CLKDEV_CON_ID("hac1_fck", &mstp_clks[MSTP017]),
-	CLKDEV_CON_ID("hac0_fck", &mstp_clks[MSTP016]),
-	CLKDEV_CON_ID("mmcif_fck", &mstp_clks[MSTP013]),
-	CLKDEV_CON_ID("flctl_fck", &mstp_clks[MSTP012]),
-
-	CLKDEV_ICK_ID("fck", "sh-tmu.0", &mstp_clks[MSTP008]),
-	CLKDEV_ICK_ID("fck", "sh-tmu.1", &mstp_clks[MSTP009]),
-
-	CLKDEV_CON_ID("siof_fck", &mstp_clks[MSTP003]),
-	CLKDEV_CON_ID("hspi_fck", &mstp_clks[MSTP002]),
-	CLKDEV_CON_ID("hudi_fck", &mstp_clks[MSTP119]),
-	CLKDEV_CON_ID("ubc0", &mstp_clks[MSTP117]),
-	CLKDEV_CON_ID("dmac_11_6_fck", &mstp_clks[MSTP105]),
-	CLKDEV_CON_ID("dmac_5_0_fck", &mstp_clks[MSTP104]),
-	CLKDEV_CON_ID("gdta_fck", &mstp_clks[MSTP100]),
-};
-
-int __init arch_clk_init(void)
-{
-	int i, ret = 0;
-
-	for (i = 0; i < ARRAY_SIZE(clks); i++)
-		ret |= clk_register(clks[i]);
-
-	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
-
-	if (!ret)
-		ret = sh_clk_div4_register(div4_clks, ARRAY_SIZE(div4_clks),
-					   &div4_table);
-	if (!ret)
-		ret = sh_clk_mstp_register(mstp_clks, MSTP_NR);
-
-	return ret;
-}
diff --git a/arch/sh/kernel/cpu/sh4a/clock-sh7786.c b/arch/sh/kernel/cpu/sh4a/clock-sh7786.c
deleted file mode 100644
index f23862df3e8fb9..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/clock-sh7786.c
+++ /dev/null
@@ -1,189 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh4a/clock-sh7786.c
- *
- * SH7786 support for the clock framework
- *
- *  Copyright (C) 2010  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/clk.h>
-#include <linux/io.h>
-#include <linux/clkdev.h>
-#include <asm/clock.h>
-#include <asm/freq.h>
-
-/*
- * Default rate for the root input clock, reset this with clk_set_rate()
- * from the platform code.
- */
-static struct clk extal_clk = {
-	.rate		= 33333333,
-};
-
-static unsigned long pll_recalc(struct clk *clk)
-{
-	int multiplier;
-
-	/*
-	 * Clock modes 0, 1, and 2 use an x64 multiplier against PLL1,
-	 * while modes 3, 4, and 5 use an x32.
-	 */
-	multiplier = (sh_mv.mv_mode_pins() & 0xf) < 3 ? 64 : 32;
-
-	return clk->parent->rate * multiplier;
-}
-
-static struct sh_clk_ops pll_clk_ops = {
-	.recalc		= pll_recalc,
-};
-
-static struct clk pll_clk = {
-	.ops		= &pll_clk_ops,
-	.parent		= &extal_clk,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-static struct clk *clks[] = {
-	&extal_clk,
-	&pll_clk,
-};
-
-static unsigned int div2[] = { 1, 2, 4, 6, 8, 12, 16, 18,
-			       24, 32, 36, 48 };
-
-static struct clk_div_mult_table div4_div_mult_table = {
-	.divisors = div2,
-	.nr_divisors = ARRAY_SIZE(div2),
-};
-
-static struct clk_div4_table div4_table = {
-	.div_mult_table = &div4_div_mult_table,
-};
-
-enum { DIV4_I, DIV4_SH, DIV4_B, DIV4_DDR, DIV4_DU, DIV4_P, DIV4_NR };
-
-#define DIV4(_bit, _mask, _flags) \
-  SH_CLK_DIV4(&pll_clk, FRQMR1, _bit, _mask, _flags)
-
-struct clk div4_clks[DIV4_NR] = {
-	[DIV4_P] = DIV4(0, 0x0b40, 0),
-	[DIV4_DU] = DIV4(4, 0x0010, 0),
-	[DIV4_DDR] = DIV4(12, 0x0002, CLK_ENABLE_ON_INIT),
-	[DIV4_B] = DIV4(16, 0x0360, CLK_ENABLE_ON_INIT),
-	[DIV4_SH] = DIV4(20, 0x0002, CLK_ENABLE_ON_INIT),
-	[DIV4_I] = DIV4(28, 0x0006, CLK_ENABLE_ON_INIT),
-};
-
-#define MSTPCR0		0xffc40030
-#define MSTPCR1		0xffc40034
-
-enum { MSTP029, MSTP028, MSTP027, MSTP026, MSTP025, MSTP024,
-       MSTP023, MSTP022, MSTP021, MSTP020, MSTP017, MSTP016,
-       MSTP015, MSTP014, MSTP011, MSTP010, MSTP009, MSTP008,
-       MSTP005, MSTP004, MSTP002,
-       MSTP112, MSTP110, MSTP109, MSTP108,
-       MSTP105, MSTP104, MSTP103, MSTP102,
-       MSTP_NR };
-
-static struct clk mstp_clks[MSTP_NR] = {
-	/* MSTPCR0 */
-	[MSTP029] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 29, 0),
-	[MSTP028] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 28, 0),
-	[MSTP027] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 27, 0),
-	[MSTP026] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 26, 0),
-	[MSTP025] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 25, 0),
-	[MSTP024] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 24, 0),
-	[MSTP023] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 23, 0),
-	[MSTP022] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 22, 0),
-	[MSTP021] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 21, 0),
-	[MSTP020] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 20, 0),
-	[MSTP017] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 17, 0),
-	[MSTP016] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 16, 0),
-	[MSTP015] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 15, 0),
-	[MSTP014] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 14, 0),
-	[MSTP011] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 11, 0),
-	[MSTP010] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 10, 0),
-	[MSTP009] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 9, 0),
-	[MSTP008] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 8, 0),
-	[MSTP005] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 5, 0),
-	[MSTP004] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 4, 0),
-	[MSTP002] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 2, 0),
-
-	/* MSTPCR1 */
-	[MSTP112] = SH_CLK_MSTP32(NULL, MSTPCR1, 12, 0),
-	[MSTP110] = SH_CLK_MSTP32(NULL, MSTPCR1, 10, 0),
-	[MSTP109] = SH_CLK_MSTP32(NULL, MSTPCR1, 9, 0),
-	[MSTP108] = SH_CLK_MSTP32(NULL, MSTPCR1, 8, 0),
-	[MSTP105] = SH_CLK_MSTP32(NULL, MSTPCR1, 5, 0),
-	[MSTP104] = SH_CLK_MSTP32(NULL, MSTPCR1, 4, 0),
-	[MSTP103] = SH_CLK_MSTP32(NULL, MSTPCR1, 3, 0),
-	[MSTP102] = SH_CLK_MSTP32(NULL, MSTPCR1, 2, 0),
-};
-
-static struct clk_lookup lookups[] = {
-	/* main clocks */
-	CLKDEV_CON_ID("extal", &extal_clk),
-	CLKDEV_CON_ID("pll_clk", &pll_clk),
-
-	/* DIV4 clocks */
-	CLKDEV_CON_ID("peripheral_clk", &div4_clks[DIV4_P]),
-	CLKDEV_CON_ID("du_clk", &div4_clks[DIV4_DU]),
-	CLKDEV_CON_ID("ddr_clk", &div4_clks[DIV4_DDR]),
-	CLKDEV_CON_ID("bus_clk", &div4_clks[DIV4_B]),
-	CLKDEV_CON_ID("shyway_clk", &div4_clks[DIV4_SH]),
-	CLKDEV_CON_ID("cpu_clk", &div4_clks[DIV4_I]),
-
-	/* MSTP32 clocks */
-	CLKDEV_ICK_ID("fck", "sh-sci.5", &mstp_clks[MSTP029]),
-	CLKDEV_ICK_ID("fck", "sh-sci.4", &mstp_clks[MSTP028]),
-	CLKDEV_ICK_ID("fck", "sh-sci.3", &mstp_clks[MSTP027]),
-	CLKDEV_ICK_ID("fck", "sh-sci.2", &mstp_clks[MSTP026]),
-	CLKDEV_ICK_ID("fck", "sh-sci.1", &mstp_clks[MSTP025]),
-	CLKDEV_ICK_ID("fck", "sh-sci.0", &mstp_clks[MSTP024]),
-
-	CLKDEV_CON_ID("ssi3_fck", &mstp_clks[MSTP023]),
-	CLKDEV_CON_ID("ssi2_fck", &mstp_clks[MSTP022]),
-	CLKDEV_CON_ID("ssi1_fck", &mstp_clks[MSTP021]),
-	CLKDEV_CON_ID("ssi0_fck", &mstp_clks[MSTP020]),
-	CLKDEV_CON_ID("hac1_fck", &mstp_clks[MSTP017]),
-	CLKDEV_CON_ID("hac0_fck", &mstp_clks[MSTP016]),
-	CLKDEV_CON_ID("i2c1_fck", &mstp_clks[MSTP015]),
-	CLKDEV_CON_ID("i2c0_fck", &mstp_clks[MSTP014]),
-
-	CLKDEV_ICK_ID("fck", "sh-tmu.0", &mstp_clks[MSTP008]),
-	CLKDEV_ICK_ID("fck", "sh-tmu.1", &mstp_clks[MSTP009]),
-	CLKDEV_ICK_ID("fck", "sh-tmu.2", &mstp_clks[MSTP010]),
-	CLKDEV_ICK_ID("fck", "sh-tmu.3", &mstp_clks[MSTP011]),
-
-	CLKDEV_CON_ID("sdif1_fck", &mstp_clks[MSTP005]),
-	CLKDEV_CON_ID("sdif0_fck", &mstp_clks[MSTP004]),
-	CLKDEV_CON_ID("hspi_fck", &mstp_clks[MSTP002]),
-	CLKDEV_CON_ID("usb_fck", &mstp_clks[MSTP112]),
-	CLKDEV_CON_ID("pcie2_fck", &mstp_clks[MSTP110]),
-	CLKDEV_CON_ID("pcie1_fck", &mstp_clks[MSTP109]),
-	CLKDEV_CON_ID("pcie0_fck", &mstp_clks[MSTP108]),
-	CLKDEV_CON_ID("dmac_11_6_fck", &mstp_clks[MSTP105]),
-	CLKDEV_CON_ID("dmac_5_0_fck", &mstp_clks[MSTP104]),
-	CLKDEV_CON_ID("du_fck", &mstp_clks[MSTP103]),
-	CLKDEV_CON_ID("ether_fck", &mstp_clks[MSTP102]),
-};
-
-int __init arch_clk_init(void)
-{
-	int i, ret = 0;
-
-	for (i = 0; i < ARRAY_SIZE(clks); i++)
-		ret |= clk_register(clks[i]);
-
-	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
-
-	if (!ret)
-		ret = sh_clk_div4_register(div4_clks, ARRAY_SIZE(div4_clks),
-					   &div4_table);
-	if (!ret)
-		ret = sh_clk_mstp_register(mstp_clks, MSTP_NR);
-
-	return ret;
-}
diff --git a/arch/sh/kernel/cpu/sh4a/clock-shx3.c b/arch/sh/kernel/cpu/sh4a/clock-shx3.c
deleted file mode 100644
index 6c7b6ab6cab5a6..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/clock-shx3.c
+++ /dev/null
@@ -1,148 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh4/clock-shx3.c
- *
- * SH-X3 support for the clock framework
- *
- *  Copyright (C) 2006-2007  Renesas Technology Corp.
- *  Copyright (C) 2006-2007  Renesas Solutions Corp.
- *  Copyright (C) 2006-2010  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/clkdev.h>
-#include <asm/clock.h>
-#include <asm/freq.h>
-
-/*
- * Default rate for the root input clock, reset this with clk_set_rate()
- * from the platform code.
- */
-static struct clk extal_clk = {
-	.rate		= 16666666,
-};
-
-static unsigned long pll_recalc(struct clk *clk)
-{
-	/* PLL1 has a fixed x72 multiplier.  */
-	return clk->parent->rate * 72;
-}
-
-static struct sh_clk_ops pll_clk_ops = {
-	.recalc		= pll_recalc,
-};
-
-static struct clk pll_clk = {
-	.ops		= &pll_clk_ops,
-	.parent		= &extal_clk,
-	.flags		= CLK_ENABLE_ON_INIT,
-};
-
-static struct clk *clks[] = {
-	&extal_clk,
-	&pll_clk,
-};
-
-static unsigned int div2[] = { 1, 2, 4, 6, 8, 12, 16, 18,
-			       24, 32, 36, 48 };
-
-static struct clk_div_mult_table div4_div_mult_table = {
-	.divisors = div2,
-	.nr_divisors = ARRAY_SIZE(div2),
-};
-
-static struct clk_div4_table div4_table = {
-	.div_mult_table = &div4_div_mult_table,
-};
-
-enum { DIV4_I, DIV4_SH, DIV4_B, DIV4_DDR, DIV4_SHA, DIV4_P, DIV4_NR };
-
-#define DIV4(_bit, _mask, _flags) \
-  SH_CLK_DIV4(&pll_clk, FRQMR1, _bit, _mask, _flags)
-
-struct clk div4_clks[DIV4_NR] = {
-	[DIV4_P] = DIV4(0, 0x0f80, 0),
-	[DIV4_SHA] = DIV4(4, 0x0ff0, 0),
-	[DIV4_DDR] = DIV4(12, 0x000c, CLK_ENABLE_ON_INIT),
-	[DIV4_B] = DIV4(16, 0x0fe0, CLK_ENABLE_ON_INIT),
-	[DIV4_SH] = DIV4(20, 0x000c, CLK_ENABLE_ON_INIT),
-	[DIV4_I] = DIV4(28, 0x000e, CLK_ENABLE_ON_INIT),
-};
-
-#define MSTPCR0		0xffc00030
-#define MSTPCR1		0xffc00034
-
-enum { MSTP027, MSTP026, MSTP025, MSTP024,
-       MSTP009, MSTP008, MSTP003, MSTP002,
-       MSTP001, MSTP000, MSTP119, MSTP105,
-       MSTP104, MSTP_NR };
-
-static struct clk mstp_clks[MSTP_NR] = {
-	/* MSTPCR0 */
-	[MSTP027] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 27, 0),
-	[MSTP026] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 26, 0),
-	[MSTP025] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 25, 0),
-	[MSTP024] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 24, 0),
-	[MSTP009] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 9, 0),
-	[MSTP008] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 8, 0),
-	[MSTP003] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 3, 0),
-	[MSTP002] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 2, 0),
-	[MSTP001] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 1, 0),
-	[MSTP000] = SH_CLK_MSTP32(&div4_clks[DIV4_P], MSTPCR0, 0, 0),
-
-	/* MSTPCR1 */
-	[MSTP119] = SH_CLK_MSTP32(NULL, MSTPCR1, 19, 0),
-	[MSTP105] = SH_CLK_MSTP32(NULL, MSTPCR1, 5, 0),
-	[MSTP104] = SH_CLK_MSTP32(NULL, MSTPCR1, 4, 0),
-};
-
-static struct clk_lookup lookups[] = {
-	/* main clocks */
-	CLKDEV_CON_ID("extal", &extal_clk),
-	CLKDEV_CON_ID("pll_clk", &pll_clk),
-
-	/* DIV4 clocks */
-	CLKDEV_CON_ID("peripheral_clk", &div4_clks[DIV4_P]),
-	CLKDEV_CON_ID("shywaya_clk", &div4_clks[DIV4_SHA]),
-	CLKDEV_CON_ID("ddr_clk", &div4_clks[DIV4_DDR]),
-	CLKDEV_CON_ID("bus_clk", &div4_clks[DIV4_B]),
-	CLKDEV_CON_ID("shyway_clk", &div4_clks[DIV4_SH]),
-	CLKDEV_CON_ID("cpu_clk", &div4_clks[DIV4_I]),
-
-	/* MSTP32 clocks */
-	CLKDEV_ICK_ID("fck", "sh-sci.3", &mstp_clks[MSTP027]),
-	CLKDEV_ICK_ID("fck", "sh-sci.2", &mstp_clks[MSTP026]),
-	CLKDEV_ICK_ID("fck", "sh-sci.1", &mstp_clks[MSTP025]),
-	CLKDEV_ICK_ID("fck", "sh-sci.0", &mstp_clks[MSTP024]),
-
-	CLKDEV_CON_ID("h8ex_fck", &mstp_clks[MSTP003]),
-	CLKDEV_CON_ID("csm_fck", &mstp_clks[MSTP002]),
-	CLKDEV_CON_ID("fe1_fck", &mstp_clks[MSTP001]),
-	CLKDEV_CON_ID("fe0_fck", &mstp_clks[MSTP000]),
-
-	CLKDEV_ICK_ID("fck", "sh-tmu.0", &mstp_clks[MSTP008]),
-	CLKDEV_ICK_ID("fck", "sh-tmu.1", &mstp_clks[MSTP009]),
-
-	CLKDEV_CON_ID("hudi_fck", &mstp_clks[MSTP119]),
-	CLKDEV_CON_ID("dmac_11_6_fck", &mstp_clks[MSTP105]),
-	CLKDEV_CON_ID("dmac_5_0_fck", &mstp_clks[MSTP104]),
-};
-
-int __init arch_clk_init(void)
-{
-	int i, ret = 0;
-
-	for (i = 0; i < ARRAY_SIZE(clks); i++)
-		ret |= clk_register(clks[i]);
-
-	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
-
-	if (!ret)
-		ret = sh_clk_div4_register(div4_clks, ARRAY_SIZE(div4_clks),
-					   &div4_table);
-	if (!ret)
-		ret = sh_clk_mstp_register(mstp_clks, MSTP_NR);
-
-	return ret;
-}
diff --git a/arch/sh/kernel/cpu/sh4a/intc-shx3.c b/arch/sh/kernel/cpu/sh4a/intc-shx3.c
deleted file mode 100644
index eea87d25efbb3f..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/intc-shx3.c
+++ /dev/null
@@ -1,31 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Shared support for SH-X3 interrupt controllers.
- *
- *  Copyright (C) 2009 - 2010  Paul Mundt
- */
-#include <linux/irq.h>
-#include <linux/io.h>
-#include <linux/init.h>
-
-#define INTACK		0xfe4100b8
-#define INTACKCLR	0xfe4100bc
-#define INTC_USERIMASK	0xfe411000
-
-#ifdef CONFIG_INTC_BALANCING
-unsigned int irq_lookup(unsigned int irq)
-{
-	return __raw_readl(INTACK) & 1 ? irq : NO_IRQ_IGNORE;
-}
-
-void irq_finish(unsigned int irq)
-{
-	__raw_writel(irq2evt(irq), INTACKCLR);
-}
-#endif
-
-static int __init shx3_irq_setup(void)
-{
-	return register_intc_userimask(INTC_USERIMASK);
-}
-arch_initcall(shx3_irq_setup);
diff --git a/arch/sh/kernel/cpu/sh4a/perf_event.c b/arch/sh/kernel/cpu/sh4a/perf_event.c
deleted file mode 100644
index 3beb8fed3d289d..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/perf_event.c
+++ /dev/null
@@ -1,299 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Performance events support for SH-4A performance counters
- *
- *  Copyright (C) 2009, 2010  Paul Mundt
- */
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/irq.h>
-#include <linux/perf_event.h>
-#include <asm/processor.h>
-
-#define PPC_CCBR(idx)	(0xff200800 + (sizeof(u32) * idx))
-#define PPC_PMCTR(idx)	(0xfc100000 + (sizeof(u32) * idx))
-
-#define CCBR_CIT_MASK	(0x7ff << 6)
-#define CCBR_DUC	(1 << 3)
-#define CCBR_CMDS	(1 << 1)
-#define CCBR_PPCE	(1 << 0)
-
-#ifdef CONFIG_CPU_SHX3
-/*
- * The PMCAT location for SH-X3 CPUs was quietly moved, while the CCBR
- * and PMCTR locations remains tentatively constant. This change remains
- * wholly undocumented, and was simply found through trial and error.
- *
- * Early cuts of SH-X3 still appear to use the SH-X/SH-X2 locations, and
- * it's unclear when this ceased to be the case. For now we always use
- * the new location (if future parts keep up with this trend then
- * scanning for them at runtime also remains a viable option.)
- *
- * The gap in the register space also suggests that there are other
- * undocumented counters, so this will need to be revisited at a later
- * point in time.
- */
-#define PPC_PMCAT	0xfc100240
-#else
-#define PPC_PMCAT	0xfc100080
-#endif
-
-#define PMCAT_OVF3	(1 << 27)
-#define PMCAT_CNN3	(1 << 26)
-#define PMCAT_CLR3	(1 << 25)
-#define PMCAT_OVF2	(1 << 19)
-#define PMCAT_CLR2	(1 << 17)
-#define PMCAT_OVF1	(1 << 11)
-#define PMCAT_CNN1	(1 << 10)
-#define PMCAT_CLR1	(1 << 9)
-#define PMCAT_OVF0	(1 << 3)
-#define PMCAT_CLR0	(1 << 1)
-
-static struct sh_pmu sh4a_pmu;
-
-/*
- * Supported raw event codes:
- *
- *	Event Code	Description
- *	----------	-----------
- *
- *	0x0000		number of elapsed cycles
- *	0x0200		number of elapsed cycles in privileged mode
- *	0x0280		number of elapsed cycles while SR.BL is asserted
- *	0x0202		instruction execution
- *	0x0203		instruction execution in parallel
- *	0x0204		number of unconditional branches
- *	0x0208		number of exceptions
- *	0x0209		number of interrupts
- *	0x0220		UTLB miss caused by instruction fetch
- *	0x0222		UTLB miss caused by operand access
- *	0x02a0		number of ITLB misses
- *	0x0028		number of accesses to instruction memories
- *	0x0029		number of accesses to instruction cache
- *	0x002a		instruction cache miss
- *	0x022e		number of access to instruction X/Y memory
- *	0x0030		number of reads to operand memories
- *	0x0038		number of writes to operand memories
- *	0x0031		number of operand cache read accesses
- *	0x0039		number of operand cache write accesses
- *	0x0032		operand cache read miss
- *	0x003a		operand cache write miss
- *	0x0236		number of reads to operand X/Y memory
- *	0x023e		number of writes to operand X/Y memory
- *	0x0237		number of reads to operand U memory
- *	0x023f		number of writes to operand U memory
- *	0x0337		number of U memory read buffer misses
- *	0x02b4		number of wait cycles due to operand read access
- *	0x02bc		number of wait cycles due to operand write access
- *	0x0033		number of wait cycles due to operand cache read miss
- *	0x003b		number of wait cycles due to operand cache write miss
- */
-
-/*
- * Special reserved bits used by hardware emulators, read values will
- * vary, but writes must always be 0.
- */
-#define PMCAT_EMU_CLR_MASK	((1 << 24) | (1 << 16) | (1 << 8) | (1 << 0))
-
-static const int sh4a_general_events[] = {
-	[PERF_COUNT_HW_CPU_CYCLES]		= 0x0000,
-	[PERF_COUNT_HW_INSTRUCTIONS]		= 0x0202,
-	[PERF_COUNT_HW_CACHE_REFERENCES]	= 0x0029,	/* I-cache */
-	[PERF_COUNT_HW_CACHE_MISSES]		= 0x002a,	/* I-cache */
-	[PERF_COUNT_HW_BRANCH_INSTRUCTIONS]	= 0x0204,
-	[PERF_COUNT_HW_BRANCH_MISSES]		= -1,
-	[PERF_COUNT_HW_BUS_CYCLES]		= -1,
-};
-
-#define C(x)	PERF_COUNT_HW_CACHE_##x
-
-static const int sh4a_cache_events
-			[PERF_COUNT_HW_CACHE_MAX]
-			[PERF_COUNT_HW_CACHE_OP_MAX]
-			[PERF_COUNT_HW_CACHE_RESULT_MAX] =
-{
-	[ C(L1D) ] = {
-		[ C(OP_READ) ] = {
-			[ C(RESULT_ACCESS) ] = 0x0031,
-			[ C(RESULT_MISS)   ] = 0x0032,
-		},
-		[ C(OP_WRITE) ] = {
-			[ C(RESULT_ACCESS) ] = 0x0039,
-			[ C(RESULT_MISS)   ] = 0x003a,
-		},
-		[ C(OP_PREFETCH) ] = {
-			[ C(RESULT_ACCESS) ] = 0,
-			[ C(RESULT_MISS)   ] = 0,
-		},
-	},
-
-	[ C(L1I) ] = {
-		[ C(OP_READ) ] = {
-			[ C(RESULT_ACCESS) ] = 0x0029,
-			[ C(RESULT_MISS)   ] = 0x002a,
-		},
-		[ C(OP_WRITE) ] = {
-			[ C(RESULT_ACCESS) ] = -1,
-			[ C(RESULT_MISS)   ] = -1,
-		},
-		[ C(OP_PREFETCH) ] = {
-			[ C(RESULT_ACCESS) ] = 0,
-			[ C(RESULT_MISS)   ] = 0,
-		},
-	},
-
-	[ C(LL) ] = {
-		[ C(OP_READ) ] = {
-			[ C(RESULT_ACCESS) ] = 0x0030,
-			[ C(RESULT_MISS)   ] = 0,
-		},
-		[ C(OP_WRITE) ] = {
-			[ C(RESULT_ACCESS) ] = 0x0038,
-			[ C(RESULT_MISS)   ] = 0,
-		},
-		[ C(OP_PREFETCH) ] = {
-			[ C(RESULT_ACCESS) ] = 0,
-			[ C(RESULT_MISS)   ] = 0,
-		},
-	},
-
-	[ C(DTLB) ] = {
-		[ C(OP_READ) ] = {
-			[ C(RESULT_ACCESS) ] = 0x0222,
-			[ C(RESULT_MISS)   ] = 0x0220,
-		},
-		[ C(OP_WRITE) ] = {
-			[ C(RESULT_ACCESS) ] = 0,
-			[ C(RESULT_MISS)   ] = 0,
-		},
-		[ C(OP_PREFETCH) ] = {
-			[ C(RESULT_ACCESS) ] = 0,
-			[ C(RESULT_MISS)   ] = 0,
-		},
-	},
-
-	[ C(ITLB) ] = {
-		[ C(OP_READ) ] = {
-			[ C(RESULT_ACCESS) ] = 0,
-			[ C(RESULT_MISS)   ] = 0x02a0,
-		},
-		[ C(OP_WRITE) ] = {
-			[ C(RESULT_ACCESS) ] = -1,
-			[ C(RESULT_MISS)   ] = -1,
-		},
-		[ C(OP_PREFETCH) ] = {
-			[ C(RESULT_ACCESS) ] = -1,
-			[ C(RESULT_MISS)   ] = -1,
-		},
-	},
-
-	[ C(BPU) ] = {
-		[ C(OP_READ) ] = {
-			[ C(RESULT_ACCESS) ] = -1,
-			[ C(RESULT_MISS)   ] = -1,
-		},
-		[ C(OP_WRITE) ] = {
-			[ C(RESULT_ACCESS) ] = -1,
-			[ C(RESULT_MISS)   ] = -1,
-		},
-		[ C(OP_PREFETCH) ] = {
-			[ C(RESULT_ACCESS) ] = -1,
-			[ C(RESULT_MISS)   ] = -1,
-		},
-	},
-
-	[ C(NODE) ] = {
-		[ C(OP_READ) ] = {
-			[ C(RESULT_ACCESS) ] = -1,
-			[ C(RESULT_MISS)   ] = -1,
-		},
-		[ C(OP_WRITE) ] = {
-			[ C(RESULT_ACCESS) ] = -1,
-			[ C(RESULT_MISS)   ] = -1,
-		},
-		[ C(OP_PREFETCH) ] = {
-			[ C(RESULT_ACCESS) ] = -1,
-			[ C(RESULT_MISS)   ] = -1,
-		},
-	},
-};
-
-static int sh4a_event_map(int event)
-{
-	return sh4a_general_events[event];
-}
-
-static u64 sh4a_pmu_read(int idx)
-{
-	return __raw_readl(PPC_PMCTR(idx));
-}
-
-static void sh4a_pmu_disable(struct hw_perf_event *hwc, int idx)
-{
-	unsigned int tmp;
-
-	tmp = __raw_readl(PPC_CCBR(idx));
-	tmp &= ~(CCBR_CIT_MASK | CCBR_DUC);
-	__raw_writel(tmp, PPC_CCBR(idx));
-}
-
-static void sh4a_pmu_enable(struct hw_perf_event *hwc, int idx)
-{
-	unsigned int tmp;
-
-	tmp = __raw_readl(PPC_PMCAT);
-	tmp &= ~PMCAT_EMU_CLR_MASK;
-	tmp |= idx ? PMCAT_CLR1 : PMCAT_CLR0;
-	__raw_writel(tmp, PPC_PMCAT);
-
-	tmp = __raw_readl(PPC_CCBR(idx));
-	tmp |= (hwc->config << 6) | CCBR_CMDS | CCBR_PPCE;
-	__raw_writel(tmp, PPC_CCBR(idx));
-
-	__raw_writel(__raw_readl(PPC_CCBR(idx)) | CCBR_DUC, PPC_CCBR(idx));
-}
-
-static void sh4a_pmu_disable_all(void)
-{
-	int i;
-
-	for (i = 0; i < sh4a_pmu.num_events; i++)
-		__raw_writel(__raw_readl(PPC_CCBR(i)) & ~CCBR_DUC, PPC_CCBR(i));
-}
-
-static void sh4a_pmu_enable_all(void)
-{
-	int i;
-
-	for (i = 0; i < sh4a_pmu.num_events; i++)
-		__raw_writel(__raw_readl(PPC_CCBR(i)) | CCBR_DUC, PPC_CCBR(i));
-}
-
-static struct sh_pmu sh4a_pmu = {
-	.name		= "sh4a",
-	.num_events	= 2,
-	.event_map	= sh4a_event_map,
-	.max_events	= ARRAY_SIZE(sh4a_general_events),
-	.raw_event_mask	= 0x3ff,
-	.cache_events	= &sh4a_cache_events,
-	.read		= sh4a_pmu_read,
-	.disable	= sh4a_pmu_disable,
-	.enable		= sh4a_pmu_enable,
-	.disable_all	= sh4a_pmu_disable_all,
-	.enable_all	= sh4a_pmu_enable_all,
-};
-
-static int __init sh4a_pmu_init(void)
-{
-	/*
-	 * Make sure this CPU actually has perf counters.
-	 */
-	if (!(boot_cpu_data.flags & CPU_HAS_PERF_COUNTER)) {
-		pr_notice("HW perf events unsupported, software events only.\n");
-		return -ENODEV;
-	}
-
-	return register_sh_pmu(&sh4a_pmu);
-}
-early_initcall(sh4a_pmu_init);
diff --git a/arch/sh/kernel/cpu/sh4a/pinmux-sh7722.c b/arch/sh/kernel/cpu/sh4a/pinmux-sh7722.c
deleted file mode 100644
index 0dd5312f930b1e..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/pinmux-sh7722.c
+++ /dev/null
@@ -1,21 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/bug.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/ioport.h>
-#include <cpu/pfc.h>
-
-static struct resource sh7722_pfc_resources[] = {
-	[0] = {
-		.start	= 0xa4050100,
-		.end	= 0xa405018f,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static int __init plat_pinmux_setup(void)
-{
-	return sh_pfc_register("pfc-sh7722", sh7722_pfc_resources,
-			       ARRAY_SIZE(sh7722_pfc_resources));
-}
-arch_initcall(plat_pinmux_setup);
diff --git a/arch/sh/kernel/cpu/sh4a/pinmux-sh7723.c b/arch/sh/kernel/cpu/sh4a/pinmux-sh7723.c
deleted file mode 100644
index b67abc0637a487..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/pinmux-sh7723.c
+++ /dev/null
@@ -1,27 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7723 Pinmux
- *
- *  Copyright (C) 2008  Magnus Damm
- */
-
-#include <linux/bug.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/ioport.h>
-#include <cpu/pfc.h>
-
-static struct resource sh7723_pfc_resources[] = {
-	[0] = {
-		.start	= 0xa4050100,
-		.end	= 0xa405016f,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static int __init plat_pinmux_setup(void)
-{
-	return sh_pfc_register("pfc-sh7723", sh7723_pfc_resources,
-			       ARRAY_SIZE(sh7723_pfc_resources));
-}
-arch_initcall(plat_pinmux_setup);
diff --git a/arch/sh/kernel/cpu/sh4a/pinmux-sh7724.c b/arch/sh/kernel/cpu/sh4a/pinmux-sh7724.c
deleted file mode 100644
index b43c3259060bbe..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/pinmux-sh7724.c
+++ /dev/null
@@ -1,32 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7724 Pinmux
- *
- * Copyright (C) 2009 Renesas Solutions Corp.
- *
- * Kuninori Morimoto <morimoto.kuninori@renesas.com>
- *
- * Based on SH7723 Pinmux
- *  Copyright (C) 2008  Magnus Damm
- */
-
-#include <linux/bug.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/ioport.h>
-#include <cpu/pfc.h>
-
-static struct resource sh7724_pfc_resources[] = {
-	[0] = {
-		.start	= 0xa4050100,
-		.end	= 0xa405016f,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static int __init plat_pinmux_setup(void)
-{
-	return sh_pfc_register("pfc-sh7724", sh7724_pfc_resources,
-			       ARRAY_SIZE(sh7724_pfc_resources));
-}
-arch_initcall(plat_pinmux_setup);
diff --git a/arch/sh/kernel/cpu/sh4a/pinmux-sh7734.c b/arch/sh/kernel/cpu/sh4a/pinmux-sh7734.c
deleted file mode 100644
index 46256b19619a79..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/pinmux-sh7734.c
+++ /dev/null
@@ -1,32 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7734 processor support - PFC hardware block
- *
- * Copyright (C) 2012  Renesas Solutions Corp.
- * Copyright (C) 2012  Nobuhiro Iwamatsu <nobuhiro.iwamatsu.yj@renesas.com>
- */
-#include <linux/bug.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/ioport.h>
-#include <cpu/pfc.h>
-
-static struct resource sh7734_pfc_resources[] = {
-	[0] = { /* PFC */
-		.start	= 0xFFFC0000,
-		.end	= 0xFFFC011C,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = { /* GPIO */
-		.start	= 0xFFC40000,
-		.end	= 0xFFC4502B,
-		.flags	= IORESOURCE_MEM,
-	}
-};
-
-static int __init plat_pinmux_setup(void)
-{
-	return sh_pfc_register("pfc-sh7734", sh7734_pfc_resources,
-			       ARRAY_SIZE(sh7734_pfc_resources));
-}
-arch_initcall(plat_pinmux_setup);
diff --git a/arch/sh/kernel/cpu/sh4a/pinmux-sh7757.c b/arch/sh/kernel/cpu/sh4a/pinmux-sh7757.c
deleted file mode 100644
index c92f304cb4bad1..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/pinmux-sh7757.c
+++ /dev/null
@@ -1,32 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7757 (B0 step) Pinmux
- *
- *  Copyright (C) 2009-2010  Renesas Solutions Corp.
- *
- *  Author : Yoshihiro Shimoda <shimoda.yoshihiro@renesas.com>
- *
- * Based on SH7723 Pinmux
- *  Copyright (C) 2008  Magnus Damm
- */
-
-#include <linux/bug.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/ioport.h>
-#include <cpu/pfc.h>
-
-static struct resource sh7757_pfc_resources[] = {
-	[0] = {
-		.start	= 0xffec0000,
-		.end	= 0xffec008f,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static int __init plat_pinmux_setup(void)
-{
-	return sh_pfc_register("pfc-sh7757", sh7757_pfc_resources,
-			       ARRAY_SIZE(sh7757_pfc_resources));
-}
-arch_initcall(plat_pinmux_setup);
diff --git a/arch/sh/kernel/cpu/sh4a/pinmux-sh7785.c b/arch/sh/kernel/cpu/sh4a/pinmux-sh7785.c
deleted file mode 100644
index f329de6e758a4f..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/pinmux-sh7785.c
+++ /dev/null
@@ -1,27 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7785 Pinmux
- *
- *  Copyright (C) 2008  Magnus Damm
- */
-
-#include <linux/bug.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/ioport.h>
-#include <cpu/pfc.h>
-
-static struct resource sh7785_pfc_resources[] = {
-	[0] = {
-		.start	= 0xffe70000,
-		.end	= 0xffe7008f,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static int __init plat_pinmux_setup(void)
-{
-	return sh_pfc_register("pfc-sh7785", sh7785_pfc_resources,
-			       ARRAY_SIZE(sh7785_pfc_resources));
-}
-arch_initcall(plat_pinmux_setup);
diff --git a/arch/sh/kernel/cpu/sh4a/pinmux-sh7786.c b/arch/sh/kernel/cpu/sh4a/pinmux-sh7786.c
deleted file mode 100644
index 47e8639f3e71b1..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/pinmux-sh7786.c
+++ /dev/null
@@ -1,32 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7786 Pinmux
- *
- * Copyright (C) 2008, 2009  Renesas Solutions Corp.
- * Kuninori Morimoto <morimoto.kuninori@renesas.com>
- *
- *  Based on SH7785 pinmux
- *
- *  Copyright (C) 2008  Magnus Damm
- */
-
-#include <linux/bug.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/ioport.h>
-#include <cpu/pfc.h>
-
-static struct resource sh7786_pfc_resources[] = {
-	[0] = {
-		.start	= 0xffcc0000,
-		.end	= 0xffcc008f,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static int __init plat_pinmux_setup(void)
-{
-	return sh_pfc_register("pfc-sh7786", sh7786_pfc_resources,
-			       ARRAY_SIZE(sh7786_pfc_resources));
-}
-arch_initcall(plat_pinmux_setup);
diff --git a/arch/sh/kernel/cpu/sh4a/pinmux-shx3.c b/arch/sh/kernel/cpu/sh4a/pinmux-shx3.c
deleted file mode 100644
index 6c02f625646754..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/pinmux-shx3.c
+++ /dev/null
@@ -1,26 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH-X3 prototype CPU pinmux
- *
- * Copyright (C) 2010  Paul Mundt
- */
-#include <linux/bug.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/ioport.h>
-#include <cpu/pfc.h>
-
-static struct resource shx3_pfc_resources[] = {
-	[0] = {
-		.start	= 0xffc70000,
-		.end	= 0xffc7001f,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static int __init plat_pinmux_setup(void)
-{
-	return sh_pfc_register("pfc-shx3", shx3_pfc_resources,
-			       ARRAY_SIZE(shx3_pfc_resources));
-}
-arch_initcall(plat_pinmux_setup);
diff --git a/arch/sh/kernel/cpu/sh4a/serial-sh7722.c b/arch/sh/kernel/cpu/sh4a/serial-sh7722.c
deleted file mode 100644
index 6ecc8b6e133c69..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/serial-sh7722.c
+++ /dev/null
@@ -1,24 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/serial_sci.h>
-#include <linux/serial_core.h>
-#include <linux/io.h>
-
-#define PSCR 0xA405011E
-
-static void sh7722_sci_init_pins(struct uart_port *port, unsigned int cflag)
-{
-	unsigned short data;
-
-	if (port->mapbase == 0xffe00000) {
-		data = __raw_readw(PSCR);
-		data &= ~0x03cf;
-		if (!(cflag & CRTSCTS))
-			data |= 0x0340;
-
-		__raw_writew(data, PSCR);
-	}
-}
-
-struct plat_sci_port_ops sh7722_sci_port_ops = {
-	.init_pins	= sh7722_sci_init_pins,
-};
diff --git a/arch/sh/kernel/cpu/sh4a/setup-sh7343.c b/arch/sh/kernel/cpu/sh4a/setup-sh7343.c
deleted file mode 100644
index b6015188fab1f1..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/setup-sh7343.c
+++ /dev/null
@@ -1,444 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7343 Setup
- *
- *  Copyright (C) 2006  Paul Mundt
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/serial_sci.h>
-#include <linux/uio_driver.h>
-#include <linux/sh_timer.h>
-#include <linux/sh_intc.h>
-#include <asm/clock.h>
-#include <asm/platform_early.h>
-
-/* Serial */
-static struct plat_sci_port scif0_platform_data = {
-	.scscr		= SCSCR_CKE1,
-	.type           = PORT_SCIF,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xffe00000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xc00)),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct plat_sci_port scif1_platform_data = {
-	.scscr		= SCSCR_CKE1,
-	.type           = PORT_SCIF,
-};
-
-static struct resource scif1_resources[] = {
-	DEFINE_RES_MEM(0xffe10000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xc20)),
-};
-
-static struct platform_device scif1_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif1_resources,
-	.num_resources	= ARRAY_SIZE(scif1_resources),
-	.dev		= {
-		.platform_data	= &scif1_platform_data,
-	},
-};
-
-static struct plat_sci_port scif2_platform_data = {
-	.scscr		= SCSCR_CKE1,
-	.type           = PORT_SCIF,
-};
-
-static struct resource scif2_resources[] = {
-	DEFINE_RES_MEM(0xffe20000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xc40)),
-};
-
-static struct platform_device scif2_device = {
-	.name		= "sh-sci",
-	.id		= 2,
-	.resource	= scif2_resources,
-	.num_resources	= ARRAY_SIZE(scif2_resources),
-	.dev		= {
-		.platform_data	= &scif2_platform_data,
-	},
-};
-
-static struct plat_sci_port scif3_platform_data = {
-	.scscr		= SCSCR_CKE1,
-	.type           = PORT_SCIF,
-};
-
-static struct resource scif3_resources[] = {
-	DEFINE_RES_MEM(0xffe30000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xc60)),
-};
-
-static struct platform_device scif3_device = {
-	.name		= "sh-sci",
-	.id		= 3,
-	.resource	= scif3_resources,
-	.num_resources	= ARRAY_SIZE(scif3_resources),
-	.dev		= {
-		.platform_data	= &scif3_platform_data,
-	},
-};
-
-static struct resource iic0_resources[] = {
-	[0] = {
-		.name	= "IIC0",
-		.start  = 0x04470000,
-		.end    = 0x04470017,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0xe00),
-		.end    = evt2irq(0xe60),
-		.flags  = IORESOURCE_IRQ,
-       },
-};
-
-static struct platform_device iic0_device = {
-	.name           = "i2c-sh_mobile",
-	.id             = 0, /* "i2c0" clock */
-	.num_resources  = ARRAY_SIZE(iic0_resources),
-	.resource       = iic0_resources,
-};
-
-static struct resource iic1_resources[] = {
-	[0] = {
-		.name	= "IIC1",
-		.start  = 0x04750000,
-		.end    = 0x04750017,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0x780),
-		.end    = evt2irq(0x7e0),
-		.flags  = IORESOURCE_IRQ,
-       },
-};
-
-static struct platform_device iic1_device = {
-	.name           = "i2c-sh_mobile",
-	.id             = 1, /* "i2c1" clock */
-	.num_resources  = ARRAY_SIZE(iic1_resources),
-	.resource       = iic1_resources,
-};
-
-static struct uio_info vpu_platform_data = {
-	.name = "VPU4",
-	.version = "0",
-	.irq = evt2irq(0x980),
-};
-
-static struct resource vpu_resources[] = {
-	[0] = {
-		.name	= "VPU",
-		.start	= 0xfe900000,
-		.end	= 0xfe9022eb,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* place holder for contiguous memory */
-	},
-};
-
-static struct platform_device vpu_device = {
-	.name		= "uio_pdrv_genirq",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &vpu_platform_data,
-	},
-	.resource	= vpu_resources,
-	.num_resources	= ARRAY_SIZE(vpu_resources),
-};
-
-static struct uio_info veu_platform_data = {
-	.name = "VEU",
-	.version = "0",
-	.irq = evt2irq(0x8c0),
-};
-
-static struct resource veu_resources[] = {
-	[0] = {
-		.name	= "VEU",
-		.start	= 0xfe920000,
-		.end	= 0xfe9200b7,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* place holder for contiguous memory */
-	},
-};
-
-static struct platform_device veu_device = {
-	.name		= "uio_pdrv_genirq",
-	.id		= 1,
-	.dev = {
-		.platform_data	= &veu_platform_data,
-	},
-	.resource	= veu_resources,
-	.num_resources	= ARRAY_SIZE(veu_resources),
-};
-
-static struct uio_info jpu_platform_data = {
-	.name = "JPU",
-	.version = "0",
-	.irq = evt2irq(0x560),
-};
-
-static struct resource jpu_resources[] = {
-	[0] = {
-		.name	= "JPU",
-		.start	= 0xfea00000,
-		.end	= 0xfea102d3,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* place holder for contiguous memory */
-	},
-};
-
-static struct platform_device jpu_device = {
-	.name		= "uio_pdrv_genirq",
-	.id		= 2,
-	.dev = {
-		.platform_data	= &jpu_platform_data,
-	},
-	.resource	= jpu_resources,
-	.num_resources	= ARRAY_SIZE(jpu_resources),
-};
-
-static struct sh_timer_config cmt_platform_data = {
-	.channels_mask = 0x20,
-};
-
-static struct resource cmt_resources[] = {
-	DEFINE_RES_MEM(0x044a0000, 0x70),
-	DEFINE_RES_IRQ(evt2irq(0xf00)),
-};
-
-static struct platform_device cmt_device = {
-	.name		= "sh-cmt-32",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &cmt_platform_data,
-	},
-	.resource	= cmt_resources,
-	.num_resources	= ARRAY_SIZE(cmt_resources),
-};
-
-static struct sh_timer_config tmu0_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu0_resources[] = {
-	DEFINE_RES_MEM(0xffd80000, 0x2c),
-	DEFINE_RES_IRQ(evt2irq(0x400)),
-	DEFINE_RES_IRQ(evt2irq(0x420)),
-	DEFINE_RES_IRQ(evt2irq(0x440)),
-};
-
-static struct platform_device tmu0_device = {
-	.name		= "sh-tmu",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &tmu0_platform_data,
-	},
-	.resource	= tmu0_resources,
-	.num_resources	= ARRAY_SIZE(tmu0_resources),
-};
-
-static struct platform_device *sh7343_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&cmt_device,
-	&tmu0_device,
-	&iic0_device,
-	&iic1_device,
-	&vpu_device,
-	&veu_device,
-	&jpu_device,
-};
-
-static int __init sh7343_devices_setup(void)
-{
-	platform_resource_setup_memory(&vpu_device, "vpu", 1 << 20);
-	platform_resource_setup_memory(&veu_device, "veu", 2 << 20);
-	platform_resource_setup_memory(&jpu_device, "jpu", 2 << 20);
-
-	return platform_add_devices(sh7343_devices,
-				    ARRAY_SIZE(sh7343_devices));
-}
-arch_initcall(sh7343_devices_setup);
-
-static struct platform_device *sh7343_early_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&cmt_device,
-	&tmu0_device,
-};
-
-void __init plat_early_device_setup(void)
-{
-	sh_early_platform_add_devices(sh7343_early_devices,
-				   ARRAY_SIZE(sh7343_early_devices));
-}
-
-enum {
-	UNUSED = 0,
-	ENABLED,
-	DISABLED,
-
-	/* interrupt sources */
-	IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7,
-	DMAC0, DMAC1, DMAC2, DMAC3,
-	VIO_CEUI, VIO_BEUI, VIO_VEUI, VOU,
-	MFI, VPU, TPU, Z3D4, USBI0, USBI1,
-	MMC_ERR, MMC_TRAN, MMC_FSTAT, MMC_FRDY,
-	DMAC4, DMAC5, DMAC_DADERR,
-	KEYSC,
-	SCIF, SCIF1, SCIF2, SCIF3,
-	SIOF0, SIOF1, SIO,
-	FLCTL_FLSTEI, FLCTL_FLENDI, FLCTL_FLTREQ0I, FLCTL_FLTREQ1I,
-	I2C0_ALI, I2C0_TACKI, I2C0_WAITI, I2C0_DTEI,
-	I2C1_ALI, I2C1_TACKI, I2C1_WAITI, I2C1_DTEI,
-	SIM_TEI, SIM_TXI, SIM_RXI, SIM_ERI,
-	IRDA, SDHI, CMT, TSIF, SIU,
-	TMU0, TMU1, TMU2,
-	JPU, LCDC,
-
-	/* interrupt groups */
-
-	DMAC0123, VIOVOU, MMC, DMAC45, FLCTL, I2C0, I2C1, SIM, USB,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_VECT(IRQ0, 0x600), INTC_VECT(IRQ1, 0x620),
-	INTC_VECT(IRQ2, 0x640), INTC_VECT(IRQ3, 0x660),
-	INTC_VECT(IRQ4, 0x680), INTC_VECT(IRQ5, 0x6a0),
-	INTC_VECT(IRQ6, 0x6c0), INTC_VECT(IRQ7, 0x6e0),
-	INTC_VECT(I2C1_ALI, 0x780), INTC_VECT(I2C1_TACKI, 0x7a0),
-	INTC_VECT(I2C1_WAITI, 0x7c0), INTC_VECT(I2C1_DTEI, 0x7e0),
-	INTC_VECT(DMAC0, 0x800), INTC_VECT(DMAC1, 0x820),
-	INTC_VECT(DMAC2, 0x840), INTC_VECT(DMAC3, 0x860),
-	INTC_VECT(VIO_CEUI, 0x880), INTC_VECT(VIO_BEUI, 0x8a0),
-	INTC_VECT(VIO_VEUI, 0x8c0), INTC_VECT(VOU, 0x8e0),
-	INTC_VECT(MFI, 0x900), INTC_VECT(VPU, 0x980),
-	INTC_VECT(TPU, 0x9a0), INTC_VECT(Z3D4, 0x9e0),
-	INTC_VECT(USBI0, 0xa20), INTC_VECT(USBI1, 0xa40),
-	INTC_VECT(MMC_ERR, 0xb00), INTC_VECT(MMC_TRAN, 0xb20),
-	INTC_VECT(MMC_FSTAT, 0xb40), INTC_VECT(MMC_FRDY, 0xb60),
-	INTC_VECT(DMAC4, 0xb80), INTC_VECT(DMAC5, 0xba0),
-	INTC_VECT(DMAC_DADERR, 0xbc0), INTC_VECT(KEYSC, 0xbe0),
-	INTC_VECT(SCIF, 0xc00), INTC_VECT(SCIF1, 0xc20),
-	INTC_VECT(SCIF2, 0xc40), INTC_VECT(SCIF3, 0xc60),
-	INTC_VECT(SIOF0, 0xc80), INTC_VECT(SIOF1, 0xca0),
-	INTC_VECT(SIO, 0xd00),
-	INTC_VECT(FLCTL_FLSTEI, 0xd80), INTC_VECT(FLCTL_FLENDI, 0xda0),
-	INTC_VECT(FLCTL_FLTREQ0I, 0xdc0), INTC_VECT(FLCTL_FLTREQ1I, 0xde0),
-	INTC_VECT(I2C0_ALI, 0xe00), INTC_VECT(I2C0_TACKI, 0xe20),
-	INTC_VECT(I2C0_WAITI, 0xe40), INTC_VECT(I2C0_DTEI, 0xe60),
-	INTC_VECT(SDHI, 0xe80), INTC_VECT(SDHI, 0xea0),
-	INTC_VECT(SDHI, 0xec0), INTC_VECT(SDHI, 0xee0),
-	INTC_VECT(CMT, 0xf00), INTC_VECT(TSIF, 0xf20),
-	INTC_VECT(SIU, 0xf80),
-	INTC_VECT(TMU0, 0x400), INTC_VECT(TMU1, 0x420),
-	INTC_VECT(TMU2, 0x440),
-	INTC_VECT(JPU, 0x560), INTC_VECT(LCDC, 0x580),
-};
-
-static struct intc_group groups[] __initdata = {
-	INTC_GROUP(DMAC0123, DMAC0, DMAC1, DMAC2, DMAC3),
-	INTC_GROUP(VIOVOU, VIO_CEUI, VIO_BEUI, VIO_VEUI, VOU),
-	INTC_GROUP(MMC, MMC_FRDY, MMC_FSTAT, MMC_TRAN, MMC_ERR),
-	INTC_GROUP(DMAC45, DMAC4, DMAC5, DMAC_DADERR),
-	INTC_GROUP(FLCTL, FLCTL_FLSTEI, FLCTL_FLENDI,
-		   FLCTL_FLTREQ0I, FLCTL_FLTREQ1I),
-	INTC_GROUP(I2C0, I2C0_ALI, I2C0_TACKI, I2C0_WAITI, I2C0_DTEI),
-	INTC_GROUP(I2C1, I2C1_ALI, I2C1_TACKI, I2C1_WAITI, I2C1_DTEI),
-	INTC_GROUP(SIM, SIM_TEI, SIM_TXI, SIM_RXI, SIM_ERI),
-	INTC_GROUP(USB, USBI0, USBI1),
-};
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xa4080084, 0xa40800c4, 8, /* IMR1 / IMCR1 */
-	  { VOU, VIO_VEUI, VIO_BEUI, VIO_CEUI, DMAC3, DMAC2, DMAC1, DMAC0 } },
-	{ 0xa4080088, 0xa40800c8, 8, /* IMR2 / IMCR2 */
-	  { 0, 0, 0, VPU, 0, 0, 0, MFI } },
-	{ 0xa408008c, 0xa40800cc, 8, /* IMR3 / IMCR3 */
-	  { SIM_TEI, SIM_TXI, SIM_RXI, SIM_ERI, 0, 0, 0, IRDA } },
-	{ 0xa4080090, 0xa40800d0, 8, /* IMR4 / IMCR4 */
-	  { 0, TMU2, TMU1, TMU0, JPU, 0, 0, LCDC } },
-	{ 0xa4080094, 0xa40800d4, 8, /* IMR5 / IMCR5 */
-	  { KEYSC, DMAC_DADERR, DMAC5, DMAC4, SCIF3, SCIF2, SCIF1, SCIF } },
-	{ 0xa4080098, 0xa40800d8, 8, /* IMR6 / IMCR6 */
-	  { 0, 0, 0, SIO, Z3D4, 0, SIOF1, SIOF0 } },
-	{ 0xa408009c, 0xa40800dc, 8, /* IMR7 / IMCR7 */
-	  { I2C0_DTEI, I2C0_WAITI, I2C0_TACKI, I2C0_ALI,
-	    FLCTL_FLTREQ1I, FLCTL_FLTREQ0I, FLCTL_FLENDI, FLCTL_FLSTEI } },
-	{ 0xa40800a0, 0xa40800e0, 8, /* IMR8 / IMCR8 */
-	  { DISABLED, ENABLED, ENABLED, ENABLED, 0, 0, 0, SIU } },
-	{ 0xa40800a4, 0xa40800e4, 8, /* IMR9 / IMCR9 */
-	  { 0, 0, 0, CMT, 0, USBI1, USBI0 } },
-	{ 0xa40800a8, 0xa40800e8, 8, /* IMR10 / IMCR10 */
-	  { MMC_FRDY, MMC_FSTAT, MMC_TRAN, MMC_ERR } },
-	{ 0xa40800ac, 0xa40800ec, 8, /* IMR11 / IMCR11 */
-	  { I2C1_DTEI, I2C1_WAITI, I2C1_TACKI, I2C1_ALI, TPU, 0, 0, TSIF } },
-	{ 0xa4140044, 0xa4140064, 8, /* INTMSK00 / INTMSKCLR00 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xa4080000, 0, 16, 4, /* IPRA */ { TMU0, TMU1, TMU2 } },
-	{ 0xa4080004, 0, 16, 4, /* IPRB */ { JPU, LCDC, SIM } },
-	{ 0xa4080010, 0, 16, 4, /* IPRE */ { DMAC0123, VIOVOU, MFI, VPU } },
-	{ 0xa4080014, 0, 16, 4, /* IPRF */ { KEYSC, DMAC45, USB, CMT } },
-	{ 0xa4080018, 0, 16, 4, /* IPRG */ { SCIF, SCIF1, SCIF2, SCIF3 } },
-	{ 0xa408001c, 0, 16, 4, /* IPRH */ { SIOF0, SIOF1, FLCTL, I2C0 } },
-	{ 0xa4080020, 0, 16, 4, /* IPRI */ { SIO, 0, TSIF, I2C1 } },
-	{ 0xa4080024, 0, 16, 4, /* IPRJ */ { Z3D4, 0, SIU } },
-	{ 0xa4080028, 0, 16, 4, /* IPRK */ { 0, MMC, 0, SDHI } },
-	{ 0xa408002c, 0, 16, 4, /* IPRL */ { 0, 0, TPU } },
-	{ 0xa4140010, 0, 32, 4, /* INTPRI00 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_sense_reg sense_registers[] __initdata = {
-	{ 0xa414001c, 16, 2, /* ICR1 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_mask_reg ack_registers[] __initdata = {
-	{ 0xa4140024, 0, 8, /* INTREQ00 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_desc intc_desc __initdata = {
-	.name = "sh7343",
-	.force_enable = ENABLED,
-	.force_disable = DISABLED,
-	.hw = INTC_HW_DESC(vectors, groups, mask_registers,
-			   prio_registers, sense_registers, ack_registers),
-};
-
-void __init plat_irq_setup(void)
-{
-	register_intc_controller(&intc_desc);
-}
diff --git a/arch/sh/kernel/cpu/sh4a/setup-sh7366.c b/arch/sh/kernel/cpu/sh4a/setup-sh7366.c
deleted file mode 100644
index 6676beef053e59..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/setup-sh7366.c
+++ /dev/null
@@ -1,388 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7366 Setup
- *
- *  Copyright (C) 2008 Renesas Solutions
- *
- * Based on linux/arch/sh/kernel/cpu/sh4a/setup-sh7722.c
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/serial_sci.h>
-#include <linux/uio_driver.h>
-#include <linux/sh_timer.h>
-#include <linux/sh_intc.h>
-#include <linux/usb/r8a66597.h>
-#include <asm/clock.h>
-#include <asm/platform_early.h>
-
-static struct plat_sci_port scif0_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xffe00000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xc00)),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct resource iic_resources[] = {
-	[0] = {
-		.name	= "IIC",
-		.start  = 0x04470000,
-		.end    = 0x04470017,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0xe00),
-		.end    = evt2irq(0xe60),
-		.flags  = IORESOURCE_IRQ,
-       },
-};
-
-static struct platform_device iic_device = {
-	.name           = "i2c-sh_mobile",
-	.id             = 0, /* "i2c0" clock */
-	.num_resources  = ARRAY_SIZE(iic_resources),
-	.resource       = iic_resources,
-};
-
-static struct r8a66597_platdata r8a66597_data = {
-	.on_chip = 1,
-};
-
-static struct resource usb_host_resources[] = {
-	[0] = {
-		.start  = 0xa4d80000,
-		.end    = 0xa4d800ff,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0xa20),
-		.end    = evt2irq(0xa20),
-		.flags	= IORESOURCE_IRQ | IRQF_TRIGGER_LOW,
-	},
-};
-
-static struct platform_device usb_host_device = {
-	.name	= "r8a66597_hcd",
-	.id	= -1,
-	.dev = {
-		.dma_mask		= NULL,
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &r8a66597_data,
-	},
-	.num_resources	= ARRAY_SIZE(usb_host_resources),
-	.resource	= usb_host_resources,
-};
-
-static struct uio_info vpu_platform_data = {
-	.name = "VPU5",
-	.version = "0",
-	.irq = evt2irq(0x980),
-};
-
-static struct resource vpu_resources[] = {
-	[0] = {
-		.name	= "VPU",
-		.start	= 0xfe900000,
-		.end	= 0xfe902807,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* place holder for contiguous memory */
-	},
-};
-
-static struct platform_device vpu_device = {
-	.name		= "uio_pdrv_genirq",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &vpu_platform_data,
-	},
-	.resource	= vpu_resources,
-	.num_resources	= ARRAY_SIZE(vpu_resources),
-};
-
-static struct uio_info veu0_platform_data = {
-	.name = "VEU",
-	.version = "0",
-	.irq = evt2irq(0x8c0),
-};
-
-static struct resource veu0_resources[] = {
-	[0] = {
-		.name	= "VEU(1)",
-		.start	= 0xfe920000,
-		.end	= 0xfe9200b7,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* place holder for contiguous memory */
-	},
-};
-
-static struct platform_device veu0_device = {
-	.name		= "uio_pdrv_genirq",
-	.id		= 1,
-	.dev = {
-		.platform_data	= &veu0_platform_data,
-	},
-	.resource	= veu0_resources,
-	.num_resources	= ARRAY_SIZE(veu0_resources),
-};
-
-static struct uio_info veu1_platform_data = {
-	.name = "VEU",
-	.version = "0",
-	.irq = evt2irq(0x560),
-};
-
-static struct resource veu1_resources[] = {
-	[0] = {
-		.name	= "VEU(2)",
-		.start	= 0xfe924000,
-		.end	= 0xfe9240b7,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* place holder for contiguous memory */
-	},
-};
-
-static struct platform_device veu1_device = {
-	.name		= "uio_pdrv_genirq",
-	.id		= 2,
-	.dev = {
-		.platform_data	= &veu1_platform_data,
-	},
-	.resource	= veu1_resources,
-	.num_resources	= ARRAY_SIZE(veu1_resources),
-};
-
-static struct sh_timer_config cmt_platform_data = {
-	.channels_mask = 0x20,
-};
-
-static struct resource cmt_resources[] = {
-	DEFINE_RES_MEM(0x044a0000, 0x70),
-	DEFINE_RES_IRQ(evt2irq(0xf00)),
-};
-
-static struct platform_device cmt_device = {
-	.name		= "sh-cmt-32",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &cmt_platform_data,
-	},
-	.resource	= cmt_resources,
-	.num_resources	= ARRAY_SIZE(cmt_resources),
-};
-
-static struct sh_timer_config tmu0_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu0_resources[] = {
-	DEFINE_RES_MEM(0xffd80000, 0x2c),
-	DEFINE_RES_IRQ(evt2irq(0x400)),
-	DEFINE_RES_IRQ(evt2irq(0x420)),
-	DEFINE_RES_IRQ(evt2irq(0x440)),
-};
-
-static struct platform_device tmu0_device = {
-	.name		= "sh-tmu",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &tmu0_platform_data,
-	},
-	.resource	= tmu0_resources,
-	.num_resources	= ARRAY_SIZE(tmu0_resources),
-};
-
-static struct platform_device *sh7366_devices[] __initdata = {
-	&scif0_device,
-	&cmt_device,
-	&tmu0_device,
-	&iic_device,
-	&usb_host_device,
-	&vpu_device,
-	&veu0_device,
-	&veu1_device,
-};
-
-static int __init sh7366_devices_setup(void)
-{
-	platform_resource_setup_memory(&vpu_device, "vpu", 2 << 20);
-	platform_resource_setup_memory(&veu0_device, "veu0", 2 << 20);
-	platform_resource_setup_memory(&veu1_device, "veu1", 2 << 20);
-
-	return platform_add_devices(sh7366_devices,
-				    ARRAY_SIZE(sh7366_devices));
-}
-arch_initcall(sh7366_devices_setup);
-
-static struct platform_device *sh7366_early_devices[] __initdata = {
-	&scif0_device,
-	&cmt_device,
-	&tmu0_device,
-};
-
-void __init plat_early_device_setup(void)
-{
-	sh_early_platform_add_devices(sh7366_early_devices,
-				   ARRAY_SIZE(sh7366_early_devices));
-}
-
-enum {
-	UNUSED=0,
-	ENABLED,
-	DISABLED,
-
-	/* interrupt sources */
-	IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7,
-	ICB,
-	DMAC0, DMAC1, DMAC2, DMAC3,
-	VIO_CEUI, VIO_BEUI, VIO_VEUI, VOU,
-	MFI, VPU, USB,
-	MMC_MMC1I, MMC_MMC2I, MMC_MMC3I,
-	DMAC4, DMAC5, DMAC_DADERR,
-	SCIF, SCIFA1, SCIFA2,
-	DENC, MSIOF,
-	FLCTL_FLSTEI, FLCTL_FLENDI, FLCTL_FLTREQ0I, FLCTL_FLTREQ1I,
-	I2C_ALI, I2C_TACKI, I2C_WAITI, I2C_DTEI,
-	SDHI, CMT, TSIF, SIU,
-	TMU0, TMU1, TMU2,
-	VEU2, LCDC,
-
-	/* interrupt groups */
-
-	DMAC0123, VIOVOU, MMC, DMAC45, FLCTL, I2C,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_VECT(IRQ0, 0x600), INTC_VECT(IRQ1, 0x620),
-	INTC_VECT(IRQ2, 0x640), INTC_VECT(IRQ3, 0x660),
-	INTC_VECT(IRQ4, 0x680), INTC_VECT(IRQ5, 0x6a0),
-	INTC_VECT(IRQ6, 0x6c0), INTC_VECT(IRQ7, 0x6e0),
-	INTC_VECT(ICB, 0x700),
-	INTC_VECT(DMAC0, 0x800), INTC_VECT(DMAC1, 0x820),
-	INTC_VECT(DMAC2, 0x840), INTC_VECT(DMAC3, 0x860),
-	INTC_VECT(VIO_CEUI, 0x880), INTC_VECT(VIO_BEUI, 0x8a0),
-	INTC_VECT(VIO_VEUI, 0x8c0), INTC_VECT(VOU, 0x8e0),
-	INTC_VECT(MFI, 0x900), INTC_VECT(VPU, 0x980), INTC_VECT(USB, 0xa20),
-	INTC_VECT(MMC_MMC1I, 0xb00), INTC_VECT(MMC_MMC2I, 0xb20),
-	INTC_VECT(MMC_MMC3I, 0xb40),
-	INTC_VECT(DMAC4, 0xb80), INTC_VECT(DMAC5, 0xba0),
-	INTC_VECT(DMAC_DADERR, 0xbc0),
-	INTC_VECT(SCIF, 0xc00), INTC_VECT(SCIFA1, 0xc20),
-	INTC_VECT(SCIFA2, 0xc40),
-	INTC_VECT(DENC, 0xc60), INTC_VECT(MSIOF, 0xc80),
-	INTC_VECT(FLCTL_FLSTEI, 0xd80), INTC_VECT(FLCTL_FLENDI, 0xda0),
-	INTC_VECT(FLCTL_FLTREQ0I, 0xdc0), INTC_VECT(FLCTL_FLTREQ1I, 0xde0),
-	INTC_VECT(I2C_ALI, 0xe00), INTC_VECT(I2C_TACKI, 0xe20),
-	INTC_VECT(I2C_WAITI, 0xe40), INTC_VECT(I2C_DTEI, 0xe60),
-	INTC_VECT(SDHI, 0xe80), INTC_VECT(SDHI, 0xea0),
-	INTC_VECT(SDHI, 0xec0), INTC_VECT(SDHI, 0xee0),
-	INTC_VECT(CMT, 0xf00), INTC_VECT(TSIF, 0xf20),
-	INTC_VECT(SIU, 0xf80),
-	INTC_VECT(TMU0, 0x400), INTC_VECT(TMU1, 0x420),
-	INTC_VECT(TMU2, 0x440),
-	INTC_VECT(VEU2, 0x560), INTC_VECT(LCDC, 0x580),
-};
-
-static struct intc_group groups[] __initdata = {
-	INTC_GROUP(DMAC0123, DMAC0, DMAC1, DMAC2, DMAC3),
-	INTC_GROUP(VIOVOU, VIO_CEUI, VIO_BEUI, VIO_VEUI, VOU),
-	INTC_GROUP(MMC, MMC_MMC1I, MMC_MMC2I, MMC_MMC3I),
-	INTC_GROUP(DMAC45, DMAC4, DMAC5, DMAC_DADERR),
-	INTC_GROUP(FLCTL, FLCTL_FLSTEI, FLCTL_FLENDI,
-		   FLCTL_FLTREQ0I, FLCTL_FLTREQ1I),
-	INTC_GROUP(I2C, I2C_ALI, I2C_TACKI, I2C_WAITI, I2C_DTEI),
-};
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xa4080080, 0xa40800c0, 8, /* IMR0 / IMCR0 */
-	  { } },
-	{ 0xa4080084, 0xa40800c4, 8, /* IMR1 / IMCR1 */
-	  { VOU, VIO_VEUI, VIO_BEUI, VIO_CEUI, DMAC3, DMAC2, DMAC1, DMAC0 } },
-	{ 0xa4080088, 0xa40800c8, 8, /* IMR2 / IMCR2 */
-	  { 0, 0, 0, VPU, 0, 0, 0, MFI } },
-	{ 0xa408008c, 0xa40800cc, 8, /* IMR3 / IMCR3 */
-	  { 0, 0, 0, ICB } },
-	{ 0xa4080090, 0xa40800d0, 8, /* IMR4 / IMCR4 */
-	  { 0, TMU2, TMU1, TMU0, VEU2, 0, 0, LCDC } },
-	{ 0xa4080094, 0xa40800d4, 8, /* IMR5 / IMCR5 */
-	  { 0, DMAC_DADERR, DMAC5, DMAC4, DENC, SCIFA2, SCIFA1, SCIF } },
-	{ 0xa4080098, 0xa40800d8, 8, /* IMR6 / IMCR6 */
-	  { 0, 0, 0, 0, 0, 0, 0, MSIOF } },
-	{ 0xa408009c, 0xa40800dc, 8, /* IMR7 / IMCR7 */
-	  { I2C_DTEI, I2C_WAITI, I2C_TACKI, I2C_ALI,
-	    FLCTL_FLTREQ1I, FLCTL_FLTREQ0I, FLCTL_FLENDI, FLCTL_FLSTEI } },
-	{ 0xa40800a0, 0xa40800e0, 8, /* IMR8 / IMCR8 */
-	  { DISABLED, ENABLED, ENABLED, ENABLED, 0, 0, 0, SIU } },
-	{ 0xa40800a4, 0xa40800e4, 8, /* IMR9 / IMCR9 */
-	  { 0, 0, 0, CMT, 0, USB, } },
-	{ 0xa40800a8, 0xa40800e8, 8, /* IMR10 / IMCR10 */
-	  { 0, MMC_MMC3I, MMC_MMC2I, MMC_MMC1I } },
-	{ 0xa40800ac, 0xa40800ec, 8, /* IMR11 / IMCR11 */
-	  { 0, 0, 0, 0, 0, 0, 0, TSIF } },
-	{ 0xa4140044, 0xa4140064, 8, /* INTMSK00 / INTMSKCLR00 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xa4080000, 0, 16, 4, /* IPRA */ { TMU0, TMU1, TMU2 } },
-	{ 0xa4080004, 0, 16, 4, /* IPRB */ { VEU2, LCDC, ICB } },
-	{ 0xa4080008, 0, 16, 4, /* IPRC */ { } },
-	{ 0xa408000c, 0, 16, 4, /* IPRD */ { } },
-	{ 0xa4080010, 0, 16, 4, /* IPRE */ { DMAC0123, VIOVOU, MFI, VPU } },
-	{ 0xa4080014, 0, 16, 4, /* IPRF */ { 0, DMAC45, USB, CMT } },
-	{ 0xa4080018, 0, 16, 4, /* IPRG */ { SCIF, SCIFA1, SCIFA2, DENC } },
-	{ 0xa408001c, 0, 16, 4, /* IPRH */ { MSIOF, 0, FLCTL, I2C } },
-	{ 0xa4080020, 0, 16, 4, /* IPRI */ { 0, 0, TSIF, } },
-	{ 0xa4080024, 0, 16, 4, /* IPRJ */ { 0, 0, SIU } },
-	{ 0xa4080028, 0, 16, 4, /* IPRK */ { 0, MMC, 0, SDHI } },
-	{ 0xa408002c, 0, 16, 4, /* IPRL */ { } },
-	{ 0xa4140010, 0, 32, 4, /* INTPRI00 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_sense_reg sense_registers[] __initdata = {
-	{ 0xa414001c, 16, 2, /* ICR1 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_mask_reg ack_registers[] __initdata = {
-	{ 0xa4140024, 0, 8, /* INTREQ00 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_desc intc_desc __initdata = {
-	.name = "sh7366",
-	.force_enable = ENABLED,
-	.force_disable = DISABLED,
-	.hw = INTC_HW_DESC(vectors, groups, mask_registers,
-			   prio_registers, sense_registers, ack_registers),
-};
-
-void __init plat_irq_setup(void)
-{
-	register_intc_controller(&intc_desc);
-}
-
-void __init plat_mem_setup(void)
-{
-	/* TODO: Register Node 1 */
-}
diff --git a/arch/sh/kernel/cpu/sh4a/setup-sh7722.c b/arch/sh/kernel/cpu/sh4a/setup-sh7722.c
deleted file mode 100644
index 0c6757ef63f42c..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/setup-sh7722.c
+++ /dev/null
@@ -1,666 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7722 Setup
- *
- *  Copyright (C) 2006 - 2008  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/mm.h>
-#include <linux/platform_device.h>
-#include <linux/serial.h>
-#include <linux/serial_sci.h>
-#include <linux/sh_dma.h>
-#include <linux/sh_timer.h>
-#include <linux/sh_intc.h>
-#include <linux/uio_driver.h>
-#include <linux/usb/m66592.h>
-
-#include <asm/clock.h>
-#include <asm/mmzone.h>
-#include <asm/siu.h>
-#include <asm/platform_early.h>
-
-#include <cpu/dma-register.h>
-#include <cpu/sh7722.h>
-#include <cpu/serial.h>
-
-static const struct sh_dmae_slave_config sh7722_dmae_slaves[] = {
-	{
-		.slave_id	= SHDMA_SLAVE_SCIF0_TX,
-		.addr		= 0xffe0000c,
-		.chcr		= DM_FIX | SM_INC | RS_ERS | TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x21,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SCIF0_RX,
-		.addr		= 0xffe00014,
-		.chcr		= DM_INC | SM_FIX | RS_ERS | TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x22,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SCIF1_TX,
-		.addr		= 0xffe1000c,
-		.chcr		= DM_FIX | SM_INC | RS_ERS | TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x25,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SCIF1_RX,
-		.addr		= 0xffe10014,
-		.chcr		= DM_INC | SM_FIX | RS_ERS | TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x26,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SCIF2_TX,
-		.addr		= 0xffe2000c,
-		.chcr		= DM_FIX | SM_INC | RS_ERS | TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x29,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SCIF2_RX,
-		.addr		= 0xffe20014,
-		.chcr		= DM_INC | SM_FIX | RS_ERS | TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x2a,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SIUA_TX,
-		.addr		= 0xa454c098,
-		.chcr		= DM_FIX | SM_INC | RS_ERS | TS_INDEX2VAL(XMIT_SZ_32BIT),
-		.mid_rid	= 0xb1,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SIUA_RX,
-		.addr		= 0xa454c090,
-		.chcr		= DM_INC | SM_FIX | RS_ERS | TS_INDEX2VAL(XMIT_SZ_32BIT),
-		.mid_rid	= 0xb2,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SIUB_TX,
-		.addr		= 0xa454c09c,
-		.chcr		= DM_FIX | SM_INC | RS_ERS | TS_INDEX2VAL(XMIT_SZ_32BIT),
-		.mid_rid	= 0xb5,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SIUB_RX,
-		.addr		= 0xa454c094,
-		.chcr		= DM_INC | SM_FIX | RS_ERS | TS_INDEX2VAL(XMIT_SZ_32BIT),
-		.mid_rid	= 0xb6,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SDHI0_TX,
-		.addr		= 0x04ce0030,
-		.chcr		= DM_FIX | SM_INC | RS_ERS | TS_INDEX2VAL(XMIT_SZ_16BIT),
-		.mid_rid	= 0xc1,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SDHI0_RX,
-		.addr		= 0x04ce0030,
-		.chcr		= DM_INC | SM_FIX | RS_ERS | TS_INDEX2VAL(XMIT_SZ_16BIT),
-		.mid_rid	= 0xc2,
-	},
-};
-
-static const struct sh_dmae_channel sh7722_dmae_channels[] = {
-	{
-		.offset = 0,
-		.dmars = 0,
-		.dmars_bit = 0,
-	}, {
-		.offset = 0x10,
-		.dmars = 0,
-		.dmars_bit = 8,
-	}, {
-		.offset = 0x20,
-		.dmars = 4,
-		.dmars_bit = 0,
-	}, {
-		.offset = 0x30,
-		.dmars = 4,
-		.dmars_bit = 8,
-	}, {
-		.offset = 0x50,
-		.dmars = 8,
-		.dmars_bit = 0,
-	}, {
-		.offset = 0x60,
-		.dmars = 8,
-		.dmars_bit = 8,
-	}
-};
-
-static const unsigned int ts_shift[] = TS_SHIFT;
-
-static struct sh_dmae_pdata dma_platform_data = {
-	.slave		= sh7722_dmae_slaves,
-	.slave_num	= ARRAY_SIZE(sh7722_dmae_slaves),
-	.channel	= sh7722_dmae_channels,
-	.channel_num	= ARRAY_SIZE(sh7722_dmae_channels),
-	.ts_low_shift	= CHCR_TS_LOW_SHIFT,
-	.ts_low_mask	= CHCR_TS_LOW_MASK,
-	.ts_high_shift	= CHCR_TS_HIGH_SHIFT,
-	.ts_high_mask	= CHCR_TS_HIGH_MASK,
-	.ts_shift	= ts_shift,
-	.ts_shift_num	= ARRAY_SIZE(ts_shift),
-	.dmaor_init	= DMAOR_INIT,
-};
-
-static struct resource sh7722_dmae_resources[] = {
-	[0] = {
-		/* Channel registers and DMAOR */
-		.start	= 0xfe008020,
-		.end	= 0xfe00808f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* DMARSx */
-		.start	= 0xfe009000,
-		.end	= 0xfe00900b,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "error_irq",
-		.start	= evt2irq(0xbc0),
-		.end	= evt2irq(0xbc0),
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		/* IRQ for channels 0-3 */
-		.start	= evt2irq(0x800),
-		.end	= evt2irq(0x860),
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		/* IRQ for channels 4-5 */
-		.start	= evt2irq(0xb80),
-		.end	= evt2irq(0xba0),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-struct platform_device dma_device = {
-	.name		= "sh-dma-engine",
-	.id		= -1,
-	.resource	= sh7722_dmae_resources,
-	.num_resources	= ARRAY_SIZE(sh7722_dmae_resources),
-	.dev		= {
-		.platform_data	= &dma_platform_data,
-	},
-};
-
-/* Serial */
-static struct plat_sci_port scif0_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type           = PORT_SCIF,
-	.ops		= &sh7722_sci_port_ops,
-	.regtype	= SCIx_SH4_SCIF_NO_SCSPTR_REGTYPE,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xffe00000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xc00)),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct plat_sci_port scif1_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type           = PORT_SCIF,
-	.ops		= &sh7722_sci_port_ops,
-	.regtype	= SCIx_SH4_SCIF_NO_SCSPTR_REGTYPE,
-};
-
-static struct resource scif1_resources[] = {
-	DEFINE_RES_MEM(0xffe10000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xc20)),
-};
-
-static struct platform_device scif1_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif1_resources,
-	.num_resources	= ARRAY_SIZE(scif1_resources),
-	.dev		= {
-		.platform_data	= &scif1_platform_data,
-	},
-};
-
-static struct plat_sci_port scif2_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type           = PORT_SCIF,
-	.ops		= &sh7722_sci_port_ops,
-	.regtype	= SCIx_SH4_SCIF_NO_SCSPTR_REGTYPE,
-};
-
-static struct resource scif2_resources[] = {
-	DEFINE_RES_MEM(0xffe20000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xc40)),
-};
-
-static struct platform_device scif2_device = {
-	.name		= "sh-sci",
-	.id		= 2,
-	.resource	= scif2_resources,
-	.num_resources	= ARRAY_SIZE(scif2_resources),
-	.dev		= {
-		.platform_data	= &scif2_platform_data,
-	},
-};
-
-static struct resource rtc_resources[] = {
-	[0] = {
-		.start	= 0xa465fec0,
-		.end	= 0xa465fec0 + 0x58 - 1,
-		.flags	= IORESOURCE_IO,
-	},
-	[1] = {
-		/* Period IRQ */
-		.start	= evt2irq(0x7a0),
-		.flags	= IORESOURCE_IRQ,
-	},
-	[2] = {
-		/* Carry IRQ */
-		.start	= evt2irq(0x7c0),
-		.flags	= IORESOURCE_IRQ,
-	},
-	[3] = {
-		/* Alarm IRQ */
-		.start	= evt2irq(0x780),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device rtc_device = {
-	.name		= "sh-rtc",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(rtc_resources),
-	.resource	= rtc_resources,
-};
-
-static struct m66592_platdata usbf_platdata = {
-	.on_chip = 1,
-};
-
-static struct resource usbf_resources[] = {
-	[0] = {
-		.name	= "USBF",
-		.start	= 0x04480000,
-		.end	= 0x044800FF,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0xa20),
-		.end	= evt2irq(0xa20),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device usbf_device = {
-	.name		= "m66592_udc",
-	.id             = 0, /* "usbf0" clock */
-	.dev = {
-		.dma_mask		= NULL,
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &usbf_platdata,
-	},
-	.num_resources	= ARRAY_SIZE(usbf_resources),
-	.resource	= usbf_resources,
-};
-
-static struct resource iic_resources[] = {
-	[0] = {
-		.name	= "IIC",
-		.start  = 0x04470000,
-		.end    = 0x04470017,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0xe00),
-		.end    = evt2irq(0xe60),
-		.flags  = IORESOURCE_IRQ,
-       },
-};
-
-static struct platform_device iic_device = {
-	.name           = "i2c-sh_mobile",
-	.id             = 0, /* "i2c0" clock */
-	.num_resources  = ARRAY_SIZE(iic_resources),
-	.resource       = iic_resources,
-};
-
-static struct uio_info vpu_platform_data = {
-	.name = "VPU4",
-	.version = "0",
-	.irq = evt2irq(0x980),
-};
-
-static struct resource vpu_resources[] = {
-	[0] = {
-		.name	= "VPU",
-		.start	= 0xfe900000,
-		.end	= 0xfe9022eb,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* place holder for contiguous memory */
-	},
-};
-
-static struct platform_device vpu_device = {
-	.name		= "uio_pdrv_genirq",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &vpu_platform_data,
-	},
-	.resource	= vpu_resources,
-	.num_resources	= ARRAY_SIZE(vpu_resources),
-};
-
-static struct uio_info veu_platform_data = {
-	.name = "VEU",
-	.version = "0",
-	.irq = evt2irq(0x8c0),
-};
-
-static struct resource veu_resources[] = {
-	[0] = {
-		.name	= "VEU",
-		.start	= 0xfe920000,
-		.end	= 0xfe9200b7,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* place holder for contiguous memory */
-	},
-};
-
-static struct platform_device veu_device = {
-	.name		= "uio_pdrv_genirq",
-	.id		= 1,
-	.dev = {
-		.platform_data	= &veu_platform_data,
-	},
-	.resource	= veu_resources,
-	.num_resources	= ARRAY_SIZE(veu_resources),
-};
-
-static struct uio_info jpu_platform_data = {
-	.name = "JPU",
-	.version = "0",
-	.irq = evt2irq(0x560),
-};
-
-static struct resource jpu_resources[] = {
-	[0] = {
-		.name	= "JPU",
-		.start	= 0xfea00000,
-		.end	= 0xfea102d3,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* place holder for contiguous memory */
-	},
-};
-
-static struct platform_device jpu_device = {
-	.name		= "uio_pdrv_genirq",
-	.id		= 2,
-	.dev = {
-		.platform_data	= &jpu_platform_data,
-	},
-	.resource	= jpu_resources,
-	.num_resources	= ARRAY_SIZE(jpu_resources),
-};
-
-static struct sh_timer_config cmt_platform_data = {
-	.channels_mask = 0x20,
-};
-
-static struct resource cmt_resources[] = {
-	DEFINE_RES_MEM(0x044a0000, 0x70),
-	DEFINE_RES_IRQ(evt2irq(0xf00)),
-};
-
-static struct platform_device cmt_device = {
-	.name		= "sh-cmt-32",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &cmt_platform_data,
-	},
-	.resource	= cmt_resources,
-	.num_resources	= ARRAY_SIZE(cmt_resources),
-};
-
-static struct sh_timer_config tmu0_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu0_resources[] = {
-	DEFINE_RES_MEM(0xffd80000, 0x2c),
-	DEFINE_RES_IRQ(evt2irq(0x400)),
-	DEFINE_RES_IRQ(evt2irq(0x420)),
-	DEFINE_RES_IRQ(evt2irq(0x440)),
-};
-
-static struct platform_device tmu0_device = {
-	.name		= "sh-tmu",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &tmu0_platform_data,
-	},
-	.resource	= tmu0_resources,
-	.num_resources	= ARRAY_SIZE(tmu0_resources),
-};
-
-static struct siu_platform siu_platform_data = {
-	.dma_slave_tx_a	= SHDMA_SLAVE_SIUA_TX,
-	.dma_slave_rx_a	= SHDMA_SLAVE_SIUA_RX,
-	.dma_slave_tx_b	= SHDMA_SLAVE_SIUB_TX,
-	.dma_slave_rx_b	= SHDMA_SLAVE_SIUB_RX,
-};
-
-static struct resource siu_resources[] = {
-	[0] = {
-		.start	= 0xa4540000,
-		.end	= 0xa454c10f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0xf80),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device siu_device = {
-	.name		= "siu-pcm-audio",
-	.id		= -1,
-	.dev = {
-		.platform_data	= &siu_platform_data,
-	},
-	.resource	= siu_resources,
-	.num_resources	= ARRAY_SIZE(siu_resources),
-};
-
-static struct platform_device *sh7722_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&cmt_device,
-	&tmu0_device,
-	&rtc_device,
-	&usbf_device,
-	&iic_device,
-	&vpu_device,
-	&veu_device,
-	&jpu_device,
-	&siu_device,
-	&dma_device,
-};
-
-static int __init sh7722_devices_setup(void)
-{
-	platform_resource_setup_memory(&vpu_device, "vpu", 1 << 20);
-	platform_resource_setup_memory(&veu_device, "veu", 2 << 20);
-	platform_resource_setup_memory(&jpu_device, "jpu", 2 << 20);
-
-	return platform_add_devices(sh7722_devices,
-				    ARRAY_SIZE(sh7722_devices));
-}
-arch_initcall(sh7722_devices_setup);
-
-static struct platform_device *sh7722_early_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&cmt_device,
-	&tmu0_device,
-};
-
-void __init plat_early_device_setup(void)
-{
-	sh_early_platform_add_devices(sh7722_early_devices,
-				   ARRAY_SIZE(sh7722_early_devices));
-}
-
-enum {
-	UNUSED=0,
-	ENABLED,
-	DISABLED,
-
-	/* interrupt sources */
-	IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7,
-	HUDI,
-	SIM_ERI, SIM_RXI, SIM_TXI, SIM_TEI,
-	RTC_ATI, RTC_PRI, RTC_CUI,
-	DMAC0, DMAC1, DMAC2, DMAC3,
-	VIO_CEUI, VIO_BEUI, VIO_VEUI, VOU,
-	VPU, TPU,
-	USB_USBI0, USB_USBI1,
-	DMAC4, DMAC5, DMAC_DADERR,
-	KEYSC,
-	SCIF0, SCIF1, SCIF2, SIOF0, SIOF1, SIO,
-	FLCTL_FLSTEI, FLCTL_FLENDI, FLCTL_FLTREQ0I, FLCTL_FLTREQ1I,
-	I2C_ALI, I2C_TACKI, I2C_WAITI, I2C_DTEI,
-	CMT, TSIF, SIU, TWODG,
-	TMU0, TMU1, TMU2,
-	IRDA, JPU, LCDC,
-
-	/* interrupt groups */
-	SIM, RTC, DMAC0123, VIOVOU, USB, DMAC45, FLCTL, I2C, SDHI,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_VECT(IRQ0, 0x600), INTC_VECT(IRQ1, 0x620),
-	INTC_VECT(IRQ2, 0x640), INTC_VECT(IRQ3, 0x660),
-	INTC_VECT(IRQ4, 0x680), INTC_VECT(IRQ5, 0x6a0),
-	INTC_VECT(IRQ6, 0x6c0), INTC_VECT(IRQ7, 0x6e0),
-	INTC_VECT(SIM_ERI, 0x700), INTC_VECT(SIM_RXI, 0x720),
-	INTC_VECT(SIM_TXI, 0x740), INTC_VECT(SIM_TEI, 0x760),
-	INTC_VECT(RTC_ATI, 0x780), INTC_VECT(RTC_PRI, 0x7a0),
-	INTC_VECT(RTC_CUI, 0x7c0),
-	INTC_VECT(DMAC0, 0x800), INTC_VECT(DMAC1, 0x820),
-	INTC_VECT(DMAC2, 0x840), INTC_VECT(DMAC3, 0x860),
-	INTC_VECT(VIO_CEUI, 0x880), INTC_VECT(VIO_BEUI, 0x8a0),
-	INTC_VECT(VIO_VEUI, 0x8c0), INTC_VECT(VOU, 0x8e0),
-	INTC_VECT(VPU, 0x980), INTC_VECT(TPU, 0x9a0),
-	INTC_VECT(USB_USBI0, 0xa20), INTC_VECT(USB_USBI1, 0xa40),
-	INTC_VECT(DMAC4, 0xb80), INTC_VECT(DMAC5, 0xba0),
-	INTC_VECT(DMAC_DADERR, 0xbc0), INTC_VECT(KEYSC, 0xbe0),
-	INTC_VECT(SCIF0, 0xc00), INTC_VECT(SCIF1, 0xc20),
-	INTC_VECT(SCIF2, 0xc40), INTC_VECT(SIOF0, 0xc80),
-	INTC_VECT(SIOF1, 0xca0), INTC_VECT(SIO, 0xd00),
-	INTC_VECT(FLCTL_FLSTEI, 0xd80), INTC_VECT(FLCTL_FLENDI, 0xda0),
-	INTC_VECT(FLCTL_FLTREQ0I, 0xdc0), INTC_VECT(FLCTL_FLTREQ1I, 0xde0),
-	INTC_VECT(I2C_ALI, 0xe00), INTC_VECT(I2C_TACKI, 0xe20),
-	INTC_VECT(I2C_WAITI, 0xe40), INTC_VECT(I2C_DTEI, 0xe60),
-	INTC_VECT(SDHI, 0xe80), INTC_VECT(SDHI, 0xea0),
-	INTC_VECT(SDHI, 0xec0), INTC_VECT(SDHI, 0xee0),
-	INTC_VECT(CMT, 0xf00), INTC_VECT(TSIF, 0xf20),
-	INTC_VECT(SIU, 0xf80), INTC_VECT(TWODG, 0xfa0),
-	INTC_VECT(TMU0, 0x400), INTC_VECT(TMU1, 0x420),
-	INTC_VECT(TMU2, 0x440), INTC_VECT(IRDA, 0x480),
-	INTC_VECT(JPU, 0x560), INTC_VECT(LCDC, 0x580),
-};
-
-static struct intc_group groups[] __initdata = {
-	INTC_GROUP(SIM, SIM_ERI, SIM_RXI, SIM_TXI, SIM_TEI),
-	INTC_GROUP(RTC, RTC_ATI, RTC_PRI, RTC_CUI),
-	INTC_GROUP(DMAC0123, DMAC0, DMAC1, DMAC2, DMAC3),
-	INTC_GROUP(VIOVOU, VIO_CEUI, VIO_BEUI, VIO_VEUI, VOU),
-	INTC_GROUP(USB, USB_USBI0, USB_USBI1),
-	INTC_GROUP(DMAC45, DMAC4, DMAC5, DMAC_DADERR),
-	INTC_GROUP(FLCTL, FLCTL_FLSTEI, FLCTL_FLENDI,
-		   FLCTL_FLTREQ0I, FLCTL_FLTREQ1I),
-	INTC_GROUP(I2C, I2C_ALI, I2C_TACKI, I2C_WAITI, I2C_DTEI),
-};
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xa4080080, 0xa40800c0, 8, /* IMR0 / IMCR0 */
-	  { } },
-	{ 0xa4080084, 0xa40800c4, 8, /* IMR1 / IMCR1 */
-	  { VOU, VIO_VEUI, VIO_BEUI, VIO_CEUI, DMAC3, DMAC2, DMAC1, DMAC0 } },
-	{ 0xa4080088, 0xa40800c8, 8, /* IMR2 / IMCR2 */
-	  { 0, 0, 0, VPU, } },
-	{ 0xa408008c, 0xa40800cc, 8, /* IMR3 / IMCR3 */
-	  { SIM_TEI, SIM_TXI, SIM_RXI, SIM_ERI, 0, 0, 0, IRDA } },
-	{ 0xa4080090, 0xa40800d0, 8, /* IMR4 / IMCR4 */
-	  { 0, TMU2, TMU1, TMU0, JPU, 0, 0, LCDC } },
-	{ 0xa4080094, 0xa40800d4, 8, /* IMR5 / IMCR5 */
-	  { KEYSC, DMAC_DADERR, DMAC5, DMAC4, 0, SCIF2, SCIF1, SCIF0 } },
-	{ 0xa4080098, 0xa40800d8, 8, /* IMR6 / IMCR6 */
-	  { 0, 0, 0, SIO, 0, 0, SIOF1, SIOF0 } },
-	{ 0xa408009c, 0xa40800dc, 8, /* IMR7 / IMCR7 */
-	  { I2C_DTEI, I2C_WAITI, I2C_TACKI, I2C_ALI,
-	    FLCTL_FLTREQ1I, FLCTL_FLTREQ0I, FLCTL_FLENDI, FLCTL_FLSTEI } },
-	{ 0xa40800a0, 0xa40800e0, 8, /* IMR8 / IMCR8 */
-	  { DISABLED, ENABLED, ENABLED, ENABLED, 0, 0, TWODG, SIU } },
-	{ 0xa40800a4, 0xa40800e4, 8, /* IMR9 / IMCR9 */
-	  { 0, 0, 0, CMT, 0, USB_USBI1, USB_USBI0, } },
-	{ 0xa40800a8, 0xa40800e8, 8, /* IMR10 / IMCR10 */
-	  { } },
-	{ 0xa40800ac, 0xa40800ec, 8, /* IMR11 / IMCR11 */
-	  { 0, RTC_CUI, RTC_PRI, RTC_ATI, 0, TPU, 0, TSIF } },
-	{ 0xa4140044, 0xa4140064, 8, /* INTMSK00 / INTMSKCLR00 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xa4080000, 0, 16, 4, /* IPRA */ { TMU0, TMU1, TMU2, IRDA } },
-	{ 0xa4080004, 0, 16, 4, /* IPRB */ { JPU, LCDC, SIM } },
-	{ 0xa4080008, 0, 16, 4, /* IPRC */ { } },
-	{ 0xa408000c, 0, 16, 4, /* IPRD */ { } },
-	{ 0xa4080010, 0, 16, 4, /* IPRE */ { DMAC0123, VIOVOU, 0, VPU } },
-	{ 0xa4080014, 0, 16, 4, /* IPRF */ { KEYSC, DMAC45, USB, CMT } },
-	{ 0xa4080018, 0, 16, 4, /* IPRG */ { SCIF0, SCIF1, SCIF2 } },
-	{ 0xa408001c, 0, 16, 4, /* IPRH */ { SIOF0, SIOF1, FLCTL, I2C } },
-	{ 0xa4080020, 0, 16, 4, /* IPRI */ { SIO, 0, TSIF, RTC } },
-	{ 0xa4080024, 0, 16, 4, /* IPRJ */ { 0, 0, SIU } },
-	{ 0xa4080028, 0, 16, 4, /* IPRK */ { 0, 0, 0, SDHI } },
-	{ 0xa408002c, 0, 16, 4, /* IPRL */ { TWODG, 0, TPU } },
-	{ 0xa4140010, 0, 32, 4, /* INTPRI00 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_sense_reg sense_registers[] __initdata = {
-	{ 0xa414001c, 16, 2, /* ICR1 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_mask_reg ack_registers[] __initdata = {
-	{ 0xa4140024, 0, 8, /* INTREQ00 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_desc intc_desc __initdata = {
-	.name = "sh7722",
-	.force_enable = ENABLED,
-	.force_disable = DISABLED,
-	.hw = INTC_HW_DESC(vectors, groups, mask_registers,
-			   prio_registers, sense_registers, ack_registers),
-};
-
-void __init plat_irq_setup(void)
-{
-	register_intc_controller(&intc_desc);
-}
-
-void __init plat_mem_setup(void)
-{
-	/* Register the URAM space as Node 1 */
-	setup_bootmem_node(1, 0x055f0000, 0x05610000);
-}
diff --git a/arch/sh/kernel/cpu/sh4a/setup-sh7723.c b/arch/sh/kernel/cpu/sh4a/setup-sh7723.c
deleted file mode 100644
index 83ae1ad4a86e86..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/setup-sh7723.c
+++ /dev/null
@@ -1,644 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7723 Setup
- *
- *  Copyright (C) 2008  Paul Mundt
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/mm.h>
-#include <linux/serial_sci.h>
-#include <linux/uio_driver.h>
-#include <linux/usb/r8a66597.h>
-#include <linux/sh_timer.h>
-#include <linux/sh_intc.h>
-#include <linux/io.h>
-#include <asm/clock.h>
-#include <asm/mmzone.h>
-#include <asm/platform_early.h>
-#include <cpu/sh7723.h>
-
-/* Serial */
-static struct plat_sci_port scif0_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type           = PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_NO_SCSPTR_REGTYPE,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xffe00000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xc00)),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct plat_sci_port scif1_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type           = PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_NO_SCSPTR_REGTYPE,
-};
-
-static struct resource scif1_resources[] = {
-	DEFINE_RES_MEM(0xffe10000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xc20)),
-};
-
-static struct platform_device scif1_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif1_resources,
-	.num_resources	= ARRAY_SIZE(scif1_resources),
-	.dev		= {
-		.platform_data	= &scif1_platform_data,
-	},
-};
-
-static struct plat_sci_port scif2_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type           = PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_NO_SCSPTR_REGTYPE,
-};
-
-static struct resource scif2_resources[] = {
-	DEFINE_RES_MEM(0xffe20000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xc40)),
-};
-
-static struct platform_device scif2_device = {
-	.name		= "sh-sci",
-	.id		= 2,
-	.resource	= scif2_resources,
-	.num_resources	= ARRAY_SIZE(scif2_resources),
-	.dev		= {
-		.platform_data	= &scif2_platform_data,
-	},
-};
-
-static struct plat_sci_port scif3_platform_data = {
-	.sampling_rate	= 8,
-	.type           = PORT_SCIFA,
-};
-
-static struct resource scif3_resources[] = {
-	DEFINE_RES_MEM(0xa4e30000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x900)),
-};
-
-static struct platform_device scif3_device = {
-	.name		= "sh-sci",
-	.id		= 3,
-	.resource	= scif3_resources,
-	.num_resources	= ARRAY_SIZE(scif3_resources),
-	.dev		= {
-		.platform_data	= &scif3_platform_data,
-	},
-};
-
-static struct plat_sci_port scif4_platform_data = {
-	.sampling_rate	= 8,
-	.type           = PORT_SCIFA,
-};
-
-static struct resource scif4_resources[] = {
-	DEFINE_RES_MEM(0xa4e40000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xd00)),
-};
-
-static struct platform_device scif4_device = {
-	.name		= "sh-sci",
-	.id		= 4,
-	.resource	= scif4_resources,
-	.num_resources	= ARRAY_SIZE(scif4_resources),
-	.dev		= {
-		.platform_data	= &scif4_platform_data,
-	},
-};
-
-static struct plat_sci_port scif5_platform_data = {
-	.sampling_rate	= 8,
-	.type           = PORT_SCIFA,
-};
-
-static struct resource scif5_resources[] = {
-	DEFINE_RES_MEM(0xa4e50000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xfa0)),
-};
-
-static struct platform_device scif5_device = {
-	.name		= "sh-sci",
-	.id		= 5,
-	.resource	= scif5_resources,
-	.num_resources	= ARRAY_SIZE(scif5_resources),
-	.dev		= {
-		.platform_data	= &scif5_platform_data,
-	},
-};
-
-static struct uio_info vpu_platform_data = {
-	.name = "VPU5",
-	.version = "0",
-	.irq = evt2irq(0x980),
-};
-
-static struct resource vpu_resources[] = {
-	[0] = {
-		.name	= "VPU",
-		.start	= 0xfe900000,
-		.end	= 0xfe902807,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* place holder for contiguous memory */
-	},
-};
-
-static struct platform_device vpu_device = {
-	.name		= "uio_pdrv_genirq",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &vpu_platform_data,
-	},
-	.resource	= vpu_resources,
-	.num_resources	= ARRAY_SIZE(vpu_resources),
-};
-
-static struct uio_info veu0_platform_data = {
-	.name = "VEU2H",
-	.version = "0",
-	.irq = evt2irq(0x8c0),
-};
-
-static struct resource veu0_resources[] = {
-	[0] = {
-		.name	= "VEU2H0",
-		.start	= 0xfe920000,
-		.end	= 0xfe92027b,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* place holder for contiguous memory */
-	},
-};
-
-static struct platform_device veu0_device = {
-	.name		= "uio_pdrv_genirq",
-	.id		= 1,
-	.dev = {
-		.platform_data	= &veu0_platform_data,
-	},
-	.resource	= veu0_resources,
-	.num_resources	= ARRAY_SIZE(veu0_resources),
-};
-
-static struct uio_info veu1_platform_data = {
-	.name = "VEU2H",
-	.version = "0",
-	.irq = evt2irq(0x560),
-};
-
-static struct resource veu1_resources[] = {
-	[0] = {
-		.name	= "VEU2H1",
-		.start	= 0xfe924000,
-		.end	= 0xfe92427b,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* place holder for contiguous memory */
-	},
-};
-
-static struct platform_device veu1_device = {
-	.name		= "uio_pdrv_genirq",
-	.id		= 2,
-	.dev = {
-		.platform_data	= &veu1_platform_data,
-	},
-	.resource	= veu1_resources,
-	.num_resources	= ARRAY_SIZE(veu1_resources),
-};
-
-static struct sh_timer_config cmt_platform_data = {
-	.channels_mask = 0x20,
-};
-
-static struct resource cmt_resources[] = {
-	DEFINE_RES_MEM(0x044a0000, 0x70),
-	DEFINE_RES_IRQ(evt2irq(0xf00)),
-};
-
-static struct platform_device cmt_device = {
-	.name		= "sh-cmt-32",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &cmt_platform_data,
-	},
-	.resource	= cmt_resources,
-	.num_resources	= ARRAY_SIZE(cmt_resources),
-};
-
-static struct sh_timer_config tmu0_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu0_resources[] = {
-	DEFINE_RES_MEM(0xffd80000, 0x2c),
-	DEFINE_RES_IRQ(evt2irq(0x400)),
-	DEFINE_RES_IRQ(evt2irq(0x420)),
-	DEFINE_RES_IRQ(evt2irq(0x440)),
-};
-
-static struct platform_device tmu0_device = {
-	.name		= "sh-tmu",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &tmu0_platform_data,
-	},
-	.resource	= tmu0_resources,
-	.num_resources	= ARRAY_SIZE(tmu0_resources),
-};
-
-static struct sh_timer_config tmu1_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu1_resources[] = {
-	DEFINE_RES_MEM(0xffd90000, 0x2c),
-	DEFINE_RES_IRQ(evt2irq(0x920)),
-	DEFINE_RES_IRQ(evt2irq(0x940)),
-	DEFINE_RES_IRQ(evt2irq(0x960)),
-};
-
-static struct platform_device tmu1_device = {
-	.name		= "sh-tmu",
-	.id		= 1,
-	.dev = {
-		.platform_data	= &tmu1_platform_data,
-	},
-	.resource	= tmu1_resources,
-	.num_resources	= ARRAY_SIZE(tmu1_resources),
-};
-
-static struct resource rtc_resources[] = {
-	[0] = {
-		.start	= 0xa465fec0,
-		.end	= 0xa465fec0 + 0x58 - 1,
-		.flags	= IORESOURCE_IO,
-	},
-	[1] = {
-		/* Period IRQ */
-		.start	= evt2irq(0xaa0),
-		.flags	= IORESOURCE_IRQ,
-	},
-	[2] = {
-		/* Carry IRQ */
-		.start	= evt2irq(0xac0),
-		.flags	= IORESOURCE_IRQ,
-	},
-	[3] = {
-		/* Alarm IRQ */
-		.start	= evt2irq(0xa80),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device rtc_device = {
-	.name		= "sh-rtc",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(rtc_resources),
-	.resource	= rtc_resources,
-};
-
-static struct r8a66597_platdata r8a66597_data = {
-	.on_chip = 1,
-};
-
-static struct resource sh7723_usb_host_resources[] = {
-	[0] = {
-		.start	= 0xa4d80000,
-		.end	= 0xa4d800ff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0xa20),
-		.end	= evt2irq(0xa20),
-		.flags	= IORESOURCE_IRQ | IRQF_TRIGGER_LOW,
-	},
-};
-
-static struct platform_device sh7723_usb_host_device = {
-	.name		= "r8a66597_hcd",
-	.id		= 0,
-	.dev = {
-		.dma_mask		= NULL,         /*  not use dma */
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &r8a66597_data,
-	},
-	.num_resources	= ARRAY_SIZE(sh7723_usb_host_resources),
-	.resource	= sh7723_usb_host_resources,
-};
-
-static struct resource iic_resources[] = {
-	[0] = {
-		.name	= "IIC",
-		.start  = 0x04470000,
-		.end    = 0x04470017,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0xe00),
-		.end    = evt2irq(0xe60),
-		.flags  = IORESOURCE_IRQ,
-       },
-};
-
-static struct platform_device iic_device = {
-	.name           = "i2c-sh_mobile",
-	.id             = 0, /* "i2c0" clock */
-	.num_resources  = ARRAY_SIZE(iic_resources),
-	.resource       = iic_resources,
-};
-
-static struct platform_device *sh7723_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&scif4_device,
-	&scif5_device,
-	&cmt_device,
-	&tmu0_device,
-	&tmu1_device,
-	&rtc_device,
-	&iic_device,
-	&sh7723_usb_host_device,
-	&vpu_device,
-	&veu0_device,
-	&veu1_device,
-};
-
-static int __init sh7723_devices_setup(void)
-{
-	platform_resource_setup_memory(&vpu_device, "vpu", 2 << 20);
-	platform_resource_setup_memory(&veu0_device, "veu0", 2 << 20);
-	platform_resource_setup_memory(&veu1_device, "veu1", 2 << 20);
-
-	return platform_add_devices(sh7723_devices,
-				    ARRAY_SIZE(sh7723_devices));
-}
-arch_initcall(sh7723_devices_setup);
-
-static struct platform_device *sh7723_early_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&scif4_device,
-	&scif5_device,
-	&cmt_device,
-	&tmu0_device,
-	&tmu1_device,
-};
-
-void __init plat_early_device_setup(void)
-{
-	sh_early_platform_add_devices(sh7723_early_devices,
-				   ARRAY_SIZE(sh7723_early_devices));
-}
-
-#define RAMCR_CACHE_L2FC	0x0002
-#define RAMCR_CACHE_L2E		0x0001
-#define L2_CACHE_ENABLE		(RAMCR_CACHE_L2E|RAMCR_CACHE_L2FC)
-
-void l2_cache_init(void)
-{
-	/* Enable L2 cache */
-	__raw_writel(L2_CACHE_ENABLE, RAMCR);
-}
-
-enum {
-	UNUSED=0,
-	ENABLED,
-	DISABLED,
-
-	/* interrupt sources */
-	IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7,
-	HUDI,
-	DMAC1A_DEI0,DMAC1A_DEI1,DMAC1A_DEI2,DMAC1A_DEI3,
-	_2DG_TRI,_2DG_INI,_2DG_CEI,
-	DMAC0A_DEI0,DMAC0A_DEI1,DMAC0A_DEI2,DMAC0A_DEI3,
-	VIO_CEUI,VIO_BEUI,VIO_VEU2HI,VIO_VOUI,
-	SCIFA_SCIFA0,
-	VPU_VPUI,
-	TPU_TPUI,
-	ADC_ADI,
-	USB_USI0,
-	RTC_ATI,RTC_PRI,RTC_CUI,
-	DMAC1B_DEI4,DMAC1B_DEI5,DMAC1B_DADERR,
-	DMAC0B_DEI4,DMAC0B_DEI5,DMAC0B_DADERR,
-	KEYSC_KEYI,
-	SCIF_SCIF0,SCIF_SCIF1,SCIF_SCIF2,
-	MSIOF_MSIOFI0,MSIOF_MSIOFI1,
-	SCIFA_SCIFA1,
-	FLCTL_FLSTEI,FLCTL_FLTENDI,FLCTL_FLTREQ0I,FLCTL_FLTREQ1I,
-	I2C_ALI,I2C_TACKI,I2C_WAITI,I2C_DTEI,
-	CMT_CMTI,
-	TSIF_TSIFI,
-	SIU_SIUI,
-	SCIFA_SCIFA2,
-	TMU0_TUNI0, TMU0_TUNI1, TMU0_TUNI2,
-	IRDA_IRDAI,
-	ATAPI_ATAPII,
-	VEU2H1_VEU2HI,
-	LCDC_LCDCI,
-	TMU1_TUNI0,TMU1_TUNI1,TMU1_TUNI2,
-
-	/* interrupt groups */
-	DMAC1A, DMAC0A, VIO, DMAC0B, FLCTL, I2C, _2DG,
-	SDHI1, RTC, DMAC1B, SDHI0,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_VECT(IRQ0, 0x600), INTC_VECT(IRQ1, 0x620),
-	INTC_VECT(IRQ2, 0x640), INTC_VECT(IRQ3, 0x660),
-	INTC_VECT(IRQ4, 0x680), INTC_VECT(IRQ5, 0x6a0),
-	INTC_VECT(IRQ6, 0x6c0), INTC_VECT(IRQ7, 0x6e0),
-
-	INTC_VECT(DMAC1A_DEI0,0x700),
-	INTC_VECT(DMAC1A_DEI1,0x720),
-	INTC_VECT(DMAC1A_DEI2,0x740),
-	INTC_VECT(DMAC1A_DEI3,0x760),
-
-	INTC_VECT(_2DG_TRI, 0x780),
-	INTC_VECT(_2DG_INI, 0x7A0),
-	INTC_VECT(_2DG_CEI, 0x7C0),
-
-	INTC_VECT(DMAC0A_DEI0,0x800),
-	INTC_VECT(DMAC0A_DEI1,0x820),
-	INTC_VECT(DMAC0A_DEI2,0x840),
-	INTC_VECT(DMAC0A_DEI3,0x860),
-
-	INTC_VECT(VIO_CEUI,0x880),
-	INTC_VECT(VIO_BEUI,0x8A0),
-	INTC_VECT(VIO_VEU2HI,0x8C0),
-	INTC_VECT(VIO_VOUI,0x8E0),
-
-	INTC_VECT(SCIFA_SCIFA0,0x900),
-	INTC_VECT(VPU_VPUI,0x980),
-	INTC_VECT(TPU_TPUI,0x9A0),
-	INTC_VECT(ADC_ADI,0x9E0),
-	INTC_VECT(USB_USI0,0xA20),
-
-	INTC_VECT(RTC_ATI,0xA80),
-	INTC_VECT(RTC_PRI,0xAA0),
-	INTC_VECT(RTC_CUI,0xAC0),
-
-	INTC_VECT(DMAC1B_DEI4,0xB00),
-	INTC_VECT(DMAC1B_DEI5,0xB20),
-	INTC_VECT(DMAC1B_DADERR,0xB40),
-
-	INTC_VECT(DMAC0B_DEI4,0xB80),
-	INTC_VECT(DMAC0B_DEI5,0xBA0),
-	INTC_VECT(DMAC0B_DADERR,0xBC0),
-
-	INTC_VECT(KEYSC_KEYI,0xBE0),
-	INTC_VECT(SCIF_SCIF0,0xC00),
-	INTC_VECT(SCIF_SCIF1,0xC20),
-	INTC_VECT(SCIF_SCIF2,0xC40),
-	INTC_VECT(MSIOF_MSIOFI0,0xC80),
-	INTC_VECT(MSIOF_MSIOFI1,0xCA0),
-	INTC_VECT(SCIFA_SCIFA1,0xD00),
-
-	INTC_VECT(FLCTL_FLSTEI,0xD80),
-	INTC_VECT(FLCTL_FLTENDI,0xDA0),
-	INTC_VECT(FLCTL_FLTREQ0I,0xDC0),
-	INTC_VECT(FLCTL_FLTREQ1I,0xDE0),
-
-	INTC_VECT(I2C_ALI,0xE00),
-	INTC_VECT(I2C_TACKI,0xE20),
-	INTC_VECT(I2C_WAITI,0xE40),
-	INTC_VECT(I2C_DTEI,0xE60),
-
-	INTC_VECT(SDHI0, 0xE80),
-	INTC_VECT(SDHI0, 0xEA0),
-	INTC_VECT(SDHI0, 0xEC0),
-
-	INTC_VECT(CMT_CMTI,0xF00),
-	INTC_VECT(TSIF_TSIFI,0xF20),
-	INTC_VECT(SIU_SIUI,0xF80),
-	INTC_VECT(SCIFA_SCIFA2,0xFA0),
-
-	INTC_VECT(TMU0_TUNI0,0x400),
-	INTC_VECT(TMU0_TUNI1,0x420),
-	INTC_VECT(TMU0_TUNI2,0x440),
-
-	INTC_VECT(IRDA_IRDAI,0x480),
-	INTC_VECT(ATAPI_ATAPII,0x4A0),
-
-	INTC_VECT(SDHI1, 0x4E0),
-	INTC_VECT(SDHI1, 0x500),
-	INTC_VECT(SDHI1, 0x520),
-
-	INTC_VECT(VEU2H1_VEU2HI,0x560),
-	INTC_VECT(LCDC_LCDCI,0x580),
-
-	INTC_VECT(TMU1_TUNI0,0x920),
-	INTC_VECT(TMU1_TUNI1,0x940),
-	INTC_VECT(TMU1_TUNI2,0x960),
-
-};
-
-static struct intc_group groups[] __initdata = {
-	INTC_GROUP(DMAC1A,DMAC1A_DEI0,DMAC1A_DEI1,DMAC1A_DEI2,DMAC1A_DEI3),
-	INTC_GROUP(DMAC0A,DMAC0A_DEI0,DMAC0A_DEI1,DMAC0A_DEI2,DMAC0A_DEI3),
-	INTC_GROUP(VIO, VIO_CEUI,VIO_BEUI,VIO_VEU2HI,VIO_VOUI),
-	INTC_GROUP(DMAC0B, DMAC0B_DEI4,DMAC0B_DEI5,DMAC0B_DADERR),
-	INTC_GROUP(FLCTL,FLCTL_FLSTEI,FLCTL_FLTENDI,FLCTL_FLTREQ0I,FLCTL_FLTREQ1I),
-	INTC_GROUP(I2C,I2C_ALI,I2C_TACKI,I2C_WAITI,I2C_DTEI),
-	INTC_GROUP(_2DG, _2DG_TRI,_2DG_INI,_2DG_CEI),
-	INTC_GROUP(RTC, RTC_ATI,RTC_PRI,RTC_CUI),
-	INTC_GROUP(DMAC1B, DMAC1B_DEI4,DMAC1B_DEI5,DMAC1B_DADERR),
-};
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xa4080080, 0xa40800c0, 8, /* IMR0 / IMCR0 */
-	  { 0, TMU1_TUNI2, TMU1_TUNI1, TMU1_TUNI0,
-	    0, ENABLED, ENABLED, ENABLED } },
-	{ 0xa4080084, 0xa40800c4, 8, /* IMR1 / IMCR1 */
-	  { VIO_VOUI, VIO_VEU2HI,VIO_BEUI,VIO_CEUI,DMAC0A_DEI3,DMAC0A_DEI2,DMAC0A_DEI1,DMAC0A_DEI0 } },
-	{ 0xa4080088, 0xa40800c8, 8, /* IMR2 / IMCR2 */
-	  { 0, 0, 0, VPU_VPUI,0,0,0,SCIFA_SCIFA0 } },
-	{ 0xa408008c, 0xa40800cc, 8, /* IMR3 / IMCR3 */
-	  { DMAC1A_DEI3,DMAC1A_DEI2,DMAC1A_DEI1,DMAC1A_DEI0,0,0,0,IRDA_IRDAI } },
-	{ 0xa4080090, 0xa40800d0, 8, /* IMR4 / IMCR4 */
-	  { 0,TMU0_TUNI2,TMU0_TUNI1,TMU0_TUNI0,VEU2H1_VEU2HI,0,0,LCDC_LCDCI } },
-	{ 0xa4080094, 0xa40800d4, 8, /* IMR5 / IMCR5 */
-	  { KEYSC_KEYI,DMAC0B_DADERR,DMAC0B_DEI5,DMAC0B_DEI4,0,SCIF_SCIF2,SCIF_SCIF1,SCIF_SCIF0 } },
-	{ 0xa4080098, 0xa40800d8, 8, /* IMR6 / IMCR6 */
-	  { 0,0,0,SCIFA_SCIFA1,ADC_ADI,0,MSIOF_MSIOFI1,MSIOF_MSIOFI0 } },
-	{ 0xa408009c, 0xa40800dc, 8, /* IMR7 / IMCR7 */
-	  { I2C_DTEI, I2C_WAITI, I2C_TACKI, I2C_ALI,
-	    FLCTL_FLTREQ1I, FLCTL_FLTREQ0I, FLCTL_FLTENDI, FLCTL_FLSTEI } },
-	{ 0xa40800a0, 0xa40800e0, 8, /* IMR8 / IMCR8 */
-	  { 0, ENABLED, ENABLED, ENABLED,
-	    0, 0, SCIFA_SCIFA2, SIU_SIUI } },
-	{ 0xa40800a4, 0xa40800e4, 8, /* IMR9 / IMCR9 */
-	  { 0, 0, 0, CMT_CMTI, 0, 0, USB_USI0,0 } },
-	{ 0xa40800a8, 0xa40800e8, 8, /* IMR10 / IMCR10 */
-	  { 0, DMAC1B_DADERR,DMAC1B_DEI5,DMAC1B_DEI4,0,RTC_ATI,RTC_PRI,RTC_CUI } },
-	{ 0xa40800ac, 0xa40800ec, 8, /* IMR11 / IMCR11 */
-	  { 0,_2DG_CEI,_2DG_INI,_2DG_TRI,0,TPU_TPUI,0,TSIF_TSIFI } },
-	{ 0xa40800b0, 0xa40800f0, 8, /* IMR12 / IMCR12 */
-	  { 0,0,0,0,0,0,0,ATAPI_ATAPII } },
-	{ 0xa4140044, 0xa4140064, 8, /* INTMSK00 / INTMSKCLR00 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xa4080000, 0, 16, 4, /* IPRA */ { TMU0_TUNI0, TMU0_TUNI1, TMU0_TUNI2, IRDA_IRDAI } },
-	{ 0xa4080004, 0, 16, 4, /* IPRB */ { VEU2H1_VEU2HI, LCDC_LCDCI, DMAC1A, 0} },
-	{ 0xa4080008, 0, 16, 4, /* IPRC */ { TMU1_TUNI0, TMU1_TUNI1, TMU1_TUNI2, 0} },
-	{ 0xa408000c, 0, 16, 4, /* IPRD */ { } },
-	{ 0xa4080010, 0, 16, 4, /* IPRE */ { DMAC0A, VIO, SCIFA_SCIFA0, VPU_VPUI } },
-	{ 0xa4080014, 0, 16, 4, /* IPRF */ { KEYSC_KEYI, DMAC0B, USB_USI0, CMT_CMTI } },
-	{ 0xa4080018, 0, 16, 4, /* IPRG */ { SCIF_SCIF0, SCIF_SCIF1, SCIF_SCIF2,0 } },
-	{ 0xa408001c, 0, 16, 4, /* IPRH */ { MSIOF_MSIOFI0,MSIOF_MSIOFI1, FLCTL, I2C } },
-	{ 0xa4080020, 0, 16, 4, /* IPRI */ { SCIFA_SCIFA1,0,TSIF_TSIFI,_2DG } },
-	{ 0xa4080024, 0, 16, 4, /* IPRJ */ { ADC_ADI,0,SIU_SIUI,SDHI1 } },
-	{ 0xa4080028, 0, 16, 4, /* IPRK */ { RTC,DMAC1B,0,SDHI0 } },
-	{ 0xa408002c, 0, 16, 4, /* IPRL */ { SCIFA_SCIFA2,0,TPU_TPUI,ATAPI_ATAPII } },
-	{ 0xa4140010, 0, 32, 4, /* INTPRI00 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_sense_reg sense_registers[] __initdata = {
-	{ 0xa414001c, 16, 2, /* ICR1 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_mask_reg ack_registers[] __initdata = {
-	{ 0xa4140024, 0, 8, /* INTREQ00 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_desc intc_desc __initdata = {
-	.name = "sh7723",
-	.force_enable = ENABLED,
-	.force_disable = DISABLED,
-	.hw = INTC_HW_DESC(vectors, groups, mask_registers,
-			   prio_registers, sense_registers, ack_registers),
-};
-
-void __init plat_irq_setup(void)
-{
-	register_intc_controller(&intc_desc);
-}
diff --git a/arch/sh/kernel/cpu/sh4a/setup-sh7724.c b/arch/sh/kernel/cpu/sh4a/setup-sh7724.c
deleted file mode 100644
index 0d990ab1ba2a9e..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/setup-sh7724.c
+++ /dev/null
@@ -1,1288 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7724 Setup
- *
- * Copyright (C) 2009 Renesas Solutions Corp.
- *
- * Kuninori Morimoto <morimoto.kuninori@renesas.com>
- *
- * Based on SH7723 Setup
- * Copyright (C) 2008  Paul Mundt
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/mm.h>
-#include <linux/serial_sci.h>
-#include <linux/uio_driver.h>
-#include <linux/sh_dma.h>
-#include <linux/sh_timer.h>
-#include <linux/sh_intc.h>
-#include <linux/io.h>
-#include <linux/notifier.h>
-
-#include <asm/suspend.h>
-#include <asm/clock.h>
-#include <asm/mmzone.h>
-#include <asm/platform_early.h>
-
-#include <cpu/dma-register.h>
-#include <cpu/sh7724.h>
-
-/* DMA */
-static const struct sh_dmae_slave_config sh7724_dmae_slaves[] = {
-	{
-		.slave_id	= SHDMA_SLAVE_SCIF0_TX,
-		.addr		= 0xffe0000c,
-		.chcr		= DM_FIX | SM_INC | RS_ERS | TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x21,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SCIF0_RX,
-		.addr		= 0xffe00014,
-		.chcr		= DM_INC | SM_FIX | RS_ERS | TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x22,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SCIF1_TX,
-		.addr		= 0xffe1000c,
-		.chcr		= DM_FIX | SM_INC | RS_ERS | TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x25,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SCIF1_RX,
-		.addr		= 0xffe10014,
-		.chcr		= DM_INC | SM_FIX | RS_ERS | TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x26,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SCIF2_TX,
-		.addr		= 0xffe2000c,
-		.chcr		= DM_FIX | SM_INC | RS_ERS | TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x29,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SCIF2_RX,
-		.addr		= 0xffe20014,
-		.chcr		= DM_INC | SM_FIX | RS_ERS | TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x2a,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SCIF3_TX,
-		.addr		= 0xa4e30020,
-		.chcr		= DM_FIX | SM_INC | RS_ERS | TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x2d,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SCIF3_RX,
-		.addr		= 0xa4e30024,
-		.chcr		= DM_INC | SM_FIX | RS_ERS | TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x2e,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SCIF4_TX,
-		.addr		= 0xa4e40020,
-		.chcr		= DM_FIX | SM_INC | RS_ERS | TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x31,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SCIF4_RX,
-		.addr		= 0xa4e40024,
-		.chcr		= DM_INC | SM_FIX | RS_ERS | TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x32,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SCIF5_TX,
-		.addr		= 0xa4e50020,
-		.chcr		= DM_FIX | SM_INC | RS_ERS | TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x35,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SCIF5_RX,
-		.addr		= 0xa4e50024,
-		.chcr		= DM_INC | SM_FIX | RS_ERS | TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x36,
-	}, {
-		.slave_id	= SHDMA_SLAVE_USB0D0_TX,
-		.addr		= 0xA4D80100,
-		.chcr		= DM_FIX | SM_INC | RS_ERS | TS_INDEX2VAL(XMIT_SZ_32BIT),
-		.mid_rid	= 0x73,
-	}, {
-		.slave_id	= SHDMA_SLAVE_USB0D0_RX,
-		.addr		= 0xA4D80100,
-		.chcr		= DM_INC | SM_FIX | RS_ERS | TS_INDEX2VAL(XMIT_SZ_32BIT),
-		.mid_rid	= 0x73,
-	}, {
-		.slave_id	= SHDMA_SLAVE_USB0D1_TX,
-		.addr		= 0xA4D80120,
-		.chcr		= DM_FIX | SM_INC | RS_ERS | TS_INDEX2VAL(XMIT_SZ_32BIT),
-		.mid_rid	= 0x77,
-	}, {
-		.slave_id	= SHDMA_SLAVE_USB0D1_RX,
-		.addr		= 0xA4D80120,
-		.chcr		= DM_INC | SM_FIX | RS_ERS | TS_INDEX2VAL(XMIT_SZ_32BIT),
-		.mid_rid	= 0x77,
-	}, {
-		.slave_id	= SHDMA_SLAVE_USB1D0_TX,
-		.addr		= 0xA4D90100,
-		.chcr		= DM_FIX | SM_INC | RS_ERS | TS_INDEX2VAL(XMIT_SZ_32BIT),
-		.mid_rid	= 0xab,
-	}, {
-		.slave_id	= SHDMA_SLAVE_USB1D0_RX,
-		.addr		= 0xA4D90100,
-		.chcr		= DM_INC | SM_FIX | RS_ERS | TS_INDEX2VAL(XMIT_SZ_32BIT),
-		.mid_rid	= 0xab,
-	}, {
-		.slave_id	= SHDMA_SLAVE_USB1D1_TX,
-		.addr		= 0xA4D90120,
-		.chcr		= DM_FIX | SM_INC | RS_ERS | TS_INDEX2VAL(XMIT_SZ_32BIT),
-		.mid_rid	= 0xaf,
-	}, {
-		.slave_id	= SHDMA_SLAVE_USB1D1_RX,
-		.addr		= 0xA4D90120,
-		.chcr		= DM_INC | SM_FIX | RS_ERS | TS_INDEX2VAL(XMIT_SZ_32BIT),
-		.mid_rid	= 0xaf,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SDHI0_TX,
-		.addr		= 0x04ce0030,
-		.chcr		= DM_FIX | SM_INC | RS_ERS | TS_INDEX2VAL(XMIT_SZ_16BIT),
-		.mid_rid	= 0xc1,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SDHI0_RX,
-		.addr		= 0x04ce0030,
-		.chcr		= DM_INC | SM_FIX | RS_ERS | TS_INDEX2VAL(XMIT_SZ_16BIT),
-		.mid_rid	= 0xc2,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SDHI1_TX,
-		.addr		= 0x04cf0030,
-		.chcr		= DM_FIX | SM_INC | RS_ERS | TS_INDEX2VAL(XMIT_SZ_16BIT),
-		.mid_rid	= 0xc9,
-	}, {
-		.slave_id	= SHDMA_SLAVE_SDHI1_RX,
-		.addr		= 0x04cf0030,
-		.chcr		= DM_INC | SM_FIX | RS_ERS | TS_INDEX2VAL(XMIT_SZ_16BIT),
-		.mid_rid	= 0xca,
-	},
-};
-
-static const struct sh_dmae_channel sh7724_dmae_channels[] = {
-	{
-		.offset = 0,
-		.dmars = 0,
-		.dmars_bit = 0,
-	}, {
-		.offset = 0x10,
-		.dmars = 0,
-		.dmars_bit = 8,
-	}, {
-		.offset = 0x20,
-		.dmars = 4,
-		.dmars_bit = 0,
-	}, {
-		.offset = 0x30,
-		.dmars = 4,
-		.dmars_bit = 8,
-	}, {
-		.offset = 0x50,
-		.dmars = 8,
-		.dmars_bit = 0,
-	}, {
-		.offset = 0x60,
-		.dmars = 8,
-		.dmars_bit = 8,
-	}
-};
-
-static const unsigned int ts_shift[] = TS_SHIFT;
-
-static struct sh_dmae_pdata dma_platform_data = {
-	.slave		= sh7724_dmae_slaves,
-	.slave_num	= ARRAY_SIZE(sh7724_dmae_slaves),
-	.channel	= sh7724_dmae_channels,
-	.channel_num	= ARRAY_SIZE(sh7724_dmae_channels),
-	.ts_low_shift	= CHCR_TS_LOW_SHIFT,
-	.ts_low_mask	= CHCR_TS_LOW_MASK,
-	.ts_high_shift	= CHCR_TS_HIGH_SHIFT,
-	.ts_high_mask	= CHCR_TS_HIGH_MASK,
-	.ts_shift	= ts_shift,
-	.ts_shift_num	= ARRAY_SIZE(ts_shift),
-	.dmaor_init	= DMAOR_INIT,
-};
-
-/* Resource order important! */
-static struct resource sh7724_dmae0_resources[] = {
-	{
-		/* Channel registers and DMAOR */
-		.start	= 0xfe008020,
-		.end	= 0xfe00808f,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		/* DMARSx */
-		.start	= 0xfe009000,
-		.end	= 0xfe00900b,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "error_irq",
-		.start	= evt2irq(0xbc0),
-		.end	= evt2irq(0xbc0),
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		/* IRQ for channels 0-3 */
-		.start	= evt2irq(0x800),
-		.end	= evt2irq(0x860),
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		/* IRQ for channels 4-5 */
-		.start	= evt2irq(0xb80),
-		.end	= evt2irq(0xba0),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-/* Resource order important! */
-static struct resource sh7724_dmae1_resources[] = {
-	{
-		/* Channel registers and DMAOR */
-		.start	= 0xfdc08020,
-		.end	= 0xfdc0808f,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		/* DMARSx */
-		.start	= 0xfdc09000,
-		.end	= 0xfdc0900b,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "error_irq",
-		.start	= evt2irq(0xb40),
-		.end	= evt2irq(0xb40),
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		/* IRQ for channels 0-3 */
-		.start	= evt2irq(0x700),
-		.end	= evt2irq(0x760),
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		/* IRQ for channels 4-5 */
-		.start	= evt2irq(0xb00),
-		.end	= evt2irq(0xb20),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device dma0_device = {
-	.name		= "sh-dma-engine",
-	.id		= 0,
-	.resource	= sh7724_dmae0_resources,
-	.num_resources	= ARRAY_SIZE(sh7724_dmae0_resources),
-	.dev		= {
-		.platform_data	= &dma_platform_data,
-	},
-};
-
-static struct platform_device dma1_device = {
-	.name		= "sh-dma-engine",
-	.id		= 1,
-	.resource	= sh7724_dmae1_resources,
-	.num_resources	= ARRAY_SIZE(sh7724_dmae1_resources),
-	.dev		= {
-		.platform_data	= &dma_platform_data,
-	},
-};
-
-/* Serial */
-static struct plat_sci_port scif0_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type           = PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_NO_SCSPTR_REGTYPE,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xffe00000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xc00)),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct plat_sci_port scif1_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type           = PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_NO_SCSPTR_REGTYPE,
-};
-
-static struct resource scif1_resources[] = {
-	DEFINE_RES_MEM(0xffe10000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xc20)),
-};
-
-static struct platform_device scif1_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif1_resources,
-	.num_resources	= ARRAY_SIZE(scif1_resources),
-	.dev		= {
-		.platform_data	= &scif1_platform_data,
-	},
-};
-
-static struct plat_sci_port scif2_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type           = PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_NO_SCSPTR_REGTYPE,
-};
-
-static struct resource scif2_resources[] = {
-	DEFINE_RES_MEM(0xffe20000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xc40)),
-};
-
-static struct platform_device scif2_device = {
-	.name		= "sh-sci",
-	.id		= 2,
-	.resource	= scif2_resources,
-	.num_resources	= ARRAY_SIZE(scif2_resources),
-	.dev		= {
-		.platform_data	= &scif2_platform_data,
-	},
-};
-
-static struct plat_sci_port scif3_platform_data = {
-	.sampling_rate	= 8,
-	.type           = PORT_SCIFA,
-};
-
-static struct resource scif3_resources[] = {
-	DEFINE_RES_MEM(0xa4e30000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x900)),
-};
-
-static struct platform_device scif3_device = {
-	.name		= "sh-sci",
-	.id		= 3,
-	.resource	= scif3_resources,
-	.num_resources	= ARRAY_SIZE(scif3_resources),
-	.dev		= {
-		.platform_data	= &scif3_platform_data,
-	},
-};
-
-static struct plat_sci_port scif4_platform_data = {
-	.sampling_rate	= 8,
-	.type           = PORT_SCIFA,
-};
-
-static struct resource scif4_resources[] = {
-	DEFINE_RES_MEM(0xa4e40000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xd00)),
-};
-
-static struct platform_device scif4_device = {
-	.name		= "sh-sci",
-	.id		= 4,
-	.resource	= scif4_resources,
-	.num_resources	= ARRAY_SIZE(scif4_resources),
-	.dev		= {
-		.platform_data	= &scif4_platform_data,
-	},
-};
-
-static struct plat_sci_port scif5_platform_data = {
-	.sampling_rate	= 8,
-	.type           = PORT_SCIFA,
-};
-
-static struct resource scif5_resources[] = {
-	DEFINE_RES_MEM(0xa4e50000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xfa0)),
-};
-
-static struct platform_device scif5_device = {
-	.name		= "sh-sci",
-	.id		= 5,
-	.resource	= scif5_resources,
-	.num_resources	= ARRAY_SIZE(scif5_resources),
-	.dev		= {
-		.platform_data	= &scif5_platform_data,
-	},
-};
-
-/* RTC */
-static struct resource rtc_resources[] = {
-	[0] = {
-		.start	= 0xa465fec0,
-		.end	= 0xa465fec0 + 0x58 - 1,
-		.flags	= IORESOURCE_IO,
-	},
-	[1] = {
-		/* Period IRQ */
-		.start	= evt2irq(0xaa0),
-		.flags	= IORESOURCE_IRQ,
-	},
-	[2] = {
-		/* Carry IRQ */
-		.start	= evt2irq(0xac0),
-		.flags	= IORESOURCE_IRQ,
-	},
-	[3] = {
-		/* Alarm IRQ */
-		.start	= evt2irq(0xa80),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device rtc_device = {
-	.name		= "sh-rtc",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(rtc_resources),
-	.resource	= rtc_resources,
-};
-
-/* I2C0 */
-static struct resource iic0_resources[] = {
-	[0] = {
-		.name	= "IIC0",
-		.start  = 0x04470000,
-		.end    = 0x04470018 - 1,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0xe00),
-		.end    = evt2irq(0xe60),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device iic0_device = {
-	.name           = "i2c-sh_mobile",
-	.id             = 0, /* "i2c0" clock */
-	.num_resources  = ARRAY_SIZE(iic0_resources),
-	.resource       = iic0_resources,
-};
-
-/* I2C1 */
-static struct resource iic1_resources[] = {
-	[0] = {
-		.name	= "IIC1",
-		.start  = 0x04750000,
-		.end    = 0x04750018 - 1,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0xd80),
-		.end    = evt2irq(0xde0),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device iic1_device = {
-	.name           = "i2c-sh_mobile",
-	.id             = 1, /* "i2c1" clock */
-	.num_resources  = ARRAY_SIZE(iic1_resources),
-	.resource       = iic1_resources,
-};
-
-/* VPU */
-static struct uio_info vpu_platform_data = {
-	.name = "VPU5F",
-	.version = "0",
-	.irq = evt2irq(0x980),
-};
-
-static struct resource vpu_resources[] = {
-	[0] = {
-		.name	= "VPU",
-		.start	= 0xfe900000,
-		.end	= 0xfe902807,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* place holder for contiguous memory */
-	},
-};
-
-static struct platform_device vpu_device = {
-	.name		= "uio_pdrv_genirq",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &vpu_platform_data,
-	},
-	.resource	= vpu_resources,
-	.num_resources	= ARRAY_SIZE(vpu_resources),
-};
-
-/* VEU0 */
-static struct uio_info veu0_platform_data = {
-	.name = "VEU3F0",
-	.version = "0",
-	.irq = evt2irq(0xc60),
-};
-
-static struct resource veu0_resources[] = {
-	[0] = {
-		.name	= "VEU3F0",
-		.start	= 0xfe920000,
-		.end	= 0xfe9200cb,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* place holder for contiguous memory */
-	},
-};
-
-static struct platform_device veu0_device = {
-	.name		= "uio_pdrv_genirq",
-	.id		= 1,
-	.dev = {
-		.platform_data	= &veu0_platform_data,
-	},
-	.resource	= veu0_resources,
-	.num_resources	= ARRAY_SIZE(veu0_resources),
-};
-
-/* VEU1 */
-static struct uio_info veu1_platform_data = {
-	.name = "VEU3F1",
-	.version = "0",
-	.irq = evt2irq(0x8c0),
-};
-
-static struct resource veu1_resources[] = {
-	[0] = {
-		.name	= "VEU3F1",
-		.start	= 0xfe924000,
-		.end	= 0xfe9240cb,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* place holder for contiguous memory */
-	},
-};
-
-static struct platform_device veu1_device = {
-	.name		= "uio_pdrv_genirq",
-	.id		= 2,
-	.dev = {
-		.platform_data	= &veu1_platform_data,
-	},
-	.resource	= veu1_resources,
-	.num_resources	= ARRAY_SIZE(veu1_resources),
-};
-
-/* BEU0 */
-static struct uio_info beu0_platform_data = {
-	.name = "BEU0",
-	.version = "0",
-	.irq = evt2irq(0x8A0),
-};
-
-static struct resource beu0_resources[] = {
-	[0] = {
-		.name	= "BEU0",
-		.start	= 0xfe930000,
-		.end	= 0xfe933400,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* place holder for contiguous memory */
-	},
-};
-
-static struct platform_device beu0_device = {
-	.name		= "uio_pdrv_genirq",
-	.id		= 6,
-	.dev = {
-		.platform_data	= &beu0_platform_data,
-	},
-	.resource	= beu0_resources,
-	.num_resources	= ARRAY_SIZE(beu0_resources),
-};
-
-/* BEU1 */
-static struct uio_info beu1_platform_data = {
-	.name = "BEU1",
-	.version = "0",
-	.irq = evt2irq(0xA00),
-};
-
-static struct resource beu1_resources[] = {
-	[0] = {
-		.name	= "BEU1",
-		.start	= 0xfe940000,
-		.end	= 0xfe943400,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* place holder for contiguous memory */
-	},
-};
-
-static struct platform_device beu1_device = {
-	.name		= "uio_pdrv_genirq",
-	.id		= 7,
-	.dev = {
-		.platform_data	= &beu1_platform_data,
-	},
-	.resource	= beu1_resources,
-	.num_resources	= ARRAY_SIZE(beu1_resources),
-};
-
-static struct sh_timer_config cmt_platform_data = {
-	.channels_mask = 0x20,
-};
-
-static struct resource cmt_resources[] = {
-	DEFINE_RES_MEM(0x044a0000, 0x70),
-	DEFINE_RES_IRQ(evt2irq(0xf00)),
-};
-
-static struct platform_device cmt_device = {
-	.name		= "sh-cmt-32",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &cmt_platform_data,
-	},
-	.resource	= cmt_resources,
-	.num_resources	= ARRAY_SIZE(cmt_resources),
-};
-
-static struct sh_timer_config tmu0_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu0_resources[] = {
-	DEFINE_RES_MEM(0xffd80000, 0x2c),
-	DEFINE_RES_IRQ(evt2irq(0x400)),
-	DEFINE_RES_IRQ(evt2irq(0x420)),
-	DEFINE_RES_IRQ(evt2irq(0x440)),
-};
-
-static struct platform_device tmu0_device = {
-	.name		= "sh-tmu",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &tmu0_platform_data,
-	},
-	.resource	= tmu0_resources,
-	.num_resources	= ARRAY_SIZE(tmu0_resources),
-};
-
-static struct sh_timer_config tmu1_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu1_resources[] = {
-	DEFINE_RES_MEM(0xffd90000, 0x2c),
-	DEFINE_RES_IRQ(evt2irq(0x920)),
-	DEFINE_RES_IRQ(evt2irq(0x940)),
-	DEFINE_RES_IRQ(evt2irq(0x960)),
-};
-
-static struct platform_device tmu1_device = {
-	.name		= "sh-tmu",
-	.id		= 1,
-	.dev = {
-		.platform_data	= &tmu1_platform_data,
-	},
-	.resource	= tmu1_resources,
-	.num_resources	= ARRAY_SIZE(tmu1_resources),
-};
-
-/* JPU */
-static struct uio_info jpu_platform_data = {
-	.name = "JPU",
-	.version = "0",
-	.irq = evt2irq(0x560),
-};
-
-static struct resource jpu_resources[] = {
-	[0] = {
-		.name	= "JPU",
-		.start	= 0xfe980000,
-		.end	= 0xfe9902d3,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* place holder for contiguous memory */
-	},
-};
-
-static struct platform_device jpu_device = {
-	.name		= "uio_pdrv_genirq",
-	.id		= 3,
-	.dev = {
-		.platform_data	= &jpu_platform_data,
-	},
-	.resource	= jpu_resources,
-	.num_resources	= ARRAY_SIZE(jpu_resources),
-};
-
-/* SPU2DSP0 */
-static struct uio_info spu0_platform_data = {
-	.name = "SPU2DSP0",
-	.version = "0",
-	.irq = evt2irq(0xcc0),
-};
-
-static struct resource spu0_resources[] = {
-	[0] = {
-		.name	= "SPU2DSP0",
-		.start	= 0xFE200000,
-		.end	= 0xFE2FFFFF,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* place holder for contiguous memory */
-	},
-};
-
-static struct platform_device spu0_device = {
-	.name		= "uio_pdrv_genirq",
-	.id		= 4,
-	.dev = {
-		.platform_data	= &spu0_platform_data,
-	},
-	.resource	= spu0_resources,
-	.num_resources	= ARRAY_SIZE(spu0_resources),
-};
-
-/* SPU2DSP1 */
-static struct uio_info spu1_platform_data = {
-	.name = "SPU2DSP1",
-	.version = "0",
-	.irq = evt2irq(0xce0),
-};
-
-static struct resource spu1_resources[] = {
-	[0] = {
-		.name	= "SPU2DSP1",
-		.start	= 0xFE300000,
-		.end	= 0xFE3FFFFF,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* place holder for contiguous memory */
-	},
-};
-
-static struct platform_device spu1_device = {
-	.name		= "uio_pdrv_genirq",
-	.id		= 5,
-	.dev = {
-		.platform_data	= &spu1_platform_data,
-	},
-	.resource	= spu1_resources,
-	.num_resources	= ARRAY_SIZE(spu1_resources),
-};
-
-static struct platform_device *sh7724_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&scif4_device,
-	&scif5_device,
-	&cmt_device,
-	&tmu0_device,
-	&tmu1_device,
-	&dma0_device,
-	&dma1_device,
-	&rtc_device,
-	&iic0_device,
-	&iic1_device,
-	&vpu_device,
-	&veu0_device,
-	&veu1_device,
-	&beu0_device,
-	&beu1_device,
-	&jpu_device,
-	&spu0_device,
-	&spu1_device,
-};
-
-static int __init sh7724_devices_setup(void)
-{
-	platform_resource_setup_memory(&vpu_device, "vpu", 2 << 20);
-	platform_resource_setup_memory(&veu0_device, "veu0", 2 << 20);
-	platform_resource_setup_memory(&veu1_device, "veu1", 2 << 20);
-	platform_resource_setup_memory(&jpu_device,  "jpu",  2 << 20);
-	platform_resource_setup_memory(&spu0_device, "spu0", 2 << 20);
-	platform_resource_setup_memory(&spu1_device, "spu1", 2 << 20);
-
-	return platform_add_devices(sh7724_devices,
-				    ARRAY_SIZE(sh7724_devices));
-}
-arch_initcall(sh7724_devices_setup);
-
-static struct platform_device *sh7724_early_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&scif4_device,
-	&scif5_device,
-	&cmt_device,
-	&tmu0_device,
-	&tmu1_device,
-};
-
-void __init plat_early_device_setup(void)
-{
-	sh_early_platform_add_devices(sh7724_early_devices,
-				   ARRAY_SIZE(sh7724_early_devices));
-}
-
-#define RAMCR_CACHE_L2FC	0x0002
-#define RAMCR_CACHE_L2E		0x0001
-#define L2_CACHE_ENABLE		(RAMCR_CACHE_L2E|RAMCR_CACHE_L2FC)
-
-void l2_cache_init(void)
-{
-	/* Enable L2 cache */
-	__raw_writel(L2_CACHE_ENABLE, RAMCR);
-}
-
-enum {
-	UNUSED = 0,
-	ENABLED,
-	DISABLED,
-
-	/* interrupt sources */
-	IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7,
-	HUDI,
-	DMAC1A_DEI0, DMAC1A_DEI1, DMAC1A_DEI2, DMAC1A_DEI3,
-	_2DG_TRI, _2DG_INI, _2DG_CEI,
-	DMAC0A_DEI0, DMAC0A_DEI1, DMAC0A_DEI2, DMAC0A_DEI3,
-	VIO_CEU0, VIO_BEU0, VIO_VEU1, VIO_VOU,
-	SCIFA3,
-	VPU,
-	TPU,
-	CEU1,
-	BEU1,
-	USB0, USB1,
-	ATAPI,
-	RTC_ATI, RTC_PRI, RTC_CUI,
-	DMAC1B_DEI4, DMAC1B_DEI5, DMAC1B_DADERR,
-	DMAC0B_DEI4, DMAC0B_DEI5, DMAC0B_DADERR,
-	KEYSC,
-	SCIF_SCIF0, SCIF_SCIF1, SCIF_SCIF2,
-	VEU0,
-	MSIOF_MSIOFI0, MSIOF_MSIOFI1,
-	SPU_SPUI0, SPU_SPUI1,
-	SCIFA4,
-	ICB,
-	ETHI,
-	I2C1_ALI, I2C1_TACKI, I2C1_WAITI, I2C1_DTEI,
-	I2C0_ALI, I2C0_TACKI, I2C0_WAITI, I2C0_DTEI,
-	CMT,
-	TSIF,
-	FSI,
-	SCIFA5,
-	TMU0_TUNI0, TMU0_TUNI1, TMU0_TUNI2,
-	IRDA,
-	JPU,
-	_2DDMAC,
-	MMC_MMC2I, MMC_MMC3I,
-	LCDC,
-	TMU1_TUNI0, TMU1_TUNI1, TMU1_TUNI2,
-
-	/* interrupt groups */
-	DMAC1A, _2DG, DMAC0A, VIO, USB, RTC,
-	DMAC1B, DMAC0B, I2C0, I2C1, SDHI0, SDHI1, SPU, MMCIF,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_VECT(IRQ0, 0x600), INTC_VECT(IRQ1, 0x620),
-	INTC_VECT(IRQ2, 0x640), INTC_VECT(IRQ3, 0x660),
-	INTC_VECT(IRQ4, 0x680), INTC_VECT(IRQ5, 0x6a0),
-	INTC_VECT(IRQ6, 0x6c0), INTC_VECT(IRQ7, 0x6e0),
-
-	INTC_VECT(DMAC1A_DEI0, 0x700),
-	INTC_VECT(DMAC1A_DEI1, 0x720),
-	INTC_VECT(DMAC1A_DEI2, 0x740),
-	INTC_VECT(DMAC1A_DEI3, 0x760),
-
-	INTC_VECT(_2DG_TRI, 0x780),
-	INTC_VECT(_2DG_INI, 0x7A0),
-	INTC_VECT(_2DG_CEI, 0x7C0),
-
-	INTC_VECT(DMAC0A_DEI0, 0x800),
-	INTC_VECT(DMAC0A_DEI1, 0x820),
-	INTC_VECT(DMAC0A_DEI2, 0x840),
-	INTC_VECT(DMAC0A_DEI3, 0x860),
-
-	INTC_VECT(VIO_CEU0, 0x880),
-	INTC_VECT(VIO_BEU0, 0x8A0),
-	INTC_VECT(VIO_VEU1, 0x8C0),
-	INTC_VECT(VIO_VOU,  0x8E0),
-
-	INTC_VECT(SCIFA3, 0x900),
-	INTC_VECT(VPU,    0x980),
-	INTC_VECT(TPU,    0x9A0),
-	INTC_VECT(CEU1,   0x9E0),
-	INTC_VECT(BEU1,   0xA00),
-	INTC_VECT(USB0,   0xA20),
-	INTC_VECT(USB1,   0xA40),
-	INTC_VECT(ATAPI,  0xA60),
-
-	INTC_VECT(RTC_ATI, 0xA80),
-	INTC_VECT(RTC_PRI, 0xAA0),
-	INTC_VECT(RTC_CUI, 0xAC0),
-
-	INTC_VECT(DMAC1B_DEI4, 0xB00),
-	INTC_VECT(DMAC1B_DEI5, 0xB20),
-	INTC_VECT(DMAC1B_DADERR, 0xB40),
-
-	INTC_VECT(DMAC0B_DEI4, 0xB80),
-	INTC_VECT(DMAC0B_DEI5, 0xBA0),
-	INTC_VECT(DMAC0B_DADERR, 0xBC0),
-
-	INTC_VECT(KEYSC,      0xBE0),
-	INTC_VECT(SCIF_SCIF0, 0xC00),
-	INTC_VECT(SCIF_SCIF1, 0xC20),
-	INTC_VECT(SCIF_SCIF2, 0xC40),
-	INTC_VECT(VEU0,       0xC60),
-	INTC_VECT(MSIOF_MSIOFI0, 0xC80),
-	INTC_VECT(MSIOF_MSIOFI1, 0xCA0),
-	INTC_VECT(SPU_SPUI0, 0xCC0),
-	INTC_VECT(SPU_SPUI1, 0xCE0),
-	INTC_VECT(SCIFA4,    0xD00),
-
-	INTC_VECT(ICB,  0xD20),
-	INTC_VECT(ETHI, 0xD60),
-
-	INTC_VECT(I2C1_ALI, 0xD80),
-	INTC_VECT(I2C1_TACKI, 0xDA0),
-	INTC_VECT(I2C1_WAITI, 0xDC0),
-	INTC_VECT(I2C1_DTEI, 0xDE0),
-
-	INTC_VECT(I2C0_ALI, 0xE00),
-	INTC_VECT(I2C0_TACKI, 0xE20),
-	INTC_VECT(I2C0_WAITI, 0xE40),
-	INTC_VECT(I2C0_DTEI, 0xE60),
-
-	INTC_VECT(SDHI0, 0xE80),
-	INTC_VECT(SDHI0, 0xEA0),
-	INTC_VECT(SDHI0, 0xEC0),
-	INTC_VECT(SDHI0, 0xEE0),
-
-	INTC_VECT(CMT,    0xF00),
-	INTC_VECT(TSIF,   0xF20),
-	INTC_VECT(FSI,    0xF80),
-	INTC_VECT(SCIFA5, 0xFA0),
-
-	INTC_VECT(TMU0_TUNI0, 0x400),
-	INTC_VECT(TMU0_TUNI1, 0x420),
-	INTC_VECT(TMU0_TUNI2, 0x440),
-
-	INTC_VECT(IRDA,    0x480),
-
-	INTC_VECT(SDHI1, 0x4E0),
-	INTC_VECT(SDHI1, 0x500),
-	INTC_VECT(SDHI1, 0x520),
-
-	INTC_VECT(JPU, 0x560),
-	INTC_VECT(_2DDMAC, 0x4A0),
-
-	INTC_VECT(MMC_MMC2I, 0x5A0),
-	INTC_VECT(MMC_MMC3I, 0x5C0),
-
-	INTC_VECT(LCDC, 0xF40),
-
-	INTC_VECT(TMU1_TUNI0, 0x920),
-	INTC_VECT(TMU1_TUNI1, 0x940),
-	INTC_VECT(TMU1_TUNI2, 0x960),
-};
-
-static struct intc_group groups[] __initdata = {
-	INTC_GROUP(DMAC1A, DMAC1A_DEI0, DMAC1A_DEI1, DMAC1A_DEI2, DMAC1A_DEI3),
-	INTC_GROUP(_2DG, _2DG_TRI, _2DG_INI, _2DG_CEI),
-	INTC_GROUP(DMAC0A, DMAC0A_DEI0, DMAC0A_DEI1, DMAC0A_DEI2, DMAC0A_DEI3),
-	INTC_GROUP(VIO, VIO_CEU0, VIO_BEU0, VIO_VEU1, VIO_VOU),
-	INTC_GROUP(USB, USB0, USB1),
-	INTC_GROUP(RTC, RTC_ATI, RTC_PRI, RTC_CUI),
-	INTC_GROUP(DMAC1B, DMAC1B_DEI4, DMAC1B_DEI5, DMAC1B_DADERR),
-	INTC_GROUP(DMAC0B, DMAC0B_DEI4, DMAC0B_DEI5, DMAC0B_DADERR),
-	INTC_GROUP(I2C0, I2C0_ALI, I2C0_TACKI, I2C0_WAITI, I2C0_DTEI),
-	INTC_GROUP(I2C1, I2C1_ALI, I2C1_TACKI, I2C1_WAITI, I2C1_DTEI),
-	INTC_GROUP(SPU, SPU_SPUI0, SPU_SPUI1),
-	INTC_GROUP(MMCIF, MMC_MMC2I, MMC_MMC3I),
-};
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xa4080080, 0xa40800c0, 8, /* IMR0 / IMCR0 */
-	  { 0, TMU1_TUNI2, TMU1_TUNI1, TMU1_TUNI0,
-	    0, ENABLED, ENABLED, ENABLED } },
-	{ 0xa4080084, 0xa40800c4, 8, /* IMR1 / IMCR1 */
-	  { VIO_VOU, VIO_VEU1, VIO_BEU0, VIO_CEU0,
-	    DMAC0A_DEI3, DMAC0A_DEI2, DMAC0A_DEI1, DMAC0A_DEI0 } },
-	{ 0xa4080088, 0xa40800c8, 8, /* IMR2 / IMCR2 */
-	  { 0, 0, 0, VPU, ATAPI, ETHI, 0, SCIFA3 } },
-	{ 0xa408008c, 0xa40800cc, 8, /* IMR3 / IMCR3 */
-	  { DMAC1A_DEI3, DMAC1A_DEI2, DMAC1A_DEI1, DMAC1A_DEI0,
-	    SPU_SPUI1, SPU_SPUI0, BEU1, IRDA } },
-	{ 0xa4080090, 0xa40800d0, 8, /* IMR4 / IMCR4 */
-	  { 0, TMU0_TUNI2, TMU0_TUNI1, TMU0_TUNI0,
-	    JPU, 0, 0, LCDC } },
-	{ 0xa4080094, 0xa40800d4, 8, /* IMR5 / IMCR5 */
-	  { KEYSC, DMAC0B_DADERR, DMAC0B_DEI5, DMAC0B_DEI4,
-	    VEU0, SCIF_SCIF2, SCIF_SCIF1, SCIF_SCIF0 } },
-	{ 0xa4080098, 0xa40800d8, 8, /* IMR6 / IMCR6 */
-	  { 0, 0, ICB, SCIFA4,
-	    CEU1, 0, MSIOF_MSIOFI1, MSIOF_MSIOFI0 } },
-	{ 0xa408009c, 0xa40800dc, 8, /* IMR7 / IMCR7 */
-	  { I2C0_DTEI, I2C0_WAITI, I2C0_TACKI, I2C0_ALI,
-	    I2C1_DTEI, I2C1_WAITI, I2C1_TACKI, I2C1_ALI } },
-	{ 0xa40800a0, 0xa40800e0, 8, /* IMR8 / IMCR8 */
-	  { DISABLED, ENABLED, ENABLED, ENABLED,
-	    0, 0, SCIFA5, FSI } },
-	{ 0xa40800a4, 0xa40800e4, 8, /* IMR9 / IMCR9 */
-	  { 0, 0, 0, CMT, 0, USB1, USB0, 0 } },
-	{ 0xa40800a8, 0xa40800e8, 8, /* IMR10 / IMCR10 */
-	  { 0, DMAC1B_DADERR, DMAC1B_DEI5, DMAC1B_DEI4,
-	    0, RTC_CUI, RTC_PRI, RTC_ATI } },
-	{ 0xa40800ac, 0xa40800ec, 8, /* IMR11 / IMCR11 */
-	  { 0, _2DG_CEI, _2DG_INI, _2DG_TRI,
-	    0, TPU, 0, TSIF } },
-	{ 0xa40800b0, 0xa40800f0, 8, /* IMR12 / IMCR12 */
-	  { 0, 0, MMC_MMC3I, MMC_MMC2I, 0, 0, 0, _2DDMAC } },
-	{ 0xa4140044, 0xa4140064, 8, /* INTMSK00 / INTMSKCLR00 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xa4080000, 0, 16, 4, /* IPRA */ { TMU0_TUNI0, TMU0_TUNI1,
-					     TMU0_TUNI2, IRDA } },
-	{ 0xa4080004, 0, 16, 4, /* IPRB */ { JPU, LCDC, DMAC1A, BEU1 } },
-	{ 0xa4080008, 0, 16, 4, /* IPRC */ { TMU1_TUNI0, TMU1_TUNI1,
-					     TMU1_TUNI2, SPU } },
-	{ 0xa408000c, 0, 16, 4, /* IPRD */ { 0, MMCIF, 0, ATAPI } },
-	{ 0xa4080010, 0, 16, 4, /* IPRE */ { DMAC0A, VIO, SCIFA3, VPU } },
-	{ 0xa4080014, 0, 16, 4, /* IPRF */ { KEYSC, DMAC0B, USB, CMT } },
-	{ 0xa4080018, 0, 16, 4, /* IPRG */ { SCIF_SCIF0, SCIF_SCIF1,
-					     SCIF_SCIF2, VEU0 } },
-	{ 0xa408001c, 0, 16, 4, /* IPRH */ { MSIOF_MSIOFI0, MSIOF_MSIOFI1,
-					     I2C1, I2C0 } },
-	{ 0xa4080020, 0, 16, 4, /* IPRI */ { SCIFA4, ICB, TSIF, _2DG } },
-	{ 0xa4080024, 0, 16, 4, /* IPRJ */ { CEU1, ETHI, FSI, SDHI1 } },
-	{ 0xa4080028, 0, 16, 4, /* IPRK */ { RTC, DMAC1B, 0, SDHI0 } },
-	{ 0xa408002c, 0, 16, 4, /* IPRL */ { SCIFA5, 0, TPU, _2DDMAC } },
-	{ 0xa4140010, 0, 32, 4, /* INTPRI00 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_sense_reg sense_registers[] __initdata = {
-	{ 0xa414001c, 16, 2, /* ICR1 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_mask_reg ack_registers[] __initdata = {
-	{ 0xa4140024, 0, 8, /* INTREQ00 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_desc intc_desc __initdata = {
-	.name = "sh7724",
-	.force_enable = ENABLED,
-	.force_disable = DISABLED,
-	.hw = INTC_HW_DESC(vectors, groups, mask_registers,
-			   prio_registers, sense_registers, ack_registers),
-};
-
-void __init plat_irq_setup(void)
-{
-	register_intc_controller(&intc_desc);
-}
-
-static struct {
-	/* BSC */
-	unsigned long mmselr;
-	unsigned long cs0bcr;
-	unsigned long cs4bcr;
-	unsigned long cs5abcr;
-	unsigned long cs5bbcr;
-	unsigned long cs6abcr;
-	unsigned long cs6bbcr;
-	unsigned long cs4wcr;
-	unsigned long cs5awcr;
-	unsigned long cs5bwcr;
-	unsigned long cs6awcr;
-	unsigned long cs6bwcr;
-	/* INTC */
-	unsigned short ipra;
-	unsigned short iprb;
-	unsigned short iprc;
-	unsigned short iprd;
-	unsigned short ipre;
-	unsigned short iprf;
-	unsigned short iprg;
-	unsigned short iprh;
-	unsigned short ipri;
-	unsigned short iprj;
-	unsigned short iprk;
-	unsigned short iprl;
-	unsigned char imr0;
-	unsigned char imr1;
-	unsigned char imr2;
-	unsigned char imr3;
-	unsigned char imr4;
-	unsigned char imr5;
-	unsigned char imr6;
-	unsigned char imr7;
-	unsigned char imr8;
-	unsigned char imr9;
-	unsigned char imr10;
-	unsigned char imr11;
-	unsigned char imr12;
-	/* RWDT */
-	unsigned short rwtcnt;
-	unsigned short rwtcsr;
-	/* CPG */
-	unsigned long irdaclk;
-	unsigned long spuclk;
-} sh7724_rstandby_state;
-
-static int sh7724_pre_sleep_notifier_call(struct notifier_block *nb,
-					  unsigned long flags, void *unused)
-{
-	if (!(flags & SUSP_SH_RSTANDBY))
-		return NOTIFY_DONE;
-
-	/* BCR */
-	sh7724_rstandby_state.mmselr = __raw_readl(0xff800020); /* MMSELR */
-	sh7724_rstandby_state.mmselr |= 0xa5a50000;
-	sh7724_rstandby_state.cs0bcr = __raw_readl(0xfec10004); /* CS0BCR */
-	sh7724_rstandby_state.cs4bcr = __raw_readl(0xfec10010); /* CS4BCR */
-	sh7724_rstandby_state.cs5abcr = __raw_readl(0xfec10014); /* CS5ABCR */
-	sh7724_rstandby_state.cs5bbcr = __raw_readl(0xfec10018); /* CS5BBCR */
-	sh7724_rstandby_state.cs6abcr = __raw_readl(0xfec1001c); /* CS6ABCR */
-	sh7724_rstandby_state.cs6bbcr = __raw_readl(0xfec10020); /* CS6BBCR */
-	sh7724_rstandby_state.cs4wcr = __raw_readl(0xfec10030); /* CS4WCR */
-	sh7724_rstandby_state.cs5awcr = __raw_readl(0xfec10034); /* CS5AWCR */
-	sh7724_rstandby_state.cs5bwcr = __raw_readl(0xfec10038); /* CS5BWCR */
-	sh7724_rstandby_state.cs6awcr = __raw_readl(0xfec1003c); /* CS6AWCR */
-	sh7724_rstandby_state.cs6bwcr = __raw_readl(0xfec10040); /* CS6BWCR */
-
-	/* INTC */
-	sh7724_rstandby_state.ipra = __raw_readw(0xa4080000); /* IPRA */
-	sh7724_rstandby_state.iprb = __raw_readw(0xa4080004); /* IPRB */
-	sh7724_rstandby_state.iprc = __raw_readw(0xa4080008); /* IPRC */
-	sh7724_rstandby_state.iprd = __raw_readw(0xa408000c); /* IPRD */
-	sh7724_rstandby_state.ipre = __raw_readw(0xa4080010); /* IPRE */
-	sh7724_rstandby_state.iprf = __raw_readw(0xa4080014); /* IPRF */
-	sh7724_rstandby_state.iprg = __raw_readw(0xa4080018); /* IPRG */
-	sh7724_rstandby_state.iprh = __raw_readw(0xa408001c); /* IPRH */
-	sh7724_rstandby_state.ipri = __raw_readw(0xa4080020); /* IPRI */
-	sh7724_rstandby_state.iprj = __raw_readw(0xa4080024); /* IPRJ */
-	sh7724_rstandby_state.iprk = __raw_readw(0xa4080028); /* IPRK */
-	sh7724_rstandby_state.iprl = __raw_readw(0xa408002c); /* IPRL */
-	sh7724_rstandby_state.imr0 = __raw_readb(0xa4080080); /* IMR0 */
-	sh7724_rstandby_state.imr1 = __raw_readb(0xa4080084); /* IMR1 */
-	sh7724_rstandby_state.imr2 = __raw_readb(0xa4080088); /* IMR2 */
-	sh7724_rstandby_state.imr3 = __raw_readb(0xa408008c); /* IMR3 */
-	sh7724_rstandby_state.imr4 = __raw_readb(0xa4080090); /* IMR4 */
-	sh7724_rstandby_state.imr5 = __raw_readb(0xa4080094); /* IMR5 */
-	sh7724_rstandby_state.imr6 = __raw_readb(0xa4080098); /* IMR6 */
-	sh7724_rstandby_state.imr7 = __raw_readb(0xa408009c); /* IMR7 */
-	sh7724_rstandby_state.imr8 = __raw_readb(0xa40800a0); /* IMR8 */
-	sh7724_rstandby_state.imr9 = __raw_readb(0xa40800a4); /* IMR9 */
-	sh7724_rstandby_state.imr10 = __raw_readb(0xa40800a8); /* IMR10 */
-	sh7724_rstandby_state.imr11 = __raw_readb(0xa40800ac); /* IMR11 */
-	sh7724_rstandby_state.imr12 = __raw_readb(0xa40800b0); /* IMR12 */
-
-	/* RWDT */
-	sh7724_rstandby_state.rwtcnt = __raw_readb(0xa4520000); /* RWTCNT */
-	sh7724_rstandby_state.rwtcnt |= 0x5a00;
-	sh7724_rstandby_state.rwtcsr = __raw_readb(0xa4520004); /* RWTCSR */
-	sh7724_rstandby_state.rwtcsr |= 0xa500;
-	__raw_writew(sh7724_rstandby_state.rwtcsr & 0x07, 0xa4520004);
-
-	/* CPG */
-	sh7724_rstandby_state.irdaclk = __raw_readl(0xa4150018); /* IRDACLKCR */
-	sh7724_rstandby_state.spuclk = __raw_readl(0xa415003c); /* SPUCLKCR */
-
-	return NOTIFY_DONE;
-}
-
-static int sh7724_post_sleep_notifier_call(struct notifier_block *nb,
-					   unsigned long flags, void *unused)
-{
-	if (!(flags & SUSP_SH_RSTANDBY))
-		return NOTIFY_DONE;
-
-	/* BCR */
-	__raw_writel(sh7724_rstandby_state.mmselr, 0xff800020); /* MMSELR */
-	__raw_writel(sh7724_rstandby_state.cs0bcr, 0xfec10004); /* CS0BCR */
-	__raw_writel(sh7724_rstandby_state.cs4bcr, 0xfec10010); /* CS4BCR */
-	__raw_writel(sh7724_rstandby_state.cs5abcr, 0xfec10014); /* CS5ABCR */
-	__raw_writel(sh7724_rstandby_state.cs5bbcr, 0xfec10018); /* CS5BBCR */
-	__raw_writel(sh7724_rstandby_state.cs6abcr, 0xfec1001c); /* CS6ABCR */
-	__raw_writel(sh7724_rstandby_state.cs6bbcr, 0xfec10020); /* CS6BBCR */
-	__raw_writel(sh7724_rstandby_state.cs4wcr, 0xfec10030); /* CS4WCR */
-	__raw_writel(sh7724_rstandby_state.cs5awcr, 0xfec10034); /* CS5AWCR */
-	__raw_writel(sh7724_rstandby_state.cs5bwcr, 0xfec10038); /* CS5BWCR */
-	__raw_writel(sh7724_rstandby_state.cs6awcr, 0xfec1003c); /* CS6AWCR */
-	__raw_writel(sh7724_rstandby_state.cs6bwcr, 0xfec10040); /* CS6BWCR */
-
-	/* INTC */
-	__raw_writew(sh7724_rstandby_state.ipra, 0xa4080000); /* IPRA */
-	__raw_writew(sh7724_rstandby_state.iprb, 0xa4080004); /* IPRB */
-	__raw_writew(sh7724_rstandby_state.iprc, 0xa4080008); /* IPRC */
-	__raw_writew(sh7724_rstandby_state.iprd, 0xa408000c); /* IPRD */
-	__raw_writew(sh7724_rstandby_state.ipre, 0xa4080010); /* IPRE */
-	__raw_writew(sh7724_rstandby_state.iprf, 0xa4080014); /* IPRF */
-	__raw_writew(sh7724_rstandby_state.iprg, 0xa4080018); /* IPRG */
-	__raw_writew(sh7724_rstandby_state.iprh, 0xa408001c); /* IPRH */
-	__raw_writew(sh7724_rstandby_state.ipri, 0xa4080020); /* IPRI */
-	__raw_writew(sh7724_rstandby_state.iprj, 0xa4080024); /* IPRJ */
-	__raw_writew(sh7724_rstandby_state.iprk, 0xa4080028); /* IPRK */
-	__raw_writew(sh7724_rstandby_state.iprl, 0xa408002c); /* IPRL */
-	__raw_writeb(sh7724_rstandby_state.imr0, 0xa4080080); /* IMR0 */
-	__raw_writeb(sh7724_rstandby_state.imr1, 0xa4080084); /* IMR1 */
-	__raw_writeb(sh7724_rstandby_state.imr2, 0xa4080088); /* IMR2 */
-	__raw_writeb(sh7724_rstandby_state.imr3, 0xa408008c); /* IMR3 */
-	__raw_writeb(sh7724_rstandby_state.imr4, 0xa4080090); /* IMR4 */
-	__raw_writeb(sh7724_rstandby_state.imr5, 0xa4080094); /* IMR5 */
-	__raw_writeb(sh7724_rstandby_state.imr6, 0xa4080098); /* IMR6 */
-	__raw_writeb(sh7724_rstandby_state.imr7, 0xa408009c); /* IMR7 */
-	__raw_writeb(sh7724_rstandby_state.imr8, 0xa40800a0); /* IMR8 */
-	__raw_writeb(sh7724_rstandby_state.imr9, 0xa40800a4); /* IMR9 */
-	__raw_writeb(sh7724_rstandby_state.imr10, 0xa40800a8); /* IMR10 */
-	__raw_writeb(sh7724_rstandby_state.imr11, 0xa40800ac); /* IMR11 */
-	__raw_writeb(sh7724_rstandby_state.imr12, 0xa40800b0); /* IMR12 */
-
-	/* RWDT */
-	__raw_writew(sh7724_rstandby_state.rwtcnt, 0xa4520000); /* RWTCNT */
-	__raw_writew(sh7724_rstandby_state.rwtcsr, 0xa4520004); /* RWTCSR */
-
-	/* CPG */
-	__raw_writel(sh7724_rstandby_state.irdaclk, 0xa4150018); /* IRDACLKCR */
-	__raw_writel(sh7724_rstandby_state.spuclk, 0xa415003c); /* SPUCLKCR */
-
-	return NOTIFY_DONE;
-}
-
-static struct notifier_block sh7724_pre_sleep_notifier = {
-	.notifier_call = sh7724_pre_sleep_notifier_call,
-	.priority = SH_MOBILE_PRE(SH_MOBILE_SLEEP_CPU),
-};
-
-static struct notifier_block sh7724_post_sleep_notifier = {
-	.notifier_call = sh7724_post_sleep_notifier_call,
-	.priority = SH_MOBILE_POST(SH_MOBILE_SLEEP_CPU),
-};
-
-static int __init sh7724_sleep_setup(void)
-{
-	atomic_notifier_chain_register(&sh_mobile_pre_sleep_notifier_list,
-				       &sh7724_pre_sleep_notifier);
-
-	atomic_notifier_chain_register(&sh_mobile_post_sleep_notifier_list,
-				       &sh7724_post_sleep_notifier);
-	return 0;
-}
-arch_initcall(sh7724_sleep_setup);
-
diff --git a/arch/sh/kernel/cpu/sh4a/setup-sh7734.c b/arch/sh/kernel/cpu/sh4a/setup-sh7734.c
deleted file mode 100644
index 9911da794358d0..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/setup-sh7734.c
+++ /dev/null
@@ -1,621 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh4a/setup-sh7734.c
- *
- * SH7734 Setup
- *
- * Copyright (C) 2011,2012 Nobuhiro Iwamatsu <nobuhiro.iwamatsu.yj@renesas.com>
- * Copyright (C) 2011,2012 Renesas Solutions Corp.
- */
-
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/mm.h>
-#include <linux/dma-mapping.h>
-#include <linux/serial_sci.h>
-#include <linux/sh_timer.h>
-#include <linux/io.h>
-#include <asm/clock.h>
-#include <asm/irq.h>
-#include <asm/platform_early.h>
-#include <cpu/sh7734.h>
-
-/* SCIF */
-static struct plat_sci_port scif0_platform_data = {
-	.scscr          = SCSCR_REIE,
-	.type           = PORT_SCIF,
-	.regtype        = SCIx_SH4_SCIF_BRG_REGTYPE,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xffe40000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x8c0)),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct plat_sci_port scif1_platform_data = {
-	.scscr          = SCSCR_REIE,
-	.type           = PORT_SCIF,
-	.regtype        = SCIx_SH4_SCIF_BRG_REGTYPE,
-};
-
-static struct resource scif1_resources[] = {
-	DEFINE_RES_MEM(0xffe41000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x8e0)),
-};
-
-static struct platform_device scif1_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif1_resources,
-	.num_resources	= ARRAY_SIZE(scif1_resources),
-	.dev		= {
-		.platform_data = &scif1_platform_data,
-	},
-};
-
-static struct plat_sci_port scif2_platform_data = {
-	.scscr          = SCSCR_REIE,
-	.type           = PORT_SCIF,
-	.regtype        = SCIx_SH4_SCIF_BRG_REGTYPE,
-};
-
-static struct resource scif2_resources[] = {
-	DEFINE_RES_MEM(0xffe42000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x900)),
-};
-
-static struct platform_device scif2_device = {
-	.name		= "sh-sci",
-	.id		= 2,
-	.resource	= scif2_resources,
-	.num_resources	= ARRAY_SIZE(scif2_resources),
-	.dev		= {
-		.platform_data = &scif2_platform_data,
-	},
-};
-
-static struct plat_sci_port scif3_platform_data = {
-	.scscr          = SCSCR_REIE | SCSCR_TOIE,
-	.type           = PORT_SCIF,
-	.regtype        = SCIx_SH4_SCIF_BRG_REGTYPE,
-};
-
-static struct resource scif3_resources[] = {
-	DEFINE_RES_MEM(0xffe43000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x920)),
-};
-
-static struct platform_device scif3_device = {
-	.name		= "sh-sci",
-	.id		= 3,
-	.resource	= scif3_resources,
-	.num_resources	= ARRAY_SIZE(scif3_resources),
-	.dev		= {
-		.platform_data	= &scif3_platform_data,
-	},
-};
-
-static struct plat_sci_port scif4_platform_data = {
-	.scscr          = SCSCR_REIE,
-	.type           = PORT_SCIF,
-	.regtype        = SCIx_SH4_SCIF_BRG_REGTYPE,
-};
-
-static struct resource scif4_resources[] = {
-	DEFINE_RES_MEM(0xffe44000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x940)),
-};
-
-static struct platform_device scif4_device = {
-	.name		= "sh-sci",
-	.id		= 4,
-	.resource	= scif4_resources,
-	.num_resources	= ARRAY_SIZE(scif4_resources),
-	.dev		= {
-		.platform_data	= &scif4_platform_data,
-	},
-};
-
-static struct plat_sci_port scif5_platform_data = {
-	.scscr          = SCSCR_REIE,
-	.type           = PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_BRG_REGTYPE,
-};
-
-static struct resource scif5_resources[] = {
-	DEFINE_RES_MEM(0xffe43000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x960)),
-};
-
-static struct platform_device scif5_device = {
-	.name		= "sh-sci",
-	.id		= 5,
-	.resource	= scif5_resources,
-	.num_resources	= ARRAY_SIZE(scif5_resources),
-	.dev		= {
-		.platform_data	= &scif5_platform_data,
-	},
-};
-
-/* RTC */
-static struct resource rtc_resources[] = {
-	[0] = {
-		.name	= "rtc",
-		.start	= 0xFFFC5000,
-		.end	= 0xFFFC5000 + 0x26 - 1,
-		.flags	= IORESOURCE_IO,
-	},
-	[1] = {
-		.start	= evt2irq(0xC00),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device rtc_device = {
-	.name		= "sh-rtc",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(rtc_resources),
-	.resource	= rtc_resources,
-};
-
-/* I2C 0 */
-static struct resource i2c0_resources[] = {
-	[0] = {
-		.name	= "IIC0",
-		.start  = 0xFFC70000,
-		.end    = 0xFFC7000A - 1,
-		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
-		.start  = evt2irq(0x860),
-		.flags  = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device i2c0_device = {
-	.name           = "i2c-sh7734",
-	.id             = 0,
-	.num_resources  = ARRAY_SIZE(i2c0_resources),
-	.resource       = i2c0_resources,
-};
-
-/* TMU */
-static struct sh_timer_config tmu0_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu0_resources[] = {
-	DEFINE_RES_MEM(0xffd80000, 0x30),
-	DEFINE_RES_IRQ(evt2irq(0x400)),
-	DEFINE_RES_IRQ(evt2irq(0x420)),
-	DEFINE_RES_IRQ(evt2irq(0x440)),
-};
-
-static struct platform_device tmu0_device = {
-	.name		= "sh-tmu",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &tmu0_platform_data,
-	},
-	.resource	= tmu0_resources,
-	.num_resources	= ARRAY_SIZE(tmu0_resources),
-};
-
-static struct sh_timer_config tmu1_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu1_resources[] = {
-	DEFINE_RES_MEM(0xffd81000, 0x30),
-	DEFINE_RES_IRQ(evt2irq(0x480)),
-	DEFINE_RES_IRQ(evt2irq(0x4a0)),
-	DEFINE_RES_IRQ(evt2irq(0x4c0)),
-};
-
-static struct platform_device tmu1_device = {
-	.name		= "sh-tmu",
-	.id		= 1,
-	.dev = {
-		.platform_data	= &tmu1_platform_data,
-	},
-	.resource	= tmu1_resources,
-	.num_resources	= ARRAY_SIZE(tmu1_resources),
-};
-
-static struct sh_timer_config tmu2_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu2_resources[] = {
-	DEFINE_RES_MEM(0xffd82000, 0x30),
-	DEFINE_RES_IRQ(evt2irq(0x500)),
-	DEFINE_RES_IRQ(evt2irq(0x520)),
-	DEFINE_RES_IRQ(evt2irq(0x540)),
-};
-
-static struct platform_device tmu2_device = {
-	.name		= "sh-tmu",
-	.id		= 2,
-	.dev = {
-		.platform_data	= &tmu2_platform_data,
-	},
-	.resource	= tmu2_resources,
-	.num_resources	= ARRAY_SIZE(tmu2_resources),
-};
-
-static struct platform_device *sh7734_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&scif4_device,
-	&scif5_device,
-	&tmu0_device,
-	&tmu1_device,
-	&tmu2_device,
-	&rtc_device,
-};
-
-static struct platform_device *sh7734_early_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&scif4_device,
-	&scif5_device,
-	&tmu0_device,
-	&tmu1_device,
-	&tmu2_device,
-};
-
-void __init plat_early_device_setup(void)
-{
-	sh_early_platform_add_devices(sh7734_early_devices,
-		ARRAY_SIZE(sh7734_early_devices));
-}
-
-#define GROUP 0
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-
-	IRL0_LLLL, IRL0_LLLH, IRL0_LLHL, IRL0_LLHH,
-	IRL0_LHLL, IRL0_LHLH, IRL0_LHHL, IRL0_LHHH,
-	IRL0_HLLL, IRL0_HLLH, IRL0_HLHL, IRL0_HLHH,
-	IRL0_HHLL, IRL0_HHLH, IRL0_HHHL,
-
-	IRQ0, IRQ1, IRQ2, IRQ3,
-	DU,
-	TMU00, TMU10, TMU20, TMU21,
-	TMU30, TMU40, TMU50, TMU51,
-	TMU60, TMU70, TMU80,
-	RESET_WDT,
-	USB,
-	HUDI,
-	SHDMAC,
-	SSI0, SSI1,	SSI2, SSI3,
-	VIN0,
-	RGPVG,
-	_2DG,
-	MMC,
-	HSPI,
-	LBSCATA,
-	I2C0,
-	RCAN0,
-	MIMLB,
-	SCIF0, SCIF1, SCIF2, SCIF3, SCIF4, SCIF5,
-	LBSCDMAC0, LBSCDMAC1, LBSCDMAC2,
-	RCAN1,
-	SDHI0, SDHI1,
-	IEBUS,
-	HPBDMAC0_3, HPBDMAC4_10, HPBDMAC11_18, HPBDMAC19_22, HPBDMAC23_25_27_28,
-	RTC,
-	VIN1,
-	LCDC,
-	SRC0, SRC1,
-	GETHER,
-	SDHI2,
-	GPIO0_3, GPIO4_5,
-	STIF0, STIF1,
-	ADMAC,
-	HIF,
-	FLCTL,
-	ADC,
-	MTU2,
-	RSPI,
-	QSPI,
-	HSCIF,
-	VEU3F_VE3,
-
-	/* Group */
-	/* Mask */
-	STIF_M,
-	GPIO_M,
-	HPBDMAC_M,
-	LBSCDMAC_M,
-	RCAN_M,
-	SRC_M,
-	SCIF_M,
-	LCDC_M,
-	_2DG_M,
-	VIN_M,
-	TMU_3_M,
-	TMU_0_M,
-
-	/* Priority */
-	RCAN_P,
-	LBSCDMAC_P,
-
-	/* Common */
-	SDHI,
-	SSI,
-	SPI,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_VECT(DU, 0x3E0),
-	INTC_VECT(TMU00, 0x400),
-	INTC_VECT(TMU10, 0x420),
-	INTC_VECT(TMU20, 0x440),
-	INTC_VECT(TMU30, 0x480),
-	INTC_VECT(TMU40, 0x4A0),
-	INTC_VECT(TMU50, 0x4C0),
-	INTC_VECT(TMU51, 0x4E0),
-	INTC_VECT(TMU60, 0x500),
-	INTC_VECT(TMU70, 0x520),
-	INTC_VECT(TMU80, 0x540),
-	INTC_VECT(RESET_WDT, 0x560),
-	INTC_VECT(USB, 0x580),
-	INTC_VECT(HUDI, 0x600),
-	INTC_VECT(SHDMAC, 0x620),
-	INTC_VECT(SSI0, 0x6C0),
-	INTC_VECT(SSI1, 0x6E0),
-	INTC_VECT(SSI2, 0x700),
-	INTC_VECT(SSI3, 0x720),
-	INTC_VECT(VIN0, 0x740),
-	INTC_VECT(RGPVG, 0x760),
-	INTC_VECT(_2DG, 0x780),
-	INTC_VECT(MMC, 0x7A0),
-	INTC_VECT(HSPI, 0x7E0),
-	INTC_VECT(LBSCATA, 0x840),
-	INTC_VECT(I2C0, 0x860),
-	INTC_VECT(RCAN0, 0x880),
-	INTC_VECT(SCIF0, 0x8A0),
-	INTC_VECT(SCIF1, 0x8C0),
-	INTC_VECT(SCIF2, 0x900),
-	INTC_VECT(SCIF3, 0x920),
-	INTC_VECT(SCIF4, 0x940),
-	INTC_VECT(SCIF5, 0x960),
-	INTC_VECT(LBSCDMAC0, 0x9E0),
-	INTC_VECT(LBSCDMAC1, 0xA00),
-	INTC_VECT(LBSCDMAC2, 0xA20),
-	INTC_VECT(RCAN1, 0xA60),
-	INTC_VECT(SDHI0, 0xAE0),
-	INTC_VECT(SDHI1, 0xB00),
-	INTC_VECT(IEBUS, 0xB20),
-	INTC_VECT(HPBDMAC0_3, 0xB60),
-	INTC_VECT(HPBDMAC4_10, 0xB80),
-	INTC_VECT(HPBDMAC11_18, 0xBA0),
-	INTC_VECT(HPBDMAC19_22, 0xBC0),
-	INTC_VECT(HPBDMAC23_25_27_28, 0xBE0),
-	INTC_VECT(RTC, 0xC00),
-	INTC_VECT(VIN1, 0xC20),
-	INTC_VECT(LCDC, 0xC40),
-	INTC_VECT(SRC0, 0xC60),
-	INTC_VECT(SRC1, 0xC80),
-	INTC_VECT(GETHER, 0xCA0),
-	INTC_VECT(SDHI2, 0xCC0),
-	INTC_VECT(GPIO0_3, 0xCE0),
-	INTC_VECT(GPIO4_5, 0xD00),
-	INTC_VECT(STIF0, 0xD20),
-	INTC_VECT(STIF1, 0xD40),
-	INTC_VECT(ADMAC, 0xDA0),
-	INTC_VECT(HIF, 0xDC0),
-	INTC_VECT(FLCTL, 0xDE0),
-	INTC_VECT(ADC, 0xE00),
-	INTC_VECT(MTU2, 0xE20),
-	INTC_VECT(RSPI, 0xE40),
-	INTC_VECT(QSPI, 0xE60),
-	INTC_VECT(HSCIF, 0xFC0),
-	INTC_VECT(VEU3F_VE3, 0xF40),
-};
-
-static struct intc_group groups[] __initdata = {
-	/* Common */
-	INTC_GROUP(SDHI, SDHI0, SDHI1, SDHI2),
-	INTC_GROUP(SPI, HSPI, RSPI, QSPI),
-	INTC_GROUP(SSI, SSI0, SSI1, SSI2, SSI3),
-
-	/* Mask group */
-	INTC_GROUP(STIF_M, STIF0, STIF1), /* 22 */
-	INTC_GROUP(GPIO_M, GPIO0_3, GPIO4_5), /* 21 */
-	INTC_GROUP(HPBDMAC_M, HPBDMAC0_3, HPBDMAC4_10, HPBDMAC11_18,
-			HPBDMAC19_22, HPBDMAC23_25_27_28), /* 19 */
-	INTC_GROUP(LBSCDMAC_M, LBSCDMAC0, LBSCDMAC1, LBSCDMAC2), /* 18 */
-	INTC_GROUP(RCAN_M, RCAN0, RCAN1, IEBUS), /* 17 */
-	INTC_GROUP(SRC_M, SRC0, SRC1), /* 16 */
-	INTC_GROUP(SCIF_M, SCIF0, SCIF1, SCIF2, SCIF3, SCIF4, SCIF5,
-			HSCIF), /* 14 */
-	INTC_GROUP(LCDC_M, LCDC, MIMLB), /* 13 */
-	INTC_GROUP(_2DG_M, _2DG, RGPVG), /* 12 */
-	INTC_GROUP(VIN_M, VIN0, VIN1), /* 10 */
-	INTC_GROUP(TMU_3_M, TMU30, TMU40, TMU50, TMU51,
-			TMU60, TMU60, TMU70, TMU80), /* 2 */
-	INTC_GROUP(TMU_0_M, TMU00, TMU10, TMU20, TMU21), /* 1 */
-
-	/* Priority group*/
-	INTC_GROUP(RCAN_P, RCAN0, RCAN1), /* INT2PRI5 */
-	INTC_GROUP(LBSCDMAC_P, LBSCDMAC0, LBSCDMAC1), /* INT2PRI5 */
-};
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xFF804040, 0xFF804044, 32, /* INT2MSKRG / INT2MSKCR */
-	  { 0,
-		VEU3F_VE3,
-		SDHI, /* SDHI 0-2 */
-		ADMAC,
-		FLCTL,
-		RESET_WDT,
-		HIF,
-		ADC,
-		MTU2,
-		STIF_M, /* STIF 0,1 */
-		GPIO_M, /* GPIO 0-5*/
-		GETHER,
-		HPBDMAC_M, /* HPBDMAC 0_3 - 23_25_27_28 */
-		LBSCDMAC_M, /* LBSCDMAC 0 - 2 */
-		RCAN_M, /* RCAN, IEBUS */
-		SRC_M,	/* SRC 0,1 */
-		LBSCATA,
-		SCIF_M, /* SCIF 0-5, HSCIF */
-		LCDC_M, /* LCDC, MIMLB */
-		_2DG_M,	/* 2DG, RGPVG */
-		SPI, /* HSPI, RSPI, QSPI */
-		VIN_M,	/* VIN0, 1 */
-		SSI,	/* SSI 0-3 */
-		USB,
-		SHDMAC,
-		HUDI,
-		MMC,
-		RTC,
-		I2C0, /* I2C */ /* I2C 0, 1*/
-		TMU_3_M, /* TMU30 - TMU80 */
-		TMU_0_M, /* TMU00 - TMU21 */
-		DU } },
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xFF804000, 0, 32, 8, /* INT2PRI0 */
-		{ DU, TMU00, TMU10, TMU20 } },
-	{ 0xFF804004, 0, 32, 8, /* INT2PRI1 */
-		{ TMU30, TMU60, RTC, SDHI } },
-	{ 0xFF804008, 0, 32, 8, /* INT2PRI2 */
-		{ HUDI, SHDMAC, USB, SSI } },
-	{ 0xFF80400C, 0, 32, 8, /* INT2PRI3 */
-		{ VIN0, SPI, _2DG, LBSCATA } },
-	{ 0xFF804010, 0, 32, 8, /* INT2PRI4 */
-		{ SCIF0, SCIF3, HSCIF, LCDC } },
-	{ 0xFF804014, 0, 32, 8, /* INT2PRI5 */
-		{ RCAN_P, LBSCDMAC_P, LBSCDMAC2, MMC } },
-	{ 0xFF804018, 0, 32, 8, /* INT2PRI6 */
-		{ HPBDMAC0_3, HPBDMAC4_10, HPBDMAC11_18, HPBDMAC19_22 } },
-	{ 0xFF80401C, 0, 32, 8, /* INT2PRI7 */
-		{ HPBDMAC23_25_27_28, I2C0, SRC0, SRC1 } },
-	{ 0xFF804020, 0, 32, 8, /* INT2PRI8 */
-		{ 0 /* ADIF */, VIN1, RESET_WDT, HIF } },
-	{ 0xFF804024, 0, 32, 8, /* INT2PRI9 */
-		{ ADMAC, FLCTL, GPIO0_3, GPIO4_5 } },
-	{ 0xFF804028, 0, 32, 8, /* INT2PRI10 */
-		{ STIF0, STIF1, VEU3F_VE3, GETHER } },
-	{ 0xFF80402C, 0, 32, 8, /* INT2PRI11 */
-		{ MTU2, RGPVG, MIMLB, IEBUS } },
-};
-
-static DECLARE_INTC_DESC(intc_desc, "sh7734", vectors, groups,
-	mask_registers, prio_registers, NULL);
-
-/* Support for external interrupt pins in IRQ mode */
-
-static struct intc_vect irq3210_vectors[] __initdata = {
-	INTC_VECT(IRQ0, 0x240), INTC_VECT(IRQ1, 0x280),
-	INTC_VECT(IRQ2, 0x2C0), INTC_VECT(IRQ3, 0x300),
-};
-
-static struct intc_sense_reg irq3210_sense_registers[] __initdata = {
-	{ 0xFF80201C, 32, 2, /* ICR1 */
-	{ IRQ0, IRQ1, IRQ2, IRQ3, } },
-};
-
-static struct intc_mask_reg irq3210_ack_registers[] __initdata = {
-	{ 0xFF802024, 0, 32, /* INTREQ */
-	{ IRQ0, IRQ1, IRQ2, IRQ3, } },
-};
-
-static struct intc_mask_reg irq3210_mask_registers[] __initdata = {
-	{ 0xFF802044, 0xFF802064, 32, /* INTMSK0 / INTMSKCLR0 */
-	{ IRQ0, IRQ1, IRQ2, IRQ3, } },
-};
-
-static struct intc_prio_reg irq3210_prio_registers[] __initdata = {
-	{ 0xFF802010, 0, 32, 4, /* INTPRI */
-	{ IRQ0, IRQ1, IRQ2, IRQ3, } },
-};
-
-static DECLARE_INTC_DESC_ACK(intc_desc_irq3210, "sh7734-irq3210",
-	irq3210_vectors, NULL,
-	irq3210_mask_registers, irq3210_prio_registers,
-	irq3210_sense_registers, irq3210_ack_registers);
-
-/* External interrupt pins in IRL mode */
-
-static struct intc_vect vectors_irl3210[] __initdata = {
-	INTC_VECT(IRL0_LLLL, 0x200), INTC_VECT(IRL0_LLLH, 0x220),
-	INTC_VECT(IRL0_LLHL, 0x240), INTC_VECT(IRL0_LLHH, 0x260),
-	INTC_VECT(IRL0_LHLL, 0x280), INTC_VECT(IRL0_LHLH, 0x2a0),
-	INTC_VECT(IRL0_LHHL, 0x2c0), INTC_VECT(IRL0_LHHH, 0x2e0),
-	INTC_VECT(IRL0_HLLL, 0x300), INTC_VECT(IRL0_HLLH, 0x320),
-	INTC_VECT(IRL0_HLHL, 0x340), INTC_VECT(IRL0_HLHH, 0x360),
-	INTC_VECT(IRL0_HHLL, 0x380), INTC_VECT(IRL0_HHLH, 0x3a0),
-	INTC_VECT(IRL0_HHHL, 0x3c0),
-};
-
-static DECLARE_INTC_DESC(intc_desc_irl3210, "sh7734-irl3210",
-	vectors_irl3210, NULL, mask_registers, NULL, NULL);
-
-#define INTC_ICR0		0xFF802000
-#define INTC_INTMSK0    0xFF802044
-#define INTC_INTMSK1    0xFF802048
-#define INTC_INTMSKCLR0 0xFF802064
-#define INTC_INTMSKCLR1 0xFF802068
-
-void __init plat_irq_setup(void)
-{
-	/* disable IRQ3-0 */
-	__raw_writel(0xF0000000, INTC_INTMSK0);
-
-	/* disable IRL3-0 */
-	__raw_writel(0x80000000, INTC_INTMSK1);
-
-	/* select IRL mode for IRL3-0 */
-	__raw_writel(__raw_readl(INTC_ICR0) & ~0x00800000, INTC_ICR0);
-
-	/* disable holding function, ie enable "SH-4 Mode (LVLMODE)" */
-	__raw_writel(__raw_readl(INTC_ICR0) | 0x00200000, INTC_ICR0);
-
-	register_intc_controller(&intc_desc);
-}
-
-void __init plat_irq_setup_pins(int mode)
-{
-	switch (mode) {
-	case IRQ_MODE_IRQ3210:
-		/* select IRQ mode for IRL3-0 */
-		__raw_writel(__raw_readl(INTC_ICR0) | 0x00800000, INTC_ICR0);
-		register_intc_controller(&intc_desc_irq3210);
-		break;
-	case IRQ_MODE_IRL3210:
-		/* enable IRL0-3 but don't provide any masking */
-		__raw_writel(0x80000000, INTC_INTMSKCLR1);
-		__raw_writel(0xf0000000, INTC_INTMSKCLR0);
-		break;
-	case IRQ_MODE_IRL3210_MASK:
-		/* enable IRL0-3 and mask using cpu intc controller */
-		__raw_writel(0x80000000, INTC_INTMSKCLR0);
-		register_intc_controller(&intc_desc_irl3210);
-		break;
-	default:
-		BUG();
-	}
-}
diff --git a/arch/sh/kernel/cpu/sh4a/setup-sh7757.c b/arch/sh/kernel/cpu/sh4a/setup-sh7757.c
deleted file mode 100644
index 67e330b7ea4621..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/setup-sh7757.c
+++ /dev/null
@@ -1,1242 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7757 Setup
- *
- * Copyright (C) 2009, 2011  Renesas Solutions Corp.
- *
- *  based on setup-sh7785.c : Copyright (C) 2007  Paul Mundt
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/serial_sci.h>
-#include <linux/io.h>
-#include <linux/mm.h>
-#include <linux/dma-mapping.h>
-#include <linux/sh_timer.h>
-#include <linux/sh_dma.h>
-#include <linux/sh_intc.h>
-#include <linux/usb/ohci_pdriver.h>
-#include <cpu/dma-register.h>
-#include <cpu/sh7757.h>
-#include <asm/platform_early.h>
-
-static struct plat_sci_port scif2_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif2_resources[] = {
-	DEFINE_RES_MEM(0xfe4b0000, 0x100),		/* SCIF2 */
-	DEFINE_RES_IRQ(evt2irq(0x700)),
-};
-
-static struct platform_device scif2_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif2_resources,
-	.num_resources	= ARRAY_SIZE(scif2_resources),
-	.dev		= {
-		.platform_data	= &scif2_platform_data,
-	},
-};
-
-static struct plat_sci_port scif3_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif3_resources[] = {
-	DEFINE_RES_MEM(0xfe4c0000, 0x100),		/* SCIF3 */
-	DEFINE_RES_IRQ(evt2irq(0xb80)),
-};
-
-static struct platform_device scif3_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif3_resources,
-	.num_resources	= ARRAY_SIZE(scif3_resources),
-	.dev		= {
-		.platform_data	= &scif3_platform_data,
-	},
-};
-
-static struct plat_sci_port scif4_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif4_resources[] = {
-	DEFINE_RES_MEM(0xfe4d0000, 0x100),		/* SCIF4 */
-	DEFINE_RES_IRQ(evt2irq(0xf00)),
-};
-
-static struct platform_device scif4_device = {
-	.name		= "sh-sci",
-	.id		= 2,
-	.resource	= scif4_resources,
-	.num_resources	= ARRAY_SIZE(scif4_resources),
-	.dev		= {
-		.platform_data	= &scif4_platform_data,
-	},
-};
-
-static struct sh_timer_config tmu0_platform_data = {
-	.channels_mask = 3,
-};
-
-static struct resource tmu0_resources[] = {
-	DEFINE_RES_MEM(0xfe430000, 0x20),
-	DEFINE_RES_IRQ(evt2irq(0x580)),
-	DEFINE_RES_IRQ(evt2irq(0x5a0)),
-};
-
-static struct platform_device tmu0_device = {
-	.name		= "sh-tmu",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &tmu0_platform_data,
-	},
-	.resource	= tmu0_resources,
-	.num_resources	= ARRAY_SIZE(tmu0_resources),
-};
-
-static struct resource spi0_resources[] = {
-	[0] = {
-		.start	= 0xfe002000,
-		.end	= 0xfe0020ff,
-		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_32BIT,
-	},
-	[1] = {
-		.start	= evt2irq(0xcc0),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-/* DMA */
-static const struct sh_dmae_slave_config sh7757_dmae0_slaves[] = {
-	{
-		.slave_id	= SHDMA_SLAVE_SDHI_TX,
-		.addr		= 0x1fe50030,
-		.chcr		= SM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_16BIT),
-		.mid_rid	= 0xc5,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_SDHI_RX,
-		.addr		= 0x1fe50030,
-		.chcr		= DM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_16BIT),
-		.mid_rid	= 0xc6,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_MMCIF_TX,
-		.addr		= 0x1fcb0034,
-		.chcr		= SM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_32BIT),
-		.mid_rid	= 0xd3,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_MMCIF_RX,
-		.addr		= 0x1fcb0034,
-		.chcr		= DM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_32BIT),
-		.mid_rid	= 0xd7,
-	},
-};
-
-static const struct sh_dmae_slave_config sh7757_dmae1_slaves[] = {
-	{
-		.slave_id	= SHDMA_SLAVE_SCIF2_TX,
-		.addr		= 0x1f4b000c,
-		.chcr		= SM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x21,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_SCIF2_RX,
-		.addr		= 0x1f4b0014,
-		.chcr		= DM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x22,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_SCIF3_TX,
-		.addr		= 0x1f4c000c,
-		.chcr		= SM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x29,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_SCIF3_RX,
-		.addr		= 0x1f4c0014,
-		.chcr		= DM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x2a,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_SCIF4_TX,
-		.addr		= 0x1f4d000c,
-		.chcr		= SM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x41,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_SCIF4_RX,
-		.addr		= 0x1f4d0014,
-		.chcr		= DM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x42,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_RSPI_TX,
-		.addr		= 0xfe480004,
-		.chcr		= SM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_16BIT),
-		.mid_rid	= 0xc1,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_RSPI_RX,
-		.addr		= 0xfe480004,
-		.chcr		= DM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_16BIT),
-		.mid_rid	= 0xc2,
-	},
-};
-
-static const struct sh_dmae_slave_config sh7757_dmae2_slaves[] = {
-	{
-		.slave_id	= SHDMA_SLAVE_RIIC0_TX,
-		.addr		= 0x1e500012,
-		.chcr		= SM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x21,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_RIIC0_RX,
-		.addr		= 0x1e500013,
-		.chcr		= DM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x22,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_RIIC1_TX,
-		.addr		= 0x1e510012,
-		.chcr		= SM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x29,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_RIIC1_RX,
-		.addr		= 0x1e510013,
-		.chcr		= DM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x2a,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_RIIC2_TX,
-		.addr		= 0x1e520012,
-		.chcr		= SM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0xa1,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_RIIC2_RX,
-		.addr		= 0x1e520013,
-		.chcr		= DM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0xa2,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_RIIC3_TX,
-		.addr		= 0x1e530012,
-		.chcr		= SM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0xa9,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_RIIC3_RX,
-		.addr		= 0x1e530013,
-		.chcr		= DM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0xaf,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_RIIC4_TX,
-		.addr		= 0x1e540012,
-		.chcr		= SM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0xc5,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_RIIC4_RX,
-		.addr		= 0x1e540013,
-		.chcr		= DM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0xc6,
-	},
-};
-
-static const struct sh_dmae_slave_config sh7757_dmae3_slaves[] = {
-	{
-		.slave_id	= SHDMA_SLAVE_RIIC5_TX,
-		.addr		= 0x1e550012,
-		.chcr		= SM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x21,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_RIIC5_RX,
-		.addr		= 0x1e550013,
-		.chcr		= DM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x22,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_RIIC6_TX,
-		.addr		= 0x1e560012,
-		.chcr		= SM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x29,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_RIIC6_RX,
-		.addr		= 0x1e560013,
-		.chcr		= DM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x2a,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_RIIC7_TX,
-		.addr		= 0x1e570012,
-		.chcr		= SM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x41,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_RIIC7_RX,
-		.addr		= 0x1e570013,
-		.chcr		= DM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x42,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_RIIC8_TX,
-		.addr		= 0x1e580012,
-		.chcr		= SM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x45,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_RIIC8_RX,
-		.addr		= 0x1e580013,
-		.chcr		= DM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x46,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_RIIC9_TX,
-		.addr		= 0x1e590012,
-		.chcr		= SM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x51,
-	},
-	{
-		.slave_id	= SHDMA_SLAVE_RIIC9_RX,
-		.addr		= 0x1e590013,
-		.chcr		= DM_INC | RS_ERS | 0x40000000 |
-				  TS_INDEX2VAL(XMIT_SZ_8BIT),
-		.mid_rid	= 0x52,
-	},
-};
-
-static const struct sh_dmae_channel sh7757_dmae_channels[] = {
-	{
-		.offset = 0,
-		.dmars = 0,
-		.dmars_bit = 0,
-	}, {
-		.offset = 0x10,
-		.dmars = 0,
-		.dmars_bit = 8,
-	}, {
-		.offset = 0x20,
-		.dmars = 4,
-		.dmars_bit = 0,
-	}, {
-		.offset = 0x30,
-		.dmars = 4,
-		.dmars_bit = 8,
-	}, {
-		.offset = 0x50,
-		.dmars = 8,
-		.dmars_bit = 0,
-	}, {
-		.offset = 0x60,
-		.dmars = 8,
-		.dmars_bit = 8,
-	}
-};
-
-static const unsigned int ts_shift[] = TS_SHIFT;
-
-static struct sh_dmae_pdata dma0_platform_data = {
-	.slave		= sh7757_dmae0_slaves,
-	.slave_num	= ARRAY_SIZE(sh7757_dmae0_slaves),
-	.channel	= sh7757_dmae_channels,
-	.channel_num	= ARRAY_SIZE(sh7757_dmae_channels),
-	.ts_low_shift	= CHCR_TS_LOW_SHIFT,
-	.ts_low_mask	= CHCR_TS_LOW_MASK,
-	.ts_high_shift	= CHCR_TS_HIGH_SHIFT,
-	.ts_high_mask	= CHCR_TS_HIGH_MASK,
-	.ts_shift	= ts_shift,
-	.ts_shift_num	= ARRAY_SIZE(ts_shift),
-	.dmaor_init	= DMAOR_INIT,
-};
-
-static struct sh_dmae_pdata dma1_platform_data = {
-	.slave		= sh7757_dmae1_slaves,
-	.slave_num	= ARRAY_SIZE(sh7757_dmae1_slaves),
-	.channel	= sh7757_dmae_channels,
-	.channel_num	= ARRAY_SIZE(sh7757_dmae_channels),
-	.ts_low_shift	= CHCR_TS_LOW_SHIFT,
-	.ts_low_mask	= CHCR_TS_LOW_MASK,
-	.ts_high_shift	= CHCR_TS_HIGH_SHIFT,
-	.ts_high_mask	= CHCR_TS_HIGH_MASK,
-	.ts_shift	= ts_shift,
-	.ts_shift_num	= ARRAY_SIZE(ts_shift),
-	.dmaor_init	= DMAOR_INIT,
-};
-
-static struct sh_dmae_pdata dma2_platform_data = {
-	.slave		= sh7757_dmae2_slaves,
-	.slave_num	= ARRAY_SIZE(sh7757_dmae2_slaves),
-	.channel	= sh7757_dmae_channels,
-	.channel_num	= ARRAY_SIZE(sh7757_dmae_channels),
-	.ts_low_shift	= CHCR_TS_LOW_SHIFT,
-	.ts_low_mask	= CHCR_TS_LOW_MASK,
-	.ts_high_shift	= CHCR_TS_HIGH_SHIFT,
-	.ts_high_mask	= CHCR_TS_HIGH_MASK,
-	.ts_shift	= ts_shift,
-	.ts_shift_num	= ARRAY_SIZE(ts_shift),
-	.dmaor_init	= DMAOR_INIT,
-};
-
-static struct sh_dmae_pdata dma3_platform_data = {
-	.slave		= sh7757_dmae3_slaves,
-	.slave_num	= ARRAY_SIZE(sh7757_dmae3_slaves),
-	.channel	= sh7757_dmae_channels,
-	.channel_num	= ARRAY_SIZE(sh7757_dmae_channels),
-	.ts_low_shift	= CHCR_TS_LOW_SHIFT,
-	.ts_low_mask	= CHCR_TS_LOW_MASK,
-	.ts_high_shift	= CHCR_TS_HIGH_SHIFT,
-	.ts_high_mask	= CHCR_TS_HIGH_MASK,
-	.ts_shift	= ts_shift,
-	.ts_shift_num	= ARRAY_SIZE(ts_shift),
-	.dmaor_init	= DMAOR_INIT,
-};
-
-/* channel 0 to 5 */
-static struct resource sh7757_dmae0_resources[] = {
-	[0] = {
-		/* Channel registers and DMAOR */
-		.start	= 0xff608020,
-		.end	= 0xff60808f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* DMARSx */
-		.start	= 0xff609000,
-		.end	= 0xff60900b,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "error_irq",
-		.start	= evt2irq(0x640),
-		.end	= evt2irq(0x640),
-		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_SHAREABLE,
-	},
-};
-
-/* channel 6 to 11 */
-static struct resource sh7757_dmae1_resources[] = {
-	[0] = {
-		/* Channel registers and DMAOR */
-		.start	= 0xff618020,
-		.end	= 0xff61808f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* DMARSx */
-		.start	= 0xff619000,
-		.end	= 0xff61900b,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "error_irq",
-		.start	= evt2irq(0x640),
-		.end	= evt2irq(0x640),
-		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_SHAREABLE,
-	},
-	{
-		/* IRQ for channels 4 */
-		.start	= evt2irq(0x7c0),
-		.end	= evt2irq(0x7c0),
-		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_SHAREABLE,
-	},
-	{
-		/* IRQ for channels 5 */
-		.start	= evt2irq(0x7c0),
-		.end	= evt2irq(0x7c0),
-		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_SHAREABLE,
-	},
-	{
-		/* IRQ for channels 6 */
-		.start	= evt2irq(0xd00),
-		.end	= evt2irq(0xd00),
-		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_SHAREABLE,
-	},
-	{
-		/* IRQ for channels 7 */
-		.start	= evt2irq(0xd00),
-		.end	= evt2irq(0xd00),
-		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_SHAREABLE,
-	},
-	{
-		/* IRQ for channels 8 */
-		.start	= evt2irq(0xd00),
-		.end	= evt2irq(0xd00),
-		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_SHAREABLE,
-	},
-	{
-		/* IRQ for channels 9 */
-		.start	= evt2irq(0xd00),
-		.end	= evt2irq(0xd00),
-		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_SHAREABLE,
-	},
-	{
-		/* IRQ for channels 10 */
-		.start	= evt2irq(0xd00),
-		.end	= evt2irq(0xd00),
-		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_SHAREABLE,
-	},
-	{
-		/* IRQ for channels 11 */
-		.start	= evt2irq(0xd00),
-		.end	= evt2irq(0xd00),
-		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_SHAREABLE,
-	},
-};
-
-/* channel 12 to 17 */
-static struct resource sh7757_dmae2_resources[] = {
-	[0] = {
-		/* Channel registers and DMAOR */
-		.start	= 0xff708020,
-		.end	= 0xff70808f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* DMARSx */
-		.start	= 0xff709000,
-		.end	= 0xff70900b,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "error_irq",
-		.start	= evt2irq(0x2a60),
-		.end	= evt2irq(0x2a60),
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		/* IRQ for channels 12 to 16 */
-		.start	= evt2irq(0x2400),
-		.end	= evt2irq(0x2480),
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		/* IRQ for channel 17 */
-		.start	= evt2irq(0x24e0),
-		.end	= evt2irq(0x24e0),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-/* channel 18 to 23 */
-static struct resource sh7757_dmae3_resources[] = {
-	[0] = {
-		/* Channel registers and DMAOR */
-		.start	= 0xff718020,
-		.end	= 0xff71808f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* DMARSx */
-		.start	= 0xff719000,
-		.end	= 0xff71900b,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "error_irq",
-		.start	= evt2irq(0x2a80),
-		.end	= evt2irq(0x2a80),
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		/* IRQ for channels 18 to 22 */
-		.start	= evt2irq(0x2500),
-		.end	= evt2irq(0x2580),
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		/* IRQ for channel 23 */
-		.start	= evt2irq(0x2600),
-		.end	= evt2irq(0x2600),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device dma0_device = {
-	.name           = "sh-dma-engine",
-	.id             = 0,
-	.resource	= sh7757_dmae0_resources,
-	.num_resources	= ARRAY_SIZE(sh7757_dmae0_resources),
-	.dev            = {
-		.platform_data	= &dma0_platform_data,
-	},
-};
-
-static struct platform_device dma1_device = {
-	.name		= "sh-dma-engine",
-	.id		= 1,
-	.resource	= sh7757_dmae1_resources,
-	.num_resources	= ARRAY_SIZE(sh7757_dmae1_resources),
-	.dev		= {
-		.platform_data	= &dma1_platform_data,
-	},
-};
-
-static struct platform_device dma2_device = {
-	.name		= "sh-dma-engine",
-	.id		= 2,
-	.resource	= sh7757_dmae2_resources,
-	.num_resources	= ARRAY_SIZE(sh7757_dmae2_resources),
-	.dev		= {
-		.platform_data	= &dma2_platform_data,
-	},
-};
-
-static struct platform_device dma3_device = {
-	.name		= "sh-dma-engine",
-	.id		= 3,
-	.resource	= sh7757_dmae3_resources,
-	.num_resources	= ARRAY_SIZE(sh7757_dmae3_resources),
-	.dev		= {
-		.platform_data	= &dma3_platform_data,
-	},
-};
-
-static struct platform_device spi0_device = {
-	.name	= "sh_spi",
-	.id	= 0,
-	.dev	= {
-		.dma_mask		= NULL,
-		.coherent_dma_mask	= 0xffffffff,
-	},
-	.num_resources	= ARRAY_SIZE(spi0_resources),
-	.resource	= spi0_resources,
-};
-
-static struct resource spi1_resources[] = {
-	{
-		.start	= 0xffd8ee70,
-		.end	= 0xffd8eeff,
-		.flags	= IORESOURCE_MEM | IORESOURCE_MEM_8BIT,
-	},
-	{
-		.start	= evt2irq(0x8c0),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device spi1_device = {
-	.name	= "sh_spi",
-	.id	= 1,
-	.num_resources	= ARRAY_SIZE(spi1_resources),
-	.resource	= spi1_resources,
-};
-
-static struct resource rspi_resources[] = {
-	{
-		.start	= 0xfe480000,
-		.end	= 0xfe4800ff,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= evt2irq(0x1d80),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device rspi_device = {
-	.name	= "rspi",
-	.id	= 2,
-	.num_resources	= ARRAY_SIZE(rspi_resources),
-	.resource	= rspi_resources,
-};
-
-static struct resource usb_ehci_resources[] = {
-	[0] = {
-		.start	= 0xfe4f1000,
-		.end	= 0xfe4f10ff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0x920),
-		.end	= evt2irq(0x920),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device usb_ehci_device = {
-	.name		= "sh_ehci",
-	.id		= -1,
-	.dev = {
-		.dma_mask = &usb_ehci_device.dev.coherent_dma_mask,
-		.coherent_dma_mask = DMA_BIT_MASK(32),
-	},
-	.num_resources	= ARRAY_SIZE(usb_ehci_resources),
-	.resource	= usb_ehci_resources,
-};
-
-static struct resource usb_ohci_resources[] = {
-	[0] = {
-		.start	= 0xfe4f1800,
-		.end	= 0xfe4f18ff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0x920),
-		.end	= evt2irq(0x920),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct usb_ohci_pdata usb_ohci_pdata;
-
-static struct platform_device usb_ohci_device = {
-	.name		= "ohci-platform",
-	.id		= -1,
-	.dev = {
-		.dma_mask = &usb_ohci_device.dev.coherent_dma_mask,
-		.coherent_dma_mask = DMA_BIT_MASK(32),
-		.platform_data	= &usb_ohci_pdata,
-	},
-	.num_resources	= ARRAY_SIZE(usb_ohci_resources),
-	.resource	= usb_ohci_resources,
-};
-
-static struct platform_device *sh7757_devices[] __initdata = {
-	&scif2_device,
-	&scif3_device,
-	&scif4_device,
-	&tmu0_device,
-	&dma0_device,
-	&dma1_device,
-	&dma2_device,
-	&dma3_device,
-	&spi0_device,
-	&spi1_device,
-	&rspi_device,
-	&usb_ehci_device,
-	&usb_ohci_device,
-};
-
-static int __init sh7757_devices_setup(void)
-{
-	return platform_add_devices(sh7757_devices,
-				    ARRAY_SIZE(sh7757_devices));
-}
-arch_initcall(sh7757_devices_setup);
-
-static struct platform_device *sh7757_early_devices[] __initdata = {
-	&scif2_device,
-	&scif3_device,
-	&scif4_device,
-	&tmu0_device,
-};
-
-void __init plat_early_device_setup(void)
-{
-	sh_early_platform_add_devices(sh7757_early_devices,
-				   ARRAY_SIZE(sh7757_early_devices));
-}
-
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-
-	IRL0_LLLL, IRL0_LLLH, IRL0_LLHL, IRL0_LLHH,
-	IRL0_LHLL, IRL0_LHLH, IRL0_LHHL, IRL0_LHHH,
-	IRL0_HLLL, IRL0_HLLH, IRL0_HLHL, IRL0_HLHH,
-	IRL0_HHLL, IRL0_HHLH, IRL0_HHHL,
-
-	IRL4_LLLL, IRL4_LLLH, IRL4_LLHL, IRL4_LLHH,
-	IRL4_LHLL, IRL4_LHLH, IRL4_LHHL, IRL4_LHHH,
-	IRL4_HLLL, IRL4_HLLH, IRL4_HLHL, IRL4_HLHH,
-	IRL4_HHLL, IRL4_HHLH, IRL4_HHHL,
-	IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7,
-
-	SDHI, DVC,
-	IRQ8, IRQ9, IRQ11, IRQ10, IRQ12, IRQ13, IRQ14, IRQ15,
-	TMU0, TMU1, TMU2, TMU2_TICPI, TMU3, TMU4, TMU5,
-	HUDI,
-	ARC4,
-	DMAC0_5, DMAC6_7, DMAC8_11,
-	SCIF0, SCIF1, SCIF2, SCIF3, SCIF4,
-	USB0, USB1,
-	JMC,
-	SPI0, SPI1,
-	TMR01, TMR23, TMR45,
-	FRT,
-	LPC, LPC5, LPC6, LPC7, LPC8,
-	PECI0, PECI1, PECI2, PECI3, PECI4, PECI5,
-	ETHERC,
-	ADC0, ADC1,
-	SIM,
-	IIC0_0, IIC0_1, IIC0_2, IIC0_3,
-	IIC1_0, IIC1_1, IIC1_2, IIC1_3,
-	IIC2_0, IIC2_1, IIC2_2, IIC2_3,
-	IIC3_0, IIC3_1, IIC3_2, IIC3_3,
-	IIC4_0, IIC4_1, IIC4_2, IIC4_3,
-	IIC5_0, IIC5_1, IIC5_2, IIC5_3,
-	IIC6_0, IIC6_1, IIC6_2, IIC6_3,
-	IIC7_0, IIC7_1, IIC7_2, IIC7_3,
-	IIC8_0, IIC8_1, IIC8_2, IIC8_3,
-	IIC9_0, IIC9_1, IIC9_2, IIC9_3,
-	ONFICTL,
-	MMC1, MMC2,
-	ECCU,
-	PCIC,
-	G200,
-	RSPI,
-	SGPIO,
-	DMINT12, DMINT13, DMINT14, DMINT15, DMINT16, DMINT17, DMINT18, DMINT19,
-	DMINT20, DMINT21, DMINT22, DMINT23,
-	DDRECC,
-	TSIP,
-	PCIE_BRIDGE,
-	WDT0B, WDT1B, WDT2B, WDT3B, WDT4B, WDT5B, WDT6B, WDT7B, WDT8B,
-	GETHER0, GETHER1, GETHER2,
-	PBIA, PBIB, PBIC,
-	DMAE2, DMAE3,
-	SERMUX2, SERMUX3,
-
-	/* interrupt groups */
-
-	TMU012, TMU345,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_VECT(SDHI, 0x480), INTC_VECT(SDHI, 0x04a0),
-	INTC_VECT(SDHI, 0x4c0),
-	INTC_VECT(DVC, 0x4e0),
-	INTC_VECT(IRQ8, 0x500), INTC_VECT(IRQ9, 0x520),
-	INTC_VECT(IRQ10, 0x540),
-	INTC_VECT(TMU0, 0x580), INTC_VECT(TMU1, 0x5a0),
-	INTC_VECT(TMU2, 0x5c0), INTC_VECT(TMU2_TICPI, 0x5e0),
-	INTC_VECT(HUDI, 0x600),
-	INTC_VECT(ARC4, 0x620),
-	INTC_VECT(DMAC0_5, 0x640), INTC_VECT(DMAC0_5, 0x660),
-	INTC_VECT(DMAC0_5, 0x680), INTC_VECT(DMAC0_5, 0x6a0),
-	INTC_VECT(DMAC0_5, 0x6c0),
-	INTC_VECT(IRQ11, 0x6e0),
-	INTC_VECT(SCIF2, 0x700), INTC_VECT(SCIF2, 0x720),
-	INTC_VECT(SCIF2, 0x740), INTC_VECT(SCIF2, 0x760),
-	INTC_VECT(DMAC0_5, 0x780), INTC_VECT(DMAC0_5, 0x7a0),
-	INTC_VECT(DMAC6_7, 0x7c0), INTC_VECT(DMAC6_7, 0x7e0),
-	INTC_VECT(USB0, 0x840),
-	INTC_VECT(IRQ12, 0x880),
-	INTC_VECT(JMC, 0x8a0),
-	INTC_VECT(SPI1, 0x8c0),
-	INTC_VECT(IRQ13, 0x8e0), INTC_VECT(IRQ14, 0x900),
-	INTC_VECT(USB1, 0x920),
-	INTC_VECT(TMR01, 0xa00), INTC_VECT(TMR23, 0xa20),
-	INTC_VECT(TMR45, 0xa40),
-	INTC_VECT(FRT, 0xa80),
-	INTC_VECT(LPC, 0xaa0), INTC_VECT(LPC, 0xac0),
-	INTC_VECT(LPC, 0xae0), INTC_VECT(LPC, 0xb00),
-	INTC_VECT(LPC, 0xb20),
-	INTC_VECT(SCIF0, 0xb40), INTC_VECT(SCIF1, 0xb60),
-	INTC_VECT(SCIF3, 0xb80), INTC_VECT(SCIF3, 0xba0),
-	INTC_VECT(SCIF3, 0xbc0), INTC_VECT(SCIF3, 0xbe0),
-	INTC_VECT(PECI0, 0xc00), INTC_VECT(PECI1, 0xc20),
-	INTC_VECT(PECI2, 0xc40),
-	INTC_VECT(IRQ15, 0xc60),
-	INTC_VECT(ETHERC, 0xc80), INTC_VECT(ETHERC, 0xca0),
-	INTC_VECT(SPI0, 0xcc0),
-	INTC_VECT(ADC1, 0xce0),
-	INTC_VECT(DMAC8_11, 0xd00), INTC_VECT(DMAC8_11, 0xd20),
-	INTC_VECT(DMAC8_11, 0xd40), INTC_VECT(DMAC8_11, 0xd60),
-	INTC_VECT(SIM, 0xd80), INTC_VECT(SIM, 0xda0),
-	INTC_VECT(SIM, 0xdc0), INTC_VECT(SIM, 0xde0),
-	INTC_VECT(TMU3, 0xe00), INTC_VECT(TMU4, 0xe20),
-	INTC_VECT(TMU5, 0xe40),
-	INTC_VECT(ADC0, 0xe60),
-	INTC_VECT(SCIF4, 0xf00), INTC_VECT(SCIF4, 0xf20),
-	INTC_VECT(SCIF4, 0xf40), INTC_VECT(SCIF4, 0xf60),
-	INTC_VECT(IIC0_0, 0x1400), INTC_VECT(IIC0_1, 0x1420),
-	INTC_VECT(IIC0_2, 0x1440), INTC_VECT(IIC0_3, 0x1460),
-	INTC_VECT(IIC1_0, 0x1480), INTC_VECT(IIC1_1, 0x14e0),
-	INTC_VECT(IIC1_2, 0x1500), INTC_VECT(IIC1_3, 0x1520),
-	INTC_VECT(IIC2_0, 0x1540), INTC_VECT(IIC2_1, 0x1560),
-	INTC_VECT(IIC2_2, 0x1580), INTC_VECT(IIC2_3, 0x1600),
-	INTC_VECT(IIC3_0, 0x1620), INTC_VECT(IIC3_1, 0x1640),
-	INTC_VECT(IIC3_2, 0x16e0), INTC_VECT(IIC3_3, 0x1700),
-	INTC_VECT(IIC4_0, 0x17c0), INTC_VECT(IIC4_1, 0x1800),
-	INTC_VECT(IIC4_2, 0x1820), INTC_VECT(IIC4_3, 0x1840),
-	INTC_VECT(IIC5_0, 0x1860), INTC_VECT(IIC5_1, 0x1880),
-	INTC_VECT(IIC5_2, 0x18a0), INTC_VECT(IIC5_3, 0x18c0),
-	INTC_VECT(IIC6_0, 0x18e0), INTC_VECT(IIC6_1, 0x1900),
-	INTC_VECT(IIC6_2, 0x1920),
-	INTC_VECT(ONFICTL, 0x1960),
-	INTC_VECT(IIC6_3, 0x1980),
-	INTC_VECT(IIC7_0, 0x19a0), INTC_VECT(IIC7_1, 0x1a00),
-	INTC_VECT(IIC7_2, 0x1a20), INTC_VECT(IIC7_3, 0x1a40),
-	INTC_VECT(IIC8_0, 0x1a60), INTC_VECT(IIC8_1, 0x1a80),
-	INTC_VECT(IIC8_2, 0x1aa0), INTC_VECT(IIC8_3, 0x1b40),
-	INTC_VECT(IIC9_0, 0x1b60), INTC_VECT(IIC9_1, 0x1b80),
-	INTC_VECT(IIC9_2, 0x1c00), INTC_VECT(IIC9_3, 0x1c20),
-	INTC_VECT(MMC1, 0x1c60), INTC_VECT(MMC2, 0x1c80),
-	INTC_VECT(ECCU, 0x1cc0),
-	INTC_VECT(PCIC, 0x1ce0),
-	INTC_VECT(G200, 0x1d00),
-	INTC_VECT(RSPI, 0x1d80), INTC_VECT(RSPI, 0x1da0),
-	INTC_VECT(RSPI, 0x1dc0), INTC_VECT(RSPI, 0x1de0),
-	INTC_VECT(PECI3, 0x1ec0), INTC_VECT(PECI4, 0x1ee0),
-	INTC_VECT(PECI5, 0x1f00),
-	INTC_VECT(SGPIO, 0x1f80), INTC_VECT(SGPIO, 0x1fa0),
-	INTC_VECT(SGPIO, 0x1fc0),
-	INTC_VECT(DMINT12, 0x2400), INTC_VECT(DMINT13, 0x2420),
-	INTC_VECT(DMINT14, 0x2440), INTC_VECT(DMINT15, 0x2460),
-	INTC_VECT(DMINT16, 0x2480), INTC_VECT(DMINT17, 0x24e0),
-	INTC_VECT(DMINT18, 0x2500), INTC_VECT(DMINT19, 0x2520),
-	INTC_VECT(DMINT20, 0x2540), INTC_VECT(DMINT21, 0x2560),
-	INTC_VECT(DMINT22, 0x2580), INTC_VECT(DMINT23, 0x2600),
-	INTC_VECT(DDRECC, 0x2620),
-	INTC_VECT(TSIP, 0x2640),
-	INTC_VECT(PCIE_BRIDGE, 0x27c0),
-	INTC_VECT(WDT0B, 0x2800), INTC_VECT(WDT1B, 0x2820),
-	INTC_VECT(WDT2B, 0x2840), INTC_VECT(WDT3B, 0x2860),
-	INTC_VECT(WDT4B, 0x2880), INTC_VECT(WDT5B, 0x28a0),
-	INTC_VECT(WDT6B, 0x28c0), INTC_VECT(WDT7B, 0x28e0),
-	INTC_VECT(WDT8B, 0x2900),
-	INTC_VECT(GETHER0, 0x2960), INTC_VECT(GETHER1, 0x2980),
-	INTC_VECT(GETHER2, 0x29a0),
-	INTC_VECT(PBIA, 0x2a00), INTC_VECT(PBIB, 0x2a20),
-	INTC_VECT(PBIC, 0x2a40),
-	INTC_VECT(DMAE2, 0x2a60), INTC_VECT(DMAE3, 0x2a80),
-	INTC_VECT(SERMUX2, 0x2aa0), INTC_VECT(SERMUX3, 0x2b40),
-	INTC_VECT(LPC5, 0x2b60), INTC_VECT(LPC6, 0x2b80),
-	INTC_VECT(LPC7, 0x2c00), INTC_VECT(LPC8, 0x2c20),
-};
-
-static struct intc_group groups[] __initdata = {
-	INTC_GROUP(TMU012, TMU0, TMU1, TMU2, TMU2_TICPI),
-	INTC_GROUP(TMU345, TMU3, TMU4, TMU5),
-};
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xffd00044, 0xffd00064, 32, /* INTMSK0 / INTMSKCLR0 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-
-	{ 0xffd40080, 0xffd40084, 32, /* INTMSK2 / INTMSKCLR2 */
-	  { IRL0_LLLL, IRL0_LLLH, IRL0_LLHL, IRL0_LLHH,
-	    IRL0_LHLL, IRL0_LHLH, IRL0_LHHL, IRL0_LHHH,
-	    IRL0_HLLL, IRL0_HLLH, IRL0_HLHL, IRL0_HLHH,
-	    IRL0_HHLL, IRL0_HHLH, IRL0_HHHL, 0,
-	    IRL4_LLLL, IRL4_LLLH, IRL4_LLHL, IRL4_LLHH,
-	    IRL4_LHLL, IRL4_LHLH, IRL4_LHHL, IRL4_LHHH,
-	    IRL4_HLLL, IRL4_HLLH, IRL4_HLHL, IRL4_HLHH,
-	    IRL4_HHLL, IRL4_HHLH, IRL4_HHHL, 0, } },
-
-	{ 0xffd40038, 0xffd4003c, 32, /* INT2MSKR / INT2MSKCR */
-	  { 0, 0, 0, 0, 0, 0, 0, 0,
-	    0, DMAC8_11, 0, PECI0, LPC, FRT, 0, TMR45,
-	    TMR23, TMR01, 0, 0, 0, 0, 0, DMAC0_5,
-	    HUDI, 0, 0, SCIF3, SCIF2, SDHI, TMU345, TMU012
-	     } },
-
-	{ 0xffd400d0, 0xffd400d4, 32, /* INT2MSKR1 / INT2MSKCR1 */
-	  { IRQ15, IRQ14, IRQ13, IRQ12, IRQ11, IRQ10, SCIF4, ETHERC,
-	    IRQ9, IRQ8, SCIF1, SCIF0, USB0, 0, 0, USB1,
-	    ADC1, 0, DMAC6_7, ADC0, SPI0, SIM, PECI2, PECI1,
-	    ARC4, 0, SPI1, JMC, 0, 0, 0, DVC
-	     } },
-
-	{ 0xffd10038, 0xffd1003c, 32, /* INT2MSKR2 / INT2MSKCR2 */
-	  { IIC4_1, IIC4_2, IIC5_0, ONFICTL, 0, 0, SGPIO, 0,
-	    0, G200, 0, IIC9_2, IIC8_2, IIC8_1, IIC8_0, IIC7_3,
-	    IIC7_2, IIC7_1, IIC6_3, IIC0_0, IIC0_1, IIC0_2, IIC0_3, IIC3_1,
-	    IIC2_3, 0, IIC2_1, IIC9_1, IIC3_3, IIC1_0, 0, IIC2_2
-	     } },
-
-	{ 0xffd100d0, 0xffd100d4, 32, /* INT2MSKR3 / INT2MSKCR3 */
-	  { MMC1, IIC6_1, IIC6_0, IIC5_1, IIC3_2, IIC2_0, PECI5, MMC2,
-	    IIC1_3, IIC1_2, IIC9_0, IIC8_3, IIC4_3, IIC7_0, 0, IIC6_2,
-	    PCIC, 0, IIC4_0, 0, ECCU, RSPI, 0, IIC9_3,
-	    IIC3_0, 0, IIC5_3, IIC5_2, 0, 0, 0, IIC1_1
-	     } },
-
-	{ 0xffd20038, 0xffd2003c, 32, /* INT2MSKR4 / INT2MSKCR4 */
-	  { WDT0B, WDT1B, WDT3B, GETHER0, 0, 0, 0, 0,
-	    0, 0, 0, LPC7, SERMUX2, DMAE3, DMAE2, PBIC,
-	    PBIB, PBIA, GETHER1, DMINT12, DMINT13, DMINT14, DMINT15, TSIP,
-	    DMINT23, 0, DMINT21, LPC6, 0, DMINT16, 0, DMINT22
-	     } },
-
-	{ 0xffd200d0, 0xffd200d4, 32, /* INT2MSKR5 / INT2MSKCR5 */
-	  { 0, WDT8B, WDT7B, WDT4B, 0, DMINT20, 0, 0,
-	    DMINT19, DMINT18, LPC5, SERMUX3, WDT2B, GETHER2, 0, 0,
-	    0, 0, PCIE_BRIDGE, 0, 0, 0, 0, LPC8,
-	    DDRECC, 0, WDT6B, WDT5B, 0, 0, 0, DMINT17
-	     } },
-};
-
-#define INTPRI		0xffd00010
-#define INT2PRI0	0xffd40000
-#define INT2PRI1	0xffd40004
-#define INT2PRI2	0xffd40008
-#define INT2PRI3	0xffd4000c
-#define INT2PRI4	0xffd40010
-#define INT2PRI5	0xffd40014
-#define INT2PRI6	0xffd40018
-#define INT2PRI7	0xffd4001c
-#define INT2PRI8	0xffd400a0
-#define INT2PRI9	0xffd400a4
-#define INT2PRI10	0xffd400a8
-#define INT2PRI11	0xffd400ac
-#define INT2PRI12	0xffd400b0
-#define INT2PRI13	0xffd400b4
-#define INT2PRI14	0xffd400b8
-#define INT2PRI15	0xffd400bc
-#define INT2PRI16	0xffd10000
-#define INT2PRI17	0xffd10004
-#define INT2PRI18	0xffd10008
-#define INT2PRI19	0xffd1000c
-#define INT2PRI20	0xffd10010
-#define INT2PRI21	0xffd10014
-#define INT2PRI22	0xffd10018
-#define INT2PRI23	0xffd1001c
-#define INT2PRI24	0xffd100a0
-#define INT2PRI25	0xffd100a4
-#define INT2PRI26	0xffd100a8
-#define INT2PRI27	0xffd100ac
-#define INT2PRI28	0xffd100b0
-#define INT2PRI29	0xffd100b4
-#define INT2PRI30	0xffd100b8
-#define INT2PRI31	0xffd100bc
-#define INT2PRI32	0xffd20000
-#define INT2PRI33	0xffd20004
-#define INT2PRI34	0xffd20008
-#define INT2PRI35	0xffd2000c
-#define INT2PRI36	0xffd20010
-#define INT2PRI37	0xffd20014
-#define INT2PRI38	0xffd20018
-#define INT2PRI39	0xffd2001c
-#define INT2PRI40	0xffd200a0
-#define INT2PRI41	0xffd200a4
-#define INT2PRI42	0xffd200a8
-#define INT2PRI43	0xffd200ac
-#define INT2PRI44	0xffd200b0
-#define INT2PRI45	0xffd200b4
-#define INT2PRI46	0xffd200b8
-#define INT2PRI47	0xffd200bc
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ INTPRI, 0, 32, 4, { IRQ0, IRQ1, IRQ2, IRQ3,
-			      IRQ4, IRQ5, IRQ6, IRQ7 } },
-
-	{ INT2PRI0, 0, 32, 8, { TMU0, TMU1, TMU2, TMU2_TICPI } },
-	{ INT2PRI1, 0, 32, 8, { TMU3, TMU4, TMU5, SDHI } },
-	{ INT2PRI2, 0, 32, 8, { SCIF2, SCIF3, 0, IRQ8 } },
-	{ INT2PRI3, 0, 32, 8, { HUDI, DMAC0_5, ADC0, IRQ9 } },
-	{ INT2PRI4, 0, 32, 8, { IRQ10, 0, TMR01, TMR23 } },
-	{ INT2PRI5, 0, 32, 8, { TMR45, 0, FRT, LPC } },
-	{ INT2PRI6, 0, 32, 8, { PECI0, ETHERC, DMAC8_11, 0 } },
-	{ INT2PRI7, 0, 32, 8, { SCIF4, 0, IRQ11, IRQ12 } },
-	{ INT2PRI8, 0, 32, 8, { 0, 0, 0, DVC } },
-	{ INT2PRI9, 0, 32, 8, { ARC4, 0, SPI1, JMC } },
-	{ INT2PRI10, 0, 32, 8, { SPI0, SIM, PECI2, PECI1 } },
-	{ INT2PRI11, 0, 32, 8, { ADC1, IRQ13, DMAC6_7, IRQ14 } },
-	{ INT2PRI12, 0, 32, 8, { USB0, 0, IRQ15, USB1 } },
-	{ INT2PRI13, 0, 32, 8, { 0, 0, SCIF1, SCIF0 } },
-
-	{ INT2PRI16, 0, 32, 8, { IIC2_2, 0, 0, 0 } },
-	{ INT2PRI17, 0, 32, 8, { 0, 0, 0, IIC1_0 } },
-	{ INT2PRI18, 0, 32, 8, { IIC3_3, IIC9_1, IIC2_1, IIC1_2 } },
-	{ INT2PRI19, 0, 32, 8, { IIC2_3, IIC3_1, 0, IIC1_3 } },
-	{ INT2PRI20, 0, 32, 8, { IIC2_0, IIC6_3, IIC7_1, IIC7_2 } },
-	{ INT2PRI21, 0, 32, 8, { IIC7_3, IIC8_0, IIC8_1, IIC8_2 } },
-	{ INT2PRI22, 0, 32, 8, { IIC9_2, MMC2, G200, 0 } },
-	{ INT2PRI23, 0, 32, 8, { PECI5, SGPIO, IIC3_2, IIC5_1 } },
-	{ INT2PRI24, 0, 32, 8, { PECI4, PECI3, 0, IIC1_1 } },
-	{ INT2PRI25, 0, 32, 8, { IIC3_0, 0, IIC5_3, IIC5_2 } },
-	{ INT2PRI26, 0, 32, 8, { ECCU, RSPI, 0, IIC9_3 } },
-	{ INT2PRI27, 0, 32, 8, { PCIC, IIC6_0, IIC4_0, IIC6_1 } },
-	{ INT2PRI28, 0, 32, 8, { IIC4_3, IIC7_0, MMC1, IIC6_2 } },
-	{ INT2PRI29, 0, 32, 8, { 0, 0, IIC9_0, IIC8_3 } },
-	{ INT2PRI30, 0, 32, 8, { IIC4_1, IIC4_2, IIC5_0, ONFICTL } },
-	{ INT2PRI31, 0, 32, 8, { IIC0_0, IIC0_1, IIC0_2, IIC0_3 } },
-	{ INT2PRI32, 0, 32, 8, { DMINT22, 0, 0, 0 } },
-	{ INT2PRI33, 0, 32, 8, { 0, 0, 0, DMINT16 } },
-	{ INT2PRI34, 0, 32, 8, { 0, LPC6, DMINT21, DMINT18 } },
-	{ INT2PRI35, 0, 32, 8, { DMINT23, TSIP, 0, DMINT19 } },
-	{ INT2PRI36, 0, 32, 8, { DMINT20, GETHER1, PBIA, PBIB } },
-	{ INT2PRI37, 0, 32, 8, { PBIC, DMAE2, DMAE3, SERMUX2 } },
-	{ INT2PRI38, 0, 32, 8, { LPC7, 0, 0, 0 } },
-	{ INT2PRI39, 0, 32, 8, { 0, 0, 0, WDT4B } },
-	{ INT2PRI40, 0, 32, 8, { 0, 0, 0, DMINT17 } },
-	{ INT2PRI41, 0, 32, 8, { DDRECC, 0, WDT6B, WDT5B } },
-	{ INT2PRI42, 0, 32, 8, { 0, 0, 0, LPC8 } },
-	{ INT2PRI43, 0, 32, 8, { 0, WDT7B, PCIE_BRIDGE, WDT8B } },
-	{ INT2PRI44, 0, 32, 8, { WDT2B, GETHER2, 0, 0 } },
-	{ INT2PRI45, 0, 32, 8, { 0, 0, LPC5, SERMUX3 } },
-	{ INT2PRI46, 0, 32, 8, { WDT0B, WDT1B, WDT3B, GETHER0 } },
-	{ INT2PRI47, 0, 32, 8, { DMINT12, DMINT13, DMINT14, DMINT15 } },
-};
-
-static struct intc_sense_reg sense_registers_irq8to15[] __initdata = {
-	{ 0xffd100f8, 32, 2, /* ICR2 */   { IRQ15, IRQ14, IRQ13, IRQ12,
-					    IRQ11, IRQ10, IRQ9, IRQ8 } },
-};
-
-static DECLARE_INTC_DESC(intc_desc, "sh7757", vectors, groups,
-			 mask_registers, prio_registers,
-			 sense_registers_irq8to15);
-
-/* Support for external interrupt pins in IRQ mode */
-static struct intc_vect vectors_irq0123[] __initdata = {
-	INTC_VECT(IRQ0, 0x200), INTC_VECT(IRQ1, 0x240),
-	INTC_VECT(IRQ2, 0x280), INTC_VECT(IRQ3, 0x2c0),
-};
-
-static struct intc_vect vectors_irq4567[] __initdata = {
-	INTC_VECT(IRQ4, 0x300), INTC_VECT(IRQ5, 0x340),
-	INTC_VECT(IRQ6, 0x380), INTC_VECT(IRQ7, 0x3c0),
-};
-
-static struct intc_sense_reg sense_registers[] __initdata = {
-	{ 0xffd0001c, 32, 2, /* ICR1 */   { IRQ0, IRQ1, IRQ2, IRQ3,
-					    IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_mask_reg ack_registers[] __initdata = {
-	{ 0xffd00024, 0, 32, /* INTREQ */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static DECLARE_INTC_DESC_ACK(intc_desc_irq0123, "sh7757-irq0123",
-			     vectors_irq0123, NULL, mask_registers,
-			     prio_registers, sense_registers, ack_registers);
-
-static DECLARE_INTC_DESC_ACK(intc_desc_irq4567, "sh7757-irq4567",
-			     vectors_irq4567, NULL, mask_registers,
-			     prio_registers, sense_registers, ack_registers);
-
-/* External interrupt pins in IRL mode */
-static struct intc_vect vectors_irl0123[] __initdata = {
-	INTC_VECT(IRL0_LLLL, 0x200), INTC_VECT(IRL0_LLLH, 0x220),
-	INTC_VECT(IRL0_LLHL, 0x240), INTC_VECT(IRL0_LLHH, 0x260),
-	INTC_VECT(IRL0_LHLL, 0x280), INTC_VECT(IRL0_LHLH, 0x2a0),
-	INTC_VECT(IRL0_LHHL, 0x2c0), INTC_VECT(IRL0_LHHH, 0x2e0),
-	INTC_VECT(IRL0_HLLL, 0x300), INTC_VECT(IRL0_HLLH, 0x320),
-	INTC_VECT(IRL0_HLHL, 0x340), INTC_VECT(IRL0_HLHH, 0x360),
-	INTC_VECT(IRL0_HHLL, 0x380), INTC_VECT(IRL0_HHLH, 0x3a0),
-	INTC_VECT(IRL0_HHHL, 0x3c0),
-};
-
-static struct intc_vect vectors_irl4567[] __initdata = {
-	INTC_VECT(IRL4_LLLL, 0x200), INTC_VECT(IRL4_LLLH, 0x220),
-	INTC_VECT(IRL4_LLHL, 0x240), INTC_VECT(IRL4_LLHH, 0x260),
-	INTC_VECT(IRL4_LHLL, 0x280), INTC_VECT(IRL4_LHLH, 0x2a0),
-	INTC_VECT(IRL4_LHHL, 0x2c0), INTC_VECT(IRL4_LHHH, 0x2e0),
-	INTC_VECT(IRL4_HLLL, 0x300), INTC_VECT(IRL4_HLLH, 0x320),
-	INTC_VECT(IRL4_HLHL, 0x340), INTC_VECT(IRL4_HLHH, 0x360),
-	INTC_VECT(IRL4_HHLL, 0x380), INTC_VECT(IRL4_HHLH, 0x3a0),
-	INTC_VECT(IRL4_HHHL, 0x3c0),
-};
-
-static DECLARE_INTC_DESC(intc_desc_irl0123, "sh7757-irl0123", vectors_irl0123,
-			 NULL, mask_registers, NULL, NULL);
-
-static DECLARE_INTC_DESC(intc_desc_irl4567, "sh7757-irl4567", vectors_irl4567,
-			 NULL, mask_registers, NULL, NULL);
-
-#define INTC_ICR0	0xffd00000
-#define INTC_INTMSK0	0xffd00044
-#define INTC_INTMSK1	0xffd00048
-#define INTC_INTMSK2	0xffd40080
-#define INTC_INTMSKCLR1	0xffd00068
-#define INTC_INTMSKCLR2	0xffd40084
-
-void __init plat_irq_setup(void)
-{
-	/* disable IRQ3-0 + IRQ7-4 */
-	__raw_writel(0xff000000, INTC_INTMSK0);
-
-	/* disable IRL3-0 + IRL7-4 */
-	__raw_writel(0xc0000000, INTC_INTMSK1);
-	__raw_writel(0xfffefffe, INTC_INTMSK2);
-
-	/* select IRL mode for IRL3-0 + IRL7-4 */
-	__raw_writel(__raw_readl(INTC_ICR0) & ~0x00c00000, INTC_ICR0);
-
-	/* disable holding function, ie enable "SH-4 Mode" */
-	__raw_writel(__raw_readl(INTC_ICR0) | 0x00200000, INTC_ICR0);
-
-	register_intc_controller(&intc_desc);
-}
-
-void __init plat_irq_setup_pins(int mode)
-{
-	switch (mode) {
-	case IRQ_MODE_IRQ7654:
-		/* select IRQ mode for IRL7-4 */
-		__raw_writel(__raw_readl(INTC_ICR0) | 0x00400000, INTC_ICR0);
-		register_intc_controller(&intc_desc_irq4567);
-		break;
-	case IRQ_MODE_IRQ3210:
-		/* select IRQ mode for IRL3-0 */
-		__raw_writel(__raw_readl(INTC_ICR0) | 0x00800000, INTC_ICR0);
-		register_intc_controller(&intc_desc_irq0123);
-		break;
-	case IRQ_MODE_IRL7654:
-		/* enable IRL7-4 but don't provide any masking */
-		__raw_writel(0x40000000, INTC_INTMSKCLR1);
-		__raw_writel(0x0000fffe, INTC_INTMSKCLR2);
-		break;
-	case IRQ_MODE_IRL3210:
-		/* enable IRL0-3 but don't provide any masking */
-		__raw_writel(0x80000000, INTC_INTMSKCLR1);
-		__raw_writel(0xfffe0000, INTC_INTMSKCLR2);
-		break;
-	case IRQ_MODE_IRL7654_MASK:
-		/* enable IRL7-4 and mask using cpu intc controller */
-		__raw_writel(0x40000000, INTC_INTMSKCLR1);
-		register_intc_controller(&intc_desc_irl4567);
-		break;
-	case IRQ_MODE_IRL3210_MASK:
-		/* enable IRL0-3 and mask using cpu intc controller */
-		__raw_writel(0x80000000, INTC_INTMSKCLR1);
-		register_intc_controller(&intc_desc_irl0123);
-		break;
-	default:
-		BUG();
-	}
-}
-
-void __init plat_mem_setup(void)
-{
-}
diff --git a/arch/sh/kernel/cpu/sh4a/setup-sh7763.c b/arch/sh/kernel/cpu/sh4a/setup-sh7763.c
deleted file mode 100644
index b0608664785f50..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/setup-sh7763.c
+++ /dev/null
@@ -1,455 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7763 Setup
- *
- *  Copyright (C) 2006  Paul Mundt
- *  Copyright (C) 2007  Yoshihiro Shimoda
- *  Copyright (C) 2008, 2009  Nobuhiro Iwamatsu
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/sh_timer.h>
-#include <linux/sh_intc.h>
-#include <linux/io.h>
-#include <linux/serial_sci.h>
-#include <linux/usb/ohci_pdriver.h>
-#include <asm/platform_early.h>
-
-static struct plat_sci_port scif0_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xffe00000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x700)),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct plat_sci_port scif1_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif1_resources[] = {
-	DEFINE_RES_MEM(0xffe08000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xb80)),
-};
-
-static struct platform_device scif1_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif1_resources,
-	.num_resources	= ARRAY_SIZE(scif1_resources),
-	.dev		= {
-		.platform_data	= &scif1_platform_data,
-	},
-};
-
-static struct plat_sci_port scif2_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif2_resources[] = {
-	DEFINE_RES_MEM(0xffe10000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xf00)),
-};
-
-static struct platform_device scif2_device = {
-	.name		= "sh-sci",
-	.id		= 2,
-	.resource	= scif2_resources,
-	.num_resources	= ARRAY_SIZE(scif2_resources),
-	.dev		= {
-		.platform_data	= &scif2_platform_data,
-	},
-};
-
-static struct resource rtc_resources[] = {
-	[0] = {
-		.start	= 0xffe80000,
-		.end	= 0xffe80000 + 0x58 - 1,
-		.flags	= IORESOURCE_IO,
-	},
-	[1] = {
-		/* Shared Period/Carry/Alarm IRQ */
-		.start  = evt2irq(0x480),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device rtc_device = {
-	.name		= "sh-rtc",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(rtc_resources),
-	.resource	= rtc_resources,
-};
-
-static struct resource usb_ohci_resources[] = {
-	[0] = {
-		.start	= 0xffec8000,
-		.end	= 0xffec80ff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0xc60),
-		.end	= evt2irq(0xc60),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static u64 usb_ohci_dma_mask = 0xffffffffUL;
-
-static struct usb_ohci_pdata usb_ohci_pdata;
-
-static struct platform_device usb_ohci_device = {
-	.name		= "ohci-platform",
-	.id		= -1,
-	.dev = {
-		.dma_mask		= &usb_ohci_dma_mask,
-		.coherent_dma_mask	= 0xffffffff,
-		.platform_data		= &usb_ohci_pdata,
-	},
-	.num_resources	= ARRAY_SIZE(usb_ohci_resources),
-	.resource	= usb_ohci_resources,
-};
-
-static struct resource usbf_resources[] = {
-	[0] = {
-		.start	= 0xffec0000,
-		.end	= 0xffec00ff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0xc80),
-		.end	= evt2irq(0xc80),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device usbf_device = {
-	.name		= "sh_udc",
-	.id		= -1,
-	.dev = {
-		.dma_mask		= NULL,
-		.coherent_dma_mask	= 0xffffffff,
-	},
-	.num_resources	= ARRAY_SIZE(usbf_resources),
-	.resource	= usbf_resources,
-};
-
-static struct sh_timer_config tmu0_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu0_resources[] = {
-	DEFINE_RES_MEM(0xffd80000, 0x30),
-	DEFINE_RES_IRQ(evt2irq(0x580)),
-	DEFINE_RES_IRQ(evt2irq(0x5a0)),
-	DEFINE_RES_IRQ(evt2irq(0x5c0)),
-};
-
-static struct platform_device tmu0_device = {
-	.name		= "sh-tmu",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &tmu0_platform_data,
-	},
-	.resource	= tmu0_resources,
-	.num_resources	= ARRAY_SIZE(tmu0_resources),
-};
-
-static struct sh_timer_config tmu1_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu1_resources[] = {
-	DEFINE_RES_MEM(0xffd88000, 0x2c),
-	DEFINE_RES_IRQ(evt2irq(0xe00)),
-	DEFINE_RES_IRQ(evt2irq(0xe20)),
-	DEFINE_RES_IRQ(evt2irq(0xe40)),
-};
-
-static struct platform_device tmu1_device = {
-	.name		= "sh-tmu",
-	.id		= 1,
-	.dev = {
-		.platform_data	= &tmu1_platform_data,
-	},
-	.resource	= tmu1_resources,
-	.num_resources	= ARRAY_SIZE(tmu1_resources),
-};
-
-static struct platform_device *sh7763_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&tmu0_device,
-	&tmu1_device,
-	&rtc_device,
-	&usb_ohci_device,
-	&usbf_device,
-};
-
-static int __init sh7763_devices_setup(void)
-{
-	return platform_add_devices(sh7763_devices,
-				    ARRAY_SIZE(sh7763_devices));
-}
-arch_initcall(sh7763_devices_setup);
-
-static struct platform_device *sh7763_early_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&tmu0_device,
-	&tmu1_device,
-};
-
-void __init plat_early_device_setup(void)
-{
-	sh_early_platform_add_devices(sh7763_early_devices,
-				   ARRAY_SIZE(sh7763_early_devices));
-}
-
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-
-	IRL_LLLL, IRL_LLLH, IRL_LLHL, IRL_LLHH,
-	IRL_LHLL, IRL_LHLH, IRL_LHHL, IRL_LHHH,
-	IRL_HLLL, IRL_HLLH, IRL_HLHL, IRL_HLHH,
-	IRL_HHLL, IRL_HHLH, IRL_HHHL,
-
-	IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7,
-	RTC, WDT, TMU0, TMU1, TMU2, TMU2_TICPI,
-	HUDI, LCDC, DMAC, SCIF0, IIC0, IIC1, CMT, GETHER, HAC,
-	PCISERR, PCIINTA, PCIINTB, PCIINTC, PCIINTD, PCIC5,
-	STIF0, STIF1, SCIF1, SIOF0, SIOF1, SIOF2,
-	USBH, USBF, TPU, PCC, MMCIF, SIM,
-	TMU3, TMU4, TMU5, ADC, SSI0, SSI1, SSI2, SSI3,
-	SCIF2, GPIO,
-
-	/* interrupt groups */
-
-	TMU012, TMU345,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_VECT(RTC, 0x480), INTC_VECT(RTC, 0x4a0),
-	INTC_VECT(RTC, 0x4c0),
-	INTC_VECT(WDT, 0x560), INTC_VECT(TMU0, 0x580),
-	INTC_VECT(TMU1, 0x5a0), INTC_VECT(TMU2, 0x5c0),
-	INTC_VECT(TMU2_TICPI, 0x5e0), INTC_VECT(HUDI, 0x600),
-	INTC_VECT(LCDC, 0x620),
-	INTC_VECT(DMAC, 0x640), INTC_VECT(DMAC, 0x660),
-	INTC_VECT(DMAC, 0x680), INTC_VECT(DMAC, 0x6a0),
-	INTC_VECT(DMAC, 0x6c0),
-	INTC_VECT(SCIF0, 0x700), INTC_VECT(SCIF0, 0x720),
-	INTC_VECT(SCIF0, 0x740), INTC_VECT(SCIF0, 0x760),
-	INTC_VECT(DMAC, 0x780), INTC_VECT(DMAC, 0x7a0),
-	INTC_VECT(IIC0, 0x8A0), INTC_VECT(IIC1, 0x8C0),
-	INTC_VECT(CMT, 0x900), INTC_VECT(GETHER, 0x920),
-	INTC_VECT(GETHER, 0x940), INTC_VECT(GETHER, 0x960),
-	INTC_VECT(HAC, 0x980),
-	INTC_VECT(PCISERR, 0xa00), INTC_VECT(PCIINTA, 0xa20),
-	INTC_VECT(PCIINTB, 0xa40), INTC_VECT(PCIINTC, 0xa60),
-	INTC_VECT(PCIINTD, 0xa80), INTC_VECT(PCIC5, 0xaa0),
-	INTC_VECT(PCIC5, 0xac0), INTC_VECT(PCIC5, 0xae0),
-	INTC_VECT(PCIC5, 0xb00), INTC_VECT(PCIC5, 0xb20),
-	INTC_VECT(STIF0, 0xb40), INTC_VECT(STIF1, 0xb60),
-	INTC_VECT(SCIF1, 0xb80), INTC_VECT(SCIF1, 0xba0),
-	INTC_VECT(SCIF1, 0xbc0), INTC_VECT(SCIF1, 0xbe0),
-	INTC_VECT(SIOF0, 0xc00), INTC_VECT(SIOF1, 0xc20),
-	INTC_VECT(USBH, 0xc60), INTC_VECT(USBF, 0xc80),
-	INTC_VECT(USBF, 0xca0),
-	INTC_VECT(TPU, 0xcc0), INTC_VECT(PCC, 0xce0),
-	INTC_VECT(MMCIF, 0xd00), INTC_VECT(MMCIF, 0xd20),
-	INTC_VECT(MMCIF, 0xd40), INTC_VECT(MMCIF, 0xd60),
-	INTC_VECT(SIM, 0xd80), INTC_VECT(SIM, 0xda0),
-	INTC_VECT(SIM, 0xdc0), INTC_VECT(SIM, 0xde0),
-	INTC_VECT(TMU3, 0xe00), INTC_VECT(TMU4, 0xe20),
-	INTC_VECT(TMU5, 0xe40), INTC_VECT(ADC, 0xe60),
-	INTC_VECT(SSI0, 0xe80), INTC_VECT(SSI1, 0xea0),
-	INTC_VECT(SSI2, 0xec0), INTC_VECT(SSI3, 0xee0),
-	INTC_VECT(SCIF2, 0xf00), INTC_VECT(SCIF2, 0xf20),
-	INTC_VECT(SCIF2, 0xf40), INTC_VECT(SCIF2, 0xf60),
-	INTC_VECT(GPIO, 0xf80), INTC_VECT(GPIO, 0xfa0),
-	INTC_VECT(GPIO, 0xfc0), INTC_VECT(GPIO, 0xfe0),
-};
-
-static struct intc_group groups[] __initdata = {
-	INTC_GROUP(TMU012, TMU0, TMU1, TMU2, TMU2_TICPI),
-	INTC_GROUP(TMU345, TMU3, TMU4, TMU5),
-};
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xffd40038, 0xffd4003c, 32, /* INT2MSKR / INT2MSKCR */
-	  { 0, 0, 0, 0, 0, 0, GPIO, 0,
-	    SSI0, MMCIF, 0, SIOF0, PCIC5, PCIINTD, PCIINTC, PCIINTB,
-	    PCIINTA, PCISERR, HAC, CMT, 0, 0, 0, DMAC,
-	    HUDI, 0, WDT, SCIF1, SCIF0, RTC, TMU345, TMU012 } },
-	{ 0xffd400d0, 0xffd400d4, 32, /* INT2MSKR1 / INT2MSKCR1 */
-	  { 0, 0, 0, 0, 0, 0, SCIF2, USBF,
-	    0, 0, STIF1, STIF0, 0, 0, USBH, GETHER,
-	    PCC, 0, 0, ADC, TPU, SIM, SIOF2, SIOF1,
-	    LCDC, 0, IIC1, IIC0, SSI3, SSI2, SSI1, 0 } },
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xffd40000, 0, 32, 8, /* INT2PRI0 */ { TMU0, TMU1,
-						 TMU2, TMU2_TICPI } },
-	{ 0xffd40004, 0, 32, 8, /* INT2PRI1 */ { TMU3, TMU4, TMU5, RTC } },
-	{ 0xffd40008, 0, 32, 8, /* INT2PRI2 */ { SCIF0, SCIF1, WDT } },
-	{ 0xffd4000c, 0, 32, 8, /* INT2PRI3 */ { HUDI, DMAC, ADC } },
-	{ 0xffd40010, 0, 32, 8, /* INT2PRI4 */ { CMT, HAC,
-						 PCISERR, PCIINTA } },
-	{ 0xffd40014, 0, 32, 8, /* INT2PRI5 */ { PCIINTB, PCIINTC,
-						 PCIINTD, PCIC5 } },
-	{ 0xffd40018, 0, 32, 8, /* INT2PRI6 */ { SIOF0, USBF, MMCIF, SSI0 } },
-	{ 0xffd4001c, 0, 32, 8, /* INT2PRI7 */ { SCIF2, GPIO } },
-	{ 0xffd400a0, 0, 32, 8, /* INT2PRI8 */ { SSI3, SSI2, SSI1, 0 } },
-	{ 0xffd400a4, 0, 32, 8, /* INT2PRI9 */ { LCDC, 0, IIC1, IIC0 } },
-	{ 0xffd400a8, 0, 32, 8, /* INT2PRI10 */ { TPU, SIM, SIOF2, SIOF1 } },
-	{ 0xffd400ac, 0, 32, 8, /* INT2PRI11 */ { PCC } },
-	{ 0xffd400b0, 0, 32, 8, /* INT2PRI12 */ { 0, 0, USBH, GETHER } },
-	{ 0xffd400b4, 0, 32, 8, /* INT2PRI13 */ { 0, 0, STIF1, STIF0 } },
-};
-
-static DECLARE_INTC_DESC(intc_desc, "sh7763", vectors, groups,
-			 mask_registers, prio_registers, NULL);
-
-/* Support for external interrupt pins in IRQ mode */
-static struct intc_vect irq_vectors[] __initdata = {
-	INTC_VECT(IRQ0, 0x240), INTC_VECT(IRQ1, 0x280),
-	INTC_VECT(IRQ2, 0x2c0), INTC_VECT(IRQ3, 0x300),
-	INTC_VECT(IRQ4, 0x340), INTC_VECT(IRQ5, 0x380),
-	INTC_VECT(IRQ6, 0x3c0), INTC_VECT(IRQ7, 0x200),
-};
-
-static struct intc_mask_reg irq_mask_registers[] __initdata = {
-	{ 0xffd00044, 0xffd00064, 32, /* INTMSK0 / INTMSKCLR0 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_prio_reg irq_prio_registers[] __initdata = {
-	{ 0xffd00010, 0, 32, 4, /* INTPRI */ { IRQ0, IRQ1, IRQ2, IRQ3,
-					       IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_sense_reg irq_sense_registers[] __initdata = {
-	{ 0xffd0001c, 32, 2, /* ICR1 */   { IRQ0, IRQ1, IRQ2, IRQ3,
-					    IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_mask_reg irq_ack_registers[] __initdata = {
-	{ 0xffd00024, 0, 32, /* INTREQ */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static DECLARE_INTC_DESC_ACK(intc_irq_desc, "sh7763-irq", irq_vectors,
-			     NULL, irq_mask_registers, irq_prio_registers,
-			     irq_sense_registers, irq_ack_registers);
-
-
-/* External interrupt pins in IRL mode */
-static struct intc_vect irl_vectors[] __initdata = {
-	INTC_VECT(IRL_LLLL, 0x200), INTC_VECT(IRL_LLLH, 0x220),
-	INTC_VECT(IRL_LLHL, 0x240), INTC_VECT(IRL_LLHH, 0x260),
-	INTC_VECT(IRL_LHLL, 0x280), INTC_VECT(IRL_LHLH, 0x2a0),
-	INTC_VECT(IRL_LHHL, 0x2c0), INTC_VECT(IRL_LHHH, 0x2e0),
-	INTC_VECT(IRL_HLLL, 0x300), INTC_VECT(IRL_HLLH, 0x320),
-	INTC_VECT(IRL_HLHL, 0x340), INTC_VECT(IRL_HLHH, 0x360),
-	INTC_VECT(IRL_HHLL, 0x380), INTC_VECT(IRL_HHLH, 0x3a0),
-	INTC_VECT(IRL_HHHL, 0x3c0),
-};
-
-static struct intc_mask_reg irl3210_mask_registers[] __initdata = {
-	{ 0xffd40080, 0xffd40084, 32, /* INTMSK2 / INTMSKCLR2 */
-	  { IRL_LLLL, IRL_LLLH, IRL_LLHL, IRL_LLHH,
-	    IRL_LHLL, IRL_LHLH, IRL_LHHL, IRL_LHHH,
-	    IRL_HLLL, IRL_HLLH, IRL_HLHL, IRL_HLHH,
-	    IRL_HHLL, IRL_HHLH, IRL_HHHL, } },
-};
-
-static struct intc_mask_reg irl7654_mask_registers[] __initdata = {
-	{ 0xffd40080, 0xffd40084, 32, /* INTMSK2 / INTMSKCLR2 */
-	  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	    IRL_LLLL, IRL_LLLH, IRL_LLHL, IRL_LLHH,
-	    IRL_LHLL, IRL_LHLH, IRL_LHHL, IRL_LHHH,
-	    IRL_HLLL, IRL_HLLH, IRL_HLHL, IRL_HLHH,
-	    IRL_HHLL, IRL_HHLH, IRL_HHHL, } },
-};
-
-static DECLARE_INTC_DESC(intc_irl7654_desc, "sh7763-irl7654", irl_vectors,
-			NULL, irl7654_mask_registers, NULL, NULL);
-
-static DECLARE_INTC_DESC(intc_irl3210_desc, "sh7763-irl3210", irl_vectors,
-			NULL, irl3210_mask_registers, NULL, NULL);
-
-#define INTC_ICR0	0xffd00000
-#define INTC_INTMSK0	0xffd00044
-#define INTC_INTMSK1	0xffd00048
-#define INTC_INTMSK2	0xffd40080
-#define INTC_INTMSKCLR1	0xffd00068
-#define INTC_INTMSKCLR2	0xffd40084
-
-void __init plat_irq_setup(void)
-{
-	/* disable IRQ7-0 */
-	__raw_writel(0xff000000, INTC_INTMSK0);
-
-	/* disable IRL3-0 + IRL7-4 */
-	__raw_writel(0xc0000000, INTC_INTMSK1);
-	__raw_writel(0xfffefffe, INTC_INTMSK2);
-
-	register_intc_controller(&intc_desc);
-}
-
-void __init plat_irq_setup_pins(int mode)
-{
-	switch (mode) {
-	case IRQ_MODE_IRQ:
-		/* select IRQ mode for IRL3-0 + IRL7-4 */
-		__raw_writel(__raw_readl(INTC_ICR0) | 0x00c00000, INTC_ICR0);
-		register_intc_controller(&intc_irq_desc);
-		break;
-	case IRQ_MODE_IRL7654:
-		/* enable IRL7-4 but don't provide any masking */
-		__raw_writel(0x40000000, INTC_INTMSKCLR1);
-		__raw_writel(0x0000fffe, INTC_INTMSKCLR2);
-		break;
-	case IRQ_MODE_IRL3210:
-		/* enable IRL0-3 but don't provide any masking */
-		__raw_writel(0x80000000, INTC_INTMSKCLR1);
-		__raw_writel(0xfffe0000, INTC_INTMSKCLR2);
-		break;
-	case IRQ_MODE_IRL7654_MASK:
-		/* enable IRL7-4 and mask using cpu intc controller */
-		__raw_writel(0x40000000, INTC_INTMSKCLR1);
-		register_intc_controller(&intc_irl7654_desc);
-		break;
-	case IRQ_MODE_IRL3210_MASK:
-		/* enable IRL0-3 and mask using cpu intc controller */
-		__raw_writel(0x80000000, INTC_INTMSKCLR1);
-		register_intc_controller(&intc_irl3210_desc);
-		break;
-	default:
-		BUG();
-	}
-}
diff --git a/arch/sh/kernel/cpu/sh4a/setup-sh7770.c b/arch/sh/kernel/cpu/sh4a/setup-sh7770.c
deleted file mode 100644
index 5efec6ceb04d5c..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/setup-sh7770.c
+++ /dev/null
@@ -1,571 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7770 Setup
- *
- *  Copyright (C) 2006 - 2008  Paul Mundt
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/serial_sci.h>
-#include <linux/sh_timer.h>
-#include <linux/sh_intc.h>
-#include <linux/io.h>
-#include <asm/platform_early.h>
-
-static struct plat_sci_port scif0_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_TOIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xff923000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x9a0)),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct plat_sci_port scif1_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_TOIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif1_resources[] = {
-	DEFINE_RES_MEM(0xff924000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x9c0)),
-};
-
-static struct platform_device scif1_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif1_resources,
-	.num_resources	= ARRAY_SIZE(scif1_resources),
-	.dev		= {
-		.platform_data	= &scif1_platform_data,
-	},
-};
-
-static struct plat_sci_port scif2_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_TOIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif2_resources[] = {
-	DEFINE_RES_MEM(0xff925000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x9e0)),
-};
-
-static struct platform_device scif2_device = {
-	.name		= "sh-sci",
-	.id		= 2,
-	.resource	= scif2_resources,
-	.num_resources	= ARRAY_SIZE(scif2_resources),
-	.dev		= {
-		.platform_data	= &scif2_platform_data,
-	},
-};
-
-static struct plat_sci_port scif3_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_TOIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif3_resources[] = {
-	DEFINE_RES_MEM(0xff926000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xa00)),
-};
-
-static struct platform_device scif3_device = {
-	.name		= "sh-sci",
-	.id		= 3,
-	.resource	= scif3_resources,
-	.num_resources	= ARRAY_SIZE(scif3_resources),
-	.dev		= {
-		.platform_data	= &scif3_platform_data,
-	},
-};
-
-static struct plat_sci_port scif4_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_TOIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif4_resources[] = {
-	DEFINE_RES_MEM(0xff927000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xa20)),
-};
-
-static struct platform_device scif4_device = {
-	.name		= "sh-sci",
-	.id		= 4,
-	.resource	= scif4_resources,
-	.num_resources	= ARRAY_SIZE(scif4_resources),
-	.dev		= {
-		.platform_data	= &scif4_platform_data,
-	},
-};
-
-static struct plat_sci_port scif5_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_TOIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif5_resources[] = {
-	DEFINE_RES_MEM(0xff928000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xa40)),
-};
-
-static struct platform_device scif5_device = {
-	.name		= "sh-sci",
-	.id		= 5,
-	.resource	= scif5_resources,
-	.num_resources	= ARRAY_SIZE(scif5_resources),
-	.dev		= {
-		.platform_data	= &scif5_platform_data,
-	},
-};
-
-static struct plat_sci_port scif6_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_TOIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif6_resources[] = {
-	DEFINE_RES_MEM(0xff929000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xa60)),
-};
-
-static struct platform_device scif6_device = {
-	.name		= "sh-sci",
-	.id		= 6,
-	.resource	= scif6_resources,
-	.num_resources	= ARRAY_SIZE(scif6_resources),
-	.dev		= {
-		.platform_data	= &scif6_platform_data,
-	},
-};
-
-static struct plat_sci_port scif7_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_TOIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif7_resources[] = {
-	DEFINE_RES_MEM(0xff92a000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xa80)),
-};
-
-static struct platform_device scif7_device = {
-	.name		= "sh-sci",
-	.id		= 7,
-	.resource	= scif7_resources,
-	.num_resources	= ARRAY_SIZE(scif7_resources),
-	.dev		= {
-		.platform_data	= &scif7_platform_data,
-	},
-};
-
-static struct plat_sci_port scif8_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_TOIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif8_resources[] = {
-	DEFINE_RES_MEM(0xff92b000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xaa0)),
-};
-
-static struct platform_device scif8_device = {
-	.name		= "sh-sci",
-	.id		= 8,
-	.resource	= scif8_resources,
-	.num_resources	= ARRAY_SIZE(scif8_resources),
-	.dev		= {
-		.platform_data	= &scif8_platform_data,
-	},
-};
-
-static struct plat_sci_port scif9_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_TOIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif9_resources[] = {
-	DEFINE_RES_MEM(0xff92c000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xac0)),
-};
-
-static struct platform_device scif9_device = {
-	.name		= "sh-sci",
-	.id		= 9,
-	.resource	= scif9_resources,
-	.num_resources	= ARRAY_SIZE(scif9_resources),
-	.dev		= {
-		.platform_data	= &scif9_platform_data,
-	},
-};
-
-static struct sh_timer_config tmu0_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu0_resources[] = {
-	DEFINE_RES_MEM(0xffd80000, 0x30),
-	DEFINE_RES_IRQ(evt2irq(0x400)),
-	DEFINE_RES_IRQ(evt2irq(0x420)),
-	DEFINE_RES_IRQ(evt2irq(0x440)),
-};
-
-static struct platform_device tmu0_device = {
-	.name		= "sh-tmu",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &tmu0_platform_data,
-	},
-	.resource	= tmu0_resources,
-	.num_resources	= ARRAY_SIZE(tmu0_resources),
-};
-
-static struct sh_timer_config tmu1_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu1_resources[] = {
-	DEFINE_RES_MEM(0xffd81000, 0x30),
-	DEFINE_RES_IRQ(evt2irq(0x460)),
-	DEFINE_RES_IRQ(evt2irq(0x480)),
-	DEFINE_RES_IRQ(evt2irq(0x4a0)),
-};
-
-static struct platform_device tmu1_device = {
-	.name		= "sh-tmu",
-	.id		= 1,
-	.dev = {
-		.platform_data	= &tmu1_platform_data,
-	},
-	.resource	= tmu1_resources,
-	.num_resources	= ARRAY_SIZE(tmu1_resources),
-};
-
-static struct sh_timer_config tmu2_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu2_resources[] = {
-	DEFINE_RES_MEM(0xffd82000, 0x2c),
-	DEFINE_RES_IRQ(evt2irq(0x4c0)),
-	DEFINE_RES_IRQ(evt2irq(0x4e0)),
-	DEFINE_RES_IRQ(evt2irq(0x500)),
-};
-
-static struct platform_device tmu2_device = {
-	.name		= "sh-tmu",
-	.id		= 2,
-	.dev = {
-		.platform_data	= &tmu2_platform_data,
-	},
-	.resource	= tmu2_resources,
-	.num_resources	= ARRAY_SIZE(tmu2_resources),
-};
-
-static struct platform_device *sh7770_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&scif4_device,
-	&scif5_device,
-	&scif6_device,
-	&scif7_device,
-	&scif8_device,
-	&scif9_device,
-	&tmu0_device,
-	&tmu1_device,
-	&tmu2_device,
-};
-
-static int __init sh7770_devices_setup(void)
-{
-	return platform_add_devices(sh7770_devices,
-				    ARRAY_SIZE(sh7770_devices));
-}
-arch_initcall(sh7770_devices_setup);
-
-static struct platform_device *sh7770_early_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&scif4_device,
-	&scif5_device,
-	&scif6_device,
-	&scif7_device,
-	&scif8_device,
-	&scif9_device,
-	&tmu0_device,
-	&tmu1_device,
-	&tmu2_device,
-};
-
-void __init plat_early_device_setup(void)
-{
-	sh_early_platform_add_devices(sh7770_early_devices,
-				   ARRAY_SIZE(sh7770_early_devices));
-}
-
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-	IRL_LLLL, IRL_LLLH, IRL_LLHL, IRL_LLHH,
-	IRL_LHLL, IRL_LHLH, IRL_LHHL, IRL_LHHH,
-	IRL_HLLL, IRL_HLLH, IRL_HLHL, IRL_HLHH,
-	IRL_HHLL, IRL_HHLH, IRL_HHHL,
-
-	IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5,
-
-	GPIO,
-	TMU0, TMU1, TMU2, TMU2_TICPI,
-	TMU3, TMU4, TMU5, TMU5_TICPI,
-	TMU6, TMU7, TMU8,
-	HAC, IPI, SPDIF, HUDI, I2C,
-	DMAC0_DMINT0, DMAC0_DMINT1, DMAC0_DMINT2,
-	I2S0, I2S1, I2S2, I2S3,
-	SRC_RX, SRC_TX, SRC_SPDIF,
-	DU, VIDEO_IN, REMOTE, YUV, USB, ATAPI, CAN, GPS, GFX2D,
-	GFX3D_MBX, GFX3D_DMAC,
-	EXBUS_ATA,
-	SPI0, SPI1,
-	SCIF089, SCIF1234, SCIF567,
-	ADC,
-	BBDMAC_0_3, BBDMAC_4_7, BBDMAC_8_10, BBDMAC_11_14,
-	BBDMAC_15_18, BBDMAC_19_22, BBDMAC_23_26, BBDMAC_27,
-	BBDMAC_28, BBDMAC_29, BBDMAC_30, BBDMAC_31,
-
-	/* interrupt groups */
-	TMU, DMAC, I2S, SRC, GFX3D, SPI, SCIF, BBDMAC,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_VECT(GPIO, 0x3e0),
-	INTC_VECT(TMU0, 0x400), INTC_VECT(TMU1, 0x420),
-	INTC_VECT(TMU2, 0x440), INTC_VECT(TMU2_TICPI, 0x460),
-	INTC_VECT(TMU3, 0x480), INTC_VECT(TMU4, 0x4a0),
-	INTC_VECT(TMU5, 0x4c0), INTC_VECT(TMU5_TICPI, 0x4e0),
-	INTC_VECT(TMU6, 0x500), INTC_VECT(TMU7, 0x520),
-	INTC_VECT(TMU8, 0x540),
-	INTC_VECT(HAC, 0x580), INTC_VECT(IPI, 0x5c0),
-	INTC_VECT(SPDIF, 0x5e0),
-	INTC_VECT(HUDI, 0x600), INTC_VECT(I2C, 0x620),
-	INTC_VECT(DMAC0_DMINT0, 0x640), INTC_VECT(DMAC0_DMINT1, 0x660),
-	INTC_VECT(DMAC0_DMINT2, 0x680),
-	INTC_VECT(I2S0, 0x6a0), INTC_VECT(I2S1, 0x6c0),
-	INTC_VECT(I2S2, 0x6e0), INTC_VECT(I2S3, 0x700),
-	INTC_VECT(SRC_RX, 0x720), INTC_VECT(SRC_TX, 0x740),
-	INTC_VECT(SRC_SPDIF, 0x760),
-	INTC_VECT(DU, 0x780), INTC_VECT(VIDEO_IN, 0x7a0),
-	INTC_VECT(REMOTE, 0x7c0), INTC_VECT(YUV, 0x7e0),
-	INTC_VECT(USB, 0x840), INTC_VECT(ATAPI, 0x860),
-	INTC_VECT(CAN, 0x880), INTC_VECT(GPS, 0x8a0),
-	INTC_VECT(GFX2D, 0x8c0),
-	INTC_VECT(GFX3D_MBX, 0x900), INTC_VECT(GFX3D_DMAC, 0x920),
-	INTC_VECT(EXBUS_ATA, 0x940),
-	INTC_VECT(SPI0, 0x960), INTC_VECT(SPI1, 0x980),
-	INTC_VECT(SCIF089, 0x9a0), INTC_VECT(SCIF1234, 0x9c0),
-	INTC_VECT(SCIF1234, 0x9e0), INTC_VECT(SCIF1234, 0xa00),
-	INTC_VECT(SCIF1234, 0xa20), INTC_VECT(SCIF567, 0xa40),
-	INTC_VECT(SCIF567, 0xa60), INTC_VECT(SCIF567, 0xa80),
-	INTC_VECT(SCIF089, 0xaa0), INTC_VECT(SCIF089, 0xac0),
-	INTC_VECT(ADC, 0xb20),
-	INTC_VECT(BBDMAC_0_3, 0xba0), INTC_VECT(BBDMAC_0_3, 0xbc0),
-	INTC_VECT(BBDMAC_0_3, 0xbe0), INTC_VECT(BBDMAC_0_3, 0xc00),
-	INTC_VECT(BBDMAC_4_7, 0xc20), INTC_VECT(BBDMAC_4_7, 0xc40),
-	INTC_VECT(BBDMAC_4_7, 0xc60), INTC_VECT(BBDMAC_4_7, 0xc80),
-	INTC_VECT(BBDMAC_8_10, 0xca0), INTC_VECT(BBDMAC_8_10, 0xcc0),
-	INTC_VECT(BBDMAC_8_10, 0xce0), INTC_VECT(BBDMAC_11_14, 0xd00),
-	INTC_VECT(BBDMAC_11_14, 0xd20), INTC_VECT(BBDMAC_11_14, 0xd40),
-	INTC_VECT(BBDMAC_11_14, 0xd60), INTC_VECT(BBDMAC_15_18, 0xd80),
-	INTC_VECT(BBDMAC_15_18, 0xda0), INTC_VECT(BBDMAC_15_18, 0xdc0),
-	INTC_VECT(BBDMAC_15_18, 0xde0), INTC_VECT(BBDMAC_19_22, 0xe00),
-	INTC_VECT(BBDMAC_19_22, 0xe20), INTC_VECT(BBDMAC_19_22, 0xe40),
-	INTC_VECT(BBDMAC_19_22, 0xe60), INTC_VECT(BBDMAC_23_26, 0xe80),
-	INTC_VECT(BBDMAC_23_26, 0xea0), INTC_VECT(BBDMAC_23_26, 0xec0),
-	INTC_VECT(BBDMAC_23_26, 0xee0), INTC_VECT(BBDMAC_27, 0xf00),
-	INTC_VECT(BBDMAC_28, 0xf20), INTC_VECT(BBDMAC_29, 0xf40),
-	INTC_VECT(BBDMAC_30, 0xf60), INTC_VECT(BBDMAC_31, 0xf80),
-};
-
-static struct intc_group groups[] __initdata = {
-	INTC_GROUP(TMU, TMU0, TMU1, TMU2, TMU2_TICPI, TMU3, TMU4, TMU5,
-		   TMU5_TICPI, TMU6, TMU7, TMU8),
-	INTC_GROUP(DMAC, DMAC0_DMINT0, DMAC0_DMINT1, DMAC0_DMINT2),
-	INTC_GROUP(I2S, I2S0, I2S1, I2S2, I2S3),
-	INTC_GROUP(SRC, SRC_RX, SRC_TX, SRC_SPDIF),
-	INTC_GROUP(GFX3D, GFX3D_MBX, GFX3D_DMAC),
-	INTC_GROUP(SPI, SPI0, SPI1),
-	INTC_GROUP(SCIF, SCIF089, SCIF1234, SCIF567),
-	INTC_GROUP(BBDMAC,
-		   BBDMAC_0_3, BBDMAC_4_7, BBDMAC_8_10, BBDMAC_11_14,
-		   BBDMAC_15_18, BBDMAC_19_22, BBDMAC_23_26, BBDMAC_27,
-		   BBDMAC_28, BBDMAC_29, BBDMAC_30, BBDMAC_31),
-};
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xffe00040, 0xffe00044, 32, /* INT2MSKR / INT2MSKCR */
-	  { 0, BBDMAC, ADC, SCIF, SPI, EXBUS_ATA, GFX3D, GFX2D,
-	    GPS, CAN, ATAPI, USB, YUV, REMOTE, VIDEO_IN, DU, SRC, I2S,
-	    DMAC, I2C, HUDI, SPDIF, IPI, HAC, TMU, GPIO } },
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xffe00000, 0, 32, 8, /* INT2PRI0 */ { GPIO, TMU0, 0, HAC } },
-	{ 0xffe00004, 0, 32, 8, /* INT2PRI1 */ { IPI, SPDIF, HUDI, I2C } },
-	{ 0xffe00008, 0, 32, 8, /* INT2PRI2 */ { DMAC, I2S, SRC, DU } },
-	{ 0xffe0000c, 0, 32, 8, /* INT2PRI3 */ { VIDEO_IN, REMOTE, YUV, USB } },
-	{ 0xffe00010, 0, 32, 8, /* INT2PRI4 */ { ATAPI, CAN, GPS, GFX2D } },
-	{ 0xffe00014, 0, 32, 8, /* INT2PRI5 */ { 0, GFX3D, EXBUS_ATA, SPI } },
-	{ 0xffe00018, 0, 32, 8, /* INT2PRI6 */ { SCIF1234, SCIF567, SCIF089 } },
-	{ 0xffe0001c, 0, 32, 8, /* INT2PRI7 */ { ADC, 0, 0, BBDMAC_0_3 } },
-	{ 0xffe00020, 0, 32, 8, /* INT2PRI8 */
-	  { BBDMAC_4_7, BBDMAC_8_10, BBDMAC_11_14, BBDMAC_15_18 } },
-	{ 0xffe00024, 0, 32, 8, /* INT2PRI9 */
-	  { BBDMAC_19_22, BBDMAC_23_26, BBDMAC_27, BBDMAC_28 } },
-	{ 0xffe00028, 0, 32, 8, /* INT2PRI10 */
-	  { BBDMAC_29, BBDMAC_30, BBDMAC_31 } },
-	{ 0xffe0002c, 0, 32, 8, /* INT2PRI11 */
-	  { TMU1, TMU2, TMU2_TICPI, TMU3 } },
-	{ 0xffe00030, 0, 32, 8, /* INT2PRI12 */
-	  { TMU4, TMU5, TMU5_TICPI, TMU6 } },
-	{ 0xffe00034, 0, 32, 8, /* INT2PRI13 */
-	  { TMU7, TMU8 } },
-};
-
-static DECLARE_INTC_DESC(intc_desc, "sh7770", vectors, groups,
-			 mask_registers, prio_registers, NULL);
-
-/* Support for external interrupt pins in IRQ mode */
-static struct intc_vect irq_vectors[] __initdata = {
-	INTC_VECT(IRQ0, 0x240), INTC_VECT(IRQ1, 0x280),
-	INTC_VECT(IRQ2, 0x2c0), INTC_VECT(IRQ3, 0x300),
-	INTC_VECT(IRQ4, 0x340), INTC_VECT(IRQ5, 0x380),
-};
-
-static struct intc_mask_reg irq_mask_registers[] __initdata = {
-	{ 0xffd00044, 0xffd00064, 32, /* INTMSK0 / INTMSKCLR0 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, } },
-};
-
-static struct intc_prio_reg irq_prio_registers[] __initdata = {
-	{ 0xffd00010, 0, 32, 4, /* INTPRI */ { IRQ0, IRQ1, IRQ2, IRQ3,
-					       IRQ4, IRQ5, } },
-};
-
-static struct intc_sense_reg irq_sense_registers[] __initdata = {
-	{ 0xffd0001c, 32, 2, /* ICR1 */   { IRQ0, IRQ1, IRQ2, IRQ3,
-					    IRQ4, IRQ5, } },
-};
-
-static DECLARE_INTC_DESC(intc_irq_desc, "sh7770-irq", irq_vectors,
-			 NULL, irq_mask_registers, irq_prio_registers,
-			 irq_sense_registers);
-
-/* External interrupt pins in IRL mode */
-static struct intc_vect irl_vectors[] __initdata = {
-	INTC_VECT(IRL_LLLL, 0x200), INTC_VECT(IRL_LLLH, 0x220),
-	INTC_VECT(IRL_LLHL, 0x240), INTC_VECT(IRL_LLHH, 0x260),
-	INTC_VECT(IRL_LHLL, 0x280), INTC_VECT(IRL_LHLH, 0x2a0),
-	INTC_VECT(IRL_LHHL, 0x2c0), INTC_VECT(IRL_LHHH, 0x2e0),
-	INTC_VECT(IRL_HLLL, 0x300), INTC_VECT(IRL_HLLH, 0x320),
-	INTC_VECT(IRL_HLHL, 0x340), INTC_VECT(IRL_HLHH, 0x360),
-	INTC_VECT(IRL_HHLL, 0x380), INTC_VECT(IRL_HHLH, 0x3a0),
-	INTC_VECT(IRL_HHHL, 0x3c0),
-};
-
-static struct intc_mask_reg irl3210_mask_registers[] __initdata = {
-	{ 0xffd40080, 0xffd40084, 32, /* INTMSK2 / INTMSKCLR2 */
-	  { IRL_LLLL, IRL_LLLH, IRL_LLHL, IRL_LLHH,
-	    IRL_LHLL, IRL_LHLH, IRL_LHHL, IRL_LHHH,
-	    IRL_HLLL, IRL_HLLH, IRL_HLHL, IRL_HLHH,
-	    IRL_HHLL, IRL_HHLH, IRL_HHHL, } },
-};
-
-static struct intc_mask_reg irl7654_mask_registers[] __initdata = {
-	{ 0xffd40080, 0xffd40084, 32, /* INTMSK2 / INTMSKCLR2 */
-	  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	    IRL_LLLL, IRL_LLLH, IRL_LLHL, IRL_LLHH,
-	    IRL_LHLL, IRL_LHLH, IRL_LHHL, IRL_LHHH,
-	    IRL_HLLL, IRL_HLLH, IRL_HLHL, IRL_HLHH,
-	    IRL_HHLL, IRL_HHLH, IRL_HHHL, } },
-};
-
-static DECLARE_INTC_DESC(intc_irl7654_desc, "sh7780-irl7654", irl_vectors,
-			 NULL, irl7654_mask_registers, NULL, NULL);
-
-static DECLARE_INTC_DESC(intc_irl3210_desc, "sh7780-irl3210", irl_vectors,
-			 NULL, irl3210_mask_registers, NULL, NULL);
-
-#define INTC_ICR0	0xffd00000
-#define INTC_INTMSK0	0xffd00044
-#define INTC_INTMSK1	0xffd00048
-#define INTC_INTMSK2	0xffd40080
-#define INTC_INTMSKCLR1	0xffd00068
-#define INTC_INTMSKCLR2	0xffd40084
-
-void __init plat_irq_setup(void)
-{
-	/* disable IRQ7-0 */
-	__raw_writel(0xff000000, INTC_INTMSK0);
-
-	/* disable IRL3-0 + IRL7-4 */
-	__raw_writel(0xc0000000, INTC_INTMSK1);
-	__raw_writel(0xfffefffe, INTC_INTMSK2);
-
-	/* select IRL mode for IRL3-0 + IRL7-4 */
-	__raw_writel(__raw_readl(INTC_ICR0) & ~0x00c00000, INTC_ICR0);
-
-	/* disable holding function, ie enable "SH-4 Mode" */
-	__raw_writel(__raw_readl(INTC_ICR0) | 0x00200000, INTC_ICR0);
-
-	register_intc_controller(&intc_desc);
-}
-
-void __init plat_irq_setup_pins(int mode)
-{
-	switch (mode) {
-	case IRQ_MODE_IRQ:
-		/* select IRQ mode for IRL3-0 + IRL7-4 */
-		__raw_writel(__raw_readl(INTC_ICR0) | 0x00c00000, INTC_ICR0);
-		register_intc_controller(&intc_irq_desc);
-		break;
-	case IRQ_MODE_IRL7654:
-		/* enable IRL7-4 but don't provide any masking */
-		__raw_writel(0x40000000, INTC_INTMSKCLR1);
-		__raw_writel(0x0000fffe, INTC_INTMSKCLR2);
-		break;
-	case IRQ_MODE_IRL3210:
-		/* enable IRL0-3 but don't provide any masking */
-		__raw_writel(0x80000000, INTC_INTMSKCLR1);
-		__raw_writel(0xfffe0000, INTC_INTMSKCLR2);
-		break;
-	case IRQ_MODE_IRL7654_MASK:
-		/* enable IRL7-4 and mask using cpu intc controller */
-		__raw_writel(0x40000000, INTC_INTMSKCLR1);
-		register_intc_controller(&intc_irl7654_desc);
-		break;
-	case IRQ_MODE_IRL3210_MASK:
-		/* enable IRL0-3 and mask using cpu intc controller */
-		__raw_writel(0x80000000, INTC_INTMSKCLR1);
-		register_intc_controller(&intc_irl3210_desc);
-		break;
-	default:
-		BUG();
-	}
-}
diff --git a/arch/sh/kernel/cpu/sh4a/setup-sh7780.c b/arch/sh/kernel/cpu/sh4a/setup-sh7780.c
deleted file mode 100644
index c818b788ecb05a..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/setup-sh7780.c
+++ /dev/null
@@ -1,505 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7780 Setup
- *
- *  Copyright (C) 2006  Paul Mundt
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/io.h>
-#include <linux/serial_sci.h>
-#include <linux/sh_dma.h>
-#include <linux/sh_timer.h>
-#include <linux/sh_intc.h>
-#include <cpu/dma-register.h>
-#include <asm/platform_early.h>
-
-static struct plat_sci_port scif0_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_CKE1,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xffe00000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x700)),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct plat_sci_port scif1_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_CKE1,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif1_resources[] = {
-	DEFINE_RES_MEM(0xffe10000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0xb80)),
-};
-
-static struct platform_device scif1_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif1_resources,
-	.num_resources	= ARRAY_SIZE(scif1_resources),
-	.dev		= {
-		.platform_data	= &scif1_platform_data,
-	},
-};
-
-static struct sh_timer_config tmu0_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu0_resources[] = {
-	DEFINE_RES_MEM(0xffd80000, 0x30),
-	DEFINE_RES_IRQ(evt2irq(0x580)),
-	DEFINE_RES_IRQ(evt2irq(0x5a0)),
-	DEFINE_RES_IRQ(evt2irq(0x5c0)),
-};
-
-static struct platform_device tmu0_device = {
-	.name		= "sh-tmu",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &tmu0_platform_data,
-	},
-	.resource	= tmu0_resources,
-	.num_resources	= ARRAY_SIZE(tmu0_resources),
-};
-
-static struct sh_timer_config tmu1_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu1_resources[] = {
-	DEFINE_RES_MEM(0xffdc0000, 0x2c),
-	DEFINE_RES_IRQ(evt2irq(0xe00)),
-	DEFINE_RES_IRQ(evt2irq(0xe20)),
-	DEFINE_RES_IRQ(evt2irq(0xe40)),
-};
-
-static struct platform_device tmu1_device = {
-	.name		= "sh-tmu",
-	.id		= 1,
-	.dev = {
-		.platform_data	= &tmu1_platform_data,
-	},
-	.resource	= tmu1_resources,
-	.num_resources	= ARRAY_SIZE(tmu1_resources),
-};
-
-static struct resource rtc_resources[] = {
-	[0] = {
-		.start	= 0xffe80000,
-		.end	= 0xffe80000 + 0x58 - 1,
-		.flags	= IORESOURCE_IO,
-	},
-	[1] = {
-		/* Shared Period/Carry/Alarm IRQ */
-		.start	= evt2irq(0x480),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device rtc_device = {
-	.name		= "sh-rtc",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(rtc_resources),
-	.resource	= rtc_resources,
-};
-
-/* DMA */
-static const struct sh_dmae_channel sh7780_dmae0_channels[] = {
-	{
-		.offset = 0,
-		.dmars = 0,
-		.dmars_bit = 0,
-	}, {
-		.offset = 0x10,
-		.dmars = 0,
-		.dmars_bit = 8,
-	}, {
-		.offset = 0x20,
-		.dmars = 4,
-		.dmars_bit = 0,
-	}, {
-		.offset = 0x30,
-		.dmars = 4,
-		.dmars_bit = 8,
-	}, {
-		.offset = 0x50,
-		.dmars = 8,
-		.dmars_bit = 0,
-	}, {
-		.offset = 0x60,
-		.dmars = 8,
-		.dmars_bit = 8,
-	}
-};
-
-static const struct sh_dmae_channel sh7780_dmae1_channels[] = {
-	{
-		.offset = 0,
-	}, {
-		.offset = 0x10,
-	}, {
-		.offset = 0x20,
-	}, {
-		.offset = 0x30,
-	}, {
-		.offset = 0x50,
-	}, {
-		.offset = 0x60,
-	}
-};
-
-static const unsigned int ts_shift[] = TS_SHIFT;
-
-static struct sh_dmae_pdata dma0_platform_data = {
-	.channel	= sh7780_dmae0_channels,
-	.channel_num	= ARRAY_SIZE(sh7780_dmae0_channels),
-	.ts_low_shift	= CHCR_TS_LOW_SHIFT,
-	.ts_low_mask	= CHCR_TS_LOW_MASK,
-	.ts_high_shift	= CHCR_TS_HIGH_SHIFT,
-	.ts_high_mask	= CHCR_TS_HIGH_MASK,
-	.ts_shift	= ts_shift,
-	.ts_shift_num	= ARRAY_SIZE(ts_shift),
-	.dmaor_init	= DMAOR_INIT,
-};
-
-static struct sh_dmae_pdata dma1_platform_data = {
-	.channel	= sh7780_dmae1_channels,
-	.channel_num	= ARRAY_SIZE(sh7780_dmae1_channels),
-	.ts_low_shift	= CHCR_TS_LOW_SHIFT,
-	.ts_low_mask	= CHCR_TS_LOW_MASK,
-	.ts_high_shift	= CHCR_TS_HIGH_SHIFT,
-	.ts_high_mask	= CHCR_TS_HIGH_MASK,
-	.ts_shift	= ts_shift,
-	.ts_shift_num	= ARRAY_SIZE(ts_shift),
-	.dmaor_init	= DMAOR_INIT,
-};
-
-static struct resource sh7780_dmae0_resources[] = {
-	[0] = {
-		/* Channel registers and DMAOR */
-		.start	= 0xfc808020,
-		.end	= 0xfc80808f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* DMARSx */
-		.start	= 0xfc809000,
-		.end	= 0xfc80900b,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		/*
-		 * Real DMA error vector is 0x6c0, and channel
-		 * vectors are 0x640-0x6a0, 0x780-0x7a0
-		 */
-		.name	= "error_irq",
-		.start	= evt2irq(0x640),
-		.end	= evt2irq(0x640),
-		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_SHAREABLE,
-	},
-};
-
-static struct resource sh7780_dmae1_resources[] = {
-	[0] = {
-		/* Channel registers and DMAOR */
-		.start	= 0xfc818020,
-		.end	= 0xfc81808f,
-		.flags	= IORESOURCE_MEM,
-	},
-	/* DMAC1 has no DMARS */
-	{
-		/*
-		 * Real DMA error vector is 0x6c0, and channel
-		 * vectors are 0x7c0-0x7e0, 0xd80-0xde0
-		 */
-		.name	= "error_irq",
-		.start	= evt2irq(0x7c0),
-		.end	= evt2irq(0x7c0),
-		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_SHAREABLE,
-	},
-};
-
-static struct platform_device dma0_device = {
-	.name           = "sh-dma-engine",
-	.id             = 0,
-	.resource	= sh7780_dmae0_resources,
-	.num_resources	= ARRAY_SIZE(sh7780_dmae0_resources),
-	.dev            = {
-		.platform_data	= &dma0_platform_data,
-	},
-};
-
-static struct platform_device dma1_device = {
-	.name		= "sh-dma-engine",
-	.id		= 1,
-	.resource	= sh7780_dmae1_resources,
-	.num_resources	= ARRAY_SIZE(sh7780_dmae1_resources),
-	.dev		= {
-		.platform_data	= &dma1_platform_data,
-	},
-};
-
-static struct platform_device *sh7780_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&tmu0_device,
-	&tmu1_device,
-	&rtc_device,
-	&dma0_device,
-	&dma1_device,
-};
-
-static int __init sh7780_devices_setup(void)
-{
-	return platform_add_devices(sh7780_devices,
-				    ARRAY_SIZE(sh7780_devices));
-}
-arch_initcall(sh7780_devices_setup);
-
-static struct platform_device *sh7780_early_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&tmu0_device,
-	&tmu1_device,
-};
-
-void __init plat_early_device_setup(void)
-{
-	if (mach_is_sh2007()) {
-		scif0_platform_data.scscr &= ~SCSCR_CKE1;
-		scif1_platform_data.scscr &= ~SCSCR_CKE1;
-	}
-
-	sh_early_platform_add_devices(sh7780_early_devices,
-				   ARRAY_SIZE(sh7780_early_devices));
-}
-
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-
-	IRL_LLLL, IRL_LLLH, IRL_LLHL, IRL_LLHH,
-	IRL_LHLL, IRL_LHLH, IRL_LHHL, IRL_LHHH,
-	IRL_HLLL, IRL_HLLH, IRL_HLHL, IRL_HLHH,
-	IRL_HHLL, IRL_HHLH, IRL_HHHL,
-
-	IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7,
-	RTC, WDT, TMU0, TMU1, TMU2, TMU2_TICPI,
-	HUDI, DMAC0, SCIF0, DMAC1, CMT, HAC,
-	PCISERR, PCIINTA, PCIINTB, PCIINTC, PCIINTD, PCIC5,
-	SCIF1, SIOF, HSPI, MMCIF, TMU3, TMU4, TMU5, SSI, FLCTL,	GPIO,
-
-	/* interrupt groups */
-
-	TMU012,	TMU345,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_VECT(RTC, 0x480), INTC_VECT(RTC, 0x4a0),
-	INTC_VECT(RTC, 0x4c0),
-	INTC_VECT(WDT, 0x560),
-	INTC_VECT(TMU0, 0x580), INTC_VECT(TMU1, 0x5a0),
-	INTC_VECT(TMU2, 0x5c0), INTC_VECT(TMU2_TICPI, 0x5e0),
-	INTC_VECT(HUDI, 0x600),
-	INTC_VECT(DMAC0, 0x640), INTC_VECT(DMAC0, 0x660),
-	INTC_VECT(DMAC0, 0x680), INTC_VECT(DMAC0, 0x6a0),
-	INTC_VECT(DMAC0, 0x6c0),
-	INTC_VECT(SCIF0, 0x700), INTC_VECT(SCIF0, 0x720),
-	INTC_VECT(SCIF0, 0x740), INTC_VECT(SCIF0, 0x760),
-	INTC_VECT(DMAC0, 0x780), INTC_VECT(DMAC0, 0x7a0),
-	INTC_VECT(DMAC1, 0x7c0), INTC_VECT(DMAC1, 0x7e0),
-	INTC_VECT(CMT, 0x900), INTC_VECT(HAC, 0x980),
-	INTC_VECT(PCISERR, 0xa00), INTC_VECT(PCIINTA, 0xa20),
-	INTC_VECT(PCIINTB, 0xa40), INTC_VECT(PCIINTC, 0xa60),
-	INTC_VECT(PCIINTD, 0xa80), INTC_VECT(PCIC5, 0xaa0),
-	INTC_VECT(PCIC5, 0xac0), INTC_VECT(PCIC5, 0xae0),
-	INTC_VECT(PCIC5, 0xb00), INTC_VECT(PCIC5, 0xb20),
-	INTC_VECT(SCIF1, 0xb80), INTC_VECT(SCIF1, 0xba0),
-	INTC_VECT(SCIF1, 0xbc0), INTC_VECT(SCIF1, 0xbe0),
-	INTC_VECT(SIOF, 0xc00), INTC_VECT(HSPI, 0xc80),
-	INTC_VECT(MMCIF, 0xd00), INTC_VECT(MMCIF, 0xd20),
-	INTC_VECT(MMCIF, 0xd40), INTC_VECT(MMCIF, 0xd60),
-	INTC_VECT(DMAC1, 0xd80), INTC_VECT(DMAC1, 0xda0),
-	INTC_VECT(DMAC1, 0xdc0), INTC_VECT(DMAC1, 0xde0),
-	INTC_VECT(TMU3, 0xe00), INTC_VECT(TMU4, 0xe20),
-	INTC_VECT(TMU5, 0xe40),
-	INTC_VECT(SSI, 0xe80),
-	INTC_VECT(FLCTL, 0xf00), INTC_VECT(FLCTL, 0xf20),
-	INTC_VECT(FLCTL, 0xf40), INTC_VECT(FLCTL, 0xf60),
-	INTC_VECT(GPIO, 0xf80), INTC_VECT(GPIO, 0xfa0),
-	INTC_VECT(GPIO, 0xfc0), INTC_VECT(GPIO, 0xfe0),
-};
-
-static struct intc_group groups[] __initdata = {
-	INTC_GROUP(TMU012, TMU0, TMU1, TMU2, TMU2_TICPI),
-	INTC_GROUP(TMU345, TMU3, TMU4, TMU5),
-};
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xffd40038, 0xffd4003c, 32, /* INT2MSKR / INT2MSKCR */
-	  { 0, 0, 0, 0, 0, 0, GPIO, FLCTL,
-	    SSI, MMCIF, HSPI, SIOF, PCIC5, PCIINTD, PCIINTC, PCIINTB,
-	    PCIINTA, PCISERR, HAC, CMT, 0, 0, DMAC1, DMAC0,
-	    HUDI, 0, WDT, SCIF1, SCIF0, RTC, TMU345, TMU012 } },
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xffd40000, 0, 32, 8, /* INT2PRI0 */ { TMU0, TMU1,
-						 TMU2, TMU2_TICPI } },
-	{ 0xffd40004, 0, 32, 8, /* INT2PRI1 */ { TMU3, TMU4, TMU5, RTC } },
-	{ 0xffd40008, 0, 32, 8, /* INT2PRI2 */ { SCIF0, SCIF1, WDT } },
-	{ 0xffd4000c, 0, 32, 8, /* INT2PRI3 */ { HUDI, DMAC0, DMAC1 } },
-	{ 0xffd40010, 0, 32, 8, /* INT2PRI4 */ { CMT, HAC,
-						 PCISERR, PCIINTA, } },
-	{ 0xffd40014, 0, 32, 8, /* INT2PRI5 */ { PCIINTB, PCIINTC,
-						 PCIINTD, PCIC5 } },
-	{ 0xffd40018, 0, 32, 8, /* INT2PRI6 */ { SIOF, HSPI, MMCIF, SSI } },
-	{ 0xffd4001c, 0, 32, 8, /* INT2PRI7 */ { FLCTL, GPIO } },
-};
-
-static DECLARE_INTC_DESC(intc_desc, "sh7780", vectors, groups,
-			 mask_registers, prio_registers, NULL);
-
-/* Support for external interrupt pins in IRQ mode */
-
-static struct intc_vect irq_vectors[] __initdata = {
-	INTC_VECT(IRQ0, 0x240), INTC_VECT(IRQ1, 0x280),
-	INTC_VECT(IRQ2, 0x2c0), INTC_VECT(IRQ3, 0x300),
-	INTC_VECT(IRQ4, 0x340), INTC_VECT(IRQ5, 0x380),
-	INTC_VECT(IRQ6, 0x3c0), INTC_VECT(IRQ7, 0x200),
-};
-
-static struct intc_mask_reg irq_mask_registers[] __initdata = {
-	{ 0xffd00044, 0xffd00064, 32, /* INTMSK0 / INTMSKCLR0 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_prio_reg irq_prio_registers[] __initdata = {
-	{ 0xffd00010, 0, 32, 4, /* INTPRI */ { IRQ0, IRQ1, IRQ2, IRQ3,
-					       IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_sense_reg irq_sense_registers[] __initdata = {
-	{ 0xffd0001c, 32, 2, /* ICR1 */   { IRQ0, IRQ1, IRQ2, IRQ3,
-					    IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_mask_reg irq_ack_registers[] __initdata = {
-	{ 0xffd00024, 0, 32, /* INTREQ */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static DECLARE_INTC_DESC_ACK(intc_irq_desc, "sh7780-irq", irq_vectors,
-			     NULL, irq_mask_registers, irq_prio_registers,
-			     irq_sense_registers, irq_ack_registers);
-
-/* External interrupt pins in IRL mode */
-
-static struct intc_vect irl_vectors[] __initdata = {
-	INTC_VECT(IRL_LLLL, 0x200), INTC_VECT(IRL_LLLH, 0x220),
-	INTC_VECT(IRL_LLHL, 0x240), INTC_VECT(IRL_LLHH, 0x260),
-	INTC_VECT(IRL_LHLL, 0x280), INTC_VECT(IRL_LHLH, 0x2a0),
-	INTC_VECT(IRL_LHHL, 0x2c0), INTC_VECT(IRL_LHHH, 0x2e0),
-	INTC_VECT(IRL_HLLL, 0x300), INTC_VECT(IRL_HLLH, 0x320),
-	INTC_VECT(IRL_HLHL, 0x340), INTC_VECT(IRL_HLHH, 0x360),
-	INTC_VECT(IRL_HHLL, 0x380), INTC_VECT(IRL_HHLH, 0x3a0),
-	INTC_VECT(IRL_HHHL, 0x3c0),
-};
-
-static struct intc_mask_reg irl3210_mask_registers[] __initdata = {
-	{ 0xffd40080, 0xffd40084, 32, /* INTMSK2 / INTMSKCLR2 */
-	  { IRL_LLLL, IRL_LLLH, IRL_LLHL, IRL_LLHH,
-	    IRL_LHLL, IRL_LHLH, IRL_LHHL, IRL_LHHH,
-	    IRL_HLLL, IRL_HLLH, IRL_HLHL, IRL_HLHH,
-	    IRL_HHLL, IRL_HHLH, IRL_HHHL, } },
-};
-
-static struct intc_mask_reg irl7654_mask_registers[] __initdata = {
-	{ 0xffd40080, 0xffd40084, 32, /* INTMSK2 / INTMSKCLR2 */
-	  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	    IRL_LLLL, IRL_LLLH, IRL_LLHL, IRL_LLHH,
-	    IRL_LHLL, IRL_LHLH, IRL_LHHL, IRL_LHHH,
-	    IRL_HLLL, IRL_HLLH, IRL_HLHL, IRL_HLHH,
-	    IRL_HHLL, IRL_HHLH, IRL_HHHL, } },
-};
-
-static DECLARE_INTC_DESC(intc_irl7654_desc, "sh7780-irl7654", irl_vectors,
-			 NULL, irl7654_mask_registers, NULL, NULL);
-
-static DECLARE_INTC_DESC(intc_irl3210_desc, "sh7780-irl3210", irl_vectors,
-			 NULL, irl3210_mask_registers, NULL, NULL);
-
-#define INTC_ICR0	0xffd00000
-#define INTC_INTMSK0	0xffd00044
-#define INTC_INTMSK1	0xffd00048
-#define INTC_INTMSK2	0xffd40080
-#define INTC_INTMSKCLR1	0xffd00068
-#define INTC_INTMSKCLR2	0xffd40084
-
-void __init plat_irq_setup(void)
-{
-	/* disable IRQ7-0 */
-	__raw_writel(0xff000000, INTC_INTMSK0);
-
-	/* disable IRL3-0 + IRL7-4 */
-	__raw_writel(0xc0000000, INTC_INTMSK1);
-	__raw_writel(0xfffefffe, INTC_INTMSK2);
-
-	/* select IRL mode for IRL3-0 + IRL7-4 */
-	__raw_writel(__raw_readl(INTC_ICR0) & ~0x00c00000, INTC_ICR0);
-
-	/* disable holding function, ie enable "SH-4 Mode" */
-	__raw_writel(__raw_readl(INTC_ICR0) | 0x00200000, INTC_ICR0);
-
-	register_intc_controller(&intc_desc);
-}
-
-void __init plat_irq_setup_pins(int mode)
-{
-	switch (mode) {
-	case IRQ_MODE_IRQ:
-		/* select IRQ mode for IRL3-0 + IRL7-4 */
-		__raw_writel(__raw_readl(INTC_ICR0) | 0x00c00000, INTC_ICR0);
-		register_intc_controller(&intc_irq_desc);
-		break;
-	case IRQ_MODE_IRL7654:
-		/* enable IRL7-4 but don't provide any masking */
-		__raw_writel(0x40000000, INTC_INTMSKCLR1);
-		__raw_writel(0x0000fffe, INTC_INTMSKCLR2);
-		break;
-	case IRQ_MODE_IRL3210:
-		/* enable IRL0-3 but don't provide any masking */
-		__raw_writel(0x80000000, INTC_INTMSKCLR1);
-		__raw_writel(0xfffe0000, INTC_INTMSKCLR2);
-		break;
-	case IRQ_MODE_IRL7654_MASK:
-		/* enable IRL7-4 and mask using cpu intc controller */
-		__raw_writel(0x40000000, INTC_INTMSKCLR1);
-		register_intc_controller(&intc_irl7654_desc);
-		break;
-	case IRQ_MODE_IRL3210_MASK:
-		/* enable IRL0-3 and mask using cpu intc controller */
-		__raw_writel(0x80000000, INTC_INTMSKCLR1);
-		register_intc_controller(&intc_irl3210_desc);
-		break;
-	default:
-		BUG();
-	}
-}
diff --git a/arch/sh/kernel/cpu/sh4a/setup-sh7785.c b/arch/sh/kernel/cpu/sh4a/setup-sh7785.c
deleted file mode 100644
index 3b4a414d60a91c..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/setup-sh7785.c
+++ /dev/null
@@ -1,608 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7785 Setup
- *
- *  Copyright (C) 2007  Paul Mundt
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/serial_sci.h>
-#include <linux/io.h>
-#include <linux/mm.h>
-#include <linux/sh_dma.h>
-#include <linux/sh_timer.h>
-#include <linux/sh_intc.h>
-#include <asm/mmzone.h>
-#include <asm/platform_early.h>
-#include <cpu/dma-register.h>
-
-static struct plat_sci_port scif0_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_CKE1,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xffea0000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x700)),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct plat_sci_port scif1_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_CKE1,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif1_resources[] = {
-	DEFINE_RES_MEM(0xffeb0000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x780)),
-};
-
-static struct platform_device scif1_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif1_resources,
-	.num_resources	= ARRAY_SIZE(scif1_resources),
-	.dev		= {
-		.platform_data	= &scif1_platform_data,
-	},
-};
-
-static struct plat_sci_port scif2_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_CKE1,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif2_resources[] = {
-	DEFINE_RES_MEM(0xffec0000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x980)),
-};
-
-static struct platform_device scif2_device = {
-	.name		= "sh-sci",
-	.id		= 2,
-	.resource	= scif2_resources,
-	.num_resources	= ARRAY_SIZE(scif2_resources),
-	.dev		= {
-		.platform_data	= &scif2_platform_data,
-	},
-};
-
-static struct plat_sci_port scif3_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_CKE1,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif3_resources[] = {
-	DEFINE_RES_MEM(0xffed0000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x9a0)),
-};
-
-static struct platform_device scif3_device = {
-	.name		= "sh-sci",
-	.id		= 3,
-	.resource	= scif3_resources,
-	.num_resources	= ARRAY_SIZE(scif3_resources),
-	.dev		= {
-		.platform_data	= &scif3_platform_data,
-	},
-};
-
-static struct plat_sci_port scif4_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_CKE1,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif4_resources[] = {
-	DEFINE_RES_MEM(0xffee0000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x9c0)),
-};
-
-static struct platform_device scif4_device = {
-	.name		= "sh-sci",
-	.id		= 4,
-	.resource	= scif4_resources,
-	.num_resources	= ARRAY_SIZE(scif4_resources),
-	.dev		= {
-		.platform_data	= &scif4_platform_data,
-	},
-};
-
-static struct plat_sci_port scif5_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_CKE1,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif5_resources[] = {
-	DEFINE_RES_MEM(0xffef0000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x9e0)),
-};
-
-static struct platform_device scif5_device = {
-	.name		= "sh-sci",
-	.id		= 5,
-	.resource	= scif5_resources,
-	.num_resources	= ARRAY_SIZE(scif5_resources),
-	.dev		= {
-		.platform_data	= &scif5_platform_data,
-	},
-};
-
-static struct sh_timer_config tmu0_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu0_resources[] = {
-	DEFINE_RES_MEM(0xffd80000, 0x30),
-	DEFINE_RES_IRQ(evt2irq(0x580)),
-	DEFINE_RES_IRQ(evt2irq(0x5a0)),
-	DEFINE_RES_IRQ(evt2irq(0x5c0)),
-};
-
-static struct platform_device tmu0_device = {
-	.name		= "sh-tmu",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &tmu0_platform_data,
-	},
-	.resource	= tmu0_resources,
-	.num_resources	= ARRAY_SIZE(tmu0_resources),
-};
-
-static struct sh_timer_config tmu1_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu1_resources[] = {
-	DEFINE_RES_MEM(0xffdc0000, 0x2c),
-	DEFINE_RES_IRQ(evt2irq(0xe00)),
-	DEFINE_RES_IRQ(evt2irq(0xe20)),
-	DEFINE_RES_IRQ(evt2irq(0xe40)),
-};
-
-static struct platform_device tmu1_device = {
-	.name		= "sh-tmu",
-	.id		= 1,
-	.dev = {
-		.platform_data	= &tmu1_platform_data,
-	},
-	.resource	= tmu1_resources,
-	.num_resources	= ARRAY_SIZE(tmu1_resources),
-};
-
-/* DMA */
-static const struct sh_dmae_channel sh7785_dmae0_channels[] = {
-	{
-		.offset = 0,
-		.dmars = 0,
-		.dmars_bit = 0,
-	}, {
-		.offset = 0x10,
-		.dmars = 0,
-		.dmars_bit = 8,
-	}, {
-		.offset = 0x20,
-		.dmars = 4,
-		.dmars_bit = 0,
-	}, {
-		.offset = 0x30,
-		.dmars = 4,
-		.dmars_bit = 8,
-	}, {
-		.offset = 0x50,
-		.dmars = 8,
-		.dmars_bit = 0,
-	}, {
-		.offset = 0x60,
-		.dmars = 8,
-		.dmars_bit = 8,
-	}
-};
-
-static const struct sh_dmae_channel sh7785_dmae1_channels[] = {
-	{
-		.offset = 0,
-	}, {
-		.offset = 0x10,
-	}, {
-		.offset = 0x20,
-	}, {
-		.offset = 0x30,
-	}, {
-		.offset = 0x50,
-	}, {
-		.offset = 0x60,
-	}
-};
-
-static const unsigned int ts_shift[] = TS_SHIFT;
-
-static struct sh_dmae_pdata dma0_platform_data = {
-	.channel	= sh7785_dmae0_channels,
-	.channel_num	= ARRAY_SIZE(sh7785_dmae0_channels),
-	.ts_low_shift	= CHCR_TS_LOW_SHIFT,
-	.ts_low_mask	= CHCR_TS_LOW_MASK,
-	.ts_high_shift	= CHCR_TS_HIGH_SHIFT,
-	.ts_high_mask	= CHCR_TS_HIGH_MASK,
-	.ts_shift	= ts_shift,
-	.ts_shift_num	= ARRAY_SIZE(ts_shift),
-	.dmaor_init	= DMAOR_INIT,
-};
-
-static struct sh_dmae_pdata dma1_platform_data = {
-	.channel	= sh7785_dmae1_channels,
-	.channel_num	= ARRAY_SIZE(sh7785_dmae1_channels),
-	.ts_low_shift	= CHCR_TS_LOW_SHIFT,
-	.ts_low_mask	= CHCR_TS_LOW_MASK,
-	.ts_high_shift	= CHCR_TS_HIGH_SHIFT,
-	.ts_high_mask	= CHCR_TS_HIGH_MASK,
-	.ts_shift	= ts_shift,
-	.ts_shift_num	= ARRAY_SIZE(ts_shift),
-	.dmaor_init	= DMAOR_INIT,
-};
-
-static struct resource sh7785_dmae0_resources[] = {
-	[0] = {
-		/* Channel registers and DMAOR */
-		.start	= 0xfc808020,
-		.end	= 0xfc80808f,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		/* DMARSx */
-		.start	= 0xfc809000,
-		.end	= 0xfc80900b,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		/*
-		 * Real DMA error vector is 0x6e0, and channel
-		 * vectors are 0x620-0x6c0
-		 */
-		.name	= "error_irq",
-		.start	= evt2irq(0x620),
-		.end	= evt2irq(0x620),
-		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_SHAREABLE,
-	},
-};
-
-static struct resource sh7785_dmae1_resources[] = {
-	[0] = {
-		/* Channel registers and DMAOR */
-		.start	= 0xfcc08020,
-		.end	= 0xfcc0808f,
-		.flags	= IORESOURCE_MEM,
-	},
-	/* DMAC1 has no DMARS */
-	{
-		/*
-		 * Real DMA error vector is 0x940, and channel
-		 * vectors are 0x880-0x920
-		 */
-		.name	= "error_irq",
-		.start	= evt2irq(0x880),
-		.end	= evt2irq(0x880),
-		.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_SHAREABLE,
-	},
-};
-
-static struct platform_device dma0_device = {
-	.name           = "sh-dma-engine",
-	.id             = 0,
-	.resource	= sh7785_dmae0_resources,
-	.num_resources	= ARRAY_SIZE(sh7785_dmae0_resources),
-	.dev            = {
-		.platform_data	= &dma0_platform_data,
-	},
-};
-
-static struct platform_device dma1_device = {
-	.name		= "sh-dma-engine",
-	.id		= 1,
-	.resource	= sh7785_dmae1_resources,
-	.num_resources	= ARRAY_SIZE(sh7785_dmae1_resources),
-	.dev		= {
-		.platform_data	= &dma1_platform_data,
-	},
-};
-
-static struct platform_device *sh7785_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&scif4_device,
-	&scif5_device,
-	&tmu0_device,
-	&tmu1_device,
-	&dma0_device,
-	&dma1_device,
-};
-
-static int __init sh7785_devices_setup(void)
-{
-	return platform_add_devices(sh7785_devices,
-				    ARRAY_SIZE(sh7785_devices));
-}
-arch_initcall(sh7785_devices_setup);
-
-static struct platform_device *sh7785_early_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&scif4_device,
-	&scif5_device,
-	&tmu0_device,
-	&tmu1_device,
-};
-
-void __init plat_early_device_setup(void)
-{
-	sh_early_platform_add_devices(sh7785_early_devices,
-				   ARRAY_SIZE(sh7785_early_devices));
-}
-
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-
-	IRL0_LLLL, IRL0_LLLH, IRL0_LLHL, IRL0_LLHH,
-	IRL0_LHLL, IRL0_LHLH, IRL0_LHHL, IRL0_LHHH,
-	IRL0_HLLL, IRL0_HLLH, IRL0_HLHL, IRL0_HLHH,
-	IRL0_HHLL, IRL0_HHLH, IRL0_HHHL,
-
-	IRL4_LLLL, IRL4_LLLH, IRL4_LLHL, IRL4_LLHH,
-	IRL4_LHLL, IRL4_LHLH, IRL4_LHHL, IRL4_LHHH,
-	IRL4_HLLL, IRL4_HLLH, IRL4_HLHL, IRL4_HLHH,
-	IRL4_HHLL, IRL4_HHLH, IRL4_HHHL,
-
-	IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7,
-	WDT, TMU0, TMU1, TMU2, TMU2_TICPI,
-	HUDI, DMAC0, SCIF0, SCIF1, DMAC1, HSPI,
-	SCIF2, SCIF3, SCIF4, SCIF5,
-	PCISERR, PCIINTA, PCIINTB, PCIINTC, PCIINTD, PCIC5,
-	SIOF, MMCIF, DU, GDTA,
-	TMU3, TMU4, TMU5,
-	SSI0, SSI1,
-	HAC0, HAC1,
-	FLCTL, GPIO,
-
-	/* interrupt groups */
-
-	TMU012,	TMU345
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_VECT(WDT, 0x560),
-	INTC_VECT(TMU0, 0x580), INTC_VECT(TMU1, 0x5a0),
-	INTC_VECT(TMU2, 0x5c0), INTC_VECT(TMU2_TICPI, 0x5e0),
-	INTC_VECT(HUDI, 0x600),
-	INTC_VECT(DMAC0, 0x620), INTC_VECT(DMAC0, 0x640),
-	INTC_VECT(DMAC0, 0x660), INTC_VECT(DMAC0, 0x680),
-	INTC_VECT(DMAC0, 0x6a0), INTC_VECT(DMAC0, 0x6c0),
-	INTC_VECT(DMAC0, 0x6e0),
-	INTC_VECT(SCIF0, 0x700), INTC_VECT(SCIF0, 0x720),
-	INTC_VECT(SCIF0, 0x740), INTC_VECT(SCIF0, 0x760),
-	INTC_VECT(SCIF1, 0x780), INTC_VECT(SCIF1, 0x7a0),
-	INTC_VECT(SCIF1, 0x7c0), INTC_VECT(SCIF1, 0x7e0),
-	INTC_VECT(DMAC1, 0x880), INTC_VECT(DMAC1, 0x8a0),
-	INTC_VECT(DMAC1, 0x8c0), INTC_VECT(DMAC1, 0x8e0),
-	INTC_VECT(DMAC1, 0x900), INTC_VECT(DMAC1, 0x920),
-	INTC_VECT(DMAC1, 0x940),
-	INTC_VECT(HSPI, 0x960),
-	INTC_VECT(SCIF2, 0x980), INTC_VECT(SCIF3, 0x9a0),
-	INTC_VECT(SCIF4, 0x9c0), INTC_VECT(SCIF5, 0x9e0),
-	INTC_VECT(PCISERR, 0xa00), INTC_VECT(PCIINTA, 0xa20),
-	INTC_VECT(PCIINTB, 0xa40), INTC_VECT(PCIINTC, 0xa60),
-	INTC_VECT(PCIINTD, 0xa80), INTC_VECT(PCIC5, 0xaa0),
-	INTC_VECT(PCIC5, 0xac0), INTC_VECT(PCIC5, 0xae0),
-	INTC_VECT(PCIC5, 0xb00), INTC_VECT(PCIC5, 0xb20),
-	INTC_VECT(SIOF, 0xc00),
-	INTC_VECT(MMCIF, 0xd00), INTC_VECT(MMCIF, 0xd20),
-	INTC_VECT(MMCIF, 0xd40), INTC_VECT(MMCIF, 0xd60),
-	INTC_VECT(DU, 0xd80),
-	INTC_VECT(GDTA, 0xda0), INTC_VECT(GDTA, 0xdc0),
-	INTC_VECT(GDTA, 0xde0),
-	INTC_VECT(TMU3, 0xe00), INTC_VECT(TMU4, 0xe20),
-	INTC_VECT(TMU5, 0xe40),
-	INTC_VECT(SSI0, 0xe80), INTC_VECT(SSI1, 0xea0),
-	INTC_VECT(HAC0, 0xec0), INTC_VECT(HAC1, 0xee0),
-	INTC_VECT(FLCTL, 0xf00), INTC_VECT(FLCTL, 0xf20),
-	INTC_VECT(FLCTL, 0xf40), INTC_VECT(FLCTL, 0xf60),
-	INTC_VECT(GPIO, 0xf80), INTC_VECT(GPIO, 0xfa0),
-	INTC_VECT(GPIO, 0xfc0), INTC_VECT(GPIO, 0xfe0),
-};
-
-static struct intc_group groups[] __initdata = {
-	INTC_GROUP(TMU012, TMU0, TMU1, TMU2, TMU2_TICPI),
-	INTC_GROUP(TMU345, TMU3, TMU4, TMU5),
-};
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xffd00044, 0xffd00064, 32, /* INTMSK0 / INTMSKCLR0 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-
-	{ 0xffd40080, 0xffd40084, 32, /* INTMSK2 / INTMSKCLR2 */
-	  { IRL0_LLLL, IRL0_LLLH, IRL0_LLHL, IRL0_LLHH,
-	    IRL0_LHLL, IRL0_LHLH, IRL0_LHHL, IRL0_LHHH,
-	    IRL0_HLLL, IRL0_HLLH, IRL0_HLHL, IRL0_HLHH,
-	    IRL0_HHLL, IRL0_HHLH, IRL0_HHHL, 0,
-	    IRL4_LLLL, IRL4_LLLH, IRL4_LLHL, IRL4_LLHH,
-	    IRL4_LHLL, IRL4_LHLH, IRL4_LHHL, IRL4_LHHH,
-	    IRL4_HLLL, IRL4_HLLH, IRL4_HLHL, IRL4_HLHH,
-	    IRL4_HHLL, IRL4_HHLH, IRL4_HHHL, 0, } },
-
-	{ 0xffd40038, 0xffd4003c, 32, /* INT2MSKR / INT2MSKCR */
-	  { 0, 0, 0, GDTA, DU, SSI0, SSI1, GPIO,
-	    FLCTL, MMCIF, HSPI, SIOF, PCIC5, PCIINTD, PCIINTC, PCIINTB,
-	    PCIINTA, PCISERR, HAC1, HAC0, DMAC1, DMAC0, HUDI, WDT,
-	    SCIF5, SCIF4, SCIF3, SCIF2, SCIF1, SCIF0, TMU345, TMU012 } },
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xffd00010, 0, 32, 4, /* INTPRI */   { IRQ0, IRQ1, IRQ2, IRQ3,
-						 IRQ4, IRQ5, IRQ6, IRQ7 } },
-	{ 0xffd40000, 0, 32, 8, /* INT2PRI0 */ { TMU0, TMU1,
-						 TMU2, TMU2_TICPI } },
-	{ 0xffd40004, 0, 32, 8, /* INT2PRI1 */ { TMU3, TMU4, TMU5, } },
-	{ 0xffd40008, 0, 32, 8, /* INT2PRI2 */ { SCIF0, SCIF1,
-						 SCIF2, SCIF3 } },
-	{ 0xffd4000c, 0, 32, 8, /* INT2PRI3 */ { SCIF4, SCIF5, WDT, } },
-	{ 0xffd40010, 0, 32, 8, /* INT2PRI4 */ { HUDI, DMAC0, DMAC1, } },
-	{ 0xffd40014, 0, 32, 8, /* INT2PRI5 */ { HAC0, HAC1,
-						 PCISERR, PCIINTA } },
-	{ 0xffd40018, 0, 32, 8, /* INT2PRI6 */ { PCIINTB, PCIINTC,
-						 PCIINTD, PCIC5 } },
-	{ 0xffd4001c, 0, 32, 8, /* INT2PRI7 */ { SIOF, HSPI, MMCIF, } },
-	{ 0xffd40020, 0, 32, 8, /* INT2PRI8 */ { FLCTL, GPIO, SSI0, SSI1, } },
-	{ 0xffd40024, 0, 32, 8, /* INT2PRI9 */ { DU, GDTA, } },
-};
-
-static DECLARE_INTC_DESC(intc_desc, "sh7785", vectors, groups,
-			 mask_registers, prio_registers, NULL);
-
-/* Support for external interrupt pins in IRQ mode */
-
-static struct intc_vect vectors_irq0123[] __initdata = {
-	INTC_VECT(IRQ0, 0x240), INTC_VECT(IRQ1, 0x280),
-	INTC_VECT(IRQ2, 0x2c0), INTC_VECT(IRQ3, 0x300),
-};
-
-static struct intc_vect vectors_irq4567[] __initdata = {
-	INTC_VECT(IRQ4, 0x340), INTC_VECT(IRQ5, 0x380),
-	INTC_VECT(IRQ6, 0x3c0), INTC_VECT(IRQ7, 0x200),
-};
-
-static struct intc_sense_reg sense_registers[] __initdata = {
-	{ 0xffd0001c, 32, 2, /* ICR1 */   { IRQ0, IRQ1, IRQ2, IRQ3,
-					    IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_mask_reg ack_registers[] __initdata = {
-	{ 0xffd00024, 0, 32, /* INTREQ */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static DECLARE_INTC_DESC_ACK(intc_desc_irq0123, "sh7785-irq0123",
-			     vectors_irq0123, NULL, mask_registers,
-			     prio_registers, sense_registers, ack_registers);
-
-static DECLARE_INTC_DESC_ACK(intc_desc_irq4567, "sh7785-irq4567",
-			     vectors_irq4567, NULL, mask_registers,
-			     prio_registers, sense_registers, ack_registers);
-
-/* External interrupt pins in IRL mode */
-
-static struct intc_vect vectors_irl0123[] __initdata = {
-	INTC_VECT(IRL0_LLLL, 0x200), INTC_VECT(IRL0_LLLH, 0x220),
-	INTC_VECT(IRL0_LLHL, 0x240), INTC_VECT(IRL0_LLHH, 0x260),
-	INTC_VECT(IRL0_LHLL, 0x280), INTC_VECT(IRL0_LHLH, 0x2a0),
-	INTC_VECT(IRL0_LHHL, 0x2c0), INTC_VECT(IRL0_LHHH, 0x2e0),
-	INTC_VECT(IRL0_HLLL, 0x300), INTC_VECT(IRL0_HLLH, 0x320),
-	INTC_VECT(IRL0_HLHL, 0x340), INTC_VECT(IRL0_HLHH, 0x360),
-	INTC_VECT(IRL0_HHLL, 0x380), INTC_VECT(IRL0_HHLH, 0x3a0),
-	INTC_VECT(IRL0_HHHL, 0x3c0),
-};
-
-static struct intc_vect vectors_irl4567[] __initdata = {
-	INTC_VECT(IRL4_LLLL, 0xb00), INTC_VECT(IRL4_LLLH, 0xb20),
-	INTC_VECT(IRL4_LLHL, 0xb40), INTC_VECT(IRL4_LLHH, 0xb60),
-	INTC_VECT(IRL4_LHLL, 0xb80), INTC_VECT(IRL4_LHLH, 0xba0),
-	INTC_VECT(IRL4_LHHL, 0xbc0), INTC_VECT(IRL4_LHHH, 0xbe0),
-	INTC_VECT(IRL4_HLLL, 0xc00), INTC_VECT(IRL4_HLLH, 0xc20),
-	INTC_VECT(IRL4_HLHL, 0xc40), INTC_VECT(IRL4_HLHH, 0xc60),
-	INTC_VECT(IRL4_HHLL, 0xc80), INTC_VECT(IRL4_HHLH, 0xca0),
-	INTC_VECT(IRL4_HHHL, 0xcc0),
-};
-
-static DECLARE_INTC_DESC(intc_desc_irl0123, "sh7785-irl0123", vectors_irl0123,
-			 NULL, mask_registers, NULL, NULL);
-
-static DECLARE_INTC_DESC(intc_desc_irl4567, "sh7785-irl4567", vectors_irl4567,
-			 NULL, mask_registers, NULL, NULL);
-
-#define INTC_ICR0	0xffd00000
-#define INTC_INTMSK0	0xffd00044
-#define INTC_INTMSK1	0xffd00048
-#define INTC_INTMSK2	0xffd40080
-#define INTC_INTMSKCLR1	0xffd00068
-#define INTC_INTMSKCLR2	0xffd40084
-
-void __init plat_irq_setup(void)
-{
-	/* disable IRQ3-0 + IRQ7-4 */
-	__raw_writel(0xff000000, INTC_INTMSK0);
-
-	/* disable IRL3-0 + IRL7-4 */
-	__raw_writel(0xc0000000, INTC_INTMSK1);
-	__raw_writel(0xfffefffe, INTC_INTMSK2);
-
-	/* select IRL mode for IRL3-0 + IRL7-4 */
-	__raw_writel(__raw_readl(INTC_ICR0) & ~0x00c00000, INTC_ICR0);
-
-	/* disable holding function, ie enable "SH-4 Mode" */
-	__raw_writel(__raw_readl(INTC_ICR0) | 0x00200000, INTC_ICR0);
-
-	register_intc_controller(&intc_desc);
-}
-
-void __init plat_irq_setup_pins(int mode)
-{
-	switch (mode) {
-	case IRQ_MODE_IRQ7654:
-		/* select IRQ mode for IRL7-4 */
-		__raw_writel(__raw_readl(INTC_ICR0) | 0x00400000, INTC_ICR0);
-		register_intc_controller(&intc_desc_irq4567);
-		break;
-	case IRQ_MODE_IRQ3210:
-		/* select IRQ mode for IRL3-0 */
-		__raw_writel(__raw_readl(INTC_ICR0) | 0x00800000, INTC_ICR0);
-		register_intc_controller(&intc_desc_irq0123);
-		break;
-	case IRQ_MODE_IRL7654:
-		/* enable IRL7-4 but don't provide any masking */
-		__raw_writel(0x40000000, INTC_INTMSKCLR1);
-		__raw_writel(0x0000fffe, INTC_INTMSKCLR2);
-		break;
-	case IRQ_MODE_IRL3210:
-		/* enable IRL0-3 but don't provide any masking */
-		__raw_writel(0x80000000, INTC_INTMSKCLR1);
-		__raw_writel(0xfffe0000, INTC_INTMSKCLR2);
-		break;
-	case IRQ_MODE_IRL7654_MASK:
-		/* enable IRL7-4 and mask using cpu intc controller */
-		__raw_writel(0x40000000, INTC_INTMSKCLR1);
-		register_intc_controller(&intc_desc_irl4567);
-		break;
-	case IRQ_MODE_IRL3210_MASK:
-		/* enable IRL0-3 and mask using cpu intc controller */
-		__raw_writel(0x80000000, INTC_INTMSKCLR1);
-		register_intc_controller(&intc_desc_irl0123);
-		break;
-	default:
-		BUG();
-	}
-}
-
-void __init plat_mem_setup(void)
-{
-	/* Register the URAM space as Node 1 */
-	setup_bootmem_node(1, 0xe55f0000, 0xe5610000);
-}
diff --git a/arch/sh/kernel/cpu/sh4a/setup-sh7786.c b/arch/sh/kernel/cpu/sh4a/setup-sh7786.c
deleted file mode 100644
index 74620f30b19bad..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/setup-sh7786.c
+++ /dev/null
@@ -1,841 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH7786 Setup
- *
- * Copyright (C) 2009 - 2011  Renesas Solutions Corp.
- * Kuninori Morimoto <morimoto.kuninori@renesas.com>
- * Paul Mundt <paul.mundt@renesas.com>
- *
- * Based on SH7785 Setup
- *
- *  Copyright (C) 2007  Paul Mundt
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/serial_sci.h>
-#include <linux/io.h>
-#include <linux/mm.h>
-#include <linux/dma-mapping.h>
-#include <linux/sh_timer.h>
-#include <linux/sh_dma.h>
-#include <linux/sh_intc.h>
-#include <linux/usb/ohci_pdriver.h>
-#include <cpu/dma-register.h>
-#include <asm/mmzone.h>
-#include <asm/platform_early.h>
-
-static struct plat_sci_port scif0_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_CKE1,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xffea0000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x700)),
-	DEFINE_RES_IRQ(evt2irq(0x720)),
-	DEFINE_RES_IRQ(evt2irq(0x760)),
-	DEFINE_RES_IRQ(evt2irq(0x740)),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-/*
- * The rest of these all have multiplexed IRQs
- */
-static struct plat_sci_port scif1_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_CKE1,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif1_resources[] = {
-	DEFINE_RES_MEM(0xffeb0000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x780)),
-};
-
-static struct resource scif1_demux_resources[] = {
-	DEFINE_RES_MEM(0xffeb0000, 0x100),
-	/* Placeholders, see sh7786_devices_setup() */
-	DEFINE_RES_IRQ(0),
-	DEFINE_RES_IRQ(0),
-	DEFINE_RES_IRQ(0),
-	DEFINE_RES_IRQ(0),
-};
-
-static struct platform_device scif1_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif1_resources,
-	.num_resources	= ARRAY_SIZE(scif1_resources),
-	.dev		= {
-		.platform_data	= &scif1_platform_data,
-	},
-};
-
-static struct plat_sci_port scif2_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_CKE1,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif2_resources[] = {
-	DEFINE_RES_MEM(0xffec0000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x840)),
-};
-
-static struct platform_device scif2_device = {
-	.name		= "sh-sci",
-	.id		= 2,
-	.resource	= scif2_resources,
-	.num_resources	= ARRAY_SIZE(scif2_resources),
-	.dev		= {
-		.platform_data	= &scif2_platform_data,
-	},
-};
-
-static struct plat_sci_port scif3_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_CKE1,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif3_resources[] = {
-	DEFINE_RES_MEM(0xffed0000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x860)),
-};
-
-static struct platform_device scif3_device = {
-	.name		= "sh-sci",
-	.id		= 3,
-	.resource	= scif3_resources,
-	.num_resources	= ARRAY_SIZE(scif3_resources),
-	.dev		= {
-		.platform_data	= &scif3_platform_data,
-	},
-};
-
-static struct plat_sci_port scif4_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_CKE1,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif4_resources[] = {
-	DEFINE_RES_MEM(0xffee0000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x880)),
-};
-
-static struct platform_device scif4_device = {
-	.name		= "sh-sci",
-	.id		= 4,
-	.resource	= scif4_resources,
-	.num_resources	= ARRAY_SIZE(scif4_resources),
-	.dev		= {
-		.platform_data	= &scif4_platform_data,
-	},
-};
-
-static struct plat_sci_port scif5_platform_data = {
-	.scscr		= SCSCR_REIE | SCSCR_CKE1,
-	.type		= PORT_SCIF,
-	.regtype	= SCIx_SH4_SCIF_FIFODATA_REGTYPE,
-};
-
-static struct resource scif5_resources[] = {
-	DEFINE_RES_MEM(0xffef0000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x8a0)),
-};
-
-static struct platform_device scif5_device = {
-	.name		= "sh-sci",
-	.id		= 5,
-	.resource	= scif5_resources,
-	.num_resources	= ARRAY_SIZE(scif5_resources),
-	.dev		= {
-		.platform_data	= &scif5_platform_data,
-	},
-};
-
-static struct sh_timer_config tmu0_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu0_resources[] = {
-	DEFINE_RES_MEM(0xffd80000, 0x30),
-	DEFINE_RES_IRQ(evt2irq(0x400)),
-	DEFINE_RES_IRQ(evt2irq(0x420)),
-	DEFINE_RES_IRQ(evt2irq(0x440)),
-};
-
-static struct platform_device tmu0_device = {
-	.name		= "sh-tmu",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &tmu0_platform_data,
-	},
-	.resource	= tmu0_resources,
-	.num_resources	= ARRAY_SIZE(tmu0_resources),
-};
-
-static struct sh_timer_config tmu1_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu1_resources[] = {
-	DEFINE_RES_MEM(0xffda0000, 0x2c),
-	DEFINE_RES_IRQ(evt2irq(0x480)),
-	DEFINE_RES_IRQ(evt2irq(0x4a0)),
-	DEFINE_RES_IRQ(evt2irq(0x4c0)),
-};
-
-static struct platform_device tmu1_device = {
-	.name		= "sh-tmu",
-	.id		= 1,
-	.dev = {
-		.platform_data	= &tmu1_platform_data,
-	},
-	.resource	= tmu1_resources,
-	.num_resources	= ARRAY_SIZE(tmu1_resources),
-};
-
-static struct sh_timer_config tmu2_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu2_resources[] = {
-	DEFINE_RES_MEM(0xffdc0000, 0x2c),
-	DEFINE_RES_IRQ(evt2irq(0x7a0)),
-	DEFINE_RES_IRQ(evt2irq(0x7a0)),
-	DEFINE_RES_IRQ(evt2irq(0x7a0)),
-};
-
-static struct platform_device tmu2_device = {
-	.name		= "sh-tmu",
-	.id		= 2,
-	.dev = {
-		.platform_data	= &tmu2_platform_data,
-	},
-	.resource	= tmu2_resources,
-	.num_resources	= ARRAY_SIZE(tmu2_resources),
-};
-
-static struct sh_timer_config tmu3_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu3_resources[] = {
-	DEFINE_RES_MEM(0xffde0000, 0x2c),
-	DEFINE_RES_IRQ(evt2irq(0x7c0)),
-	DEFINE_RES_IRQ(evt2irq(0x7c0)),
-	DEFINE_RES_IRQ(evt2irq(0x7c0)),
-};
-
-static struct platform_device tmu3_device = {
-	.name		= "sh-tmu",
-	.id		= 3,
-	.dev = {
-		.platform_data	= &tmu3_platform_data,
-	},
-	.resource	= tmu3_resources,
-	.num_resources	= ARRAY_SIZE(tmu3_resources),
-};
-
-static const struct sh_dmae_channel dmac0_channels[] = {
-	{
-		.offset = 0,
-		.dmars = 0,
-		.dmars_bit = 0,
-	}, {
-		.offset = 0x10,
-		.dmars = 0,
-		.dmars_bit = 8,
-	}, {
-		.offset = 0x20,
-		.dmars = 4,
-		.dmars_bit = 0,
-	}, {
-		.offset = 0x30,
-		.dmars = 4,
-		.dmars_bit = 8,
-	}, {
-		.offset = 0x50,
-		.dmars = 8,
-		.dmars_bit = 0,
-	}, {
-		.offset = 0x60,
-		.dmars = 8,
-		.dmars_bit = 8,
-	}
-};
-
-static const unsigned int ts_shift[] = TS_SHIFT;
-
-static struct sh_dmae_pdata dma0_platform_data = {
-	.channel	= dmac0_channels,
-	.channel_num	= ARRAY_SIZE(dmac0_channels),
-	.ts_low_shift	= CHCR_TS_LOW_SHIFT,
-	.ts_low_mask	= CHCR_TS_LOW_MASK,
-	.ts_high_shift	= CHCR_TS_HIGH_SHIFT,
-	.ts_high_mask	= CHCR_TS_HIGH_MASK,
-	.ts_shift	= ts_shift,
-	.ts_shift_num	= ARRAY_SIZE(ts_shift),
-	.dmaor_init	= DMAOR_INIT,
-};
-
-/* Resource order important! */
-static struct resource dmac0_resources[] = {
-	{
-		/* Channel registers and DMAOR */
-		.start	= 0xfe008020,
-		.end	= 0xfe00808f,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		/* DMARSx */
-		.start	= 0xfe009000,
-		.end	= 0xfe00900b,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.name	= "error_irq",
-		.start	= evt2irq(0x5c0),
-		.end	= evt2irq(0x5c0),
-		.flags	= IORESOURCE_IRQ,
-	}, {
-		/* IRQ for channels 0-5 */
-		.start	= evt2irq(0x500),
-		.end	= evt2irq(0x5a0),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device dma0_device = {
-	.name		= "sh-dma-engine",
-	.id		= 0,
-	.resource	= dmac0_resources,
-	.num_resources	= ARRAY_SIZE(dmac0_resources),
-	.dev		= {
-		.platform_data	= &dma0_platform_data,
-	},
-};
-
-#define USB_EHCI_START 0xffe70000
-#define USB_OHCI_START 0xffe70400
-
-static struct resource usb_ehci_resources[] = {
-	[0] = {
-		.start	= USB_EHCI_START,
-		.end	= USB_EHCI_START + 0x3ff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0xba0),
-		.end	= evt2irq(0xba0),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device usb_ehci_device = {
-	.name		= "sh_ehci",
-	.id		= -1,
-	.dev = {
-		.dma_mask		= &usb_ehci_device.dev.coherent_dma_mask,
-		.coherent_dma_mask	= DMA_BIT_MASK(32),
-	},
-	.num_resources	= ARRAY_SIZE(usb_ehci_resources),
-	.resource	= usb_ehci_resources,
-};
-
-static struct resource usb_ohci_resources[] = {
-	[0] = {
-		.start	= USB_OHCI_START,
-		.end	= USB_OHCI_START + 0x3ff,
-		.flags	= IORESOURCE_MEM,
-	},
-	[1] = {
-		.start	= evt2irq(0xba0),
-		.end	= evt2irq(0xba0),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct usb_ohci_pdata usb_ohci_pdata;
-
-static struct platform_device usb_ohci_device = {
-	.name		= "ohci-platform",
-	.id		= -1,
-	.dev = {
-		.dma_mask		= &usb_ohci_device.dev.coherent_dma_mask,
-		.coherent_dma_mask	= DMA_BIT_MASK(32),
-		.platform_data		= &usb_ohci_pdata,
-	},
-	.num_resources	= ARRAY_SIZE(usb_ohci_resources),
-	.resource	= usb_ohci_resources,
-};
-
-static struct platform_device *sh7786_early_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&scif3_device,
-	&scif4_device,
-	&scif5_device,
-	&tmu0_device,
-	&tmu1_device,
-	&tmu2_device,
-	&tmu3_device,
-};
-
-static struct platform_device *sh7786_devices[] __initdata = {
-	&dma0_device,
-	&usb_ehci_device,
-	&usb_ohci_device,
-};
-
-/*
- * Please call this function if your platform board
- * use external clock for USB
- * */
-#define USBCTL0		0xffe70858
-#define CLOCK_MODE_MASK 0xffffff7f
-#define EXT_CLOCK_MODE  0x00000080
-
-void __init sh7786_usb_use_exclock(void)
-{
-	u32 val = __raw_readl(USBCTL0) & CLOCK_MODE_MASK;
-	__raw_writel(val | EXT_CLOCK_MODE, USBCTL0);
-}
-
-#define USBINITREG1	0xffe70094
-#define USBINITREG2	0xffe7009c
-#define USBINITVAL1	0x00ff0040
-#define USBINITVAL2	0x00000001
-
-#define USBPCTL1	0xffe70804
-#define USBST		0xffe70808
-#define PHY_ENB		0x00000001
-#define PLL_ENB		0x00000002
-#define PHY_RST		0x00000004
-#define ACT_PLL_STATUS	0xc0000000
-
-static void __init sh7786_usb_setup(void)
-{
-	int i = 1000000;
-
-	/*
-	 * USB initial settings
-	 *
-	 * The following settings are necessary
-	 * for using the USB modules.
-	 *
-	 * see "USB Initial Settings" for detail
-	 */
-	__raw_writel(USBINITVAL1, USBINITREG1);
-	__raw_writel(USBINITVAL2, USBINITREG2);
-
-	/*
-	 * Set the PHY and PLL enable bit
-	 */
-	__raw_writel(PHY_ENB | PLL_ENB, USBPCTL1);
-	while (i--) {
-		if (ACT_PLL_STATUS == (__raw_readl(USBST) & ACT_PLL_STATUS)) {
-			/* Set the PHY RST bit */
-			__raw_writel(PHY_ENB | PLL_ENB | PHY_RST, USBPCTL1);
-			printk(KERN_INFO "sh7786 usb setup done\n");
-			break;
-		}
-		cpu_relax();
-	}
-}
-
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-	IRL0_LLLL, IRL0_LLLH, IRL0_LLHL, IRL0_LLHH,
-	IRL0_LHLL, IRL0_LHLH, IRL0_LHHL, IRL0_LHHH,
-	IRL0_HLLL, IRL0_HLLH, IRL0_HLHL, IRL0_HLHH,
-	IRL0_HHLL, IRL0_HHLH, IRL0_HHHL,
-
-	IRL4_LLLL, IRL4_LLLH, IRL4_LLHL, IRL4_LLHH,
-	IRL4_LHLL, IRL4_LHLH, IRL4_LHHL, IRL4_LHHH,
-	IRL4_HLLL, IRL4_HLLH, IRL4_HLHL, IRL4_HLHH,
-	IRL4_HHLL, IRL4_HHLH, IRL4_HHHL,
-
-	IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7,
-	WDT,
-	TMU0_0, TMU0_1, TMU0_2, TMU0_3,
-	TMU1_0, TMU1_1, TMU1_2,
-	DMAC0_0, DMAC0_1, DMAC0_2, DMAC0_3, DMAC0_4, DMAC0_5, DMAC0_6,
-	HUDI1, HUDI0,
-	DMAC1_0, DMAC1_1, DMAC1_2, DMAC1_3,
-	HPB_0, HPB_1, HPB_2,
-	SCIF0_0, SCIF0_1, SCIF0_2, SCIF0_3,
-	SCIF1,
-	TMU2, TMU3,
-	SCIF2, SCIF3, SCIF4, SCIF5,
-	Eth_0, Eth_1,
-	PCIeC0_0, PCIeC0_1, PCIeC0_2,
-	PCIeC1_0, PCIeC1_1, PCIeC1_2,
-	USB,
-	I2C0, I2C1,
-	DU,
-	SSI0, SSI1, SSI2, SSI3,
-	PCIeC2_0, PCIeC2_1, PCIeC2_2,
-	HAC0, HAC1,
-	FLCTL,
-	HSPI,
-	GPIO0, GPIO1,
-	Thermal,
-	INTICI0, INTICI1, INTICI2, INTICI3,
-	INTICI4, INTICI5, INTICI6, INTICI7,
-
-	/* Muxed sub-events */
-	TXI1, BRI1, RXI1, ERI1,
-};
-
-static struct intc_vect sh7786_vectors[] __initdata = {
-	INTC_VECT(WDT, 0x3e0),
-	INTC_VECT(TMU0_0, 0x400), INTC_VECT(TMU0_1, 0x420),
-	INTC_VECT(TMU0_2, 0x440), INTC_VECT(TMU0_3, 0x460),
-	INTC_VECT(TMU1_0, 0x480), INTC_VECT(TMU1_1, 0x4a0),
-	INTC_VECT(TMU1_2, 0x4c0),
-	INTC_VECT(DMAC0_0, 0x500), INTC_VECT(DMAC0_1, 0x520),
-	INTC_VECT(DMAC0_2, 0x540), INTC_VECT(DMAC0_3, 0x560),
-	INTC_VECT(DMAC0_4, 0x580), INTC_VECT(DMAC0_5, 0x5a0),
-	INTC_VECT(DMAC0_6, 0x5c0),
-	INTC_VECT(HUDI1, 0x5e0), INTC_VECT(HUDI0, 0x600),
-	INTC_VECT(DMAC1_0, 0x620), INTC_VECT(DMAC1_1, 0x640),
-	INTC_VECT(DMAC1_2, 0x660), INTC_VECT(DMAC1_3, 0x680),
-	INTC_VECT(HPB_0, 0x6a0), INTC_VECT(HPB_1, 0x6c0),
-	INTC_VECT(HPB_2, 0x6e0),
-	INTC_VECT(SCIF0_0, 0x700), INTC_VECT(SCIF0_1, 0x720),
-	INTC_VECT(SCIF0_2, 0x740), INTC_VECT(SCIF0_3, 0x760),
-	INTC_VECT(SCIF1, 0x780),
-	INTC_VECT(TMU2, 0x7a0), INTC_VECT(TMU3, 0x7c0),
-	INTC_VECT(SCIF2, 0x840), INTC_VECT(SCIF3, 0x860),
-	INTC_VECT(SCIF4, 0x880), INTC_VECT(SCIF5, 0x8a0),
-	INTC_VECT(Eth_0, 0x8c0), INTC_VECT(Eth_1, 0x8e0),
-	INTC_VECT(PCIeC0_0, 0xae0), INTC_VECT(PCIeC0_1, 0xb00),
-	INTC_VECT(PCIeC0_2, 0xb20),
-	INTC_VECT(PCIeC1_0, 0xb40), INTC_VECT(PCIeC1_1, 0xb60),
-	INTC_VECT(PCIeC1_2, 0xb80),
-	INTC_VECT(USB, 0xba0),
-	INTC_VECT(I2C0, 0xcc0), INTC_VECT(I2C1, 0xce0),
-	INTC_VECT(DU, 0xd00),
-	INTC_VECT(SSI0, 0xd20), INTC_VECT(SSI1, 0xd40),
-	INTC_VECT(SSI2, 0xd60), INTC_VECT(SSI3, 0xd80),
-	INTC_VECT(PCIeC2_0, 0xda0), INTC_VECT(PCIeC2_1, 0xdc0),
-	INTC_VECT(PCIeC2_2, 0xde0),
-	INTC_VECT(HAC0, 0xe00), INTC_VECT(HAC1, 0xe20),
-	INTC_VECT(FLCTL, 0xe40),
-	INTC_VECT(HSPI, 0xe80),
-	INTC_VECT(GPIO0, 0xea0), INTC_VECT(GPIO1, 0xec0),
-	INTC_VECT(Thermal, 0xee0),
-	INTC_VECT(INTICI0, 0xf00), INTC_VECT(INTICI1, 0xf20),
-	INTC_VECT(INTICI2, 0xf40), INTC_VECT(INTICI3, 0xf60),
-	INTC_VECT(INTICI4, 0xf80), INTC_VECT(INTICI5, 0xfa0),
-	INTC_VECT(INTICI6, 0xfc0), INTC_VECT(INTICI7, 0xfe0),
-};
-
-#define CnINTMSK0	0xfe410030
-#define CnINTMSK1	0xfe410040
-#define CnINTMSKCLR0	0xfe410050
-#define CnINTMSKCLR1	0xfe410060
-#define CnINT2MSKR0	0xfe410a20
-#define CnINT2MSKR1	0xfe410a24
-#define CnINT2MSKR2	0xfe410a28
-#define CnINT2MSKR3	0xfe410a2c
-#define CnINT2MSKCR0	0xfe410a30
-#define CnINT2MSKCR1	0xfe410a34
-#define CnINT2MSKCR2	0xfe410a38
-#define CnINT2MSKCR3	0xfe410a3c
-#define INTMSK2		0xfe410068
-#define INTMSKCLR2	0xfe41006c
-
-#define INTDISTCR0	0xfe4100b0
-#define INTDISTCR1	0xfe4100b4
-#define INT2DISTCR0	0xfe410900
-#define INT2DISTCR1	0xfe410904
-#define INT2DISTCR2	0xfe410908
-#define INT2DISTCR3	0xfe41090c
-
-static struct intc_mask_reg sh7786_mask_registers[] __initdata = {
-	{ CnINTMSK0, CnINTMSKCLR0, 32,
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 },
-	    INTC_SMP_BALANCING(INTDISTCR0) },
-	{ INTMSK2, INTMSKCLR2, 32,
-	  { IRL0_LLLL, IRL0_LLLH, IRL0_LLHL, IRL0_LLHH,
-	    IRL0_LHLL, IRL0_LHLH, IRL0_LHHL, IRL0_LHHH,
-	    IRL0_HLLL, IRL0_HLLH, IRL0_HLHL, IRL0_HLHH,
-	    IRL0_HHLL, IRL0_HHLH, IRL0_HHHL, 0,
-	    IRL4_LLLL, IRL4_LLLH, IRL4_LLHL, IRL4_LLHH,
-	    IRL4_LHLL, IRL4_LHLH, IRL4_LHHL, IRL4_LHHH,
-	    IRL4_HLLL, IRL4_HLLH, IRL4_HLHL, IRL4_HLHH,
-	    IRL4_HHLL, IRL4_HHLH, IRL4_HHHL, 0, } },
-	{ CnINT2MSKR0, CnINT2MSKCR0 , 32,
-	  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, WDT },
-	    INTC_SMP_BALANCING(INT2DISTCR0) },
-	{ CnINT2MSKR1, CnINT2MSKCR1, 32,
-	  { TMU0_0, TMU0_1, TMU0_2, TMU0_3, TMU1_0, TMU1_1, TMU1_2, 0,
-	    DMAC0_0, DMAC0_1, DMAC0_2, DMAC0_3, DMAC0_4, DMAC0_5, DMAC0_6,
-	    HUDI1, HUDI0,
-	    DMAC1_0, DMAC1_1, DMAC1_2, DMAC1_3,
-	    HPB_0, HPB_1, HPB_2,
-	    SCIF0_0, SCIF0_1, SCIF0_2, SCIF0_3,
-	    SCIF1,
-	    TMU2, TMU3, 0, }, INTC_SMP_BALANCING(INT2DISTCR1) },
-	{ CnINT2MSKR2, CnINT2MSKCR2, 32,
-	  { 0, 0, SCIF2, SCIF3, SCIF4, SCIF5,
-	    Eth_0, Eth_1,
-	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	    PCIeC0_0, PCIeC0_1, PCIeC0_2,
-	    PCIeC1_0, PCIeC1_1, PCIeC1_2,
-	    USB, 0, 0 }, INTC_SMP_BALANCING(INT2DISTCR2) },
-	{ CnINT2MSKR3, CnINT2MSKCR3, 32,
-	  { 0, 0, 0, 0, 0, 0,
-	    I2C0, I2C1,
-	    DU, SSI0, SSI1, SSI2, SSI3,
-	    PCIeC2_0, PCIeC2_1, PCIeC2_2,
-	    HAC0, HAC1,
-	    FLCTL, 0,
-	    HSPI, GPIO0, GPIO1, Thermal,
-	    0, 0, 0, 0, 0, 0, 0, 0 }, INTC_SMP_BALANCING(INT2DISTCR3) },
-};
-
-static struct intc_prio_reg sh7786_prio_registers[] __initdata = {
-	{ 0xfe410010, 0, 32, 4, /* INTPRI */   { IRQ0, IRQ1, IRQ2, IRQ3,
-						 IRQ4, IRQ5, IRQ6, IRQ7 } },
-	{ 0xfe410800, 0, 32, 8, /* INT2PRI0 */ { 0, 0, 0, WDT } },
-	{ 0xfe410804, 0, 32, 8, /* INT2PRI1 */ { TMU0_0, TMU0_1,
-						 TMU0_2, TMU0_3 } },
-	{ 0xfe410808, 0, 32, 8, /* INT2PRI2 */ { TMU1_0, TMU1_1,
-						 TMU1_2, 0 } },
-	{ 0xfe41080c, 0, 32, 8, /* INT2PRI3 */ { DMAC0_0, DMAC0_1,
-						 DMAC0_2, DMAC0_3 } },
-	{ 0xfe410810, 0, 32, 8, /* INT2PRI4 */ { DMAC0_4, DMAC0_5,
-						 DMAC0_6, HUDI1 } },
-	{ 0xfe410814, 0, 32, 8, /* INT2PRI5 */ { HUDI0, DMAC1_0,
-						 DMAC1_1, DMAC1_2 } },
-	{ 0xfe410818, 0, 32, 8, /* INT2PRI6 */ { DMAC1_3, HPB_0,
-						 HPB_1, HPB_2 } },
-	{ 0xfe41081c, 0, 32, 8, /* INT2PRI7 */ { SCIF0_0, SCIF0_1,
-						 SCIF0_2, SCIF0_3 } },
-	{ 0xfe410820, 0, 32, 8, /* INT2PRI8 */ { SCIF1, TMU2, TMU3, 0 } },
-	{ 0xfe410824, 0, 32, 8, /* INT2PRI9 */ { 0, 0, SCIF2, SCIF3 } },
-	{ 0xfe410828, 0, 32, 8, /* INT2PRI10 */ { SCIF4, SCIF5,
-						  Eth_0, Eth_1 } },
-	{ 0xfe41082c, 0, 32, 8, /* INT2PRI11 */ { 0, 0, 0, 0 } },
-	{ 0xfe410830, 0, 32, 8, /* INT2PRI12 */ { 0, 0, 0, 0 } },
-	{ 0xfe410834, 0, 32, 8, /* INT2PRI13 */ { 0, 0, 0, 0 } },
-	{ 0xfe410838, 0, 32, 8, /* INT2PRI14 */ { 0, 0, 0, PCIeC0_0 } },
-	{ 0xfe41083c, 0, 32, 8, /* INT2PRI15 */ { PCIeC0_1, PCIeC0_2,
-						  PCIeC1_0, PCIeC1_1 } },
-	{ 0xfe410840, 0, 32, 8, /* INT2PRI16 */ { PCIeC1_2, USB, 0, 0 } },
-	{ 0xfe410844, 0, 32, 8, /* INT2PRI17 */ { 0, 0, 0, 0 } },
-	{ 0xfe410848, 0, 32, 8, /* INT2PRI18 */ { 0, 0, I2C0, I2C1 } },
-	{ 0xfe41084c, 0, 32, 8, /* INT2PRI19 */ { DU, SSI0, SSI1, SSI2 } },
-	{ 0xfe410850, 0, 32, 8, /* INT2PRI20 */ { SSI3, PCIeC2_0,
-						  PCIeC2_1, PCIeC2_2 } },
-	{ 0xfe410854, 0, 32, 8, /* INT2PRI21 */ { HAC0, HAC1, FLCTL, 0 } },
-	{ 0xfe410858, 0, 32, 8, /* INT2PRI22 */ { HSPI, GPIO0,
-						  GPIO1, Thermal } },
-	{ 0xfe41085c, 0, 32, 8, /* INT2PRI23 */ { 0, 0, 0, 0 } },
-	{ 0xfe410860, 0, 32, 8, /* INT2PRI24 */ { 0, 0, 0, 0 } },
-	{ 0xfe410090, 0xfe4100a0, 32, 4, /* CnICIPRI / CnICIPRICLR */
-	  { INTICI7, INTICI6, INTICI5, INTICI4,
-	    INTICI3, INTICI2, INTICI1, INTICI0 }, INTC_SMP(4, 2) },
-};
-
-static struct intc_subgroup sh7786_subgroups[] __initdata = {
-	{ 0xfe410c20, 32, SCIF1,
-	  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, TXI1, BRI1, RXI1, ERI1 } },
-};
-
-static struct intc_desc sh7786_intc_desc __initdata = {
-	.name		= "sh7786",
-	.hw		= {
-		.vectors	= sh7786_vectors,
-		.nr_vectors	= ARRAY_SIZE(sh7786_vectors),
-		.mask_regs	= sh7786_mask_registers,
-		.nr_mask_regs	= ARRAY_SIZE(sh7786_mask_registers),
-		.subgroups	= sh7786_subgroups,
-		.nr_subgroups	= ARRAY_SIZE(sh7786_subgroups),
-		.prio_regs	= sh7786_prio_registers,
-		.nr_prio_regs	= ARRAY_SIZE(sh7786_prio_registers),
-	},
-};
-
-/* Support for external interrupt pins in IRQ mode */
-static struct intc_vect vectors_irq0123[] __initdata = {
-	INTC_VECT(IRQ0, 0x200), INTC_VECT(IRQ1, 0x240),
-	INTC_VECT(IRQ2, 0x280), INTC_VECT(IRQ3, 0x2c0),
-};
-
-static struct intc_vect vectors_irq4567[] __initdata = {
-	INTC_VECT(IRQ4, 0x300), INTC_VECT(IRQ5, 0x340),
-	INTC_VECT(IRQ6, 0x380), INTC_VECT(IRQ7, 0x3c0),
-};
-
-static struct intc_sense_reg sh7786_sense_registers[] __initdata = {
-	{ 0xfe41001c, 32, 2, /* ICR1 */   { IRQ0, IRQ1, IRQ2, IRQ3,
-					    IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static struct intc_mask_reg sh7786_ack_registers[] __initdata = {
-	{ 0xfe410024, 0, 32, /* INTREQ */
-	  { IRQ0, IRQ1, IRQ2, IRQ3, IRQ4, IRQ5, IRQ6, IRQ7 } },
-};
-
-static DECLARE_INTC_DESC_ACK(intc_desc_irq0123, "sh7786-irq0123",
-			     vectors_irq0123, NULL, sh7786_mask_registers,
-			     sh7786_prio_registers, sh7786_sense_registers,
-			     sh7786_ack_registers);
-
-static DECLARE_INTC_DESC_ACK(intc_desc_irq4567, "sh7786-irq4567",
-			     vectors_irq4567, NULL, sh7786_mask_registers,
-			     sh7786_prio_registers, sh7786_sense_registers,
-			     sh7786_ack_registers);
-
-/* External interrupt pins in IRL mode */
-
-static struct intc_vect vectors_irl0123[] __initdata = {
-	INTC_VECT(IRL0_LLLL, 0x200), INTC_VECT(IRL0_LLLH, 0x220),
-	INTC_VECT(IRL0_LLHL, 0x240), INTC_VECT(IRL0_LLHH, 0x260),
-	INTC_VECT(IRL0_LHLL, 0x280), INTC_VECT(IRL0_LHLH, 0x2a0),
-	INTC_VECT(IRL0_LHHL, 0x2c0), INTC_VECT(IRL0_LHHH, 0x2e0),
-	INTC_VECT(IRL0_HLLL, 0x300), INTC_VECT(IRL0_HLLH, 0x320),
-	INTC_VECT(IRL0_HLHL, 0x340), INTC_VECT(IRL0_HLHH, 0x360),
-	INTC_VECT(IRL0_HHLL, 0x380), INTC_VECT(IRL0_HHLH, 0x3a0),
-	INTC_VECT(IRL0_HHHL, 0x3c0),
-};
-
-static struct intc_vect vectors_irl4567[] __initdata = {
-	INTC_VECT(IRL4_LLLL, 0x900), INTC_VECT(IRL4_LLLH, 0x920),
-	INTC_VECT(IRL4_LLHL, 0x940), INTC_VECT(IRL4_LLHH, 0x960),
-	INTC_VECT(IRL4_LHLL, 0x980), INTC_VECT(IRL4_LHLH, 0x9a0),
-	INTC_VECT(IRL4_LHHL, 0x9c0), INTC_VECT(IRL4_LHHH, 0x9e0),
-	INTC_VECT(IRL4_HLLL, 0xa00), INTC_VECT(IRL4_HLLH, 0xa20),
-	INTC_VECT(IRL4_HLHL, 0xa40), INTC_VECT(IRL4_HLHH, 0xa60),
-	INTC_VECT(IRL4_HHLL, 0xa80), INTC_VECT(IRL4_HHLH, 0xaa0),
-	INTC_VECT(IRL4_HHHL, 0xac0),
-};
-
-static DECLARE_INTC_DESC(intc_desc_irl0123, "sh7786-irl0123", vectors_irl0123,
-			 NULL, sh7786_mask_registers, NULL, NULL);
-
-static DECLARE_INTC_DESC(intc_desc_irl4567, "sh7786-irl4567", vectors_irl4567,
-			 NULL, sh7786_mask_registers, NULL, NULL);
-
-#define INTC_ICR0	0xfe410000
-#define INTC_INTMSK0	CnINTMSK0
-#define INTC_INTMSK1	CnINTMSK1
-#define INTC_INTMSK2	INTMSK2
-#define INTC_INTMSKCLR1	CnINTMSKCLR1
-#define INTC_INTMSKCLR2	INTMSKCLR2
-
-void __init plat_irq_setup(void)
-{
-	/* disable IRQ3-0 + IRQ7-4 */
-	__raw_writel(0xff000000, INTC_INTMSK0);
-
-	/* disable IRL3-0 + IRL7-4 */
-	__raw_writel(0xc0000000, INTC_INTMSK1);
-	__raw_writel(0xfffefffe, INTC_INTMSK2);
-
-	/* select IRL mode for IRL3-0 + IRL7-4 */
-	__raw_writel(__raw_readl(INTC_ICR0) & ~0x00c00000, INTC_ICR0);
-
-	register_intc_controller(&sh7786_intc_desc);
-}
-
-void __init plat_irq_setup_pins(int mode)
-{
-	switch (mode) {
-	case IRQ_MODE_IRQ7654:
-		/* select IRQ mode for IRL7-4 */
-		__raw_writel(__raw_readl(INTC_ICR0) | 0x00400000, INTC_ICR0);
-		register_intc_controller(&intc_desc_irq4567);
-		break;
-	case IRQ_MODE_IRQ3210:
-		/* select IRQ mode for IRL3-0 */
-		__raw_writel(__raw_readl(INTC_ICR0) | 0x00800000, INTC_ICR0);
-		register_intc_controller(&intc_desc_irq0123);
-		break;
-	case IRQ_MODE_IRL7654:
-		/* enable IRL7-4 but don't provide any masking */
-		__raw_writel(0x40000000, INTC_INTMSKCLR1);
-		__raw_writel(0x0000fffe, INTC_INTMSKCLR2);
-		break;
-	case IRQ_MODE_IRL3210:
-		/* enable IRL0-3 but don't provide any masking */
-		__raw_writel(0x80000000, INTC_INTMSKCLR1);
-		__raw_writel(0xfffe0000, INTC_INTMSKCLR2);
-		break;
-	case IRQ_MODE_IRL7654_MASK:
-		/* enable IRL7-4 and mask using cpu intc controller */
-		__raw_writel(0x40000000, INTC_INTMSKCLR1);
-		register_intc_controller(&intc_desc_irl4567);
-		break;
-	case IRQ_MODE_IRL3210_MASK:
-		/* enable IRL0-3 and mask using cpu intc controller */
-		__raw_writel(0x80000000, INTC_INTMSKCLR1);
-		register_intc_controller(&intc_desc_irl0123);
-		break;
-	default:
-		BUG();
-	}
-}
-
-void __init plat_mem_setup(void)
-{
-}
-
-static int __init sh7786_devices_setup(void)
-{
-	int ret, irq;
-
-	sh7786_usb_setup();
-
-	/*
-	 * De-mux SCIF1 IRQs if possible
-	 */
-	irq = intc_irq_lookup(sh7786_intc_desc.name, TXI1);
-	if (irq > 0) {
-		scif1_demux_resources[1].start =
-			intc_irq_lookup(sh7786_intc_desc.name, ERI1);
-		scif1_demux_resources[2].start =
-			intc_irq_lookup(sh7786_intc_desc.name, RXI1);
-		scif1_demux_resources[3].start = irq;
-		scif1_demux_resources[4].start =
-			intc_irq_lookup(sh7786_intc_desc.name, BRI1);
-
-		scif1_device.resource = scif1_demux_resources;
-		scif1_device.num_resources = ARRAY_SIZE(scif1_demux_resources);
-	}
-
-	ret = platform_add_devices(sh7786_early_devices,
-				   ARRAY_SIZE(sh7786_early_devices));
-	if (unlikely(ret != 0))
-		return ret;
-
-	return platform_add_devices(sh7786_devices,
-				    ARRAY_SIZE(sh7786_devices));
-}
-arch_initcall(sh7786_devices_setup);
-
-void __init plat_early_device_setup(void)
-{
-	sh_early_platform_add_devices(sh7786_early_devices,
-				   ARRAY_SIZE(sh7786_early_devices));
-}
diff --git a/arch/sh/kernel/cpu/sh4a/setup-shx3.c b/arch/sh/kernel/cpu/sh4a/setup-shx3.c
deleted file mode 100644
index 7014d6d199b3e6..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/setup-shx3.c
+++ /dev/null
@@ -1,396 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH-X3 Prototype Setup
- *
- *  Copyright (C) 2007 - 2010  Paul Mundt
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/serial.h>
-#include <linux/serial_sci.h>
-#include <linux/io.h>
-#include <linux/gpio.h>
-#include <linux/sh_timer.h>
-#include <linux/sh_intc.h>
-#include <cpu/shx3.h>
-#include <asm/mmzone.h>
-#include <asm/platform_early.h>
-
-/*
- * This intentionally only registers SCIF ports 0, 1, and 3. SCIF 2
- * INTEVT values overlap with the FPU EXPEVT ones, requiring special
- * demuxing in the exception dispatch path.
- *
- * As this overlap is something that never should have made it in to
- * silicon in the first place, we just refuse to deal with the port at
- * all rather than adding infrastructure to hack around it.
- */
-static struct plat_sci_port scif0_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif0_resources[] = {
-	DEFINE_RES_MEM(0xffc30000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x700)),
-	DEFINE_RES_IRQ(evt2irq(0x720)),
-	DEFINE_RES_IRQ(evt2irq(0x760)),
-	DEFINE_RES_IRQ(evt2irq(0x740)),
-};
-
-static struct platform_device scif0_device = {
-	.name		= "sh-sci",
-	.id		= 0,
-	.resource	= scif0_resources,
-	.num_resources	= ARRAY_SIZE(scif0_resources),
-	.dev		= {
-		.platform_data	= &scif0_platform_data,
-	},
-};
-
-static struct plat_sci_port scif1_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif1_resources[] = {
-	DEFINE_RES_MEM(0xffc40000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x780)),
-	DEFINE_RES_IRQ(evt2irq(0x7a0)),
-	DEFINE_RES_IRQ(evt2irq(0x7e0)),
-	DEFINE_RES_IRQ(evt2irq(0x7c0)),
-};
-
-static struct platform_device scif1_device = {
-	.name		= "sh-sci",
-	.id		= 1,
-	.resource	= scif1_resources,
-	.num_resources	= ARRAY_SIZE(scif1_resources),
-	.dev		= {
-		.platform_data	= &scif1_platform_data,
-	},
-};
-
-static struct plat_sci_port scif2_platform_data = {
-	.scscr		= SCSCR_REIE,
-	.type		= PORT_SCIF,
-};
-
-static struct resource scif2_resources[] = {
-	DEFINE_RES_MEM(0xffc60000, 0x100),
-	DEFINE_RES_IRQ(evt2irq(0x880)),
-	DEFINE_RES_IRQ(evt2irq(0x8a0)),
-	DEFINE_RES_IRQ(evt2irq(0x8e0)),
-	DEFINE_RES_IRQ(evt2irq(0x8c0)),
-};
-
-static struct platform_device scif2_device = {
-	.name		= "sh-sci",
-	.id		= 2,
-	.resource	= scif2_resources,
-	.num_resources	= ARRAY_SIZE(scif2_resources),
-	.dev		= {
-		.platform_data	= &scif2_platform_data,
-	},
-};
-
-static struct sh_timer_config tmu0_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu0_resources[] = {
-	DEFINE_RES_MEM(0xffc10000, 0x30),
-	DEFINE_RES_IRQ(evt2irq(0x400)),
-	DEFINE_RES_IRQ(evt2irq(0x420)),
-	DEFINE_RES_IRQ(evt2irq(0x440)),
-};
-
-static struct platform_device tmu0_device = {
-	.name		= "sh-tmu",
-	.id		= 0,
-	.dev = {
-		.platform_data	= &tmu0_platform_data,
-	},
-	.resource	= tmu0_resources,
-	.num_resources	= ARRAY_SIZE(tmu0_resources),
-};
-
-static struct sh_timer_config tmu1_platform_data = {
-	.channels_mask = 7,
-};
-
-static struct resource tmu1_resources[] = {
-	DEFINE_RES_MEM(0xffc20000, 0x2c),
-	DEFINE_RES_IRQ(evt2irq(0x460)),
-	DEFINE_RES_IRQ(evt2irq(0x480)),
-	DEFINE_RES_IRQ(evt2irq(0x4a0)),
-};
-
-static struct platform_device tmu1_device = {
-	.name		= "sh-tmu",
-	.id		= 1,
-	.dev = {
-		.platform_data	= &tmu1_platform_data,
-	},
-	.resource	= tmu1_resources,
-	.num_resources	= ARRAY_SIZE(tmu1_resources),
-};
-
-static struct platform_device *shx3_early_devices[] __initdata = {
-	&scif0_device,
-	&scif1_device,
-	&scif2_device,
-	&tmu0_device,
-	&tmu1_device,
-};
-
-static int __init shx3_devices_setup(void)
-{
-	return platform_add_devices(shx3_early_devices,
-				   ARRAY_SIZE(shx3_early_devices));
-}
-arch_initcall(shx3_devices_setup);
-
-void __init plat_early_device_setup(void)
-{
-	sh_early_platform_add_devices(shx3_early_devices,
-				   ARRAY_SIZE(shx3_early_devices));
-}
-
-enum {
-	UNUSED = 0,
-
-	/* interrupt sources */
-	IRL_LLLL, IRL_LLLH, IRL_LLHL, IRL_LLHH,
-	IRL_LHLL, IRL_LHLH, IRL_LHHL, IRL_LHHH,
-	IRL_HLLL, IRL_HLLH, IRL_HLHL, IRL_HLHH,
-	IRL_HHLL, IRL_HHLH, IRL_HHHL,
-	IRQ0, IRQ1, IRQ2, IRQ3,
-	HUDII,
-	TMU0, TMU1, TMU2, TMU3, TMU4, TMU5,
-	PCII0, PCII1, PCII2, PCII3, PCII4,
-	PCII5, PCII6, PCII7, PCII8, PCII9,
-	SCIF0_ERI, SCIF0_RXI, SCIF0_BRI, SCIF0_TXI,
-	SCIF1_ERI, SCIF1_RXI, SCIF1_BRI, SCIF1_TXI,
-	SCIF2_ERI, SCIF2_RXI, SCIF2_BRI, SCIF2_TXI,
-	SCIF3_ERI, SCIF3_RXI, SCIF3_BRI, SCIF3_TXI,
-	DMAC0_DMINT0, DMAC0_DMINT1, DMAC0_DMINT2, DMAC0_DMINT3,
-	DMAC0_DMINT4, DMAC0_DMINT5, DMAC0_DMAE,
-	DU,
-	DMAC1_DMINT6, DMAC1_DMINT7, DMAC1_DMINT8, DMAC1_DMINT9,
-	DMAC1_DMINT10, DMAC1_DMINT11, DMAC1_DMAE,
-	IIC, VIN0, VIN1, VCORE0, ATAPI,
-	DTU0, DTU1, DTU2, DTU3,
-	FE0, FE1,
-	GPIO0, GPIO1, GPIO2, GPIO3,
-	PAM, IRM,
-	INTICI0, INTICI1, INTICI2, INTICI3,
-	INTICI4, INTICI5, INTICI6, INTICI7,
-
-	/* interrupt groups */
-	IRL, PCII56789, SCIF0, SCIF1, SCIF2, SCIF3,
-	DMAC0, DMAC1,
-};
-
-static struct intc_vect vectors[] __initdata = {
-	INTC_VECT(HUDII, 0x3e0),
-	INTC_VECT(TMU0, 0x400), INTC_VECT(TMU1, 0x420),
-	INTC_VECT(TMU2, 0x440), INTC_VECT(TMU3, 0x460),
-	INTC_VECT(TMU4, 0x480), INTC_VECT(TMU5, 0x4a0),
-	INTC_VECT(PCII0, 0x500), INTC_VECT(PCII1, 0x520),
-	INTC_VECT(PCII2, 0x540), INTC_VECT(PCII3, 0x560),
-	INTC_VECT(PCII4, 0x580), INTC_VECT(PCII5, 0x5a0),
-	INTC_VECT(PCII6, 0x5c0), INTC_VECT(PCII7, 0x5e0),
-	INTC_VECT(PCII8, 0x600), INTC_VECT(PCII9, 0x620),
-	INTC_VECT(SCIF0_ERI, 0x700), INTC_VECT(SCIF0_RXI, 0x720),
-	INTC_VECT(SCIF0_BRI, 0x740), INTC_VECT(SCIF0_TXI, 0x760),
-	INTC_VECT(SCIF1_ERI, 0x780), INTC_VECT(SCIF1_RXI, 0x7a0),
-	INTC_VECT(SCIF1_BRI, 0x7c0), INTC_VECT(SCIF1_TXI, 0x7e0),
-	INTC_VECT(SCIF3_ERI, 0x880), INTC_VECT(SCIF3_RXI, 0x8a0),
-	INTC_VECT(SCIF3_BRI, 0x8c0), INTC_VECT(SCIF3_TXI, 0x8e0),
-	INTC_VECT(DMAC0_DMINT0, 0x900), INTC_VECT(DMAC0_DMINT1, 0x920),
-	INTC_VECT(DMAC0_DMINT2, 0x940), INTC_VECT(DMAC0_DMINT3, 0x960),
-	INTC_VECT(DMAC0_DMINT4, 0x980), INTC_VECT(DMAC0_DMINT5, 0x9a0),
-	INTC_VECT(DMAC0_DMAE, 0x9c0),
-	INTC_VECT(DU, 0x9e0),
-	INTC_VECT(DMAC1_DMINT6, 0xa00), INTC_VECT(DMAC1_DMINT7, 0xa20),
-	INTC_VECT(DMAC1_DMINT8, 0xa40), INTC_VECT(DMAC1_DMINT9, 0xa60),
-	INTC_VECT(DMAC1_DMINT10, 0xa80), INTC_VECT(DMAC1_DMINT11, 0xaa0),
-	INTC_VECT(DMAC1_DMAE, 0xac0),
-	INTC_VECT(IIC, 0xae0),
-	INTC_VECT(VIN0, 0xb00), INTC_VECT(VIN1, 0xb20),
-	INTC_VECT(VCORE0, 0xb00), INTC_VECT(ATAPI, 0xb60),
-	INTC_VECT(DTU0, 0xc00), INTC_VECT(DTU0, 0xc20),
-	INTC_VECT(DTU0, 0xc40),
-	INTC_VECT(DTU1, 0xc60), INTC_VECT(DTU1, 0xc80),
-	INTC_VECT(DTU1, 0xca0),
-	INTC_VECT(DTU2, 0xcc0), INTC_VECT(DTU2, 0xce0),
-	INTC_VECT(DTU2, 0xd00),
-	INTC_VECT(DTU3, 0xd20), INTC_VECT(DTU3, 0xd40),
-	INTC_VECT(DTU3, 0xd60),
-	INTC_VECT(FE0, 0xe00), INTC_VECT(FE1, 0xe20),
-	INTC_VECT(GPIO0, 0xe40), INTC_VECT(GPIO1, 0xe60),
-	INTC_VECT(GPIO2, 0xe80), INTC_VECT(GPIO3, 0xea0),
-	INTC_VECT(PAM, 0xec0), INTC_VECT(IRM, 0xee0),
-	INTC_VECT(INTICI0, 0xf00), INTC_VECT(INTICI1, 0xf20),
-	INTC_VECT(INTICI2, 0xf40), INTC_VECT(INTICI3, 0xf60),
-	INTC_VECT(INTICI4, 0xf80), INTC_VECT(INTICI5, 0xfa0),
-	INTC_VECT(INTICI6, 0xfc0), INTC_VECT(INTICI7, 0xfe0),
-};
-
-static struct intc_group groups[] __initdata = {
-	INTC_GROUP(IRL, IRL_LLLL, IRL_LLLH, IRL_LLHL, IRL_LLHH,
-		   IRL_LHLL, IRL_LHLH, IRL_LHHL, IRL_LHHH,
-		   IRL_HLLL, IRL_HLLH, IRL_HLHL, IRL_HLHH,
-		   IRL_HHLL, IRL_HHLH, IRL_HHHL),
-	INTC_GROUP(PCII56789, PCII5, PCII6, PCII7, PCII8, PCII9),
-	INTC_GROUP(SCIF0, SCIF0_ERI, SCIF0_RXI, SCIF0_BRI, SCIF0_TXI),
-	INTC_GROUP(SCIF1, SCIF1_ERI, SCIF1_RXI, SCIF1_BRI, SCIF1_TXI),
-	INTC_GROUP(SCIF3, SCIF3_ERI, SCIF3_RXI, SCIF3_BRI, SCIF3_TXI),
-	INTC_GROUP(DMAC0, DMAC0_DMINT0, DMAC0_DMINT1, DMAC0_DMINT2,
-		   DMAC0_DMINT3, DMAC0_DMINT4, DMAC0_DMINT5, DMAC0_DMAE),
-	INTC_GROUP(DMAC1, DMAC1_DMINT6, DMAC1_DMINT7, DMAC1_DMINT8,
-		   DMAC1_DMINT9, DMAC1_DMINT10, DMAC1_DMINT11),
-};
-
-#define INT2DISTCR0	0xfe4108a0
-#define INT2DISTCR1	0xfe4108a4
-#define INT2DISTCR2	0xfe4108a8
-
-static struct intc_mask_reg mask_registers[] __initdata = {
-	{ 0xfe410030, 0xfe410050, 32, /* CnINTMSK0 / CnINTMSKCLR0 */
-	  { IRQ0, IRQ1, IRQ2, IRQ3 } },
-	{ 0xfe410040, 0xfe410060, 32, /* CnINTMSK1 / CnINTMSKCLR1 */
-	  { IRL } },
-	{ 0xfe410820, 0xfe410850, 32, /* CnINT2MSK0 / CnINT2MSKCLR0 */
-	  { FE1, FE0, 0, ATAPI, VCORE0, VIN1, VIN0, IIC,
-	    DU, GPIO3, GPIO2, GPIO1, GPIO0, PAM, 0, 0,
-	    0, 0, 0, 0, 0, 0, 0, 0, /* HUDI bits ignored */
-	    0, TMU5, TMU4, TMU3, TMU2, TMU1, TMU0, 0, },
-	    INTC_SMP_BALANCING(INT2DISTCR0) },
-	{ 0xfe410830, 0xfe410860, 32, /* CnINT2MSK1 / CnINT2MSKCLR1 */
-	  { 0, 0, 0, 0, DTU3, DTU2, DTU1, DTU0, /* IRM bits ignored */
-	    PCII9, PCII8, PCII7, PCII6, PCII5, PCII4, PCII3, PCII2,
-	    PCII1, PCII0, DMAC1_DMAE, DMAC1_DMINT11,
-	    DMAC1_DMINT10, DMAC1_DMINT9, DMAC1_DMINT8, DMAC1_DMINT7,
-	    DMAC1_DMINT6, DMAC0_DMAE, DMAC0_DMINT5, DMAC0_DMINT4,
-	    DMAC0_DMINT3, DMAC0_DMINT2, DMAC0_DMINT1, DMAC0_DMINT0 },
-	    INTC_SMP_BALANCING(INT2DISTCR1) },
-	{ 0xfe410840, 0xfe410870, 32, /* CnINT2MSK2 / CnINT2MSKCLR2 */
-	  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	    SCIF3_TXI, SCIF3_BRI, SCIF3_RXI, SCIF3_ERI,
-	    SCIF2_TXI, SCIF2_BRI, SCIF2_RXI, SCIF2_ERI,
-	    SCIF1_TXI, SCIF1_BRI, SCIF1_RXI, SCIF1_ERI,
-	    SCIF0_TXI, SCIF0_BRI, SCIF0_RXI, SCIF0_ERI },
-	    INTC_SMP_BALANCING(INT2DISTCR2) },
-};
-
-static struct intc_prio_reg prio_registers[] __initdata = {
-	{ 0xfe410010, 0, 32, 4, /* INTPRI */ { IRQ0, IRQ1, IRQ2, IRQ3 } },
-
-	{ 0xfe410800, 0, 32, 4, /* INT2PRI0 */ { 0, HUDII, TMU5, TMU4,
-						 TMU3, TMU2, TMU1, TMU0 } },
-	{ 0xfe410804, 0, 32, 4, /* INT2PRI1 */ { DTU3, DTU2, DTU1, DTU0,
-						 SCIF3, SCIF2,
-						 SCIF1, SCIF0 } },
-	{ 0xfe410808, 0, 32, 4, /* INT2PRI2 */ { DMAC1, DMAC0,
-						 PCII56789, PCII4,
-						 PCII3, PCII2,
-						 PCII1, PCII0 } },
-	{ 0xfe41080c, 0, 32, 4, /* INT2PRI3 */ { FE1, FE0, ATAPI, VCORE0,
-						 VIN1, VIN0, IIC, DU} },
-	{ 0xfe410810, 0, 32, 4, /* INT2PRI4 */ { 0, 0, PAM, GPIO3,
-						 GPIO2, GPIO1, GPIO0, IRM } },
-	{ 0xfe410090, 0xfe4100a0, 32, 4, /* CnICIPRI / CnICIPRICLR */
-	  { INTICI7, INTICI6, INTICI5, INTICI4,
-	    INTICI3, INTICI2, INTICI1, INTICI0 }, INTC_SMP(4, 4) },
-};
-
-static DECLARE_INTC_DESC(intc_desc, "shx3", vectors, groups,
-			 mask_registers, prio_registers, NULL);
-
-/* Support for external interrupt pins in IRQ mode */
-static struct intc_vect vectors_irq[] __initdata = {
-	INTC_VECT(IRQ0, 0x240), INTC_VECT(IRQ1, 0x280),
-	INTC_VECT(IRQ2, 0x2c0), INTC_VECT(IRQ3, 0x300),
-};
-
-static struct intc_sense_reg sense_registers[] __initdata = {
-	{ 0xfe41001c, 32, 2, /* ICR1 */   { IRQ0, IRQ1, IRQ2, IRQ3 } },
-};
-
-static DECLARE_INTC_DESC(intc_desc_irq, "shx3-irq", vectors_irq, groups,
-			 mask_registers, prio_registers, sense_registers);
-
-/* External interrupt pins in IRL mode */
-static struct intc_vect vectors_irl[] __initdata = {
-	INTC_VECT(IRL_LLLL, 0x200), INTC_VECT(IRL_LLLH, 0x220),
-	INTC_VECT(IRL_LLHL, 0x240), INTC_VECT(IRL_LLHH, 0x260),
-	INTC_VECT(IRL_LHLL, 0x280), INTC_VECT(IRL_LHLH, 0x2a0),
-	INTC_VECT(IRL_LHHL, 0x2c0), INTC_VECT(IRL_LHHH, 0x2e0),
-	INTC_VECT(IRL_HLLL, 0x300), INTC_VECT(IRL_HLLH, 0x320),
-	INTC_VECT(IRL_HLHL, 0x340), INTC_VECT(IRL_HLHH, 0x360),
-	INTC_VECT(IRL_HHLL, 0x380), INTC_VECT(IRL_HHLH, 0x3a0),
-	INTC_VECT(IRL_HHHL, 0x3c0),
-};
-
-static DECLARE_INTC_DESC(intc_desc_irl, "shx3-irl", vectors_irl, groups,
-			 mask_registers, prio_registers, NULL);
-
-void __init plat_irq_setup_pins(int mode)
-{
-	int ret = 0;
-
-	switch (mode) {
-	case IRQ_MODE_IRQ:
-		ret |= gpio_request(GPIO_FN_IRQ3, intc_desc_irq.name);
-		ret |= gpio_request(GPIO_FN_IRQ2, intc_desc_irq.name);
-		ret |= gpio_request(GPIO_FN_IRQ1, intc_desc_irq.name);
-		ret |= gpio_request(GPIO_FN_IRQ0, intc_desc_irq.name);
-
-		if (unlikely(ret)) {
-			pr_err("Failed to set IRQ mode\n");
-			return;
-		}
-
-		register_intc_controller(&intc_desc_irq);
-		break;
-	case IRQ_MODE_IRL3210:
-		ret |= gpio_request(GPIO_FN_IRL3, intc_desc_irl.name);
-		ret |= gpio_request(GPIO_FN_IRL2, intc_desc_irl.name);
-		ret |= gpio_request(GPIO_FN_IRL1, intc_desc_irl.name);
-		ret |= gpio_request(GPIO_FN_IRL0, intc_desc_irl.name);
-
-		if (unlikely(ret)) {
-			pr_err("Failed to set IRL mode\n");
-			return;
-		}
-
-		register_intc_controller(&intc_desc_irl);
-		break;
-	default:
-		BUG();
-	}
-}
-
-void __init plat_irq_setup(void)
-{
-	register_intc_controller(&intc_desc);
-}
-
-void __init plat_mem_setup(void)
-{
-	unsigned int nid = 1;
-
-	/* Register CPU#0 URAM space as Node 1 */
-	setup_bootmem_node(nid++, 0x145f0000, 0x14610000);	/* CPU0 */
-
-#if 0
-	/* XXX: Not yet.. */
-	setup_bootmem_node(nid++, 0x14df0000, 0x14e10000);	/* CPU1 */
-	setup_bootmem_node(nid++, 0x155f0000, 0x15610000);	/* CPU2 */
-	setup_bootmem_node(nid++, 0x15df0000, 0x15e10000);	/* CPU3 */
-#endif
-
-	setup_bootmem_node(nid++, 0x16000000, 0x16020000);	/* CSM */
-}
diff --git a/arch/sh/kernel/cpu/sh4a/smp-shx3.c b/arch/sh/kernel/cpu/sh4a/smp-shx3.c
deleted file mode 100644
index 1261dc7b84e8be..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/smp-shx3.c
+++ /dev/null
@@ -1,146 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SH-X3 SMP
- *
- *  Copyright (C) 2007 - 2010  Paul Mundt
- *  Copyright (C) 2007  Magnus Damm
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/cpumask.h>
-#include <linux/smp.h>
-#include <linux/interrupt.h>
-#include <linux/io.h>
-#include <linux/sched.h>
-#include <linux/delay.h>
-#include <linux/cpu.h>
-#include <asm/sections.h>
-
-#define STBCR_REG(phys_id) (0xfe400004 | (phys_id << 12))
-#define RESET_REG(phys_id) (0xfe400008 | (phys_id << 12))
-
-#define STBCR_MSTP	0x00000001
-#define STBCR_RESET	0x00000002
-#define STBCR_SLEEP	0x00000004
-#define STBCR_LTSLP	0x80000000
-
-static irqreturn_t ipi_interrupt_handler(int irq, void *arg)
-{
-	unsigned int message = (unsigned int)(long)arg;
-	unsigned int cpu = hard_smp_processor_id();
-	unsigned int offs = 4 * cpu;
-	unsigned int x;
-
-	x = __raw_readl(0xfe410070 + offs); /* C0INITICI..CnINTICI */
-	x &= (1 << (message << 2));
-	__raw_writel(x, 0xfe410080 + offs); /* C0INTICICLR..CnINTICICLR */
-
-	smp_message_recv(message);
-
-	return IRQ_HANDLED;
-}
-
-static void shx3_smp_setup(void)
-{
-	unsigned int cpu = 0;
-	int i, num;
-
-	init_cpu_possible(cpumask_of(cpu));
-
-	/* Enable light sleep for the boot CPU */
-	__raw_writel(__raw_readl(STBCR_REG(cpu)) | STBCR_LTSLP, STBCR_REG(cpu));
-
-	__cpu_number_map[0] = 0;
-	__cpu_logical_map[0] = 0;
-
-	/*
-	 * Do this stupidly for now.. we don't have an easy way to probe
-	 * for the total number of cores.
-	 */
-	for (i = 1, num = 0; i < NR_CPUS; i++) {
-		set_cpu_possible(i, true);
-		__cpu_number_map[i] = ++num;
-		__cpu_logical_map[num] = i;
-	}
-
-        printk(KERN_INFO "Detected %i available secondary CPU(s)\n", num);
-}
-
-static void shx3_prepare_cpus(unsigned int max_cpus)
-{
-	int i;
-
-	BUILD_BUG_ON(SMP_MSG_NR >= 8);
-
-	for (i = 0; i < SMP_MSG_NR; i++)
-		if (request_irq(104 + i, ipi_interrupt_handler,
-			    IRQF_PERCPU, "IPI", (void *)(long)i))
-			pr_err("Failed to request irq %d\n", i);
-
-	for (i = 0; i < max_cpus; i++)
-		set_cpu_present(i, true);
-}
-
-static void shx3_start_cpu(unsigned int cpu, unsigned long entry_point)
-{
-	if (__in_29bit_mode())
-		__raw_writel(entry_point, RESET_REG(cpu));
-	else
-		__raw_writel(virt_to_phys(entry_point), RESET_REG(cpu));
-
-	if (!(__raw_readl(STBCR_REG(cpu)) & STBCR_MSTP))
-		__raw_writel(STBCR_MSTP, STBCR_REG(cpu));
-
-	while (!(__raw_readl(STBCR_REG(cpu)) & STBCR_MSTP))
-		cpu_relax();
-
-	/* Start up secondary processor by sending a reset */
-	__raw_writel(STBCR_RESET | STBCR_LTSLP, STBCR_REG(cpu));
-}
-
-static unsigned int shx3_smp_processor_id(void)
-{
-	return __raw_readl(0xff000048); /* CPIDR */
-}
-
-static void shx3_send_ipi(unsigned int cpu, unsigned int message)
-{
-	unsigned long addr = 0xfe410070 + (cpu * 4);
-
-	BUG_ON(cpu >= 4);
-
-	__raw_writel(1 << (message << 2), addr); /* C0INTICI..CnINTICI */
-}
-
-static void shx3_update_boot_vector(unsigned int cpu)
-{
-	__raw_writel(STBCR_MSTP, STBCR_REG(cpu));
-	while (!(__raw_readl(STBCR_REG(cpu)) & STBCR_MSTP))
-		cpu_relax();
-	__raw_writel(STBCR_RESET, STBCR_REG(cpu));
-}
-
-static int shx3_cpu_prepare(unsigned int cpu)
-{
-	shx3_update_boot_vector(cpu);
-	return 0;
-}
-
-static int register_shx3_cpu_notifier(void)
-{
-	cpuhp_setup_state_nocalls(CPUHP_SH_SH3X_PREPARE, "sh/shx3:prepare",
-				  shx3_cpu_prepare, NULL);
-	return 0;
-}
-late_initcall(register_shx3_cpu_notifier);
-
-struct plat_smp_ops shx3_smp_ops = {
-	.smp_setup		= shx3_smp_setup,
-	.prepare_cpus		= shx3_prepare_cpus,
-	.start_cpu		= shx3_start_cpu,
-	.smp_processor_id	= shx3_smp_processor_id,
-	.send_ipi		= shx3_send_ipi,
-	.cpu_die		= native_cpu_die,
-	.cpu_disable		= native_cpu_disable,
-	.play_dead		= native_play_dead,
-};
diff --git a/arch/sh/kernel/cpu/sh4a/ubc.c b/arch/sh/kernel/cpu/sh4a/ubc.c
deleted file mode 100644
index 25eacd9c47d1b8..00000000000000
--- a/arch/sh/kernel/cpu/sh4a/ubc.c
+++ /dev/null
@@ -1,130 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/sh4a/ubc.c
- *
- * On-chip UBC support for SH-4A CPUs.
- *
- * Copyright (C) 2009 - 2010  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/err.h>
-#include <linux/clk.h>
-#include <linux/io.h>
-#include <asm/hw_breakpoint.h>
-
-#define UBC_CBR(idx)	(0xff200000 + (0x20 * idx))
-#define UBC_CRR(idx)	(0xff200004 + (0x20 * idx))
-#define UBC_CAR(idx)	(0xff200008 + (0x20 * idx))
-#define UBC_CAMR(idx)	(0xff20000c + (0x20 * idx))
-
-#define UBC_CCMFR	0xff200600
-#define UBC_CBCR	0xff200620
-
-/* CRR */
-#define UBC_CRR_PCB	(1 << 1)
-#define UBC_CRR_BIE	(1 << 0)
-
-/* CBR */
-#define UBC_CBR_CE	(1 << 0)
-
-static struct sh_ubc sh4a_ubc;
-
-static void sh4a_ubc_enable(struct arch_hw_breakpoint *info, int idx)
-{
-	__raw_writel(UBC_CBR_CE | info->len | info->type, UBC_CBR(idx));
-	__raw_writel(info->address, UBC_CAR(idx));
-}
-
-static void sh4a_ubc_disable(struct arch_hw_breakpoint *info, int idx)
-{
-	__raw_writel(0, UBC_CBR(idx));
-	__raw_writel(0, UBC_CAR(idx));
-}
-
-static void sh4a_ubc_enable_all(unsigned long mask)
-{
-	int i;
-
-	for (i = 0; i < sh4a_ubc.num_events; i++)
-		if (mask & (1 << i))
-			__raw_writel(__raw_readl(UBC_CBR(i)) | UBC_CBR_CE,
-				     UBC_CBR(i));
-}
-
-static void sh4a_ubc_disable_all(void)
-{
-	int i;
-
-	for (i = 0; i < sh4a_ubc.num_events; i++)
-		__raw_writel(__raw_readl(UBC_CBR(i)) & ~UBC_CBR_CE,
-			     UBC_CBR(i));
-}
-
-static unsigned long sh4a_ubc_active_mask(void)
-{
-	unsigned long active = 0;
-	int i;
-
-	for (i = 0; i < sh4a_ubc.num_events; i++)
-		if (__raw_readl(UBC_CBR(i)) & UBC_CBR_CE)
-			active |= (1 << i);
-
-	return active;
-}
-
-static unsigned long sh4a_ubc_triggered_mask(void)
-{
-	return __raw_readl(UBC_CCMFR);
-}
-
-static void sh4a_ubc_clear_triggered_mask(unsigned long mask)
-{
-	__raw_writel(__raw_readl(UBC_CCMFR) & ~mask, UBC_CCMFR);
-}
-
-static struct sh_ubc sh4a_ubc = {
-	.name			= "SH-4A",
-	.num_events		= 2,
-	.trap_nr		= 0x1e0,
-	.enable			= sh4a_ubc_enable,
-	.disable		= sh4a_ubc_disable,
-	.enable_all		= sh4a_ubc_enable_all,
-	.disable_all		= sh4a_ubc_disable_all,
-	.active_mask		= sh4a_ubc_active_mask,
-	.triggered_mask		= sh4a_ubc_triggered_mask,
-	.clear_triggered_mask	= sh4a_ubc_clear_triggered_mask,
-};
-
-static int __init sh4a_ubc_init(void)
-{
-	struct clk *ubc_iclk = clk_get(NULL, "ubc0");
-	int i;
-
-	/*
-	 * The UBC MSTP bit is optional, as not all platforms will have
-	 * it. Just ignore it if we can't find it.
-	 */
-	if (IS_ERR(ubc_iclk))
-		ubc_iclk = NULL;
-
-	clk_enable(ubc_iclk);
-
-	__raw_writel(0, UBC_CBCR);
-
-	for (i = 0; i < sh4a_ubc.num_events; i++) {
-		__raw_writel(0, UBC_CAMR(i));
-		__raw_writel(0, UBC_CBR(i));
-
-		__raw_writel(UBC_CRR_BIE | UBC_CRR_PCB, UBC_CRR(i));
-
-		/* dummy read for write posting */
-		(void)__raw_readl(UBC_CRR(i));
-	}
-
-	clk_disable(ubc_iclk);
-
-	sh4a_ubc.clk = ubc_iclk;
-
-	return register_sh_ubc(&sh4a_ubc);
-}
-arch_initcall(sh4a_ubc_init);
diff --git a/arch/sh/kernel/cpu/shmobile/Makefile b/arch/sh/kernel/cpu/shmobile/Makefile
deleted file mode 100644
index 7581d5f03ce155..00000000000000
--- a/arch/sh/kernel/cpu/shmobile/Makefile
+++ /dev/null
@@ -1,8 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the Linux/SuperH SH-Mobile backends.
-#
-
-# Power Management & Sleep mode
-obj-$(CONFIG_PM)	+= pm.o sleep.o
-obj-$(CONFIG_CPU_IDLE)	+= cpuidle.o
diff --git a/arch/sh/kernel/cpu/shmobile/cpuidle.c b/arch/sh/kernel/cpu/shmobile/cpuidle.c
deleted file mode 100644
index b0f9c8f8fd146a..00000000000000
--- a/arch/sh/kernel/cpu/shmobile/cpuidle.c
+++ /dev/null
@@ -1,95 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/shmobile/cpuidle.c
- *
- * Cpuidle support code for SuperH Mobile
- *
- *  Copyright (C) 2009 Magnus Damm
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/suspend.h>
-#include <linux/cpuidle.h>
-#include <linux/export.h>
-#include <asm/suspend.h>
-#include <linux/uaccess.h>
-
-static unsigned long cpuidle_mode[] = {
-	SUSP_SH_SLEEP, /* regular sleep mode */
-	SUSP_SH_SLEEP | SUSP_SH_SF, /* sleep mode + self refresh */
-	SUSP_SH_STANDBY | SUSP_SH_SF, /* software standby mode + self refresh */
-};
-
-static int cpuidle_sleep_enter(struct cpuidle_device *dev,
-				struct cpuidle_driver *drv,
-				int index)
-{
-	unsigned long allowed_mode = SUSP_SH_SLEEP;
-	int requested_state = index;
-	int allowed_state;
-	int k;
-
-	/* convert allowed mode to allowed state */
-	for (k = ARRAY_SIZE(cpuidle_mode) - 1; k > 0; k--)
-		if (cpuidle_mode[k] == allowed_mode)
-			break;
-
-	allowed_state = k;
-
-	/* take the following into account for sleep mode selection:
-	 * - allowed_state: best mode allowed by hardware (clock deps)
-	 * - requested_state: best mode allowed by software (latencies)
-	 */
-	k = min_t(int, allowed_state, requested_state);
-
-	sh_mobile_call_standby(cpuidle_mode[k]);
-
-	return k;
-}
-
-static struct cpuidle_driver cpuidle_driver = {
-	.name   = "sh_idle",
-	.owner  = THIS_MODULE,
-	.states = {
-		{
-			.exit_latency = 1,
-			.target_residency = 1 * 2,
-			.power_usage = 3,
-			.enter = cpuidle_sleep_enter,
-			.name = "C1",
-			.desc = "SuperH Sleep Mode",
-		},
-		{
-			.exit_latency = 100,
-			.target_residency = 1 * 2,
-			.power_usage = 1,
-			.enter = cpuidle_sleep_enter,
-			.name = "C2",
-			.desc = "SuperH Sleep Mode [SF]",
-			.flags = CPUIDLE_FLAG_UNUSABLE,
-		},
-		{
-			.exit_latency = 2300,
-			.target_residency = 1 * 2,
-			.power_usage = 1,
-			.enter = cpuidle_sleep_enter,
-			.name = "C3",
-			.desc = "SuperH Mobile Standby Mode [SF]",
-			.flags = CPUIDLE_FLAG_UNUSABLE,
-		},
-	},
-	.safe_state_index = 0,
-	.state_count = 3,
-};
-
-int __init sh_mobile_setup_cpuidle(void)
-{
-	if (sh_mobile_sleep_supported & SUSP_SH_SF)
-		cpuidle_driver.states[1].flags = CPUIDLE_FLAG_NONE;
-
-	if (sh_mobile_sleep_supported & SUSP_SH_STANDBY)
-		cpuidle_driver.states[2].flags = CPUIDLE_FLAG_NONE;
-
-	return cpuidle_register(&cpuidle_driver, NULL);
-}
diff --git a/arch/sh/kernel/cpu/shmobile/pm.c b/arch/sh/kernel/cpu/shmobile/pm.c
deleted file mode 100644
index ca9945f51e51d4..00000000000000
--- a/arch/sh/kernel/cpu/shmobile/pm.c
+++ /dev/null
@@ -1,153 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/cpu/shmobile/pm.c
- *
- * Power management support code for SuperH Mobile
- *
- *  Copyright (C) 2009 Magnus Damm
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/suspend.h>
-#include <asm/suspend.h>
-#include <linux/uaccess.h>
-#include <asm/cacheflush.h>
-#include <asm/bl_bit.h>
-
-/*
- * Notifier lists for pre/post sleep notification
- */
-ATOMIC_NOTIFIER_HEAD(sh_mobile_pre_sleep_notifier_list);
-ATOMIC_NOTIFIER_HEAD(sh_mobile_post_sleep_notifier_list);
-
-/*
- * Sleep modes available on SuperH Mobile:
- *
- * Sleep mode is just plain "sleep" instruction
- * Sleep Self-Refresh mode is above plus RAM put in Self-Refresh
- * Standby Self-Refresh mode is above plus stopped clocks
- */
-#define SUSP_MODE_SLEEP		(SUSP_SH_SLEEP)
-#define SUSP_MODE_SLEEP_SF	(SUSP_SH_SLEEP | SUSP_SH_SF)
-#define SUSP_MODE_STANDBY_SF	(SUSP_SH_STANDBY | SUSP_SH_SF)
-#define SUSP_MODE_RSTANDBY_SF \
-	(SUSP_SH_RSTANDBY | SUSP_SH_MMU | SUSP_SH_REGS | SUSP_SH_SF)
- /*
-  * U-standby mode is unsupported since it needs bootloader hacks
-  */
-
-#ifdef CONFIG_CPU_SUBTYPE_SH7724
-#define RAM_BASE 0xfd800000 /* RSMEM */
-#else
-#define RAM_BASE 0xe5200000 /* ILRAM */
-#endif
-
-void sh_mobile_call_standby(unsigned long mode)
-{
-	void *onchip_mem = (void *)RAM_BASE;
-	struct sh_sleep_data *sdp = onchip_mem;
-	void (*standby_onchip_mem)(unsigned long, unsigned long);
-
-	/* code located directly after data structure */
-	standby_onchip_mem = (void *)(sdp + 1);
-
-	atomic_notifier_call_chain(&sh_mobile_pre_sleep_notifier_list,
-				   mode, NULL);
-
-	/* flush the caches if MMU flag is set */
-	if (mode & SUSP_SH_MMU)
-		flush_cache_all();
-
-	/* Let assembly snippet in on-chip memory handle the rest */
-	standby_onchip_mem(mode, RAM_BASE);
-
-	atomic_notifier_call_chain(&sh_mobile_post_sleep_notifier_list,
-				   mode, NULL);
-}
-
-extern char sh_mobile_sleep_enter_start;
-extern char sh_mobile_sleep_enter_end;
-
-extern char sh_mobile_sleep_resume_start;
-extern char sh_mobile_sleep_resume_end;
-
-unsigned long sh_mobile_sleep_supported = SUSP_SH_SLEEP;
-
-void sh_mobile_register_self_refresh(unsigned long flags,
-				     void *pre_start, void *pre_end,
-				     void *post_start, void *post_end)
-{
-	void *onchip_mem = (void *)RAM_BASE;
-	void *vp;
-	struct sh_sleep_data *sdp;
-	int n;
-
-	/* part 0: data area */
-	sdp = onchip_mem;
-	sdp->addr.stbcr = 0xa4150020; /* STBCR */
-	sdp->addr.bar = 0xa4150040; /* BAR */
-	sdp->addr.pteh = 0xff000000; /* PTEH */
-	sdp->addr.ptel = 0xff000004; /* PTEL */
-	sdp->addr.ttb = 0xff000008; /* TTB */
-	sdp->addr.tea = 0xff00000c; /* TEA */
-	sdp->addr.mmucr = 0xff000010; /* MMUCR */
-	sdp->addr.ptea = 0xff000034; /* PTEA */
-	sdp->addr.pascr = 0xff000070; /* PASCR */
-	sdp->addr.irmcr = 0xff000078; /* IRMCR */
-	sdp->addr.ccr = 0xff00001c; /* CCR */
-	sdp->addr.ramcr = 0xff000074; /* RAMCR */
-	vp = sdp + 1;
-
-	/* part 1: common code to enter sleep mode */
-	n = &sh_mobile_sleep_enter_end - &sh_mobile_sleep_enter_start;
-	memcpy(vp, &sh_mobile_sleep_enter_start, n);
-	vp += roundup(n, 4);
-
-	/* part 2: board specific code to enter self-refresh mode */
-	n = pre_end - pre_start;
-	memcpy(vp, pre_start, n);
-	sdp->sf_pre = (unsigned long)vp;
-	vp += roundup(n, 4);
-
-	/* part 3: board specific code to resume from self-refresh mode */
-	n = post_end - post_start;
-	memcpy(vp, post_start, n);
-	sdp->sf_post = (unsigned long)vp;
-	vp += roundup(n, 4);
-
-	/* part 4: common code to resume from sleep mode */
-	WARN_ON(vp > (onchip_mem + 0x600));
-	vp = onchip_mem + 0x600; /* located at interrupt vector */
-	n = &sh_mobile_sleep_resume_end - &sh_mobile_sleep_resume_start;
-	memcpy(vp, &sh_mobile_sleep_resume_start, n);
-	sdp->resume = (unsigned long)vp;
-
-	sh_mobile_sleep_supported |= flags;
-}
-
-static int sh_pm_enter(suspend_state_t state)
-{
-	if (!(sh_mobile_sleep_supported & SUSP_MODE_STANDBY_SF))
-		return -ENXIO;
-
-	local_irq_disable();
-	set_bl_bit();
-	sh_mobile_call_standby(SUSP_MODE_STANDBY_SF);
-	local_irq_disable();
-	clear_bl_bit();
-	return 0;
-}
-
-static const struct platform_suspend_ops sh_pm_ops = {
-	.enter          = sh_pm_enter,
-	.valid          = suspend_valid_only_mem,
-};
-
-static int __init sh_pm_init(void)
-{
-	suspend_set_ops(&sh_pm_ops);
-	return sh_mobile_setup_cpuidle();
-}
-
-late_initcall(sh_pm_init);
diff --git a/arch/sh/kernel/cpu/shmobile/sleep.S b/arch/sh/kernel/cpu/shmobile/sleep.S
deleted file mode 100644
index f928c03151296c..00000000000000
--- a/arch/sh/kernel/cpu/shmobile/sleep.S
+++ /dev/null
@@ -1,402 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * arch/sh/kernel/cpu/sh4a/sleep-sh_mobile.S
- *
- * Sleep mode and Standby modes support for SuperH Mobile
- *
- *  Copyright (C) 2009 Magnus Damm
- */
-
-#include <linux/sys.h>
-#include <linux/errno.h>
-#include <linux/linkage.h>
-#include <asm/asm-offsets.h>
-#include <asm/suspend.h>
-
-/*
- * Kernel mode register usage, see entry.S:
- *	k0	scratch
- *	k1	scratch
- */
-#define k0	r0
-#define k1	r1
-
-/* manage self-refresh and enter standby mode. must be self-contained.
- * this code will be copied to on-chip memory and executed from there.
- */
-	.balign 4
-ENTRY(sh_mobile_sleep_enter_start)
-
-	/* save mode flags */
-	mov.l	r4, @(SH_SLEEP_MODE, r5)
-
-	/* save original vbr */
-	stc	vbr, r0
-	mov.l	r0, @(SH_SLEEP_VBR, r5)
-
-	/* point vbr to our on-chip memory page */
-	ldc	r5, vbr
-
-	/* save return address */
-	sts	pr, r0
-	mov.l	r0, @(SH_SLEEP_SPC, r5)
-
-	/* save sr */
-	stc	sr, r0
-	mov.l	r0, @(SH_SLEEP_SR, r5)
-
-	/* save general purpose registers to stack if needed */
-	mov.l	@(SH_SLEEP_MODE, r5), r0
-	tst	#SUSP_SH_REGS, r0
-	bt	skip_regs_save
-
-	sts.l	pr, @-r15
-	mov.l	r14, @-r15
-	mov.l	r13, @-r15
-	mov.l	r12, @-r15
-	mov.l	r11, @-r15
-	mov.l	r10, @-r15
-	mov.l	r9, @-r15
-	mov.l	r8, @-r15
-
-	/* make sure bank0 is selected, save low registers */
-	mov.l	rb_bit, r9
-	not	r9, r9
-	bsr	set_sr
-	 mov	#0, r10
-
-	bsr	save_low_regs
-	 nop
-
-	/* switch to bank 1, save low registers */
-	mov.l	rb_bit, r10
-	bsr	set_sr
-	 mov	#-1, r9
-
-	bsr	save_low_regs
-	 nop
-
-	/* switch back to bank 0 */
-	mov.l	rb_bit, r9
-	not	r9, r9
-	bsr	set_sr
-	 mov	#0, r10
-
-skip_regs_save:
-
-	/* save sp, also set to internal ram */
-	mov.l	r15, @(SH_SLEEP_SP, r5)
-	mov	r5, r15
-
-	/* save stbcr */
-	bsr     save_register
-	 mov    #SH_SLEEP_REG_STBCR, r0
-
-	/* save mmu and cache context if needed */
-	mov.l	@(SH_SLEEP_MODE, r5), r0
-	tst	#SUSP_SH_MMU, r0
-	bt	skip_mmu_save_disable
-
-	/* save mmu state */
-	bsr	save_register
-	 mov	#SH_SLEEP_REG_PTEH, r0
-
-	bsr	save_register
-	 mov	#SH_SLEEP_REG_PTEL, r0
-
-	bsr	save_register
-	 mov	#SH_SLEEP_REG_TTB, r0
-
-	bsr	save_register
-	 mov	#SH_SLEEP_REG_TEA, r0
-
-	bsr	save_register
-	 mov	#SH_SLEEP_REG_MMUCR, r0
-
-	bsr	save_register
-	 mov	#SH_SLEEP_REG_PTEA, r0
-
-	bsr	save_register
-	 mov	#SH_SLEEP_REG_PASCR, r0
-
-	bsr	save_register
-	 mov	#SH_SLEEP_REG_IRMCR, r0
-
-	/* invalidate TLBs and disable the MMU */
-	bsr	get_register
-	 mov	#SH_SLEEP_REG_MMUCR, r0
-	mov	#4, r1
-	mov.l	r1, @r0
-	icbi	@r0
-
-	/* save cache registers and disable caches */
-	bsr	save_register
-	 mov	#SH_SLEEP_REG_CCR, r0
-
-	bsr	save_register
-	 mov	#SH_SLEEP_REG_RAMCR, r0
-
-	bsr	get_register
-	 mov	#SH_SLEEP_REG_CCR, r0
-	mov	#0, r1
-	mov.l	r1, @r0
-	icbi	@r0
-
-skip_mmu_save_disable:
-	/* call self-refresh entering code if needed */
-	mov.l	@(SH_SLEEP_MODE, r5), r0
-	tst	#SUSP_SH_SF, r0
-	bt	skip_set_sf
-
-	mov.l	@(SH_SLEEP_SF_PRE, r5), r0
-	jsr	@r0
-	 nop
-
-skip_set_sf:
-	mov.l	@(SH_SLEEP_MODE, r5), r0
-	tst	#SUSP_SH_STANDBY, r0
-	bt	test_rstandby
-
-	/* set mode to "software standby mode" */
-	bra	do_sleep
-	 mov	#0x80, r1
-
-test_rstandby:
-	tst	#SUSP_SH_RSTANDBY, r0
-	bt	test_ustandby
-
-	/* setup BAR register */
-	bsr	get_register
-	 mov	#SH_SLEEP_REG_BAR, r0
-	mov.l	@(SH_SLEEP_RESUME, r5), r1
-	mov.l	r1, @r0
-
-	/* set mode to "r-standby mode" */
-	bra	do_sleep
-	 mov	#0x20, r1
-
-test_ustandby:
-	tst	#SUSP_SH_USTANDBY, r0
-	bt	force_sleep
-
-	/* set mode to "u-standby mode" */
-	bra	do_sleep
-	 mov	#0x10, r1
-
-force_sleep:
-
-	/* set mode to "sleep mode" */
-	mov	#0x00, r1
-
-do_sleep:
-	/* setup and enter selected standby mode */
-	bsr     get_register
-	 mov    #SH_SLEEP_REG_STBCR, r0
-	mov.l	r1, @r0
-again:
-	sleep
-	bra	again
-	 nop
-
-save_register:
-	add	#SH_SLEEP_BASE_ADDR, r0
-	mov.l	@(r0, r5), r1
-	add	#-SH_SLEEP_BASE_ADDR, r0
-	mov.l	@r1, r1
-	add	#SH_SLEEP_BASE_DATA, r0
-	mov.l	r1, @(r0, r5)
-	add	#-SH_SLEEP_BASE_DATA, r0
-	rts
-	 nop
-
-get_register:
-	add	#SH_SLEEP_BASE_ADDR, r0
-	mov.l	@(r0, r5), r0
-	rts
-	 nop
-
-set_sr:
-	stc	sr, r8
-	and	r9, r8
-	or	r10, r8
-	ldc	r8, sr
-	rts
-	 nop
-
-save_low_regs:
-	mov.l	r7, @-r15
-	mov.l	r6, @-r15
-	mov.l	r5, @-r15
-	mov.l	r4, @-r15
-	mov.l	r3, @-r15
-	mov.l	r2, @-r15
-	mov.l	r1, @-r15
-	rts
-	 mov.l	r0, @-r15
-
-	.balign 4
-rb_bit:	.long	0x20000000 ! RB=1
-
-ENTRY(sh_mobile_sleep_enter_end)
-
-	.balign 4
-ENTRY(sh_mobile_sleep_resume_start)
-
-	/* figure out start address */
-	bsr	0f
-	 nop
-0:
-	sts	pr, k1
-	mov.l	1f, k0
-	and	k0, k1
-
-	/* store pointer to data area in VBR */
-	ldc	k1, vbr
-
-	/* setup sr with saved sr */
-	mov.l	@(SH_SLEEP_SR, k1), k0
-	ldc	k0, sr
-
-	/* now: user register set! */
-	stc	vbr, r5
-
-	/* setup spc with return address to c code */
-	mov.l	@(SH_SLEEP_SPC, r5), r0
-	ldc	r0, spc
-
-	/* restore vbr */
-	mov.l	@(SH_SLEEP_VBR, r5), r0
-	ldc	r0, vbr
-
-	/* setup ssr with saved sr */
-	mov.l	@(SH_SLEEP_SR, r5), r0
-	ldc	r0, ssr
-
-	/* restore sp */
-	mov.l   @(SH_SLEEP_SP, r5), r15
-
-	/* restore sleep mode register */
-	bsr     restore_register
-	 mov    #SH_SLEEP_REG_STBCR, r0
-
-	/* call self-refresh resume code if needed */
-	mov.l	@(SH_SLEEP_MODE, r5), r0
-	tst	#SUSP_SH_SF, r0
-	bt	skip_restore_sf
-
-	mov.l	@(SH_SLEEP_SF_POST, r5), r0
-	jsr	@r0
-	 nop
-
-skip_restore_sf:
-	/* restore mmu and cache state if needed */
-	mov.l	@(SH_SLEEP_MODE, r5), r0
-	tst	#SUSP_SH_MMU, r0
-	bt	skip_restore_mmu
-
-	/* restore mmu state */
-	bsr	restore_register
-	 mov	#SH_SLEEP_REG_PTEH, r0
-
-	bsr	restore_register
-	 mov	#SH_SLEEP_REG_PTEL, r0
-
-	bsr	restore_register
-	 mov	#SH_SLEEP_REG_TTB, r0
-
-	bsr	restore_register
-	 mov	#SH_SLEEP_REG_TEA, r0
-
-	bsr	restore_register
-	 mov	#SH_SLEEP_REG_PTEA, r0
-
-	bsr	restore_register
-	 mov	#SH_SLEEP_REG_PASCR, r0
-
-	bsr	restore_register
-	 mov	#SH_SLEEP_REG_IRMCR, r0
-
-	bsr	restore_register
-	 mov	#SH_SLEEP_REG_MMUCR, r0
-	icbi	@r0
-
-	/* restore cache settings */
-	bsr	restore_register
-	 mov	#SH_SLEEP_REG_RAMCR, r0
-	icbi	@r0
-
-	bsr	restore_register
-	 mov	#SH_SLEEP_REG_CCR, r0
-	icbi	@r0
-
-skip_restore_mmu:
-
-	/* restore general purpose registers if needed */
-	mov.l	@(SH_SLEEP_MODE, r5), r0
-	tst	#SUSP_SH_REGS, r0
-	bt	skip_restore_regs
-
-	/* switch to bank 1, restore low registers */
-	mov.l	_rb_bit, r10
-	bsr	_set_sr
-	 mov	#-1, r9
-
-	bsr	restore_low_regs
-	 nop
-
-	/* switch to bank0, restore low registers */
-	mov.l	_rb_bit, r9
-	not	r9, r9
-	bsr	_set_sr
-	 mov	#0, r10
-
-	bsr	restore_low_regs
-	 nop
-
-	/* restore the rest of the registers */
-	mov.l	@r15+, r8
-	mov.l	@r15+, r9
-	mov.l	@r15+, r10
-	mov.l	@r15+, r11
-	mov.l	@r15+, r12
-	mov.l	@r15+, r13
-	mov.l	@r15+, r14
-	lds.l	@r15+, pr
-
-skip_restore_regs:
-	rte
-	 nop
-
-restore_register:
-	add	#SH_SLEEP_BASE_DATA, r0
-	mov.l	@(r0, r5), r1
-	add	#-SH_SLEEP_BASE_DATA, r0
-	add	#SH_SLEEP_BASE_ADDR, r0
-	mov.l	@(r0, r5), r0
-	mov.l	r1, @r0
-	rts
-	 nop
-
-_set_sr:
-	stc	sr, r8
-	and	r9, r8
-	or	r10, r8
-	ldc	r8, sr
-	rts
-	 nop
-
-restore_low_regs:
-	mov.l	@r15+, r0
-	mov.l	@r15+, r1
-	mov.l	@r15+, r2
-	mov.l	@r15+, r3
-	mov.l	@r15+, r4
-	mov.l	@r15+, r5
-	mov.l	@r15+, r6
-	rts
-	 mov.l	@r15+, r7
-
-	.balign 4
-_rb_bit:	.long	0x20000000 ! RB=1
-1:	.long	~0x7ff
-ENTRY(sh_mobile_sleep_resume_end)
diff --git a/arch/sh/kernel/crash_dump.c b/arch/sh/kernel/crash_dump.c
deleted file mode 100644
index 19ce6a950aaca8..00000000000000
--- a/arch/sh/kernel/crash_dump.c
+++ /dev/null
@@ -1,27 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- *	crash_dump.c - Memory preserving reboot related code.
- *
- *	Created by: Hariprasad Nellitheertha (hari@in.ibm.com)
- *	Copyright (C) IBM Corporation, 2004. All rights reserved
- */
-#include <linux/errno.h>
-#include <linux/crash_dump.h>
-#include <linux/io.h>
-#include <linux/uio.h>
-#include <linux/uaccess.h>
-
-ssize_t copy_oldmem_page(struct iov_iter *iter, unsigned long pfn,
-			 size_t csize, unsigned long offset)
-{
-	void  __iomem *vaddr;
-
-	if (!csize)
-		return 0;
-
-	vaddr = ioremap(pfn << PAGE_SHIFT, PAGE_SIZE);
-	csize = copy_to_iter(vaddr + offset, csize, iter);
-	iounmap(vaddr);
-
-	return csize;
-}
diff --git a/arch/sh/kernel/debugtraps.S b/arch/sh/kernel/debugtraps.S
deleted file mode 100644
index ad07527e2a990a..00000000000000
--- a/arch/sh/kernel/debugtraps.S
+++ /dev/null
@@ -1,38 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * arch/sh/kernel/debugtraps.S
- *
- * Debug trap jump tables for SuperH
- *
- *  Copyright (C) 2006 - 2008  Paul Mundt
- */
-#include <linux/sys.h>
-#include <linux/linkage.h>
-
-#if !defined(CONFIG_KGDB)
-#define singlestep_trap_handler		debug_trap_handler
-#endif
-
-#if !defined(CONFIG_SH_STANDARD_BIOS)
-#define sh_bios_handler			debug_trap_handler
-#endif
-
-	.data
-
-ENTRY(debug_trap_table)
-	.long debug_trap_handler	/* 0x30 */
-	.long debug_trap_handler	/* 0x31 */
-	.long debug_trap_handler	/* 0x32 */
-	.long debug_trap_handler	/* 0x33 */
-	.long debug_trap_handler	/* 0x34 */
-	.long debug_trap_handler	/* 0x35 */
-	.long debug_trap_handler	/* 0x36 */
-	.long debug_trap_handler	/* 0x37 */
-	.long debug_trap_handler	/* 0x38 */
-	.long debug_trap_handler	/* 0x39 */
-	.long debug_trap_handler	/* 0x3a */
-	.long debug_trap_handler	/* 0x3b */
-	.long breakpoint_trap_handler	/* 0x3c */
-	.long singlestep_trap_handler	/* 0x3d */
-	.long bug_trap_handler		/* 0x3e */
-	.long sh_bios_handler		/* 0x3f */
diff --git a/arch/sh/kernel/disassemble.c b/arch/sh/kernel/disassemble.c
deleted file mode 100644
index 34e25a439c811c..00000000000000
--- a/arch/sh/kernel/disassemble.c
+++ /dev/null
@@ -1,572 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Disassemble SuperH instructions.
- *
- * Copyright (C) 1999 kaz Kojima
- * Copyright (C) 2008 Paul Mundt
- */
-#include <linux/kernel.h>
-#include <linux/string.h>
-#include <linux/uaccess.h>
-
-#include <asm/ptrace.h>
-
-/*
- * Format of an instruction in memory.
- */
-typedef enum {
-	HEX_0, HEX_1, HEX_2, HEX_3, HEX_4, HEX_5, HEX_6, HEX_7,
-	HEX_8, HEX_9, HEX_A, HEX_B, HEX_C, HEX_D, HEX_E, HEX_F,
-	REG_N, REG_M, REG_NM, REG_B,
-	BRANCH_12, BRANCH_8,
-	DISP_8, DISP_4,
-	IMM_4, IMM_4BY2, IMM_4BY4, PCRELIMM_8BY2, PCRELIMM_8BY4,
-	IMM_8, IMM_8BY2, IMM_8BY4,
-} sh_nibble_type;
-
-typedef enum {
-	A_END, A_BDISP12, A_BDISP8,
-	A_DEC_M, A_DEC_N,
-	A_DISP_GBR, A_DISP_PC, A_DISP_REG_M, A_DISP_REG_N,
-	A_GBR,
-	A_IMM,
-	A_INC_M, A_INC_N,
-	A_IND_M, A_IND_N, A_IND_R0_REG_M, A_IND_R0_REG_N,
-	A_MACH, A_MACL,
-	A_PR, A_R0, A_R0_GBR, A_REG_M, A_REG_N, A_REG_B,
-	A_SR, A_VBR, A_SSR, A_SPC, A_SGR, A_DBR,
-	F_REG_N, F_REG_M, D_REG_N, D_REG_M,
-	X_REG_N, /* Only used for argument parsing */
-	X_REG_M, /* Only used for argument parsing */
-	DX_REG_N, DX_REG_M, V_REG_N, V_REG_M,
-	FD_REG_N,
-	XMTRX_M4,
-	F_FR0,
-	FPUL_N, FPUL_M, FPSCR_N, FPSCR_M,
-} sh_arg_type;
-
-static struct sh_opcode_info {
-	char *name;
-	sh_arg_type arg[7];
-	sh_nibble_type nibbles[4];
-} sh_table[] = {
-	{"add",{A_IMM,A_REG_N},{HEX_7,REG_N,IMM_8}},
-	{"add",{ A_REG_M,A_REG_N},{HEX_3,REG_N,REG_M,HEX_C}},
-	{"addc",{ A_REG_M,A_REG_N},{HEX_3,REG_N,REG_M,HEX_E}},
-	{"addv",{ A_REG_M,A_REG_N},{HEX_3,REG_N,REG_M,HEX_F}},
-	{"and",{A_IMM,A_R0},{HEX_C,HEX_9,IMM_8}},
-	{"and",{ A_REG_M,A_REG_N},{HEX_2,REG_N,REG_M,HEX_9}},
-	{"and.b",{A_IMM,A_R0_GBR},{HEX_C,HEX_D,IMM_8}},
-	{"bra",{A_BDISP12},{HEX_A,BRANCH_12}},
-	{"bsr",{A_BDISP12},{HEX_B,BRANCH_12}},
-	{"bt",{A_BDISP8},{HEX_8,HEX_9,BRANCH_8}},
-	{"bf",{A_BDISP8},{HEX_8,HEX_B,BRANCH_8}},
-	{"bt.s",{A_BDISP8},{HEX_8,HEX_D,BRANCH_8}},
-	{"bt/s",{A_BDISP8},{HEX_8,HEX_D,BRANCH_8}},
-	{"bf.s",{A_BDISP8},{HEX_8,HEX_F,BRANCH_8}},
-	{"bf/s",{A_BDISP8},{HEX_8,HEX_F,BRANCH_8}},
-	{"clrmac",{0},{HEX_0,HEX_0,HEX_2,HEX_8}},
-	{"clrs",{0},{HEX_0,HEX_0,HEX_4,HEX_8}},
-	{"clrt",{0},{HEX_0,HEX_0,HEX_0,HEX_8}},
-	{"cmp/eq",{A_IMM,A_R0},{HEX_8,HEX_8,IMM_8}},
-	{"cmp/eq",{ A_REG_M,A_REG_N},{HEX_3,REG_N,REG_M,HEX_0}},
-	{"cmp/ge",{ A_REG_M,A_REG_N},{HEX_3,REG_N,REG_M,HEX_3}},
-	{"cmp/gt",{ A_REG_M,A_REG_N},{HEX_3,REG_N,REG_M,HEX_7}},
-	{"cmp/hi",{ A_REG_M,A_REG_N},{HEX_3,REG_N,REG_M,HEX_6}},
-	{"cmp/hs",{ A_REG_M,A_REG_N},{HEX_3,REG_N,REG_M,HEX_2}},
-	{"cmp/pl",{A_REG_N},{HEX_4,REG_N,HEX_1,HEX_5}},
-	{"cmp/pz",{A_REG_N},{HEX_4,REG_N,HEX_1,HEX_1}},
-	{"cmp/str",{ A_REG_M,A_REG_N},{HEX_2,REG_N,REG_M,HEX_C}},
-	{"div0s",{ A_REG_M,A_REG_N},{HEX_2,REG_N,REG_M,HEX_7}},
-	{"div0u",{0},{HEX_0,HEX_0,HEX_1,HEX_9}},
-	{"div1",{ A_REG_M,A_REG_N},{HEX_3,REG_N,REG_M,HEX_4}},
-	{"exts.b",{ A_REG_M,A_REG_N},{HEX_6,REG_N,REG_M,HEX_E}},
-	{"exts.w",{ A_REG_M,A_REG_N},{HEX_6,REG_N,REG_M,HEX_F}},
-	{"extu.b",{ A_REG_M,A_REG_N},{HEX_6,REG_N,REG_M,HEX_C}},
-	{"extu.w",{ A_REG_M,A_REG_N},{HEX_6,REG_N,REG_M,HEX_D}},
-	{"jmp",{A_IND_N},{HEX_4,REG_N,HEX_2,HEX_B}},
-	{"jsr",{A_IND_N},{HEX_4,REG_N,HEX_0,HEX_B}},
-	{"ldc",{A_REG_N,A_SR},{HEX_4,REG_N,HEX_0,HEX_E}},
-	{"ldc",{A_REG_N,A_GBR},{HEX_4,REG_N,HEX_1,HEX_E}},
-	{"ldc",{A_REG_N,A_VBR},{HEX_4,REG_N,HEX_2,HEX_E}},
-	{"ldc",{A_REG_N,A_SSR},{HEX_4,REG_N,HEX_3,HEX_E}},
-	{"ldc",{A_REG_N,A_SPC},{HEX_4,REG_N,HEX_4,HEX_E}},
-	{"ldc",{A_REG_N,A_DBR},{HEX_4,REG_N,HEX_7,HEX_E}},
-	{"ldc",{A_REG_N,A_REG_B},{HEX_4,REG_N,REG_B,HEX_E}},
-	{"ldc.l",{A_INC_N,A_SR},{HEX_4,REG_N,HEX_0,HEX_7}},
-	{"ldc.l",{A_INC_N,A_GBR},{HEX_4,REG_N,HEX_1,HEX_7}},
-	{"ldc.l",{A_INC_N,A_VBR},{HEX_4,REG_N,HEX_2,HEX_7}},
-	{"ldc.l",{A_INC_N,A_SSR},{HEX_4,REG_N,HEX_3,HEX_7}},
-	{"ldc.l",{A_INC_N,A_SPC},{HEX_4,REG_N,HEX_4,HEX_7}},
-	{"ldc.l",{A_INC_N,A_DBR},{HEX_4,REG_N,HEX_7,HEX_7}},
-	{"ldc.l",{A_INC_N,A_REG_B},{HEX_4,REG_N,REG_B,HEX_7}},
-	{"lds",{A_REG_N,A_MACH},{HEX_4,REG_N,HEX_0,HEX_A}},
-	{"lds",{A_REG_N,A_MACL},{HEX_4,REG_N,HEX_1,HEX_A}},
-	{"lds",{A_REG_N,A_PR},{HEX_4,REG_N,HEX_2,HEX_A}},
-	{"lds",{A_REG_M,FPUL_N},{HEX_4,REG_M,HEX_5,HEX_A}},
-	{"lds",{A_REG_M,FPSCR_N},{HEX_4,REG_M,HEX_6,HEX_A}},
-	{"lds.l",{A_INC_N,A_MACH},{HEX_4,REG_N,HEX_0,HEX_6}},
-	{"lds.l",{A_INC_N,A_MACL},{HEX_4,REG_N,HEX_1,HEX_6}},
-	{"lds.l",{A_INC_N,A_PR},{HEX_4,REG_N,HEX_2,HEX_6}},
-	{"lds.l",{A_INC_M,FPUL_N},{HEX_4,REG_M,HEX_5,HEX_6}},
-	{"lds.l",{A_INC_M,FPSCR_N},{HEX_4,REG_M,HEX_6,HEX_6}},
-	{"ldtlb",{0},{HEX_0,HEX_0,HEX_3,HEX_8}},
-	{"mac.w",{A_INC_M,A_INC_N},{HEX_4,REG_N,REG_M,HEX_F}},
-	{"mov",{A_IMM,A_REG_N},{HEX_E,REG_N,IMM_8}},
-	{"mov",{ A_REG_M,A_REG_N},{HEX_6,REG_N,REG_M,HEX_3}},
-	{"mov.b",{ A_REG_M,A_IND_R0_REG_N},{HEX_0,REG_N,REG_M,HEX_4}},
-	{"mov.b",{ A_REG_M,A_DEC_N},{HEX_2,REG_N,REG_M,HEX_4}},
-	{"mov.b",{ A_REG_M,A_IND_N},{HEX_2,REG_N,REG_M,HEX_0}},
-	{"mov.b",{A_DISP_REG_M,A_R0},{HEX_8,HEX_4,REG_M,IMM_4}},
-	{"mov.b",{A_DISP_GBR,A_R0},{HEX_C,HEX_4,IMM_8}},
-	{"mov.b",{A_IND_R0_REG_M,A_REG_N},{HEX_0,REG_N,REG_M,HEX_C}},
-	{"mov.b",{A_INC_M,A_REG_N},{HEX_6,REG_N,REG_M,HEX_4}},
-	{"mov.b",{A_IND_M,A_REG_N},{HEX_6,REG_N,REG_M,HEX_0}},
-	{"mov.b",{A_R0,A_DISP_REG_M},{HEX_8,HEX_0,REG_M,IMM_4}},
-	{"mov.b",{A_R0,A_DISP_GBR},{HEX_C,HEX_0,IMM_8}},
-	{"mov.l",{ A_REG_M,A_DISP_REG_N},{HEX_1,REG_N,REG_M,IMM_4BY4}},
-	{"mov.l",{ A_REG_M,A_IND_R0_REG_N},{HEX_0,REG_N,REG_M,HEX_6}},
-	{"mov.l",{ A_REG_M,A_DEC_N},{HEX_2,REG_N,REG_M,HEX_6}},
-	{"mov.l",{ A_REG_M,A_IND_N},{HEX_2,REG_N,REG_M,HEX_2}},
-	{"mov.l",{A_DISP_REG_M,A_REG_N},{HEX_5,REG_N,REG_M,IMM_4BY4}},
-	{"mov.l",{A_DISP_GBR,A_R0},{HEX_C,HEX_6,IMM_8BY4}},
-	{"mov.l",{A_DISP_PC,A_REG_N},{HEX_D,REG_N,PCRELIMM_8BY4}},
-	{"mov.l",{A_IND_R0_REG_M,A_REG_N},{HEX_0,REG_N,REG_M,HEX_E}},
-	{"mov.l",{A_INC_M,A_REG_N},{HEX_6,REG_N,REG_M,HEX_6}},
-	{"mov.l",{A_IND_M,A_REG_N},{HEX_6,REG_N,REG_M,HEX_2}},
-	{"mov.l",{A_R0,A_DISP_GBR},{HEX_C,HEX_2,IMM_8BY4}},
-	{"mov.w",{ A_REG_M,A_IND_R0_REG_N},{HEX_0,REG_N,REG_M,HEX_5}},
-	{"mov.w",{ A_REG_M,A_DEC_N},{HEX_2,REG_N,REG_M,HEX_5}},
-	{"mov.w",{ A_REG_M,A_IND_N},{HEX_2,REG_N,REG_M,HEX_1}},
-	{"mov.w",{A_DISP_REG_M,A_R0},{HEX_8,HEX_5,REG_M,IMM_4BY2}},
-	{"mov.w",{A_DISP_GBR,A_R0},{HEX_C,HEX_5,IMM_8BY2}},
-	{"mov.w",{A_DISP_PC,A_REG_N},{HEX_9,REG_N,PCRELIMM_8BY2}},
-	{"mov.w",{A_IND_R0_REG_M,A_REG_N},{HEX_0,REG_N,REG_M,HEX_D}},
-	{"mov.w",{A_INC_M,A_REG_N},{HEX_6,REG_N,REG_M,HEX_5}},
-	{"mov.w",{A_IND_M,A_REG_N},{HEX_6,REG_N,REG_M,HEX_1}},
-	{"mov.w",{A_R0,A_DISP_REG_M},{HEX_8,HEX_1,REG_M,IMM_4BY2}},
-	{"mov.w",{A_R0,A_DISP_GBR},{HEX_C,HEX_1,IMM_8BY2}},
-	{"mova",{A_DISP_PC,A_R0},{HEX_C,HEX_7,PCRELIMM_8BY4}},
-	{"movca.l",{A_R0,A_IND_N},{HEX_0,REG_N,HEX_C,HEX_3}},
-	{"movt",{A_REG_N},{HEX_0,REG_N,HEX_2,HEX_9}},
-	{"muls",{ A_REG_M,A_REG_N},{HEX_2,REG_N,REG_M,HEX_F}},
-	{"mul.l",{ A_REG_M,A_REG_N},{HEX_0,REG_N,REG_M,HEX_7}},
-	{"mulu",{ A_REG_M,A_REG_N},{HEX_2,REG_N,REG_M,HEX_E}},
-	{"neg",{ A_REG_M,A_REG_N},{HEX_6,REG_N,REG_M,HEX_B}},
-	{"negc",{ A_REG_M,A_REG_N},{HEX_6,REG_N,REG_M,HEX_A}},
-	{"nop",{0},{HEX_0,HEX_0,HEX_0,HEX_9}},
-	{"not",{ A_REG_M,A_REG_N},{HEX_6,REG_N,REG_M,HEX_7}},
-	{"ocbi",{A_IND_N},{HEX_0,REG_N,HEX_9,HEX_3}},
-	{"ocbp",{A_IND_N},{HEX_0,REG_N,HEX_A,HEX_3}},
-	{"ocbwb",{A_IND_N},{HEX_0,REG_N,HEX_B,HEX_3}},
-	{"or",{A_IMM,A_R0},{HEX_C,HEX_B,IMM_8}},
-	{"or",{ A_REG_M,A_REG_N},{HEX_2,REG_N,REG_M,HEX_B}},
-	{"or.b",{A_IMM,A_R0_GBR},{HEX_C,HEX_F,IMM_8}},
-	{"pref",{A_IND_N},{HEX_0,REG_N,HEX_8,HEX_3}},
-	{"rotcl",{A_REG_N},{HEX_4,REG_N,HEX_2,HEX_4}},
-	{"rotcr",{A_REG_N},{HEX_4,REG_N,HEX_2,HEX_5}},
-	{"rotl",{A_REG_N},{HEX_4,REG_N,HEX_0,HEX_4}},
-	{"rotr",{A_REG_N},{HEX_4,REG_N,HEX_0,HEX_5}},
-	{"rte",{0},{HEX_0,HEX_0,HEX_2,HEX_B}},
-	{"rts",{0},{HEX_0,HEX_0,HEX_0,HEX_B}},
-	{"sets",{0},{HEX_0,HEX_0,HEX_5,HEX_8}},
-	{"sett",{0},{HEX_0,HEX_0,HEX_1,HEX_8}},
-	{"shad",{ A_REG_M,A_REG_N},{HEX_4,REG_N,REG_M,HEX_C}},
-	{"shld",{ A_REG_M,A_REG_N},{HEX_4,REG_N,REG_M,HEX_D}},
-	{"shal",{A_REG_N},{HEX_4,REG_N,HEX_2,HEX_0}},
-	{"shar",{A_REG_N},{HEX_4,REG_N,HEX_2,HEX_1}},
-	{"shll",{A_REG_N},{HEX_4,REG_N,HEX_0,HEX_0}},
-	{"shll16",{A_REG_N},{HEX_4,REG_N,HEX_2,HEX_8}},
-	{"shll2",{A_REG_N},{HEX_4,REG_N,HEX_0,HEX_8}},
-	{"shll8",{A_REG_N},{HEX_4,REG_N,HEX_1,HEX_8}},
-	{"shlr",{A_REG_N},{HEX_4,REG_N,HEX_0,HEX_1}},
-	{"shlr16",{A_REG_N},{HEX_4,REG_N,HEX_2,HEX_9}},
-	{"shlr2",{A_REG_N},{HEX_4,REG_N,HEX_0,HEX_9}},
-	{"shlr8",{A_REG_N},{HEX_4,REG_N,HEX_1,HEX_9}},
-	{"sleep",{0},{HEX_0,HEX_0,HEX_1,HEX_B}},
-	{"stc",{A_SR,A_REG_N},{HEX_0,REG_N,HEX_0,HEX_2}},
-	{"stc",{A_GBR,A_REG_N},{HEX_0,REG_N,HEX_1,HEX_2}},
-	{"stc",{A_VBR,A_REG_N},{HEX_0,REG_N,HEX_2,HEX_2}},
-	{"stc",{A_SSR,A_REG_N},{HEX_0,REG_N,HEX_3,HEX_2}},
-	{"stc",{A_SPC,A_REG_N},{HEX_0,REG_N,HEX_4,HEX_2}},
-	{"stc",{A_SGR,A_REG_N},{HEX_0,REG_N,HEX_6,HEX_2}},
-	{"stc",{A_DBR,A_REG_N},{HEX_0,REG_N,HEX_7,HEX_2}},
-	{"stc",{A_REG_B,A_REG_N},{HEX_0,REG_N,REG_B,HEX_2}},
-	{"stc.l",{A_SR,A_DEC_N},{HEX_4,REG_N,HEX_0,HEX_3}},
-	{"stc.l",{A_GBR,A_DEC_N},{HEX_4,REG_N,HEX_1,HEX_3}},
-	{"stc.l",{A_VBR,A_DEC_N},{HEX_4,REG_N,HEX_2,HEX_3}},
-	{"stc.l",{A_SSR,A_DEC_N},{HEX_4,REG_N,HEX_3,HEX_3}},
-	{"stc.l",{A_SPC,A_DEC_N},{HEX_4,REG_N,HEX_4,HEX_3}},
-	{"stc.l",{A_SGR,A_DEC_N},{HEX_4,REG_N,HEX_6,HEX_3}},
-	{"stc.l",{A_DBR,A_DEC_N},{HEX_4,REG_N,HEX_7,HEX_3}},
-	{"stc.l",{A_REG_B,A_DEC_N},{HEX_4,REG_N,REG_B,HEX_3}},
-	{"sts",{A_MACH,A_REG_N},{HEX_0,REG_N,HEX_0,HEX_A}},
-	{"sts",{A_MACL,A_REG_N},{HEX_0,REG_N,HEX_1,HEX_A}},
-	{"sts",{A_PR,A_REG_N},{HEX_0,REG_N,HEX_2,HEX_A}},
-	{"sts",{FPUL_M,A_REG_N},{HEX_0,REG_N,HEX_5,HEX_A}},
-	{"sts",{FPSCR_M,A_REG_N},{HEX_0,REG_N,HEX_6,HEX_A}},
-	{"sts.l",{A_MACH,A_DEC_N},{HEX_4,REG_N,HEX_0,HEX_2}},
-	{"sts.l",{A_MACL,A_DEC_N},{HEX_4,REG_N,HEX_1,HEX_2}},
-	{"sts.l",{A_PR,A_DEC_N},{HEX_4,REG_N,HEX_2,HEX_2}},
-	{"sts.l",{FPUL_M,A_DEC_N},{HEX_4,REG_N,HEX_5,HEX_2}},
-	{"sts.l",{FPSCR_M,A_DEC_N},{HEX_4,REG_N,HEX_6,HEX_2}},
-	{"sub",{ A_REG_M,A_REG_N},{HEX_3,REG_N,REG_M,HEX_8}},
-	{"subc",{ A_REG_M,A_REG_N},{HEX_3,REG_N,REG_M,HEX_A}},
-	{"subv",{ A_REG_M,A_REG_N},{HEX_3,REG_N,REG_M,HEX_B}},
-	{"swap.b",{ A_REG_M,A_REG_N},{HEX_6,REG_N,REG_M,HEX_8}},
-	{"swap.w",{ A_REG_M,A_REG_N},{HEX_6,REG_N,REG_M,HEX_9}},
-	{"tas.b",{A_IND_N},{HEX_4,REG_N,HEX_1,HEX_B}},
-	{"trapa",{A_IMM},{HEX_C,HEX_3,IMM_8}},
-	{"tst",{A_IMM,A_R0},{HEX_C,HEX_8,IMM_8}},
-	{"tst",{ A_REG_M,A_REG_N},{HEX_2,REG_N,REG_M,HEX_8}},
-	{"tst.b",{A_IMM,A_R0_GBR},{HEX_C,HEX_C,IMM_8}},
-	{"xor",{A_IMM,A_R0},{HEX_C,HEX_A,IMM_8}},
-	{"xor",{ A_REG_M,A_REG_N},{HEX_2,REG_N,REG_M,HEX_A}},
-	{"xor.b",{A_IMM,A_R0_GBR},{HEX_C,HEX_E,IMM_8}},
-	{"xtrct",{ A_REG_M,A_REG_N},{HEX_2,REG_N,REG_M,HEX_D}},
-	{"mul.l",{ A_REG_M,A_REG_N},{HEX_0,REG_N,REG_M,HEX_7}},
-	{"dt",{A_REG_N},{HEX_4,REG_N,HEX_1,HEX_0}},
-	{"dmuls.l",{ A_REG_M,A_REG_N},{HEX_3,REG_N,REG_M,HEX_D}},
-	{"dmulu.l",{ A_REG_M,A_REG_N},{HEX_3,REG_N,REG_M,HEX_5}},
-	{"mac.l",{A_INC_M,A_INC_N},{HEX_0,REG_N,REG_M,HEX_F}},
-	{"braf",{A_REG_N},{HEX_0,REG_N,HEX_2,HEX_3}},
-	{"bsrf",{A_REG_N},{HEX_0,REG_N,HEX_0,HEX_3}},
-	{"fabs",{FD_REG_N},{HEX_F,REG_N,HEX_5,HEX_D}},
-	{"fadd",{F_REG_M,F_REG_N},{HEX_F,REG_N,REG_M,HEX_0}},
-	{"fadd",{D_REG_M,D_REG_N},{HEX_F,REG_N,REG_M,HEX_0}},
-	{"fcmp/eq",{F_REG_M,F_REG_N},{HEX_F,REG_N,REG_M,HEX_4}},
-	{"fcmp/eq",{D_REG_M,D_REG_N},{HEX_F,REG_N,REG_M,HEX_4}},
-	{"fcmp/gt",{F_REG_M,F_REG_N},{HEX_F,REG_N,REG_M,HEX_5}},
-	{"fcmp/gt",{D_REG_M,D_REG_N},{HEX_F,REG_N,REG_M,HEX_5}},
-	{"fcnvds",{D_REG_N,FPUL_M},{HEX_F,REG_N,HEX_B,HEX_D}},
-	{"fcnvsd",{FPUL_M,D_REG_N},{HEX_F,REG_N,HEX_A,HEX_D}},
-	{"fdiv",{F_REG_M,F_REG_N},{HEX_F,REG_N,REG_M,HEX_3}},
-	{"fdiv",{D_REG_M,D_REG_N},{HEX_F,REG_N,REG_M,HEX_3}},
-	{"fipr",{V_REG_M,V_REG_N},{HEX_F,REG_NM,HEX_E,HEX_D}},
-	{"fldi0",{F_REG_N},{HEX_F,REG_N,HEX_8,HEX_D}},
-	{"fldi1",{F_REG_N},{HEX_F,REG_N,HEX_9,HEX_D}},
-	{"flds",{F_REG_N,FPUL_M},{HEX_F,REG_N,HEX_1,HEX_D}},
-	{"float",{FPUL_M,FD_REG_N},{HEX_F,REG_N,HEX_2,HEX_D}},
-	{"fmac",{F_FR0,F_REG_M,F_REG_N},{HEX_F,REG_N,REG_M,HEX_E}},
-	{"fmov",{F_REG_M,F_REG_N},{HEX_F,REG_N,REG_M,HEX_C}},
-	{"fmov",{DX_REG_M,DX_REG_N},{HEX_F,REG_N,REG_M,HEX_C}},
-	{"fmov",{A_IND_M,F_REG_N},{HEX_F,REG_N,REG_M,HEX_8}},
-	{"fmov",{A_IND_M,DX_REG_N},{HEX_F,REG_N,REG_M,HEX_8}},
-	{"fmov",{F_REG_M,A_IND_N},{HEX_F,REG_N,REG_M,HEX_A}},
-	{"fmov",{DX_REG_M,A_IND_N},{HEX_F,REG_N,REG_M,HEX_A}},
-	{"fmov",{A_INC_M,F_REG_N},{HEX_F,REG_N,REG_M,HEX_9}},
-	{"fmov",{A_INC_M,DX_REG_N},{HEX_F,REG_N,REG_M,HEX_9}},
-	{"fmov",{F_REG_M,A_DEC_N},{HEX_F,REG_N,REG_M,HEX_B}},
-	{"fmov",{DX_REG_M,A_DEC_N},{HEX_F,REG_N,REG_M,HEX_B}},
-	{"fmov",{A_IND_R0_REG_M,F_REG_N},{HEX_F,REG_N,REG_M,HEX_6}},
-	{"fmov",{A_IND_R0_REG_M,DX_REG_N},{HEX_F,REG_N,REG_M,HEX_6}},
-	{"fmov",{F_REG_M,A_IND_R0_REG_N},{HEX_F,REG_N,REG_M,HEX_7}},
-	{"fmov",{DX_REG_M,A_IND_R0_REG_N},{HEX_F,REG_N,REG_M,HEX_7}},
-	{"fmov.d",{A_IND_M,DX_REG_N},{HEX_F,REG_N,REG_M,HEX_8}},
-	{"fmov.d",{DX_REG_M,A_IND_N},{HEX_F,REG_N,REG_M,HEX_A}},
-	{"fmov.d",{A_INC_M,DX_REG_N},{HEX_F,REG_N,REG_M,HEX_9}},
-	{"fmov.d",{DX_REG_M,A_DEC_N},{HEX_F,REG_N,REG_M,HEX_B}},
-	{"fmov.d",{A_IND_R0_REG_M,DX_REG_N},{HEX_F,REG_N,REG_M,HEX_6}},
-	{"fmov.d",{DX_REG_M,A_IND_R0_REG_N},{HEX_F,REG_N,REG_M,HEX_7}},
-	{"fmov.s",{A_IND_M,F_REG_N},{HEX_F,REG_N,REG_M,HEX_8}},
-	{"fmov.s",{F_REG_M,A_IND_N},{HEX_F,REG_N,REG_M,HEX_A}},
-	{"fmov.s",{A_INC_M,F_REG_N},{HEX_F,REG_N,REG_M,HEX_9}},
-	{"fmov.s",{F_REG_M,A_DEC_N},{HEX_F,REG_N,REG_M,HEX_B}},
-	{"fmov.s",{A_IND_R0_REG_M,F_REG_N},{HEX_F,REG_N,REG_M,HEX_6}},
-	{"fmov.s",{F_REG_M,A_IND_R0_REG_N},{HEX_F,REG_N,REG_M,HEX_7}},
-	{"fmul",{F_REG_M,F_REG_N},{HEX_F,REG_N,REG_M,HEX_2}},
-	{"fmul",{D_REG_M,D_REG_N},{HEX_F,REG_N,REG_M,HEX_2}},
-	{"fneg",{FD_REG_N},{HEX_F,REG_N,HEX_4,HEX_D}},
-	{"frchg",{0},{HEX_F,HEX_B,HEX_F,HEX_D}},
-	{"fschg",{0},{HEX_F,HEX_3,HEX_F,HEX_D}},
-	{"fsqrt",{FD_REG_N},{HEX_F,REG_N,HEX_6,HEX_D}},
-	{"fsts",{FPUL_M,F_REG_N},{HEX_F,REG_N,HEX_0,HEX_D}},
-	{"fsub",{F_REG_M,F_REG_N},{HEX_F,REG_N,REG_M,HEX_1}},
-	{"fsub",{D_REG_M,D_REG_N},{HEX_F,REG_N,REG_M,HEX_1}},
-	{"ftrc",{FD_REG_N,FPUL_M},{HEX_F,REG_N,HEX_3,HEX_D}},
-	{"ftrv",{XMTRX_M4,V_REG_N},{HEX_F,REG_NM,HEX_F,HEX_D}},
-	{ 0 },
-};
-
-static void print_sh_insn(u32 memaddr, u16 insn)
-{
-	int relmask = ~0;
-	int nibs[4] = { (insn >> 12) & 0xf, (insn >> 8) & 0xf, (insn >> 4) & 0xf, insn & 0xf};
-	int lastsp;
-	struct sh_opcode_info *op = sh_table;
-
-	for (; op->name; op++) {
-		int n;
-		int imm = 0;
-		int rn = 0;
-		int rm = 0;
-		int rb = 0;
-		int disp_pc;
-		int disp_pc_addr = 0;
-
-		for (n = 0; n < 4; n++) {
-			int i = op->nibbles[n];
-
-			if (i < 16) {
-				if (nibs[n] == i)
-					continue;
-				goto fail;
-			}
-			switch (i) {
-			case BRANCH_8:
-				imm = (nibs[2] << 4) | (nibs[3]);
-				if (imm & 0x80)
-					imm |= ~0xff;
-				imm = ((char)imm) * 2 + 4 ;
-				goto ok;
-			case BRANCH_12:
-				imm = ((nibs[1]) << 8) | (nibs[2] << 4) | (nibs[3]);
-				if (imm & 0x800)
-					imm |= ~0xfff;
-				imm = imm * 2 + 4;
-				goto ok;
-			case IMM_4:
-				imm = nibs[3];
-				goto ok;
-			case IMM_4BY2:
-				imm = nibs[3] <<1;
-				goto ok;
-			case IMM_4BY4:
-				imm = nibs[3] <<2;
-				goto ok;
-			case IMM_8:
-				imm = (nibs[2] << 4) | nibs[3];
-				goto ok;
-			case PCRELIMM_8BY2:
-				imm = ((nibs[2] << 4) | nibs[3]) <<1;
-				relmask = ~1;
-				goto ok;
-			case PCRELIMM_8BY4:
-				imm = ((nibs[2] << 4) | nibs[3]) <<2;
-				relmask = ~3;
-				goto ok;
-			case IMM_8BY2:
-				imm = ((nibs[2] << 4) | nibs[3]) <<1;
-				goto ok;
-			case IMM_8BY4:
-				imm = ((nibs[2] << 4) | nibs[3]) <<2;
-				goto ok;
-			case DISP_8:
-				imm = (nibs[2] << 4) | (nibs[3]);
-				goto ok;
-			case DISP_4:
-				imm = nibs[3];
-				goto ok;
-			case REG_N:
-				rn = nibs[n];
-				break;
-			case REG_M:
-				rm = nibs[n];
-				break;
-			case REG_NM:
-				rn = (nibs[n] & 0xc) >> 2;
-				rm = (nibs[n] & 0x3);
-				break;
-			case REG_B:
-				rb = nibs[n] & 0x07;
-				break;
-			default:
-				return;
-			}
-		}
-
-	ok:
-		pr_cont("%-8s  ", op->name);
-		lastsp = (op->arg[0] == A_END);
-		disp_pc = 0;
-		for (n = 0; n < 6 && op->arg[n] != A_END; n++) {
-			if (n && op->arg[1] != A_END)
-				pr_cont(", ");
-			switch (op->arg[n]) {
-			case A_IMM:
-				pr_cont("#%d", (char)(imm));
-				break;
-			case A_R0:
-				pr_cont("r0");
-				break;
-			case A_REG_N:
-				pr_cont("r%d", rn);
-				break;
-			case A_INC_N:
-				pr_cont("@r%d+", rn);
-				break;
-			case A_DEC_N:
-				pr_cont("@-r%d", rn);
-				break;
-			case A_IND_N:
-				pr_cont("@r%d", rn);
-				break;
-			case A_DISP_REG_N:
-				pr_cont("@(%d,r%d)", imm, rn);
-				break;
-			case A_REG_M:
-				pr_cont("r%d", rm);
-				break;
-			case A_INC_M:
-				pr_cont("@r%d+", rm);
-				break;
-			case A_DEC_M:
-				pr_cont("@-r%d", rm);
-				break;
-			case A_IND_M:
-				pr_cont("@r%d", rm);
-				break;
-			case A_DISP_REG_M:
-				pr_cont("@(%d,r%d)", imm, rm);
-				break;
-			case A_REG_B:
-				pr_cont("r%d_bank", rb);
-				break;
-			case A_DISP_PC:
-				disp_pc = 1;
-				disp_pc_addr = imm + 4 + (memaddr & relmask);
-				pr_cont("%08x <%pS>", disp_pc_addr,
-					(void *)disp_pc_addr);
-				break;
-			case A_IND_R0_REG_N:
-				pr_cont("@(r0,r%d)", rn);
-				break;
-			case A_IND_R0_REG_M:
-				pr_cont("@(r0,r%d)", rm);
-				break;
-			case A_DISP_GBR:
-				pr_cont("@(%d,gbr)", imm);
-				break;
-			case A_R0_GBR:
-				pr_cont("@(r0,gbr)");
-				break;
-			case A_BDISP12:
-			case A_BDISP8:
-				pr_cont("%08x", imm + memaddr);
-				break;
-			case A_SR:
-				pr_cont("sr");
-				break;
-			case A_GBR:
-				pr_cont("gbr");
-				break;
-			case A_VBR:
-				pr_cont("vbr");
-				break;
-			case A_SSR:
-				pr_cont("ssr");
-				break;
-			case A_SPC:
-				pr_cont("spc");
-				break;
-			case A_MACH:
-				pr_cont("mach");
-				break;
-			case A_MACL:
-				pr_cont("macl");
-				break;
-			case A_PR:
-				pr_cont("pr");
-				break;
-			case A_SGR:
-				pr_cont("sgr");
-				break;
-			case A_DBR:
-				pr_cont("dbr");
-				break;
-			case FD_REG_N:
-			case F_REG_N:
-				pr_cont("fr%d", rn);
-				break;
-			case F_REG_M:
-				pr_cont("fr%d", rm);
-				break;
-			case DX_REG_N:
-				if (rn & 1) {
-					pr_cont("xd%d", rn & ~1);
-					break;
-				}
-				fallthrough;
-			case D_REG_N:
-				pr_cont("dr%d", rn);
-				break;
-			case DX_REG_M:
-				if (rm & 1) {
-					pr_cont("xd%d", rm & ~1);
-					break;
-				}
-				fallthrough;
-			case D_REG_M:
-				pr_cont("dr%d", rm);
-				break;
-			case FPSCR_M:
-			case FPSCR_N:
-				pr_cont("fpscr");
-				break;
-			case FPUL_M:
-			case FPUL_N:
-				pr_cont("fpul");
-				break;
-			case F_FR0:
-				pr_cont("fr0");
-				break;
-			case V_REG_N:
-				pr_cont("fv%d", rn*4);
-				break;
-			case V_REG_M:
-				pr_cont("fv%d", rm*4);
-				break;
-			case XMTRX_M4:
-				pr_cont("xmtrx");
-				break;
-			default:
-				return;
-			}
-		}
-
-		if (disp_pc && strcmp(op->name, "mova") != 0) {
-			u32 val;
-
-			if (relmask == ~1)
-				__get_user(val, (u16 *)disp_pc_addr);
-			else
-				__get_user(val, (u32 *)disp_pc_addr);
-
-			pr_cont("  ! %08x <%pS>", val, (void *)val);
-		}
-
-		return;
-	fail:
-		;
-
-	}
-
-	pr_info(".word 0x%x%x%x%x", nibs[0], nibs[1], nibs[2], nibs[3]);
-}
-
-void show_code(struct pt_regs *regs)
-{
-	unsigned short *pc = (unsigned short *)regs->pc;
-	long i;
-
-	if (regs->pc & 0x1)
-		return;
-
-	pr_info("Code:\n");
-
-	for (i = -3 ; i < 6 ; i++) {
-		unsigned short insn;
-
-		if (__get_user(insn, pc + i)) {
-			pr_err(" (Bad address in pc)\n");
-			break;
-		}
-
-		pr_info("%s%08lx:  ", (i ? "  " : "->"),
-			(unsigned long)(pc + i));
-		print_sh_insn((unsigned long)(pc + i), insn);
-		pr_cont("\n");
-	}
-
-	pr_info("\n");
-}
diff --git a/arch/sh/kernel/dma-coherent.c b/arch/sh/kernel/dma-coherent.c
deleted file mode 100644
index 6a44c0e7ba40ef..00000000000000
--- a/arch/sh/kernel/dma-coherent.c
+++ /dev/null
@@ -1,33 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (C) 2004 - 2007  Paul Mundt
- */
-#include <linux/mm.h>
-#include <linux/dma-map-ops.h>
-#include <asm/cacheflush.h>
-#include <asm/addrspace.h>
-
-void arch_dma_prep_coherent(struct page *page, size_t size)
-{
-	__flush_purge_region(page_address(page), size);
-}
-
-void arch_sync_dma_for_device(phys_addr_t paddr, size_t size,
-		enum dma_data_direction dir)
-{
-	void *addr = sh_cacheop_vaddr(phys_to_virt(paddr));
-
-	switch (dir) {
-	case DMA_FROM_DEVICE:		/* invalidate only */
-		__flush_invalidate_region(addr, size);
-		break;
-	case DMA_TO_DEVICE:		/* writeback only */
-		__flush_wback_region(addr, size);
-		break;
-	case DMA_BIDIRECTIONAL:		/* writeback and invalidate */
-		__flush_purge_region(addr, size);
-		break;
-	default:
-		BUG();
-	}
-}
diff --git a/arch/sh/kernel/dumpstack.c b/arch/sh/kernel/dumpstack.c
deleted file mode 100644
index 758a6c89e911bc..00000000000000
--- a/arch/sh/kernel/dumpstack.c
+++ /dev/null
@@ -1,156 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- *  Copyright (C) 1991, 1992  Linus Torvalds
- *  Copyright (C) 2000, 2001, 2002 Andi Kleen, SuSE Labs
- *  Copyright (C) 2009  Matt Fleming
- *  Copyright (C) 2002 - 2012  Paul Mundt
- */
-#include <linux/kallsyms.h>
-#include <linux/ftrace.h>
-#include <linux/debug_locks.h>
-#include <linux/sched/debug.h>
-#include <linux/sched/task_stack.h>
-#include <linux/kdebug.h>
-#include <linux/export.h>
-#include <linux/uaccess.h>
-#include <asm/unwinder.h>
-#include <asm/stacktrace.h>
-
-void dump_mem(const char *str, const char *loglvl, unsigned long bottom,
-	      unsigned long top)
-{
-	unsigned long p;
-	int i;
-
-	printk("%s%s(0x%08lx to 0x%08lx)\n", loglvl, str, bottom, top);
-
-	for (p = bottom & ~31; p < top; ) {
-		printk("%s%04lx: ", loglvl,  p & 0xffff);
-
-		for (i = 0; i < 8; i++, p += 4) {
-			unsigned int val;
-
-			if (p < bottom || p >= top)
-				pr_cont("         ");
-			else {
-				if (__get_user(val, (unsigned int __user *)p)) {
-					pr_cont("\n");
-					return;
-				}
-				pr_cont("%08x ", val);
-			}
-		}
-		pr_cont("\n");
-	}
-}
-
-void printk_address(unsigned long address, int reliable)
-{
-	pr_cont(" [<%px>] %s%pS\n", (void *) address,
-		reliable ? "" : "? ", (void *) address);
-}
-
-#ifdef CONFIG_FUNCTION_GRAPH_TRACER
-static void
-print_ftrace_graph_addr(unsigned long addr, void *data,
-			const struct stacktrace_ops *ops,
-			struct thread_info *tinfo, int *graph)
-{
-	struct task_struct *task = tinfo->task;
-	struct ftrace_ret_stack *ret_stack;
-	unsigned long ret_addr;
-
-	if (addr != (unsigned long)return_to_handler)
-		return;
-
-	if (!task->ret_stack)
-		return;
-
-	ret_stack = ftrace_graph_get_ret_stack(task, *graph);
-	if (!ret_stack)
-		return;
-
-	ret_addr = ret_stack->ret;
-
-	ops->address(data, ret_addr, 1);
-
-	(*graph)++;
-}
-#else
-static inline void
-print_ftrace_graph_addr(unsigned long addr, void *data,
-			const struct stacktrace_ops *ops,
-			struct thread_info *tinfo, int *graph)
-{ }
-#endif
-
-void
-stack_reader_dump(struct task_struct *task, struct pt_regs *regs,
-		  unsigned long *sp, const struct stacktrace_ops *ops,
-		  void *data)
-{
-	struct thread_info *context;
-	int graph = 0;
-
-	context = (struct thread_info *)
-		((unsigned long)sp & (~(THREAD_SIZE - 1)));
-
-	while (!kstack_end(sp)) {
-		unsigned long addr = *sp++;
-
-		if (__kernel_text_address(addr)) {
-			ops->address(data, addr, 1);
-
-			print_ftrace_graph_addr(addr, data, ops,
-						context, &graph);
-		}
-	}
-}
-
-/*
- * Print one address/symbol entries per line.
- */
-static void print_trace_address(void *data, unsigned long addr, int reliable)
-{
-	printk("%s", (char *)data);
-	printk_address(addr, reliable);
-}
-
-static const struct stacktrace_ops print_trace_ops = {
-	.address = print_trace_address,
-};
-
-void show_trace(struct task_struct *tsk, unsigned long *sp,
-		struct pt_regs *regs, const char *loglvl)
-{
-	if (regs && user_mode(regs))
-		return;
-
-	printk("%s\nCall trace:\n", loglvl);
-
-	unwind_stack(tsk, regs, sp, &print_trace_ops, (void *)loglvl);
-
-	pr_cont("\n");
-
-	if (!tsk)
-		tsk = current;
-
-	debug_show_held_locks(tsk);
-}
-
-void show_stack(struct task_struct *tsk, unsigned long *sp, const char *loglvl)
-{
-	unsigned long stack;
-
-	if (!tsk)
-		tsk = current;
-	if (tsk == current)
-		sp = (unsigned long *)current_stack_pointer;
-	else
-		sp = (unsigned long *)tsk->thread.sp;
-
-	stack = (unsigned long)sp;
-	dump_mem("Stack: ", loglvl, stack, THREAD_SIZE +
-		 (unsigned long)task_stack_page(tsk));
-	show_trace(tsk, sp, NULL, loglvl);
-}
diff --git a/arch/sh/kernel/dwarf.c b/arch/sh/kernel/dwarf.c
deleted file mode 100644
index bf8682e7183030..00000000000000
--- a/arch/sh/kernel/dwarf.c
+++ /dev/null
@@ -1,1206 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (C) 2009 Matt Fleming <matt@console-pimps.org>
- *
- * This is an implementation of a DWARF unwinder. Its main purpose is
- * for generating stacktrace information. Based on the DWARF 3
- * specification from http://www.dwarfstd.org.
- *
- * TODO:
- *	- DWARF64 doesn't work.
- *	- Registers with DWARF_VAL_OFFSET rules aren't handled properly.
- */
-
-/* #define DEBUG */
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <linux/list.h>
-#include <linux/mempool.h>
-#include <linux/mm.h>
-#include <linux/elf.h>
-#include <linux/ftrace.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <asm/dwarf.h>
-#include <asm/unwinder.h>
-#include <asm/sections.h>
-#include <asm/unaligned.h>
-#include <asm/stacktrace.h>
-
-/* Reserve enough memory for two stack frames */
-#define DWARF_FRAME_MIN_REQ	2
-/* ... with 4 registers per frame. */
-#define DWARF_REG_MIN_REQ	(DWARF_FRAME_MIN_REQ * 4)
-
-static struct kmem_cache *dwarf_frame_cachep;
-static mempool_t *dwarf_frame_pool;
-
-static struct kmem_cache *dwarf_reg_cachep;
-static mempool_t *dwarf_reg_pool;
-
-static struct rb_root cie_root;
-static DEFINE_SPINLOCK(dwarf_cie_lock);
-
-static struct rb_root fde_root;
-static DEFINE_SPINLOCK(dwarf_fde_lock);
-
-static struct dwarf_cie *cached_cie;
-
-static unsigned int dwarf_unwinder_ready;
-
-/**
- *	dwarf_frame_alloc_reg - allocate memory for a DWARF register
- *	@frame: the DWARF frame whose list of registers we insert on
- *	@reg_num: the register number
- *
- *	Allocate space for, and initialise, a dwarf reg from
- *	dwarf_reg_pool and insert it onto the (unsorted) linked-list of
- *	dwarf registers for @frame.
- *
- *	Return the initialised DWARF reg.
- */
-static struct dwarf_reg *dwarf_frame_alloc_reg(struct dwarf_frame *frame,
-					       unsigned int reg_num)
-{
-	struct dwarf_reg *reg;
-
-	reg = mempool_alloc(dwarf_reg_pool, GFP_ATOMIC);
-	if (!reg) {
-		printk(KERN_WARNING "Unable to allocate a DWARF register\n");
-		/*
-		 * Let's just bomb hard here, we have no way to
-		 * gracefully recover.
-		 */
-		UNWINDER_BUG();
-	}
-
-	reg->number = reg_num;
-	reg->addr = 0;
-	reg->flags = 0;
-
-	list_add(&reg->link, &frame->reg_list);
-
-	return reg;
-}
-
-static void dwarf_frame_free_regs(struct dwarf_frame *frame)
-{
-	struct dwarf_reg *reg, *n;
-
-	list_for_each_entry_safe(reg, n, &frame->reg_list, link) {
-		list_del(&reg->link);
-		mempool_free(reg, dwarf_reg_pool);
-	}
-}
-
-/**
- *	dwarf_frame_reg - return a DWARF register
- *	@frame: the DWARF frame to search in for @reg_num
- *	@reg_num: the register number to search for
- *
- *	Lookup and return the dwarf reg @reg_num for this frame. Return
- *	NULL if @reg_num is an register invalid number.
- */
-static struct dwarf_reg *dwarf_frame_reg(struct dwarf_frame *frame,
-					 unsigned int reg_num)
-{
-	struct dwarf_reg *reg;
-
-	list_for_each_entry(reg, &frame->reg_list, link) {
-		if (reg->number == reg_num)
-			return reg;
-	}
-
-	return NULL;
-}
-
-/**
- *	dwarf_read_addr - read dwarf data
- *	@src: source address of data
- *	@dst: destination address to store the data to
- *
- *	Read 'n' bytes from @src, where 'n' is the size of an address on
- *	the native machine. We return the number of bytes read, which
- *	should always be 'n'. We also have to be careful when reading
- *	from @src and writing to @dst, because they can be arbitrarily
- *	aligned. Return 'n' - the number of bytes read.
- */
-static inline int dwarf_read_addr(unsigned long *src, unsigned long *dst)
-{
-	u32 val = get_unaligned(src);
-	put_unaligned(val, dst);
-	return sizeof(unsigned long *);
-}
-
-/**
- *	dwarf_read_uleb128 - read unsigned LEB128 data
- *	@addr: the address where the ULEB128 data is stored
- *	@ret: address to store the result
- *
- *	Decode an unsigned LEB128 encoded datum. The algorithm is taken
- *	from Appendix C of the DWARF 3 spec. For information on the
- *	encodings refer to section "7.6 - Variable Length Data". Return
- *	the number of bytes read.
- */
-static inline unsigned long dwarf_read_uleb128(char *addr, unsigned int *ret)
-{
-	unsigned int result;
-	unsigned char byte;
-	int shift, count;
-
-	result = 0;
-	shift = 0;
-	count = 0;
-
-	while (1) {
-		byte = __raw_readb(addr);
-		addr++;
-		count++;
-
-		result |= (byte & 0x7f) << shift;
-		shift += 7;
-
-		if (!(byte & 0x80))
-			break;
-	}
-
-	*ret = result;
-
-	return count;
-}
-
-/**
- *	dwarf_read_leb128 - read signed LEB128 data
- *	@addr: the address of the LEB128 encoded data
- *	@ret: address to store the result
- *
- *	Decode signed LEB128 data. The algorithm is taken from Appendix
- *	C of the DWARF 3 spec. Return the number of bytes read.
- */
-static inline unsigned long dwarf_read_leb128(char *addr, int *ret)
-{
-	unsigned char byte;
-	int result, shift;
-	int num_bits;
-	int count;
-
-	result = 0;
-	shift = 0;
-	count = 0;
-
-	while (1) {
-		byte = __raw_readb(addr);
-		addr++;
-		result |= (byte & 0x7f) << shift;
-		shift += 7;
-		count++;
-
-		if (!(byte & 0x80))
-			break;
-	}
-
-	/* The number of bits in a signed integer. */
-	num_bits = 8 * sizeof(result);
-
-	if ((shift < num_bits) && (byte & 0x40))
-		result |= (-1 << shift);
-
-	*ret = result;
-
-	return count;
-}
-
-/**
- *	dwarf_read_encoded_value - return the decoded value at @addr
- *	@addr: the address of the encoded value
- *	@val: where to write the decoded value
- *	@encoding: the encoding with which we can decode @addr
- *
- *	GCC emits encoded address in the .eh_frame FDE entries. Decode
- *	the value at @addr using @encoding. The decoded value is written
- *	to @val and the number of bytes read is returned.
- */
-static int dwarf_read_encoded_value(char *addr, unsigned long *val,
-				    char encoding)
-{
-	unsigned long decoded_addr = 0;
-	int count = 0;
-
-	switch (encoding & 0x70) {
-	case DW_EH_PE_absptr:
-		break;
-	case DW_EH_PE_pcrel:
-		decoded_addr = (unsigned long)addr;
-		break;
-	default:
-		pr_debug("encoding=0x%x\n", (encoding & 0x70));
-		UNWINDER_BUG();
-	}
-
-	if ((encoding & 0x07) == 0x00)
-		encoding |= DW_EH_PE_udata4;
-
-	switch (encoding & 0x0f) {
-	case DW_EH_PE_sdata4:
-	case DW_EH_PE_udata4:
-		count += 4;
-		decoded_addr += get_unaligned((u32 *)addr);
-		__raw_writel(decoded_addr, val);
-		break;
-	default:
-		pr_debug("encoding=0x%x\n", encoding);
-		UNWINDER_BUG();
-	}
-
-	return count;
-}
-
-/**
- *	dwarf_entry_len - return the length of an FDE or CIE
- *	@addr: the address of the entry
- *	@len: the length of the entry
- *
- *	Read the initial_length field of the entry and store the size of
- *	the entry in @len. We return the number of bytes read. Return a
- *	count of 0 on error.
- */
-static inline int dwarf_entry_len(char *addr, unsigned long *len)
-{
-	u32 initial_len;
-	int count;
-
-	initial_len = get_unaligned((u32 *)addr);
-	count = 4;
-
-	/*
-	 * An initial length field value in the range DW_LEN_EXT_LO -
-	 * DW_LEN_EXT_HI indicates an extension, and should not be
-	 * interpreted as a length. The only extension that we currently
-	 * understand is the use of DWARF64 addresses.
-	 */
-	if (initial_len >= DW_EXT_LO && initial_len <= DW_EXT_HI) {
-		/*
-		 * The 64-bit length field immediately follows the
-		 * compulsory 32-bit length field.
-		 */
-		if (initial_len == DW_EXT_DWARF64) {
-			*len = get_unaligned((u64 *)addr + 4);
-			count = 12;
-		} else {
-			printk(KERN_WARNING "Unknown DWARF extension\n");
-			count = 0;
-		}
-	} else
-		*len = initial_len;
-
-	return count;
-}
-
-/**
- *	dwarf_lookup_cie - locate the cie
- *	@cie_ptr: pointer to help with lookup
- */
-static struct dwarf_cie *dwarf_lookup_cie(unsigned long cie_ptr)
-{
-	struct rb_node **rb_node = &cie_root.rb_node;
-	struct dwarf_cie *cie = NULL;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dwarf_cie_lock, flags);
-
-	/*
-	 * We've cached the last CIE we looked up because chances are
-	 * that the FDE wants this CIE.
-	 */
-	if (cached_cie && cached_cie->cie_pointer == cie_ptr) {
-		cie = cached_cie;
-		goto out;
-	}
-
-	while (*rb_node) {
-		struct dwarf_cie *cie_tmp;
-
-		cie_tmp = rb_entry(*rb_node, struct dwarf_cie, node);
-		BUG_ON(!cie_tmp);
-
-		if (cie_ptr == cie_tmp->cie_pointer) {
-			cie = cie_tmp;
-			cached_cie = cie_tmp;
-			goto out;
-		} else {
-			if (cie_ptr < cie_tmp->cie_pointer)
-				rb_node = &(*rb_node)->rb_left;
-			else
-				rb_node = &(*rb_node)->rb_right;
-		}
-	}
-
-out:
-	spin_unlock_irqrestore(&dwarf_cie_lock, flags);
-	return cie;
-}
-
-/**
- *	dwarf_lookup_fde - locate the FDE that covers pc
- *	@pc: the program counter
- */
-struct dwarf_fde *dwarf_lookup_fde(unsigned long pc)
-{
-	struct rb_node **rb_node = &fde_root.rb_node;
-	struct dwarf_fde *fde = NULL;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dwarf_fde_lock, flags);
-
-	while (*rb_node) {
-		struct dwarf_fde *fde_tmp;
-		unsigned long tmp_start, tmp_end;
-
-		fde_tmp = rb_entry(*rb_node, struct dwarf_fde, node);
-		BUG_ON(!fde_tmp);
-
-		tmp_start = fde_tmp->initial_location;
-		tmp_end = fde_tmp->initial_location + fde_tmp->address_range;
-
-		if (pc < tmp_start) {
-			rb_node = &(*rb_node)->rb_left;
-		} else {
-			if (pc < tmp_end) {
-				fde = fde_tmp;
-				goto out;
-			} else
-				rb_node = &(*rb_node)->rb_right;
-		}
-	}
-
-out:
-	spin_unlock_irqrestore(&dwarf_fde_lock, flags);
-
-	return fde;
-}
-
-/**
- *	dwarf_cfa_execute_insns - execute instructions to calculate a CFA
- *	@insn_start: address of the first instruction
- *	@insn_end: address of the last instruction
- *	@cie: the CIE for this function
- *	@fde: the FDE for this function
- *	@frame: the instructions calculate the CFA for this frame
- *	@pc: the program counter of the address we're interested in
- *
- *	Execute the Call Frame instruction sequence starting at
- *	@insn_start and ending at @insn_end. The instructions describe
- *	how to calculate the Canonical Frame Address of a stackframe.
- *	Store the results in @frame.
- */
-static int dwarf_cfa_execute_insns(unsigned char *insn_start,
-				   unsigned char *insn_end,
-				   struct dwarf_cie *cie,
-				   struct dwarf_fde *fde,
-				   struct dwarf_frame *frame,
-				   unsigned long pc)
-{
-	unsigned char insn;
-	unsigned char *current_insn;
-	unsigned int count, delta, reg, expr_len, offset;
-	struct dwarf_reg *regp;
-
-	current_insn = insn_start;
-
-	while (current_insn < insn_end && frame->pc <= pc) {
-		insn = __raw_readb(current_insn++);
-
-		/*
-		 * Firstly, handle the opcodes that embed their operands
-		 * in the instructions.
-		 */
-		switch (DW_CFA_opcode(insn)) {
-		case DW_CFA_advance_loc:
-			delta = DW_CFA_operand(insn);
-			delta *= cie->code_alignment_factor;
-			frame->pc += delta;
-			continue;
-			/* NOTREACHED */
-		case DW_CFA_offset:
-			reg = DW_CFA_operand(insn);
-			count = dwarf_read_uleb128(current_insn, &offset);
-			current_insn += count;
-			offset *= cie->data_alignment_factor;
-			regp = dwarf_frame_alloc_reg(frame, reg);
-			regp->addr = offset;
-			regp->flags |= DWARF_REG_OFFSET;
-			continue;
-			/* NOTREACHED */
-		case DW_CFA_restore:
-			reg = DW_CFA_operand(insn);
-			continue;
-			/* NOTREACHED */
-		}
-
-		/*
-		 * Secondly, handle the opcodes that don't embed their
-		 * operands in the instruction.
-		 */
-		switch (insn) {
-		case DW_CFA_nop:
-			continue;
-		case DW_CFA_advance_loc1:
-			delta = *current_insn++;
-			frame->pc += delta * cie->code_alignment_factor;
-			break;
-		case DW_CFA_advance_loc2:
-			delta = get_unaligned((u16 *)current_insn);
-			current_insn += 2;
-			frame->pc += delta * cie->code_alignment_factor;
-			break;
-		case DW_CFA_advance_loc4:
-			delta = get_unaligned((u32 *)current_insn);
-			current_insn += 4;
-			frame->pc += delta * cie->code_alignment_factor;
-			break;
-		case DW_CFA_offset_extended:
-			count = dwarf_read_uleb128(current_insn, &reg);
-			current_insn += count;
-			count = dwarf_read_uleb128(current_insn, &offset);
-			current_insn += count;
-			offset *= cie->data_alignment_factor;
-			break;
-		case DW_CFA_restore_extended:
-			count = dwarf_read_uleb128(current_insn, &reg);
-			current_insn += count;
-			break;
-		case DW_CFA_undefined:
-			count = dwarf_read_uleb128(current_insn, &reg);
-			current_insn += count;
-			regp = dwarf_frame_alloc_reg(frame, reg);
-			regp->flags |= DWARF_UNDEFINED;
-			break;
-		case DW_CFA_def_cfa:
-			count = dwarf_read_uleb128(current_insn,
-						   &frame->cfa_register);
-			current_insn += count;
-			count = dwarf_read_uleb128(current_insn,
-						   &frame->cfa_offset);
-			current_insn += count;
-
-			frame->flags |= DWARF_FRAME_CFA_REG_OFFSET;
-			break;
-		case DW_CFA_def_cfa_register:
-			count = dwarf_read_uleb128(current_insn,
-						   &frame->cfa_register);
-			current_insn += count;
-			frame->flags |= DWARF_FRAME_CFA_REG_OFFSET;
-			break;
-		case DW_CFA_def_cfa_offset:
-			count = dwarf_read_uleb128(current_insn, &offset);
-			current_insn += count;
-			frame->cfa_offset = offset;
-			break;
-		case DW_CFA_def_cfa_expression:
-			count = dwarf_read_uleb128(current_insn, &expr_len);
-			current_insn += count;
-
-			frame->cfa_expr = current_insn;
-			frame->cfa_expr_len = expr_len;
-			current_insn += expr_len;
-
-			frame->flags |= DWARF_FRAME_CFA_REG_EXP;
-			break;
-		case DW_CFA_offset_extended_sf:
-			count = dwarf_read_uleb128(current_insn, &reg);
-			current_insn += count;
-			count = dwarf_read_leb128(current_insn, &offset);
-			current_insn += count;
-			offset *= cie->data_alignment_factor;
-			regp = dwarf_frame_alloc_reg(frame, reg);
-			regp->flags |= DWARF_REG_OFFSET;
-			regp->addr = offset;
-			break;
-		case DW_CFA_val_offset:
-			count = dwarf_read_uleb128(current_insn, &reg);
-			current_insn += count;
-			count = dwarf_read_leb128(current_insn, &offset);
-			offset *= cie->data_alignment_factor;
-			regp = dwarf_frame_alloc_reg(frame, reg);
-			regp->flags |= DWARF_VAL_OFFSET;
-			regp->addr = offset;
-			break;
-		case DW_CFA_GNU_args_size:
-			count = dwarf_read_uleb128(current_insn, &offset);
-			current_insn += count;
-			break;
-		case DW_CFA_GNU_negative_offset_extended:
-			count = dwarf_read_uleb128(current_insn, &reg);
-			current_insn += count;
-			count = dwarf_read_uleb128(current_insn, &offset);
-			offset *= cie->data_alignment_factor;
-
-			regp = dwarf_frame_alloc_reg(frame, reg);
-			regp->flags |= DWARF_REG_OFFSET;
-			regp->addr = -offset;
-			break;
-		default:
-			pr_debug("unhandled DWARF instruction 0x%x\n", insn);
-			UNWINDER_BUG();
-			break;
-		}
-	}
-
-	return 0;
-}
-
-/**
- *	dwarf_free_frame - free the memory allocated for @frame
- *	@frame: the frame to free
- */
-void dwarf_free_frame(struct dwarf_frame *frame)
-{
-	dwarf_frame_free_regs(frame);
-	mempool_free(frame, dwarf_frame_pool);
-}
-
-extern void ret_from_irq(void);
-
-/**
- *	dwarf_unwind_stack - unwind the stack
- *
- *	@pc: address of the function to unwind
- *	@prev: struct dwarf_frame of the previous stackframe on the callstack
- *
- *	Return a struct dwarf_frame representing the most recent frame
- *	on the callstack. Each of the lower (older) stack frames are
- *	linked via the "prev" member.
- */
-struct dwarf_frame *dwarf_unwind_stack(unsigned long pc,
-				       struct dwarf_frame *prev)
-{
-	struct dwarf_frame *frame;
-	struct dwarf_cie *cie;
-	struct dwarf_fde *fde;
-	struct dwarf_reg *reg;
-	unsigned long addr;
-
-	/*
-	 * If we've been called in to before initialization has
-	 * completed, bail out immediately.
-	 */
-	if (!dwarf_unwinder_ready)
-		return NULL;
-
-	/*
-	 * If we're starting at the top of the stack we need get the
-	 * contents of a physical register to get the CFA in order to
-	 * begin the virtual unwinding of the stack.
-	 *
-	 * NOTE: the return address is guaranteed to be setup by the
-	 * time this function makes its first function call.
-	 */
-	if (!pc || !prev)
-		pc = _THIS_IP_;
-
-#ifdef CONFIG_FUNCTION_GRAPH_TRACER
-	/*
-	 * If our stack has been patched by the function graph tracer
-	 * then we might see the address of return_to_handler() where we
-	 * expected to find the real return address.
-	 */
-	if (pc == (unsigned long)&return_to_handler) {
-		struct ftrace_ret_stack *ret_stack;
-
-		ret_stack = ftrace_graph_get_ret_stack(current, 0);
-		if (ret_stack)
-			pc = ret_stack->ret;
-		/*
-		 * We currently have no way of tracking how many
-		 * return_to_handler()'s we've seen. If there is more
-		 * than one patched return address on our stack,
-		 * complain loudly.
-		 */
-		WARN_ON(ftrace_graph_get_ret_stack(current, 1));
-	}
-#endif
-
-	frame = mempool_alloc(dwarf_frame_pool, GFP_ATOMIC);
-	if (!frame) {
-		printk(KERN_ERR "Unable to allocate a dwarf frame\n");
-		UNWINDER_BUG();
-	}
-
-	INIT_LIST_HEAD(&frame->reg_list);
-	frame->flags = 0;
-	frame->prev = prev;
-	frame->return_addr = 0;
-
-	fde = dwarf_lookup_fde(pc);
-	if (!fde) {
-		/*
-		 * This is our normal exit path. There are two reasons
-		 * why we might exit here,
-		 *
-		 *	a) pc has no asscociated DWARF frame info and so
-		 *	we don't know how to unwind this frame. This is
-		 *	usually the case when we're trying to unwind a
-		 *	frame that was called from some assembly code
-		 *	that has no DWARF info, e.g. syscalls.
-		 *
-		 *	b) the DEBUG info for pc is bogus. There's
-		 *	really no way to distinguish this case from the
-		 *	case above, which sucks because we could print a
-		 *	warning here.
-		 */
-		goto bail;
-	}
-
-	cie = dwarf_lookup_cie(fde->cie_pointer);
-
-	frame->pc = fde->initial_location;
-
-	/* CIE initial instructions */
-	dwarf_cfa_execute_insns(cie->initial_instructions,
-				cie->instructions_end, cie, fde,
-				frame, pc);
-
-	/* FDE instructions */
-	dwarf_cfa_execute_insns(fde->instructions, fde->end, cie,
-				fde, frame, pc);
-
-	/* Calculate the CFA */
-	switch (frame->flags) {
-	case DWARF_FRAME_CFA_REG_OFFSET:
-		if (prev) {
-			reg = dwarf_frame_reg(prev, frame->cfa_register);
-			UNWINDER_BUG_ON(!reg);
-			UNWINDER_BUG_ON(reg->flags != DWARF_REG_OFFSET);
-
-			addr = prev->cfa + reg->addr;
-			frame->cfa = __raw_readl(addr);
-
-		} else {
-			/*
-			 * Again, we're starting from the top of the
-			 * stack. We need to physically read
-			 * the contents of a register in order to get
-			 * the Canonical Frame Address for this
-			 * function.
-			 */
-			frame->cfa = dwarf_read_arch_reg(frame->cfa_register);
-		}
-
-		frame->cfa += frame->cfa_offset;
-		break;
-	default:
-		UNWINDER_BUG();
-	}
-
-	reg = dwarf_frame_reg(frame, DWARF_ARCH_RA_REG);
-
-	/*
-	 * If we haven't seen the return address register or the return
-	 * address column is undefined then we must assume that this is
-	 * the end of the callstack.
-	 */
-	if (!reg || reg->flags == DWARF_UNDEFINED)
-		goto bail;
-
-	UNWINDER_BUG_ON(reg->flags != DWARF_REG_OFFSET);
-
-	addr = frame->cfa + reg->addr;
-	frame->return_addr = __raw_readl(addr);
-
-	/*
-	 * Ah, the joys of unwinding through interrupts.
-	 *
-	 * Interrupts are tricky - the DWARF info needs to be _really_
-	 * accurate and unfortunately I'm seeing a lot of bogus DWARF
-	 * info. For example, I've seen interrupts occur in epilogues
-	 * just after the frame pointer (r14) had been restored. The
-	 * problem was that the DWARF info claimed that the CFA could be
-	 * reached by using the value of the frame pointer before it was
-	 * restored.
-	 *
-	 * So until the compiler can be trusted to produce reliable
-	 * DWARF info when it really matters, let's stop unwinding once
-	 * we've calculated the function that was interrupted.
-	 */
-	if (prev && prev->pc == (unsigned long)ret_from_irq)
-		frame->return_addr = 0;
-
-	return frame;
-
-bail:
-	dwarf_free_frame(frame);
-	return NULL;
-}
-
-static int dwarf_parse_cie(void *entry, void *p, unsigned long len,
-			   unsigned char *end, struct module *mod)
-{
-	struct rb_node **rb_node = &cie_root.rb_node;
-	struct rb_node *parent = *rb_node;
-	struct dwarf_cie *cie;
-	unsigned long flags;
-	int count;
-
-	cie = kzalloc(sizeof(*cie), GFP_KERNEL);
-	if (!cie)
-		return -ENOMEM;
-
-	cie->length = len;
-
-	/*
-	 * Record the offset into the .eh_frame section
-	 * for this CIE. It allows this CIE to be
-	 * quickly and easily looked up from the
-	 * corresponding FDE.
-	 */
-	cie->cie_pointer = (unsigned long)entry;
-
-	cie->version = *(char *)p++;
-	UNWINDER_BUG_ON(cie->version != 1);
-
-	cie->augmentation = p;
-	p += strlen(cie->augmentation) + 1;
-
-	count = dwarf_read_uleb128(p, &cie->code_alignment_factor);
-	p += count;
-
-	count = dwarf_read_leb128(p, &cie->data_alignment_factor);
-	p += count;
-
-	/*
-	 * Which column in the rule table contains the
-	 * return address?
-	 */
-	if (cie->version == 1) {
-		cie->return_address_reg = __raw_readb(p);
-		p++;
-	} else {
-		count = dwarf_read_uleb128(p, &cie->return_address_reg);
-		p += count;
-	}
-
-	if (cie->augmentation[0] == 'z') {
-		unsigned int length, count;
-		cie->flags |= DWARF_CIE_Z_AUGMENTATION;
-
-		count = dwarf_read_uleb128(p, &length);
-		p += count;
-
-		UNWINDER_BUG_ON((unsigned char *)p > end);
-
-		cie->initial_instructions = p + length;
-		cie->augmentation++;
-	}
-
-	while (*cie->augmentation) {
-		/*
-		 * "L" indicates a byte showing how the
-		 * LSDA pointer is encoded. Skip it.
-		 */
-		if (*cie->augmentation == 'L') {
-			p++;
-			cie->augmentation++;
-		} else if (*cie->augmentation == 'R') {
-			/*
-			 * "R" indicates a byte showing
-			 * how FDE addresses are
-			 * encoded.
-			 */
-			cie->encoding = *(char *)p++;
-			cie->augmentation++;
-		} else if (*cie->augmentation == 'P') {
-			/*
-			 * "R" indicates a personality
-			 * routine in the CIE
-			 * augmentation.
-			 */
-			UNWINDER_BUG();
-		} else if (*cie->augmentation == 'S') {
-			UNWINDER_BUG();
-		} else {
-			/*
-			 * Unknown augmentation. Assume
-			 * 'z' augmentation.
-			 */
-			p = cie->initial_instructions;
-			UNWINDER_BUG_ON(!p);
-			break;
-		}
-	}
-
-	cie->initial_instructions = p;
-	cie->instructions_end = end;
-
-	/* Add to list */
-	spin_lock_irqsave(&dwarf_cie_lock, flags);
-
-	while (*rb_node) {
-		struct dwarf_cie *cie_tmp;
-
-		cie_tmp = rb_entry(*rb_node, struct dwarf_cie, node);
-
-		parent = *rb_node;
-
-		if (cie->cie_pointer < cie_tmp->cie_pointer)
-			rb_node = &parent->rb_left;
-		else if (cie->cie_pointer >= cie_tmp->cie_pointer)
-			rb_node = &parent->rb_right;
-		else
-			WARN_ON(1);
-	}
-
-	rb_link_node(&cie->node, parent, rb_node);
-	rb_insert_color(&cie->node, &cie_root);
-
-#ifdef CONFIG_MODULES
-	if (mod != NULL)
-		list_add_tail(&cie->link, &mod->arch.cie_list);
-#endif
-
-	spin_unlock_irqrestore(&dwarf_cie_lock, flags);
-
-	return 0;
-}
-
-static int dwarf_parse_fde(void *entry, u32 entry_type,
-			   void *start, unsigned long len,
-			   unsigned char *end, struct module *mod)
-{
-	struct rb_node **rb_node = &fde_root.rb_node;
-	struct rb_node *parent = *rb_node;
-	struct dwarf_fde *fde;
-	struct dwarf_cie *cie;
-	unsigned long flags;
-	int count;
-	void *p = start;
-
-	fde = kzalloc(sizeof(*fde), GFP_KERNEL);
-	if (!fde)
-		return -ENOMEM;
-
-	fde->length = len;
-
-	/*
-	 * In a .eh_frame section the CIE pointer is the
-	 * delta between the address within the FDE
-	 */
-	fde->cie_pointer = (unsigned long)(p - entry_type - 4);
-
-	cie = dwarf_lookup_cie(fde->cie_pointer);
-	fde->cie = cie;
-
-	if (cie->encoding)
-		count = dwarf_read_encoded_value(p, &fde->initial_location,
-						 cie->encoding);
-	else
-		count = dwarf_read_addr(p, &fde->initial_location);
-
-	p += count;
-
-	if (cie->encoding)
-		count = dwarf_read_encoded_value(p, &fde->address_range,
-						 cie->encoding & 0x0f);
-	else
-		count = dwarf_read_addr(p, &fde->address_range);
-
-	p += count;
-
-	if (fde->cie->flags & DWARF_CIE_Z_AUGMENTATION) {
-		unsigned int length;
-		count = dwarf_read_uleb128(p, &length);
-		p += count + length;
-	}
-
-	/* Call frame instructions. */
-	fde->instructions = p;
-	fde->end = end;
-
-	/* Add to list. */
-	spin_lock_irqsave(&dwarf_fde_lock, flags);
-
-	while (*rb_node) {
-		struct dwarf_fde *fde_tmp;
-		unsigned long tmp_start, tmp_end;
-		unsigned long start, end;
-
-		fde_tmp = rb_entry(*rb_node, struct dwarf_fde, node);
-
-		start = fde->initial_location;
-		end = fde->initial_location + fde->address_range;
-
-		tmp_start = fde_tmp->initial_location;
-		tmp_end = fde_tmp->initial_location + fde_tmp->address_range;
-
-		parent = *rb_node;
-
-		if (start < tmp_start)
-			rb_node = &parent->rb_left;
-		else if (start >= tmp_end)
-			rb_node = &parent->rb_right;
-		else
-			WARN_ON(1);
-	}
-
-	rb_link_node(&fde->node, parent, rb_node);
-	rb_insert_color(&fde->node, &fde_root);
-
-#ifdef CONFIG_MODULES
-	if (mod != NULL)
-		list_add_tail(&fde->link, &mod->arch.fde_list);
-#endif
-
-	spin_unlock_irqrestore(&dwarf_fde_lock, flags);
-
-	return 0;
-}
-
-static void dwarf_unwinder_dump(struct task_struct *task,
-				struct pt_regs *regs,
-				unsigned long *sp,
-				const struct stacktrace_ops *ops,
-				void *data)
-{
-	struct dwarf_frame *frame, *_frame;
-	unsigned long return_addr;
-
-	_frame = NULL;
-	return_addr = 0;
-
-	while (1) {
-		frame = dwarf_unwind_stack(return_addr, _frame);
-
-		if (_frame)
-			dwarf_free_frame(_frame);
-
-		_frame = frame;
-
-		if (!frame || !frame->return_addr)
-			break;
-
-		return_addr = frame->return_addr;
-		ops->address(data, return_addr, 1);
-	}
-
-	if (frame)
-		dwarf_free_frame(frame);
-}
-
-static struct unwinder dwarf_unwinder = {
-	.name = "dwarf-unwinder",
-	.dump = dwarf_unwinder_dump,
-	.rating = 150,
-};
-
-static void __init dwarf_unwinder_cleanup(void)
-{
-	struct dwarf_fde *fde, *next_fde;
-	struct dwarf_cie *cie, *next_cie;
-
-	/*
-	 * Deallocate all the memory allocated for the DWARF unwinder.
-	 * Traverse all the FDE/CIE lists and remove and free all the
-	 * memory associated with those data structures.
-	 */
-	rbtree_postorder_for_each_entry_safe(fde, next_fde, &fde_root, node)
-		kfree(fde);
-
-	rbtree_postorder_for_each_entry_safe(cie, next_cie, &cie_root, node)
-		kfree(cie);
-
-	mempool_destroy(dwarf_reg_pool);
-	mempool_destroy(dwarf_frame_pool);
-	kmem_cache_destroy(dwarf_reg_cachep);
-	kmem_cache_destroy(dwarf_frame_cachep);
-}
-
-/**
- *	dwarf_parse_section - parse DWARF section
- *	@eh_frame_start: start address of the .eh_frame section
- *	@eh_frame_end: end address of the .eh_frame section
- *	@mod: the kernel module containing the .eh_frame section
- *
- *	Parse the information in a .eh_frame section.
- */
-static int dwarf_parse_section(char *eh_frame_start, char *eh_frame_end,
-			       struct module *mod)
-{
-	u32 entry_type;
-	void *p, *entry;
-	int count, err = 0;
-	unsigned long len = 0;
-	unsigned int c_entries, f_entries;
-	unsigned char *end;
-
-	c_entries = 0;
-	f_entries = 0;
-	entry = eh_frame_start;
-
-	while ((char *)entry < eh_frame_end) {
-		p = entry;
-
-		count = dwarf_entry_len(p, &len);
-		if (count == 0) {
-			/*
-			 * We read a bogus length field value. There is
-			 * nothing we can do here apart from disabling
-			 * the DWARF unwinder. We can't even skip this
-			 * entry and move to the next one because 'len'
-			 * tells us where our next entry is.
-			 */
-			err = -EINVAL;
-			goto out;
-		} else
-			p += count;
-
-		/* initial length does not include itself */
-		end = p + len;
-
-		entry_type = get_unaligned((u32 *)p);
-		p += 4;
-
-		if (entry_type == DW_EH_FRAME_CIE) {
-			err = dwarf_parse_cie(entry, p, len, end, mod);
-			if (err < 0)
-				goto out;
-			else
-				c_entries++;
-		} else {
-			err = dwarf_parse_fde(entry, entry_type, p, len,
-					      end, mod);
-			if (err < 0)
-				goto out;
-			else
-				f_entries++;
-		}
-
-		entry = (char *)entry + len + 4;
-	}
-
-	printk(KERN_INFO "DWARF unwinder initialised: read %u CIEs, %u FDEs\n",
-	       c_entries, f_entries);
-
-	return 0;
-
-out:
-	return err;
-}
-
-#ifdef CONFIG_MODULES
-int module_dwarf_finalize(const Elf_Ehdr *hdr, const Elf_Shdr *sechdrs,
-			  struct module *me)
-{
-	unsigned int i, err;
-	unsigned long start, end;
-	char *secstrings = (void *)hdr + sechdrs[hdr->e_shstrndx].sh_offset;
-
-	start = end = 0;
-
-	for (i = 1; i < hdr->e_shnum; i++) {
-		/* Alloc bit cleared means "ignore it." */
-		if ((sechdrs[i].sh_flags & SHF_ALLOC)
-		    && !strcmp(secstrings+sechdrs[i].sh_name, ".eh_frame")) {
-			start = sechdrs[i].sh_addr;
-			end = start + sechdrs[i].sh_size;
-			break;
-		}
-	}
-
-	/* Did we find the .eh_frame section? */
-	if (i != hdr->e_shnum) {
-		INIT_LIST_HEAD(&me->arch.cie_list);
-		INIT_LIST_HEAD(&me->arch.fde_list);
-		err = dwarf_parse_section((char *)start, (char *)end, me);
-		if (err) {
-			printk(KERN_WARNING "%s: failed to parse DWARF info\n",
-			       me->name);
-			return err;
-		}
-	}
-
-	return 0;
-}
-
-/**
- *	module_dwarf_cleanup - remove FDE/CIEs associated with @mod
- *	@mod: the module that is being unloaded
- *
- *	Remove any FDEs and CIEs from the global lists that came from
- *	@mod's .eh_frame section because @mod is being unloaded.
- */
-void module_dwarf_cleanup(struct module *mod)
-{
-	struct dwarf_fde *fde, *ftmp;
-	struct dwarf_cie *cie, *ctmp;
-	unsigned long flags;
-
-	spin_lock_irqsave(&dwarf_cie_lock, flags);
-
-	list_for_each_entry_safe(cie, ctmp, &mod->arch.cie_list, link) {
-		list_del(&cie->link);
-		rb_erase(&cie->node, &cie_root);
-		kfree(cie);
-	}
-
-	spin_unlock_irqrestore(&dwarf_cie_lock, flags);
-
-	spin_lock_irqsave(&dwarf_fde_lock, flags);
-
-	list_for_each_entry_safe(fde, ftmp, &mod->arch.fde_list, link) {
-		list_del(&fde->link);
-		rb_erase(&fde->node, &fde_root);
-		kfree(fde);
-	}
-
-	spin_unlock_irqrestore(&dwarf_fde_lock, flags);
-}
-#endif /* CONFIG_MODULES */
-
-/**
- *	dwarf_unwinder_init - initialise the dwarf unwinder
- *
- *	Build the data structures describing the .dwarf_frame section to
- *	make it easier to lookup CIE and FDE entries. Because the
- *	.eh_frame section is packed as tightly as possible it is not
- *	easy to lookup the FDE for a given PC, so we build a list of FDE
- *	and CIE entries that make it easier.
- */
-static int __init dwarf_unwinder_init(void)
-{
-	int err = -ENOMEM;
-
-	dwarf_frame_cachep = kmem_cache_create("dwarf_frames",
-			sizeof(struct dwarf_frame), 0,
-			SLAB_PANIC | SLAB_HWCACHE_ALIGN, NULL);
-
-	dwarf_reg_cachep = kmem_cache_create("dwarf_regs",
-			sizeof(struct dwarf_reg), 0,
-			SLAB_PANIC | SLAB_HWCACHE_ALIGN, NULL);
-
-	dwarf_frame_pool = mempool_create_slab_pool(DWARF_FRAME_MIN_REQ,
-						    dwarf_frame_cachep);
-	if (!dwarf_frame_pool)
-		goto out;
-
-	dwarf_reg_pool = mempool_create_slab_pool(DWARF_REG_MIN_REQ,
-						  dwarf_reg_cachep);
-	if (!dwarf_reg_pool)
-		goto out;
-
-	err = dwarf_parse_section(__start_eh_frame, __stop_eh_frame, NULL);
-	if (err)
-		goto out;
-
-	err = unwinder_register(&dwarf_unwinder);
-	if (err)
-		goto out;
-
-	dwarf_unwinder_ready = 1;
-
-	return 0;
-
-out:
-	printk(KERN_ERR "Failed to initialise DWARF unwinder: %d\n", err);
-	dwarf_unwinder_cleanup();
-	return err;
-}
-early_initcall(dwarf_unwinder_init);
diff --git a/arch/sh/kernel/entry-common.S b/arch/sh/kernel/entry-common.S
deleted file mode 100644
index 91ab2607a1ff9f..00000000000000
--- a/arch/sh/kernel/entry-common.S
+++ /dev/null
@@ -1,400 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- *  Copyright (C) 1999, 2000, 2002  Niibe Yutaka
- *  Copyright (C) 2003 - 2008  Paul Mundt
- */
-
-! NOTE:
-! GNU as (as of 2.9.1) changes bf/s into bt/s and bra, when the address
-! to be jumped is too far, but it causes illegal slot exception.
-
-/*	
- * entry.S contains the system-call and fault low-level handling routines.
- * This also contains the timer-interrupt handler, as well as all interrupts
- * and faults that can result in a task-switch.
- *
- * NOTE: This code handles signal-recognition, which happens every time
- * after a timer-interrupt and after each system call.
- *
- * NOTE: This code uses a convention that instructions in the delay slot
- * of a transfer-control instruction are indented by an extra space, thus:
- *
- *    jmp	@k0	    ! control-transfer instruction
- *     ldc	k1, ssr     ! delay slot
- *
- * Stack layout in 'ret_from_syscall':
- * 	ptrace needs to have all regs on the stack.
- *	if the order here is changed, it needs to be
- *	updated in ptrace.c and ptrace.h
- *
- *	r0
- *      ...
- *	r15 = stack pointer
- *	spc
- *	pr
- *	ssr
- *	gbr
- *	mach
- *	macl
- *	syscall #
- *
- */
-#include <asm/dwarf.h>
-
-#if defined(CONFIG_PREEMPTION)
-#  define preempt_stop()	cli ; TRACE_IRQS_OFF
-#else
-#  define preempt_stop()
-#  define resume_kernel		__restore_all
-#endif
-
-
-	.align	2
-ENTRY(exception_error)
-	!
-	TRACE_IRQS_ON
-	sti
-	mov.l	1f, r0
-	jmp	@r0
-	 nop
-
-	.align	2
-1:	.long	do_exception_error
-
-	.align	2
-ret_from_exception:
-	CFI_STARTPROC simple
-	CFI_DEF_CFA r14, 0
-	CFI_REL_OFFSET 17, 64
-	CFI_REL_OFFSET 15, 60
-	CFI_REL_OFFSET 14, 56
-	CFI_REL_OFFSET 13, 52
-	CFI_REL_OFFSET 12, 48
-	CFI_REL_OFFSET 11, 44
-	CFI_REL_OFFSET 10, 40
-	CFI_REL_OFFSET 9, 36
-	CFI_REL_OFFSET 8, 32
-	preempt_stop()
-ENTRY(ret_from_irq)
-	!
-	mov	#OFF_SR, r0
-	mov.l	@(r0,r15), r0	! get status register
-	shll	r0
-	shll	r0		! kernel space?
-	get_current_thread_info r8, r0
-	bt	resume_kernel	! Yes, it's from kernel, go back soon
-
-#ifdef CONFIG_PREEMPTION
-	bra	resume_userspace
-	 nop
-ENTRY(resume_kernel)
-	cli
-	TRACE_IRQS_OFF
-	mov.l	@(TI_PRE_COUNT,r8), r0	! current_thread_info->preempt_count
-	tst	r0, r0
-	bf	noresched
-need_resched:
-	mov.l	@(TI_FLAGS,r8), r0	! current_thread_info->flags
-	tst	#_TIF_NEED_RESCHED, r0	! need_resched set?
-	bt	noresched
-
-	mov	#OFF_SR, r0
-	mov.l	@(r0,r15), r0		! get status register
-	shlr	r0
-	and	#(0xf0>>1), r0		! interrupts off (exception path)?
-	cmp/eq	#(0xf0>>1), r0
-	bt	noresched
-	mov.l	1f, r0
-	jsr	@r0			! call preempt_schedule_irq
-	 nop
-	bra	need_resched
-	 nop
-
-noresched:
-	bra	__restore_all
-	 nop
-
-	.align 2
-1:	.long	preempt_schedule_irq
-#endif
-
-ENTRY(resume_userspace)
-	! r8: current_thread_info
-	cli
-	TRACE_IRQS_OFF
-	mov.l	@(TI_FLAGS,r8), r0		! current_thread_info->flags
-	tst	#(_TIF_WORK_MASK & 0xff), r0
-	bt/s	__restore_all
-	 tst	#_TIF_NEED_RESCHED, r0
-
-	.align	2
-work_pending:
-	! r0: current_thread_info->flags
-	! r8: current_thread_info
-	! t:  result of "tst	#_TIF_NEED_RESCHED, r0"
-	bf/s	work_resched
-	 tst	#(_TIF_SIGPENDING | _TIF_NOTIFY_RESUME), r0
-work_notifysig:
-	bt/s	__restore_all
-	 mov	r15, r4
-	mov	r12, r5		! set arg1(save_r0)
-	mov	r0, r6
-	sti
-	mov.l	2f, r1
-	mov.l	3f, r0
-	jmp	@r1
-	 lds	r0, pr
-work_resched:
-	mov.l	1f, r1
-	jsr	@r1				! schedule
-	 nop
-	cli
-	TRACE_IRQS_OFF
-	!
-	mov.l	@(TI_FLAGS,r8), r0		! current_thread_info->flags
-	tst	#(_TIF_WORK_MASK & 0xff), r0
-	bt	__restore_all
-	bra	work_pending
-	 tst	#_TIF_NEED_RESCHED, r0
-
-	.align	2
-1:	.long	schedule
-2:	.long	do_notify_resume
-3:	.long	resume_userspace
-
-	.align	2
-syscall_exit_work:
-	! r0: current_thread_info->flags
-	! r8: current_thread_info
-	tst	#(_TIF_WORK_SYSCALL_MASK & 0xff), r0
-	bt/s	work_pending
-	 tst	#_TIF_NEED_RESCHED, r0
-	TRACE_IRQS_ON
-	sti
-	mov	r15, r4
-	mov.l	8f, r0			! do_syscall_trace_leave
-	jsr	@r0
-	 nop
-	bra	resume_userspace
-	 nop
-
-__restore_all:
-	mov	#OFF_SR, r0
-	mov.l	@(r0,r15), r0	! get status register
-
-	shlr2	r0
-	and	#0x3c, r0
-	cmp/eq	#0x3c, r0
-	bt	1f
-	TRACE_IRQS_ON
-	bra	2f
-	 nop
-1:
-	TRACE_IRQS_OFF
-2:
-	mov.l	3f, r0
-	jmp	@r0
-	 nop
-
-	.align	2
-3:	.long	restore_all
-
-	.align	2
-syscall_badsys:			! Bad syscall number
-	get_current_thread_info r8, r0
-	mov	#-ENOSYS, r0
-	bra	resume_userspace
-	 mov.l	r0, @(OFF_R0,r15)	! Return value
-
-/*
- * The main debug trap handler.
- *
- * r8=TRA (not the trap number!)
- *
- * Note: This assumes that the trapa value is left in its original
- * form (without the shlr2 shift) so the calculation for the jump
- * call table offset remains a simple in place mask.
- */
-debug_trap:
-	mov	r8, r0
-	and	#(0xf << 2), r0
-	mov.l	1f, r8
-	add	r0, r8
-	mov.l	@r8, r8
-	jsr	@r8
-	 nop
-	bra	ret_from_exception
-	 nop
-	CFI_ENDPROC
-
-	.align	2
-1:	.long	debug_trap_table
-
-/*
- * Syscall interface:
- *
- *	Syscall #: R3
- *	Arguments #0 to #3: R4--R7
- *	Arguments #4 to #6: R0, R1, R2
- *	TRA: See following table.
- *
- * (TRA>>2)	Purpose
- * --------	-------
- * 0x00-0x0f	original SH-3/4 syscall ABI (not in general use).
- * 0x10-0x1f	general SH-3/4 syscall ABI.
- *      0x1f	unified SH-2/3/4 syscall ABI (preferred).
- * 0x20-0x2f	original SH-2 syscall ABI.
- * 0x30-0x3f	debug traps used by the kernel.
- * 0x40-0xff	Not supported by all parts, so left unhandled.
- *
- * For making system calls, any trap number in the range for the
- * given cpu model may be used, but the unified trap number 0x1f is
- * preferred for compatibility with all models.
- *
- * The low bits of the trap number were once documented as matching
- * the number of arguments, but they were never actually used as such
- * by the kernel. SH-2 originally used its own separate trap range
- * because several hardware exceptions fell in the range used for the
- * SH-3/4 syscall ABI.
- *
- * This code also handles delegating other traps to the BIOS/gdb stub.
- *
- * Note: When we're first called, the TRA value must be shifted
- * right 2 bits in order to get the value that was used as the "trapa"
- * argument.
- */
-
-	.align	2
-	.globl	ret_from_fork
-ret_from_fork:
-	mov.l	1f, r8
-	jsr	@r8
-	 mov	r0, r4
-	bra	syscall_exit
-	 nop
-
-	.align	2
-	.globl	ret_from_kernel_thread
-ret_from_kernel_thread:
-	mov.l	1f, r8
-	jsr	@r8
-	 mov	r0, r4
-	mov.l	@(OFF_R5,r15), r5   ! fn
-	jsr	@r5
-	 mov.l	@(OFF_R4,r15), r4   ! arg
-	bra	syscall_exit
-	 nop
-
-	.align	2
-1:	.long	schedule_tail
-
-/*
- * The poorly named main trapa decode and dispatch routine, for
- * system calls and debug traps through their respective jump tables.
- */
-ENTRY(system_call)
-	setup_frame_reg
-#if !defined(CONFIG_CPU_SH2)
-	mov.l	1f, r9
-	mov.l	@r9, r8		! Read from TRA (Trap Address) Register
-#endif
-
-	mov	#OFF_TRA, r10
-	add	r15, r10
-	mov.l	r8, @r10		! set TRA value to tra
-
-	/*
-	 * Check the trap type
-	 */
-	mov	#((0x20 << 2) - 1), r9
-	cmp/hi	r9, r8
-	bt/s	debug_trap		! it's a debug trap..
-	 nop
-
-	TRACE_IRQS_ON
-	sti
-
-	!
-	get_current_thread_info r8, r10
-	mov.l	@(TI_FLAGS,r8), r8
-	mov	#(_TIF_WORK_SYSCALL_MASK & 0xff), r10
-	mov	#(_TIF_WORK_SYSCALL_MASK >> 8), r9
-	tst	r10, r8
-	shll8	r9
-	bf	syscall_trace_entry
-	tst	r9, r8
-	bf	syscall_trace_entry
-	!
-	mov.l	6f, r8			! Number of syscalls
-	cmp/hs	r8, r3
-	bt	syscall_badsys
-	!
-syscall_call:
-	shll2	r3		! x4
-	mov.l	3f, r8		! Load the address of sys_call_table
-	add	r8, r3
-	mov.l	@r3, r8
-	mov.l	@(OFF_R2,r15), r2
-	mov.l	@(OFF_R1,r15), r1
-	mov.l	@(OFF_R0,r15), r0
-	mov.l	r2, @-r15
-	mov.l	r1, @-r15
-	mov.l	r0, @-r15
-	jsr	@r8	    	! jump to specific syscall handler
-	 nop
-	add	#12, r15
-	mov.l	@(OFF_R0,r15), r12		! save r0
-	mov.l	r0, @(OFF_R0,r15)		! save the return value
-	!
-syscall_exit:
-	cli
-	TRACE_IRQS_OFF
-	!
-	get_current_thread_info r8, r0
-	mov.l	@(TI_FLAGS,r8), r0		! current_thread_info->flags
-	tst	#(_TIF_ALLWORK_MASK & 0xff), r0
-	mov	#(_TIF_ALLWORK_MASK >> 8), r1
-	bf	syscall_exit_work
-	shlr8	r0
-	tst	r0, r1
-	bf	syscall_exit_work
-	bra	__restore_all
-	 nop
-
-	.align	2
-syscall_trace_entry:
-	!                     	Yes it is traced.
-	mov     r15, r4
-	mov.l	7f, r11		! Call do_syscall_trace_enter which notifies
-	jsr	@r11	    	! superior (will chomp R[0-7])
-	 nop
-	cmp/eq	#-1, r0
-	bt	syscall_exit
-	!			Reload R0-R4 from kernel stack, where the
-	!   	    	    	parent may have modified them using
-	!   	    	    	ptrace(POKEUSR).  (Note that R0-R2 are
-	!   	    	    	reloaded from the kernel stack by syscall_call
-	!   	    	    	below, so don't need to be reloaded here.)
-	!   	    	    	This allows the parent to rewrite system calls
-	!   	    	    	and args on the fly.
-	mov.l	@(OFF_R4,r15), r4   ! arg0
-	mov.l	@(OFF_R5,r15), r5
-	mov.l	@(OFF_R6,r15), r6
-	mov.l	@(OFF_R7,r15), r7   ! arg3
-	mov.l	@(OFF_R3,r15), r3   ! syscall_nr
-	!
-	mov.l	6f, r10			! Number of syscalls
-	cmp/hs	r10, r3
-	bf	syscall_call
-	mov	#-ENOSYS, r0
-	bra	syscall_exit
-	 mov.l	r0, @(OFF_R0,r15)	! Return value
-
-	.align	2
-#if !defined(CONFIG_CPU_SH2)
-1:	.long	TRA
-#endif
-6:	.long	NR_syscalls
-3:	.long	sys_call_table
-7:	.long	do_syscall_trace_enter
-8:	.long	do_syscall_trace_leave
diff --git a/arch/sh/kernel/ftrace.c b/arch/sh/kernel/ftrace.c
deleted file mode 100644
index 930001bb8c6a67..00000000000000
--- a/arch/sh/kernel/ftrace.c
+++ /dev/null
@@ -1,365 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (C) 2008 Matt Fleming <matt@console-pimps.org>
- * Copyright (C) 2008 Paul Mundt <lethal@linux-sh.org>
- *
- * Code for replacing ftrace calls with jumps.
- *
- * Copyright (C) 2007-2008 Steven Rostedt <srostedt@redhat.com>
- *
- * Thanks goes to Ingo Molnar, for suggesting the idea.
- * Mathieu Desnoyers, for suggesting postponing the modifications.
- * Arjan van de Ven, for keeping me straight, and explaining to me
- * the dangers of modifying code on the run.
- */
-#include <linux/uaccess.h>
-#include <linux/ftrace.h>
-#include <linux/string.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/kernel.h>
-#include <asm/ftrace.h>
-#include <asm/cacheflush.h>
-#include <asm/unistd.h>
-#include <trace/syscall.h>
-
-#ifdef CONFIG_DYNAMIC_FTRACE
-static unsigned char ftrace_replaced_code[MCOUNT_INSN_SIZE];
-
-static unsigned char ftrace_nop[4];
-/*
- * If we're trying to nop out a call to a function, we instead
- * place a call to the address after the memory table.
- *
- * 8c011060 <a>:
- * 8c011060:       02 d1           mov.l   8c01106c <a+0xc>,r1
- * 8c011062:       22 4f           sts.l   pr,@-r15
- * 8c011064:       02 c7           mova    8c011070 <a+0x10>,r0
- * 8c011066:       2b 41           jmp     @r1
- * 8c011068:       2a 40           lds     r0,pr
- * 8c01106a:       09 00           nop
- * 8c01106c:       68 24           .word 0x2468     <--- ip
- * 8c01106e:       1d 8c           .word 0x8c1d
- * 8c011070:       26 4f           lds.l   @r15+,pr <--- ip + MCOUNT_INSN_SIZE
- *
- * We write 0x8c011070 to 0x8c01106c so that on entry to a() we branch
- * past the _mcount call and continue executing code like normal.
- */
-static unsigned char *ftrace_nop_replace(unsigned long ip)
-{
-	__raw_writel(ip + MCOUNT_INSN_SIZE, ftrace_nop);
-	return ftrace_nop;
-}
-
-static unsigned char *ftrace_call_replace(unsigned long ip, unsigned long addr)
-{
-	/* Place the address in the memory table. */
-	__raw_writel(addr, ftrace_replaced_code);
-
-	/*
-	 * No locking needed, this must be called via kstop_machine
-	 * which in essence is like running on a uniprocessor machine.
-	 */
-	return ftrace_replaced_code;
-}
-
-/*
- * Modifying code must take extra care. On an SMP machine, if
- * the code being modified is also being executed on another CPU
- * that CPU will have undefined results and possibly take a GPF.
- * We use kstop_machine to stop other CPUS from executing code.
- * But this does not stop NMIs from happening. We still need
- * to protect against that. We separate out the modification of
- * the code to take care of this.
- *
- * Two buffers are added: An IP buffer and a "code" buffer.
- *
- * 1) Put the instruction pointer into the IP buffer
- *    and the new code into the "code" buffer.
- * 2) Wait for any running NMIs to finish and set a flag that says
- *    we are modifying code, it is done in an atomic operation.
- * 3) Write the code
- * 4) clear the flag.
- * 5) Wait for any running NMIs to finish.
- *
- * If an NMI is executed, the first thing it does is to call
- * "ftrace_nmi_enter". This will check if the flag is set to write
- * and if it is, it will write what is in the IP and "code" buffers.
- *
- * The trick is, it does not matter if everyone is writing the same
- * content to the code location. Also, if a CPU is executing code
- * it is OK to write to that code location if the contents being written
- * are the same as what exists.
- */
-#define MOD_CODE_WRITE_FLAG (1 << 31)	/* set when NMI should do the write */
-static atomic_t nmi_running = ATOMIC_INIT(0);
-static int mod_code_status;		/* holds return value of text write */
-static void *mod_code_ip;		/* holds the IP to write to */
-static void *mod_code_newcode;		/* holds the text to write to the IP */
-
-static void clear_mod_flag(void)
-{
-	int old = atomic_read(&nmi_running);
-
-	for (;;) {
-		int new = old & ~MOD_CODE_WRITE_FLAG;
-
-		if (old == new)
-			break;
-
-		old = atomic_cmpxchg(&nmi_running, old, new);
-	}
-}
-
-static void ftrace_mod_code(void)
-{
-	/*
-	 * Yes, more than one CPU process can be writing to mod_code_status.
-	 *    (and the code itself)
-	 * But if one were to fail, then they all should, and if one were
-	 * to succeed, then they all should.
-	 */
-	mod_code_status = copy_to_kernel_nofault(mod_code_ip, mod_code_newcode,
-					     MCOUNT_INSN_SIZE);
-
-	/* if we fail, then kill any new writers */
-	if (mod_code_status)
-		clear_mod_flag();
-}
-
-void arch_ftrace_nmi_enter(void)
-{
-	if (atomic_inc_return(&nmi_running) & MOD_CODE_WRITE_FLAG) {
-		smp_rmb();
-		ftrace_mod_code();
-	}
-	/* Must have previous changes seen before executions */
-	smp_mb();
-}
-
-void arch_ftrace_nmi_exit(void)
-{
-	/* Finish all executions before clearing nmi_running */
-	smp_mb();
-	atomic_dec(&nmi_running);
-}
-
-static void wait_for_nmi_and_set_mod_flag(void)
-{
-	if (!atomic_cmpxchg(&nmi_running, 0, MOD_CODE_WRITE_FLAG))
-		return;
-
-	do {
-		cpu_relax();
-	} while (atomic_cmpxchg(&nmi_running, 0, MOD_CODE_WRITE_FLAG));
-}
-
-static void wait_for_nmi(void)
-{
-	if (!atomic_read(&nmi_running))
-		return;
-
-	do {
-		cpu_relax();
-	} while (atomic_read(&nmi_running));
-}
-
-static int
-do_ftrace_mod_code(unsigned long ip, void *new_code)
-{
-	mod_code_ip = (void *)ip;
-	mod_code_newcode = new_code;
-
-	/* The buffers need to be visible before we let NMIs write them */
-	smp_mb();
-
-	wait_for_nmi_and_set_mod_flag();
-
-	/* Make sure all running NMIs have finished before we write the code */
-	smp_mb();
-
-	ftrace_mod_code();
-
-	/* Make sure the write happens before clearing the bit */
-	smp_mb();
-
-	clear_mod_flag();
-	wait_for_nmi();
-
-	return mod_code_status;
-}
-
-static int ftrace_modify_code(unsigned long ip, unsigned char *old_code,
-		       unsigned char *new_code)
-{
-	unsigned char replaced[MCOUNT_INSN_SIZE];
-
-	/*
-	 * Note:
-	 * We are paranoid about modifying text, as if a bug was to happen, it
-	 * could cause us to read or write to someplace that could cause harm.
-	 * Carefully read and modify the code with probe_kernel_*(), and make
-	 * sure what we read is what we expected it to be before modifying it.
-	 */
-
-	/* read the text we want to modify */
-	if (copy_from_kernel_nofault(replaced, (void *)ip, MCOUNT_INSN_SIZE))
-		return -EFAULT;
-
-	/* Make sure it is what we expect it to be */
-	if (memcmp(replaced, old_code, MCOUNT_INSN_SIZE) != 0)
-		return -EINVAL;
-
-	/* replace the text with the new text */
-	if (do_ftrace_mod_code(ip, new_code))
-		return -EPERM;
-
-	flush_icache_range(ip, ip + MCOUNT_INSN_SIZE);
-
-	return 0;
-}
-
-int ftrace_update_ftrace_func(ftrace_func_t func)
-{
-	unsigned long ip = (unsigned long)(&ftrace_call) + MCOUNT_INSN_OFFSET;
-	unsigned char old[MCOUNT_INSN_SIZE], *new;
-
-	memcpy(old, (unsigned char *)ip, MCOUNT_INSN_SIZE);
-	new = ftrace_call_replace(ip, (unsigned long)func);
-
-	return ftrace_modify_code(ip, old, new);
-}
-
-int ftrace_make_nop(struct module *mod,
-		    struct dyn_ftrace *rec, unsigned long addr)
-{
-	unsigned char *new, *old;
-	unsigned long ip = rec->ip;
-
-	old = ftrace_call_replace(ip, addr);
-	new = ftrace_nop_replace(ip);
-
-	return ftrace_modify_code(rec->ip, old, new);
-}
-
-int ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)
-{
-	unsigned char *new, *old;
-	unsigned long ip = rec->ip;
-
-	old = ftrace_nop_replace(ip);
-	new = ftrace_call_replace(ip, addr);
-
-	return ftrace_modify_code(rec->ip, old, new);
-}
-#endif /* CONFIG_DYNAMIC_FTRACE */
-
-#ifdef CONFIG_FUNCTION_GRAPH_TRACER
-#ifdef CONFIG_DYNAMIC_FTRACE
-extern void ftrace_graph_call(void);
-
-static int ftrace_mod(unsigned long ip, unsigned long old_addr,
-		      unsigned long new_addr)
-{
-	unsigned char code[MCOUNT_INSN_SIZE];
-
-	if (copy_from_kernel_nofault(code, (void *)ip, MCOUNT_INSN_SIZE))
-		return -EFAULT;
-
-	if (old_addr != __raw_readl((unsigned long *)code))
-		return -EINVAL;
-
-	__raw_writel(new_addr, ip);
-	return 0;
-}
-
-int ftrace_enable_ftrace_graph_caller(void)
-{
-	unsigned long ip, old_addr, new_addr;
-
-	ip = (unsigned long)(&ftrace_graph_call) + GRAPH_INSN_OFFSET;
-	old_addr = (unsigned long)(&skip_trace);
-	new_addr = (unsigned long)(&ftrace_graph_caller);
-
-	return ftrace_mod(ip, old_addr, new_addr);
-}
-
-int ftrace_disable_ftrace_graph_caller(void)
-{
-	unsigned long ip, old_addr, new_addr;
-
-	ip = (unsigned long)(&ftrace_graph_call) + GRAPH_INSN_OFFSET;
-	old_addr = (unsigned long)(&ftrace_graph_caller);
-	new_addr = (unsigned long)(&skip_trace);
-
-	return ftrace_mod(ip, old_addr, new_addr);
-}
-#endif /* CONFIG_DYNAMIC_FTRACE */
-
-/*
- * Hook the return address and push it in the stack of return addrs
- * in the current thread info.
- *
- * This is the main routine for the function graph tracer. The function
- * graph tracer essentially works like this:
- *
- * parent is the stack address containing self_addr's return address.
- * We pull the real return address out of parent and store it in
- * current's ret_stack. Then, we replace the return address on the stack
- * with the address of return_to_handler. self_addr is the function that
- * called mcount.
- *
- * When self_addr returns, it will jump to return_to_handler which calls
- * ftrace_return_to_handler. ftrace_return_to_handler will pull the real
- * return address off of current's ret_stack and jump to it.
- */
-void prepare_ftrace_return(unsigned long *parent, unsigned long self_addr)
-{
-	unsigned long old;
-	int faulted;
-	unsigned long return_hooker = (unsigned long)&return_to_handler;
-
-	if (unlikely(ftrace_graph_is_dead()))
-		return;
-
-	if (unlikely(atomic_read(&current->tracing_graph_pause)))
-		return;
-
-	/*
-	 * Protect against fault, even if it shouldn't
-	 * happen. This tool is too much intrusive to
-	 * ignore such a protection.
-	 */
-	__asm__ __volatile__(
-		"1:						\n\t"
-		"mov.l		@%2, %0				\n\t"
-		"2:						\n\t"
-		"mov.l		%3, @%2				\n\t"
-		"mov		#0, %1				\n\t"
-		"3:						\n\t"
-		".section .fixup, \"ax\"			\n\t"
-		"4:						\n\t"
-		"mov.l		5f, %0				\n\t"
-		"jmp		@%0				\n\t"
-		" mov		#1, %1				\n\t"
-		".balign 4					\n\t"
-		"5:	.long 3b				\n\t"
-		".previous					\n\t"
-		".section __ex_table,\"a\"			\n\t"
-		".long 1b, 4b					\n\t"
-		".long 2b, 4b					\n\t"
-		".previous					\n\t"
-		: "=&r" (old), "=r" (faulted)
-		: "r" (parent), "r" (return_hooker)
-	);
-
-	if (unlikely(faulted)) {
-		ftrace_graph_stop();
-		WARN_ON(1);
-		return;
-	}
-
-	if (function_graph_enter(old, self_addr, 0, NULL))
-		__raw_writel(old, parent);
-}
-#endif /* CONFIG_FUNCTION_GRAPH_TRACER */
diff --git a/arch/sh/kernel/head_32.S b/arch/sh/kernel/head_32.S
deleted file mode 100644
index 4adbd4ade31946..00000000000000
--- a/arch/sh/kernel/head_32.S
+++ /dev/null
@@ -1,365 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- * $Id: head.S,v 1.7 2003/09/01 17:58:19 lethal Exp $
- *
- *  arch/sh/kernel/head.S
- *
- *  Copyright (C) 1999, 2000  Niibe Yutaka & Kaz Kojima
- *  Copyright (C) 2010  Matt Fleming
- *
- * Head.S contains the SH exception handlers and startup code.
- */
-#include <linux/init.h>
-#include <linux/linkage.h>
-#include <asm/thread_info.h>
-#include <asm/mmu.h>
-#include <cpu/mmu_context.h>
-
-#ifdef CONFIG_CPU_SH4A
-#define SYNCO()		synco
-
-#define PREFI(label, reg)	\
-	mov.l	label, reg;	\
-	prefi	@reg
-#else
-#define SYNCO()
-#define PREFI(label, reg)
-#endif
-
-	.section	.empty_zero_page, "aw"
-ENTRY(empty_zero_page)
-	.long	1		/* MOUNT_ROOT_RDONLY */
-	.long	0		/* RAMDISK_FLAGS */
-	.long	0x0200		/* ORIG_ROOT_DEV */
-	.long	1		/* LOADER_TYPE */
-	.long	0x00000000	/* INITRD_START */
-	.long	0x00000000	/* INITRD_SIZE */
-#ifdef CONFIG_32BIT
-	.long	0x53453f00 + 32	/* "SE?" = 32 bit */
-#else
-	.long	0x53453f00 + 29	/* "SE?" = 29 bit */
-#endif
-1:
-	.skip	PAGE_SIZE - empty_zero_page - 1b
-
-	__HEAD
-
-/*
- * Condition at the entry of _stext:
- *
- *   BSC has already been initialized.
- *   INTC may or may not be initialized.
- *   VBR may or may not be initialized.
- *   MMU may or may not be initialized.
- *   Cache may or may not be initialized.
- *   Hardware (including on-chip modules) may or may not be initialized. 
- *
- */
-ENTRY(_stext)
-	!			Initialize Status Register
-	mov.l	1f, r0		! MD=1, RB=0, BL=0, IMASK=0xF
-	ldc	r0, sr
-	!			Initialize global interrupt mask
-#ifdef CONFIG_CPU_HAS_SR_RB
-	mov	#0, r0
-	ldc	r0, r6_bank
-#endif
-
-#ifdef CONFIG_OF_FLATTREE
-	mov	r4, r12		! Store device tree blob pointer in r12
-#endif
-	
-	/*
-	 * Prefetch if possible to reduce cache miss penalty.
-	 *
-	 * We do this early on for SH-4A as a micro-optimization,
-	 * as later on we will have speculative execution enabled
-	 * and this will become less of an issue.
-	 */
-	PREFI(5f, r0)
-	PREFI(6f, r0)
-
-	!
-	mov.l	2f, r0
-	mov	r0, r15		! Set initial r15 (stack pointer)
-#ifdef CONFIG_CPU_HAS_SR_RB
-	mov.l	7f, r0
-	ldc	r0, r7_bank	! ... and initial thread_info
-#endif
-
-#ifdef CONFIG_PMB
-/*
- * Reconfigure the initial PMB mappings setup by the hardware.
- *
- * When we boot in 32-bit MMU mode there are 2 PMB entries already
- * setup for us.
- *
- * Entry       VPN	   PPN	    V	SZ	C	UB	WT
- * ---------------------------------------------------------------
- *   0	    0x80000000 0x00000000   1  512MB	1	0	1
- *   1	    0xA0000000 0x00000000   1  512MB	0	0	0
- *
- * But we reprogram them here because we want complete control over
- * our address space and the initial mappings may not map PAGE_OFFSET
- * to __MEMORY_START (or even map all of our RAM).
- *
- * Once we've setup cached and uncached mappings we clear the rest of the
- * PMB entries. This clearing also deals with the fact that PMB entries
- * can persist across reboots. The PMB could have been left in any state
- * when the reboot occurred, so to be safe we clear all entries and start
- * with with a clean slate.
- *
- * The uncached mapping is constructed using the smallest possible
- * mapping with a single unbufferable page. Only the kernel text needs to
- * be covered via the uncached mapping so that certain functions can be
- * run uncached.
- *
- * Drivers and the like that have previously abused the 1:1 identity
- * mapping are unsupported in 32-bit mode and must specify their caching
- * preference when page tables are constructed.
- *
- * This frees up the P2 space for more nefarious purposes.
- *
- * Register utilization is as follows:
- *
- *	r0 = PMB_DATA data field
- *	r1 = PMB_DATA address field
- *	r2 = PMB_ADDR data field
- *	r3 = PMB_ADDR address field
- *	r4 = PMB_E_SHIFT
- *	r5 = remaining amount of RAM to map
- *	r6 = PMB mapping size we're trying to use
- *	r7 = cached_to_uncached
- *	r8 = scratch register
- *	r9 = scratch register
- *	r10 = number of PMB entries we've setup
- *	r11 = scratch register
- */
-
-	mov.l	.LMMUCR, r1	/* Flush the TLB */
-	mov.l	@r1, r0
-	or	#MMUCR_TI, r0
-	mov.l	r0, @r1
-
-	mov.l	.LMEMORY_SIZE, r5
-
-	mov	#PMB_E_SHIFT, r0
-	mov	#0x1, r4
-	shld	r0, r4
-
-	mov.l	.LFIRST_DATA_ENTRY, r0
-	mov.l	.LPMB_DATA, r1
-	mov.l	.LFIRST_ADDR_ENTRY, r2
-	mov.l	.LPMB_ADDR, r3
-
-	/*
-	 * First we need to walk the PMB and figure out if there are any
-	 * existing mappings that match the initial mappings VPN/PPN.
-	 * If these have already been established by the bootloader, we
-	 * don't bother setting up new entries here, and let the late PMB
-	 * initialization take care of things instead.
-	 *
-	 * Note that we may need to coalesce and merge entries in order
-	 * to reclaim more available PMB slots, which is much more than
-	 * we want to do at this early stage.
-	 */
-	mov	#0, r10
-	mov	#NR_PMB_ENTRIES, r9
-
-	mov	r1, r7		/* temporary PMB_DATA iter */
-
-.Lvalidate_existing_mappings:
-
-	mov.l	.LPMB_DATA_MASK, r11
-	mov.l	@r7, r8
-	and	r11, r8
-	cmp/eq	r0, r8		/* Check for valid __MEMORY_START mappings */
-	bt	.Lpmb_done
-
-	add	#1, r10		/* Increment the loop counter */
-	cmp/eq	r9, r10
-	bf/s	.Lvalidate_existing_mappings
-	 add	r4, r7		/* Increment to the next PMB_DATA entry */
-
-	/*
-	 * If we've fallen through, continue with setting up the initial
-	 * mappings.
-	 */
-
-	mov	r5, r7		/* cached_to_uncached */
-	mov	#0, r10
-
-#ifdef CONFIG_UNCACHED_MAPPING
-	/*
-	 * Uncached mapping
-	 */
-	mov	#(PMB_SZ_16M >> 2), r9
-	shll2	r9
-
-	mov	#(PMB_UB >> 8), r8
-	shll8	r8
-
-	or	r0, r8
-	or	r9, r8
-	mov.l	r8, @r1
-	mov	r2, r8
-	add	r7, r8
-	mov.l	r8, @r3
-
-	add	r4, r1
-	add	r4, r3
-	add	#1, r10
-#endif
-
-/*
- * Iterate over all of the available sizes from largest to
- * smallest for constructing the cached mapping.
- */
-#define __PMB_ITER_BY_SIZE(size)			\
-.L##size:						\
-	mov	#(size >> 4), r6;			\
-	shll16	r6;					\
-	shll8	r6;					\
-							\
-	cmp/hi	r5, r6;					\
-	bt	9999f;					\
-							\
-	mov	#(PMB_SZ_##size##M >> 2), r9;		\
-	shll2	r9;					\
-							\
-	/*						\
-	 * Cached mapping				\
-	 */						\
-	mov	#PMB_C, r8;				\
-	or	r0, r8;					\
-	or	r9, r8;					\
-	mov.l	r8, @r1;				\
-	mov.l	r2, @r3;				\
-							\
-	/* Increment to the next PMB_DATA entry */	\
-	add	r4, r1;					\
-	/* Increment to the next PMB_ADDR entry */	\
-	add	r4, r3;					\
-	/* Increment number of PMB entries */		\
-	add	#1, r10;				\
-							\
-	sub	r6, r5;					\
-	add	r6, r0;					\
-	add	r6, r2;					\
-							\
-	bra	.L##size;				\
-9999:
-
-	__PMB_ITER_BY_SIZE(512)
-	__PMB_ITER_BY_SIZE(128)
-	__PMB_ITER_BY_SIZE(64)
-	__PMB_ITER_BY_SIZE(16)
-
-#ifdef CONFIG_UNCACHED_MAPPING
-	/*
-	 * Now that we can access it, update cached_to_uncached and
-	 * uncached_size.
-	 */
-	mov.l	.Lcached_to_uncached, r0
-	mov.l	r7, @r0
-
-	mov.l	.Luncached_size, r0
-	mov	#1, r7
-	shll16	r7
-	shll8	r7
-	mov.l	r7, @r0
-#endif
-
-	/*
-	 * Clear the remaining PMB entries.
-	 *
-	 * r3 = entry to begin clearing from
-	 * r10 = number of entries we've setup so far
-	 */
-	mov	#0, r1
-	mov	#NR_PMB_ENTRIES, r0
-
-.Lagain:
-	mov.l	r1, @r3		/* Clear PMB_ADDR entry */
-	add	#1, r10		/* Increment the loop counter */
-	cmp/eq	r0, r10
-	bf/s	.Lagain
-	 add	r4, r3		/* Increment to the next PMB_ADDR entry */
-
-	mov.l	6f, r0
-	icbi	@r0
-
-.Lpmb_done:
-#endif /* CONFIG_PMB */
-
-#ifndef CONFIG_SH_NO_BSS_INIT
-	/*
-	 * Don't clear BSS if running on slow platforms such as an RTL simulation,
-	 * remote memory via SHdebug link, etc.  For these the memory can be guaranteed
-	 * to be all zero on boot anyway.
-	 */
-				! Clear BSS area
-#ifdef CONFIG_SMP	
-	mov.l	3f, r0
-	cmp/eq	#0, r0		! skip clear if set to zero
-	bt	10f
-#endif
-	
-	mov.l	3f, r1
-	add	#4, r1
-	mov.l	4f, r2
-	mov	#0, r0
-9:	cmp/hs	r2, r1
-	bf/s	9b		! while (r1 < r2)
-	 mov.l	r0,@-r2
-
-10:		
-#endif
-
-#ifdef CONFIG_OF_FLATTREE
-	mov.l	8f, r0		! Make flat device tree available early.
-	jsr	@r0
-	 mov	r12, r4
-#endif
-
-	!			Additional CPU initialization
-	mov.l	6f, r0
-	jsr	@r0
-	 nop
-
-	SYNCO()			! Wait for pending instructions..
-	
-	!			Start kernel
-	mov.l	5f, r0
-	jmp	@r0
-	 nop
-
-	.balign 4
-#if defined(CONFIG_CPU_SH2)
-1:	.long	0x000000F0		! IMASK=0xF
-#else
-1:	.long	0x500080F0		! MD=1, RB=0, BL=1, FD=1, IMASK=0xF
-#endif
-ENTRY(stack_start)
-2:	.long	init_thread_union+THREAD_SIZE
-3:	.long	__bss_start
-4:	.long	_end
-5:	.long	start_kernel
-6:	.long	cpu_init
-7:	.long	init_thread_union
-#if defined(CONFIG_OF_FLATTREE)
-8:	.long	sh_fdt_init
-#endif
-
-#ifdef CONFIG_PMB
-.LPMB_ADDR:		.long	PMB_ADDR
-.LPMB_DATA:		.long	PMB_DATA
-.LPMB_DATA_MASK:	.long	PMB_PFN_MASK | PMB_V
-.LFIRST_ADDR_ENTRY:	.long	PAGE_OFFSET | PMB_V
-.LFIRST_DATA_ENTRY:	.long	__MEMORY_START | PMB_V
-.LMMUCR:		.long	MMUCR
-.LMEMORY_SIZE:		.long	__MEMORY_SIZE
-#ifdef CONFIG_UNCACHED_MAPPING
-.Lcached_to_uncached:	.long	cached_to_uncached
-.Luncached_size:	.long	uncached_size
-#endif
-#endif
diff --git a/arch/sh/kernel/hw_breakpoint.c b/arch/sh/kernel/hw_breakpoint.c
deleted file mode 100644
index f10d64311127ba..00000000000000
--- a/arch/sh/kernel/hw_breakpoint.c
+++ /dev/null
@@ -1,408 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/hw_breakpoint.c
- *
- * Unified kernel/user-space hardware breakpoint facility for the on-chip UBC.
- *
- * Copyright (C) 2009 - 2010  Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/perf_event.h>
-#include <linux/sched/signal.h>
-#include <linux/hw_breakpoint.h>
-#include <linux/percpu.h>
-#include <linux/kallsyms.h>
-#include <linux/notifier.h>
-#include <linux/kprobes.h>
-#include <linux/kdebug.h>
-#include <linux/io.h>
-#include <linux/clk.h>
-#include <asm/hw_breakpoint.h>
-#include <asm/mmu_context.h>
-#include <asm/ptrace.h>
-#include <asm/traps.h>
-
-/*
- * Stores the breakpoints currently in use on each breakpoint address
- * register for each cpus
- */
-static DEFINE_PER_CPU(struct perf_event *, bp_per_reg[HBP_NUM]);
-
-/*
- * A dummy placeholder for early accesses until the CPUs get a chance to
- * register their UBCs later in the boot process.
- */
-static struct sh_ubc ubc_dummy = { .num_events = 0 };
-
-static struct sh_ubc *sh_ubc __read_mostly = &ubc_dummy;
-
-/*
- * Install a perf counter breakpoint.
- *
- * We seek a free UBC channel and use it for this breakpoint.
- *
- * Atomic: we hold the counter->ctx->lock and we only handle variables
- * and registers local to this cpu.
- */
-int arch_install_hw_breakpoint(struct perf_event *bp)
-{
-	struct arch_hw_breakpoint *info = counter_arch_bp(bp);
-	int i;
-
-	for (i = 0; i < sh_ubc->num_events; i++) {
-		struct perf_event **slot = this_cpu_ptr(&bp_per_reg[i]);
-
-		if (!*slot) {
-			*slot = bp;
-			break;
-		}
-	}
-
-	if (WARN_ONCE(i == sh_ubc->num_events, "Can't find any breakpoint slot"))
-		return -EBUSY;
-
-	clk_enable(sh_ubc->clk);
-	sh_ubc->enable(info, i);
-
-	return 0;
-}
-
-/*
- * Uninstall the breakpoint contained in the given counter.
- *
- * First we search the debug address register it uses and then we disable
- * it.
- *
- * Atomic: we hold the counter->ctx->lock and we only handle variables
- * and registers local to this cpu.
- */
-void arch_uninstall_hw_breakpoint(struct perf_event *bp)
-{
-	struct arch_hw_breakpoint *info = counter_arch_bp(bp);
-	int i;
-
-	for (i = 0; i < sh_ubc->num_events; i++) {
-		struct perf_event **slot = this_cpu_ptr(&bp_per_reg[i]);
-
-		if (*slot == bp) {
-			*slot = NULL;
-			break;
-		}
-	}
-
-	if (WARN_ONCE(i == sh_ubc->num_events, "Can't find any breakpoint slot"))
-		return;
-
-	sh_ubc->disable(info, i);
-	clk_disable(sh_ubc->clk);
-}
-
-static int get_hbp_len(u16 hbp_len)
-{
-	unsigned int len_in_bytes = 0;
-
-	switch (hbp_len) {
-	case SH_BREAKPOINT_LEN_1:
-		len_in_bytes = 1;
-		break;
-	case SH_BREAKPOINT_LEN_2:
-		len_in_bytes = 2;
-		break;
-	case SH_BREAKPOINT_LEN_4:
-		len_in_bytes = 4;
-		break;
-	case SH_BREAKPOINT_LEN_8:
-		len_in_bytes = 8;
-		break;
-	}
-	return len_in_bytes;
-}
-
-/*
- * Check for virtual address in kernel space.
- */
-int arch_check_bp_in_kernelspace(struct arch_hw_breakpoint *hw)
-{
-	unsigned int len;
-	unsigned long va;
-
-	va = hw->address;
-	len = get_hbp_len(hw->len);
-
-	return (va >= TASK_SIZE) && ((va + len - 1) >= TASK_SIZE);
-}
-
-int arch_bp_generic_fields(int sh_len, int sh_type,
-			   int *gen_len, int *gen_type)
-{
-	/* Len */
-	switch (sh_len) {
-	case SH_BREAKPOINT_LEN_1:
-		*gen_len = HW_BREAKPOINT_LEN_1;
-		break;
-	case SH_BREAKPOINT_LEN_2:
-		*gen_len = HW_BREAKPOINT_LEN_2;
-		break;
-	case SH_BREAKPOINT_LEN_4:
-		*gen_len = HW_BREAKPOINT_LEN_4;
-		break;
-	case SH_BREAKPOINT_LEN_8:
-		*gen_len = HW_BREAKPOINT_LEN_8;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/* Type */
-	switch (sh_type) {
-	case SH_BREAKPOINT_READ:
-		*gen_type = HW_BREAKPOINT_R;
-		break;
-	case SH_BREAKPOINT_WRITE:
-		*gen_type = HW_BREAKPOINT_W;
-		break;
-	case SH_BREAKPOINT_RW:
-		*gen_type = HW_BREAKPOINT_W | HW_BREAKPOINT_R;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int arch_build_bp_info(struct perf_event *bp,
-			      const struct perf_event_attr *attr,
-			      struct arch_hw_breakpoint *hw)
-{
-	hw->address = attr->bp_addr;
-
-	/* Len */
-	switch (attr->bp_len) {
-	case HW_BREAKPOINT_LEN_1:
-		hw->len = SH_BREAKPOINT_LEN_1;
-		break;
-	case HW_BREAKPOINT_LEN_2:
-		hw->len = SH_BREAKPOINT_LEN_2;
-		break;
-	case HW_BREAKPOINT_LEN_4:
-		hw->len = SH_BREAKPOINT_LEN_4;
-		break;
-	case HW_BREAKPOINT_LEN_8:
-		hw->len = SH_BREAKPOINT_LEN_8;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/* Type */
-	switch (attr->bp_type) {
-	case HW_BREAKPOINT_R:
-		hw->type = SH_BREAKPOINT_READ;
-		break;
-	case HW_BREAKPOINT_W:
-		hw->type = SH_BREAKPOINT_WRITE;
-		break;
-	case HW_BREAKPOINT_W | HW_BREAKPOINT_R:
-		hw->type = SH_BREAKPOINT_RW;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-/*
- * Validate the arch-specific HW Breakpoint register settings
- */
-int hw_breakpoint_arch_parse(struct perf_event *bp,
-			     const struct perf_event_attr *attr,
-			     struct arch_hw_breakpoint *hw)
-{
-	unsigned int align;
-	int ret;
-
-	ret = arch_build_bp_info(bp, attr, hw);
-	if (ret)
-		return ret;
-
-	ret = -EINVAL;
-
-	switch (hw->len) {
-	case SH_BREAKPOINT_LEN_1:
-		align = 0;
-		break;
-	case SH_BREAKPOINT_LEN_2:
-		align = 1;
-		break;
-	case SH_BREAKPOINT_LEN_4:
-		align = 3;
-		break;
-	case SH_BREAKPOINT_LEN_8:
-		align = 7;
-		break;
-	default:
-		return ret;
-	}
-
-	/*
-	 * Check that the low-order bits of the address are appropriate
-	 * for the alignment implied by len.
-	 */
-	if (hw->address & align)
-		return -EINVAL;
-
-	return 0;
-}
-
-/*
- * Release the user breakpoints used by ptrace
- */
-void flush_ptrace_hw_breakpoint(struct task_struct *tsk)
-{
-	int i;
-	struct thread_struct *t = &tsk->thread;
-
-	for (i = 0; i < sh_ubc->num_events; i++) {
-		unregister_hw_breakpoint(t->ptrace_bps[i]);
-		t->ptrace_bps[i] = NULL;
-	}
-}
-
-static int __kprobes hw_breakpoint_handler(struct die_args *args)
-{
-	int cpu, i, rc = NOTIFY_STOP;
-	struct perf_event *bp;
-	unsigned int cmf, resume_mask;
-
-	/*
-	 * Do an early return if none of the channels triggered.
-	 */
-	cmf = sh_ubc->triggered_mask();
-	if (unlikely(!cmf))
-		return NOTIFY_DONE;
-
-	/*
-	 * By default, resume all of the active channels.
-	 */
-	resume_mask = sh_ubc->active_mask();
-
-	/*
-	 * Disable breakpoints during exception handling.
-	 */
-	sh_ubc->disable_all();
-
-	cpu = get_cpu();
-	for (i = 0; i < sh_ubc->num_events; i++) {
-		unsigned long event_mask = (1 << i);
-
-		if (likely(!(cmf & event_mask)))
-			continue;
-
-		/*
-		 * The counter may be concurrently released but that can only
-		 * occur from a call_rcu() path. We can then safely fetch
-		 * the breakpoint, use its callback, touch its counter
-		 * while we are in an rcu_read_lock() path.
-		 */
-		rcu_read_lock();
-
-		bp = per_cpu(bp_per_reg[i], cpu);
-		if (bp)
-			rc = NOTIFY_DONE;
-
-		/*
-		 * Reset the condition match flag to denote completion of
-		 * exception handling.
-		 */
-		sh_ubc->clear_triggered_mask(event_mask);
-
-		/*
-		 * bp can be NULL due to concurrent perf counter
-		 * removing.
-		 */
-		if (!bp) {
-			rcu_read_unlock();
-			break;
-		}
-
-		/*
-		 * Don't restore the channel if the breakpoint is from
-		 * ptrace, as it always operates in one-shot mode.
-		 */
-		if (bp->overflow_handler == ptrace_triggered)
-			resume_mask &= ~(1 << i);
-
-		perf_bp_event(bp, args->regs);
-
-		/* Deliver the signal to userspace */
-		if (!arch_check_bp_in_kernelspace(&bp->hw.info)) {
-			force_sig_fault(SIGTRAP, TRAP_HWBKPT,
-					(void __user *)NULL);
-		}
-
-		rcu_read_unlock();
-	}
-
-	if (cmf == 0)
-		rc = NOTIFY_DONE;
-
-	sh_ubc->enable_all(resume_mask);
-
-	put_cpu();
-
-	return rc;
-}
-
-BUILD_TRAP_HANDLER(breakpoint)
-{
-	unsigned long ex = lookup_exception_vector();
-	TRAP_HANDLER_DECL;
-
-	notify_die(DIE_BREAKPOINT, "breakpoint", regs, 0, ex, SIGTRAP);
-}
-
-/*
- * Handle debug exception notifications.
- */
-int __kprobes hw_breakpoint_exceptions_notify(struct notifier_block *unused,
-				    unsigned long val, void *data)
-{
-	struct die_args *args = data;
-
-	if (val != DIE_BREAKPOINT)
-		return NOTIFY_DONE;
-
-	/*
-	 * If the breakpoint hasn't been triggered by the UBC, it's
-	 * probably from a debugger, so don't do anything more here.
-	 *
-	 * This also permits the UBC interface clock to remain off for
-	 * non-UBC breakpoints, as we don't need to check the triggered
-	 * or active channel masks.
-	 */
-	if (args->trapnr != sh_ubc->trap_nr)
-		return NOTIFY_DONE;
-
-	return hw_breakpoint_handler(data);
-}
-
-void hw_breakpoint_pmu_read(struct perf_event *bp)
-{
-	/* TODO */
-}
-
-int register_sh_ubc(struct sh_ubc *ubc)
-{
-	/* Bail if it's already assigned */
-	if (sh_ubc != &ubc_dummy)
-		return -EBUSY;
-	sh_ubc = ubc;
-
-	pr_info("HW Breakpoints: %s UBC support registered\n", ubc->name);
-
-	WARN_ON(ubc->num_events > HBP_NUM);
-
-	return 0;
-}
diff --git a/arch/sh/kernel/idle.c b/arch/sh/kernel/idle.c
deleted file mode 100644
index f59814983bd59f..00000000000000
--- a/arch/sh/kernel/idle.c
+++ /dev/null
@@ -1,57 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * The idle loop for all SuperH platforms.
- *
- *  Copyright (C) 2002 - 2009  Paul Mundt
- */
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/mm.h>
-#include <linux/pm.h>
-#include <linux/tick.h>
-#include <linux/preempt.h>
-#include <linux/thread_info.h>
-#include <linux/irqflags.h>
-#include <linux/smp.h>
-#include <linux/atomic.h>
-#include <asm/smp.h>
-#include <asm/bl_bit.h>
-
-static void (*sh_idle)(void);
-
-void default_idle(void)
-{
-	set_bl_bit();
-	raw_local_irq_enable();
-	/* Isn't this racy ? */
-	cpu_sleep();
-	clear_bl_bit();
-}
-
-void arch_cpu_idle_dead(void)
-{
-	play_dead();
-}
-
-void arch_cpu_idle(void)
-{
-	sh_idle();
-}
-
-void __init select_idle_routine(void)
-{
-	/*
-	 * If a platform has set its own idle routine, leave it alone.
-	 */
-	if (!sh_idle)
-		sh_idle = default_idle;
-}
-
-void stop_this_cpu(void *unused)
-{
-	local_irq_disable();
-	set_cpu_online(smp_processor_id(), false);
-
-	for (;;)
-		cpu_sleep();
-}
diff --git a/arch/sh/kernel/io.c b/arch/sh/kernel/io.c
deleted file mode 100644
index da22f3b32d305e..00000000000000
--- a/arch/sh/kernel/io.c
+++ /dev/null
@@ -1,111 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/io.c - Machine independent I/O functions.
- *
- * Copyright (C) 2000 - 2009  Stuart Menefy
- * Copyright (C) 2005  Paul Mundt
- */
-#include <linux/module.h>
-#include <linux/pci.h>
-#include <asm/machvec.h>
-#include <asm/io.h>
-
-/*
- * Copy data from IO memory space to "real" memory space.
- */
-void memcpy_fromio(void *to, const volatile void __iomem *from, unsigned long count)
-{
-	/*
-	 * Would it be worthwhile doing byte and long transfers first
-	 * to try and get aligned?
-	 */
-#ifdef CONFIG_CPU_SH4
-	if ((count >= 0x20) &&
-	     (((u32)to & 0x1f) == 0) && (((u32)from & 0x3) == 0)) {
-		int tmp2, tmp3, tmp4, tmp5, tmp6;
-
-		__asm__ __volatile__(
-			"1:			\n\t"
-			"mov.l	@%7+, r0	\n\t"
-			"mov.l	@%7+, %2	\n\t"
-			"movca.l r0, @%0	\n\t"
-			"mov.l	@%7+, %3	\n\t"
-			"mov.l	@%7+, %4	\n\t"
-			"mov.l	@%7+, %5	\n\t"
-			"mov.l	@%7+, %6	\n\t"
-			"mov.l	@%7+, r7	\n\t"
-			"mov.l	@%7+, r0	\n\t"
-			"mov.l	%2, @(0x04,%0)	\n\t"
-			"mov	#0x20, %2	\n\t"
-			"mov.l	%3, @(0x08,%0)	\n\t"
-			"sub	%2, %1		\n\t"
-			"mov.l	%4, @(0x0c,%0)	\n\t"
-			"cmp/hi	%1, %2		! T if 32 > count	\n\t"
-			"mov.l	%5, @(0x10,%0)	\n\t"
-			"mov.l	%6, @(0x14,%0)	\n\t"
-			"mov.l	r7, @(0x18,%0)	\n\t"
-			"mov.l	r0, @(0x1c,%0)	\n\t"
-			"bf.s	1b		\n\t"
-			" add	#0x20, %0	\n\t"
-			: "=&r" (to), "=&r" (count),
-			  "=&r" (tmp2), "=&r" (tmp3), "=&r" (tmp4),
-			  "=&r" (tmp5), "=&r" (tmp6), "=&r" (from)
-			: "7"(from), "0" (to), "1" (count)
-			: "r0", "r7", "t", "memory");
-	}
-#endif
-
-	if ((((u32)to | (u32)from) & 0x3) == 0) {
-		for (; count > 3; count -= 4) {
-			*(u32 *)to = *(volatile u32 *)from;
-			to += 4;
-			from += 4;
-		}
-	}
-
-	for (; count > 0; count--) {
-		*(u8 *)to = *(volatile u8 *)from;
-		to++;
-		from++;
-	}
-
-	mb();
-}
-EXPORT_SYMBOL(memcpy_fromio);
-
-/*
- * Copy data from "real" memory space to IO memory space.
- */
-void memcpy_toio(volatile void __iomem *to, const void *from, unsigned long count)
-{
-	if ((((u32)to | (u32)from) & 0x3) == 0) {
-		for ( ; count > 3; count -= 4) {
-			*(volatile u32 *)to = *(u32 *)from;
-			to += 4;
-			from += 4;
-		}
-	}
-
-	for (; count > 0; count--) {
-		*(volatile u8 *)to = *(u8 *)from;
-		to++;
-		from++;
-	}
-
-	mb();
-}
-EXPORT_SYMBOL(memcpy_toio);
-
-/*
- * "memset" on IO memory space.
- * This needs to be optimized.
- */
-void memset_io(volatile void __iomem *dst, int c, unsigned long count)
-{
-        while (count) {
-                count--;
-                writeb(c, dst);
-                dst++;
-        }
-}
-EXPORT_SYMBOL(memset_io);
diff --git a/arch/sh/kernel/io_trapped.c b/arch/sh/kernel/io_trapped.c
deleted file mode 100644
index e803b14ef12eac..00000000000000
--- a/arch/sh/kernel/io_trapped.c
+++ /dev/null
@@ -1,291 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Trapped io support
- *
- * Copyright (C) 2008 Magnus Damm
- *
- * Intercept io operations by trapping.
- */
-#include <linux/kernel.h>
-#include <linux/mm.h>
-#include <linux/bitops.h>
-#include <linux/vmalloc.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <asm/mmu_context.h>
-#include <linux/uaccess.h>
-#include <asm/io.h>
-#include <asm/io_trapped.h>
-
-#define TRAPPED_PAGES_MAX 16
-
-#ifdef CONFIG_HAS_IOPORT_MAP
-LIST_HEAD(trapped_io);
-EXPORT_SYMBOL_GPL(trapped_io);
-#endif
-#ifdef CONFIG_HAS_IOMEM
-LIST_HEAD(trapped_mem);
-EXPORT_SYMBOL_GPL(trapped_mem);
-#endif
-static DEFINE_SPINLOCK(trapped_lock);
-
-static int trapped_io_disable __read_mostly;
-
-static int __init trapped_io_setup(char *__unused)
-{
-	trapped_io_disable = 1;
-	return 1;
-}
-__setup("noiotrap", trapped_io_setup);
-
-int register_trapped_io(struct trapped_io *tiop)
-{
-	struct resource *res;
-	unsigned long len = 0, flags = 0;
-	struct page *pages[TRAPPED_PAGES_MAX];
-	int k, n;
-
-	if (unlikely(trapped_io_disable))
-		return 0;
-
-	/* structure must be page aligned */
-	if ((unsigned long)tiop & (PAGE_SIZE - 1))
-		goto bad;
-
-	for (k = 0; k < tiop->num_resources; k++) {
-		res = tiop->resource + k;
-		len += roundup(resource_size(res), PAGE_SIZE);
-		flags |= res->flags;
-	}
-
-	/* support IORESOURCE_IO _or_ MEM, not both */
-	if (hweight_long(flags) != 1)
-		goto bad;
-
-	n = len >> PAGE_SHIFT;
-
-	if (n >= TRAPPED_PAGES_MAX)
-		goto bad;
-
-	for (k = 0; k < n; k++)
-		pages[k] = virt_to_page(tiop);
-
-	tiop->virt_base = vmap(pages, n, VM_MAP, PAGE_NONE);
-	if (!tiop->virt_base)
-		goto bad;
-
-	len = 0;
-	for (k = 0; k < tiop->num_resources; k++) {
-		res = tiop->resource + k;
-		pr_info("trapped io 0x%08lx overrides %s 0x%08lx\n",
-		       (unsigned long)(tiop->virt_base + len),
-		       res->flags & IORESOURCE_IO ? "io" : "mmio",
-		       (unsigned long)res->start);
-		len += roundup(resource_size(res), PAGE_SIZE);
-	}
-
-	tiop->magic = IO_TRAPPED_MAGIC;
-	INIT_LIST_HEAD(&tiop->list);
-	spin_lock_irq(&trapped_lock);
-#ifdef CONFIG_HAS_IOPORT_MAP
-	if (flags & IORESOURCE_IO)
-		list_add(&tiop->list, &trapped_io);
-#endif
-#ifdef CONFIG_HAS_IOMEM
-	if (flags & IORESOURCE_MEM)
-		list_add(&tiop->list, &trapped_mem);
-#endif
-	spin_unlock_irq(&trapped_lock);
-
-	return 0;
- bad:
-	pr_warn("unable to install trapped io filter\n");
-	return -1;
-}
-
-void __iomem *match_trapped_io_handler(struct list_head *list,
-				       unsigned long offset,
-				       unsigned long size)
-{
-	unsigned long voffs;
-	struct trapped_io *tiop;
-	struct resource *res;
-	int k, len;
-	unsigned long flags;
-
-	spin_lock_irqsave(&trapped_lock, flags);
-	list_for_each_entry(tiop, list, list) {
-		voffs = 0;
-		for (k = 0; k < tiop->num_resources; k++) {
-			res = tiop->resource + k;
-			if (res->start == offset) {
-				spin_unlock_irqrestore(&trapped_lock, flags);
-				return tiop->virt_base + voffs;
-			}
-
-			len = resource_size(res);
-			voffs += roundup(len, PAGE_SIZE);
-		}
-	}
-	spin_unlock_irqrestore(&trapped_lock, flags);
-	return NULL;
-}
-
-static struct trapped_io *lookup_tiop(unsigned long address)
-{
-	pgd_t *pgd_k;
-	p4d_t *p4d_k;
-	pud_t *pud_k;
-	pmd_t *pmd_k;
-	pte_t *pte_k;
-	pte_t entry;
-
-	pgd_k = swapper_pg_dir + pgd_index(address);
-	if (!pgd_present(*pgd_k))
-		return NULL;
-
-	p4d_k = p4d_offset(pgd_k, address);
-	if (!p4d_present(*p4d_k))
-		return NULL;
-
-	pud_k = pud_offset(p4d_k, address);
-	if (!pud_present(*pud_k))
-		return NULL;
-
-	pmd_k = pmd_offset(pud_k, address);
-	if (!pmd_present(*pmd_k))
-		return NULL;
-
-	pte_k = pte_offset_kernel(pmd_k, address);
-	entry = *pte_k;
-
-	return pfn_to_kaddr(pte_pfn(entry));
-}
-
-static unsigned long lookup_address(struct trapped_io *tiop,
-				    unsigned long address)
-{
-	struct resource *res;
-	unsigned long vaddr = (unsigned long)tiop->virt_base;
-	unsigned long len;
-	int k;
-
-	for (k = 0; k < tiop->num_resources; k++) {
-		res = tiop->resource + k;
-		len = roundup(resource_size(res), PAGE_SIZE);
-		if (address < (vaddr + len))
-			return res->start + (address - vaddr);
-		vaddr += len;
-	}
-	return 0;
-}
-
-static unsigned long long copy_word(unsigned long src_addr, int src_len,
-				    unsigned long dst_addr, int dst_len)
-{
-	unsigned long long tmp = 0;
-
-	switch (src_len) {
-	case 1:
-		tmp = __raw_readb(src_addr);
-		break;
-	case 2:
-		tmp = __raw_readw(src_addr);
-		break;
-	case 4:
-		tmp = __raw_readl(src_addr);
-		break;
-	case 8:
-		tmp = __raw_readq(src_addr);
-		break;
-	}
-
-	switch (dst_len) {
-	case 1:
-		__raw_writeb(tmp, dst_addr);
-		break;
-	case 2:
-		__raw_writew(tmp, dst_addr);
-		break;
-	case 4:
-		__raw_writel(tmp, dst_addr);
-		break;
-	case 8:
-		__raw_writeq(tmp, dst_addr);
-		break;
-	}
-
-	return tmp;
-}
-
-static unsigned long from_device(void *dst, const void *src, unsigned long cnt)
-{
-	struct trapped_io *tiop;
-	unsigned long src_addr = (unsigned long)src;
-	unsigned long long tmp;
-
-	pr_debug("trapped io read 0x%08lx (%ld)\n", src_addr, cnt);
-	tiop = lookup_tiop(src_addr);
-	WARN_ON(!tiop || (tiop->magic != IO_TRAPPED_MAGIC));
-
-	src_addr = lookup_address(tiop, src_addr);
-	if (!src_addr)
-		return cnt;
-
-	tmp = copy_word(src_addr,
-			max_t(unsigned long, cnt,
-			      (tiop->minimum_bus_width / 8)),
-			(unsigned long)dst, cnt);
-
-	pr_debug("trapped io read 0x%08lx -> 0x%08llx\n", src_addr, tmp);
-	return 0;
-}
-
-static unsigned long to_device(void *dst, const void *src, unsigned long cnt)
-{
-	struct trapped_io *tiop;
-	unsigned long dst_addr = (unsigned long)dst;
-	unsigned long long tmp;
-
-	pr_debug("trapped io write 0x%08lx (%ld)\n", dst_addr, cnt);
-	tiop = lookup_tiop(dst_addr);
-	WARN_ON(!tiop || (tiop->magic != IO_TRAPPED_MAGIC));
-
-	dst_addr = lookup_address(tiop, dst_addr);
-	if (!dst_addr)
-		return cnt;
-
-	tmp = copy_word((unsigned long)src, cnt,
-			dst_addr, max_t(unsigned long, cnt,
-					(tiop->minimum_bus_width / 8)));
-
-	pr_debug("trapped io write 0x%08lx -> 0x%08llx\n", dst_addr, tmp);
-	return 0;
-}
-
-static struct mem_access trapped_io_access = {
-	from_device,
-	to_device,
-};
-
-int handle_trapped_io(struct pt_regs *regs, unsigned long address)
-{
-	insn_size_t instruction;
-	int tmp;
-
-	if (trapped_io_disable)
-		return 0;
-	if (!lookup_tiop(address))
-		return 0;
-
-	WARN_ON(user_mode(regs));
-
-	if (copy_from_kernel_nofault(&instruction, (void *)(regs->pc),
-				     sizeof(instruction))) {
-		return 0;
-	}
-
-	tmp = handle_unaligned_access(instruction, regs,
-				      &trapped_io_access, 1, address);
-	return tmp == 0;
-}
diff --git a/arch/sh/kernel/iomap.c b/arch/sh/kernel/iomap.c
deleted file mode 100644
index 0a0dff4e66dea4..00000000000000
--- a/arch/sh/kernel/iomap.c
+++ /dev/null
@@ -1,162 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/iomap.c
- *
- * Copyright (C) 2000  Niibe Yutaka
- * Copyright (C) 2005 - 2007 Paul Mundt
- */
-#include <linux/module.h>
-#include <linux/io.h>
-
-unsigned int ioread8(const void __iomem *addr)
-{
-	return readb(addr);
-}
-EXPORT_SYMBOL(ioread8);
-
-unsigned int ioread16(const void __iomem *addr)
-{
-	return readw(addr);
-}
-EXPORT_SYMBOL(ioread16);
-
-unsigned int ioread16be(const void __iomem *addr)
-{
-	return be16_to_cpu(__raw_readw(addr));
-}
-EXPORT_SYMBOL(ioread16be);
-
-unsigned int ioread32(const void __iomem *addr)
-{
-	return readl(addr);
-}
-EXPORT_SYMBOL(ioread32);
-
-unsigned int ioread32be(const void __iomem *addr)
-{
-	return be32_to_cpu(__raw_readl(addr));
-}
-EXPORT_SYMBOL(ioread32be);
-
-void iowrite8(u8 val, void __iomem *addr)
-{
-	writeb(val, addr);
-}
-EXPORT_SYMBOL(iowrite8);
-
-void iowrite16(u16 val, void __iomem *addr)
-{
-	writew(val, addr);
-}
-EXPORT_SYMBOL(iowrite16);
-
-void iowrite16be(u16 val, void __iomem *addr)
-{
-	__raw_writew(cpu_to_be16(val), addr);
-}
-EXPORT_SYMBOL(iowrite16be);
-
-void iowrite32(u32 val, void __iomem *addr)
-{
-	writel(val, addr);
-}
-EXPORT_SYMBOL(iowrite32);
-
-void iowrite32be(u32 val, void __iomem *addr)
-{
-	__raw_writel(cpu_to_be32(val), addr);
-}
-EXPORT_SYMBOL(iowrite32be);
-
-/*
- * These are the "repeat MMIO read/write" functions.
- * Note the "__raw" accesses, since we don't want to
- * convert to CPU byte order. We write in "IO byte
- * order" (we also don't have IO barriers).
- */
-static inline void mmio_insb(const void __iomem *addr, u8 *dst, int count)
-{
-	while (--count >= 0) {
-		u8 data = __raw_readb(addr);
-		*dst = data;
-		dst++;
-	}
-}
-
-static inline void mmio_insw(const void __iomem *addr, u16 *dst, int count)
-{
-	while (--count >= 0) {
-		u16 data = __raw_readw(addr);
-		*dst = data;
-		dst++;
-	}
-}
-
-static inline void mmio_insl(const void __iomem *addr, u32 *dst, int count)
-{
-	while (--count >= 0) {
-		u32 data = __raw_readl(addr);
-		*dst = data;
-		dst++;
-	}
-}
-
-static inline void mmio_outsb(void __iomem *addr, const u8 *src, int count)
-{
-	while (--count >= 0) {
-		__raw_writeb(*src, addr);
-		src++;
-	}
-}
-
-static inline void mmio_outsw(void __iomem *addr, const u16 *src, int count)
-{
-	while (--count >= 0) {
-		__raw_writew(*src, addr);
-		src++;
-	}
-}
-
-static inline void mmio_outsl(void __iomem *addr, const u32 *src, int count)
-{
-	while (--count >= 0) {
-		__raw_writel(*src, addr);
-		src++;
-	}
-}
-
-void ioread8_rep(const void __iomem *addr, void *dst, unsigned long count)
-{
-	mmio_insb(addr, dst, count);
-}
-EXPORT_SYMBOL(ioread8_rep);
-
-void ioread16_rep(const void __iomem *addr, void *dst, unsigned long count)
-{
-	mmio_insw(addr, dst, count);
-}
-EXPORT_SYMBOL(ioread16_rep);
-
-void ioread32_rep(const void __iomem *addr, void *dst, unsigned long count)
-{
-	mmio_insl(addr, dst, count);
-}
-EXPORT_SYMBOL(ioread32_rep);
-
-void iowrite8_rep(void __iomem *addr, const void *src, unsigned long count)
-{
-	mmio_outsb(addr, src, count);
-}
-EXPORT_SYMBOL(iowrite8_rep);
-
-void iowrite16_rep(void __iomem *addr, const void *src, unsigned long count)
-{
-	mmio_outsw(addr, src, count);
-}
-EXPORT_SYMBOL(iowrite16_rep);
-
-void iowrite32_rep(void __iomem *addr, const void *src, unsigned long count)
-{
-	mmio_outsl(addr, src, count);
-}
-EXPORT_SYMBOL(iowrite32_rep);
diff --git a/arch/sh/kernel/ioport.c b/arch/sh/kernel/ioport.c
deleted file mode 100644
index f39446a658bdb8..00000000000000
--- a/arch/sh/kernel/ioport.c
+++ /dev/null
@@ -1,41 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/ioport.c
- *
- * Copyright (C) 2000  Niibe Yutaka
- * Copyright (C) 2005 - 2007 Paul Mundt
- */
-#include <linux/module.h>
-#include <linux/io.h>
-#include <asm/io_trapped.h>
-
-unsigned long sh_io_port_base __read_mostly = -1;
-EXPORT_SYMBOL(sh_io_port_base);
-
-void __iomem *__ioport_map(unsigned long addr, unsigned int size)
-{
-	if (sh_mv.mv_ioport_map)
-		return sh_mv.mv_ioport_map(addr, size);
-
-	return (void __iomem *)(addr + sh_io_port_base);
-}
-EXPORT_SYMBOL(__ioport_map);
-
-void __iomem *ioport_map(unsigned long port, unsigned int nr)
-{
-	void __iomem *ret;
-
-	ret = __ioport_map_trapped(port, nr);
-	if (ret)
-		return ret;
-
-	return __ioport_map(port, nr);
-}
-EXPORT_SYMBOL(ioport_map);
-
-void ioport_unmap(void __iomem *addr)
-{
-	if (sh_mv.mv_ioport_unmap)
-		sh_mv.mv_ioport_unmap(addr);
-}
-EXPORT_SYMBOL(ioport_unmap);
diff --git a/arch/sh/kernel/irq.c b/arch/sh/kernel/irq.c
deleted file mode 100644
index 4e6835de54cf8e..00000000000000
--- a/arch/sh/kernel/irq.c
+++ /dev/null
@@ -1,249 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/kernel/irq.c
- *
- *	Copyright (C) 1992, 1998 Linus Torvalds, Ingo Molnar
- *
- *
- * SuperH version:  Copyright (C) 1999  Niibe Yutaka
- */
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/kernel_stat.h>
-#include <linux/seq_file.h>
-#include <linux/ftrace.h>
-#include <linux/delay.h>
-#include <linux/ratelimit.h>
-#include <asm/processor.h>
-#include <asm/machvec.h>
-#include <linux/uaccess.h>
-#include <asm/thread_info.h>
-#include <cpu/mmu_context.h>
-#include <asm/softirq_stack.h>
-
-atomic_t irq_err_count;
-
-/*
- * 'what should we do if we get a hw irq event on an illegal vector'.
- * each architecture has to answer this themselves, it doesn't deserve
- * a generic callback i think.
- */
-void ack_bad_irq(unsigned int irq)
-{
-	atomic_inc(&irq_err_count);
-	printk("unexpected IRQ trap at vector %02x\n", irq);
-}
-
-#if defined(CONFIG_PROC_FS)
-/*
- * /proc/interrupts printing for arch specific interrupts
- */
-int arch_show_interrupts(struct seq_file *p, int prec)
-{
-	int j;
-
-	seq_printf(p, "%*s: ", prec, "NMI");
-	for_each_online_cpu(j)
-		seq_printf(p, "%10u ", per_cpu(irq_stat.__nmi_count, j));
-	seq_printf(p, "  Non-maskable interrupts\n");
-
-	seq_printf(p, "%*s: %10u\n", prec, "ERR", atomic_read(&irq_err_count));
-
-	return 0;
-}
-#endif
-
-#ifdef CONFIG_IRQSTACKS
-/*
- * per-CPU IRQ handling contexts (thread information and stack)
- */
-union irq_ctx {
-	struct thread_info	tinfo;
-	u32			stack[THREAD_SIZE/sizeof(u32)];
-};
-
-static union irq_ctx *hardirq_ctx[NR_CPUS] __read_mostly;
-static union irq_ctx *softirq_ctx[NR_CPUS] __read_mostly;
-
-static char softirq_stack[NR_CPUS * THREAD_SIZE] __page_aligned_bss;
-static char hardirq_stack[NR_CPUS * THREAD_SIZE] __page_aligned_bss;
-
-static inline void handle_one_irq(unsigned int irq)
-{
-	union irq_ctx *curctx, *irqctx;
-
-	curctx = (union irq_ctx *)current_thread_info();
-	irqctx = hardirq_ctx[smp_processor_id()];
-
-	/*
-	 * this is where we switch to the IRQ stack. However, if we are
-	 * already using the IRQ stack (because we interrupted a hardirq
-	 * handler) we can't do that and just have to keep using the
-	 * current stack (which is the irq stack already after all)
-	 */
-	if (curctx != irqctx) {
-		u32 *isp;
-
-		isp = (u32 *)((char *)irqctx + sizeof(*irqctx));
-		irqctx->tinfo.task = curctx->tinfo.task;
-		irqctx->tinfo.previous_sp = current_stack_pointer;
-
-		/*
-		 * Copy the softirq bits in preempt_count so that the
-		 * softirq checks work in the hardirq context.
-		 */
-		irqctx->tinfo.preempt_count =
-			(irqctx->tinfo.preempt_count & ~SOFTIRQ_MASK) |
-			(curctx->tinfo.preempt_count & SOFTIRQ_MASK);
-
-		__asm__ __volatile__ (
-			"mov	%0, r4		\n"
-			"mov	r15, r8		\n"
-			"jsr	@%1		\n"
-			/* switch to the irq stack */
-			" mov	%2, r15		\n"
-			/* restore the stack (ring zero) */
-			"mov	r8, r15		\n"
-			: /* no outputs */
-			: "r" (irq), "r" (generic_handle_irq), "r" (isp)
-			: "memory", "r0", "r1", "r2", "r3", "r4",
-			  "r5", "r6", "r7", "r8", "t", "pr"
-		);
-	} else
-		generic_handle_irq(irq);
-}
-
-/*
- * allocate per-cpu stacks for hardirq and for softirq processing
- */
-void irq_ctx_init(int cpu)
-{
-	union irq_ctx *irqctx;
-
-	if (hardirq_ctx[cpu])
-		return;
-
-	irqctx = (union irq_ctx *)&hardirq_stack[cpu * THREAD_SIZE];
-	irqctx->tinfo.task		= NULL;
-	irqctx->tinfo.cpu		= cpu;
-	irqctx->tinfo.preempt_count	= HARDIRQ_OFFSET;
-	irqctx->tinfo.addr_limit	= MAKE_MM_SEG(0);
-
-	hardirq_ctx[cpu] = irqctx;
-
-	irqctx = (union irq_ctx *)&softirq_stack[cpu * THREAD_SIZE];
-	irqctx->tinfo.task		= NULL;
-	irqctx->tinfo.cpu		= cpu;
-	irqctx->tinfo.preempt_count	= 0;
-	irqctx->tinfo.addr_limit	= MAKE_MM_SEG(0);
-
-	softirq_ctx[cpu] = irqctx;
-
-	printk("CPU %u irqstacks, hard=%p soft=%p\n",
-		cpu, hardirq_ctx[cpu], softirq_ctx[cpu]);
-}
-
-void irq_ctx_exit(int cpu)
-{
-	hardirq_ctx[cpu] = NULL;
-}
-
-#ifdef CONFIG_SOFTIRQ_ON_OWN_STACK
-void do_softirq_own_stack(void)
-{
-	struct thread_info *curctx;
-	union irq_ctx *irqctx;
-	u32 *isp;
-
-	curctx = current_thread_info();
-	irqctx = softirq_ctx[smp_processor_id()];
-	irqctx->tinfo.task = curctx->task;
-	irqctx->tinfo.previous_sp = current_stack_pointer;
-
-	/* build the stack frame on the softirq stack */
-	isp = (u32 *)((char *)irqctx + sizeof(*irqctx));
-
-	__asm__ __volatile__ (
-		"mov	r15, r9		\n"
-		"jsr	@%0		\n"
-		/* switch to the softirq stack */
-		" mov	%1, r15		\n"
-		/* restore the thread stack */
-		"mov	r9, r15		\n"
-		: /* no outputs */
-		: "r" (__do_softirq), "r" (isp)
-		: "memory", "r0", "r1", "r2", "r3", "r4",
-		  "r5", "r6", "r7", "r8", "r9", "r15", "t", "pr"
-	);
-}
-#endif
-#else
-static inline void handle_one_irq(unsigned int irq)
-{
-	generic_handle_irq(irq);
-}
-#endif
-
-asmlinkage __irq_entry int do_IRQ(unsigned int irq, struct pt_regs *regs)
-{
-	struct pt_regs *old_regs = set_irq_regs(regs);
-
-	irq_enter();
-
-	irq = irq_demux(irq_lookup(irq));
-
-	if (irq != NO_IRQ_IGNORE) {
-		handle_one_irq(irq);
-		irq_finish(irq);
-	}
-
-	irq_exit();
-
-	set_irq_regs(old_regs);
-
-	return IRQ_HANDLED;
-}
-
-void __init init_IRQ(void)
-{
-	plat_irq_setup();
-
-	/* Perform the machine specific initialisation */
-	if (sh_mv.mv_init_irq)
-		sh_mv.mv_init_irq();
-
-	intc_finalize();
-
-	irq_ctx_init(smp_processor_id());
-}
-
-#ifdef CONFIG_HOTPLUG_CPU
-/*
- * The CPU has been marked offline.  Migrate IRQs off this CPU.  If
- * the affinity settings do not allow other CPUs, force them onto any
- * available CPU.
- */
-void migrate_irqs(void)
-{
-	unsigned int irq, cpu = smp_processor_id();
-
-	for_each_active_irq(irq) {
-		struct irq_data *data = irq_get_irq_data(irq);
-
-		if (irq_data_get_node(data) == cpu) {
-			const struct cpumask *mask = irq_data_get_affinity_mask(data);
-			unsigned int newcpu = cpumask_any_and(mask,
-							      cpu_online_mask);
-			if (newcpu >= nr_cpu_ids) {
-				pr_info_ratelimited("IRQ%u no longer affine to CPU%u\n",
-						    irq, cpu);
-
-				irq_set_affinity(irq, cpu_all_mask);
-			} else {
-				irq_set_affinity(irq, mask);
-			}
-		}
-	}
-}
-#endif
diff --git a/arch/sh/kernel/irq_32.c b/arch/sh/kernel/irq_32.c
deleted file mode 100644
index e09cdc4ada68c8..00000000000000
--- a/arch/sh/kernel/irq_32.c
+++ /dev/null
@@ -1,54 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SHcompact irqflags support
- *
- * Copyright (C) 2006 - 2009 Paul Mundt
- */
-#include <linux/irqflags.h>
-#include <linux/module.h>
-
-void notrace arch_local_irq_restore(unsigned long flags)
-{
-	unsigned long __dummy0, __dummy1;
-
-	if (flags == ARCH_IRQ_DISABLED) {
-		__asm__ __volatile__ (
-			"stc	sr, %0\n\t"
-			"or	#0xf0, %0\n\t"
-			"ldc	%0, sr\n\t"
-			: "=&z" (__dummy0)
-			: /* no inputs */
-			: "memory"
-		);
-	} else {
-		__asm__ __volatile__ (
-			"stc	sr, %0\n\t"
-			"and	%1, %0\n\t"
-#ifdef CONFIG_CPU_HAS_SR_RB
-			"stc	r6_bank, %1\n\t"
-			"or	%1, %0\n\t"
-#endif
-			"ldc	%0, sr\n\t"
-			: "=&r" (__dummy0), "=r" (__dummy1)
-			: "1" (~ARCH_IRQ_DISABLED)
-			: "memory"
-		);
-	}
-}
-EXPORT_SYMBOL(arch_local_irq_restore);
-
-unsigned long notrace arch_local_save_flags(void)
-{
-	unsigned long flags;
-
-	__asm__ __volatile__ (
-		"stc	sr, %0\n\t"
-		"and	#0xf0, %0\n\t"
-		: "=&z" (flags)
-		: /* no inputs */
-		: "memory"
-	);
-
-	return flags;
-}
-EXPORT_SYMBOL(arch_local_save_flags);
diff --git a/arch/sh/kernel/kdebugfs.c b/arch/sh/kernel/kdebugfs.c
deleted file mode 100644
index 8b505e1556a5f8..00000000000000
--- a/arch/sh/kernel/kdebugfs.c
+++ /dev/null
@@ -1,14 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/debugfs.h>
-
-struct dentry *arch_debugfs_dir;
-EXPORT_SYMBOL(arch_debugfs_dir);
-
-static int __init arch_kdebugfs_init(void)
-{
-	arch_debugfs_dir = debugfs_create_dir("sh", NULL);
-	return 0;
-}
-arch_initcall(arch_kdebugfs_init);
diff --git a/arch/sh/kernel/kgdb.c b/arch/sh/kernel/kgdb.c
deleted file mode 100644
index e4147efa9ec6da..00000000000000
--- a/arch/sh/kernel/kgdb.c
+++ /dev/null
@@ -1,378 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SuperH KGDB support
- *
- * Copyright (C) 2008 - 2012  Paul Mundt
- *
- * Single stepping taken from the old stub by Henry Bell and Jeremy Siegel.
- */
-#include <linux/kgdb.h>
-#include <linux/kdebug.h>
-#include <linux/irq.h>
-#include <linux/io.h>
-#include <linux/sched.h>
-#include <linux/sched/task_stack.h>
-
-#include <asm/cacheflush.h>
-#include <asm/traps.h>
-
-/* Macros for single step instruction identification */
-#define OPCODE_BT(op)		(((op) & 0xff00) == 0x8900)
-#define OPCODE_BF(op)		(((op) & 0xff00) == 0x8b00)
-#define OPCODE_BTF_DISP(op)	(((op) & 0x80) ? (((op) | 0xffffff80) << 1) : \
-				 (((op) & 0x7f ) << 1))
-#define OPCODE_BFS(op)		(((op) & 0xff00) == 0x8f00)
-#define OPCODE_BTS(op)		(((op) & 0xff00) == 0x8d00)
-#define OPCODE_BRA(op)		(((op) & 0xf000) == 0xa000)
-#define OPCODE_BRA_DISP(op)	(((op) & 0x800) ? (((op) | 0xfffff800) << 1) : \
-				 (((op) & 0x7ff) << 1))
-#define OPCODE_BRAF(op)		(((op) & 0xf0ff) == 0x0023)
-#define OPCODE_BRAF_REG(op)	(((op) & 0x0f00) >> 8)
-#define OPCODE_BSR(op)		(((op) & 0xf000) == 0xb000)
-#define OPCODE_BSR_DISP(op)	(((op) & 0x800) ? (((op) | 0xfffff800) << 1) : \
-				 (((op) & 0x7ff) << 1))
-#define OPCODE_BSRF(op)		(((op) & 0xf0ff) == 0x0003)
-#define OPCODE_BSRF_REG(op)	(((op) >> 8) & 0xf)
-#define OPCODE_JMP(op)		(((op) & 0xf0ff) == 0x402b)
-#define OPCODE_JMP_REG(op)	(((op) >> 8) & 0xf)
-#define OPCODE_JSR(op)		(((op) & 0xf0ff) == 0x400b)
-#define OPCODE_JSR_REG(op)	(((op) >> 8) & 0xf)
-#define OPCODE_RTS(op)		((op) == 0xb)
-#define OPCODE_RTE(op)		((op) == 0x2b)
-
-#define SR_T_BIT_MASK           0x1
-#define STEP_OPCODE             0xc33d
-
-/* Calculate the new address for after a step */
-static short *get_step_address(struct pt_regs *linux_regs)
-{
-	insn_size_t op = __raw_readw(linux_regs->pc);
-	long addr;
-
-	/* BT */
-	if (OPCODE_BT(op)) {
-		if (linux_regs->sr & SR_T_BIT_MASK)
-			addr = linux_regs->pc + 4 + OPCODE_BTF_DISP(op);
-		else
-			addr = linux_regs->pc + 2;
-	}
-
-	/* BTS */
-	else if (OPCODE_BTS(op)) {
-		if (linux_regs->sr & SR_T_BIT_MASK)
-			addr = linux_regs->pc + 4 + OPCODE_BTF_DISP(op);
-		else
-			addr = linux_regs->pc + 4;	/* Not in delay slot */
-	}
-
-	/* BF */
-	else if (OPCODE_BF(op)) {
-		if (!(linux_regs->sr & SR_T_BIT_MASK))
-			addr = linux_regs->pc + 4 + OPCODE_BTF_DISP(op);
-		else
-			addr = linux_regs->pc + 2;
-	}
-
-	/* BFS */
-	else if (OPCODE_BFS(op)) {
-		if (!(linux_regs->sr & SR_T_BIT_MASK))
-			addr = linux_regs->pc + 4 + OPCODE_BTF_DISP(op);
-		else
-			addr = linux_regs->pc + 4;	/* Not in delay slot */
-	}
-
-	/* BRA */
-	else if (OPCODE_BRA(op))
-		addr = linux_regs->pc + 4 + OPCODE_BRA_DISP(op);
-
-	/* BRAF */
-	else if (OPCODE_BRAF(op))
-		addr = linux_regs->pc + 4
-		    + linux_regs->regs[OPCODE_BRAF_REG(op)];
-
-	/* BSR */
-	else if (OPCODE_BSR(op))
-		addr = linux_regs->pc + 4 + OPCODE_BSR_DISP(op);
-
-	/* BSRF */
-	else if (OPCODE_BSRF(op))
-		addr = linux_regs->pc + 4
-		    + linux_regs->regs[OPCODE_BSRF_REG(op)];
-
-	/* JMP */
-	else if (OPCODE_JMP(op))
-		addr = linux_regs->regs[OPCODE_JMP_REG(op)];
-
-	/* JSR */
-	else if (OPCODE_JSR(op))
-		addr = linux_regs->regs[OPCODE_JSR_REG(op)];
-
-	/* RTS */
-	else if (OPCODE_RTS(op))
-		addr = linux_regs->pr;
-
-	/* RTE */
-	else if (OPCODE_RTE(op))
-		addr = linux_regs->regs[15];
-
-	/* Other */
-	else
-		addr = linux_regs->pc + instruction_size(op);
-
-	flush_icache_range(addr, addr + instruction_size(op));
-	return (short *)addr;
-}
-
-/*
- * Replace the instruction immediately after the current instruction
- * (i.e. next in the expected flow of control) with a trap instruction,
- * so that returning will cause only a single instruction to be executed.
- * Note that this model is slightly broken for instructions with delay
- * slots (e.g. B[TF]S, BSR, BRA etc), where both the branch and the
- * instruction in the delay slot will be executed.
- */
-
-static unsigned long stepped_address;
-static insn_size_t stepped_opcode;
-
-static void do_single_step(struct pt_regs *linux_regs)
-{
-	/* Determine where the target instruction will send us to */
-	unsigned short *addr = get_step_address(linux_regs);
-
-	stepped_address = (int)addr;
-
-	/* Replace it */
-	stepped_opcode = __raw_readw((long)addr);
-	*addr = STEP_OPCODE;
-
-	/* Flush and return */
-	flush_icache_range((long)addr, (long)addr +
-			   instruction_size(stepped_opcode));
-}
-
-/* Undo a single step */
-static void undo_single_step(struct pt_regs *linux_regs)
-{
-	/* If we have stepped, put back the old instruction */
-	/* Use stepped_address in case we stopped elsewhere */
-	if (stepped_opcode != 0) {
-		__raw_writew(stepped_opcode, stepped_address);
-		flush_icache_range(stepped_address, stepped_address + 2);
-	}
-
-	stepped_opcode = 0;
-}
-
-struct dbg_reg_def_t dbg_reg_def[DBG_MAX_REG_NUM] = {
-	{ "r0",		GDB_SIZEOF_REG, offsetof(struct pt_regs, regs[0]) },
-	{ "r1",		GDB_SIZEOF_REG, offsetof(struct pt_regs, regs[1]) },
-	{ "r2",		GDB_SIZEOF_REG, offsetof(struct pt_regs, regs[2]) },
-	{ "r3",		GDB_SIZEOF_REG, offsetof(struct pt_regs, regs[3]) },
-	{ "r4",		GDB_SIZEOF_REG, offsetof(struct pt_regs, regs[4]) },
-	{ "r5",		GDB_SIZEOF_REG, offsetof(struct pt_regs, regs[5]) },
-	{ "r6",		GDB_SIZEOF_REG, offsetof(struct pt_regs, regs[6]) },
-	{ "r7",		GDB_SIZEOF_REG, offsetof(struct pt_regs, regs[7]) },
-	{ "r8",		GDB_SIZEOF_REG, offsetof(struct pt_regs, regs[8]) },
-	{ "r9",		GDB_SIZEOF_REG, offsetof(struct pt_regs, regs[9]) },
-	{ "r10",	GDB_SIZEOF_REG, offsetof(struct pt_regs, regs[10]) },
-	{ "r11",	GDB_SIZEOF_REG, offsetof(struct pt_regs, regs[11]) },
-	{ "r12",	GDB_SIZEOF_REG, offsetof(struct pt_regs, regs[12]) },
-	{ "r13",	GDB_SIZEOF_REG, offsetof(struct pt_regs, regs[13]) },
-	{ "r14",	GDB_SIZEOF_REG, offsetof(struct pt_regs, regs[14]) },
-	{ "r15",	GDB_SIZEOF_REG, offsetof(struct pt_regs, regs[15]) },
-	{ "pc",		GDB_SIZEOF_REG, offsetof(struct pt_regs, pc) },
-	{ "pr",		GDB_SIZEOF_REG, offsetof(struct pt_regs, pr) },
-	{ "sr",		GDB_SIZEOF_REG, offsetof(struct pt_regs, sr) },
-	{ "gbr",	GDB_SIZEOF_REG, offsetof(struct pt_regs, gbr) },
-	{ "mach",	GDB_SIZEOF_REG, offsetof(struct pt_regs, mach) },
-	{ "macl",	GDB_SIZEOF_REG, offsetof(struct pt_regs, macl) },
-	{ "vbr",	GDB_SIZEOF_REG, -1 },
-};
-
-int dbg_set_reg(int regno, void *mem, struct pt_regs *regs)
-{
-	if (regno < 0 || regno >= DBG_MAX_REG_NUM)
-		return -EINVAL;
-
-	if (dbg_reg_def[regno].offset != -1)
-		memcpy((void *)regs + dbg_reg_def[regno].offset, mem,
-		       dbg_reg_def[regno].size);
-
-	return 0;
-}
-
-char *dbg_get_reg(int regno, void *mem, struct pt_regs *regs)
-{
-	if (regno >= DBG_MAX_REG_NUM || regno < 0)
-		return NULL;
-
-	if (dbg_reg_def[regno].size != -1)
-		memcpy(mem, (void *)regs + dbg_reg_def[regno].offset,
-		       dbg_reg_def[regno].size);
-
-	switch (regno) {
-	case GDB_VBR:
-		__asm__ __volatile__ ("stc vbr, %0" : "=r" (mem));
-		break;
-	}
-
-	return dbg_reg_def[regno].name;
-}
-
-void sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *p)
-{
-	struct pt_regs *thread_regs = task_pt_regs(p);
-	int reg;
-
-	/* Initialize to zero */
-	for (reg = 0; reg < DBG_MAX_REG_NUM; reg++)
-		gdb_regs[reg] = 0;
-
-	/*
-	 * Copy out GP regs 8 to 14.
-	 *
-	 * switch_to() relies on SR.RB toggling, so regs 0->7 are banked
-	 * and need privileged instructions to get to. The r15 value we
-	 * fetch from the thread info directly.
-	 */
-	for (reg = GDB_R8; reg < GDB_R15; reg++)
-		gdb_regs[reg] = thread_regs->regs[reg];
-
-	gdb_regs[GDB_R15] = p->thread.sp;
-	gdb_regs[GDB_PC] = p->thread.pc;
-
-	/*
-	 * Additional registers we have context for
-	 */
-	gdb_regs[GDB_PR] = thread_regs->pr;
-	gdb_regs[GDB_GBR] = thread_regs->gbr;
-}
-
-int kgdb_arch_handle_exception(int e_vector, int signo, int err_code,
-			       char *remcomInBuffer, char *remcomOutBuffer,
-			       struct pt_regs *linux_regs)
-{
-	unsigned long addr;
-	char *ptr;
-
-	/* Undo any stepping we may have done */
-	undo_single_step(linux_regs);
-
-	switch (remcomInBuffer[0]) {
-	case 'c':
-	case 's':
-		/* try to read optional parameter, pc unchanged if no parm */
-		ptr = &remcomInBuffer[1];
-		if (kgdb_hex2long(&ptr, &addr))
-			linux_regs->pc = addr;
-		fallthrough;
-	case 'D':
-	case 'k':
-		atomic_set(&kgdb_cpu_doing_single_step, -1);
-
-		if (remcomInBuffer[0] == 's') {
-			do_single_step(linux_regs);
-			kgdb_single_step = 1;
-
-			atomic_set(&kgdb_cpu_doing_single_step,
-				   raw_smp_processor_id());
-		}
-
-		return 0;
-	}
-
-	/* this means that we do not want to exit from the handler: */
-	return -1;
-}
-
-unsigned long kgdb_arch_pc(int exception, struct pt_regs *regs)
-{
-	if (exception == 60)
-		return instruction_pointer(regs) - 2;
-	return instruction_pointer(regs);
-}
-
-void kgdb_arch_set_pc(struct pt_regs *regs, unsigned long ip)
-{
-	regs->pc = ip;
-}
-
-/*
- * The primary entry points for the kgdb debug trap table entries.
- */
-BUILD_TRAP_HANDLER(singlestep)
-{
-	unsigned long flags;
-	TRAP_HANDLER_DECL;
-
-	local_irq_save(flags);
-	regs->pc -= instruction_size(__raw_readw(regs->pc - 4));
-	kgdb_handle_exception(0, SIGTRAP, 0, regs);
-	local_irq_restore(flags);
-}
-
-static int __kgdb_notify(struct die_args *args, unsigned long cmd)
-{
-	int ret;
-
-	switch (cmd) {
-	case DIE_BREAKPOINT:
-		/*
-		 * This means a user thread is single stepping
-		 * a system call which should be ignored
-		 */
-		if (test_thread_flag(TIF_SINGLESTEP))
-			return NOTIFY_DONE;
-
-		ret = kgdb_handle_exception(args->trapnr & 0xff, args->signr,
-					    args->err, args->regs);
-		if (ret)
-			return NOTIFY_DONE;
-
-		break;
-	}
-
-	return NOTIFY_STOP;
-}
-
-static int
-kgdb_notify(struct notifier_block *self, unsigned long cmd, void *ptr)
-{
-	unsigned long flags;
-	int ret;
-
-	local_irq_save(flags);
-	ret = __kgdb_notify(ptr, cmd);
-	local_irq_restore(flags);
-
-	return ret;
-}
-
-static struct notifier_block kgdb_notifier = {
-	.notifier_call	= kgdb_notify,
-
-	/*
-	 * Lowest-prio notifier priority, we want to be notified last:
-	 */
-	.priority	= -INT_MAX,
-};
-
-int kgdb_arch_init(void)
-{
-	return register_die_notifier(&kgdb_notifier);
-}
-
-void kgdb_arch_exit(void)
-{
-	unregister_die_notifier(&kgdb_notifier);
-}
-
-const struct kgdb_arch arch_kgdb_ops = {
-	/* Breakpoint instruction: trapa #0x3c */
-#ifdef CONFIG_CPU_LITTLE_ENDIAN
-	.gdb_bpt_instr		= { 0x3c, 0xc3 },
-#else
-	.gdb_bpt_instr		= { 0xc3, 0x3c },
-#endif
-};
diff --git a/arch/sh/kernel/kprobes.c b/arch/sh/kernel/kprobes.c
deleted file mode 100644
index aed1ea8e2c2f06..00000000000000
--- a/arch/sh/kernel/kprobes.c
+++ /dev/null
@@ -1,452 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Kernel probes (kprobes) for SuperH
- *
- * Copyright (C) 2007 Chris Smith <chris.smith@st.com>
- * Copyright (C) 2006 Lineo Solutions, Inc.
- */
-#include <linux/kprobes.h>
-#include <linux/extable.h>
-#include <linux/ptrace.h>
-#include <linux/preempt.h>
-#include <linux/kdebug.h>
-#include <linux/slab.h>
-#include <asm/cacheflush.h>
-#include <linux/uaccess.h>
-
-DEFINE_PER_CPU(struct kprobe *, current_kprobe) = NULL;
-DEFINE_PER_CPU(struct kprobe_ctlblk, kprobe_ctlblk);
-
-static DEFINE_PER_CPU(struct kprobe, saved_current_opcode);
-static DEFINE_PER_CPU(struct kprobe, saved_next_opcode);
-static DEFINE_PER_CPU(struct kprobe, saved_next_opcode2);
-
-#define OPCODE_JMP(x)	(((x) & 0xF0FF) == 0x402b)
-#define OPCODE_JSR(x)	(((x) & 0xF0FF) == 0x400b)
-#define OPCODE_BRA(x)	(((x) & 0xF000) == 0xa000)
-#define OPCODE_BRAF(x)	(((x) & 0xF0FF) == 0x0023)
-#define OPCODE_BSR(x)	(((x) & 0xF000) == 0xb000)
-#define OPCODE_BSRF(x)	(((x) & 0xF0FF) == 0x0003)
-
-#define OPCODE_BF_S(x)	(((x) & 0xFF00) == 0x8f00)
-#define OPCODE_BT_S(x)	(((x) & 0xFF00) == 0x8d00)
-
-#define OPCODE_BF(x)	(((x) & 0xFF00) == 0x8b00)
-#define OPCODE_BT(x)	(((x) & 0xFF00) == 0x8900)
-
-#define OPCODE_RTS(x)	(((x) & 0x000F) == 0x000b)
-#define OPCODE_RTE(x)	(((x) & 0xFFFF) == 0x002b)
-
-int __kprobes arch_prepare_kprobe(struct kprobe *p)
-{
-	kprobe_opcode_t opcode = *(kprobe_opcode_t *) (p->addr);
-
-	if (OPCODE_RTE(opcode))
-		return -EFAULT;	/* Bad breakpoint */
-
-	p->opcode = opcode;
-
-	return 0;
-}
-
-void __kprobes arch_copy_kprobe(struct kprobe *p)
-{
-	memcpy(p->ainsn.insn, p->addr, MAX_INSN_SIZE * sizeof(kprobe_opcode_t));
-	p->opcode = *p->addr;
-}
-
-void __kprobes arch_arm_kprobe(struct kprobe *p)
-{
-	*p->addr = BREAKPOINT_INSTRUCTION;
-	flush_icache_range((unsigned long)p->addr,
-			   (unsigned long)p->addr + sizeof(kprobe_opcode_t));
-}
-
-void __kprobes arch_disarm_kprobe(struct kprobe *p)
-{
-	*p->addr = p->opcode;
-	flush_icache_range((unsigned long)p->addr,
-			   (unsigned long)p->addr + sizeof(kprobe_opcode_t));
-}
-
-int __kprobes arch_trampoline_kprobe(struct kprobe *p)
-{
-	if (*p->addr == BREAKPOINT_INSTRUCTION)
-		return 1;
-
-	return 0;
-}
-
-/**
- * If an illegal slot instruction exception occurs for an address
- * containing a kprobe, remove the probe.
- *
- * Returns 0 if the exception was handled successfully, 1 otherwise.
- */
-int __kprobes kprobe_handle_illslot(unsigned long pc)
-{
-	struct kprobe *p = get_kprobe((kprobe_opcode_t *) pc + 1);
-
-	if (p != NULL) {
-		printk("Warning: removing kprobe from delay slot: 0x%.8x\n",
-		       (unsigned int)pc + 2);
-		unregister_kprobe(p);
-		return 0;
-	}
-
-	return 1;
-}
-
-void __kprobes arch_remove_kprobe(struct kprobe *p)
-{
-	struct kprobe *saved = this_cpu_ptr(&saved_next_opcode);
-
-	if (saved->addr) {
-		arch_disarm_kprobe(p);
-		arch_disarm_kprobe(saved);
-
-		saved->addr = NULL;
-		saved->opcode = 0;
-
-		saved = this_cpu_ptr(&saved_next_opcode2);
-		if (saved->addr) {
-			arch_disarm_kprobe(saved);
-
-			saved->addr = NULL;
-			saved->opcode = 0;
-		}
-	}
-}
-
-static void __kprobes save_previous_kprobe(struct kprobe_ctlblk *kcb)
-{
-	kcb->prev_kprobe.kp = kprobe_running();
-	kcb->prev_kprobe.status = kcb->kprobe_status;
-}
-
-static void __kprobes restore_previous_kprobe(struct kprobe_ctlblk *kcb)
-{
-	__this_cpu_write(current_kprobe, kcb->prev_kprobe.kp);
-	kcb->kprobe_status = kcb->prev_kprobe.status;
-}
-
-static void __kprobes set_current_kprobe(struct kprobe *p, struct pt_regs *regs,
-					 struct kprobe_ctlblk *kcb)
-{
-	__this_cpu_write(current_kprobe, p);
-}
-
-/*
- * Singlestep is implemented by disabling the current kprobe and setting one
- * on the next instruction, following branches. Two probes are set if the
- * branch is conditional.
- */
-static void __kprobes prepare_singlestep(struct kprobe *p, struct pt_regs *regs)
-{
-	__this_cpu_write(saved_current_opcode.addr, (kprobe_opcode_t *)regs->pc);
-
-	if (p != NULL) {
-		struct kprobe *op1, *op2;
-
-		arch_disarm_kprobe(p);
-
-		op1 = this_cpu_ptr(&saved_next_opcode);
-		op2 = this_cpu_ptr(&saved_next_opcode2);
-
-		if (OPCODE_JSR(p->opcode) || OPCODE_JMP(p->opcode)) {
-			unsigned int reg_nr = ((p->opcode >> 8) & 0x000F);
-			op1->addr = (kprobe_opcode_t *) regs->regs[reg_nr];
-		} else if (OPCODE_BRA(p->opcode) || OPCODE_BSR(p->opcode)) {
-			unsigned long disp = (p->opcode & 0x0FFF);
-			op1->addr =
-			    (kprobe_opcode_t *) (regs->pc + 4 + disp * 2);
-
-		} else if (OPCODE_BRAF(p->opcode) || OPCODE_BSRF(p->opcode)) {
-			unsigned int reg_nr = ((p->opcode >> 8) & 0x000F);
-			op1->addr =
-			    (kprobe_opcode_t *) (regs->pc + 4 +
-						 regs->regs[reg_nr]);
-
-		} else if (OPCODE_RTS(p->opcode)) {
-			op1->addr = (kprobe_opcode_t *) regs->pr;
-
-		} else if (OPCODE_BF(p->opcode) || OPCODE_BT(p->opcode)) {
-			unsigned long disp = (p->opcode & 0x00FF);
-			/* case 1 */
-			op1->addr = p->addr + 1;
-			/* case 2 */
-			op2->addr =
-			    (kprobe_opcode_t *) (regs->pc + 4 + disp * 2);
-			op2->opcode = *(op2->addr);
-			arch_arm_kprobe(op2);
-
-		} else if (OPCODE_BF_S(p->opcode) || OPCODE_BT_S(p->opcode)) {
-			unsigned long disp = (p->opcode & 0x00FF);
-			/* case 1 */
-			op1->addr = p->addr + 2;
-			/* case 2 */
-			op2->addr =
-			    (kprobe_opcode_t *) (regs->pc + 4 + disp * 2);
-			op2->opcode = *(op2->addr);
-			arch_arm_kprobe(op2);
-
-		} else {
-			op1->addr = p->addr + 1;
-		}
-
-		op1->opcode = *(op1->addr);
-		arch_arm_kprobe(op1);
-	}
-}
-
-/* Called with kretprobe_lock held */
-void __kprobes arch_prepare_kretprobe(struct kretprobe_instance *ri,
-				      struct pt_regs *regs)
-{
-	ri->ret_addr = (kprobe_opcode_t *) regs->pr;
-	ri->fp = NULL;
-
-	/* Replace the return addr with trampoline addr */
-	regs->pr = (unsigned long)__kretprobe_trampoline;
-}
-
-static int __kprobes kprobe_handler(struct pt_regs *regs)
-{
-	struct kprobe *p;
-	int ret = 0;
-	kprobe_opcode_t *addr = NULL;
-	struct kprobe_ctlblk *kcb;
-
-	/*
-	 * We don't want to be preempted for the entire
-	 * duration of kprobe processing
-	 */
-	preempt_disable();
-	kcb = get_kprobe_ctlblk();
-
-	addr = (kprobe_opcode_t *) (regs->pc);
-
-	/* Check we're not actually recursing */
-	if (kprobe_running()) {
-		p = get_kprobe(addr);
-		if (p) {
-			if (kcb->kprobe_status == KPROBE_HIT_SS &&
-			    *p->ainsn.insn == BREAKPOINT_INSTRUCTION) {
-				goto no_kprobe;
-			}
-			/* We have reentered the kprobe_handler(), since
-			 * another probe was hit while within the handler.
-			 * We here save the original kprobes variables and
-			 * just single step on the instruction of the new probe
-			 * without calling any user handlers.
-			 */
-			save_previous_kprobe(kcb);
-			set_current_kprobe(p, regs, kcb);
-			kprobes_inc_nmissed_count(p);
-			prepare_singlestep(p, regs);
-			kcb->kprobe_status = KPROBE_REENTER;
-			return 1;
-		}
-		goto no_kprobe;
-	}
-
-	p = get_kprobe(addr);
-	if (!p) {
-		/* Not one of ours: let kernel handle it */
-		if (*(kprobe_opcode_t *)addr != BREAKPOINT_INSTRUCTION) {
-			/*
-			 * The breakpoint instruction was removed right
-			 * after we hit it. Another cpu has removed
-			 * either a probepoint or a debugger breakpoint
-			 * at this address. In either case, no further
-			 * handling of this interrupt is appropriate.
-			 */
-			ret = 1;
-		}
-
-		goto no_kprobe;
-	}
-
-	set_current_kprobe(p, regs, kcb);
-	kcb->kprobe_status = KPROBE_HIT_ACTIVE;
-
-	if (p->pre_handler && p->pre_handler(p, regs)) {
-		/* handler has already set things up, so skip ss setup */
-		reset_current_kprobe();
-		preempt_enable_no_resched();
-		return 1;
-	}
-
-	prepare_singlestep(p, regs);
-	kcb->kprobe_status = KPROBE_HIT_SS;
-	return 1;
-
-no_kprobe:
-	preempt_enable_no_resched();
-	return ret;
-}
-
-/*
- * For function-return probes, init_kprobes() establishes a probepoint
- * here. When a retprobed function returns, this probe is hit and
- * trampoline_probe_handler() runs, calling the kretprobe's handler.
- */
-static void __used kretprobe_trampoline_holder(void)
-{
-	asm volatile (".globl __kretprobe_trampoline\n"
-		      "__kretprobe_trampoline:\n\t"
-		      "nop\n");
-}
-
-/*
- * Called when we hit the probe point at __kretprobe_trampoline
- */
-int __kprobes trampoline_probe_handler(struct kprobe *p, struct pt_regs *regs)
-{
-	regs->pc = __kretprobe_trampoline_handler(regs, NULL);
-
-	return 1;
-}
-
-static int __kprobes post_kprobe_handler(struct pt_regs *regs)
-{
-	struct kprobe *cur = kprobe_running();
-	struct kprobe_ctlblk *kcb = get_kprobe_ctlblk();
-	kprobe_opcode_t *addr = NULL;
-	struct kprobe *p = NULL;
-
-	if (!cur)
-		return 0;
-
-	if ((kcb->kprobe_status != KPROBE_REENTER) && cur->post_handler) {
-		kcb->kprobe_status = KPROBE_HIT_SSDONE;
-		cur->post_handler(cur, regs, 0);
-	}
-
-	p = this_cpu_ptr(&saved_next_opcode);
-	if (p->addr) {
-		arch_disarm_kprobe(p);
-		p->addr = NULL;
-		p->opcode = 0;
-
-		addr = __this_cpu_read(saved_current_opcode.addr);
-		__this_cpu_write(saved_current_opcode.addr, NULL);
-
-		p = get_kprobe(addr);
-		arch_arm_kprobe(p);
-
-		p = this_cpu_ptr(&saved_next_opcode2);
-		if (p->addr) {
-			arch_disarm_kprobe(p);
-			p->addr = NULL;
-			p->opcode = 0;
-		}
-	}
-
-	/* Restore back the original saved kprobes variables and continue. */
-	if (kcb->kprobe_status == KPROBE_REENTER) {
-		restore_previous_kprobe(kcb);
-		goto out;
-	}
-
-	reset_current_kprobe();
-
-out:
-	preempt_enable_no_resched();
-
-	return 1;
-}
-
-int __kprobes kprobe_fault_handler(struct pt_regs *regs, int trapnr)
-{
-	struct kprobe *cur = kprobe_running();
-	struct kprobe_ctlblk *kcb = get_kprobe_ctlblk();
-	const struct exception_table_entry *entry;
-
-	switch (kcb->kprobe_status) {
-	case KPROBE_HIT_SS:
-	case KPROBE_REENTER:
-		/*
-		 * We are here because the instruction being single
-		 * stepped caused a page fault. We reset the current
-		 * kprobe, point the pc back to the probe address
-		 * and allow the page fault handler to continue as a
-		 * normal page fault.
-		 */
-		regs->pc = (unsigned long)cur->addr;
-		if (kcb->kprobe_status == KPROBE_REENTER)
-			restore_previous_kprobe(kcb);
-		else
-			reset_current_kprobe();
-		preempt_enable_no_resched();
-		break;
-	case KPROBE_HIT_ACTIVE:
-	case KPROBE_HIT_SSDONE:
-		/*
-		 * In case the user-specified fault handler returned
-		 * zero, try to fix up.
-		 */
-		if ((entry = search_exception_tables(regs->pc)) != NULL) {
-			regs->pc = entry->fixup;
-			return 1;
-		}
-
-		/*
-		 * fixup_exception() could not handle it,
-		 * Let do_page_fault() fix it.
-		 */
-		break;
-	default:
-		break;
-	}
-
-	return 0;
-}
-
-/*
- * Wrapper routine to for handling exceptions.
- */
-int __kprobes kprobe_exceptions_notify(struct notifier_block *self,
-				       unsigned long val, void *data)
-{
-	struct kprobe *p = NULL;
-	struct die_args *args = (struct die_args *)data;
-	int ret = NOTIFY_DONE;
-	kprobe_opcode_t *addr = NULL;
-	struct kprobe_ctlblk *kcb = get_kprobe_ctlblk();
-
-	addr = (kprobe_opcode_t *) (args->regs->pc);
-	if (val == DIE_TRAP &&
-	    args->trapnr == (BREAKPOINT_INSTRUCTION & 0xff)) {
-		if (!kprobe_running()) {
-			if (kprobe_handler(args->regs)) {
-				ret = NOTIFY_STOP;
-			} else {
-				/* Not a kprobe trap */
-				ret = NOTIFY_DONE;
-			}
-		} else {
-			p = get_kprobe(addr);
-			if ((kcb->kprobe_status == KPROBE_HIT_SS) ||
-			    (kcb->kprobe_status == KPROBE_REENTER)) {
-				if (post_kprobe_handler(args->regs))
-					ret = NOTIFY_STOP;
-			} else {
-				if (kprobe_handler(args->regs))
-					ret = NOTIFY_STOP;
-			}
-		}
-	}
-
-	return ret;
-}
-
-static struct kprobe trampoline_p = {
-	.addr = (kprobe_opcode_t *)&__kretprobe_trampoline,
-	.pre_handler = trampoline_probe_handler
-};
-
-int __init arch_init_kprobes(void)
-{
-	return register_kprobe(&trampoline_p);
-}
diff --git a/arch/sh/kernel/machine_kexec.c b/arch/sh/kernel/machine_kexec.c
deleted file mode 100644
index 223c14f44af7e4..00000000000000
--- a/arch/sh/kernel/machine_kexec.c
+++ /dev/null
@@ -1,204 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * machine_kexec.c - handle transition of Linux booting another kernel
- * Copyright (C) 2002-2003 Eric Biederman  <ebiederm@xmission.com>
- *
- * GameCube/ppc32 port Copyright (C) 2004 Albert Herranz
- * LANDISK/sh4 supported by kogiidena
- */
-#include <linux/mm.h>
-#include <linux/kexec.h>
-#include <linux/delay.h>
-#include <linux/reboot.h>
-#include <linux/numa.h>
-#include <linux/ftrace.h>
-#include <linux/suspend.h>
-#include <linux/memblock.h>
-#include <asm/mmu_context.h>
-#include <asm/io.h>
-#include <asm/cacheflush.h>
-#include <asm/sh_bios.h>
-#include <asm/reboot.h>
-
-typedef void (*relocate_new_kernel_t)(unsigned long indirection_page,
-				      unsigned long reboot_code_buffer,
-				      unsigned long start_address);
-
-extern const unsigned char relocate_new_kernel[];
-extern const unsigned int relocate_new_kernel_size;
-extern void *vbr_base;
-
-void native_machine_crash_shutdown(struct pt_regs *regs)
-{
-	/* Nothing to do for UP, but definitely broken for SMP.. */
-}
-
-/*
- * Do what every setup is needed on image and the
- * reboot code buffer to allow us to avoid allocations
- * later.
- */
-int machine_kexec_prepare(struct kimage *image)
-{
-	return 0;
-}
-
-void machine_kexec_cleanup(struct kimage *image)
-{
-}
-
-static void kexec_info(struct kimage *image)
-{
-        int i;
-	printk("kexec information\n");
-	for (i = 0; i < image->nr_segments; i++) {
-	        printk("  segment[%d]: 0x%08x - 0x%08x (0x%08x)\n",
-		       i,
-		       (unsigned int)image->segment[i].mem,
-		       (unsigned int)image->segment[i].mem +
-				     image->segment[i].memsz,
-		       (unsigned int)image->segment[i].memsz);
-	}
-	printk("  start     : 0x%08x\n\n", (unsigned int)image->start);
-}
-
-/*
- * Do not allocate memory (or fail in any way) in machine_kexec().
- * We are past the point of no return, committed to rebooting now.
- */
-void machine_kexec(struct kimage *image)
-{
-	unsigned long page_list;
-	unsigned long reboot_code_buffer;
-	relocate_new_kernel_t rnk;
-	unsigned long entry;
-	unsigned long *ptr;
-	int save_ftrace_enabled;
-
-	/*
-	 * Nicked from the mips version of machine_kexec():
-	 * The generic kexec code builds a page list with physical
-	 * addresses. Use phys_to_virt() to convert them to virtual.
-	 */
-	for (ptr = &image->head; (entry = *ptr) && !(entry & IND_DONE);
-	     ptr = (entry & IND_INDIRECTION) ?
-	       phys_to_virt(entry & PAGE_MASK) : ptr + 1) {
-		if (*ptr & IND_SOURCE || *ptr & IND_INDIRECTION ||
-		    *ptr & IND_DESTINATION)
-			*ptr = (unsigned long) phys_to_virt(*ptr);
-	}
-
-#ifdef CONFIG_KEXEC_JUMP
-	if (image->preserve_context)
-		save_processor_state();
-#endif
-
-	save_ftrace_enabled = __ftrace_enabled_save();
-
-	/* Interrupts aren't acceptable while we reboot */
-	local_irq_disable();
-
-	page_list = image->head;
-
-	/* we need both effective and real address here */
-	reboot_code_buffer =
-			(unsigned long)page_address(image->control_code_page);
-
-	/* copy our kernel relocation code to the control code page */
-	memcpy((void *)reboot_code_buffer, relocate_new_kernel,
-						relocate_new_kernel_size);
-
-	kexec_info(image);
-	flush_cache_all();
-
-	sh_bios_vbr_reload();
-
-	/* now call it */
-	rnk = (relocate_new_kernel_t) reboot_code_buffer;
-	(*rnk)(page_list, reboot_code_buffer,
-	       (unsigned long)phys_to_virt(image->start));
-
-#ifdef CONFIG_KEXEC_JUMP
-	asm volatile("ldc %0, vbr" : : "r" (&vbr_base) : "memory");
-
-	if (image->preserve_context)
-		restore_processor_state();
-
-	/* Convert page list back to physical addresses, what a mess. */
-	for (ptr = &image->head; (entry = *ptr) && !(entry & IND_DONE);
-	     ptr = (*ptr & IND_INDIRECTION) ?
-	       phys_to_virt(*ptr & PAGE_MASK) : ptr + 1) {
-		if (*ptr & IND_SOURCE || *ptr & IND_INDIRECTION ||
-		    *ptr & IND_DESTINATION)
-			*ptr = virt_to_phys(*ptr);
-	}
-#endif
-
-	__ftrace_enabled_restore(save_ftrace_enabled);
-}
-
-void arch_crash_save_vmcoreinfo(void)
-{
-#ifdef CONFIG_NUMA
-	VMCOREINFO_SYMBOL(node_data);
-	VMCOREINFO_LENGTH(node_data, MAX_NUMNODES);
-#endif
-#ifdef CONFIG_X2TLB
-	VMCOREINFO_CONFIG(X2TLB);
-#endif
-}
-
-void __init reserve_crashkernel(void)
-{
-	unsigned long long crash_size, crash_base;
-	int ret;
-
-	ret = parse_crashkernel(boot_command_line, memblock_phys_mem_size(),
-			&crash_size, &crash_base);
-	if (ret == 0 && crash_size > 0) {
-		crashk_res.start = crash_base;
-		crashk_res.end = crash_base + crash_size - 1;
-	}
-
-	if (crashk_res.end == crashk_res.start)
-		goto disable;
-
-	crash_size = PAGE_ALIGN(resource_size(&crashk_res));
-	if (!crashk_res.start) {
-		unsigned long max = memblock_end_of_DRAM() - memory_limit;
-		crashk_res.start = memblock_phys_alloc_range(crash_size,
-							     PAGE_SIZE, 0, max);
-		if (!crashk_res.start) {
-			pr_err("crashkernel allocation failed\n");
-			goto disable;
-		}
-	} else {
-		ret = memblock_reserve(crashk_res.start, crash_size);
-		if (unlikely(ret < 0)) {
-			pr_err("crashkernel reservation failed - "
-			       "memory is in use\n");
-			goto disable;
-		}
-	}
-
-	crashk_res.end = crashk_res.start + crash_size - 1;
-
-	/*
-	 * Crash kernel trumps memory limit
-	 */
-	if ((memblock_end_of_DRAM() - memory_limit) <= crashk_res.end) {
-		memory_limit = 0;
-		pr_info("Disabled memory limit for crashkernel\n");
-	}
-
-	pr_info("Reserving %ldMB of memory at 0x%08lx "
-		"for crashkernel (System RAM: %ldMB)\n",
-		(unsigned long)(crash_size >> 20),
-		(unsigned long)(crashk_res.start),
-		(unsigned long)(memblock_phys_mem_size() >> 20));
-
-	return;
-
-disable:
-	crashk_res.start = crashk_res.end = 0;
-}
diff --git a/arch/sh/kernel/machvec.c b/arch/sh/kernel/machvec.c
deleted file mode 100644
index 57efaf5b82ae07..00000000000000
--- a/arch/sh/kernel/machvec.c
+++ /dev/null
@@ -1,122 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/machvec.c
- *
- * The SuperH machine vector setup handlers, yanked from setup.c
- *
- *  Copyright (C) 1999  Niibe Yutaka
- *  Copyright (C) 2002 - 2007 Paul Mundt
- */
-#include <linux/init.h>
-#include <linux/string.h>
-#include <asm/machvec.h>
-#include <asm/sections.h>
-#include <asm/addrspace.h>
-#include <asm/setup.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/processor.h>
-
-#define MV_NAME_SIZE 32
-
-#define for_each_mv(mv) \
-	for ((mv) = (struct sh_machine_vector *)__machvec_start; \
-	     (mv) && (unsigned long)(mv) < (unsigned long)__machvec_end; \
-	     (mv)++)
-
-static struct sh_machine_vector * __init get_mv_byname(const char *name)
-{
-	struct sh_machine_vector *mv;
-
-	for_each_mv(mv)
-		if (strcasecmp(name, mv->mv_name) == 0)
-			return mv;
-
-	return NULL;
-}
-
-static unsigned int __initdata machvec_selected;
-
-static int __init early_parse_mv(char *from)
-{
-	char mv_name[MV_NAME_SIZE] = "";
-	char *mv_end;
-	char *mv_comma;
-	int mv_len;
-	struct sh_machine_vector *mvp;
-
-	mv_end = strchr(from, ' ');
-	if (mv_end == NULL)
-		mv_end = from + strlen(from);
-
-	mv_comma = strchr(from, ',');
-	mv_len = mv_end - from;
-	if (mv_len > (MV_NAME_SIZE-1))
-		mv_len = MV_NAME_SIZE-1;
-	memcpy(mv_name, from, mv_len);
-	mv_name[mv_len] = '\0';
-	from = mv_end;
-
-	machvec_selected = 1;
-
-	/* Boot with the generic vector */
-	if (strcmp(mv_name, "generic") == 0)
-		return 0;
-
-	mvp = get_mv_byname(mv_name);
-	if (unlikely(!mvp)) {
-		pr_info("Available vectors:\n\n\t'%s', ", sh_mv.mv_name);
-		for_each_mv(mvp)
-			pr_cont("'%s', ", mvp->mv_name);
-		pr_cont("\n\n");
-		panic("Failed to select machvec '%s' -- halting.\n",
-		      mv_name);
-	} else
-		sh_mv = *mvp;
-
-	return 0;
-}
-early_param("sh_mv", early_parse_mv);
-
-void __init sh_mv_setup(void)
-{
-	/*
-	 * Only overload the machvec if one hasn't been selected on
-	 * the command line with sh_mv=
-	 */
-	if (!machvec_selected) {
-		unsigned long machvec_size;
-
-		machvec_size = ((unsigned long)__machvec_end -
-				(unsigned long)__machvec_start);
-
-		/*
-		 * Sanity check for machvec section alignment. Ensure
-		 * __initmv hasn't been misused.
-		 */
-		if (machvec_size % sizeof(struct sh_machine_vector))
-			panic("machvec misaligned, invalid __initmv use?");
-
-		/*
-		 * If the machvec hasn't been preselected, use the first
-		 * vector (usually the only one) from .machvec.init.
-		 */
-		if (machvec_size >= sizeof(struct sh_machine_vector))
-			sh_mv = *(struct sh_machine_vector *)__machvec_start;
-	}
-
-	pr_notice("Booting machvec: %s\n", get_system_type());
-
-	/*
-	 * Manually walk the vec, fill in anything that the board hasn't yet
-	 * by hand, wrapping to the generic implementation.
-	 */
-#define mv_set(elem) do { \
-	if (!sh_mv.mv_##elem) \
-		sh_mv.mv_##elem = generic_##elem; \
-} while (0)
-
-	mv_set(irq_demux);
-	mv_set(mode_pins);
-	mv_set(mem_init);
-}
diff --git a/arch/sh/kernel/module.c b/arch/sh/kernel/module.c
deleted file mode 100644
index b9cee98a754e51..00000000000000
--- a/arch/sh/kernel/module.c
+++ /dev/null
@@ -1,104 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*  Kernel module help for SH.
-
-    SHcompact version by Kaz Kojima and Paul Mundt.
-
-    SHmedia bits:
-
-	Copyright 2004 SuperH (UK) Ltd
-	Author: Richard Curnow
-
-	Based on the sh version, and on code from the sh64-specific parts of
-	modutils, originally written by Richard Curnow and Ben Gaster.
-*/
-#include <linux/moduleloader.h>
-#include <linux/elf.h>
-#include <linux/vmalloc.h>
-#include <linux/bug.h>
-#include <linux/fs.h>
-#include <linux/string.h>
-#include <linux/kernel.h>
-#include <asm/unaligned.h>
-#include <asm/dwarf.h>
-
-int apply_relocate_add(Elf32_Shdr *sechdrs,
-		   const char *strtab,
-		   unsigned int symindex,
-		   unsigned int relsec,
-		   struct module *me)
-{
-	unsigned int i;
-	Elf32_Rela *rel = (void *)sechdrs[relsec].sh_addr;
-	Elf32_Sym *sym;
-	Elf32_Addr relocation;
-	uint32_t *location;
-	uint32_t value;
-
-	pr_debug("Applying relocate section %u to %u\n", relsec,
-		 sechdrs[relsec].sh_info);
-	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
-		/* This is where to make the change */
-		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
-			+ rel[i].r_offset;
-		/* This is the symbol it is referring to.  Note that all
-		   undefined symbols have been resolved.  */
-		sym = (Elf32_Sym *)sechdrs[symindex].sh_addr
-			+ ELF32_R_SYM(rel[i].r_info);
-		relocation = sym->st_value + rel[i].r_addend;
-
-		switch (ELF32_R_TYPE(rel[i].r_info)) {
-		case R_SH_NONE:
-			break;
-		case R_SH_DIR32:
-			value = get_unaligned(location);
-			value += relocation;
-			put_unaligned(value, location);
-			break;
-		case R_SH_REL32:
-			relocation = (relocation - (Elf32_Addr) location);
-			value = get_unaligned(location);
-			value += relocation;
-			put_unaligned(value, location);
-			break;
-		case R_SH_IMM_LOW16:
-			*location = (*location & ~0x3fffc00) |
-				((relocation & 0xffff) << 10);
-			break;
-		case R_SH_IMM_MEDLOW16:
-			*location = (*location & ~0x3fffc00) |
-				(((relocation >> 16) & 0xffff) << 10);
-			break;
-		case R_SH_IMM_LOW16_PCREL:
-			relocation -= (Elf32_Addr) location;
-			*location = (*location & ~0x3fffc00) |
-				((relocation & 0xffff) << 10);
-			break;
-		case R_SH_IMM_MEDLOW16_PCREL:
-			relocation -= (Elf32_Addr) location;
-			*location = (*location & ~0x3fffc00) |
-				(((relocation >> 16) & 0xffff) << 10);
-			break;
-		default:
-			printk(KERN_ERR "module %s: Unknown relocation: %u\n",
-			       me->name, ELF32_R_TYPE(rel[i].r_info));
-			return -ENOEXEC;
-		}
-	}
-	return 0;
-}
-
-int module_finalize(const Elf_Ehdr *hdr,
-		    const Elf_Shdr *sechdrs,
-		    struct module *me)
-{
-	int ret = 0;
-
-	ret |= module_dwarf_finalize(hdr, sechdrs, me);
-
-	return ret;
-}
-
-void module_arch_cleanup(struct module *mod)
-{
-	module_dwarf_cleanup(mod);
-}
diff --git a/arch/sh/kernel/nmi_debug.c b/arch/sh/kernel/nmi_debug.c
deleted file mode 100644
index 11777867c6f5fc..00000000000000
--- a/arch/sh/kernel/nmi_debug.c
+++ /dev/null
@@ -1,75 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (C) 2007 Atmel Corporation
- */
-#include <linux/delay.h>
-#include <linux/kdebug.h>
-#include <linux/notifier.h>
-#include <linux/sched.h>
-#include <linux/sched/debug.h>
-#include <linux/hardirq.h>
-
-enum nmi_action {
-	NMI_SHOW_STATE	= 1 << 0,
-	NMI_SHOW_REGS	= 1 << 1,
-	NMI_DIE		= 1 << 2,
-	NMI_DEBOUNCE	= 1 << 3,
-};
-
-static unsigned long nmi_actions;
-
-static int nmi_debug_notify(struct notifier_block *self,
-		unsigned long val, void *data)
-{
-	struct die_args *args = data;
-
-	if (likely(val != DIE_NMI))
-		return NOTIFY_DONE;
-
-	if (nmi_actions & NMI_SHOW_STATE)
-		show_state();
-	if (nmi_actions & NMI_SHOW_REGS)
-		show_regs(args->regs);
-	if (nmi_actions & NMI_DEBOUNCE)
-		mdelay(10);
-	if (nmi_actions & NMI_DIE)
-		return NOTIFY_BAD;
-
-	return NOTIFY_OK;
-}
-
-static struct notifier_block nmi_debug_nb = {
-	.notifier_call = nmi_debug_notify,
-};
-
-static int __init nmi_debug_setup(char *str)
-{
-	char *p, *sep;
-
-	register_die_notifier(&nmi_debug_nb);
-
-	if (*str != '=')
-		return 0;
-
-	for (p = str + 1; *p; p = sep + 1) {
-		sep = strchr(p, ',');
-		if (sep)
-			*sep = 0;
-		if (strcmp(p, "state") == 0)
-			nmi_actions |= NMI_SHOW_STATE;
-		else if (strcmp(p, "regs") == 0)
-			nmi_actions |= NMI_SHOW_REGS;
-		else if (strcmp(p, "debounce") == 0)
-			nmi_actions |= NMI_DEBOUNCE;
-		else if (strcmp(p, "die") == 0)
-			nmi_actions |= NMI_DIE;
-		else
-			printk(KERN_WARNING "NMI: Unrecognized action `%s'\n",
-				p);
-		if (!sep)
-			break;
-	}
-
-	return 0;
-}
-__setup("nmi_debug", nmi_debug_setup);
diff --git a/arch/sh/kernel/perf_callchain.c b/arch/sh/kernel/perf_callchain.c
deleted file mode 100644
index c9d3aa18732d1d..00000000000000
--- a/arch/sh/kernel/perf_callchain.c
+++ /dev/null
@@ -1,32 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Performance event callchain support - SuperH architecture code
- *
- * Copyright (C) 2009  Paul Mundt
- */
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/perf_event.h>
-#include <linux/percpu.h>
-#include <asm/unwinder.h>
-#include <asm/ptrace.h>
-
-static void callchain_address(void *data, unsigned long addr, int reliable)
-{
-	struct perf_callchain_entry_ctx *entry = data;
-
-	if (reliable)
-		perf_callchain_store(entry, addr);
-}
-
-static const struct stacktrace_ops callchain_ops = {
-	.address	= callchain_address,
-};
-
-void
-perf_callchain_kernel(struct perf_callchain_entry_ctx *entry, struct pt_regs *regs)
-{
-	perf_callchain_store(entry, regs->pc);
-
-	unwind_stack(NULL, regs, NULL, &callchain_ops, entry);
-}
diff --git a/arch/sh/kernel/perf_event.c b/arch/sh/kernel/perf_event.c
deleted file mode 100644
index 1d2507f2243723..00000000000000
--- a/arch/sh/kernel/perf_event.c
+++ /dev/null
@@ -1,363 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Performance event support framework for SuperH hardware counters.
- *
- *  Copyright (C) 2009  Paul Mundt
- *
- * Heavily based on the x86 and PowerPC implementations.
- *
- * x86:
- *  Copyright (C) 2008 Thomas Gleixner <tglx@linutronix.de>
- *  Copyright (C) 2008-2009 Red Hat, Inc., Ingo Molnar
- *  Copyright (C) 2009 Jaswinder Singh Rajput
- *  Copyright (C) 2009 Advanced Micro Devices, Inc., Robert Richter
- *  Copyright (C) 2008-2009 Red Hat, Inc., Peter Zijlstra
- *  Copyright (C) 2009 Intel Corporation, <markus.t.metzger@intel.com>
- *
- * ppc:
- *  Copyright 2008-2009 Paul Mackerras, IBM Corporation.
- */
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/irq.h>
-#include <linux/perf_event.h>
-#include <linux/export.h>
-#include <asm/processor.h>
-
-struct cpu_hw_events {
-	struct perf_event	*events[MAX_HWEVENTS];
-	unsigned long		used_mask[BITS_TO_LONGS(MAX_HWEVENTS)];
-	unsigned long		active_mask[BITS_TO_LONGS(MAX_HWEVENTS)];
-};
-
-DEFINE_PER_CPU(struct cpu_hw_events, cpu_hw_events);
-
-static struct sh_pmu *sh_pmu __read_mostly;
-
-/* Number of perf_events counting hardware events */
-static atomic_t num_events;
-/* Used to avoid races in calling reserve/release_pmc_hardware */
-static DEFINE_MUTEX(pmc_reserve_mutex);
-
-/*
- * Stub these out for now, do something more profound later.
- */
-int reserve_pmc_hardware(void)
-{
-	return 0;
-}
-
-void release_pmc_hardware(void)
-{
-}
-
-static inline int sh_pmu_initialized(void)
-{
-	return !!sh_pmu;
-}
-
-/*
- * Release the PMU if this is the last perf_event.
- */
-static void hw_perf_event_destroy(struct perf_event *event)
-{
-	if (!atomic_add_unless(&num_events, -1, 1)) {
-		mutex_lock(&pmc_reserve_mutex);
-		if (atomic_dec_return(&num_events) == 0)
-			release_pmc_hardware();
-		mutex_unlock(&pmc_reserve_mutex);
-	}
-}
-
-static int hw_perf_cache_event(int config, int *evp)
-{
-	unsigned long type, op, result;
-	int ev;
-
-	if (!sh_pmu->cache_events)
-		return -EINVAL;
-
-	/* unpack config */
-	type = config & 0xff;
-	op = (config >> 8) & 0xff;
-	result = (config >> 16) & 0xff;
-
-	if (type >= PERF_COUNT_HW_CACHE_MAX ||
-	    op >= PERF_COUNT_HW_CACHE_OP_MAX ||
-	    result >= PERF_COUNT_HW_CACHE_RESULT_MAX)
-		return -EINVAL;
-
-	ev = (*sh_pmu->cache_events)[type][op][result];
-	if (ev == 0)
-		return -EOPNOTSUPP;
-	if (ev == -1)
-		return -EINVAL;
-	*evp = ev;
-	return 0;
-}
-
-static int __hw_perf_event_init(struct perf_event *event)
-{
-	struct perf_event_attr *attr = &event->attr;
-	struct hw_perf_event *hwc = &event->hw;
-	int config = -1;
-	int err;
-
-	if (!sh_pmu_initialized())
-		return -ENODEV;
-
-	/*
-	 * See if we need to reserve the counter.
-	 *
-	 * If no events are currently in use, then we have to take a
-	 * mutex to ensure that we don't race with another task doing
-	 * reserve_pmc_hardware or release_pmc_hardware.
-	 */
-	err = 0;
-	if (!atomic_inc_not_zero(&num_events)) {
-		mutex_lock(&pmc_reserve_mutex);
-		if (atomic_read(&num_events) == 0 &&
-		    reserve_pmc_hardware())
-			err = -EBUSY;
-		else
-			atomic_inc(&num_events);
-		mutex_unlock(&pmc_reserve_mutex);
-	}
-
-	if (err)
-		return err;
-
-	event->destroy = hw_perf_event_destroy;
-
-	switch (attr->type) {
-	case PERF_TYPE_RAW:
-		config = attr->config & sh_pmu->raw_event_mask;
-		break;
-	case PERF_TYPE_HW_CACHE:
-		err = hw_perf_cache_event(attr->config, &config);
-		if (err)
-			return err;
-		break;
-	case PERF_TYPE_HARDWARE:
-		if (attr->config >= sh_pmu->max_events)
-			return -EINVAL;
-
-		config = sh_pmu->event_map(attr->config);
-		break;
-	}
-
-	if (config == -1)
-		return -EINVAL;
-
-	hwc->config |= config;
-
-	return 0;
-}
-
-static void sh_perf_event_update(struct perf_event *event,
-				   struct hw_perf_event *hwc, int idx)
-{
-	u64 prev_raw_count, new_raw_count;
-	s64 delta;
-	int shift = 0;
-
-	/*
-	 * Depending on the counter configuration, they may or may not
-	 * be chained, in which case the previous counter value can be
-	 * updated underneath us if the lower-half overflows.
-	 *
-	 * Our tactic to handle this is to first atomically read and
-	 * exchange a new raw count - then add that new-prev delta
-	 * count to the generic counter atomically.
-	 *
-	 * As there is no interrupt associated with the overflow events,
-	 * this is the simplest approach for maintaining consistency.
-	 */
-again:
-	prev_raw_count = local64_read(&hwc->prev_count);
-	new_raw_count = sh_pmu->read(idx);
-
-	if (local64_cmpxchg(&hwc->prev_count, prev_raw_count,
-			     new_raw_count) != prev_raw_count)
-		goto again;
-
-	/*
-	 * Now we have the new raw value and have updated the prev
-	 * timestamp already. We can now calculate the elapsed delta
-	 * (counter-)time and add that to the generic counter.
-	 *
-	 * Careful, not all hw sign-extends above the physical width
-	 * of the count.
-	 */
-	delta = (new_raw_count << shift) - (prev_raw_count << shift);
-	delta >>= shift;
-
-	local64_add(delta, &event->count);
-}
-
-static void sh_pmu_stop(struct perf_event *event, int flags)
-{
-	struct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);
-	struct hw_perf_event *hwc = &event->hw;
-	int idx = hwc->idx;
-
-	if (!(event->hw.state & PERF_HES_STOPPED)) {
-		sh_pmu->disable(hwc, idx);
-		cpuc->events[idx] = NULL;
-		event->hw.state |= PERF_HES_STOPPED;
-	}
-
-	if ((flags & PERF_EF_UPDATE) && !(event->hw.state & PERF_HES_UPTODATE)) {
-		sh_perf_event_update(event, &event->hw, idx);
-		event->hw.state |= PERF_HES_UPTODATE;
-	}
-}
-
-static void sh_pmu_start(struct perf_event *event, int flags)
-{
-	struct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);
-	struct hw_perf_event *hwc = &event->hw;
-	int idx = hwc->idx;
-
-	if (WARN_ON_ONCE(idx == -1))
-		return;
-
-	if (flags & PERF_EF_RELOAD)
-		WARN_ON_ONCE(!(event->hw.state & PERF_HES_UPTODATE));
-
-	cpuc->events[idx] = event;
-	event->hw.state = 0;
-	sh_pmu->enable(hwc, idx);
-}
-
-static void sh_pmu_del(struct perf_event *event, int flags)
-{
-	struct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);
-
-	sh_pmu_stop(event, PERF_EF_UPDATE);
-	__clear_bit(event->hw.idx, cpuc->used_mask);
-
-	perf_event_update_userpage(event);
-}
-
-static int sh_pmu_add(struct perf_event *event, int flags)
-{
-	struct cpu_hw_events *cpuc = this_cpu_ptr(&cpu_hw_events);
-	struct hw_perf_event *hwc = &event->hw;
-	int idx = hwc->idx;
-	int ret = -EAGAIN;
-
-	perf_pmu_disable(event->pmu);
-
-	if (__test_and_set_bit(idx, cpuc->used_mask)) {
-		idx = find_first_zero_bit(cpuc->used_mask, sh_pmu->num_events);
-		if (idx == sh_pmu->num_events)
-			goto out;
-
-		__set_bit(idx, cpuc->used_mask);
-		hwc->idx = idx;
-	}
-
-	sh_pmu->disable(hwc, idx);
-
-	event->hw.state = PERF_HES_UPTODATE | PERF_HES_STOPPED;
-	if (flags & PERF_EF_START)
-		sh_pmu_start(event, PERF_EF_RELOAD);
-
-	perf_event_update_userpage(event);
-	ret = 0;
-out:
-	perf_pmu_enable(event->pmu);
-	return ret;
-}
-
-static void sh_pmu_read(struct perf_event *event)
-{
-	sh_perf_event_update(event, &event->hw, event->hw.idx);
-}
-
-static int sh_pmu_event_init(struct perf_event *event)
-{
-	int err;
-
-	/* does not support taken branch sampling */
-	if (has_branch_stack(event))
-		return -EOPNOTSUPP;
-
-	switch (event->attr.type) {
-	case PERF_TYPE_RAW:
-	case PERF_TYPE_HW_CACHE:
-	case PERF_TYPE_HARDWARE:
-		err = __hw_perf_event_init(event);
-		break;
-
-	default:
-		return -ENOENT;
-	}
-
-	if (unlikely(err)) {
-		if (event->destroy)
-			event->destroy(event);
-	}
-
-	return err;
-}
-
-static void sh_pmu_enable(struct pmu *pmu)
-{
-	if (!sh_pmu_initialized())
-		return;
-
-	sh_pmu->enable_all();
-}
-
-static void sh_pmu_disable(struct pmu *pmu)
-{
-	if (!sh_pmu_initialized())
-		return;
-
-	sh_pmu->disable_all();
-}
-
-static struct pmu pmu = {
-	.pmu_enable	= sh_pmu_enable,
-	.pmu_disable	= sh_pmu_disable,
-	.event_init	= sh_pmu_event_init,
-	.add		= sh_pmu_add,
-	.del		= sh_pmu_del,
-	.start		= sh_pmu_start,
-	.stop		= sh_pmu_stop,
-	.read		= sh_pmu_read,
-};
-
-static int sh_pmu_prepare_cpu(unsigned int cpu)
-{
-	struct cpu_hw_events *cpuhw = &per_cpu(cpu_hw_events, cpu);
-
-	memset(cpuhw, 0, sizeof(struct cpu_hw_events));
-	return 0;
-}
-
-int register_sh_pmu(struct sh_pmu *_pmu)
-{
-	if (sh_pmu)
-		return -EBUSY;
-	sh_pmu = _pmu;
-
-	pr_info("Performance Events: %s support registered\n", _pmu->name);
-
-	/*
-	 * All of the on-chip counters are "limited", in that they have
-	 * no interrupts, and are therefore unable to do sampling without
-	 * further work and timer assistance.
-	 */
-	pmu.capabilities |= PERF_PMU_CAP_NO_INTERRUPT;
-
-	WARN_ON(_pmu->num_events > MAX_HWEVENTS);
-
-	perf_pmu_register(&pmu, "cpu", PERF_TYPE_RAW);
-	cpuhp_setup_state(CPUHP_PERF_SUPERH, "PERF_SUPERH", sh_pmu_prepare_cpu,
-			  NULL);
-	return 0;
-}
diff --git a/arch/sh/kernel/process.c b/arch/sh/kernel/process.c
deleted file mode 100644
index 169832fcf21b2f..00000000000000
--- a/arch/sh/kernel/process.c
+++ /dev/null
@@ -1,77 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/mm.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/sched/signal.h>
-#include <linux/sched/task_stack.h>
-#include <linux/export.h>
-#include <linux/stackprotector.h>
-#include <asm/fpu.h>
-#include <asm/ptrace.h>
-
-struct kmem_cache *task_xstate_cachep = NULL;
-unsigned int xstate_size;
-
-#ifdef CONFIG_STACKPROTECTOR
-unsigned long __stack_chk_guard __read_mostly;
-EXPORT_SYMBOL(__stack_chk_guard);
-#endif
-
-/*
- * this gets called so that we can store lazy state into memory and copy the
- * current task into the new thread.
- */
-int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)
-{
-	unlazy_fpu(src, task_pt_regs(src));
-	*dst = *src;
-
-	if (src->thread.xstate) {
-		dst->thread.xstate = kmem_cache_alloc(task_xstate_cachep,
-						      GFP_KERNEL);
-		if (!dst->thread.xstate)
-			return -ENOMEM;
-		memcpy(dst->thread.xstate, src->thread.xstate, xstate_size);
-	}
-
-	return 0;
-}
-
-void free_thread_xstate(struct task_struct *tsk)
-{
-	if (tsk->thread.xstate) {
-		kmem_cache_free(task_xstate_cachep, tsk->thread.xstate);
-		tsk->thread.xstate = NULL;
-	}
-}
-
-void arch_release_task_struct(struct task_struct *tsk)
-{
-	free_thread_xstate(tsk);
-}
-
-void arch_task_cache_init(void)
-{
-	if (!xstate_size)
-		return;
-
-	task_xstate_cachep = kmem_cache_create("task_xstate", xstate_size,
-					       __alignof__(union thread_xstate),
-					       SLAB_PANIC, NULL);
-}
-
-#ifdef CONFIG_SH_FPU_EMU
-# define HAVE_SOFTFP	1
-#else
-# define HAVE_SOFTFP	0
-#endif
-
-void init_thread_xstate(void)
-{
-	if (boot_cpu_data.flags & CPU_HAS_FPU)
-		xstate_size = sizeof(struct sh_fpu_hard_struct);
-	else if (HAVE_SOFTFP)
-		xstate_size = sizeof(struct sh_fpu_soft_struct);
-	else
-		xstate_size = 0;
-}
diff --git a/arch/sh/kernel/process_32.c b/arch/sh/kernel/process_32.c
deleted file mode 100644
index 92b6649d492952..00000000000000
--- a/arch/sh/kernel/process_32.c
+++ /dev/null
@@ -1,197 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/process.c
- *
- * This file handles the architecture-dependent parts of process handling..
- *
- *  Copyright (C) 1995  Linus Torvalds
- *
- *  SuperH version:  Copyright (C) 1999, 2000  Niibe Yutaka & Kaz Kojima
- *		     Copyright (C) 2006 Lineo Solutions Inc. support SH4A UBC
- *		     Copyright (C) 2002 - 2008  Paul Mundt
- */
-#include <linux/module.h>
-#include <linux/mm.h>
-#include <linux/sched/debug.h>
-#include <linux/sched/task.h>
-#include <linux/sched/task_stack.h>
-#include <linux/slab.h>
-#include <linux/elfcore.h>
-#include <linux/fs.h>
-#include <linux/ftrace.h>
-#include <linux/hw_breakpoint.h>
-#include <linux/prefetch.h>
-#include <linux/stackprotector.h>
-#include <linux/uaccess.h>
-#include <asm/mmu_context.h>
-#include <asm/fpu.h>
-#include <asm/syscalls.h>
-#include <asm/switch_to.h>
-
-void show_regs(struct pt_regs * regs)
-{
-	pr_info("\n");
-	show_regs_print_info(KERN_DEFAULT);
-
-	pr_info("PC is at %pS\n", (void *)instruction_pointer(regs));
-	pr_info("PR is at %pS\n", (void *)regs->pr);
-
-	pr_info("PC  : %08lx SP  : %08lx SR  : %08lx ", regs->pc,
-		regs->regs[15], regs->sr);
-#ifdef CONFIG_MMU
-	pr_cont("TEA : %08x\n", __raw_readl(MMU_TEA));
-#else
-	pr_cont("\n");
-#endif
-
-	pr_info("R0  : %08lx R1  : %08lx R2  : %08lx R3  : %08lx\n",
-		regs->regs[0], regs->regs[1], regs->regs[2], regs->regs[3]);
-	pr_info("R4  : %08lx R5  : %08lx R6  : %08lx R7  : %08lx\n",
-		regs->regs[4], regs->regs[5], regs->regs[6], regs->regs[7]);
-	pr_info("R8  : %08lx R9  : %08lx R10 : %08lx R11 : %08lx\n",
-		regs->regs[8], regs->regs[9], regs->regs[10], regs->regs[11]);
-	pr_info("R12 : %08lx R13 : %08lx R14 : %08lx\n",
-		regs->regs[12], regs->regs[13], regs->regs[14]);
-	pr_info("MACH: %08lx MACL: %08lx GBR : %08lx PR  : %08lx\n",
-		regs->mach, regs->macl, regs->gbr, regs->pr);
-
-	show_trace(NULL, (unsigned long *)regs->regs[15], regs, KERN_DEFAULT);
-	show_code(regs);
-}
-
-void start_thread(struct pt_regs *regs, unsigned long new_pc,
-		  unsigned long new_sp)
-{
-	regs->pr = 0;
-	regs->sr = SR_FD;
-	regs->pc = new_pc;
-	regs->regs[15] = new_sp;
-
-	free_thread_xstate(current);
-}
-EXPORT_SYMBOL(start_thread);
-
-void flush_thread(void)
-{
-	struct task_struct *tsk = current;
-
-	flush_ptrace_hw_breakpoint(tsk);
-
-#if defined(CONFIG_SH_FPU)
-	/* Forget lazy FPU state */
-	clear_fpu(tsk, task_pt_regs(tsk));
-	clear_used_math();
-#endif
-}
-
-asmlinkage void ret_from_fork(void);
-asmlinkage void ret_from_kernel_thread(void);
-
-int copy_thread(struct task_struct *p, const struct kernel_clone_args *args)
-{
-	unsigned long clone_flags = args->flags;
-	unsigned long usp = args->stack;
-	unsigned long tls = args->tls;
-	struct thread_info *ti = task_thread_info(p);
-	struct pt_regs *childregs;
-
-#if defined(CONFIG_SH_DSP)
-	struct task_struct *tsk = current;
-
-	if (is_dsp_enabled(tsk)) {
-		/* We can use the __save_dsp or just copy the struct:
-		 * __save_dsp(p);
-		 * p->thread.dsp_status.status |= SR_DSP
-		 */
-		p->thread.dsp_status = tsk->thread.dsp_status;
-	}
-#endif
-
-	memset(p->thread.ptrace_bps, 0, sizeof(p->thread.ptrace_bps));
-
-	childregs = task_pt_regs(p);
-	p->thread.sp = (unsigned long) childregs;
-	if (unlikely(args->fn)) {
-		memset(childregs, 0, sizeof(struct pt_regs));
-		p->thread.pc = (unsigned long) ret_from_kernel_thread;
-		childregs->regs[4] = (unsigned long) args->fn_arg;
-		childregs->regs[5] = (unsigned long) args->fn;
-		childregs->sr = SR_MD;
-#if defined(CONFIG_SH_FPU)
-		childregs->sr |= SR_FD;
-#endif
-		ti->status &= ~TS_USEDFPU;
-		p->thread.fpu_counter = 0;
-		return 0;
-	}
-	*childregs = *current_pt_regs();
-
-	if (usp)
-		childregs->regs[15] = usp;
-
-	if (clone_flags & CLONE_SETTLS)
-		childregs->gbr = tls;
-
-	childregs->regs[0] = 0; /* Set return value for child */
-	p->thread.pc = (unsigned long) ret_from_fork;
-	return 0;
-}
-
-/*
- *	switch_to(x,y) should switch tasks from x to y.
- *
- */
-__notrace_funcgraph struct task_struct *
-__switch_to(struct task_struct *prev, struct task_struct *next)
-{
-	struct thread_struct *next_t = &next->thread;
-
-#if defined(CONFIG_STACKPROTECTOR) && !defined(CONFIG_SMP)
-	__stack_chk_guard = next->stack_canary;
-#endif
-
-	unlazy_fpu(prev, task_pt_regs(prev));
-
-	/* we're going to use this soon, after a few expensive things */
-	if (next->thread.fpu_counter > 5)
-		prefetch(next_t->xstate);
-
-#ifdef CONFIG_MMU
-	/*
-	 * Restore the kernel mode register
-	 *	k7 (r7_bank1)
-	 */
-	asm volatile("ldc	%0, r7_bank"
-		     : /* no output */
-		     : "r" (task_thread_info(next)));
-#endif
-
-	/*
-	 * If the task has used fpu the last 5 timeslices, just do a full
-	 * restore of the math state immediately to avoid the trap; the
-	 * chances of needing FPU soon are obviously high now
-	 */
-	if (next->thread.fpu_counter > 5)
-		__fpu_state_restore();
-
-	return prev;
-}
-
-unsigned long __get_wchan(struct task_struct *p)
-{
-	unsigned long pc;
-
-	/*
-	 * The same comment as on the Alpha applies here, too ...
-	 */
-	pc = thread_saved_pc(p);
-
-#ifdef CONFIG_FRAME_POINTER
-	if (in_sched_functions(pc)) {
-		unsigned long schedule_frame = (unsigned long)p->thread.sp;
-		return ((unsigned long *)schedule_frame)[21];
-	}
-#endif
-
-	return pc;
-}
diff --git a/arch/sh/kernel/ptrace.c b/arch/sh/kernel/ptrace.c
deleted file mode 100644
index bfc59f2c2602f4..00000000000000
--- a/arch/sh/kernel/ptrace.c
+++ /dev/null
@@ -1,34 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/ptrace.h>
-
-/**
- * regs_query_register_offset() - query register offset from its name
- * @name:	the name of a register
- *
- * regs_query_register_offset() returns the offset of a register in struct
- * pt_regs from its name. If the name is invalid, this returns -EINVAL;
- */
-int regs_query_register_offset(const char *name)
-{
-	const struct pt_regs_offset *roff;
-	for (roff = regoffset_table; roff->name != NULL; roff++)
-		if (!strcmp(roff->name, name))
-			return roff->offset;
-	return -EINVAL;
-}
-
-/**
- * regs_query_register_name() - query register name from its offset
- * @offset:	the offset of a register in struct pt_regs.
- *
- * regs_query_register_name() returns the name of a register from its
- * offset in struct pt_regs. If the @offset is invalid, this returns NULL;
- */
-const char *regs_query_register_name(unsigned int offset)
-{
-	const struct pt_regs_offset *roff;
-	for (roff = regoffset_table; roff->name != NULL; roff++)
-		if (roff->offset == offset)
-			return roff->name;
-	return NULL;
-}
diff --git a/arch/sh/kernel/ptrace_32.c b/arch/sh/kernel/ptrace_32.c
deleted file mode 100644
index 36f50ad81e8329..00000000000000
--- a/arch/sh/kernel/ptrace_32.c
+++ /dev/null
@@ -1,487 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * SuperH process tracing
- *
- * Copyright (C) 1999, 2000  Kaz Kojima & Niibe Yutaka
- * Copyright (C) 2002 - 2009  Paul Mundt
- *
- * Audit support by Yuichi Nakamura <ynakam@hitachisoft.jp>
- */
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/sched/task_stack.h>
-#include <linux/mm.h>
-#include <linux/smp.h>
-#include <linux/errno.h>
-#include <linux/ptrace.h>
-#include <linux/user.h>
-#include <linux/security.h>
-#include <linux/signal.h>
-#include <linux/io.h>
-#include <linux/audit.h>
-#include <linux/seccomp.h>
-#include <linux/elf.h>
-#include <linux/regset.h>
-#include <linux/hw_breakpoint.h>
-#include <linux/uaccess.h>
-#include <asm/processor.h>
-#include <asm/mmu_context.h>
-#include <asm/syscalls.h>
-#include <asm/fpu.h>
-
-#define CREATE_TRACE_POINTS
-#include <trace/events/syscalls.h>
-
-/*
- * This routine will get a word off of the process kernel stack.
- */
-static inline int get_stack_long(struct task_struct *task, int offset)
-{
-	unsigned char *stack;
-
-	stack = (unsigned char *)task_pt_regs(task);
-	stack += offset;
-	return (*((int *)stack));
-}
-
-/*
- * This routine will put a word on the process kernel stack.
- */
-static inline int put_stack_long(struct task_struct *task, int offset,
-				 unsigned long data)
-{
-	unsigned char *stack;
-
-	stack = (unsigned char *)task_pt_regs(task);
-	stack += offset;
-	*(unsigned long *) stack = data;
-	return 0;
-}
-
-void ptrace_triggered(struct perf_event *bp,
-		      struct perf_sample_data *data, struct pt_regs *regs)
-{
-	struct perf_event_attr attr;
-
-	/*
-	 * Disable the breakpoint request here since ptrace has defined a
-	 * one-shot behaviour for breakpoint exceptions.
-	 */
-	attr = bp->attr;
-	attr.disabled = true;
-	modify_user_hw_breakpoint(bp, &attr);
-}
-
-static int set_single_step(struct task_struct *tsk, unsigned long addr)
-{
-	struct thread_struct *thread = &tsk->thread;
-	struct perf_event *bp;
-	struct perf_event_attr attr;
-
-	bp = thread->ptrace_bps[0];
-	if (!bp) {
-		ptrace_breakpoint_init(&attr);
-
-		attr.bp_addr = addr;
-		attr.bp_len = HW_BREAKPOINT_LEN_2;
-		attr.bp_type = HW_BREAKPOINT_R;
-
-		bp = register_user_hw_breakpoint(&attr, ptrace_triggered,
-						 NULL, tsk);
-		if (IS_ERR(bp))
-			return PTR_ERR(bp);
-
-		thread->ptrace_bps[0] = bp;
-	} else {
-		int err;
-
-		attr = bp->attr;
-		attr.bp_addr = addr;
-		/* reenable breakpoint */
-		attr.disabled = false;
-		err = modify_user_hw_breakpoint(bp, &attr);
-		if (unlikely(err))
-			return err;
-	}
-
-	return 0;
-}
-
-void user_enable_single_step(struct task_struct *child)
-{
-	unsigned long pc = get_stack_long(child, offsetof(struct pt_regs, pc));
-
-	set_tsk_thread_flag(child, TIF_SINGLESTEP);
-
-	set_single_step(child, pc);
-}
-
-void user_disable_single_step(struct task_struct *child)
-{
-	clear_tsk_thread_flag(child, TIF_SINGLESTEP);
-}
-
-/*
- * Called by kernel/ptrace.c when detaching..
- *
- * Make sure single step bits etc are not set.
- */
-void ptrace_disable(struct task_struct *child)
-{
-	user_disable_single_step(child);
-}
-
-static int genregs_get(struct task_struct *target,
-		       const struct user_regset *regset,
-		       struct membuf to)
-{
-	const struct pt_regs *regs = task_pt_regs(target);
-
-	return membuf_write(&to, regs, sizeof(struct pt_regs));
-}
-
-static int genregs_set(struct task_struct *target,
-		       const struct user_regset *regset,
-		       unsigned int pos, unsigned int count,
-		       const void *kbuf, const void __user *ubuf)
-{
-	struct pt_regs *regs = task_pt_regs(target);
-	int ret;
-
-	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
-				 regs->regs,
-				 0, 16 * sizeof(unsigned long));
-	if (!ret && count > 0)
-		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
-					 &regs->pc,
-					 offsetof(struct pt_regs, pc),
-					 sizeof(struct pt_regs));
-	if (!ret)
-		user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,
-					  sizeof(struct pt_regs), -1);
-
-	return ret;
-}
-
-#ifdef CONFIG_SH_FPU
-static int fpregs_get(struct task_struct *target,
-	       const struct user_regset *regset,
-	       struct membuf to)
-{
-	int ret;
-
-	ret = init_fpu(target);
-	if (ret)
-		return ret;
-
-	return membuf_write(&to, target->thread.xstate,
-			    sizeof(struct user_fpu_struct));
-}
-
-static int fpregs_set(struct task_struct *target,
-		       const struct user_regset *regset,
-		       unsigned int pos, unsigned int count,
-		       const void *kbuf, const void __user *ubuf)
-{
-	int ret;
-
-	ret = init_fpu(target);
-	if (ret)
-		return ret;
-
-	set_stopped_child_used_math(target);
-
-	if ((boot_cpu_data.flags & CPU_HAS_FPU))
-		return user_regset_copyin(&pos, &count, &kbuf, &ubuf,
-					  &target->thread.xstate->hardfpu, 0, -1);
-
-	return user_regset_copyin(&pos, &count, &kbuf, &ubuf,
-				  &target->thread.xstate->softfpu, 0, -1);
-}
-
-static int fpregs_active(struct task_struct *target,
-			 const struct user_regset *regset)
-{
-	return tsk_used_math(target) ? regset->n : 0;
-}
-#endif
-
-#ifdef CONFIG_SH_DSP
-static int dspregs_get(struct task_struct *target,
-		       const struct user_regset *regset,
-		       struct membuf to)
-{
-	const struct pt_dspregs *regs =
-		(struct pt_dspregs *)&target->thread.dsp_status.dsp_regs;
-
-	return membuf_write(&to, regs, sizeof(struct pt_dspregs));
-}
-
-static int dspregs_set(struct task_struct *target,
-		       const struct user_regset *regset,
-		       unsigned int pos, unsigned int count,
-		       const void *kbuf, const void __user *ubuf)
-{
-	struct pt_dspregs *regs =
-		(struct pt_dspregs *)&target->thread.dsp_status.dsp_regs;
-	int ret;
-
-	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, regs,
-				 0, sizeof(struct pt_dspregs));
-	if (!ret)
-		user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,
-					  sizeof(struct pt_dspregs), -1);
-
-	return ret;
-}
-
-static int dspregs_active(struct task_struct *target,
-			  const struct user_regset *regset)
-{
-	struct pt_regs *regs = task_pt_regs(target);
-
-	return regs->sr & SR_DSP ? regset->n : 0;
-}
-#endif
-
-const struct pt_regs_offset regoffset_table[] = {
-	REGS_OFFSET_NAME(0),
-	REGS_OFFSET_NAME(1),
-	REGS_OFFSET_NAME(2),
-	REGS_OFFSET_NAME(3),
-	REGS_OFFSET_NAME(4),
-	REGS_OFFSET_NAME(5),
-	REGS_OFFSET_NAME(6),
-	REGS_OFFSET_NAME(7),
-	REGS_OFFSET_NAME(8),
-	REGS_OFFSET_NAME(9),
-	REGS_OFFSET_NAME(10),
-	REGS_OFFSET_NAME(11),
-	REGS_OFFSET_NAME(12),
-	REGS_OFFSET_NAME(13),
-	REGS_OFFSET_NAME(14),
-	REGS_OFFSET_NAME(15),
-	REG_OFFSET_NAME(pc),
-	REG_OFFSET_NAME(pr),
-	REG_OFFSET_NAME(sr),
-	REG_OFFSET_NAME(gbr),
-	REG_OFFSET_NAME(mach),
-	REG_OFFSET_NAME(macl),
-	REG_OFFSET_NAME(tra),
-	REG_OFFSET_END,
-};
-
-/*
- * These are our native regset flavours.
- */
-enum sh_regset {
-	REGSET_GENERAL,
-#ifdef CONFIG_SH_FPU
-	REGSET_FPU,
-#endif
-#ifdef CONFIG_SH_DSP
-	REGSET_DSP,
-#endif
-};
-
-static const struct user_regset sh_regsets[] = {
-	/*
-	 * Format is:
-	 *	R0 --> R15
-	 *	PC, PR, SR, GBR, MACH, MACL, TRA
-	 */
-	[REGSET_GENERAL] = {
-		.core_note_type	= NT_PRSTATUS,
-		.n		= ELF_NGREG,
-		.size		= sizeof(long),
-		.align		= sizeof(long),
-		.regset_get		= genregs_get,
-		.set		= genregs_set,
-	},
-
-#ifdef CONFIG_SH_FPU
-	[REGSET_FPU] = {
-		.core_note_type	= NT_PRFPREG,
-		.n		= sizeof(struct user_fpu_struct) / sizeof(long),
-		.size		= sizeof(long),
-		.align		= sizeof(long),
-		.regset_get		= fpregs_get,
-		.set		= fpregs_set,
-		.active		= fpregs_active,
-	},
-#endif
-
-#ifdef CONFIG_SH_DSP
-	[REGSET_DSP] = {
-		.n		= sizeof(struct pt_dspregs) / sizeof(long),
-		.size		= sizeof(long),
-		.align		= sizeof(long),
-		.regset_get		= dspregs_get,
-		.set		= dspregs_set,
-		.active		= dspregs_active,
-	},
-#endif
-};
-
-static const struct user_regset_view user_sh_native_view = {
-	.name		= "sh",
-	.e_machine	= EM_SH,
-	.regsets	= sh_regsets,
-	.n		= ARRAY_SIZE(sh_regsets),
-};
-
-const struct user_regset_view *task_user_regset_view(struct task_struct *task)
-{
-	return &user_sh_native_view;
-}
-
-long arch_ptrace(struct task_struct *child, long request,
-		 unsigned long addr, unsigned long data)
-{
-	unsigned long __user *datap = (unsigned long __user *)data;
-	int ret;
-
-	switch (request) {
-	/* read the word at location addr in the USER area. */
-	case PTRACE_PEEKUSR: {
-		unsigned long tmp;
-
-		ret = -EIO;
-		if ((addr & 3) || addr < 0 ||
-		    addr > sizeof(struct user) - 3)
-			break;
-
-		if (addr < sizeof(struct pt_regs))
-			tmp = get_stack_long(child, addr);
-		else if (addr >= offsetof(struct user, fpu) &&
-			 addr < offsetof(struct user, u_fpvalid)) {
-			if (!tsk_used_math(child)) {
-				if (addr == offsetof(struct user, fpu.fpscr))
-					tmp = FPSCR_INIT;
-				else
-					tmp = 0;
-			} else {
-				unsigned long index;
-				ret = init_fpu(child);
-				if (ret)
-					break;
-				index = addr - offsetof(struct user, fpu);
-				tmp = ((unsigned long *)child->thread.xstate)
-					[index >> 2];
-			}
-		} else if (addr == offsetof(struct user, u_fpvalid))
-			tmp = !!tsk_used_math(child);
-		else if (addr == PT_TEXT_ADDR)
-			tmp = child->mm->start_code;
-		else if (addr == PT_DATA_ADDR)
-			tmp = child->mm->start_data;
-		else if (addr == PT_TEXT_END_ADDR)
-			tmp = child->mm->end_code;
-		else if (addr == PT_TEXT_LEN)
-			tmp = child->mm->end_code - child->mm->start_code;
-		else
-			tmp = 0;
-		ret = put_user(tmp, datap);
-		break;
-	}
-
-	case PTRACE_POKEUSR: /* write the word at location addr in the USER area */
-		ret = -EIO;
-		if ((addr & 3) || addr < 0 ||
-		    addr > sizeof(struct user) - 3)
-			break;
-
-		if (addr < sizeof(struct pt_regs))
-			ret = put_stack_long(child, addr, data);
-		else if (addr >= offsetof(struct user, fpu) &&
-			 addr < offsetof(struct user, u_fpvalid)) {
-			unsigned long index;
-			ret = init_fpu(child);
-			if (ret)
-				break;
-			index = addr - offsetof(struct user, fpu);
-			set_stopped_child_used_math(child);
-			((unsigned long *)child->thread.xstate)
-				[index >> 2] = data;
-			ret = 0;
-		} else if (addr == offsetof(struct user, u_fpvalid)) {
-			conditional_stopped_child_used_math(data, child);
-			ret = 0;
-		}
-		break;
-
-	case PTRACE_GETREGS:
-		return copy_regset_to_user(child, &user_sh_native_view,
-					   REGSET_GENERAL,
-					   0, sizeof(struct pt_regs),
-					   datap);
-	case PTRACE_SETREGS:
-		return copy_regset_from_user(child, &user_sh_native_view,
-					     REGSET_GENERAL,
-					     0, sizeof(struct pt_regs),
-					     datap);
-#ifdef CONFIG_SH_FPU
-	case PTRACE_GETFPREGS:
-		return copy_regset_to_user(child, &user_sh_native_view,
-					   REGSET_FPU,
-					   0, sizeof(struct user_fpu_struct),
-					   datap);
-	case PTRACE_SETFPREGS:
-		return copy_regset_from_user(child, &user_sh_native_view,
-					     REGSET_FPU,
-					     0, sizeof(struct user_fpu_struct),
-					     datap);
-#endif
-#ifdef CONFIG_SH_DSP
-	case PTRACE_GETDSPREGS:
-		return copy_regset_to_user(child, &user_sh_native_view,
-					   REGSET_DSP,
-					   0, sizeof(struct pt_dspregs),
-					   datap);
-	case PTRACE_SETDSPREGS:
-		return copy_regset_from_user(child, &user_sh_native_view,
-					     REGSET_DSP,
-					     0, sizeof(struct pt_dspregs),
-					     datap);
-#endif
-	default:
-		ret = ptrace_request(child, request, addr, data);
-		break;
-	}
-
-	return ret;
-}
-
-asmlinkage long do_syscall_trace_enter(struct pt_regs *regs)
-{
-	if (test_thread_flag(TIF_SYSCALL_TRACE) &&
-	    ptrace_report_syscall_entry(regs)) {
-		regs->regs[0] = -ENOSYS;
-		return -1;
-	}
-
-	if (secure_computing() == -1)
-		return -1;
-
-	if (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))
-		trace_sys_enter(regs, regs->regs[0]);
-
-	audit_syscall_entry(regs->regs[3], regs->regs[4], regs->regs[5],
-			    regs->regs[6], regs->regs[7]);
-
-	return 0;
-}
-
-asmlinkage void do_syscall_trace_leave(struct pt_regs *regs)
-{
-	int step;
-
-	audit_syscall_exit(regs);
-
-	if (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))
-		trace_sys_exit(regs, regs->regs[0]);
-
-	step = test_thread_flag(TIF_SINGLESTEP);
-	if (step || test_thread_flag(TIF_SYSCALL_TRACE))
-		ptrace_report_syscall_exit(regs, step);
-}
diff --git a/arch/sh/kernel/reboot.c b/arch/sh/kernel/reboot.c
deleted file mode 100644
index e8eeedc9b1822d..00000000000000
--- a/arch/sh/kernel/reboot.c
+++ /dev/null
@@ -1,96 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/pm.h>
-#include <linux/kexec.h>
-#include <linux/kernel.h>
-#include <linux/reboot.h>
-#include <linux/module.h>
-#include <asm/watchdog.h>
-#include <asm/addrspace.h>
-#include <asm/reboot.h>
-#include <asm/tlbflush.h>
-#include <asm/traps.h>
-
-void (*pm_power_off)(void);
-EXPORT_SYMBOL(pm_power_off);
-
-static void watchdog_trigger_immediate(void)
-{
-	sh_wdt_write_cnt(0xFF);
-	sh_wdt_write_csr(0xC2);
-}
-
-static void native_machine_restart(char * __unused)
-{
-	local_irq_disable();
-
-	/* Destroy all of the TLBs in preparation for reset by MMU */
-	__flush_tlb_global();
-
-	/* Address error with SR.BL=1 first. */
-	trigger_address_error();
-
-	/* If that fails or is unsupported, go for the watchdog next. */
-	watchdog_trigger_immediate();
-
-	/*
-	 * Give up and sleep.
-	 */
-	while (1)
-		cpu_sleep();
-}
-
-static void native_machine_shutdown(void)
-{
-	smp_send_stop();
-}
-
-static void native_machine_power_off(void)
-{
-	do_kernel_power_off();
-}
-
-static void native_machine_halt(void)
-{
-	/* stop other cpus */
-	machine_shutdown();
-
-	/* stop this cpu */
-	stop_this_cpu(NULL);
-}
-
-struct machine_ops machine_ops = {
-	.power_off	= native_machine_power_off,
-	.shutdown	= native_machine_shutdown,
-	.restart	= native_machine_restart,
-	.halt		= native_machine_halt,
-#ifdef CONFIG_KEXEC
-	.crash_shutdown = native_machine_crash_shutdown,
-#endif
-};
-
-void machine_power_off(void)
-{
-	machine_ops.power_off();
-}
-
-void machine_shutdown(void)
-{
-	machine_ops.shutdown();
-}
-
-void machine_restart(char *cmd)
-{
-	machine_ops.restart(cmd);
-}
-
-void machine_halt(void)
-{
-	machine_ops.halt();
-}
-
-#ifdef CONFIG_KEXEC
-void machine_crash_shutdown(struct pt_regs *regs)
-{
-	machine_ops.crash_shutdown(regs);
-}
-#endif
diff --git a/arch/sh/kernel/relocate_kernel.S b/arch/sh/kernel/relocate_kernel.S
deleted file mode 100644
index d9bf2b727b429e..00000000000000
--- a/arch/sh/kernel/relocate_kernel.S
+++ /dev/null
@@ -1,230 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * relocate_kernel.S - put the kernel image in place to boot
- * 2005.9.17 kogiidena@eggplant.ddo.jp
- *
- * LANDISK/sh4 is supported. Maybe, SH archtecture works well.
- *
- * 2009-03-18 Magnus Damm - Added Kexec Jump support
- */
-#include <linux/linkage.h>
-#include <asm/addrspace.h>
-#include <asm/page.h>
-
-		.globl relocate_new_kernel
-relocate_new_kernel:
-	/* r4 = indirection_page   */
-	/* r5 = reboot_code_buffer */
-	/* r6 = start_address      */
-
-	mov.l	10f, r0		/* PAGE_SIZE */
-	add	r5, r0		/* setup new stack at end of control page */
-
-	/* save r15->r8 to new stack */
-	mov.l	r15, @-r0
-	mov	r0, r15
-	mov.l	r14, @-r15
-	mov.l	r13, @-r15
-	mov.l	r12, @-r15
-	mov.l	r11, @-r15
-	mov.l	r10, @-r15
-	mov.l	r9, @-r15
-	mov.l	r8, @-r15
-
-	/* save other random registers */
-	sts.l	macl, @-r15
-	sts.l	mach, @-r15
-	stc.l	gbr, @-r15
-	stc.l	ssr, @-r15
-	stc.l	sr, @-r15
-	sts.l	pr, @-r15
-	stc.l	spc, @-r15
-
-	/* switch to bank1 and save r7->r0 */
-	mov.l	12f, r9
-	stc	sr, r8
-	or	r9, r8
-	ldc	r8, sr
-	mov.l	r7, @-r15
-	mov.l	r6, @-r15
-	mov.l	r5, @-r15
-	mov.l	r4, @-r15
-	mov.l	r3, @-r15
-	mov.l	r2, @-r15
-	mov.l	r1, @-r15
-	mov.l	r0, @-r15
-
-	/* switch to bank0 and save r7->r0 */
-	mov.l	12f, r9
-	not	r9, r9
-	stc	sr, r8
-	and	r9, r8
-	ldc	r8, sr
-	mov.l	r7, @-r15
-	mov.l	r6, @-r15
-	mov.l	r5, @-r15
-	mov.l	r4, @-r15
-	mov.l	r3, @-r15
-	mov.l	r2, @-r15
-	mov.l	r1, @-r15
-	mov.l	r0, @-r15
-
-	mov.l	r4, @-r15	/* save indirection page again */
-
-	bsr	swap_pages	/* swap pages before jumping to new kernel */
-	 nop
-
-	mova	11f, r0
-	mov.l	r15, @r0	/* save pointer to stack */
-
-	jsr	@r6		/* hand over control to new kernel */
-	 nop
-
-	mov.l	11f, r15	/* get pointer to stack */
-	mov.l	@r15+, r4	/* restore r4 to get indirection page */
-
-	bsr	swap_pages	/* swap pages back to previous state */
-	 nop
-
-	/* make sure bank0 is active and restore r0->r7 */
-	mov.l	12f, r9
-	not	r9, r9
-	stc	sr, r8
-	and	r9, r8
-	ldc	r8, sr
-	mov.l	@r15+, r0
-	mov.l	@r15+, r1
-	mov.l	@r15+, r2
-	mov.l	@r15+, r3
-	mov.l	@r15+, r4
-	mov.l	@r15+, r5
-	mov.l	@r15+, r6
-	mov.l	@r15+, r7
-
-	/* switch to bank1 and restore r0->r7 */
-	mov.l	12f, r9
-	stc	sr, r8
-	or	r9, r8
-	ldc	r8, sr
-	mov.l	@r15+, r0
-	mov.l	@r15+, r1
-	mov.l	@r15+, r2
-	mov.l	@r15+, r3
-	mov.l	@r15+, r4
-	mov.l	@r15+, r5
-	mov.l	@r15+, r6
-	mov.l	@r15+, r7
-
-	/* switch back to bank0 */
-	mov.l	12f, r9
-	not	r9, r9
-	stc	sr, r8
-	and	r9, r8
-	ldc	r8, sr
-
-	/* restore other random registers */
-	ldc.l	@r15+, spc
-	lds.l	@r15+, pr
-	ldc.l	@r15+, sr
-	ldc.l	@r15+, ssr
-	ldc.l	@r15+, gbr
-	lds.l	@r15+, mach
-	lds.l	@r15+, macl
-
-	/* restore r8->r15 */
-	mov.l	@r15+, r8
-	mov.l	@r15+, r9
-	mov.l	@r15+, r10
-	mov.l	@r15+, r11
-	mov.l	@r15+, r12
-	mov.l	@r15+, r13
-	mov.l	@r15+, r14
-	mov.l	@r15+, r15
-	rts
-	 nop
-
-swap_pages:
-	bra	1f
-	 mov	r4,r0	  /* cmd = indirection_page */
-0:
-	mov.l	@r4+,r0	  /* cmd = *ind++ */
-
-1:	/* addr = cmd & 0xfffffff0 */
-	mov	r0,r2
-	mov	#-16,r1
-	and	r1,r2
-
-	/* if(cmd & IND_DESTINATION) dst = addr  */
-	tst	#1,r0
-	bt	2f
-	bra	0b
-	 mov	r2,r5
-
-2:	/* else if(cmd & IND_INDIRECTION) ind = addr  */
-	tst	#2,r0
-	bt	3f
-	bra	0b
-	 mov	r2,r4
-
-3:	/* else if(cmd & IND_DONE) return */
-	tst	#4,r0
-	bt	4f
-	rts
-	 nop
-
-4:	/* else if(cmd & IND_SOURCE) memcpy(dst,addr,PAGE_SIZE) */
-	tst	#8,r0
-	bt	0b
-
-	mov.l	10f,r3	  /* PAGE_SIZE */
-	shlr2	r3
-	shlr2	r3
-5:
-	dt	r3
-
-	/* regular kexec just overwrites the destination page
-	 * with the contents of the source page.
-	 * for the kexec jump case we need to swap the contents
-	 * of the pages.
-	 * to keep it simple swap the contents for both cases.
-	 */
-	mov.l	@(0, r2), r8
-	mov.l	@(0, r5), r1
-	mov.l	r8, @(0, r5)
-	mov.l	r1, @(0, r2)
-
-	mov.l	@(4, r2), r8
-	mov.l	@(4, r5), r1
-	mov.l	r8, @(4, r5)
-	mov.l	r1, @(4, r2)
-
-	mov.l	@(8, r2), r8
-	mov.l	@(8, r5), r1
-	mov.l	r8, @(8, r5)
-	mov.l	r1, @(8, r2)
-
-	mov.l	@(12, r2), r8
-	mov.l	@(12, r5), r1
-	mov.l	r8, @(12, r5)
-	mov.l	r1, @(12, r2)
-
-	add	#16,r5
-	add	#16,r2
-	bf	5b
-
-	bra	0b
-	 nop
-
-	.align 2
-10:
-	.long	PAGE_SIZE
-11:
-	.long	0
-12:
-	.long	0x20000000 ! RB=1
-
-relocate_new_kernel_end:
-
-	.globl relocate_new_kernel_size
-relocate_new_kernel_size:
-	.long relocate_new_kernel_end - relocate_new_kernel
diff --git a/arch/sh/kernel/return_address.c b/arch/sh/kernel/return_address.c
deleted file mode 100644
index 8838094c9ff944..00000000000000
--- a/arch/sh/kernel/return_address.c
+++ /dev/null
@@ -1,56 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/return_address.c
- *
- * Copyright (C) 2009  Matt Fleming
- * Copyright (C) 2009  Paul Mundt
- */
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <asm/dwarf.h>
-
-#ifdef CONFIG_DWARF_UNWINDER
-
-void *return_address(unsigned int depth)
-{
-	struct dwarf_frame *frame;
-	unsigned long ra;
-	int i;
-
-	for (i = 0, frame = NULL, ra = 0; i <= depth; i++) {
-		struct dwarf_frame *tmp;
-
-		tmp = dwarf_unwind_stack(ra, frame);
-		if (!tmp)
-			return NULL;
-
-		if (frame)
-			dwarf_free_frame(frame);
-
-		frame = tmp;
-
-		if (!frame || !frame->return_addr)
-			break;
-
-		ra = frame->return_addr;
-	}
-
-	/* Failed to unwind the stack to the specified depth. */
-	WARN_ON(i != depth + 1);
-
-	if (frame)
-		dwarf_free_frame(frame);
-
-	return (void *)ra;
-}
-
-#else
-
-void *return_address(unsigned int depth)
-{
-	return NULL;
-}
-
-#endif
-
-EXPORT_SYMBOL_GPL(return_address);
diff --git a/arch/sh/kernel/setup.c b/arch/sh/kernel/setup.c
deleted file mode 100644
index 1fcb6659822a30..00000000000000
--- a/arch/sh/kernel/setup.c
+++ /dev/null
@@ -1,356 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/setup.c
- *
- * This file handles the architecture-dependent parts of initialization
- *
- *  Copyright (C) 1999  Niibe Yutaka
- *  Copyright (C) 2002 - 2010 Paul Mundt
- */
-#include <linux/screen_info.h>
-#include <linux/ioport.h>
-#include <linux/init.h>
-#include <linux/initrd.h>
-#include <linux/console.h>
-#include <linux/root_dev.h>
-#include <linux/utsname.h>
-#include <linux/nodemask.h>
-#include <linux/cpu.h>
-#include <linux/pfn.h>
-#include <linux/fs.h>
-#include <linux/mm.h>
-#include <linux/kexec.h>
-#include <linux/module.h>
-#include <linux/smp.h>
-#include <linux/err.h>
-#include <linux/crash_dump.h>
-#include <linux/mmzone.h>
-#include <linux/clk.h>
-#include <linux/delay.h>
-#include <linux/platform_device.h>
-#include <linux/memblock.h>
-#include <linux/of.h>
-#include <linux/of_fdt.h>
-#include <linux/uaccess.h>
-#include <uapi/linux/mount.h>
-#include <asm/io.h>
-#include <asm/page.h>
-#include <asm/elf.h>
-#include <asm/sections.h>
-#include <asm/irq.h>
-#include <asm/setup.h>
-#include <asm/clock.h>
-#include <asm/smp.h>
-#include <asm/mmu_context.h>
-#include <asm/mmzone.h>
-#include <asm/sparsemem.h>
-#include <asm/platform_early.h>
-
-/*
- * Initialize loops_per_jiffy as 10000000 (1000MIPS).
- * This value will be used at the very early stage of serial setup.
- * The bigger value means no problem.
- */
-struct sh_cpuinfo cpu_data[NR_CPUS] __read_mostly = {
-	[0] = {
-		.type			= CPU_SH_NONE,
-		.family			= CPU_FAMILY_UNKNOWN,
-		.loops_per_jiffy	= 10000000,
-		.phys_bits		= MAX_PHYSMEM_BITS,
-	},
-};
-EXPORT_SYMBOL(cpu_data);
-
-/*
- * The machine vector. First entry in .machvec.init, or clobbered by
- * sh_mv= on the command line, prior to .machvec.init teardown.
- */
-struct sh_machine_vector sh_mv = { .mv_name = "generic", };
-EXPORT_SYMBOL(sh_mv);
-
-#ifdef CONFIG_VT
-struct screen_info screen_info;
-#endif
-
-extern int root_mountflags;
-
-#define RAMDISK_IMAGE_START_MASK	0x07FF
-#define RAMDISK_PROMPT_FLAG		0x8000
-#define RAMDISK_LOAD_FLAG		0x4000
-
-static char __initdata command_line[COMMAND_LINE_SIZE] = { 0, };
-
-static struct resource code_resource = {
-	.name = "Kernel code",
-	.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,
-};
-
-static struct resource data_resource = {
-	.name = "Kernel data",
-	.flags = IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,
-};
-
-static struct resource bss_resource = {
-	.name	= "Kernel bss",
-	.flags	= IORESOURCE_BUSY | IORESOURCE_SYSTEM_RAM,
-};
-
-unsigned long memory_start;
-EXPORT_SYMBOL(memory_start);
-unsigned long memory_end = 0;
-EXPORT_SYMBOL(memory_end);
-unsigned long memory_limit = 0;
-
-static struct resource mem_resources[MAX_NUMNODES];
-
-int l1i_cache_shape, l1d_cache_shape, l2_cache_shape;
-
-static int __init early_parse_mem(char *p)
-{
-	if (!p)
-		return 1;
-
-	memory_limit = PAGE_ALIGN(memparse(p, &p));
-
-	pr_notice("Memory limited to %ldMB\n", memory_limit >> 20);
-
-	return 0;
-}
-early_param("mem", early_parse_mem);
-
-void __init check_for_initrd(void)
-{
-#ifdef CONFIG_BLK_DEV_INITRD
-	unsigned long start, end;
-
-	/*
-	 * Check for the rare cases where boot loaders adhere to the boot
-	 * ABI.
-	 */
-	if (!LOADER_TYPE || !INITRD_START || !INITRD_SIZE)
-		goto disable;
-
-	start = INITRD_START + __MEMORY_START;
-	end = start + INITRD_SIZE;
-
-	if (unlikely(end <= start))
-		goto disable;
-	if (unlikely(start & ~PAGE_MASK)) {
-		pr_err("initrd must be page aligned\n");
-		goto disable;
-	}
-
-	if (unlikely(start < __MEMORY_START)) {
-		pr_err("initrd start (%08lx) < __MEMORY_START(%x)\n",
-			start, __MEMORY_START);
-		goto disable;
-	}
-
-	if (unlikely(end > memblock_end_of_DRAM())) {
-		pr_err("initrd extends beyond end of memory "
-		       "(0x%08lx > 0x%08lx)\ndisabling initrd\n",
-		       end, (unsigned long)memblock_end_of_DRAM());
-		goto disable;
-	}
-
-	/*
-	 * If we got this far in spite of the boot loader's best efforts
-	 * to the contrary, assume we actually have a valid initrd and
-	 * fix up the root dev.
-	 */
-	ROOT_DEV = Root_RAM0;
-
-	/*
-	 * Address sanitization
-	 */
-	initrd_start = (unsigned long)__va(start);
-	initrd_end = initrd_start + INITRD_SIZE;
-
-	memblock_reserve(__pa(initrd_start), INITRD_SIZE);
-
-	return;
-
-disable:
-	pr_info("initrd disabled\n");
-	initrd_start = initrd_end = 0;
-#endif
-}
-
-#ifndef CONFIG_GENERIC_CALIBRATE_DELAY
-void calibrate_delay(void)
-{
-	struct clk *clk = clk_get(NULL, "cpu_clk");
-
-	if (IS_ERR(clk))
-		panic("Need a sane CPU clock definition!");
-
-	loops_per_jiffy = (clk_get_rate(clk) >> 1) / HZ;
-
-	printk(KERN_INFO "Calibrating delay loop (skipped)... "
-			 "%lu.%02lu BogoMIPS PRESET (lpj=%lu)\n",
-			 loops_per_jiffy/(500000/HZ),
-			 (loops_per_jiffy/(5000/HZ)) % 100,
-			 loops_per_jiffy);
-}
-#endif
-
-void __init __add_active_range(unsigned int nid, unsigned long start_pfn,
-						unsigned long end_pfn)
-{
-	struct resource *res = &mem_resources[nid];
-	unsigned long start, end;
-
-	WARN_ON(res->name); /* max one active range per node for now */
-
-	start = start_pfn << PAGE_SHIFT;
-	end = end_pfn << PAGE_SHIFT;
-
-	res->name = "System RAM";
-	res->start = start;
-	res->end = end - 1;
-	res->flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;
-
-	if (request_resource(&iomem_resource, res)) {
-		pr_err("unable to request memory_resource 0x%lx 0x%lx\n",
-		       start_pfn, end_pfn);
-		return;
-	}
-
-	/*
-	 * We don't know which RAM region contains kernel data or
-	 * the reserved crashkernel region, so try it repeatedly
-	 * and let the resource manager test it.
-	 */
-	request_resource(res, &code_resource);
-	request_resource(res, &data_resource);
-	request_resource(res, &bss_resource);
-#ifdef CONFIG_KEXEC
-	request_resource(res, &crashk_res);
-#endif
-
-	/*
-	 * Also make sure that there is a PMB mapping that covers this
-	 * range before we attempt to activate it, to avoid reset by MMU.
-	 * We can hit this path with NUMA or memory hot-add.
-	 */
-	pmb_bolt_mapping((unsigned long)__va(start), start, end - start,
-			 PAGE_KERNEL);
-
-	memblock_set_node(PFN_PHYS(start_pfn), PFN_PHYS(end_pfn - start_pfn),
-			  &memblock.memory, nid);
-}
-
-void __init __weak plat_early_device_setup(void)
-{
-}
-
-#ifdef CONFIG_OF_FLATTREE
-void __ref sh_fdt_init(phys_addr_t dt_phys)
-{
-	static int done = 0;
-	void *dt_virt;
-
-	/* Avoid calling an __init function on secondary cpus. */
-	if (done) return;
-
-#ifdef CONFIG_USE_BUILTIN_DTB
-	dt_virt = __dtb_start;
-#else
-	dt_virt = phys_to_virt(dt_phys);
-#endif
-
-	if (!dt_virt || !early_init_dt_scan(dt_virt)) {
-		pr_crit("Error: invalid device tree blob"
-			" at physical address %p\n", (void *)dt_phys);
-
-		while (true)
-			cpu_relax();
-	}
-
-	done = 1;
-}
-#endif
-
-void __init setup_arch(char **cmdline_p)
-{
-	enable_mmu();
-
-	ROOT_DEV = old_decode_dev(ORIG_ROOT_DEV);
-
-	printk(KERN_NOTICE "Boot params:\n"
-			   "... MOUNT_ROOT_RDONLY - %08lx\n"
-			   "... RAMDISK_FLAGS     - %08lx\n"
-			   "... ORIG_ROOT_DEV     - %08lx\n"
-			   "... LOADER_TYPE       - %08lx\n"
-			   "... INITRD_START      - %08lx\n"
-			   "... INITRD_SIZE       - %08lx\n",
-			   MOUNT_ROOT_RDONLY, RAMDISK_FLAGS,
-			   ORIG_ROOT_DEV, LOADER_TYPE,
-			   INITRD_START, INITRD_SIZE);
-
-#ifdef CONFIG_BLK_DEV_RAM
-	rd_image_start = RAMDISK_FLAGS & RAMDISK_IMAGE_START_MASK;
-#endif
-
-	if (!MOUNT_ROOT_RDONLY)
-		root_mountflags &= ~MS_RDONLY;
-	setup_initial_init_mm(_text, _etext, _edata, _end);
-
-	code_resource.start = virt_to_phys(_text);
-	code_resource.end = virt_to_phys(_etext)-1;
-	data_resource.start = virt_to_phys(_etext);
-	data_resource.end = virt_to_phys(_edata)-1;
-	bss_resource.start = virt_to_phys(__bss_start);
-	bss_resource.end = virt_to_phys(__bss_stop)-1;
-
-#ifdef CONFIG_CMDLINE_OVERWRITE
-	strlcpy(command_line, CONFIG_CMDLINE, sizeof(command_line));
-#else
-	strlcpy(command_line, COMMAND_LINE, sizeof(command_line));
-#ifdef CONFIG_CMDLINE_EXTEND
-	strlcat(command_line, " ", sizeof(command_line));
-	strlcat(command_line, CONFIG_CMDLINE, sizeof(command_line));
-#endif
-#endif
-
-	/* Save unparsed command line copy for /proc/cmdline */
-	memcpy(boot_command_line, command_line, COMMAND_LINE_SIZE);
-	*cmdline_p = command_line;
-
-	parse_early_param();
-
-	plat_early_device_setup();
-
-	sh_mv_setup();
-
-	/* Let earlyprintk output early console messages */
-	sh_early_platform_driver_probe("earlyprintk", 1, 1);
-
-#ifdef CONFIG_OF_FLATTREE
-#ifdef CONFIG_USE_BUILTIN_DTB
-	unflatten_and_copy_device_tree();
-#else
-	unflatten_device_tree();
-#endif
-#endif
-
-	paging_init();
-
-	/* Perform the machine specific initialisation */
-	if (likely(sh_mv.mv_setup))
-		sh_mv.mv_setup(cmdline_p);
-
-	plat_smp_setup();
-}
-
-/* processor boot mode configuration */
-int generic_mode_pins(void)
-{
-	pr_warn("generic_mode_pins(): missing mode pin configuration\n");
-	return 0;
-}
-
-int test_mode_pin(int pin)
-{
-	return sh_mv.mv_mode_pins() & pin;
-}
diff --git a/arch/sh/kernel/sh_bios.c b/arch/sh/kernel/sh_bios.c
deleted file mode 100644
index 250dbdf3fa7497..00000000000000
--- a/arch/sh/kernel/sh_bios.c
+++ /dev/null
@@ -1,169 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- *  C interface for trapping into the standard LinuxSH BIOS.
- *
- *  Copyright (C) 2000 Greg Banks, Mitch Davis
- *  Copyright (C) 1999, 2000  Niibe Yutaka
- *  Copyright (C) 2002  M. R. Brown
- *  Copyright (C) 2004 - 2010  Paul Mundt
- */
-#include <linux/module.h>
-#include <linux/console.h>
-#include <linux/tty.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/delay.h>
-#include <asm/sh_bios.h>
-
-#define BIOS_CALL_CONSOLE_WRITE		0
-#define BIOS_CALL_ETH_NODE_ADDR		10
-#define BIOS_CALL_SHUTDOWN		11
-#define BIOS_CALL_GDB_DETACH		0xff
-
-void *gdb_vbr_vector = NULL;
-
-static inline long sh_bios_call(long func, long arg0, long arg1, long arg2,
-				    long arg3)
-{
-	register long r0 __asm__("r0") = func;
-	register long r4 __asm__("r4") = arg0;
-	register long r5 __asm__("r5") = arg1;
-	register long r6 __asm__("r6") = arg2;
-	register long r7 __asm__("r7") = arg3;
-
-	if (!gdb_vbr_vector)
-		return -ENOSYS;
-
-	__asm__ __volatile__("trapa	#0x3f":"=z"(r0)
-			     :"0"(r0), "r"(r4), "r"(r5), "r"(r6), "r"(r7)
-			     :"memory");
-	return r0;
-}
-
-void sh_bios_console_write(const char *buf, unsigned int len)
-{
-	sh_bios_call(BIOS_CALL_CONSOLE_WRITE, (long)buf, (long)len, 0, 0);
-}
-
-void sh_bios_gdb_detach(void)
-{
-	sh_bios_call(BIOS_CALL_GDB_DETACH, 0, 0, 0, 0);
-}
-EXPORT_SYMBOL_GPL(sh_bios_gdb_detach);
-
-void sh_bios_get_node_addr(unsigned char *node_addr)
-{
-	sh_bios_call(BIOS_CALL_ETH_NODE_ADDR, 0, (long)node_addr, 0, 0);
-}
-EXPORT_SYMBOL_GPL(sh_bios_get_node_addr);
-
-void sh_bios_shutdown(unsigned int how)
-{
-	sh_bios_call(BIOS_CALL_SHUTDOWN, how, 0, 0, 0);
-}
-
-/*
- * Read the old value of the VBR register to initialise the vector
- * through which debug and BIOS traps are delegated by the Linux trap
- * handler.
- */
-void sh_bios_vbr_init(void)
-{
-	unsigned long vbr;
-
-	if (unlikely(gdb_vbr_vector))
-		return;
-
-	__asm__ __volatile__ ("stc vbr, %0" : "=r" (vbr));
-
-	if (vbr) {
-		gdb_vbr_vector = (void *)(vbr + 0x100);
-		printk(KERN_NOTICE "Setting GDB trap vector to %p\n",
-		       gdb_vbr_vector);
-	} else
-		printk(KERN_NOTICE "SH-BIOS not detected\n");
-}
-
-/**
- * sh_bios_vbr_reload - Re-load the system VBR from the BIOS vector.
- *
- * This can be used by save/restore code to reinitialize the system VBR
- * from the fixed BIOS VBR. A no-op if no BIOS VBR is known.
- */
-void sh_bios_vbr_reload(void)
-{
-	if (gdb_vbr_vector)
-		__asm__ __volatile__ (
-			"ldc %0, vbr"
-			:
-			: "r" (((unsigned long) gdb_vbr_vector) - 0x100)
-			: "memory"
-		);
-}
-
-#ifdef CONFIG_EARLY_PRINTK
-/*
- *	Print a string through the BIOS
- */
-static void sh_console_write(struct console *co, const char *s,
-				 unsigned count)
-{
-	sh_bios_console_write(s, count);
-}
-
-/*
- *	Setup initial baud/bits/parity. We do two things here:
- *	- construct a cflag setting for the first rs_open()
- *	- initialize the serial port
- *	Return non-zero if we didn't find a serial port.
- */
-static int __init sh_console_setup(struct console *co, char *options)
-{
-	int	cflag = CREAD | HUPCL | CLOCAL;
-
-	/*
-	 *	Now construct a cflag setting.
-	 *	TODO: this is a totally bogus cflag, as we have
-	 *	no idea what serial settings the BIOS is using, or
-	 *	even if its using the serial port at all.
-	 */
-	cflag |= B115200 | CS8 | /*no parity*/0;
-
-	co->cflag = cflag;
-
-	return 0;
-}
-
-static struct console bios_console = {
-	.name		= "bios",
-	.write		= sh_console_write,
-	.setup		= sh_console_setup,
-	.flags		= CON_PRINTBUFFER,
-	.index		= -1,
-};
-
-static int __init setup_early_printk(char *buf)
-{
-	int keep_early = 0;
-
-	if (!buf)
-		return 0;
-
-	if (strstr(buf, "keep"))
-		keep_early = 1;
-
-	if (!strncmp(buf, "bios", 4))
-		early_console = &bios_console;
-
-	if (likely(early_console)) {
-		if (keep_early)
-			early_console->flags &= ~CON_BOOT;
-		else
-			early_console->flags |= CON_BOOT;
-		register_console(early_console);
-	}
-
-	return 0;
-}
-early_param("earlyprintk", setup_early_printk);
-#endif
diff --git a/arch/sh/kernel/sh_ksyms_32.c b/arch/sh/kernel/sh_ksyms_32.c
deleted file mode 100644
index 5858936cb43111..00000000000000
--- a/arch/sh/kernel/sh_ksyms_32.c
+++ /dev/null
@@ -1,118 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/module.h>
-#include <linux/string.h>
-#include <linux/uaccess.h>
-#include <linux/delay.h>
-#include <linux/mm.h>
-#include <asm/checksum.h>
-#include <asm/sections.h>
-
-EXPORT_SYMBOL(memchr);
-EXPORT_SYMBOL(memcpy);
-EXPORT_SYMBOL(memset);
-EXPORT_SYMBOL(memmove);
-EXPORT_SYMBOL(__copy_user);
-EXPORT_SYMBOL(__udelay);
-EXPORT_SYMBOL(__ndelay);
-EXPORT_SYMBOL(__const_udelay);
-EXPORT_SYMBOL(strlen);
-EXPORT_SYMBOL(csum_partial);
-EXPORT_SYMBOL(csum_partial_copy_generic);
-EXPORT_SYMBOL(copy_page);
-EXPORT_SYMBOL(__clear_user);
-EXPORT_SYMBOL(empty_zero_page);
-#ifdef CONFIG_FLATMEM
-/* need in pfn_valid macro */
-EXPORT_SYMBOL(min_low_pfn);
-EXPORT_SYMBOL(max_low_pfn);
-#endif
-
-#define DECLARE_EXPORT(name)		\
-	extern void name(void);EXPORT_SYMBOL(name)
-
-DECLARE_EXPORT(__udivsi3);
-DECLARE_EXPORT(__sdivsi3);
-DECLARE_EXPORT(__lshrsi3);
-DECLARE_EXPORT(__ashrsi3);
-DECLARE_EXPORT(__ashlsi3);
-DECLARE_EXPORT(__lshrsi3_r0);
-DECLARE_EXPORT(__ashrsi3_r0);
-DECLARE_EXPORT(__ashlsi3_r0);
-
-DECLARE_EXPORT(__ashiftrt_r4_0);
-DECLARE_EXPORT(__ashiftrt_r4_1);
-DECLARE_EXPORT(__ashiftrt_r4_2);
-DECLARE_EXPORT(__ashiftrt_r4_3);
-DECLARE_EXPORT(__ashiftrt_r4_4);
-DECLARE_EXPORT(__ashiftrt_r4_5);
-DECLARE_EXPORT(__ashiftrt_r4_6);
-DECLARE_EXPORT(__ashiftrt_r4_7);
-DECLARE_EXPORT(__ashiftrt_r4_8);
-DECLARE_EXPORT(__ashiftrt_r4_9);
-DECLARE_EXPORT(__ashiftrt_r4_10);
-DECLARE_EXPORT(__ashiftrt_r4_11);
-DECLARE_EXPORT(__ashiftrt_r4_12);
-DECLARE_EXPORT(__ashiftrt_r4_13);
-DECLARE_EXPORT(__ashiftrt_r4_14);
-DECLARE_EXPORT(__ashiftrt_r4_15);
-DECLARE_EXPORT(__ashiftrt_r4_16);
-DECLARE_EXPORT(__ashiftrt_r4_17);
-DECLARE_EXPORT(__ashiftrt_r4_18);
-DECLARE_EXPORT(__ashiftrt_r4_19);
-DECLARE_EXPORT(__ashiftrt_r4_20);
-DECLARE_EXPORT(__ashiftrt_r4_21);
-DECLARE_EXPORT(__ashiftrt_r4_22);
-DECLARE_EXPORT(__ashiftrt_r4_23);
-DECLARE_EXPORT(__ashiftrt_r4_24);
-DECLARE_EXPORT(__ashiftrt_r4_25);
-DECLARE_EXPORT(__ashiftrt_r4_26);
-DECLARE_EXPORT(__ashiftrt_r4_27);
-DECLARE_EXPORT(__ashiftrt_r4_28);
-DECLARE_EXPORT(__ashiftrt_r4_29);
-DECLARE_EXPORT(__ashiftrt_r4_30);
-DECLARE_EXPORT(__ashiftrt_r4_31);
-DECLARE_EXPORT(__ashiftrt_r4_32);
-DECLARE_EXPORT(__movstr);
-DECLARE_EXPORT(__movstrSI8);
-DECLARE_EXPORT(__movstrSI12);
-DECLARE_EXPORT(__movstrSI16);
-DECLARE_EXPORT(__movstrSI20);
-DECLARE_EXPORT(__movstrSI24);
-DECLARE_EXPORT(__movstrSI28);
-DECLARE_EXPORT(__movstrSI32);
-DECLARE_EXPORT(__movstrSI36);
-DECLARE_EXPORT(__movstrSI40);
-DECLARE_EXPORT(__movstrSI44);
-DECLARE_EXPORT(__movstrSI48);
-DECLARE_EXPORT(__movstrSI52);
-DECLARE_EXPORT(__movstrSI56);
-DECLARE_EXPORT(__movstrSI60);
-DECLARE_EXPORT(__movstr_i4_even);
-DECLARE_EXPORT(__movstr_i4_odd);
-DECLARE_EXPORT(__movstrSI12_i4);
-DECLARE_EXPORT(__movmem);
-DECLARE_EXPORT(__movmemSI8);
-DECLARE_EXPORT(__movmemSI12);
-DECLARE_EXPORT(__movmemSI16);
-DECLARE_EXPORT(__movmemSI20);
-DECLARE_EXPORT(__movmemSI24);
-DECLARE_EXPORT(__movmemSI28);
-DECLARE_EXPORT(__movmemSI32);
-DECLARE_EXPORT(__movmemSI36);
-DECLARE_EXPORT(__movmemSI40);
-DECLARE_EXPORT(__movmemSI44);
-DECLARE_EXPORT(__movmemSI48);
-DECLARE_EXPORT(__movmemSI52);
-DECLARE_EXPORT(__movmemSI56);
-DECLARE_EXPORT(__movmemSI60);
-DECLARE_EXPORT(__movmem_i4_even);
-DECLARE_EXPORT(__movmem_i4_odd);
-DECLARE_EXPORT(__movmemSI12_i4);
-DECLARE_EXPORT(__udiv_qrnnd_16);
-DECLARE_EXPORT(__sdivsi3_i4);
-DECLARE_EXPORT(__udivsi3_i4);
-DECLARE_EXPORT(__sdivsi3_i4i);
-DECLARE_EXPORT(__udivsi3_i4i);
-#ifdef CONFIG_MCOUNT
-DECLARE_EXPORT(mcount);
-#endif
diff --git a/arch/sh/kernel/signal_32.c b/arch/sh/kernel/signal_32.c
deleted file mode 100644
index 90f495d35db29a..00000000000000
--- a/arch/sh/kernel/signal_32.c
+++ /dev/null
@@ -1,507 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- *  linux/arch/sh/kernel/signal.c
- *
- *  Copyright (C) 1991, 1992  Linus Torvalds
- *
- *  1997-11-28  Modified for POSIX.1b signals by Richard Henderson
- *
- *  SuperH version:  Copyright (C) 1999, 2000  Niibe Yutaka & Kaz Kojima
- *
- */
-#include <linux/sched.h>
-#include <linux/sched/task_stack.h>
-#include <linux/mm.h>
-#include <linux/smp.h>
-#include <linux/kernel.h>
-#include <linux/signal.h>
-#include <linux/errno.h>
-#include <linux/wait.h>
-#include <linux/ptrace.h>
-#include <linux/unistd.h>
-#include <linux/stddef.h>
-#include <linux/tty.h>
-#include <linux/elf.h>
-#include <linux/personality.h>
-#include <linux/binfmts.h>
-#include <linux/io.h>
-#include <linux/resume_user_mode.h>
-#include <asm/ucontext.h>
-#include <linux/uaccess.h>
-#include <asm/cacheflush.h>
-#include <asm/syscalls.h>
-#include <asm/fpu.h>
-
-struct fdpic_func_descriptor {
-	unsigned long	text;
-	unsigned long	GOT;
-};
-
-/*
- * The following define adds a 64 byte gap between the signal
- * stack frame and previous contents of the stack.  This allows
- * frame unwinding in a function epilogue but only if a frame
- * pointer is used in the function.  This is necessary because
- * current gcc compilers (<4.3) do not generate unwind info on
- * SH for function epilogues.
- */
-#define UNWINDGUARD 64
-
-/*
- * Do a signal return; undo the signal stack.
- */
-
-#define MOVW(n)	 (0x9300|((n)-2))	/* Move mem word at PC+n to R3 */
-#if defined(CONFIG_CPU_SH2)
-#define TRAP_NOARG 0xc320		/* Syscall w/no args (NR in R3) */
-#else
-#define TRAP_NOARG 0xc310		/* Syscall w/no args (NR in R3) */
-#endif
-#define OR_R0_R0 0x200b			/* or r0,r0 (insert to avoid hardware bug) */
-
-struct sigframe
-{
-	struct sigcontext sc;
-	unsigned long extramask[_NSIG_WORDS-1];
-	u16 retcode[8];
-};
-
-struct rt_sigframe
-{
-	struct siginfo info;
-	struct ucontext uc;
-	u16 retcode[8];
-};
-
-#ifdef CONFIG_SH_FPU
-static inline int restore_sigcontext_fpu(struct sigcontext __user *sc)
-{
-	struct task_struct *tsk = current;
-
-	if (!(boot_cpu_data.flags & CPU_HAS_FPU))
-		return 0;
-
-	set_used_math();
-	return __copy_from_user(&tsk->thread.xstate->hardfpu, &sc->sc_fpregs[0],
-				sizeof(long)*(16*2+2));
-}
-
-static inline int save_sigcontext_fpu(struct sigcontext __user *sc,
-				      struct pt_regs *regs)
-{
-	struct task_struct *tsk = current;
-
-	if (!(boot_cpu_data.flags & CPU_HAS_FPU))
-		return 0;
-
-	if (!used_math())
-		return __put_user(0, &sc->sc_ownedfp);
-
-	if (__put_user(1, &sc->sc_ownedfp))
-		return -EFAULT;
-
-	/* This will cause a "finit" to be triggered by the next
-	   attempted FPU operation by the 'current' process.
-	   */
-	clear_used_math();
-
-	unlazy_fpu(tsk, regs);
-	return __copy_to_user(&sc->sc_fpregs[0], &tsk->thread.xstate->hardfpu,
-			      sizeof(long)*(16*2+2));
-}
-#endif /* CONFIG_SH_FPU */
-
-static int
-restore_sigcontext(struct pt_regs *regs, struct sigcontext __user *sc, int *r0_p)
-{
-	unsigned int err = 0;
-
-#define COPY(x)		err |= __get_user(regs->x, &sc->sc_##x)
-			COPY(regs[1]);
-	COPY(regs[2]);	COPY(regs[3]);
-	COPY(regs[4]);	COPY(regs[5]);
-	COPY(regs[6]);	COPY(regs[7]);
-	COPY(regs[8]);	COPY(regs[9]);
-	COPY(regs[10]);	COPY(regs[11]);
-	COPY(regs[12]);	COPY(regs[13]);
-	COPY(regs[14]);	COPY(regs[15]);
-	COPY(gbr);	COPY(mach);
-	COPY(macl);	COPY(pr);
-	COPY(sr);	COPY(pc);
-#undef COPY
-
-#ifdef CONFIG_SH_FPU
-	if (boot_cpu_data.flags & CPU_HAS_FPU) {
-		int owned_fp;
-		struct task_struct *tsk = current;
-
-		regs->sr |= SR_FD; /* Release FPU */
-		clear_fpu(tsk, regs);
-		clear_used_math();
-		err |= __get_user (owned_fp, &sc->sc_ownedfp);
-		if (owned_fp)
-			err |= restore_sigcontext_fpu(sc);
-	}
-#endif
-
-	regs->tra = -1;		/* disable syscall checks */
-	err |= __get_user(*r0_p, &sc->sc_regs[0]);
-	return err;
-}
-
-asmlinkage int sys_sigreturn(void)
-{
-	struct pt_regs *regs = current_pt_regs();
-	struct sigframe __user *frame = (struct sigframe __user *)regs->regs[15];
-	sigset_t set;
-	int r0;
-
-        /* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
-
-	if (!access_ok(frame, sizeof(*frame)))
-		goto badframe;
-
-	if (__get_user(set.sig[0], &frame->sc.oldmask)
-	    || (_NSIG_WORDS > 1
-		&& __copy_from_user(&set.sig[1], &frame->extramask,
-				    sizeof(frame->extramask))))
-		goto badframe;
-
-	set_current_blocked(&set);
-
-	if (restore_sigcontext(regs, &frame->sc, &r0))
-		goto badframe;
-	return r0;
-
-badframe:
-	force_sig(SIGSEGV);
-	return 0;
-}
-
-asmlinkage int sys_rt_sigreturn(void)
-{
-	struct pt_regs *regs = current_pt_regs();
-	struct rt_sigframe __user *frame = (struct rt_sigframe __user *)regs->regs[15];
-	sigset_t set;
-	int r0;
-
-	/* Always make any pending restarted system calls return -EINTR */
-	current->restart_block.fn = do_no_restart_syscall;
-
-	if (!access_ok(frame, sizeof(*frame)))
-		goto badframe;
-
-	if (__copy_from_user(&set, &frame->uc.uc_sigmask, sizeof(set)))
-		goto badframe;
-
-	set_current_blocked(&set);
-
-	if (restore_sigcontext(regs, &frame->uc.uc_mcontext, &r0))
-		goto badframe;
-
-	if (restore_altstack(&frame->uc.uc_stack))
-		goto badframe;
-
-	return r0;
-
-badframe:
-	force_sig(SIGSEGV);
-	return 0;
-}
-
-/*
- * Set up a signal frame.
- */
-
-static int
-setup_sigcontext(struct sigcontext __user *sc, struct pt_regs *regs,
-		 unsigned long mask)
-{
-	int err = 0;
-
-#define COPY(x)		err |= __put_user(regs->x, &sc->sc_##x)
-	COPY(regs[0]);	COPY(regs[1]);
-	COPY(regs[2]);	COPY(regs[3]);
-	COPY(regs[4]);	COPY(regs[5]);
-	COPY(regs[6]);	COPY(regs[7]);
-	COPY(regs[8]);	COPY(regs[9]);
-	COPY(regs[10]);	COPY(regs[11]);
-	COPY(regs[12]);	COPY(regs[13]);
-	COPY(regs[14]);	COPY(regs[15]);
-	COPY(gbr);	COPY(mach);
-	COPY(macl);	COPY(pr);
-	COPY(sr);	COPY(pc);
-#undef COPY
-
-#ifdef CONFIG_SH_FPU
-	err |= save_sigcontext_fpu(sc, regs);
-#endif
-
-	/* non-iBCS2 extensions.. */
-	err |= __put_user(mask, &sc->oldmask);
-
-	return err;
-}
-
-/*
- * Determine which stack to use..
- */
-static inline void __user *
-get_sigframe(struct k_sigaction *ka, unsigned long sp, size_t frame_size)
-{
-	if (ka->sa.sa_flags & SA_ONSTACK) {
-		if (sas_ss_flags(sp) == 0)
-			sp = current->sas_ss_sp + current->sas_ss_size;
-	}
-
-	return (void __user *)((sp - (frame_size+UNWINDGUARD)) & -8ul);
-}
-
-/* These symbols are defined with the addresses in the vsyscall page.
-   See vsyscall-trapa.S.  */
-extern void __kernel_sigreturn(void);
-extern void __kernel_rt_sigreturn(void);
-
-static int setup_frame(struct ksignal *ksig, sigset_t *set,
-		       struct pt_regs *regs)
-{
-	struct sigframe __user *frame;
-	int err = 0, sig = ksig->sig;
-
-	frame = get_sigframe(&ksig->ka, regs->regs[15], sizeof(*frame));
-
-	if (!access_ok(frame, sizeof(*frame)))
-		return -EFAULT;
-
-	err |= setup_sigcontext(&frame->sc, regs, set->sig[0]);
-
-	if (_NSIG_WORDS > 1)
-		err |= __copy_to_user(frame->extramask, &set->sig[1],
-				      sizeof(frame->extramask));
-
-	/* Set up to return from userspace.  If provided, use a stub
-	   already in userspace.  */
-	if (ksig->ka.sa.sa_flags & SA_RESTORER) {
-		regs->pr = (unsigned long) ksig->ka.sa.sa_restorer;
-#ifdef CONFIG_VSYSCALL
-	} else if (likely(current->mm->context.vdso)) {
-		regs->pr = VDSO_SYM(&__kernel_sigreturn);
-#endif
-	} else {
-		/* Generate return code (system call to sigreturn) */
-		err |= __put_user(MOVW(7), &frame->retcode[0]);
-		err |= __put_user(TRAP_NOARG, &frame->retcode[1]);
-		err |= __put_user(OR_R0_R0, &frame->retcode[2]);
-		err |= __put_user(OR_R0_R0, &frame->retcode[3]);
-		err |= __put_user(OR_R0_R0, &frame->retcode[4]);
-		err |= __put_user(OR_R0_R0, &frame->retcode[5]);
-		err |= __put_user(OR_R0_R0, &frame->retcode[6]);
-		err |= __put_user((__NR_sigreturn), &frame->retcode[7]);
-		regs->pr = (unsigned long) frame->retcode;
-		flush_icache_range(regs->pr, regs->pr + sizeof(frame->retcode));
-	}
-
-	if (err)
-		return -EFAULT;
-
-	/* Set up registers for signal handler */
-	regs->regs[15] = (unsigned long) frame;
-	regs->regs[4] = sig; /* Arg for signal handler */
-	regs->regs[5] = 0;
-	regs->regs[6] = (unsigned long) &frame->sc;
-
-	if (current->personality & FDPIC_FUNCPTRS) {
-		struct fdpic_func_descriptor __user *funcptr =
-			(struct fdpic_func_descriptor __user *)ksig->ka.sa.sa_handler;
-
-		err |= __get_user(regs->pc, &funcptr->text);
-		err |= __get_user(regs->regs[12], &funcptr->GOT);
-	} else
-		regs->pc = (unsigned long)ksig->ka.sa.sa_handler;
-
-	if (err)
-		return -EFAULT;
-
-	pr_debug("SIG deliver (%s:%d): sp=%p pc=%08lx pr=%08lx\n",
-		 current->comm, task_pid_nr(current), frame, regs->pc, regs->pr);
-
-	return 0;
-}
-
-static int setup_rt_frame(struct ksignal *ksig, sigset_t *set,
-			  struct pt_regs *regs)
-{
-	struct rt_sigframe __user *frame;
-	int err = 0, sig = ksig->sig;
-
-	frame = get_sigframe(&ksig->ka, regs->regs[15], sizeof(*frame));
-
-	if (!access_ok(frame, sizeof(*frame)))
-		return -EFAULT;
-
-	err |= copy_siginfo_to_user(&frame->info, &ksig->info);
-
-	/* Create the ucontext.  */
-	err |= __put_user(0, &frame->uc.uc_flags);
-	err |= __put_user(NULL, &frame->uc.uc_link);
-	err |= __save_altstack(&frame->uc.uc_stack, regs->regs[15]);
-	err |= setup_sigcontext(&frame->uc.uc_mcontext,
-			        regs, set->sig[0]);
-	err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));
-
-	/* Set up to return from userspace.  If provided, use a stub
-	   already in userspace.  */
-	if (ksig->ka.sa.sa_flags & SA_RESTORER) {
-		regs->pr = (unsigned long) ksig->ka.sa.sa_restorer;
-#ifdef CONFIG_VSYSCALL
-	} else if (likely(current->mm->context.vdso)) {
-		regs->pr = VDSO_SYM(&__kernel_rt_sigreturn);
-#endif
-	} else {
-		/* Generate return code (system call to rt_sigreturn) */
-		err |= __put_user(MOVW(7), &frame->retcode[0]);
-		err |= __put_user(TRAP_NOARG, &frame->retcode[1]);
-		err |= __put_user(OR_R0_R0, &frame->retcode[2]);
-		err |= __put_user(OR_R0_R0, &frame->retcode[3]);
-		err |= __put_user(OR_R0_R0, &frame->retcode[4]);
-		err |= __put_user(OR_R0_R0, &frame->retcode[5]);
-		err |= __put_user(OR_R0_R0, &frame->retcode[6]);
-		err |= __put_user((__NR_rt_sigreturn), &frame->retcode[7]);
-		regs->pr = (unsigned long) frame->retcode;
-		flush_icache_range(regs->pr, regs->pr + sizeof(frame->retcode));
-	}
-
-	if (err)
-		return -EFAULT;
-
-	/* Set up registers for signal handler */
-	regs->regs[15] = (unsigned long) frame;
-	regs->regs[4] = sig; /* Arg for signal handler */
-	regs->regs[5] = (unsigned long) &frame->info;
-	regs->regs[6] = (unsigned long) &frame->uc;
-
-	if (current->personality & FDPIC_FUNCPTRS) {
-		struct fdpic_func_descriptor __user *funcptr =
-			(struct fdpic_func_descriptor __user *)ksig->ka.sa.sa_handler;
-
-		err |= __get_user(regs->pc, &funcptr->text);
-		err |= __get_user(regs->regs[12], &funcptr->GOT);
-	} else
-		regs->pc = (unsigned long)ksig->ka.sa.sa_handler;
-
-	if (err)
-		return -EFAULT;
-
-	pr_debug("SIG deliver (%s:%d): sp=%p pc=%08lx pr=%08lx\n",
-		 current->comm, task_pid_nr(current), frame, regs->pc, regs->pr);
-
-	return 0;
-}
-
-static inline void
-handle_syscall_restart(unsigned long save_r0, struct pt_regs *regs,
-		       struct sigaction *sa)
-{
-	/* If we're not from a syscall, bail out */
-	if (regs->tra < 0)
-		return;
-
-	/* check for system call restart.. */
-	switch (regs->regs[0]) {
-		case -ERESTART_RESTARTBLOCK:
-		case -ERESTARTNOHAND:
-		no_system_call_restart:
-			regs->regs[0] = -EINTR;
-			break;
-
-		case -ERESTARTSYS:
-			if (!(sa->sa_flags & SA_RESTART))
-				goto no_system_call_restart;
-			fallthrough;
-		case -ERESTARTNOINTR:
-			regs->regs[0] = save_r0;
-			regs->pc -= instruction_size(__raw_readw(regs->pc - 4));
-			break;
-	}
-}
-
-/*
- * OK, we're invoking a handler
- */
-static void
-handle_signal(struct ksignal *ksig, struct pt_regs *regs, unsigned int save_r0)
-{
-	sigset_t *oldset = sigmask_to_save();
-	int ret;
-
-	/* Set up the stack frame */
-	if (ksig->ka.sa.sa_flags & SA_SIGINFO)
-		ret = setup_rt_frame(ksig, oldset, regs);
-	else
-		ret = setup_frame(ksig, oldset, regs);
-
-	signal_setup_done(ret, ksig, test_thread_flag(TIF_SINGLESTEP));
-}
-
-/*
- * Note that 'init' is a special process: it doesn't get signals it doesn't
- * want to handle. Thus you cannot kill init even with a SIGKILL even by
- * mistake.
- *
- * Note that we go through the signals twice: once to check the signals that
- * the kernel can handle, and then we build all the user-level signal handling
- * stack-frames in one go after that.
- */
-static void do_signal(struct pt_regs *regs, unsigned int save_r0)
-{
-	struct ksignal ksig;
-
-	/*
-	 * We want the common case to go fast, which
-	 * is why we may in certain cases get here from
-	 * kernel mode. Just return without doing anything
-	 * if so.
-	 */
-	if (!user_mode(regs))
-		return;
-
-	if (get_signal(&ksig)) {
-		handle_syscall_restart(save_r0, regs, &ksig.ka.sa);
-
-		/* Whee!  Actually deliver the signal.  */
-		handle_signal(&ksig, regs, save_r0);
-		return;
-	}
-
-	/* Did we come from a system call? */
-	if (regs->tra >= 0) {
-		/* Restart the system call - no handlers present */
-		if (regs->regs[0] == -ERESTARTNOHAND ||
-		    regs->regs[0] == -ERESTARTSYS ||
-		    regs->regs[0] == -ERESTARTNOINTR) {
-			regs->regs[0] = save_r0;
-			regs->pc -= instruction_size(__raw_readw(regs->pc - 4));
-		} else if (regs->regs[0] == -ERESTART_RESTARTBLOCK) {
-			regs->pc -= instruction_size(__raw_readw(regs->pc - 4));
-			regs->regs[3] = __NR_restart_syscall;
-		}
-	}
-
-	/*
-	 * If there's no signal to deliver, we just put the saved sigmask
-	 * back.
-	 */
-	restore_saved_sigmask();
-}
-
-asmlinkage void do_notify_resume(struct pt_regs *regs, unsigned int save_r0,
-				 unsigned long thread_info_flags)
-{
-	/* deal with pending signal delivery */
-	if (thread_info_flags & (_TIF_SIGPENDING | _TIF_NOTIFY_SIGNAL))
-		do_signal(regs, save_r0);
-
-	if (thread_info_flags & _TIF_NOTIFY_RESUME)
-		resume_user_mode_work(regs);
-}
diff --git a/arch/sh/kernel/smp.c b/arch/sh/kernel/smp.c
deleted file mode 100644
index 65924d9ec24598..00000000000000
--- a/arch/sh/kernel/smp.c
+++ /dev/null
@@ -1,471 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/smp.c
- *
- * SMP support for the SuperH processors.
- *
- * Copyright (C) 2002 - 2010 Paul Mundt
- * Copyright (C) 2006 - 2007 Akio Idehara
- */
-#include <linux/err.h>
-#include <linux/cache.h>
-#include <linux/cpumask.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/spinlock.h>
-#include <linux/mm.h>
-#include <linux/module.h>
-#include <linux/cpu.h>
-#include <linux/interrupt.h>
-#include <linux/sched/mm.h>
-#include <linux/sched/hotplug.h>
-#include <linux/atomic.h>
-#include <linux/clockchips.h>
-#include <asm/processor.h>
-#include <asm/mmu_context.h>
-#include <asm/smp.h>
-#include <asm/cacheflush.h>
-#include <asm/sections.h>
-#include <asm/setup.h>
-
-int __cpu_number_map[NR_CPUS];		/* Map physical to logical */
-int __cpu_logical_map[NR_CPUS];		/* Map logical to physical */
-
-struct plat_smp_ops *mp_ops = NULL;
-
-/* State of each CPU */
-DEFINE_PER_CPU(int, cpu_state) = { 0 };
-
-void register_smp_ops(struct plat_smp_ops *ops)
-{
-	if (mp_ops)
-		printk(KERN_WARNING "Overriding previously set SMP ops\n");
-
-	mp_ops = ops;
-}
-
-static inline void smp_store_cpu_info(unsigned int cpu)
-{
-	struct sh_cpuinfo *c = cpu_data + cpu;
-
-	memcpy(c, &boot_cpu_data, sizeof(struct sh_cpuinfo));
-
-	c->loops_per_jiffy = loops_per_jiffy;
-}
-
-void __init smp_prepare_cpus(unsigned int max_cpus)
-{
-	unsigned int cpu = smp_processor_id();
-
-	init_new_context(current, &init_mm);
-	current_thread_info()->cpu = cpu;
-	mp_ops->prepare_cpus(max_cpus);
-
-#ifndef CONFIG_HOTPLUG_CPU
-	init_cpu_present(cpu_possible_mask);
-#endif
-}
-
-void __init smp_prepare_boot_cpu(void)
-{
-	unsigned int cpu = smp_processor_id();
-
-	__cpu_number_map[0] = cpu;
-	__cpu_logical_map[0] = cpu;
-
-	set_cpu_online(cpu, true);
-	set_cpu_possible(cpu, true);
-
-	per_cpu(cpu_state, cpu) = CPU_ONLINE;
-}
-
-#ifdef CONFIG_HOTPLUG_CPU
-void native_cpu_die(unsigned int cpu)
-{
-	unsigned int i;
-
-	for (i = 0; i < 10; i++) {
-		smp_rmb();
-		if (per_cpu(cpu_state, cpu) == CPU_DEAD) {
-			if (system_state == SYSTEM_RUNNING)
-				pr_info("CPU %u is now offline\n", cpu);
-
-			return;
-		}
-
-		msleep(100);
-	}
-
-	pr_err("CPU %u didn't die...\n", cpu);
-}
-
-int native_cpu_disable(unsigned int cpu)
-{
-	return cpu == 0 ? -EPERM : 0;
-}
-
-void play_dead_common(void)
-{
-	idle_task_exit();
-	irq_ctx_exit(raw_smp_processor_id());
-	mb();
-
-	__this_cpu_write(cpu_state, CPU_DEAD);
-	local_irq_disable();
-}
-
-void native_play_dead(void)
-{
-	play_dead_common();
-}
-
-int __cpu_disable(void)
-{
-	unsigned int cpu = smp_processor_id();
-	int ret;
-
-	ret = mp_ops->cpu_disable(cpu);
-	if (ret)
-		return ret;
-
-	/*
-	 * Take this CPU offline.  Once we clear this, we can't return,
-	 * and we must not schedule until we're ready to give up the cpu.
-	 */
-	set_cpu_online(cpu, false);
-
-	/*
-	 * OK - migrate IRQs away from this CPU
-	 */
-	migrate_irqs();
-
-	/*
-	 * Flush user cache and TLB mappings, and then remove this CPU
-	 * from the vm mask set of all processes.
-	 */
-	flush_cache_all();
-#ifdef CONFIG_MMU
-	local_flush_tlb_all();
-#endif
-
-	clear_tasks_mm_cpumask(cpu);
-
-	return 0;
-}
-#else /* ... !CONFIG_HOTPLUG_CPU */
-int native_cpu_disable(unsigned int cpu)
-{
-	return -ENOSYS;
-}
-
-void native_cpu_die(unsigned int cpu)
-{
-	/* We said "no" in __cpu_disable */
-	BUG();
-}
-
-void native_play_dead(void)
-{
-	BUG();
-}
-#endif
-
-asmlinkage void start_secondary(void)
-{
-	unsigned int cpu = smp_processor_id();
-	struct mm_struct *mm = &init_mm;
-
-	enable_mmu();
-	mmgrab(mm);
-	mmget(mm);
-	current->active_mm = mm;
-#ifdef CONFIG_MMU
-	enter_lazy_tlb(mm, current);
-	local_flush_tlb_all();
-#endif
-
-	per_cpu_trap_init();
-
-	notify_cpu_starting(cpu);
-
-	local_irq_enable();
-
-	calibrate_delay();
-
-	smp_store_cpu_info(cpu);
-
-	set_cpu_online(cpu, true);
-	per_cpu(cpu_state, cpu) = CPU_ONLINE;
-
-	cpu_startup_entry(CPUHP_AP_ONLINE_IDLE);
-}
-
-extern struct {
-	unsigned long sp;
-	unsigned long bss_start;
-	unsigned long bss_end;
-	void *start_kernel_fn;
-	void *cpu_init_fn;
-	void *thread_info;
-} stack_start;
-
-int __cpu_up(unsigned int cpu, struct task_struct *tsk)
-{
-	unsigned long timeout;
-
-	per_cpu(cpu_state, cpu) = CPU_UP_PREPARE;
-
-	/* Fill in data in head.S for secondary cpus */
-	stack_start.sp = tsk->thread.sp;
-	stack_start.thread_info = tsk->stack;
-	stack_start.bss_start = 0; /* don't clear bss for secondary cpus */
-	stack_start.start_kernel_fn = start_secondary;
-
-	flush_icache_range((unsigned long)&stack_start,
-			   (unsigned long)&stack_start + sizeof(stack_start));
-	wmb();
-
-	mp_ops->start_cpu(cpu, (unsigned long)_stext);
-
-	timeout = jiffies + HZ;
-	while (time_before(jiffies, timeout)) {
-		if (cpu_online(cpu))
-			break;
-
-		udelay(10);
-		barrier();
-	}
-
-	if (cpu_online(cpu))
-		return 0;
-
-	return -ENOENT;
-}
-
-void __init smp_cpus_done(unsigned int max_cpus)
-{
-	unsigned long bogosum = 0;
-	int cpu;
-
-	for_each_online_cpu(cpu)
-		bogosum += cpu_data[cpu].loops_per_jiffy;
-
-	printk(KERN_INFO "SMP: Total of %d processors activated "
-	       "(%lu.%02lu BogoMIPS).\n", num_online_cpus(),
-	       bogosum / (500000/HZ),
-	       (bogosum / (5000/HZ)) % 100);
-}
-
-void smp_send_reschedule(int cpu)
-{
-	mp_ops->send_ipi(cpu, SMP_MSG_RESCHEDULE);
-}
-
-void smp_send_stop(void)
-{
-	smp_call_function(stop_this_cpu, 0, 0);
-}
-
-void arch_send_call_function_ipi_mask(const struct cpumask *mask)
-{
-	int cpu;
-
-	for_each_cpu(cpu, mask)
-		mp_ops->send_ipi(cpu, SMP_MSG_FUNCTION);
-}
-
-void arch_send_call_function_single_ipi(int cpu)
-{
-	mp_ops->send_ipi(cpu, SMP_MSG_FUNCTION_SINGLE);
-}
-
-#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST
-void tick_broadcast(const struct cpumask *mask)
-{
-	int cpu;
-
-	for_each_cpu(cpu, mask)
-		mp_ops->send_ipi(cpu, SMP_MSG_TIMER);
-}
-
-static void ipi_timer(void)
-{
-	irq_enter();
-	tick_receive_broadcast();
-	irq_exit();
-}
-#endif
-
-void smp_message_recv(unsigned int msg)
-{
-	switch (msg) {
-	case SMP_MSG_FUNCTION:
-		generic_smp_call_function_interrupt();
-		break;
-	case SMP_MSG_RESCHEDULE:
-		scheduler_ipi();
-		break;
-	case SMP_MSG_FUNCTION_SINGLE:
-		generic_smp_call_function_single_interrupt();
-		break;
-#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST
-	case SMP_MSG_TIMER:
-		ipi_timer();
-		break;
-#endif
-	default:
-		printk(KERN_WARNING "SMP %d: %s(): unknown IPI %d\n",
-		       smp_processor_id(), __func__, msg);
-		break;
-	}
-}
-
-/* Not really SMP stuff ... */
-int setup_profiling_timer(unsigned int multiplier)
-{
-	return 0;
-}
-
-#ifdef CONFIG_MMU
-
-static void flush_tlb_all_ipi(void *info)
-{
-	local_flush_tlb_all();
-}
-
-void flush_tlb_all(void)
-{
-	on_each_cpu(flush_tlb_all_ipi, 0, 1);
-}
-
-static void flush_tlb_mm_ipi(void *mm)
-{
-	local_flush_tlb_mm((struct mm_struct *)mm);
-}
-
-/*
- * The following tlb flush calls are invoked when old translations are
- * being torn down, or pte attributes are changing. For single threaded
- * address spaces, a new context is obtained on the current cpu, and tlb
- * context on other cpus are invalidated to force a new context allocation
- * at switch_mm time, should the mm ever be used on other cpus. For
- * multithreaded address spaces, intercpu interrupts have to be sent.
- * Another case where intercpu interrupts are required is when the target
- * mm might be active on another cpu (eg debuggers doing the flushes on
- * behalf of debugees, kswapd stealing pages from another process etc).
- * Kanoj 07/00.
- */
-void flush_tlb_mm(struct mm_struct *mm)
-{
-	preempt_disable();
-
-	if ((atomic_read(&mm->mm_users) != 1) || (current->mm != mm)) {
-		smp_call_function(flush_tlb_mm_ipi, (void *)mm, 1);
-	} else {
-		int i;
-		for_each_online_cpu(i)
-			if (smp_processor_id() != i)
-				cpu_context(i, mm) = 0;
-	}
-	local_flush_tlb_mm(mm);
-
-	preempt_enable();
-}
-
-struct flush_tlb_data {
-	struct vm_area_struct *vma;
-	unsigned long addr1;
-	unsigned long addr2;
-};
-
-static void flush_tlb_range_ipi(void *info)
-{
-	struct flush_tlb_data *fd = (struct flush_tlb_data *)info;
-
-	local_flush_tlb_range(fd->vma, fd->addr1, fd->addr2);
-}
-
-void flush_tlb_range(struct vm_area_struct *vma,
-		     unsigned long start, unsigned long end)
-{
-	struct mm_struct *mm = vma->vm_mm;
-
-	preempt_disable();
-	if ((atomic_read(&mm->mm_users) != 1) || (current->mm != mm)) {
-		struct flush_tlb_data fd;
-
-		fd.vma = vma;
-		fd.addr1 = start;
-		fd.addr2 = end;
-		smp_call_function(flush_tlb_range_ipi, (void *)&fd, 1);
-	} else {
-		int i;
-		for_each_online_cpu(i)
-			if (smp_processor_id() != i)
-				cpu_context(i, mm) = 0;
-	}
-	local_flush_tlb_range(vma, start, end);
-	preempt_enable();
-}
-
-static void flush_tlb_kernel_range_ipi(void *info)
-{
-	struct flush_tlb_data *fd = (struct flush_tlb_data *)info;
-
-	local_flush_tlb_kernel_range(fd->addr1, fd->addr2);
-}
-
-void flush_tlb_kernel_range(unsigned long start, unsigned long end)
-{
-	struct flush_tlb_data fd;
-
-	fd.addr1 = start;
-	fd.addr2 = end;
-	on_each_cpu(flush_tlb_kernel_range_ipi, (void *)&fd, 1);
-}
-
-static void flush_tlb_page_ipi(void *info)
-{
-	struct flush_tlb_data *fd = (struct flush_tlb_data *)info;
-
-	local_flush_tlb_page(fd->vma, fd->addr1);
-}
-
-void flush_tlb_page(struct vm_area_struct *vma, unsigned long page)
-{
-	preempt_disable();
-	if ((atomic_read(&vma->vm_mm->mm_users) != 1) ||
-	    (current->mm != vma->vm_mm)) {
-		struct flush_tlb_data fd;
-
-		fd.vma = vma;
-		fd.addr1 = page;
-		smp_call_function(flush_tlb_page_ipi, (void *)&fd, 1);
-	} else {
-		int i;
-		for_each_online_cpu(i)
-			if (smp_processor_id() != i)
-				cpu_context(i, vma->vm_mm) = 0;
-	}
-	local_flush_tlb_page(vma, page);
-	preempt_enable();
-}
-
-static void flush_tlb_one_ipi(void *info)
-{
-	struct flush_tlb_data *fd = (struct flush_tlb_data *)info;
-	local_flush_tlb_one(fd->addr1, fd->addr2);
-}
-
-void flush_tlb_one(unsigned long asid, unsigned long vaddr)
-{
-	struct flush_tlb_data fd;
-
-	fd.addr1 = asid;
-	fd.addr2 = vaddr;
-
-	smp_call_function(flush_tlb_one_ipi, (void *)&fd, 1);
-	local_flush_tlb_one(asid, vaddr);
-}
-
-#endif
diff --git a/arch/sh/kernel/stacktrace.c b/arch/sh/kernel/stacktrace.c
deleted file mode 100644
index daf0b53ee066fa..00000000000000
--- a/arch/sh/kernel/stacktrace.c
+++ /dev/null
@@ -1,79 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/stacktrace.c
- *
- * Stack trace management functions
- *
- *  Copyright (C) 2006 - 2008  Paul Mundt
- */
-#include <linux/sched.h>
-#include <linux/sched/debug.h>
-#include <linux/stacktrace.h>
-#include <linux/thread_info.h>
-#include <linux/module.h>
-#include <asm/unwinder.h>
-#include <asm/ptrace.h>
-#include <asm/stacktrace.h>
-
-/*
- * Save stack-backtrace addresses into a stack_trace buffer.
- */
-static void save_stack_address(void *data, unsigned long addr, int reliable)
-{
-	struct stack_trace *trace = data;
-
-	if (!reliable)
-		return;
-
-	if (trace->skip > 0) {
-		trace->skip--;
-		return;
-	}
-
-	if (trace->nr_entries < trace->max_entries)
-		trace->entries[trace->nr_entries++] = addr;
-}
-
-static const struct stacktrace_ops save_stack_ops = {
-	.address = save_stack_address,
-};
-
-void save_stack_trace(struct stack_trace *trace)
-{
-	unsigned long *sp = (unsigned long *)current_stack_pointer;
-
-	unwind_stack(current, NULL, sp,  &save_stack_ops, trace);
-}
-EXPORT_SYMBOL_GPL(save_stack_trace);
-
-static void
-save_stack_address_nosched(void *data, unsigned long addr, int reliable)
-{
-	struct stack_trace *trace = (struct stack_trace *)data;
-
-	if (!reliable)
-		return;
-
-	if (in_sched_functions(addr))
-		return;
-
-	if (trace->skip > 0) {
-		trace->skip--;
-		return;
-	}
-
-	if (trace->nr_entries < trace->max_entries)
-		trace->entries[trace->nr_entries++] = addr;
-}
-
-static const struct stacktrace_ops save_stack_ops_nosched = {
-	.address = save_stack_address_nosched,
-};
-
-void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
-{
-	unsigned long *sp = (unsigned long *)tsk->thread.sp;
-
-	unwind_stack(current, NULL, sp,  &save_stack_ops_nosched, trace);
-}
-EXPORT_SYMBOL_GPL(save_stack_trace_tsk);
diff --git a/arch/sh/kernel/swsusp.c b/arch/sh/kernel/swsusp.c
deleted file mode 100644
index 0b772d6d714fed..00000000000000
--- a/arch/sh/kernel/swsusp.c
+++ /dev/null
@@ -1,35 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * swsusp.c - SuperH hibernation support
- *
- * Copyright (C) 2009 Magnus Damm
- */
-
-#include <linux/mm.h>
-#include <linux/sched.h>
-#include <linux/suspend.h>
-#include <asm/suspend.h>
-#include <asm/sections.h>
-#include <asm/tlbflush.h>
-#include <asm/page.h>
-#include <asm/fpu.h>
-
-struct swsusp_arch_regs swsusp_arch_regs_cpu0;
-
-int pfn_is_nosave(unsigned long pfn)
-{
-	unsigned long begin_pfn = __pa(&__nosave_begin) >> PAGE_SHIFT;
-	unsigned long end_pfn = PAGE_ALIGN(__pa(&__nosave_end)) >> PAGE_SHIFT;
-
-	return (pfn >= begin_pfn) && (pfn < end_pfn);
-}
-
-void save_processor_state(void)
-{
-	init_fpu(current);
-}
-
-void restore_processor_state(void)
-{
-	local_flush_tlb_all();
-}
diff --git a/arch/sh/kernel/sys_sh.c b/arch/sh/kernel/sys_sh.c
deleted file mode 100644
index a5a7b33ed81ae9..00000000000000
--- a/arch/sh/kernel/sys_sh.c
+++ /dev/null
@@ -1,96 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/kernel/sys_sh.c
- *
- * This file contains various random system calls that
- * have a non-standard calling sequence on the Linux/SuperH
- * platform.
- *
- * Taken from i386 version.
- */
-#include <linux/errno.h>
-#include <linux/sched.h>
-#include <linux/mm.h>
-#include <linux/smp.h>
-#include <linux/sem.h>
-#include <linux/msg.h>
-#include <linux/shm.h>
-#include <linux/stat.h>
-#include <linux/syscalls.h>
-#include <linux/mman.h>
-#include <linux/file.h>
-#include <linux/utsname.h>
-#include <linux/module.h>
-#include <linux/fs.h>
-#include <linux/ipc.h>
-#include <asm/syscalls.h>
-#include <linux/uaccess.h>
-#include <asm/unistd.h>
-#include <asm/cacheflush.h>
-#include <asm/cachectl.h>
-
-asmlinkage int old_mmap(unsigned long addr, unsigned long len,
-	unsigned long prot, unsigned long flags,
-	int fd, unsigned long off)
-{
-	if (off & ~PAGE_MASK)
-		return -EINVAL;
-	return ksys_mmap_pgoff(addr, len, prot, flags, fd, off>>PAGE_SHIFT);
-}
-
-asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,
-	unsigned long prot, unsigned long flags,
-	unsigned long fd, unsigned long pgoff)
-{
-	/*
-	 * The shift for mmap2 is constant, regardless of PAGE_SIZE
-	 * setting.
-	 */
-	if (pgoff & ((1 << (PAGE_SHIFT - 12)) - 1))
-		return -EINVAL;
-
-	pgoff >>= PAGE_SHIFT - 12;
-
-	return ksys_mmap_pgoff(addr, len, prot, flags, fd, pgoff);
-}
-
-/* sys_cacheflush -- flush (part of) the processor cache.  */
-asmlinkage int sys_cacheflush(unsigned long addr, unsigned long len, int op)
-{
-	struct vm_area_struct *vma;
-
-	if ((op <= 0) || (op > (CACHEFLUSH_D_PURGE|CACHEFLUSH_I)))
-		return -EINVAL;
-
-	/*
-	 * Verify that the specified address region actually belongs
-	 * to this process.
-	 */
-	if (addr + len < addr)
-		return -EFAULT;
-
-	mmap_read_lock(current->mm);
-	vma = find_vma (current->mm, addr);
-	if (vma == NULL || addr < vma->vm_start || addr + len > vma->vm_end) {
-		mmap_read_unlock(current->mm);
-		return -EFAULT;
-	}
-
-	switch (op & CACHEFLUSH_D_PURGE) {
-		case CACHEFLUSH_D_INVAL:
-			__flush_invalidate_region((void *)addr, len);
-			break;
-		case CACHEFLUSH_D_WB:
-			__flush_wback_region((void *)addr, len);
-			break;
-		case CACHEFLUSH_D_PURGE:
-			__flush_purge_region((void *)addr, len);
-			break;
-	}
-
-	if (op & CACHEFLUSH_I)
-		flush_icache_range(addr, addr+len);
-
-	mmap_read_unlock(current->mm);
-	return 0;
-}
diff --git a/arch/sh/kernel/sys_sh32.c b/arch/sh/kernel/sys_sh32.c
deleted file mode 100644
index 9dca568509a5e5..00000000000000
--- a/arch/sh/kernel/sys_sh32.c
+++ /dev/null
@@ -1,61 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/errno.h>
-#include <linux/sched.h>
-#include <linux/sched/task_stack.h>
-#include <linux/mm.h>
-#include <linux/smp.h>
-#include <linux/sem.h>
-#include <linux/msg.h>
-#include <linux/shm.h>
-#include <linux/stat.h>
-#include <linux/syscalls.h>
-#include <linux/mman.h>
-#include <linux/file.h>
-#include <linux/module.h>
-#include <linux/fs.h>
-#include <linux/ipc.h>
-#include <asm/cacheflush.h>
-#include <linux/uaccess.h>
-#include <asm/unistd.h>
-#include <asm/syscalls.h>
-
-/*
- * sys_pipe() is the normal C calling standard for creating
- * a pipe. It's not the way Unix traditionally does this, though.
- */
-asmlinkage int sys_sh_pipe(void)
-{
-	int fd[2];
-	int error;
-
-	error = do_pipe_flags(fd, 0);
-	if (!error) {
-		current_pt_regs()->regs[1] = fd[1];
-		return fd[0];
-	}
-	return error;
-}
-
-asmlinkage ssize_t sys_pread_wrapper(unsigned int fd, char __user *buf,
-			     size_t count, long dummy, loff_t pos)
-{
-	return ksys_pread64(fd, buf, count, pos);
-}
-
-asmlinkage ssize_t sys_pwrite_wrapper(unsigned int fd, const char __user *buf,
-			      size_t count, long dummy, loff_t pos)
-{
-	return ksys_pwrite64(fd, buf, count, pos);
-}
-
-asmlinkage int sys_fadvise64_64_wrapper(int fd, u32 offset0, u32 offset1,
-				u32 len0, u32 len1, int advice)
-{
-#ifdef  __LITTLE_ENDIAN__
-	return ksys_fadvise64_64(fd, (u64)offset1 << 32 | offset0,
-				 (u64)len1 << 32 | len0, advice);
-#else
-	return ksys_fadvise64_64(fd, (u64)offset0 << 32 | offset1,
-				 (u64)len0 << 32 | len1, advice);
-#endif
-}
diff --git a/arch/sh/kernel/syscalls/Makefile b/arch/sh/kernel/syscalls/Makefile
deleted file mode 100644
index b265e4bc16c2e0..00000000000000
--- a/arch/sh/kernel/syscalls/Makefile
+++ /dev/null
@@ -1,32 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-kapi := arch/$(SRCARCH)/include/generated/asm
-uapi := arch/$(SRCARCH)/include/generated/uapi/asm
-
-$(shell mkdir -p $(uapi) $(kapi))
-
-syscall := $(src)/syscall.tbl
-syshdr := $(srctree)/scripts/syscallhdr.sh
-systbl := $(srctree)/scripts/syscalltbl.sh
-
-quiet_cmd_syshdr = SYSHDR  $@
-      cmd_syshdr = $(CONFIG_SHELL) $(syshdr) --emit-nr $< $@
-
-quiet_cmd_systbl = SYSTBL  $@
-      cmd_systbl = $(CONFIG_SHELL) $(systbl) $< $@
-
-$(uapi)/unistd_32.h: $(syscall) $(syshdr) FORCE
-	$(call if_changed,syshdr)
-
-$(kapi)/syscall_table.h: $(syscall) $(systbl) FORCE
-	$(call if_changed,systbl)
-
-uapisyshdr-y		+= unistd_32.h
-kapisyshdr-y		+= syscall_table.h
-
-uapisyshdr-y	:= $(addprefix $(uapi)/, $(uapisyshdr-y))
-kapisyshdr-y	:= $(addprefix $(kapi)/, $(kapisyshdr-y))
-targets		+= $(addprefix ../../../../, $(uapisyshdr-y) $(kapisyshdr-y))
-
-PHONY += all
-all: $(uapisyshdr-y) $(kapisyshdr-y)
-	@:
diff --git a/arch/sh/kernel/syscalls/syscall.tbl b/arch/sh/kernel/syscalls/syscall.tbl
deleted file mode 100644
index 2de85c977f54f9..00000000000000
--- a/arch/sh/kernel/syscalls/syscall.tbl
+++ /dev/null
@@ -1,455 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
-#
-# system call numbers and entry vectors for sh
-#
-# The format is:
-# <number> <abi> <name> <entry point>
-#
-# The <abi> is always "common" for this file
-#
-0	common	restart_syscall			sys_restart_syscall
-1	common	exit				sys_exit
-2	common	fork				sys_fork
-3	common	read				sys_read
-4	common	write				sys_write
-5	common	open				sys_open
-6	common	close				sys_close
-7	common	waitpid				sys_waitpid
-8	common	creat				sys_creat
-9	common	link				sys_link
-10	common	unlink				sys_unlink
-11	common	execve				sys_execve
-12	common	chdir				sys_chdir
-13	common	time				sys_time32
-14	common	mknod				sys_mknod
-15	common	chmod				sys_chmod
-16	common	lchown				sys_lchown16
-# 17 was break
-18	common	oldstat				sys_stat
-19	common	lseek				sys_lseek
-20	common	getpid				sys_getpid
-21	common	mount				sys_mount
-22	common	umount				sys_oldumount
-23	common	setuid				sys_setuid16
-24	common	getuid				sys_getuid16
-25	common	stime				sys_stime32
-26	common	ptrace				sys_ptrace
-27	common	alarm				sys_alarm
-28	common	oldfstat			sys_fstat
-29	common	pause				sys_pause
-30	common	utime				sys_utime32
-# 31 was stty
-# 32 was gtty
-33	common	access				sys_access
-34	common	nice				sys_nice
-# 35 was ftime
-36	common	sync				sys_sync
-37	common	kill				sys_kill
-38	common	rename				sys_rename
-39	common	mkdir				sys_mkdir
-40	common	rmdir				sys_rmdir
-41	common	dup				sys_dup
-42	common	pipe				sys_sh_pipe
-43	common	times				sys_times
-# 44 was prof
-45	common	brk				sys_brk
-46	common	setgid				sys_setgid16
-47	common	getgid				sys_getgid16
-48	common	signal				sys_signal
-49	common	geteuid				sys_geteuid16
-50	common	getegid				sys_getegid16
-51	common	acct				sys_acct
-52	common	umount2				sys_umount
-# 53 was lock
-54	common	ioctl				sys_ioctl
-55	common	fcntl				sys_fcntl
-# 56 was mpx
-57	common	setpgid				sys_setpgid
-# 58 was ulimit
-# 59 was olduname
-60	common	umask				sys_umask
-61	common	chroot				sys_chroot
-62	common	ustat				sys_ustat
-63	common	dup2				sys_dup2
-64	common	getppid				sys_getppid
-65	common	getpgrp				sys_getpgrp
-66	common	setsid				sys_setsid
-67	common	sigaction			sys_sigaction
-68	common	sgetmask			sys_sgetmask
-69	common	ssetmask			sys_ssetmask
-70	common	setreuid			sys_setreuid16
-71	common	setregid			sys_setregid16
-72	common	sigsuspend			sys_sigsuspend
-73	common	sigpending			sys_sigpending
-74	common	sethostname			sys_sethostname
-75	common	setrlimit			sys_setrlimit
-76	common	getrlimit			sys_old_getrlimit
-77	common	getrusage			sys_getrusage
-78	common	gettimeofday			sys_gettimeofday
-79	common	settimeofday			sys_settimeofday
-80	common	getgroups			sys_getgroups16
-81	common	setgroups			sys_setgroups16
-# 82 was select
-83	common	symlink				sys_symlink
-84	common	oldlstat			sys_lstat
-85	common	readlink			sys_readlink
-86	common	uselib				sys_uselib
-87	common	swapon				sys_swapon
-88	common	reboot				sys_reboot
-89	common	readdir				sys_old_readdir
-90	common	mmap				old_mmap
-91	common	munmap				sys_munmap
-92	common	truncate			sys_truncate
-93	common	ftruncate			sys_ftruncate
-94	common	fchmod				sys_fchmod
-95	common	fchown				sys_fchown16
-96	common	getpriority			sys_getpriority
-97	common	setpriority			sys_setpriority
-# 98 was profil
-99	common	statfs				sys_statfs
-100	common	fstatfs				sys_fstatfs
-# 101 was ioperm
-102	common	socketcall			sys_socketcall
-103	common	syslog				sys_syslog
-104	common	setitimer			sys_setitimer
-105	common	getitimer			sys_getitimer
-106	common	stat				sys_newstat
-107	common	lstat				sys_newlstat
-108	common	fstat				sys_newfstat
-109	common	olduname			sys_uname
-# 110 was iopl
-111	common	vhangup				sys_vhangup
-# 112 was idle
-# 113 was vm86old
-114	common	wait4				sys_wait4
-115	common	swapoff				sys_swapoff
-116	common	sysinfo				sys_sysinfo
-117	common	ipc				sys_ipc
-118	common	fsync				sys_fsync
-119	common	sigreturn			sys_sigreturn
-120	common	clone				sys_clone
-121	common	setdomainname			sys_setdomainname
-122	common	uname				sys_newuname
-123	common	cacheflush			sys_cacheflush
-124	common	adjtimex			sys_adjtimex_time32
-125	common	mprotect			sys_mprotect
-126	common	sigprocmask			sys_sigprocmask
-# 127 was create_module
-128	common	init_module			sys_init_module
-129	common	delete_module			sys_delete_module
-# 130 was get_kernel_syms
-131	common	quotactl			sys_quotactl
-132	common	getpgid				sys_getpgid
-133	common	fchdir				sys_fchdir
-134	common	bdflush				sys_ni_syscall
-135	common	sysfs				sys_sysfs
-136	common	personality			sys_personality
-# 137 was afs_syscall
-138	common	setfsuid			sys_setfsuid16
-139	common	setfsgid			sys_setfsgid16
-140	common	_llseek				sys_llseek
-141	common	getdents			sys_getdents
-142	common	_newselect			sys_select
-143	common	flock				sys_flock
-144	common	msync				sys_msync
-145	common	readv				sys_readv
-146	common	writev				sys_writev
-147	common	getsid				sys_getsid
-148	common	fdatasync			sys_fdatasync
-149	common	_sysctl				sys_ni_syscall
-150	common	mlock				sys_mlock
-151	common	munlock				sys_munlock
-152	common	mlockall			sys_mlockall
-153	common	munlockall			sys_munlockall
-154	common	sched_setparam			sys_sched_setparam
-155	common	sched_getparam			sys_sched_getparam
-156	common	sched_setscheduler		sys_sched_setscheduler
-157	common	sched_getscheduler		sys_sched_getscheduler
-158	common	sched_yield			sys_sched_yield
-159	common	sched_get_priority_max		sys_sched_get_priority_max
-160	common	sched_get_priority_min		sys_sched_get_priority_min
-161	common	sched_rr_get_interval		sys_sched_rr_get_interval_time32
-162	common	nanosleep			sys_nanosleep_time32
-163	common	mremap				sys_mremap
-164	common	setresuid			sys_setresuid16
-165	common	getresuid			sys_getresuid16
-# 166 was vm86
-# 167 was query_module
-168	common	poll				sys_poll
-169	common	nfsservctl			sys_ni_syscall
-170	common	setresgid			sys_setresgid16
-171	common	getresgid			sys_getresgid16
-172	common	prctl				sys_prctl
-173	common	rt_sigreturn			sys_rt_sigreturn
-174	common	rt_sigaction			sys_rt_sigaction
-175	common	rt_sigprocmask			sys_rt_sigprocmask
-176	common	rt_sigpending			sys_rt_sigpending
-177	common	rt_sigtimedwait			sys_rt_sigtimedwait_time32
-178	common	rt_sigqueueinfo			sys_rt_sigqueueinfo
-179	common	rt_sigsuspend			sys_rt_sigsuspend
-180	common	pread64				sys_pread_wrapper
-181	common	pwrite64			sys_pwrite_wrapper
-182	common	chown				sys_chown16
-183	common	getcwd				sys_getcwd
-184	common	capget				sys_capget
-185	common	capset				sys_capset
-186	common	sigaltstack			sys_sigaltstack
-187	common	sendfile			sys_sendfile
-# 188 is reserved for getpmsg
-# 189 is reserved for putpmsg
-190	common	vfork				sys_vfork
-191	common	ugetrlimit			sys_getrlimit
-192	common	mmap2				sys_mmap2
-193	common	truncate64			sys_truncate64
-194	common	ftruncate64			sys_ftruncate64
-195	common	stat64				sys_stat64
-196	common	lstat64				sys_lstat64
-197	common	fstat64				sys_fstat64
-198	common	lchown32			sys_lchown
-199	common	getuid32			sys_getuid
-200	common	getgid32			sys_getgid
-201	common	geteuid32			sys_geteuid
-202	common	getegid32			sys_getegid
-203	common	setreuid32			sys_setreuid
-204	common	setregid32			sys_setregid
-205	common	getgroups32			sys_getgroups
-206	common	setgroups32			sys_setgroups
-207	common	fchown32			sys_fchown
-208	common	setresuid32			sys_setresuid
-209	common	getresuid32			sys_getresuid
-210	common	setresgid32			sys_setresgid
-211	common	getresgid32			sys_getresgid
-212	common	chown32				sys_chown
-213	common	setuid32			sys_setuid
-214	common	setgid32			sys_setgid
-215	common	setfsuid32			sys_setfsuid
-216	common	setfsgid32			sys_setfsgid
-217	common	pivot_root			sys_pivot_root
-218	common	mincore				sys_mincore
-219	common	madvise				sys_madvise
-220	common	getdents64			sys_getdents64
-221	common	fcntl64				sys_fcntl64
-# 222 is reserved for tux
-# 223 is unused
-224	common	gettid				sys_gettid
-225	common	readahead			sys_readahead
-226	common	setxattr			sys_setxattr
-227	common	lsetxattr			sys_lsetxattr
-228	common	fsetxattr			sys_fsetxattr
-229	common	getxattr			sys_getxattr
-230	common	lgetxattr			sys_lgetxattr
-231	common	fgetxattr			sys_fgetxattr
-232	common	listxattr			sys_listxattr
-233	common	llistxattr			sys_llistxattr
-234	common	flistxattr			sys_flistxattr
-235	common	removexattr			sys_removexattr
-236	common	lremovexattr			sys_lremovexattr
-237	common	fremovexattr			sys_fremovexattr
-238	common	tkill				sys_tkill
-239	common	sendfile64			sys_sendfile64
-240	common	futex				sys_futex_time32
-241	common	sched_setaffinity		sys_sched_setaffinity
-242	common	sched_getaffinity		sys_sched_getaffinity
-# 243 is reserved for set_thread_area
-# 244 is reserved for get_thread_area
-245	common	io_setup			sys_io_setup
-246	common	io_destroy			sys_io_destroy
-247	common	io_getevents			sys_io_getevents_time32
-248	common	io_submit			sys_io_submit
-249	common	io_cancel			sys_io_cancel
-250	common	fadvise64			sys_fadvise64
-# 251 is unused
-252	common	exit_group			sys_exit_group
-253	common	lookup_dcookie			sys_lookup_dcookie
-254	common	epoll_create			sys_epoll_create
-255	common	epoll_ctl			sys_epoll_ctl
-256	common	epoll_wait			sys_epoll_wait
-257	common	remap_file_pages		sys_remap_file_pages
-258	common	set_tid_address			sys_set_tid_address
-259	common	timer_create			sys_timer_create
-260	common	timer_settime			sys_timer_settime32
-261	common	timer_gettime			sys_timer_gettime32
-262	common	timer_getoverrun		sys_timer_getoverrun
-263	common	timer_delete			sys_timer_delete
-264	common	clock_settime			sys_clock_settime32
-265	common	clock_gettime			sys_clock_gettime32
-266	common	clock_getres			sys_clock_getres_time32
-267	common	clock_nanosleep			sys_clock_nanosleep_time32
-268	common	statfs64			sys_statfs64
-269	common	fstatfs64			sys_fstatfs64
-270	common	tgkill				sys_tgkill
-271	common	utimes				sys_utimes_time32
-272	common	fadvise64_64			sys_fadvise64_64_wrapper
-# 273 is reserved for vserver
-274	common	mbind				sys_mbind
-275	common	get_mempolicy			sys_get_mempolicy
-276	common	set_mempolicy			sys_set_mempolicy
-277	common	mq_open				sys_mq_open
-278	common	mq_unlink			sys_mq_unlink
-279	common	mq_timedsend			sys_mq_timedsend_time32
-280	common	mq_timedreceive			sys_mq_timedreceive_time32
-281	common	mq_notify			sys_mq_notify
-282	common	mq_getsetattr			sys_mq_getsetattr
-283	common	kexec_load			sys_kexec_load
-284	common	waitid				sys_waitid
-285	common	add_key				sys_add_key
-286	common	request_key			sys_request_key
-287	common	keyctl				sys_keyctl
-288	common	ioprio_set			sys_ioprio_set
-289	common	ioprio_get			sys_ioprio_get
-290	common	inotify_init			sys_inotify_init
-291	common	inotify_add_watch		sys_inotify_add_watch
-292	common	inotify_rm_watch		sys_inotify_rm_watch
-# 293 is unused
-294	common	migrate_pages			sys_migrate_pages
-295	common	openat				sys_openat
-296	common	mkdirat				sys_mkdirat
-297	common	mknodat				sys_mknodat
-298	common	fchownat			sys_fchownat
-299	common	futimesat			sys_futimesat_time32
-300	common	fstatat64			sys_fstatat64
-301	common	unlinkat			sys_unlinkat
-302	common	renameat			sys_renameat
-303	common	linkat				sys_linkat
-304	common	symlinkat			sys_symlinkat
-305	common	readlinkat			sys_readlinkat
-306	common	fchmodat			sys_fchmodat
-307	common	faccessat			sys_faccessat
-308	common	pselect6			sys_pselect6_time32
-309	common	ppoll				sys_ppoll_time32
-310	common	unshare				sys_unshare
-311	common	set_robust_list			sys_set_robust_list
-312	common	get_robust_list			sys_get_robust_list
-313	common	splice				sys_splice
-314	common	sync_file_range			sys_sync_file_range
-315	common	tee				sys_tee
-316	common	vmsplice			sys_vmsplice
-317	common	move_pages			sys_move_pages
-318	common	getcpu				sys_getcpu
-319	common	epoll_pwait			sys_epoll_pwait
-320	common	utimensat			sys_utimensat_time32
-321	common	signalfd			sys_signalfd
-322	common	timerfd_create			sys_timerfd_create
-323	common	eventfd				sys_eventfd
-324	common	fallocate			sys_fallocate
-325	common	timerfd_settime			sys_timerfd_settime32
-326	common	timerfd_gettime			sys_timerfd_gettime32
-327	common	signalfd4			sys_signalfd4
-328	common	eventfd2			sys_eventfd2
-329	common	epoll_create1			sys_epoll_create1
-330	common	dup3				sys_dup3
-331	common	pipe2				sys_pipe2
-332	common	inotify_init1			sys_inotify_init1
-333	common	preadv				sys_preadv
-334	common	pwritev				sys_pwritev
-335	common	rt_tgsigqueueinfo		sys_rt_tgsigqueueinfo
-336	common	perf_event_open			sys_perf_event_open
-337	common	fanotify_init			sys_fanotify_init
-338	common	fanotify_mark			sys_fanotify_mark
-339	common	prlimit64			sys_prlimit64
-340	common	socket				sys_socket
-341	common	bind				sys_bind
-342	common	connect				sys_connect
-343	common	listen				sys_listen
-344	common	accept				sys_accept
-345	common	getsockname			sys_getsockname
-346	common	getpeername			sys_getpeername
-347	common	socketpair			sys_socketpair
-348	common	send				sys_send
-349	common	sendto				sys_sendto
-350	common	recv				sys_recv
-351	common	recvfrom			sys_recvfrom
-352	common	shutdown			sys_shutdown
-353	common	setsockopt			sys_setsockopt
-354	common	getsockopt			sys_getsockopt
-355	common	sendmsg				sys_sendmsg
-356	common	recvmsg				sys_recvmsg
-357	common	recvmmsg			sys_recvmmsg_time32
-358	common	accept4				sys_accept4
-359	common	name_to_handle_at		sys_name_to_handle_at
-360	common	open_by_handle_at		sys_open_by_handle_at
-361	common	clock_adjtime			sys_clock_adjtime32
-362	common	syncfs				sys_syncfs
-363	common	sendmmsg			sys_sendmmsg
-364	common	setns				sys_setns
-365	common	process_vm_readv		sys_process_vm_readv
-366	common	process_vm_writev		sys_process_vm_writev
-367	common	kcmp				sys_kcmp
-368	common	finit_module			sys_finit_module
-369	common	sched_getattr			sys_sched_getattr
-370	common	sched_setattr			sys_sched_setattr
-371	common	renameat2			sys_renameat2
-372	common	seccomp				sys_seccomp
-373	common	getrandom			sys_getrandom
-374	common	memfd_create			sys_memfd_create
-375	common	bpf				sys_bpf
-376	common	execveat			sys_execveat
-377	common	userfaultfd			sys_userfaultfd
-378	common	membarrier			sys_membarrier
-379	common	mlock2				sys_mlock2
-380	common	copy_file_range			sys_copy_file_range
-381	common	preadv2				sys_preadv2
-382	common	pwritev2			sys_pwritev2
-383	common	statx				sys_statx
-384	common	pkey_mprotect			sys_pkey_mprotect
-385	common	pkey_alloc			sys_pkey_alloc
-386	common	pkey_free			sys_pkey_free
-387	common	rseq				sys_rseq
-# room for arch specific syscalls
-393	common	semget				sys_semget
-394	common	semctl				sys_semctl
-395	common	shmget				sys_shmget
-396	common	shmctl				sys_shmctl
-397	common	shmat				sys_shmat
-398	common	shmdt				sys_shmdt
-399	common	msgget				sys_msgget
-400	common	msgsnd				sys_msgsnd
-401	common	msgrcv				sys_msgrcv
-402	common	msgctl				sys_msgctl
-403	common	clock_gettime64			sys_clock_gettime
-404	common	clock_settime64			sys_clock_settime
-405	common	clock_adjtime64			sys_clock_adjtime
-406	common	clock_getres_time64		sys_clock_getres
-407	common	clock_nanosleep_time64		sys_clock_nanosleep
-408	common	timer_gettime64			sys_timer_gettime
-409	common	timer_settime64			sys_timer_settime
-410	common	timerfd_gettime64		sys_timerfd_gettime
-411	common	timerfd_settime64		sys_timerfd_settime
-412	common	utimensat_time64		sys_utimensat
-413	common	pselect6_time64			sys_pselect6
-414	common	ppoll_time64			sys_ppoll
-416	common	io_pgetevents_time64		sys_io_pgetevents
-417	common	recvmmsg_time64			sys_recvmmsg
-418	common	mq_timedsend_time64		sys_mq_timedsend
-419	common	mq_timedreceive_time64		sys_mq_timedreceive
-420	common	semtimedop_time64		sys_semtimedop
-421	common	rt_sigtimedwait_time64		sys_rt_sigtimedwait
-422	common	futex_time64			sys_futex
-423	common	sched_rr_get_interval_time64	sys_sched_rr_get_interval
-424	common	pidfd_send_signal		sys_pidfd_send_signal
-425	common	io_uring_setup			sys_io_uring_setup
-426	common	io_uring_enter			sys_io_uring_enter
-427	common	io_uring_register		sys_io_uring_register
-428	common	open_tree			sys_open_tree
-429	common	move_mount			sys_move_mount
-430	common	fsopen				sys_fsopen
-431	common	fsconfig			sys_fsconfig
-432	common	fsmount				sys_fsmount
-433	common	fspick				sys_fspick
-434	common	pidfd_open			sys_pidfd_open
-# 435 reserved for clone3
-436	common	close_range			sys_close_range
-437	common	openat2				sys_openat2
-438	common	pidfd_getfd			sys_pidfd_getfd
-439	common	faccessat2			sys_faccessat2
-440	common	process_madvise			sys_process_madvise
-441	common	epoll_pwait2			sys_epoll_pwait2
-442	common	mount_setattr			sys_mount_setattr
-443	common	quotactl_fd			sys_quotactl_fd
-444	common	landlock_create_ruleset		sys_landlock_create_ruleset
-445	common	landlock_add_rule		sys_landlock_add_rule
-446	common	landlock_restrict_self		sys_landlock_restrict_self
-# 447 reserved for memfd_secret
-448	common	process_mrelease		sys_process_mrelease
-449	common  futex_waitv                     sys_futex_waitv
-450	common	set_mempolicy_home_node		sys_set_mempolicy_home_node
diff --git a/arch/sh/kernel/syscalls_32.S b/arch/sh/kernel/syscalls_32.S
deleted file mode 100644
index bd1a9c54476732..00000000000000
--- a/arch/sh/kernel/syscalls_32.S
+++ /dev/null
@@ -1,17 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * arch/sh/kernel/syscalls.S
- *
- * System call table for SuperH
- *
- *  Copyright (C) 1999, 2000, 2002  Niibe Yutaka
- *  Copyright (C) 2003  Paul Mundt
- */
-#include <linux/sys.h>
-#include <linux/linkage.h>
-
-#define __SYSCALL(nr, entry)	.long entry
-	.data
-ENTRY(sys_call_table)
-#include <asm/syscall_table.h>
-#undef __SYSCALL
diff --git a/arch/sh/kernel/time.c b/arch/sh/kernel/time.c
deleted file mode 100644
index 821a09cbd6054f..00000000000000
--- a/arch/sh/kernel/time.c
+++ /dev/null
@@ -1,45 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- *  arch/sh/kernel/time.c
- *
- *  Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
- *  Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
- *  Copyright (C) 2002 - 2009  Paul Mundt
- *  Copyright (C) 2002  M. R. Brown  <mrbrown@linux-sh.org>
- */
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/profile.h>
-#include <linux/timex.h>
-#include <linux/sched.h>
-#include <linux/clockchips.h>
-#include <linux/platform_device.h>
-#include <linux/smp.h>
-#include <linux/rtc.h>
-#include <asm/clock.h>
-#include <asm/rtc.h>
-#include <asm/platform_early.h>
-
-static void __init sh_late_time_init(void)
-{
-	/*
-	 * Make sure all compiled-in early timers register themselves.
-	 *
-	 * Run probe() for two "earlytimer" devices, these will be the
-	 * clockevents and clocksource devices respectively. In the event
-	 * that only a clockevents device is available, we -ENODEV on the
-	 * clocksource and the jiffies clocksource is used transparently
-	 * instead. No error handling is necessary here.
-	 */
-	sh_early_platform_driver_register_all("earlytimer");
-	sh_early_platform_driver_probe("earlytimer", 2, 0);
-}
-
-void __init time_init(void)
-{
-	timer_probe();
-
-	clk_init();
-
-	late_time_init = sh_late_time_init;
-}
diff --git a/arch/sh/kernel/topology.c b/arch/sh/kernel/topology.c
deleted file mode 100644
index 2d2a7509b565ac..00000000000000
--- a/arch/sh/kernel/topology.c
+++ /dev/null
@@ -1,74 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/topology.c
- *
- *  Copyright (C) 2007  Paul Mundt
- */
-#include <linux/cpu.h>
-#include <linux/cpumask.h>
-#include <linux/init.h>
-#include <linux/percpu.h>
-#include <linux/topology.h>
-#include <linux/node.h>
-#include <linux/nodemask.h>
-#include <linux/export.h>
-
-static DEFINE_PER_CPU(struct cpu, cpu_devices);
-
-cpumask_t cpu_core_map[NR_CPUS];
-EXPORT_SYMBOL(cpu_core_map);
-
-static cpumask_t cpu_coregroup_map(int cpu)
-{
-	/*
-	 * Presently all SH-X3 SMP cores are multi-cores, so just keep it
-	 * simple until we have a method for determining topology..
-	 */
-	return *cpu_possible_mask;
-}
-
-const struct cpumask *cpu_coregroup_mask(int cpu)
-{
-	return &cpu_core_map[cpu];
-}
-
-int arch_update_cpu_topology(void)
-{
-	unsigned int cpu;
-
-	for_each_possible_cpu(cpu)
-		cpu_core_map[cpu] = cpu_coregroup_map(cpu);
-
-	return 0;
-}
-
-static int __init topology_init(void)
-{
-	int i, ret;
-
-	for_each_present_cpu(i) {
-		struct cpu *c = &per_cpu(cpu_devices, i);
-
-		c->hotpluggable = 1;
-
-		ret = register_cpu(c, i);
-		if (unlikely(ret))
-			printk(KERN_WARNING "%s: register_cpu %d failed (%d)\n",
-			       __func__, i, ret);
-	}
-
-#if defined(CONFIG_NUMA) && !defined(CONFIG_SMP)
-	/*
-	 * In the UP case, make sure the CPU association is still
-	 * registered under each node. Without this, sysfs fails
-	 * to make the connection between nodes other than node0
-	 * and cpu0.
-	 */
-	for_each_online_node(i)
-		if (i != numa_node_id())
-			register_cpu_under_node(raw_smp_processor_id(), i);
-#endif
-
-	return 0;
-}
-subsys_initcall(topology_init);
diff --git a/arch/sh/kernel/traps.c b/arch/sh/kernel/traps.c
deleted file mode 100644
index 01884054aeb2bd..00000000000000
--- a/arch/sh/kernel/traps.c
+++ /dev/null
@@ -1,204 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/bug.h>
-#include <linux/io.h>
-#include <linux/types.h>
-#include <linux/kdebug.h>
-#include <linux/signal.h>
-#include <linux/sched.h>
-#include <linux/sched/debug.h>
-#include <linux/sched/task_stack.h>
-#include <linux/uaccess.h>
-#include <linux/hardirq.h>
-#include <linux/kernel.h>
-#include <linux/kexec.h>
-#include <linux/sched/signal.h>
-
-#include <linux/extable.h>
-#include <linux/module.h>	/* print_modules */
-#include <asm/unwinder.h>
-#include <asm/traps.h>
-
-static DEFINE_SPINLOCK(die_lock);
-
-void __noreturn die(const char *str, struct pt_regs *regs, long err)
-{
-	static int die_counter;
-
-	oops_enter();
-
-	spin_lock_irq(&die_lock);
-	console_verbose();
-	bust_spinlocks(1);
-
-	printk("%s: %04lx [#%d]\n", str, err & 0xffff, ++die_counter);
-	print_modules();
-	show_regs(regs);
-
-	printk("Process: %s (pid: %d, stack limit = %p)\n", current->comm,
-			task_pid_nr(current), task_stack_page(current) + 1);
-
-	if (!user_mode(regs) || in_interrupt())
-		dump_mem("Stack: ", KERN_DEFAULT, regs->regs[15],
-			THREAD_SIZE + (unsigned long)task_stack_page(current));
-
-	notify_die(DIE_OOPS, str, regs, err, 255, SIGSEGV);
-
-	bust_spinlocks(0);
-	add_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);
-	spin_unlock_irq(&die_lock);
-	oops_exit();
-
-	if (kexec_should_crash(current))
-		crash_kexec(regs);
-
-	if (in_interrupt())
-		panic("Fatal exception in interrupt");
-
-	if (panic_on_oops)
-		panic("Fatal exception");
-
-	make_task_dead(SIGSEGV);
-}
-
-void die_if_kernel(const char *str, struct pt_regs *regs, long err)
-{
-	if (!user_mode(regs))
-		die(str, regs, err);
-}
-
-/*
- * try and fix up kernelspace address errors
- * - userspace errors just cause EFAULT to be returned, resulting in SEGV
- * - kernel/userspace interfaces cause a jump to an appropriate handler
- * - other kernel errors are bad
- */
-void die_if_no_fixup(const char *str, struct pt_regs *regs, long err)
-{
-	if (!user_mode(regs)) {
-		const struct exception_table_entry *fixup;
-		fixup = search_exception_tables(regs->pc);
-		if (fixup) {
-			regs->pc = fixup->fixup;
-			return;
-		}
-
-		die(str, regs, err);
-	}
-}
-
-#ifdef CONFIG_GENERIC_BUG
-static void handle_BUG(struct pt_regs *regs)
-{
-	const struct bug_entry *bug;
-	unsigned long bugaddr = regs->pc;
-	enum bug_trap_type tt;
-
-	if (!is_valid_bugaddr(bugaddr))
-		goto invalid;
-
-	bug = find_bug(bugaddr);
-
-	/* Switch unwinders when unwind_stack() is called */
-	if (bug->flags & BUGFLAG_UNWINDER)
-		unwinder_faulted = 1;
-
-	tt = report_bug(bugaddr, regs);
-	if (tt == BUG_TRAP_TYPE_WARN) {
-		regs->pc += instruction_size(bugaddr);
-		return;
-	}
-
-invalid:
-	die("Kernel BUG", regs, TRAPA_BUG_OPCODE & 0xff);
-}
-
-int is_valid_bugaddr(unsigned long addr)
-{
-	insn_size_t opcode;
-
-	if (addr < PAGE_OFFSET)
-		return 0;
-	if (get_kernel_nofault(opcode, (insn_size_t *)addr))
-		return 0;
-	if (opcode == TRAPA_BUG_OPCODE)
-		return 1;
-
-	return 0;
-}
-#endif
-
-/*
- * Generic trap handler.
- */
-BUILD_TRAP_HANDLER(debug)
-{
-	TRAP_HANDLER_DECL;
-
-	/* Rewind */
-	regs->pc -= instruction_size(__raw_readw(regs->pc - 4));
-
-	if (notify_die(DIE_TRAP, "debug trap", regs, 0, vec & 0xff,
-		       SIGTRAP) == NOTIFY_STOP)
-		return;
-
-	force_sig(SIGTRAP);
-}
-
-/*
- * Special handler for BUG() traps.
- */
-BUILD_TRAP_HANDLER(bug)
-{
-	TRAP_HANDLER_DECL;
-
-	/* Rewind */
-	regs->pc -= instruction_size(__raw_readw(regs->pc - 4));
-
-	if (notify_die(DIE_TRAP, "bug trap", regs, 0, TRAPA_BUG_OPCODE & 0xff,
-		       SIGTRAP) == NOTIFY_STOP)
-		return;
-
-#ifdef CONFIG_GENERIC_BUG
-	if (__kernel_text_address(instruction_pointer(regs))) {
-		insn_size_t insn = *(insn_size_t *)instruction_pointer(regs);
-		if (insn == TRAPA_BUG_OPCODE)
-			handle_BUG(regs);
-		return;
-	}
-#endif
-
-	force_sig(SIGTRAP);
-}
-
-#ifdef CONFIG_DYNAMIC_FTRACE
-extern void arch_ftrace_nmi_enter(void);
-extern void arch_ftrace_nmi_exit(void);
-#else
-static inline void arch_ftrace_nmi_enter(void) { }
-static inline void arch_ftrace_nmi_exit(void) { }
-#endif
-
-BUILD_TRAP_HANDLER(nmi)
-{
-	TRAP_HANDLER_DECL;
-
-	arch_ftrace_nmi_enter();
-
-	nmi_enter();
-	this_cpu_inc(irq_stat.__nmi_count);
-
-	switch (notify_die(DIE_NMI, "NMI", regs, 0, vec & 0xff, SIGINT)) {
-	case NOTIFY_OK:
-	case NOTIFY_STOP:
-		break;
-	case NOTIFY_BAD:
-		die("Fatal Non-Maskable Interrupt", regs, SIGINT);
-	default:
-		printk(KERN_ALERT "Got NMI, but nobody cared. Ignoring...\n");
-		break;
-	}
-
-	nmi_exit();
-
-	arch_ftrace_nmi_exit();
-}
diff --git a/arch/sh/kernel/traps_32.c b/arch/sh/kernel/traps_32.c
deleted file mode 100644
index 6cdda3a621a1e5..00000000000000
--- a/arch/sh/kernel/traps_32.c
+++ /dev/null
@@ -1,795 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * 'traps.c' handles hardware traps and faults after we have saved some
- * state in 'entry.S'.
- *
- *  SuperH version: Copyright (C) 1999 Niibe Yutaka
- *                  Copyright (C) 2000 Philipp Rumpf
- *                  Copyright (C) 2000 David Howells
- *                  Copyright (C) 2002 - 2010 Paul Mundt
- */
-#include <linux/kernel.h>
-#include <linux/ptrace.h>
-#include <linux/hardirq.h>
-#include <linux/init.h>
-#include <linux/spinlock.h>
-#include <linux/kallsyms.h>
-#include <linux/io.h>
-#include <linux/bug.h>
-#include <linux/debug_locks.h>
-#include <linux/kdebug.h>
-#include <linux/limits.h>
-#include <linux/sysfs.h>
-#include <linux/uaccess.h>
-#include <linux/perf_event.h>
-#include <linux/sched/task_stack.h>
-
-#include <asm/alignment.h>
-#include <asm/fpu.h>
-#include <asm/kprobes.h>
-#include <asm/traps.h>
-#include <asm/bl_bit.h>
-
-#ifdef CONFIG_CPU_SH2
-# define TRAP_RESERVED_INST	4
-# define TRAP_ILLEGAL_SLOT_INST	6
-# define TRAP_ADDRESS_ERROR	9
-# ifdef CONFIG_CPU_SH2A
-#  define TRAP_UBC		12
-#  define TRAP_FPU_ERROR	13
-#  define TRAP_DIVZERO_ERROR	17
-#  define TRAP_DIVOVF_ERROR	18
-# endif
-#else
-#define TRAP_RESERVED_INST	12
-#define TRAP_ILLEGAL_SLOT_INST	13
-#endif
-
-static inline void sign_extend(unsigned int count, unsigned char *dst)
-{
-#ifdef __LITTLE_ENDIAN__
-	if ((count == 1) && dst[0] & 0x80) {
-		dst[1] = 0xff;
-		dst[2] = 0xff;
-		dst[3] = 0xff;
-	}
-	if ((count == 2) && dst[1] & 0x80) {
-		dst[2] = 0xff;
-		dst[3] = 0xff;
-	}
-#else
-	if ((count == 1) && dst[3] & 0x80) {
-		dst[2] = 0xff;
-		dst[1] = 0xff;
-		dst[0] = 0xff;
-	}
-	if ((count == 2) && dst[2] & 0x80) {
-		dst[1] = 0xff;
-		dst[0] = 0xff;
-	}
-#endif
-}
-
-static struct mem_access user_mem_access = {
-	copy_from_user,
-	copy_to_user,
-};
-
-static unsigned long copy_from_kernel_wrapper(void *dst, const void __user *src,
-					      unsigned long cnt)
-{
-	return copy_from_kernel_nofault(dst, (const void __force *)src, cnt);
-}
-
-static unsigned long copy_to_kernel_wrapper(void __user *dst, const void *src,
-					    unsigned long cnt)
-{
-	return copy_to_kernel_nofault((void __force *)dst, src, cnt);
-}
-
-static struct mem_access kernel_mem_access = {
-	copy_from_kernel_wrapper,
-	copy_to_kernel_wrapper,
-};
-
-/*
- * handle an instruction that does an unaligned memory access by emulating the
- * desired behaviour
- * - note that PC _may not_ point to the faulting instruction
- *   (if that instruction is in a branch delay slot)
- * - return 0 if emulation okay, -EFAULT on existential error
- */
-static int handle_unaligned_ins(insn_size_t instruction, struct pt_regs *regs,
-				struct mem_access *ma)
-{
-	int ret, index, count;
-	unsigned long *rm, *rn;
-	unsigned char *src, *dst;
-	unsigned char __user *srcu, *dstu;
-
-	index = (instruction>>8)&15;	/* 0x0F00 */
-	rn = &regs->regs[index];
-
-	index = (instruction>>4)&15;	/* 0x00F0 */
-	rm = &regs->regs[index];
-
-	count = 1<<(instruction&3);
-
-	switch (count) {
-	case 1: inc_unaligned_byte_access(); break;
-	case 2: inc_unaligned_word_access(); break;
-	case 4: inc_unaligned_dword_access(); break;
-	case 8: inc_unaligned_multi_access(); break;
-	}
-
-	ret = -EFAULT;
-	switch (instruction>>12) {
-	case 0: /* mov.[bwl] to/from memory via r0+rn */
-		if (instruction & 8) {
-			/* from memory */
-			srcu = (unsigned char __user *)*rm;
-			srcu += regs->regs[0];
-			dst = (unsigned char *)rn;
-			*(unsigned long *)dst = 0;
-
-#if !defined(__LITTLE_ENDIAN__)
-			dst += 4-count;
-#endif
-			if (ma->from(dst, srcu, count))
-				goto fetch_fault;
-
-			sign_extend(count, dst);
-		} else {
-			/* to memory */
-			src = (unsigned char *)rm;
-#if !defined(__LITTLE_ENDIAN__)
-			src += 4-count;
-#endif
-			dstu = (unsigned char __user *)*rn;
-			dstu += regs->regs[0];
-
-			if (ma->to(dstu, src, count))
-				goto fetch_fault;
-		}
-		ret = 0;
-		break;
-
-	case 1: /* mov.l Rm,@(disp,Rn) */
-		src = (unsigned char*) rm;
-		dstu = (unsigned char __user *)*rn;
-		dstu += (instruction&0x000F)<<2;
-
-		if (ma->to(dstu, src, 4))
-			goto fetch_fault;
-		ret = 0;
-		break;
-
-	case 2: /* mov.[bwl] to memory, possibly with pre-decrement */
-		if (instruction & 4)
-			*rn -= count;
-		src = (unsigned char*) rm;
-		dstu = (unsigned char __user *)*rn;
-#if !defined(__LITTLE_ENDIAN__)
-		src += 4-count;
-#endif
-		if (ma->to(dstu, src, count))
-			goto fetch_fault;
-		ret = 0;
-		break;
-
-	case 5: /* mov.l @(disp,Rm),Rn */
-		srcu = (unsigned char __user *)*rm;
-		srcu += (instruction & 0x000F) << 2;
-		dst = (unsigned char *)rn;
-		*(unsigned long *)dst = 0;
-
-		if (ma->from(dst, srcu, 4))
-			goto fetch_fault;
-		ret = 0;
-		break;
-
-	case 6:	/* mov.[bwl] from memory, possibly with post-increment */
-		srcu = (unsigned char __user *)*rm;
-		if (instruction & 4)
-			*rm += count;
-		dst = (unsigned char*) rn;
-		*(unsigned long*)dst = 0;
-
-#if !defined(__LITTLE_ENDIAN__)
-		dst += 4-count;
-#endif
-		if (ma->from(dst, srcu, count))
-			goto fetch_fault;
-		sign_extend(count, dst);
-		ret = 0;
-		break;
-
-	case 8:
-		switch ((instruction&0xFF00)>>8) {
-		case 0x81: /* mov.w R0,@(disp,Rn) */
-			src = (unsigned char *) &regs->regs[0];
-#if !defined(__LITTLE_ENDIAN__)
-			src += 2;
-#endif
-			dstu = (unsigned char __user *)*rm; /* called Rn in the spec */
-			dstu += (instruction & 0x000F) << 1;
-
-			if (ma->to(dstu, src, 2))
-				goto fetch_fault;
-			ret = 0;
-			break;
-
-		case 0x85: /* mov.w @(disp,Rm),R0 */
-			srcu = (unsigned char __user *)*rm;
-			srcu += (instruction & 0x000F) << 1;
-			dst = (unsigned char *) &regs->regs[0];
-			*(unsigned long *)dst = 0;
-
-#if !defined(__LITTLE_ENDIAN__)
-			dst += 2;
-#endif
-			if (ma->from(dst, srcu, 2))
-				goto fetch_fault;
-			sign_extend(2, dst);
-			ret = 0;
-			break;
-		}
-		break;
-
-	case 9: /* mov.w @(disp,PC),Rn */
-		srcu = (unsigned char __user *)regs->pc;
-		srcu += 4;
-		srcu += (instruction & 0x00FF) << 1;
-		dst = (unsigned char *)rn;
-		*(unsigned long *)dst = 0;
-
-#if !defined(__LITTLE_ENDIAN__)
-		dst += 2;
-#endif
-
-		if (ma->from(dst, srcu, 2))
-			goto fetch_fault;
-		sign_extend(2, dst);
-		ret = 0;
-		break;
-
-	case 0xd: /* mov.l @(disp,PC),Rn */
-		srcu = (unsigned char __user *)(regs->pc & ~0x3);
-		srcu += 4;
-		srcu += (instruction & 0x00FF) << 2;
-		dst = (unsigned char *)rn;
-		*(unsigned long *)dst = 0;
-
-		if (ma->from(dst, srcu, 4))
-			goto fetch_fault;
-		ret = 0;
-		break;
-	}
-	return ret;
-
- fetch_fault:
-	/* Argh. Address not only misaligned but also non-existent.
-	 * Raise an EFAULT and see if it's trapped
-	 */
-	die_if_no_fixup("Fault in unaligned fixup", regs, 0);
-	return -EFAULT;
-}
-
-/*
- * emulate the instruction in the delay slot
- * - fetches the instruction from PC+2
- */
-static inline int handle_delayslot(struct pt_regs *regs,
-				   insn_size_t old_instruction,
-				   struct mem_access *ma)
-{
-	insn_size_t instruction;
-	void __user *addr = (void __user *)(regs->pc +
-		instruction_size(old_instruction));
-
-	if (copy_from_user(&instruction, addr, sizeof(instruction))) {
-		/* the instruction-fetch faulted */
-		if (user_mode(regs))
-			return -EFAULT;
-
-		/* kernel */
-		die("delay-slot-insn faulting in handle_unaligned_delayslot",
-		    regs, 0);
-	}
-
-	return handle_unaligned_ins(instruction, regs, ma);
-}
-
-/*
- * handle an instruction that does an unaligned memory access
- * - have to be careful of branch delay-slot instructions that fault
- *  SH3:
- *   - if the branch would be taken PC points to the branch
- *   - if the branch would not be taken, PC points to delay-slot
- *  SH4:
- *   - PC always points to delayed branch
- * - return 0 if handled, -EFAULT if failed (may not return if in kernel)
- */
-
-/* Macros to determine offset from current PC for branch instructions */
-/* Explicit type coercion is used to force sign extension where needed */
-#define SH_PC_8BIT_OFFSET(instr) ((((signed char)(instr))*2) + 4)
-#define SH_PC_12BIT_OFFSET(instr) ((((signed short)(instr<<4))>>3) + 4)
-
-int handle_unaligned_access(insn_size_t instruction, struct pt_regs *regs,
-			    struct mem_access *ma, int expected,
-			    unsigned long address)
-{
-	u_int rm;
-	int ret, index;
-
-	/*
-	 * XXX: We can't handle mixed 16/32-bit instructions yet
-	 */
-	if (instruction_size(instruction) != 2)
-		return -EINVAL;
-
-	index = (instruction>>8)&15;	/* 0x0F00 */
-	rm = regs->regs[index];
-
-	/*
-	 * Log the unexpected fixups, and then pass them on to perf.
-	 *
-	 * We intentionally don't report the expected cases to perf as
-	 * otherwise the trapped I/O case will skew the results too much
-	 * to be useful.
-	 */
-	if (!expected) {
-		unaligned_fixups_notify(current, instruction, regs);
-		perf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1,
-			      regs, address);
-	}
-
-	ret = -EFAULT;
-	switch (instruction&0xF000) {
-	case 0x0000:
-		if (instruction==0x000B) {
-			/* rts */
-			ret = handle_delayslot(regs, instruction, ma);
-			if (ret==0)
-				regs->pc = regs->pr;
-		}
-		else if ((instruction&0x00FF)==0x0023) {
-			/* braf @Rm */
-			ret = handle_delayslot(regs, instruction, ma);
-			if (ret==0)
-				regs->pc += rm + 4;
-		}
-		else if ((instruction&0x00FF)==0x0003) {
-			/* bsrf @Rm */
-			ret = handle_delayslot(regs, instruction, ma);
-			if (ret==0) {
-				regs->pr = regs->pc + 4;
-				regs->pc += rm + 4;
-			}
-		}
-		else {
-			/* mov.[bwl] to/from memory via r0+rn */
-			goto simple;
-		}
-		break;
-
-	case 0x1000: /* mov.l Rm,@(disp,Rn) */
-		goto simple;
-
-	case 0x2000: /* mov.[bwl] to memory, possibly with pre-decrement */
-		goto simple;
-
-	case 0x4000:
-		if ((instruction&0x00FF)==0x002B) {
-			/* jmp @Rm */
-			ret = handle_delayslot(regs, instruction, ma);
-			if (ret==0)
-				regs->pc = rm;
-		}
-		else if ((instruction&0x00FF)==0x000B) {
-			/* jsr @Rm */
-			ret = handle_delayslot(regs, instruction, ma);
-			if (ret==0) {
-				regs->pr = regs->pc + 4;
-				regs->pc = rm;
-			}
-		}
-		else {
-			/* mov.[bwl] to/from memory via r0+rn */
-			goto simple;
-		}
-		break;
-
-	case 0x5000: /* mov.l @(disp,Rm),Rn */
-		goto simple;
-
-	case 0x6000: /* mov.[bwl] from memory, possibly with post-increment */
-		goto simple;
-
-	case 0x8000: /* bf lab, bf/s lab, bt lab, bt/s lab */
-		switch (instruction&0x0F00) {
-		case 0x0100: /* mov.w R0,@(disp,Rm) */
-			goto simple;
-		case 0x0500: /* mov.w @(disp,Rm),R0 */
-			goto simple;
-		case 0x0B00: /* bf   lab - no delayslot*/
-			ret = 0;
-			break;
-		case 0x0F00: /* bf/s lab */
-			ret = handle_delayslot(regs, instruction, ma);
-			if (ret==0) {
-#if defined(CONFIG_CPU_SH4) || defined(CONFIG_SH7705_CACHE_32KB)
-				if ((regs->sr & 0x00000001) != 0)
-					regs->pc += 4; /* next after slot */
-				else
-#endif
-					regs->pc += SH_PC_8BIT_OFFSET(instruction);
-			}
-			break;
-		case 0x0900: /* bt   lab - no delayslot */
-			ret = 0;
-			break;
-		case 0x0D00: /* bt/s lab */
-			ret = handle_delayslot(regs, instruction, ma);
-			if (ret==0) {
-#if defined(CONFIG_CPU_SH4) || defined(CONFIG_SH7705_CACHE_32KB)
-				if ((regs->sr & 0x00000001) == 0)
-					regs->pc += 4; /* next after slot */
-				else
-#endif
-					regs->pc += SH_PC_8BIT_OFFSET(instruction);
-			}
-			break;
-		}
-		break;
-
-	case 0x9000: /* mov.w @(disp,Rm),Rn */
-		goto simple;
-
-	case 0xA000: /* bra label */
-		ret = handle_delayslot(regs, instruction, ma);
-		if (ret==0)
-			regs->pc += SH_PC_12BIT_OFFSET(instruction);
-		break;
-
-	case 0xB000: /* bsr label */
-		ret = handle_delayslot(regs, instruction, ma);
-		if (ret==0) {
-			regs->pr = regs->pc + 4;
-			regs->pc += SH_PC_12BIT_OFFSET(instruction);
-		}
-		break;
-
-	case 0xD000: /* mov.l @(disp,Rm),Rn */
-		goto simple;
-	}
-	return ret;
-
-	/* handle non-delay-slot instruction */
- simple:
-	ret = handle_unaligned_ins(instruction, regs, ma);
-	if (ret==0)
-		regs->pc += instruction_size(instruction);
-	return ret;
-}
-
-/*
- * Handle various address error exceptions:
- *  - instruction address error:
- *       misaligned PC
- *       PC >= 0x80000000 in user mode
- *  - data address error (read and write)
- *       misaligned data access
- *       access to >= 0x80000000 is user mode
- * Unfortuntaly we can't distinguish between instruction address error
- * and data address errors caused by read accesses.
- */
-asmlinkage void do_address_error(struct pt_regs *regs,
-				 unsigned long writeaccess,
-				 unsigned long address)
-{
-	unsigned long error_code = 0;
-	insn_size_t instruction;
-	int tmp;
-
-	/* Intentional ifdef */
-#ifdef CONFIG_CPU_HAS_SR_RB
-	error_code = lookup_exception_vector();
-#endif
-
-	if (user_mode(regs)) {
-		int si_code = BUS_ADRERR;
-		unsigned int user_action;
-
-		local_irq_enable();
-		inc_unaligned_user_access();
-
-		if (copy_from_user(&instruction, (insn_size_t __user *)(regs->pc & ~1),
-				   sizeof(instruction))) {
-			goto uspace_segv;
-		}
-
-		/* shout about userspace fixups */
-		unaligned_fixups_notify(current, instruction, regs);
-
-		user_action = unaligned_user_action();
-		if (user_action & UM_FIXUP)
-			goto fixup;
-		if (user_action & UM_SIGNAL)
-			goto uspace_segv;
-		else {
-			/* ignore */
-			regs->pc += instruction_size(instruction);
-			return;
-		}
-
-fixup:
-		/* bad PC is not something we can fix */
-		if (regs->pc & 1) {
-			si_code = BUS_ADRALN;
-			goto uspace_segv;
-		}
-
-		tmp = handle_unaligned_access(instruction, regs,
-					      &user_mem_access, 0,
-					      address);
-
-		if (tmp == 0)
-			return; /* sorted */
-uspace_segv:
-		printk(KERN_NOTICE "Sending SIGBUS to \"%s\" due to unaligned "
-		       "access (PC %lx PR %lx)\n", current->comm, regs->pc,
-		       regs->pr);
-
-		force_sig_fault(SIGBUS, si_code, (void __user *)address);
-	} else {
-		inc_unaligned_kernel_access();
-
-		if (regs->pc & 1)
-			die("unaligned program counter", regs, error_code);
-
-		if (copy_from_kernel_nofault(&instruction, (void *)(regs->pc),
-				   sizeof(instruction))) {
-			/* Argh. Fault on the instruction itself.
-			   This should never happen non-SMP
-			*/
-			die("insn faulting in do_address_error", regs, 0);
-		}
-
-		unaligned_fixups_notify(current, instruction, regs);
-
-		handle_unaligned_access(instruction, regs, &kernel_mem_access,
-					0, address);
-	}
-}
-
-#ifdef CONFIG_SH_DSP
-/*
- *	SH-DSP support gerg@snapgear.com.
- */
-int is_dsp_inst(struct pt_regs *regs)
-{
-	unsigned short inst = 0;
-
-	/*
-	 * Safe guard if DSP mode is already enabled or we're lacking
-	 * the DSP altogether.
-	 */
-	if (!(current_cpu_data.flags & CPU_HAS_DSP) || (regs->sr & SR_DSP))
-		return 0;
-
-	get_user(inst, ((unsigned short *) regs->pc));
-
-	inst &= 0xf000;
-
-	/* Check for any type of DSP or support instruction */
-	if ((inst == 0xf000) || (inst == 0x4000))
-		return 1;
-
-	return 0;
-}
-#else
-#define is_dsp_inst(regs)	(0)
-#endif /* CONFIG_SH_DSP */
-
-#ifdef CONFIG_CPU_SH2A
-asmlinkage void do_divide_error(unsigned long r4)
-{
-	int code;
-
-	switch (r4) {
-	case TRAP_DIVZERO_ERROR:
-		code = FPE_INTDIV;
-		break;
-	case TRAP_DIVOVF_ERROR:
-		code = FPE_INTOVF;
-		break;
-	default:
-		/* Let gcc know unhandled cases don't make it past here */
-		return;
-	}
-	force_sig_fault(SIGFPE, code, NULL);
-}
-#endif
-
-asmlinkage void do_reserved_inst(void)
-{
-	struct pt_regs *regs = current_pt_regs();
-	unsigned long error_code;
-
-#ifdef CONFIG_SH_FPU_EMU
-	unsigned short inst = 0;
-	int err;
-
-	get_user(inst, (unsigned short __user *)regs->pc);
-
-	err = do_fpu_inst(inst, regs);
-	if (!err) {
-		regs->pc += instruction_size(inst);
-		return;
-	}
-	/* not a FPU inst. */
-#endif
-
-#ifdef CONFIG_SH_DSP
-	/* Check if it's a DSP instruction */
-	if (is_dsp_inst(regs)) {
-		/* Enable DSP mode, and restart instruction. */
-		regs->sr |= SR_DSP;
-		/* Save DSP mode */
-		current->thread.dsp_status.status |= SR_DSP;
-		return;
-	}
-#endif
-
-	error_code = lookup_exception_vector();
-
-	local_irq_enable();
-	force_sig(SIGILL);
-	die_if_no_fixup("reserved instruction", regs, error_code);
-}
-
-#ifdef CONFIG_SH_FPU_EMU
-static int emulate_branch(unsigned short inst, struct pt_regs *regs)
-{
-	/*
-	 * bfs: 8fxx: PC+=d*2+4;
-	 * bts: 8dxx: PC+=d*2+4;
-	 * bra: axxx: PC+=D*2+4;
-	 * bsr: bxxx: PC+=D*2+4  after PR=PC+4;
-	 * braf:0x23: PC+=Rn*2+4;
-	 * bsrf:0x03: PC+=Rn*2+4 after PR=PC+4;
-	 * jmp: 4x2b: PC=Rn;
-	 * jsr: 4x0b: PC=Rn      after PR=PC+4;
-	 * rts: 000b: PC=PR;
-	 */
-	if (((inst & 0xf000) == 0xb000)  ||	/* bsr */
-	    ((inst & 0xf0ff) == 0x0003)  ||	/* bsrf */
-	    ((inst & 0xf0ff) == 0x400b))	/* jsr */
-		regs->pr = regs->pc + 4;
-
-	if ((inst & 0xfd00) == 0x8d00) {	/* bfs, bts */
-		regs->pc += SH_PC_8BIT_OFFSET(inst);
-		return 0;
-	}
-
-	if ((inst & 0xe000) == 0xa000) {	/* bra, bsr */
-		regs->pc += SH_PC_12BIT_OFFSET(inst);
-		return 0;
-	}
-
-	if ((inst & 0xf0df) == 0x0003) {	/* braf, bsrf */
-		regs->pc += regs->regs[(inst & 0x0f00) >> 8] + 4;
-		return 0;
-	}
-
-	if ((inst & 0xf0df) == 0x400b) {	/* jmp, jsr */
-		regs->pc = regs->regs[(inst & 0x0f00) >> 8];
-		return 0;
-	}
-
-	if ((inst & 0xffff) == 0x000b) {	/* rts */
-		regs->pc = regs->pr;
-		return 0;
-	}
-
-	return 1;
-}
-#endif
-
-asmlinkage void do_illegal_slot_inst(void)
-{
-	struct pt_regs *regs = current_pt_regs();
-	unsigned long inst;
-
-	if (kprobe_handle_illslot(regs->pc) == 0)
-		return;
-
-#ifdef CONFIG_SH_FPU_EMU
-	get_user(inst, (unsigned short __user *)regs->pc + 1);
-	if (!do_fpu_inst(inst, regs)) {
-		get_user(inst, (unsigned short __user *)regs->pc);
-		if (!emulate_branch(inst, regs))
-			return;
-		/* fault in branch.*/
-	}
-	/* not a FPU inst. */
-#endif
-
-	inst = lookup_exception_vector();
-
-	local_irq_enable();
-	force_sig(SIGILL);
-	die_if_no_fixup("illegal slot instruction", regs, inst);
-}
-
-asmlinkage void do_exception_error(void)
-{
-	long ex;
-
-	ex = lookup_exception_vector();
-	die_if_kernel("exception", current_pt_regs(), ex);
-}
-
-void per_cpu_trap_init(void)
-{
-	extern void *vbr_base;
-
-	/* NOTE: The VBR value should be at P1
-	   (or P2, virtural "fixed" address space).
-	   It's definitely should not in physical address.  */
-
-	asm volatile("ldc	%0, vbr"
-		     : /* no output */
-		     : "r" (&vbr_base)
-		     : "memory");
-
-	/* disable exception blocking now when the vbr has been setup */
-	clear_bl_bit();
-}
-
-void *set_exception_table_vec(unsigned int vec, void *handler)
-{
-	extern void *exception_handling_table[];
-	void *old_handler;
-
-	old_handler = exception_handling_table[vec];
-	exception_handling_table[vec] = handler;
-	return old_handler;
-}
-
-void __init trap_init(void)
-{
-	set_exception_table_vec(TRAP_RESERVED_INST, do_reserved_inst);
-	set_exception_table_vec(TRAP_ILLEGAL_SLOT_INST, do_illegal_slot_inst);
-
-#if defined(CONFIG_CPU_SH4) && !defined(CONFIG_SH_FPU) || \
-    defined(CONFIG_SH_FPU_EMU)
-	/*
-	 * For SH-4 lacking an FPU, treat floating point instructions as
-	 * reserved. They'll be handled in the math-emu case, or faulted on
-	 * otherwise.
-	 */
-	set_exception_table_evt(0x800, do_reserved_inst);
-	set_exception_table_evt(0x820, do_illegal_slot_inst);
-#elif defined(CONFIG_SH_FPU)
-	set_exception_table_evt(0x800, fpu_state_restore_trap_handler);
-	set_exception_table_evt(0x820, fpu_state_restore_trap_handler);
-#endif
-
-#ifdef CONFIG_CPU_SH2
-	set_exception_table_vec(TRAP_ADDRESS_ERROR, address_error_trap_handler);
-#endif
-#ifdef CONFIG_CPU_SH2A
-	set_exception_table_vec(TRAP_DIVZERO_ERROR, do_divide_error);
-	set_exception_table_vec(TRAP_DIVOVF_ERROR, do_divide_error);
-#ifdef CONFIG_SH_FPU
-	set_exception_table_vec(TRAP_FPU_ERROR, fpu_error_trap_handler);
-#endif
-#endif
-
-#ifdef TRAP_UBC
-	set_exception_table_vec(TRAP_UBC, breakpoint_trap_handler);
-#endif
-}
diff --git a/arch/sh/kernel/unwinder.c b/arch/sh/kernel/unwinder.c
deleted file mode 100644
index 7a54b72dd92377..00000000000000
--- a/arch/sh/kernel/unwinder.c
+++ /dev/null
@@ -1,165 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (C) 2009  Matt Fleming
- *
- * Based, in part, on kernel/time/clocksource.c.
- *
- * This file provides arbitration code for stack unwinders.
- *
- * Multiple stack unwinders can be available on a system, usually with
- * the most accurate unwinder being the currently active one.
- */
-#include <linux/errno.h>
-#include <linux/list.h>
-#include <linux/spinlock.h>
-#include <linux/module.h>
-#include <asm/unwinder.h>
-#include <linux/atomic.h>
-
-/*
- * This is the most basic stack unwinder an architecture can
- * provide. For architectures without reliable frame pointers, e.g.
- * RISC CPUs, it can be implemented by looking through the stack for
- * addresses that lie within the kernel text section.
- *
- * Other CPUs, e.g. x86, can use their frame pointer register to
- * construct more accurate stack traces.
- */
-static struct list_head unwinder_list;
-static struct unwinder stack_reader = {
-	.name = "stack-reader",
-	.dump = stack_reader_dump,
-	.rating = 50,
-	.list = {
-		.next = &unwinder_list,
-		.prev = &unwinder_list,
-	},
-};
-
-/*
- * "curr_unwinder" points to the stack unwinder currently in use. This
- * is the unwinder with the highest rating.
- *
- * "unwinder_list" is a linked-list of all available unwinders, sorted
- * by rating.
- *
- * All modifications of "curr_unwinder" and "unwinder_list" must be
- * performed whilst holding "unwinder_lock".
- */
-static struct unwinder *curr_unwinder = &stack_reader;
-
-static struct list_head unwinder_list = {
-	.next = &stack_reader.list,
-	.prev = &stack_reader.list,
-};
-
-static DEFINE_SPINLOCK(unwinder_lock);
-
-/**
- * select_unwinder - Select the best registered stack unwinder.
- *
- * Private function. Must hold unwinder_lock when called.
- *
- * Select the stack unwinder with the best rating. This is useful for
- * setting up curr_unwinder.
- */
-static struct unwinder *select_unwinder(void)
-{
-	struct unwinder *best;
-
-	if (list_empty(&unwinder_list))
-		return NULL;
-
-	best = list_entry(unwinder_list.next, struct unwinder, list);
-	if (best == curr_unwinder)
-		return NULL;
-
-	return best;
-}
-
-/*
- * Enqueue the stack unwinder sorted by rating.
- */
-static int unwinder_enqueue(struct unwinder *ops)
-{
-	struct list_head *tmp, *entry = &unwinder_list;
-
-	list_for_each(tmp, &unwinder_list) {
-		struct unwinder *o;
-
-		o = list_entry(tmp, struct unwinder, list);
-		if (o == ops)
-			return -EBUSY;
-		/* Keep track of the place, where to insert */
-		if (o->rating >= ops->rating)
-			entry = tmp;
-	}
-	list_add(&ops->list, entry);
-
-	return 0;
-}
-
-/**
- * unwinder_register - Used to install new stack unwinder
- * @u: unwinder to be registered
- *
- * Install the new stack unwinder on the unwinder list, which is sorted
- * by rating.
- *
- * Returns -EBUSY if registration fails, zero otherwise.
- */
-int unwinder_register(struct unwinder *u)
-{
-	unsigned long flags;
-	int ret;
-
-	spin_lock_irqsave(&unwinder_lock, flags);
-	ret = unwinder_enqueue(u);
-	if (!ret)
-		curr_unwinder = select_unwinder();
-	spin_unlock_irqrestore(&unwinder_lock, flags);
-
-	return ret;
-}
-
-int unwinder_faulted = 0;
-
-/*
- * Unwind the call stack and pass information to the stacktrace_ops
- * functions. Also handle the case where we need to switch to a new
- * stack dumper because the current one faulted unexpectedly.
- */
-void unwind_stack(struct task_struct *task, struct pt_regs *regs,
-		  unsigned long *sp, const struct stacktrace_ops *ops,
-		  void *data)
-{
-	unsigned long flags;
-
-	/*
-	 * The problem with unwinders with high ratings is that they are
-	 * inherently more complicated than the simple ones with lower
-	 * ratings. We are therefore more likely to fault in the
-	 * complicated ones, e.g. hitting BUG()s. If we fault in the
-	 * code for the current stack unwinder we try to downgrade to
-	 * one with a lower rating.
-	 *
-	 * Hopefully this will give us a semi-reliable stacktrace so we
-	 * can diagnose why curr_unwinder->dump() faulted.
-	 */
-	if (unwinder_faulted) {
-		spin_lock_irqsave(&unwinder_lock, flags);
-
-		/* Make sure no one beat us to changing the unwinder */
-		if (unwinder_faulted && !list_is_singular(&unwinder_list)) {
-			list_del(&curr_unwinder->list);
-			curr_unwinder = select_unwinder();
-
-			unwinder_faulted = 0;
-		}
-
-		spin_unlock_irqrestore(&unwinder_lock, flags);
-	}
-
-	curr_unwinder->dump(task, regs, sp, ops, data);
-}
-EXPORT_SYMBOL_GPL(unwind_stack);
diff --git a/arch/sh/kernel/vmlinux.lds.S b/arch/sh/kernel/vmlinux.lds.S
deleted file mode 100644
index 3161b9ccd2a570..00000000000000
--- a/arch/sh/kernel/vmlinux.lds.S
+++ /dev/null
@@ -1,82 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * ld script to make SuperH Linux kernel
- * Written by Niibe Yutaka and Paul Mundt
- */
-OUTPUT_ARCH(sh)
-#include <asm/thread_info.h>
-#include <asm/cache.h>
-#include <asm/vmlinux.lds.h>
-
-#ifdef CONFIG_PMB
- #define MEMORY_OFFSET	0
-#else
- #define MEMORY_OFFSET	__MEMORY_START
-#endif
-
-ENTRY(_start)
-SECTIONS
-{
-	. = PAGE_OFFSET + MEMORY_OFFSET + PHYSICAL_OFFSET + CONFIG_ZERO_PAGE_OFFSET;
-
-	_text = .;		/* Text and read-only data */
-
-	.empty_zero_page : AT(ADDR(.empty_zero_page)) {
-		*(.empty_zero_page)
-	} = 0
-
-	.text : AT(ADDR(.text)) {
-		HEAD_TEXT
-		TEXT_TEXT
-		SCHED_TEXT
-		CPUIDLE_TEXT
-		LOCK_TEXT
-		KPROBES_TEXT
-		IRQENTRY_TEXT
-		SOFTIRQENTRY_TEXT
-		*(.fixup)
-		*(.gnu.warning)
-		_etext = .;		/* End of text section */
-	} = 0x0009
-
-	EXCEPTION_TABLE(16)
-
-	_sdata = .;
-	RO_DATA(PAGE_SIZE)
-	RW_DATA(L1_CACHE_BYTES, PAGE_SIZE, THREAD_SIZE)
-	_edata = .;
-
-	DWARF_EH_FRAME
-
-	. = ALIGN(PAGE_SIZE);		/* Init code and data */
-	__init_begin = .;
-	INIT_TEXT_SECTION(PAGE_SIZE)
-	INIT_DATA_SECTION(16)
-
-	. = ALIGN(4);
-	.machvec.init : AT(ADDR(.machvec.init)) {
-		__machvec_start = .;
-		*(.machvec.init)
-		__machvec_end = .;
-	}
-
-	PERCPU_SECTION(L1_CACHE_BYTES)
-
-	/*
-	 * .exit.text is discarded at runtime, not link time, to deal with
-	 * references from __bug_table
-	 */
-	.exit.text : AT(ADDR(.exit.text)) { EXIT_TEXT }
-	.exit.data : AT(ADDR(.exit.data)) { EXIT_DATA }
-
-	. = ALIGN(PAGE_SIZE);
-	__init_end = .;
-	BSS_SECTION(0, PAGE_SIZE, 4)
-	_end = . ;
-
-	STABS_DEBUG
-	DWARF_DEBUG
-	ELF_DETAILS
-
-	DISCARDS
-}
diff --git a/arch/sh/kernel/vsyscall/.gitignore b/arch/sh/kernel/vsyscall/.gitignore
deleted file mode 100644
index 530a3031a88d79..00000000000000
--- a/arch/sh/kernel/vsyscall/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-only
-vsyscall.lds
diff --git a/arch/sh/kernel/vsyscall/Makefile b/arch/sh/kernel/vsyscall/Makefile
deleted file mode 100644
index 6e86644480488f..00000000000000
--- a/arch/sh/kernel/vsyscall/Makefile
+++ /dev/null
@@ -1,36 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-obj-y += vsyscall.o vsyscall-syscall.o vsyscall-syms.o
-
-$(obj)/vsyscall-syscall.o: \
-	$(foreach F,trapa,$(obj)/vsyscall-$F.so)
-
-# Teach kbuild about targets
-targets += $(foreach F,trapa,vsyscall-$F.o vsyscall-$F.so)
-targets += vsyscall-note.o vsyscall.lds vsyscall-dummy.o
-
-# The DSO images are built using a special linker script
-quiet_cmd_syscall = SYSCALL $@
-      cmd_syscall = $(CC) -nostdlib $(SYSCFLAGS_$(@F)) \
-			   -Wl,-T,$(filter-out FORCE,$^) -o $@
-
-export CPPFLAGS_vsyscall.lds += -P -C -Ush
-
-vsyscall-flags = -shared -s -Wl,-soname=linux-gate.so.1 -Wl,--hash-style=sysv
-
-SYSCFLAGS_vsyscall-trapa.so	= $(vsyscall-flags)
-
-$(obj)/vsyscall-trapa.so: \
-$(obj)/vsyscall-%.so: $(src)/vsyscall.lds $(obj)/vsyscall-%.o FORCE
-	$(call if_changed,syscall)
-
-# We also create a special relocatable object that should mirror the symbol
-# table and layout of the linked DSO.  With ld -R we can then refer to
-# these symbols in the kernel code rather than hand-coded addresses.
-SYSCFLAGS_vsyscall-dummy.o = -r
-$(obj)/vsyscall-dummy.o: $(src)/vsyscall.lds \
-			$(obj)/vsyscall-trapa.o $(obj)/vsyscall-note.o FORCE
-	$(call if_changed,syscall)
-
-LDFLAGS_vsyscall-syms.o := -r -R
-$(obj)/vsyscall-syms.o: $(obj)/vsyscall-dummy.o FORCE
-	$(call if_changed,ld)
diff --git a/arch/sh/kernel/vsyscall/vsyscall-note.S b/arch/sh/kernel/vsyscall/vsyscall-note.S
deleted file mode 100644
index bb350918bebd19..00000000000000
--- a/arch/sh/kernel/vsyscall/vsyscall-note.S
+++ /dev/null
@@ -1,26 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * This supplies .note.* sections to go into the PT_NOTE inside the vDSO text.
- * Here we can supply some information useful to userland.
- */
-
-#include <linux/uts.h>
-#include <linux/version.h>
-
-#define ASM_ELF_NOTE_BEGIN(name, flags, vendor, type)			      \
-	.section name, flags;						      \
-	.balign 4;							      \
-	.long 1f - 0f;		/* name length */			      \
-	.long 3f - 2f;		/* data length */			      \
-	.long type;		/* note type */				      \
-0:	.asciz vendor;		/* vendor name */			      \
-1:	.balign 4;							      \
-2:
-
-#define ASM_ELF_NOTE_END						      \
-3:	.balign 4;		/* pad out section */			      \
-	.previous
-
-	ASM_ELF_NOTE_BEGIN(".note.kernel-version", "a", UTS_SYSNAME, 0)
-	.long LINUX_VERSION_CODE
-	ASM_ELF_NOTE_END
diff --git a/arch/sh/kernel/vsyscall/vsyscall-sigreturn.S b/arch/sh/kernel/vsyscall/vsyscall-sigreturn.S
deleted file mode 100644
index bece5fa7361830..00000000000000
--- a/arch/sh/kernel/vsyscall/vsyscall-sigreturn.S
+++ /dev/null
@@ -1,75 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <asm/unistd.h>
-
-	.text
-	.balign 32
-	.globl __kernel_sigreturn
-	.type __kernel_sigreturn,@function
-__kernel_sigreturn:
-.LSTART_sigreturn:
-	mov.w	1f, r3
-	trapa	#0x10
-	or	r0, r0
-	or	r0, r0
-	or	r0, r0
-	or	r0, r0
-	or	r0, r0
-
-1:	.short	__NR_sigreturn
-.LEND_sigreturn:
-	.size __kernel_sigreturn,.-.LSTART_sigreturn
-
-	.balign 32
-	.globl __kernel_rt_sigreturn
-	.type __kernel_rt_sigreturn,@function
-__kernel_rt_sigreturn:
-.LSTART_rt_sigreturn:
-	mov.w	1f, r3
-	trapa	#0x10
-	or	r0, r0
-	or	r0, r0
-	or	r0, r0
-	or	r0, r0
-	or	r0, r0
-
-1:	.short	__NR_rt_sigreturn
-.LEND_rt_sigreturn:
-	.size __kernel_rt_sigreturn,.-.LSTART_rt_sigreturn
-	.previous
-
-	.section .eh_frame,"a",@progbits
-.LCIE1:
-	.ualong	.LCIE1_end - .LCIE1_start
-.LCIE1_start:
-	.ualong	0		/* CIE ID */
-	.byte	0x1		/* Version number */
-	.string	"zRS"		/* NUL-terminated augmentation string */
-	.uleb128 0x1		/* Code alignment factor */
-	.sleb128 -4		/* Data alignment factor */
-	.byte	0x11		/* Return address register column */
-	.uleb128 0x1		/* Augmentation length and data */
-	.byte 0x1b              /* DW_EH_PE_pcrel | DW_EH_PE_sdata4. */
-	.byte	0xc, 0xf, 0x0	/* DW_CFA_def_cfa: r15 ofs 0 */
-
-	.align 2
-.LCIE1_end:
-
-	.ualong	.LFDE0_end-.LFDE0_start	/* Length FDE0 */
-.LFDE0_start:
-	.ualong	.LFDE0_start-.LCIE1	/* CIE pointer */
-	.ualong	.LSTART_sigreturn-.	/* PC-relative start address */
-	.ualong	.LEND_sigreturn-.LSTART_sigreturn
-	.uleb128 0			/* Augmentation */
-	.align 2
-.LFDE0_end:
-
-	.ualong	.LFDE1_end-.LFDE1_start	/* Length FDE1 */
-.LFDE1_start:
-	.ualong	.LFDE1_start-.LCIE1	/* CIE pointer */
-	.ualong	.LSTART_rt_sigreturn-.	/* PC-relative start address */
-	.ualong	.LEND_rt_sigreturn-.LSTART_rt_sigreturn
-	.uleb128 0			/* Augmentation */
-	.align 2
-.LFDE1_end:
-
-	.previous
diff --git a/arch/sh/kernel/vsyscall/vsyscall-syscall.S b/arch/sh/kernel/vsyscall/vsyscall-syscall.S
deleted file mode 100644
index 2aeaa2ddee50eb..00000000000000
--- a/arch/sh/kernel/vsyscall/vsyscall-syscall.S
+++ /dev/null
@@ -1,11 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#include <linux/init.h>
-
-__INITDATA
-
-	.globl vsyscall_trapa_start, vsyscall_trapa_end
-vsyscall_trapa_start:
-	.incbin "arch/sh/kernel/vsyscall/vsyscall-trapa.so"
-vsyscall_trapa_end:
-
-__FINIT
diff --git a/arch/sh/kernel/vsyscall/vsyscall-trapa.S b/arch/sh/kernel/vsyscall/vsyscall-trapa.S
deleted file mode 100644
index 854ea323570415..00000000000000
--- a/arch/sh/kernel/vsyscall/vsyscall-trapa.S
+++ /dev/null
@@ -1,40 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-	.text
-	.globl __kernel_vsyscall
-	.type __kernel_vsyscall,@function
-__kernel_vsyscall:
-.LSTART_vsyscall:
-	trapa	#0x10
-	 nop
-.LEND_vsyscall:
-	.size __kernel_vsyscall,.-.LSTART_vsyscall
-	.previous
-
-	.section .eh_frame,"a",@progbits
-.LCIE:
-	.ualong	.LCIE_end - .LCIE_start
-.LCIE_start:
-	.ualong	0		/* CIE ID */
-	.byte	0x1		/* Version number */
-	.string	"zR"		/* NUL-terminated augmentation string */
-	.uleb128 0x1		/* Code alignment factor */
-	.sleb128 -4		/* Data alignment factor */
-	.byte	0x11		/* Return address register column */
-	.uleb128 0x1		/* Augmentation length and data */
-	.byte 0x1b              /* DW_EH_PE_pcrel | DW_EH_PE_sdata4. */
-	.byte	0xc,0xf,0x0	/* DW_CFA_def_cfa: r15 ofs 0 */
-	.align 2
-.LCIE_end:
-
-	.ualong	.LFDE_end-.LFDE_start	/* Length FDE */
-.LFDE_start:
-	.ualong	.LFDE_start-.LCIE	/* CIE pointer */
-	.ualong	.LSTART_vsyscall-.	/* PC-relative start address */
-	.ualong	.LEND_vsyscall-.LSTART_vsyscall
-	.uleb128 0			/* Augmentation */
-	.align 2
-.LFDE_end:
-	.previous
-
-/* Get the common code for the sigreturn entry points */
-#include "vsyscall-sigreturn.S"
diff --git a/arch/sh/kernel/vsyscall/vsyscall.c b/arch/sh/kernel/vsyscall/vsyscall.c
deleted file mode 100644
index 1bd85a6949c45d..00000000000000
--- a/arch/sh/kernel/vsyscall/vsyscall.c
+++ /dev/null
@@ -1,93 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/kernel/vsyscall/vsyscall.c
- *
- *  Copyright (C) 2006 Paul Mundt
- *
- * vDSO randomization
- * Copyright(C) 2005-2006, Red Hat, Inc., Ingo Molnar
- */
-#include <linux/mm.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/gfp.h>
-#include <linux/module.h>
-#include <linux/elf.h>
-#include <linux/sched.h>
-#include <linux/err.h>
-
-/*
- * Should the kernel map a VDSO page into processes and pass its
- * address down to glibc upon exec()?
- */
-unsigned int __read_mostly vdso_enabled = 1;
-EXPORT_SYMBOL_GPL(vdso_enabled);
-
-static int __init vdso_setup(char *s)
-{
-	vdso_enabled = simple_strtoul(s, NULL, 0);
-	return 1;
-}
-__setup("vdso=", vdso_setup);
-
-/*
- * These symbols are defined by vsyscall.o to mark the bounds
- * of the ELF DSO images included therein.
- */
-extern const char vsyscall_trapa_start, vsyscall_trapa_end;
-static struct page *syscall_pages[1];
-
-int __init vsyscall_init(void)
-{
-	void *syscall_page = (void *)get_zeroed_page(GFP_ATOMIC);
-	syscall_pages[0] = virt_to_page(syscall_page);
-
-	/*
-	 * XXX: Map this page to a fixmap entry if we get around
-	 * to adding the page to ELF core dumps
-	 */
-
-	memcpy(syscall_page,
-	       &vsyscall_trapa_start,
-	       &vsyscall_trapa_end - &vsyscall_trapa_start);
-
-	return 0;
-}
-
-/* Setup a VMA at program startup for the vsyscall page */
-int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)
-{
-	struct mm_struct *mm = current->mm;
-	unsigned long addr;
-	int ret;
-
-	if (mmap_write_lock_killable(mm))
-		return -EINTR;
-
-	addr = get_unmapped_area(NULL, 0, PAGE_SIZE, 0, 0);
-	if (IS_ERR_VALUE(addr)) {
-		ret = addr;
-		goto up_fail;
-	}
-
-	ret = install_special_mapping(mm, addr, PAGE_SIZE,
-				      VM_READ | VM_EXEC |
-				      VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC,
-				      syscall_pages);
-	if (unlikely(ret))
-		goto up_fail;
-
-	current->mm->context.vdso = (void *)addr;
-
-up_fail:
-	mmap_write_unlock(mm);
-	return ret;
-}
-
-const char *arch_vma_name(struct vm_area_struct *vma)
-{
-	if (vma->vm_mm && vma->vm_start == (long)vma->vm_mm->context.vdso)
-		return "[vdso]";
-
-	return NULL;
-}
diff --git a/arch/sh/kernel/vsyscall/vsyscall.lds.S b/arch/sh/kernel/vsyscall/vsyscall.lds.S
deleted file mode 100644
index e3582e03c0eb0b..00000000000000
--- a/arch/sh/kernel/vsyscall/vsyscall.lds.S
+++ /dev/null
@@ -1,85 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Linker script for vsyscall DSO.  The vsyscall page is an ELF shared
- * object prelinked to its virtual address, and with only one read-only
- * segment (that fits in one page).  This script controls its layout.
- */
-#include <asm/asm-offsets.h>
-
-#ifdef CONFIG_CPU_LITTLE_ENDIAN
-OUTPUT_FORMAT("elf32-sh-linux", "elf32-sh-linux", "elf32-sh-linux")
-#else
-OUTPUT_FORMAT("elf32-shbig-linux", "elf32-shbig-linux", "elf32-shbig-linux")
-#endif
-OUTPUT_ARCH(sh)
-
-/* The ELF entry point can be used to set the AT_SYSINFO value.  */
-ENTRY(__kernel_vsyscall);
-
-SECTIONS
-{
-	. = SIZEOF_HEADERS;
-
-	.hash		: { *(.hash) }			:text
-	.gnu.hash	: { *(.gnu.hash) }
-	.dynsym		: { *(.dynsym) }
-	.dynstr		: { *(.dynstr) }
-	.gnu.version	: { *(.gnu.version) }
-	.gnu.version_d	: { *(.gnu.version_d) }
-	.gnu.version_r	: { *(.gnu.version_r) }
-
-	/*
-	 * This linker script is used both with -r and with -shared.
-	 * For the layouts to match, we need to skip more than enough
-	 * space for the dynamic symbol table et al.  If this amount
-	 * is insufficient, ld -shared will barf.  Just increase it here.
-	 */
-	. = 0x400;
-
-	.text		: { *(.text) } 			:text	=0x90909090
-	.note		: { *(.note.*) }		:text	:note
-	.eh_frame_hdr	: { *(.eh_frame_hdr ) }		:text	:eh_frame_hdr
-	.eh_frame	: {
-		KEEP (*(.eh_frame))
-		LONG (0)
-	}						:text
-	.dynamic	: { *(.dynamic) }		:text	:dynamic
-	.useless	: {
-	      *(.got.plt) *(.got)
-	      *(.data .data.* .gnu.linkonce.d.*)
-	      *(.dynbss)
-	      *(.bss .bss.* .gnu.linkonce.b.*)
-	}						:text
-}
-
-/*
- * Very old versions of ld do not recognize this name token; use the constant.
- */
-#define PT_GNU_EH_FRAME	0x6474e550
-
-/*
- * We must supply the ELF program headers explicitly to get just one
- * PT_LOAD segment, and set the flags explicitly to make segments read-only.
- */
-PHDRS
-{
-	text		PT_LOAD FILEHDR PHDRS FLAGS(5);	/* PF_R|PF_X */
-	dynamic		PT_DYNAMIC FLAGS(4);		/* PF_R */
-	note		PT_NOTE FLAGS(4);		/* PF_R */
-	eh_frame_hdr	PT_GNU_EH_FRAME;
-}
-
-/*
- * This controls what symbols we export from the DSO.
- */
-VERSION
-{
-	LINUX_2.6 {
-	global:
-		__kernel_vsyscall;
-		__kernel_sigreturn;
-		__kernel_rt_sigreturn;
-
-	local: *;
-	};
-}
diff --git a/arch/sh/lib/Makefile b/arch/sh/lib/Makefile
deleted file mode 100644
index eb473d373ca43a..00000000000000
--- a/arch/sh/lib/Makefile
+++ /dev/null
@@ -1,32 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for SuperH-specific library files..
-#
-
-lib-y  = delay.o memmove.o memchr.o \
-	 checksum.o strlen.o div64.o div64-generic.o
-
-# Extracted from libgcc
-obj-y += movmem.o ashldi3.o ashrdi3.o lshrdi3.o \
-	 ashlsi3.o ashrsi3.o ashiftrt.o lshrsi3.o \
-	 udiv_qrnnd.o
-
-udivsi3-y			:= udivsi3_i4i-Os.o
-
-ifneq ($(CONFIG_CC_OPTIMIZE_FOR_SIZE),y)
-udivsi3-$(CONFIG_CPU_SH3)	:= udivsi3_i4i.o
-udivsi3-$(CONFIG_CPU_SH4)	:= udivsi3_i4i.o
-endif
-udivsi3-y			+= udivsi3.o
-
-obj-y				+= io.o
-
-memcpy-y			:= memcpy.o
-memcpy-$(CONFIG_CPU_SH4)	:= memcpy-sh4.o
-
-memset-y			:= memset.o
-memset-$(CONFIG_CPU_SH4)	:= memset-sh4.o
-
-lib-$(CONFIG_MMU)		+= copy_page.o __clear_user.o
-lib-$(CONFIG_MCOUNT)		+= mcount.o
-lib-y				+= $(memcpy-y) $(memset-y) $(udivsi3-y)
diff --git a/arch/sh/lib/__clear_user.S b/arch/sh/lib/__clear_user.S
deleted file mode 100644
index 0978606907ed3c..00000000000000
--- a/arch/sh/lib/__clear_user.S
+++ /dev/null
@@ -1,109 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * __clear_user_page, __clear_user, clear_page implementation of SuperH
- *
- * Copyright (C) 2001  Kaz Kojima
- * Copyright (C) 2001, 2002  Niibe Yutaka
- * Copyright (C) 2006  Paul Mundt
- */
-#include <linux/linkage.h>
-#include <asm/page.h>
-
-ENTRY(__clear_user)
-	!
-	mov	#0, r0
-	mov	#0xffffffe0, r1
-	!
-	! r4..(r4+31)&~32 	   -------- not aligned	[ Area 0 ]
-	! (r4+31)&~32..(r4+r5)&~32 -------- aligned	[ Area 1 ]
-	! (r4+r5)&~32..r4+r5       -------- not aligned	[ Area 2 ]
-	!
-	! Clear area 0
-	mov	r4, r2
-	!
-	tst	r1, r5		! length < 32
-	bt	.Larea2		! skip to remainder
-	!
-	add	#31, r2
-	and	r1, r2
-	cmp/eq	r4, r2
-	bt	.Larea1
-	mov	r2, r3
-	sub	r4, r3
-	mov	r3, r7
-	mov	r4, r2
-	!
-.L0:	dt	r3
-0:	mov.b	r0, @r2
-	bf/s	.L0
-	 add	#1, r2
-	!
-	sub	r7, r5
-	mov	r2, r4
-.Larea1:
-	mov	r4, r3
-	add	r5, r3
-	and	r1, r3
-	cmp/hi	r2, r3
-	bf	.Larea2
-	!
-	! Clear area 1
-#if defined(CONFIG_CPU_SH4)
-1:	movca.l	r0, @r2
-#else
-1:	mov.l	r0, @r2
-#endif
-	add	#4, r2
-2:	mov.l	r0, @r2
-	add	#4, r2
-3:	mov.l	r0, @r2
-	add	#4, r2
-4:	mov.l	r0, @r2
-	add	#4, r2
-5:	mov.l	r0, @r2
-	add	#4, r2
-6:	mov.l	r0, @r2
-	add	#4, r2
-7:	mov.l	r0, @r2
-	add	#4, r2
-8:	mov.l	r0, @r2
-	add	#4, r2
-	cmp/hi	r2, r3
-	bt/s	1b
-	 nop
-	!
-	! Clear area 2
-.Larea2:
-	mov	r4, r3
-	add	r5, r3
-	cmp/hs	r3, r2
-	bt/s	.Ldone
-	 sub	r2, r3
-.L2:	dt	r3
-9:	mov.b	r0, @r2
-	bf/s	.L2
-	 add	#1, r2
-	!
-.Ldone:	rts
-	 mov	#0, r0	! return 0 as normal return
-
-	! return the number of bytes remained
-.Lbad_clear_user:
-	mov	r4, r0
-	add	r5, r0
-	rts
-	 sub	r2, r0
-
-.section __ex_table,"a"
-	.align 2
-	.long	0b, .Lbad_clear_user
-	.long	1b, .Lbad_clear_user
-	.long	2b, .Lbad_clear_user
-	.long	3b, .Lbad_clear_user
-	.long	4b, .Lbad_clear_user
-	.long	5b, .Lbad_clear_user
-	.long	6b, .Lbad_clear_user
-	.long	7b, .Lbad_clear_user
-	.long	8b, .Lbad_clear_user
-	.long	9b, .Lbad_clear_user
-.previous
diff --git a/arch/sh/lib/ashiftrt.S b/arch/sh/lib/ashiftrt.S
deleted file mode 100644
index 0f7145e3c51ee2..00000000000000
--- a/arch/sh/lib/ashiftrt.S
+++ /dev/null
@@ -1,128 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ WITH GCC-exception-2.0
-
-   Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
-   2004, 2005, 2006
-   Free Software Foundation, Inc.
-*/
-
-!! libgcc routines for the Renesas / SuperH SH CPUs.
-!! Contributed by Steve Chamberlain.
-!! sac@cygnus.com
-
-!! ashiftrt_r4_x, ___ashrsi3, ___ashlsi3, ___lshrsi3 routines
-!! recoded in assembly by Toshiyasu Morita
-!! tm@netcom.com
-
-/* SH2 optimizations for ___ashrsi3, ___ashlsi3, ___lshrsi3 and
-   ELF local label prefixes by J"orn Rennecke
-   amylaar@cygnus.com  */
-
-	.global	__ashiftrt_r4_0
-	.global	__ashiftrt_r4_1
-	.global	__ashiftrt_r4_2
-	.global	__ashiftrt_r4_3
-	.global	__ashiftrt_r4_4
-	.global	__ashiftrt_r4_5
-	.global	__ashiftrt_r4_6
-	.global	__ashiftrt_r4_7
-	.global	__ashiftrt_r4_8
-	.global	__ashiftrt_r4_9
-	.global	__ashiftrt_r4_10
-	.global	__ashiftrt_r4_11
-	.global	__ashiftrt_r4_12
-	.global	__ashiftrt_r4_13
-	.global	__ashiftrt_r4_14
-	.global	__ashiftrt_r4_15
-	.global	__ashiftrt_r4_16
-	.global	__ashiftrt_r4_17
-	.global	__ashiftrt_r4_18
-	.global	__ashiftrt_r4_19
-	.global	__ashiftrt_r4_20
-	.global	__ashiftrt_r4_21
-	.global	__ashiftrt_r4_22
-	.global	__ashiftrt_r4_23
-	.global	__ashiftrt_r4_24
-	.global	__ashiftrt_r4_25
-	.global	__ashiftrt_r4_26
-	.global	__ashiftrt_r4_27
-	.global	__ashiftrt_r4_28
-	.global	__ashiftrt_r4_29
-	.global	__ashiftrt_r4_30
-	.global	__ashiftrt_r4_31
-	.global	__ashiftrt_r4_32
-
-	.align	1
-__ashiftrt_r4_32:
-__ashiftrt_r4_31:
-	rotcl	r4
-	rts
-	subc	r4,r4
-__ashiftrt_r4_30:
-	shar	r4
-__ashiftrt_r4_29:
-	shar	r4
-__ashiftrt_r4_28:
-	shar	r4
-__ashiftrt_r4_27:
-	shar	r4
-__ashiftrt_r4_26:
-	shar	r4
-__ashiftrt_r4_25:
-	shar	r4
-__ashiftrt_r4_24:
-	shlr16	r4
-	shlr8	r4
-	rts
-	exts.b	r4,r4
-__ashiftrt_r4_23:
-	shar	r4
-__ashiftrt_r4_22:
-	shar	r4
-__ashiftrt_r4_21:
-	shar	r4
-__ashiftrt_r4_20:
-	shar	r4
-__ashiftrt_r4_19:
-	shar	r4
-__ashiftrt_r4_18:
-	shar	r4
-__ashiftrt_r4_17:
-	shar	r4
-__ashiftrt_r4_16:
-	shlr16	r4
-	rts
-	exts.w	r4,r4
-__ashiftrt_r4_15:
-	shar	r4
-__ashiftrt_r4_14:
-	shar	r4
-__ashiftrt_r4_13:
-	shar	r4
-__ashiftrt_r4_12:
-	shar	r4
-__ashiftrt_r4_11:
-	shar	r4
-__ashiftrt_r4_10:
-	shar	r4
-__ashiftrt_r4_9:
-	shar	r4
-__ashiftrt_r4_8:
-	shar	r4
-__ashiftrt_r4_7:
-	shar	r4
-__ashiftrt_r4_6:
-	shar	r4
-__ashiftrt_r4_5:
-	shar	r4
-__ashiftrt_r4_4:
-	shar	r4
-__ashiftrt_r4_3:
-	shar	r4
-__ashiftrt_r4_2:
-	shar	r4
-__ashiftrt_r4_1:
-	rts
-	shar	r4
-__ashiftrt_r4_0:
-	rts
-	nop
diff --git a/arch/sh/lib/ashldi3.c b/arch/sh/lib/ashldi3.c
deleted file mode 100644
index e5afe093584742..00000000000000
--- a/arch/sh/lib/ashldi3.c
+++ /dev/null
@@ -1,30 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/module.h>
-
-#include "libgcc.h"
-
-long long __ashldi3(long long u, word_type b)
-{
-	DWunion uu, w;
-	word_type bm;
-
-	if (b == 0)
-		return u;
-
-	uu.ll = u;
-	bm = 32 - b;
-
-	if (bm <= 0) {
-		w.s.low = 0;
-		w.s.high = (unsigned int) uu.s.low << -bm;
-	} else {
-		const unsigned int carries = (unsigned int) uu.s.low >> bm;
-
-		w.s.low = (unsigned int) uu.s.low << b;
-		w.s.high = ((unsigned int) uu.s.high << b) | carries;
-	}
-
-	return w.ll;
-}
-
-EXPORT_SYMBOL(__ashldi3);
diff --git a/arch/sh/lib/ashlsi3.S b/arch/sh/lib/ashlsi3.S
deleted file mode 100644
index 4df4401cdf31d5..00000000000000
--- a/arch/sh/lib/ashlsi3.S
+++ /dev/null
@@ -1,189 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ WITH GCC-exception-2.0
-
-   Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
-   2004, 2005, 2006
-   Free Software Foundation, Inc.
-*/
-
-!! libgcc routines for the Renesas / SuperH SH CPUs.
-!! Contributed by Steve Chamberlain.
-!! sac@cygnus.com
-
-!! ashiftrt_r4_x, ___ashrsi3, ___ashlsi3, ___lshrsi3 routines
-!! recoded in assembly by Toshiyasu Morita
-!! tm@netcom.com
-
-/* SH2 optimizations for ___ashrsi3, ___ashlsi3, ___lshrsi3 and
-   ELF local label prefixes by J"orn Rennecke
-   amylaar@cygnus.com  */
-
-!
-! __ashlsi3
-!
-! Entry:
-!
-! r4: Value to shift
-! r5: Shifts
-!
-! Exit:
-!
-! r0: Result
-!
-! Destroys:
-!
-! (none)
-!
-! __ashlsi3_r0
-!
-! Entry:
-!
-! r4: Value to shift
-! r0: Shifts
-!
-! Exit:
-!
-! r0: Result
-!
-! Destroys:
-!
-! (none)
-
-
-	.global	__ashlsi3
-	.global	__ashlsi3_r0
-	
-	.align	2
-__ashlsi3:
-	mov	r5,r0
-	.align	2
-__ashlsi3_r0:
-	and	#31,r0
-	mov.l	r4,@-r15
-	mov	r0,r4
-	mova	ashlsi3_table,r0
-	mov.b	@(r0,r4),r4
-	add	r4,r0
-	jmp	@r0
-	mov.l	@r15+,r0
-
-	.align	2
-ashlsi3_table:
-	.byte		ashlsi3_0-ashlsi3_table
-	.byte		ashlsi3_1-ashlsi3_table
-	.byte		ashlsi3_2-ashlsi3_table
-	.byte		ashlsi3_3-ashlsi3_table
-	.byte		ashlsi3_4-ashlsi3_table
-	.byte		ashlsi3_5-ashlsi3_table
-	.byte		ashlsi3_6-ashlsi3_table
-	.byte		ashlsi3_7-ashlsi3_table
-	.byte		ashlsi3_8-ashlsi3_table
-	.byte		ashlsi3_9-ashlsi3_table
-	.byte		ashlsi3_10-ashlsi3_table
-	.byte		ashlsi3_11-ashlsi3_table
-	.byte		ashlsi3_12-ashlsi3_table
-	.byte		ashlsi3_13-ashlsi3_table
-	.byte		ashlsi3_14-ashlsi3_table
-	.byte		ashlsi3_15-ashlsi3_table
-	.byte		ashlsi3_16-ashlsi3_table
-	.byte		ashlsi3_17-ashlsi3_table
-	.byte		ashlsi3_18-ashlsi3_table
-	.byte		ashlsi3_19-ashlsi3_table
-	.byte		ashlsi3_20-ashlsi3_table
-	.byte		ashlsi3_21-ashlsi3_table
-	.byte		ashlsi3_22-ashlsi3_table
-	.byte		ashlsi3_23-ashlsi3_table
-	.byte		ashlsi3_24-ashlsi3_table
-	.byte		ashlsi3_25-ashlsi3_table
-	.byte		ashlsi3_26-ashlsi3_table
-	.byte		ashlsi3_27-ashlsi3_table
-	.byte		ashlsi3_28-ashlsi3_table
-	.byte		ashlsi3_29-ashlsi3_table
-	.byte		ashlsi3_30-ashlsi3_table
-	.byte		ashlsi3_31-ashlsi3_table
-
-ashlsi3_6:
-	shll2	r0
-ashlsi3_4:
-	shll2	r0
-ashlsi3_2:
-	rts
-	shll2	r0
-
-ashlsi3_7:
-	shll2	r0
-ashlsi3_5:
-	shll2	r0
-ashlsi3_3:
-	shll2	r0
-ashlsi3_1:
-	rts
-	shll	r0
-
-ashlsi3_14:
-	shll2	r0
-ashlsi3_12:
-	shll2	r0
-ashlsi3_10:
-	shll2	r0
-ashlsi3_8:
-	rts
-	shll8	r0
-
-ashlsi3_15:
-	shll2	r0
-ashlsi3_13:
-	shll2	r0
-ashlsi3_11:
-	shll2	r0
-ashlsi3_9:
-	shll8	r0
-	rts
-	shll	r0
-
-ashlsi3_22:
-	shll2	r0
-ashlsi3_20:
-	shll2	r0
-ashlsi3_18:
-	shll2	r0
-ashlsi3_16:
-	rts
-	shll16	r0
-
-ashlsi3_23:
-	shll2	r0
-ashlsi3_21:
-	shll2	r0
-ashlsi3_19:
-	shll2	r0
-ashlsi3_17:
-	shll16	r0
-	rts
-	shll	r0
-
-ashlsi3_30:
-	shll2	r0
-ashlsi3_28:
-	shll2	r0
-ashlsi3_26:
-	shll2	r0
-ashlsi3_24:
-	shll16	r0
-	rts
-	shll8	r0
-
-ashlsi3_31:
-	shll2	r0
-ashlsi3_29:
-	shll2	r0
-ashlsi3_27:
-	shll2	r0
-ashlsi3_25:
-	shll16	r0
-	shll8	r0
-	rts
-	shll	r0
-
-ashlsi3_0:
-	rts
-	nop
diff --git a/arch/sh/lib/ashrdi3.c b/arch/sh/lib/ashrdi3.c
deleted file mode 100644
index ae263fbf25383b..00000000000000
--- a/arch/sh/lib/ashrdi3.c
+++ /dev/null
@@ -1,32 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/module.h>
-
-#include "libgcc.h"
-
-long long __ashrdi3(long long u, word_type b)
-{
-	DWunion uu, w;
-	word_type bm;
-
-	if (b == 0)
-		return u;
-
-	uu.ll = u;
-	bm = 32 - b;
-
-	if (bm <= 0) {
-		/* w.s.high = 1..1 or 0..0 */
-		w.s.high =
-		    uu.s.high >> 31;
-		w.s.low = uu.s.high >> -bm;
-	} else {
-		const unsigned int carries = (unsigned int) uu.s.high << bm;
-
-		w.s.high = uu.s.high >> b;
-		w.s.low = ((unsigned int) uu.s.low >> b) | carries;
-	}
-
-	return w.ll;
-}
-
-EXPORT_SYMBOL(__ashrdi3);
diff --git a/arch/sh/lib/ashrsi3.S b/arch/sh/lib/ashrsi3.S
deleted file mode 100644
index bf3c4e03e6ffc9..00000000000000
--- a/arch/sh/lib/ashrsi3.S
+++ /dev/null
@@ -1,179 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ WITH GCC-exception-2.0
-
-   Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
-   2004, 2005, 2006
-   Free Software Foundation, Inc.
-*/
-
-!! libgcc routines for the Renesas / SuperH SH CPUs.
-!! Contributed by Steve Chamberlain.
-!! sac@cygnus.com
-
-!! ashiftrt_r4_x, ___ashrsi3, ___ashlsi3, ___lshrsi3 routines
-!! recoded in assembly by Toshiyasu Morita
-!! tm@netcom.com
-
-/* SH2 optimizations for ___ashrsi3, ___ashlsi3, ___lshrsi3 and
-   ELF local label prefixes by J"orn Rennecke
-   amylaar@cygnus.com  */
-
-!
-! __ashrsi3
-!
-! Entry:
-!
-! r4: Value to shift
-! r5: Shifts
-!
-! Exit:
-!
-! r0: Result
-!
-! Destroys:
-!
-! (none)
-!
-! __ashrsi3_r0
-!
-! Entry:
-!
-! r4: Value to shift
-! r0: Shifts
-!
-! Exit:
-!
-! r0: Result
-!
-! Destroys:
-!
-! (none)
-
-	.global	__ashrsi3
-	.global	__ashrsi3_r0
-	
-	.align	2
-__ashrsi3:
-	mov	r5,r0
-	.align	2
-__ashrsi3_r0:
-	and	#31,r0
-	mov.l	r4,@-r15
-	mov	r0,r4
-	mova	ashrsi3_table,r0
-	mov.b	@(r0,r4),r4
-	add	r4,r0
-	jmp	@r0
-	mov.l	@r15+,r0
-
-	.align	2
-ashrsi3_table:
-	.byte		ashrsi3_0-ashrsi3_table
-	.byte		ashrsi3_1-ashrsi3_table
-	.byte		ashrsi3_2-ashrsi3_table
-	.byte		ashrsi3_3-ashrsi3_table
-	.byte		ashrsi3_4-ashrsi3_table
-	.byte		ashrsi3_5-ashrsi3_table
-	.byte		ashrsi3_6-ashrsi3_table
-	.byte		ashrsi3_7-ashrsi3_table
-	.byte		ashrsi3_8-ashrsi3_table
-	.byte		ashrsi3_9-ashrsi3_table
-	.byte		ashrsi3_10-ashrsi3_table
-	.byte		ashrsi3_11-ashrsi3_table
-	.byte		ashrsi3_12-ashrsi3_table
-	.byte		ashrsi3_13-ashrsi3_table
-	.byte		ashrsi3_14-ashrsi3_table
-	.byte		ashrsi3_15-ashrsi3_table
-	.byte		ashrsi3_16-ashrsi3_table
-	.byte		ashrsi3_17-ashrsi3_table
-	.byte		ashrsi3_18-ashrsi3_table
-	.byte		ashrsi3_19-ashrsi3_table
-	.byte		ashrsi3_20-ashrsi3_table
-	.byte		ashrsi3_21-ashrsi3_table
-	.byte		ashrsi3_22-ashrsi3_table
-	.byte		ashrsi3_23-ashrsi3_table
-	.byte		ashrsi3_24-ashrsi3_table
-	.byte		ashrsi3_25-ashrsi3_table
-	.byte		ashrsi3_26-ashrsi3_table
-	.byte		ashrsi3_27-ashrsi3_table
-	.byte		ashrsi3_28-ashrsi3_table
-	.byte		ashrsi3_29-ashrsi3_table
-	.byte		ashrsi3_30-ashrsi3_table
-	.byte		ashrsi3_31-ashrsi3_table
-
-ashrsi3_31:
-	rotcl	r0
-	rts
-	subc	r0,r0
-
-ashrsi3_30:
-	shar	r0
-ashrsi3_29:
-	shar	r0
-ashrsi3_28:
-	shar	r0
-ashrsi3_27:
-	shar	r0
-ashrsi3_26:
-	shar	r0
-ashrsi3_25:
-	shar	r0
-ashrsi3_24:
-	shlr16	r0
-	shlr8	r0
-	rts
-	exts.b	r0,r0
-
-ashrsi3_23:
-	shar	r0
-ashrsi3_22:
-	shar	r0
-ashrsi3_21:
-	shar	r0
-ashrsi3_20:
-	shar	r0
-ashrsi3_19:
-	shar	r0
-ashrsi3_18:
-	shar	r0
-ashrsi3_17:
-	shar	r0
-ashrsi3_16:
-	shlr16	r0
-	rts
-	exts.w	r0,r0
-
-ashrsi3_15:
-	shar	r0
-ashrsi3_14:
-	shar	r0
-ashrsi3_13:
-	shar	r0
-ashrsi3_12:
-	shar	r0
-ashrsi3_11:
-	shar	r0
-ashrsi3_10:
-	shar	r0
-ashrsi3_9:
-	shar	r0
-ashrsi3_8:
-	shar	r0
-ashrsi3_7:
-	shar	r0
-ashrsi3_6:
-	shar	r0
-ashrsi3_5:
-	shar	r0
-ashrsi3_4:
-	shar	r0
-ashrsi3_3:
-	shar	r0
-ashrsi3_2:
-	shar	r0
-ashrsi3_1:
-	rts
-	shar	r0
-
-ashrsi3_0:
-	rts
-	nop
diff --git a/arch/sh/lib/checksum.S b/arch/sh/lib/checksum.S
deleted file mode 100644
index 3e07074e009813..00000000000000
--- a/arch/sh/lib/checksum.S
+++ /dev/null
@@ -1,365 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+
- *
- * $Id: checksum.S,v 1.10 2001/07/06 13:11:32 gniibe Exp $
- *
- * INET		An implementation of the TCP/IP protocol suite for the LINUX
- *		operating system.  INET is implemented using the  BSD Socket
- *		interface as the means of communication with the user level.
- *
- *		IP/TCP/UDP checksumming routines
- *
- * Authors:	Jorge Cwik, <jorge@laser.satlink.net>
- *		Arnt Gulbrandsen, <agulbra@nvg.unit.no>
- *		Tom May, <ftom@netcom.com>
- *              Pentium Pro/II routines:
- *              Alexander Kjeldaas <astor@guardian.no>
- *              Finn Arne Gangstad <finnag@guardian.no>
- *		Lots of code moved from tcp.c and ip.c; see those files
- *		for more names.
- *
- * Changes:     Ingo Molnar, converted csum_partial_copy() to 2.1 exception
- *			     handling.
- *		Andi Kleen,  add zeroing on error
- *                   converted to pure assembler
- *
- * SuperH version:  Copyright (C) 1999  Niibe Yutaka
- */
-
-#include <asm/errno.h>
-#include <linux/linkage.h>
-
-/*
- * computes a partial checksum, e.g. for TCP/UDP fragments
- */
-
-/*	
- * asmlinkage __wsum csum_partial(const void *buf, int len, __wsum sum);
- */
-
-.text
-ENTRY(csum_partial)
-	  /*
-	   * Experiments with Ethernet and SLIP connections show that buff
-	   * is aligned on either a 2-byte or 4-byte boundary.  We get at
-	   * least a twofold speedup on 486 and Pentium if it is 4-byte aligned.
-	   * Fortunately, it is easy to convert 2-byte alignment to 4-byte
-	   * alignment for the unrolled loop.
-	   */
-	mov	r4, r0
-	tst	#3, r0		! Check alignment.
-	bt/s	2f		! Jump if alignment is ok.
-	 mov	r4, r7		! Keep a copy to check for alignment
-	!
-	tst	#1, r0		! Check alignment.
-	bt	21f		! Jump if alignment is boundary of 2bytes.
-
-	! buf is odd
-	tst	r5, r5
-	add	#-1, r5
-	bt	9f
-	mov.b	@r4+, r0
-	extu.b	r0, r0
-	addc	r0, r6		! t=0 from previous tst
-	mov	r6, r0
-	shll8	r6
-	shlr16	r0
-	shlr8	r0
-	or	r0, r6
-	mov	r4, r0
-	tst	#2, r0
-	bt	2f
-21:
-	! buf is 2 byte aligned (len could be 0)
-	add	#-2, r5		! Alignment uses up two bytes.
-	cmp/pz	r5		!
-	bt/s	1f		! Jump if we had at least two bytes.
-	 clrt
-	bra	6f
-	 add	#2, r5		! r5 was < 2.  Deal with it.
-1:
-	mov.w	@r4+, r0
-	extu.w	r0, r0
-	addc	r0, r6
-	bf	2f
-	add	#1, r6
-2:
-	! buf is 4 byte aligned (len could be 0)
-	mov	r5, r1
-	mov	#-5, r0
-	shld	r0, r1
-	tst	r1, r1
-	bt/s	4f		! if it's =0, go to 4f
-	 clrt
-	.align	2
-3:
-	mov.l	@r4+, r0
-	mov.l	@r4+, r2
-	mov.l	@r4+, r3
-	addc	r0, r6
-	mov.l	@r4+, r0
-	addc	r2, r6
-	mov.l	@r4+, r2
-	addc	r3, r6
-	mov.l	@r4+, r3
-	addc	r0, r6
-	mov.l	@r4+, r0
-	addc	r2, r6
-	mov.l	@r4+, r2
-	addc	r3, r6
-	addc	r0, r6
-	addc	r2, r6
-	movt	r0
-	dt	r1
-	bf/s	3b
-	 cmp/eq	#1, r0
-	! here, we know r1==0
-	addc	r1, r6			! add carry to r6
-4:
-	mov	r5, r0
-	and	#0x1c, r0
-	tst	r0, r0
-	bt	6f
-	! 4 bytes or more remaining
-	mov	r0, r1
-	shlr2	r1
-	mov	#0, r2
-5:
-	addc	r2, r6
-	mov.l	@r4+, r2
-	movt	r0
-	dt	r1
-	bf/s	5b
-	 cmp/eq	#1, r0
-	addc	r2, r6
-	addc	r1, r6		! r1==0 here, so it means add carry-bit
-6:
-	! 3 bytes or less remaining
-	mov	#3, r0
-	and	r0, r5
-	tst	r5, r5
-	bt	9f		! if it's =0 go to 9f
-	mov	#2, r1
-	cmp/hs  r1, r5
-	bf	7f
-	mov.w	@r4+, r0
-	extu.w	r0, r0
-	cmp/eq	r1, r5
-	bt/s	8f
-	 clrt
-	shll16	r0
-	addc	r0, r6
-7:
-	mov.b	@r4+, r0
-	extu.b	r0, r0
-#ifndef	__LITTLE_ENDIAN__
-	shll8	r0
-#endif
-8:
-	addc	r0, r6
-	mov	#0, r0
-	addc	r0, r6
-9:
-	! Check if the buffer was misaligned, if so realign sum
-	mov	r7, r0
-	tst	#1, r0
-	bt	10f
-	mov	r6, r0
-	shll8	r6
-	shlr16	r0
-	shlr8	r0
-	or	r0, r6
-10:
-	rts
-	 mov	r6, r0
-
-/*
-unsigned int csum_partial_copy_generic (const char *src, char *dst, int len)
- */ 
-
-/*
- * Copy from ds while checksumming, otherwise like csum_partial with initial
- * sum being ~0U
- */
-
-#define EXC(...)			\
-	9999: __VA_ARGS__ ;		\
-	.section __ex_table, "a";	\
-	.long 9999b, 6001f	;	\
-	.previous
-
-!
-! r4:	const char *SRC
-! r5:	char *DST
-! r6:	int LEN
-!
-ENTRY(csum_partial_copy_generic)
-	mov	#-1,r7
-	mov	#3,r0		! Check src and dest are equally aligned
-	mov	r4,r1
-	and	r0,r1
-	and	r5,r0
-	cmp/eq	r1,r0
-	bf	3f		! Different alignments, use slow version
-	tst	#1,r0		! Check dest word aligned
-	bf	3f		! If not, do it the slow way
-
-	mov	#2,r0
-	tst	r0,r5		! Check dest alignment. 
-	bt	2f		! Jump if alignment is ok.
-	add	#-2,r6		! Alignment uses up two bytes.
-	cmp/pz	r6		! Jump if we had at least two bytes.
-	bt/s	1f
-	 clrt
-	add	#2,r6		! r6 was < 2.	Deal with it.
-	bra	4f
-	 mov	r6,r2
-
-3:	! Handle different src and dest alignments.
-	! This is not common, so simple byte by byte copy will do.
-	mov	r6,r2
-	shlr	r6
-	tst	r6,r6
-	bt	4f
-	clrt
-	.align	2
-5:
-EXC(	mov.b	@r4+,r1 	)
-EXC(	mov.b	@r4+,r0		)
-	extu.b	r1,r1
-EXC(	mov.b	r1,@r5		)
-EXC(	mov.b	r0,@(1,r5)	)
-	extu.b	r0,r0
-	add	#2,r5
-
-#ifdef	__LITTLE_ENDIAN__
-	shll8	r0
-#else
-	shll8	r1
-#endif
-	or	r1,r0
-
-	addc	r0,r7
-	movt	r0
-	dt	r6
-	bf/s	5b
-	 cmp/eq	#1,r0
-	mov	#0,r0
-	addc	r0, r7
-
-	mov	r2, r0
-	tst	#1, r0
-	bt	7f
-	bra	5f
-	 clrt
-
-	! src and dest equally aligned, but to a two byte boundary.
-	! Handle first two bytes as a special case
-	.align	2
-1:	
-EXC(	mov.w	@r4+,r0		)
-EXC(	mov.w	r0,@r5		)
-	add	#2,r5
-	extu.w	r0,r0
-	addc	r0,r7
-	mov	#0,r0
-	addc	r0,r7
-2:
-	mov	r6,r2
-	mov	#-5,r0
-	shld	r0,r6
-	tst	r6,r6
-	bt/s	2f
-	 clrt
-	.align	2
-1:	
-EXC(	mov.l	@r4+,r0		)
-EXC(	mov.l	@r4+,r1		)
-	addc	r0,r7
-EXC(	mov.l	r0,@r5		)
-EXC(	mov.l	r1,@(4,r5)	)
-	addc	r1,r7
-
-EXC(	mov.l	@r4+,r0		)
-EXC(	mov.l	@r4+,r1		)
-	addc	r0,r7
-EXC(	mov.l	r0,@(8,r5)	)
-EXC(	mov.l	r1,@(12,r5)	)
-	addc	r1,r7
-
-EXC(	mov.l	@r4+,r0 	)
-EXC(	mov.l	@r4+,r1		)
-	addc	r0,r7
-EXC(	mov.l	r0,@(16,r5)	)
-EXC(	mov.l	r1,@(20,r5)	)
-	addc	r1,r7
-
-EXC(	mov.l	@r4+,r0		)
-EXC(	mov.l	@r4+,r1		)
-	addc	r0,r7
-EXC(	mov.l	r0,@(24,r5)	)
-EXC(	mov.l	r1,@(28,r5)	)
-	addc	r1,r7
-	add	#32,r5
-	movt	r0
-	dt	r6
-	bf/s	1b
-	 cmp/eq	#1,r0
-	mov	#0,r0
-	addc	r0,r7
-
-2:	mov	r2,r6
-	mov	#0x1c,r0
-	and	r0,r6
-	cmp/pl	r6
-	bf/s	4f
-	 clrt
-	shlr2	r6
-3:	
-EXC(	mov.l	@r4+,r0	)
-	addc	r0,r7
-EXC(	mov.l	r0,@r5	)
-	add	#4,r5
-	movt	r0
-	dt	r6
-	bf/s	3b
-	 cmp/eq	#1,r0
-	mov	#0,r0
-	addc	r0,r7
-4:	mov	r2,r6
-	mov	#3,r0
-	and	r0,r6
-	cmp/pl	r6
-	bf	7f
-	mov	#2,r1
-	cmp/hs	r1,r6
-	bf	5f
-EXC(	mov.w	@r4+,r0	)
-EXC(	mov.w	r0,@r5	)
-	extu.w	r0,r0
-	add	#2,r5
-	cmp/eq	r1,r6
-	bt/s	6f
-	 clrt
-	shll16	r0
-	addc	r0,r7
-5:	
-EXC(	mov.b	@r4+,r0	)
-EXC(	mov.b	r0,@r5	)
-	extu.b	r0,r0
-#ifndef	__LITTLE_ENDIAN__
-	shll8	r0
-#endif
-6:	addc	r0,r7
-	mov	#0,r0
-	addc	r0,r7
-7:
-
-# Exception handler:
-.section .fixup, "ax"							
-
-6001:
-	rts
-	 mov	#0,r0
-.previous
-	rts
-	 mov	r7,r0
diff --git a/arch/sh/lib/copy_page.S b/arch/sh/lib/copy_page.S
deleted file mode 100644
index d4e9d18cee0bcc..00000000000000
--- a/arch/sh/lib/copy_page.S
+++ /dev/null
@@ -1,390 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * copy_page, __copy_user_page, __copy_user implementation of SuperH
- *
- * Copyright (C) 2001  Niibe Yutaka & Kaz Kojima
- * Copyright (C) 2002  Toshinobu Sugioka
- * Copyright (C) 2006  Paul Mundt
- */
-#include <linux/linkage.h>
-#include <asm/page.h>
-
-/*
- * copy_page
- * @to: P1 address
- * @from: P1 address
- *
- * void copy_page(void *to, void *from)
- */
-
-/*
- * r0, r1, r2, r3, r4, r5, r6, r7 --- scratch 
- * r8 --- from + PAGE_SIZE
- * r9 --- not used
- * r10 --- to
- * r11 --- from
- */
-ENTRY(copy_page)
-	mov.l	r8,@-r15
-	mov.l	r10,@-r15
-	mov.l	r11,@-r15
-	mov	r4,r10
-	mov	r5,r11
-	mov	r5,r8
-	mov	#(PAGE_SIZE >> 10), r0
-	shll8	r0
-	shll2	r0
-	add	r0,r8
-	!
-1:	mov.l	@r11+,r0
-	mov.l	@r11+,r1
-	mov.l	@r11+,r2
-	mov.l	@r11+,r3
-	mov.l	@r11+,r4
-	mov.l	@r11+,r5
-	mov.l	@r11+,r6
-	mov.l	@r11+,r7
-#if defined(CONFIG_CPU_SH4)
-	movca.l	r0,@r10
-#else
-	mov.l	r0,@r10
-#endif
-	add	#32,r10
-	mov.l	r7,@-r10
-	mov.l	r6,@-r10
-	mov.l	r5,@-r10
-	mov.l	r4,@-r10
-	mov.l	r3,@-r10
-	mov.l	r2,@-r10
-	mov.l	r1,@-r10
-	cmp/eq	r11,r8
-	bf/s	1b
-	 add	#28,r10
-	!
-	mov.l	@r15+,r11
-	mov.l	@r15+,r10
-	mov.l	@r15+,r8
-	rts
-	 nop
-
-/*
- * __kernel_size_t __copy_user(void *to, const void *from, __kernel_size_t n);
- * Return the number of bytes NOT copied
- */
-#define EX(...)			\
-	9999: __VA_ARGS__ ;		\
-	.section __ex_table, "a";	\
-	.long 9999b, 6000f	;	\
-	.previous
-#define EX_NO_POP(...)			\
-	9999: __VA_ARGS__ ;		\
-	.section __ex_table, "a";	\
-	.long 9999b, 6005f	;	\
-	.previous
-ENTRY(__copy_user)
-	! Check if small number of bytes
-	mov	#11,r0
-	mov	r4,r3
-	cmp/gt	r0,r6		! r6 (len) > r0 (11)
-	bf/s	.L_cleanup_loop_no_pop
-	 add	r6,r3		! last destination address
-
-	! Calculate bytes needed to align to src
-	mov.l	r11,@-r15
-	neg	r5,r0
-	mov.l	r10,@-r15
-	add	#4,r0
-	mov.l	r9,@-r15
-	and	#3,r0
-	mov.l	r8,@-r15
-	tst	r0,r0
-	bt	2f
-
-1:
-	! Copy bytes to long word align src
-EX(	mov.b	@r5+,r1		)
-	dt	r0
-	add	#-1,r6
-EX(	mov.b	r1,@r4		)
-	bf/s	1b
-	 add	#1,r4
-
-	! Jump to appropriate routine depending on dest
-2:	mov	#3,r1
-	mov	r6, r2
-	and	r4,r1
-	shlr2	r2
-	shll2	r1
-	mova	.L_jump_tbl,r0
-	mov.l	@(r0,r1),r1
-	jmp	@r1
-	 nop
-
-	.align 2
-.L_jump_tbl:
-	.long	.L_dest00
-	.long	.L_dest01
-	.long	.L_dest10
-	.long	.L_dest11
-
-/*
- * Come here if there are less than 12 bytes to copy
- *
- * Keep the branch target close, so the bf/s callee doesn't overflow
- * and result in a more expensive branch being inserted. This is the
- * fast-path for small copies, the jump via the jump table will hit the
- * default slow-path cleanup. -PFM.
- */
-.L_cleanup_loop_no_pop:
-	tst	r6,r6		! Check explicitly for zero
-	bt	1f
-
-2:
-EX_NO_POP(	mov.b	@r5+,r0		)
-	dt	r6
-EX_NO_POP(	mov.b	r0,@r4		)
-	bf/s	2b
-	 add	#1,r4
-
-1:	mov	#0,r0		! normal return
-5000:
-
-# Exception handler:
-.section .fixup, "ax"
-6005:
-	mov.l	8000f,r1
-	mov	r3,r0
-	jmp	@r1
-	 sub	r4,r0
-	.align	2
-8000:	.long	5000b
-
-.previous
-	rts
-	 nop
-
-! Destination = 00
-
-.L_dest00:
-	! Skip the large copy for small transfers
-	mov	#(32+32-4), r0
-	cmp/gt	r6, r0		! r0 (60) > r6 (len)
-	bt	1f
-
-	! Align dest to a 32 byte boundary
-	neg	r4,r0
-	add	#0x20, r0
-	and	#0x1f, r0
-	tst	r0, r0
-	bt	2f
-
-	sub	r0, r6
-	shlr2	r0
-3:
-EX(	mov.l	@r5+,r1		)
-	dt	r0
-EX(	mov.l	r1,@r4		)
-	bf/s	3b
-	 add	#4,r4
-
-2:
-EX(	mov.l	@r5+,r0		)
-EX(	mov.l	@r5+,r1		)
-EX(	mov.l	@r5+,r2		)
-EX(	mov.l	@r5+,r7		)
-EX(	mov.l	@r5+,r8		)
-EX(	mov.l	@r5+,r9		)
-EX(	mov.l	@r5+,r10	)
-EX(	mov.l	@r5+,r11	)
-#ifdef CONFIG_CPU_SH4
-EX(	movca.l	r0,@r4		)
-#else
-EX(	mov.l	r0,@r4		)
-#endif
-	add	#-32, r6
-EX(	mov.l	r1,@(4,r4)	)
-	mov	#32, r0
-EX(	mov.l	r2,@(8,r4)	)
-	cmp/gt	r6, r0		! r0 (32) > r6 (len)
-EX(	mov.l	r7,@(12,r4)	)
-EX(	mov.l	r8,@(16,r4)	)
-EX(	mov.l	r9,@(20,r4)	)
-EX(	mov.l	r10,@(24,r4)	)
-EX(	mov.l	r11,@(28,r4)	)
-	bf/s	2b
-	 add	#32,r4
-
-1:	mov	r6, r0
-	shlr2	r0
-	tst	r0, r0
-	bt	.L_cleanup
-1:
-EX(	mov.l	@r5+,r1		)
-	dt	r0
-EX(	mov.l	r1,@r4		)
-	bf/s	1b
-	 add	#4,r4
-
-	bra	.L_cleanup
-	 nop
-
-! Destination = 10
-
-.L_dest10:
-	mov	r2,r7
-	shlr2	r7
-	shlr	r7
-	tst	r7,r7
-	mov	#7,r0
-	bt/s	1f
-	 and	r0,r2
-2:
-	dt	r7
-#ifdef CONFIG_CPU_LITTLE_ENDIAN
-EX(	mov.l	@r5+,r0		)
-EX(	mov.l	@r5+,r1		)
-EX(	mov.l	@r5+,r8		)
-EX(	mov.l	@r5+,r9		)
-EX(	mov.l	@r5+,r10	)
-EX(	mov.w	r0,@r4		)
-	add	#2,r4
-	xtrct	r1,r0
-	xtrct	r8,r1
-	xtrct	r9,r8
-	xtrct	r10,r9
-
-EX(	mov.l	r0,@r4		)
-EX(	mov.l	r1,@(4,r4)	)
-EX(	mov.l	r8,@(8,r4)	)
-EX(	mov.l	r9,@(12,r4)	)
-
-EX(	mov.l	@r5+,r1		)
-EX(	mov.l	@r5+,r8		)
-EX(	mov.l	@r5+,r0		)
-	xtrct	r1,r10
-	xtrct	r8,r1
-	xtrct	r0,r8
-	shlr16	r0
-EX(	mov.l	r10,@(16,r4)	)
-EX(	mov.l	r1,@(20,r4)	)
-EX(	mov.l	r8,@(24,r4)	)
-EX(	mov.w	r0,@(28,r4)	)
-	bf/s	2b
-	 add	#30,r4
-#else
-EX(	mov.l	@(28,r5),r0	)
-EX(	mov.l	@(24,r5),r8	)
-EX(	mov.l	@(20,r5),r9	)
-EX(	mov.l	@(16,r5),r10	)
-EX(	mov.w	r0,@(30,r4)	)
-	add	#-2,r4
-	xtrct	r8,r0
-	xtrct	r9,r8
-	xtrct	r10,r9
-EX(	mov.l	r0,@(28,r4)	)
-EX(	mov.l	r8,@(24,r4)	)
-EX(	mov.l	r9,@(20,r4)	)
-
-EX(	mov.l	@(12,r5),r0	)
-EX(	mov.l	@(8,r5),r8	)
-	xtrct	r0,r10
-EX(	mov.l	@(4,r5),r9	)
-	mov.l	r10,@(16,r4)
-EX(	mov.l	@r5,r10		)
-	xtrct	r8,r0
-	xtrct	r9,r8
-	xtrct	r10,r9
-EX(	mov.l	r0,@(12,r4)	)
-EX(	mov.l	r8,@(8,r4)	)
-	swap.w	r10,r0
-EX(	mov.l	r9,@(4,r4)	)
-EX(	mov.w	r0,@(2,r4)	)
-
-	add	#32,r5
-	bf/s	2b
-	 add	#34,r4
-#endif
-	tst	r2,r2
-	bt	.L_cleanup
-
-1:	! Read longword, write two words per iteration
-EX(	mov.l	@r5+,r0		)
-	dt	r2
-#ifdef CONFIG_CPU_LITTLE_ENDIAN
-EX(	mov.w	r0,@r4		)
-	shlr16	r0
-EX(	mov.w 	r0,@(2,r4)	)
-#else
-EX(	mov.w	r0,@(2,r4)	)
-	shlr16	r0
-EX(	mov.w	r0,@r4		)
-#endif
-	bf/s	1b
-	 add	#4,r4
-
-	bra	.L_cleanup
-	 nop
-
-! Destination = 01 or 11
-
-.L_dest01:
-.L_dest11:
-	! Read longword, write byte, word, byte per iteration
-EX(	mov.l	@r5+,r0		)
-	dt	r2
-#ifdef CONFIG_CPU_LITTLE_ENDIAN
-EX(	mov.b	r0,@r4		)
-	shlr8	r0
-	add	#1,r4
-EX(	mov.w	r0,@r4		)
-	shlr16	r0
-EX(	mov.b	r0,@(2,r4)	)
-	bf/s	.L_dest01
-	 add	#3,r4
-#else
-EX(	mov.b	r0,@(3,r4)	)
-	shlr8	r0
-	swap.w	r0,r7
-EX(	mov.b	r7,@r4		)
-	add	#1,r4
-EX(	mov.w	r0,@r4		)
-	bf/s	.L_dest01
-	 add	#3,r4
-#endif
-
-! Cleanup last few bytes
-.L_cleanup:
-	mov	r6,r0
-	and	#3,r0
-	tst	r0,r0
-	bt	.L_exit
-	mov	r0,r6
-
-.L_cleanup_loop:
-EX(	mov.b	@r5+,r0		)
-	dt	r6
-EX(	mov.b	r0,@r4		)
-	bf/s	.L_cleanup_loop
-	 add	#1,r4
-
-.L_exit:
-	mov	#0,r0		! normal return
-
-5000:
-
-# Exception handler:
-.section .fixup, "ax"
-6000:
-	mov.l	8000f,r1
-	mov	r3,r0
-	jmp	@r1
-	 sub	r4,r0
-	.align	2
-8000:	.long	5000b
-
-.previous
-	mov.l	@r15+,r8
-	mov.l	@r15+,r9
-	mov.l	@r15+,r10
-	rts
-	 mov.l	@r15+,r11
diff --git a/arch/sh/lib/delay.c b/arch/sh/lib/delay.c
deleted file mode 100644
index dad8e6a54906be..00000000000000
--- a/arch/sh/lib/delay.c
+++ /dev/null
@@ -1,54 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- *	Precise Delay Loops for SuperH
- *
- *	Copyright (C) 1999 Niibe Yutaka & Kaz Kojima
- */
-
-#include <linux/sched.h>
-#include <linux/delay.h>
-
-void __delay(unsigned long loops)
-{
-	__asm__ __volatile__(
-		/*
-		 * ST40-300 appears to have an issue with this code,
-		 * normally taking two cycles each loop, as with all
-		 * other SH variants. If however the branch and the
-		 * delay slot straddle an 8 byte boundary, this increases
-		 * to 3 cycles.
-		 * This align directive ensures this doesn't occur.
-		 */
-		".balign 8\n\t"
-
-		"tst	%0, %0\n\t"
-		"1:\t"
-		"bf/s	1b\n\t"
-		" dt	%0"
-		: "=r" (loops)
-		: "0" (loops)
-		: "t");
-}
-
-inline void __const_udelay(unsigned long xloops)
-{
-	xloops *= 4;
-	__asm__("dmulu.l	%0, %2\n\t"
-		"sts	mach, %0"
-		: "=r" (xloops)
-		: "0" (xloops),
-		  "r" (cpu_data[raw_smp_processor_id()].loops_per_jiffy * (HZ/4))
-		: "macl", "mach");
-	__delay(++xloops);
-}
-
-void __udelay(unsigned long usecs)
-{
-	__const_udelay(usecs * 0x000010c6);  /* 2**32 / 1000000 */
-}
-
-void __ndelay(unsigned long nsecs)
-{
-	__const_udelay(nsecs * 0x00000005);
-}
-
diff --git a/arch/sh/lib/div64-generic.c b/arch/sh/lib/div64-generic.c
deleted file mode 100644
index 0b67fbc44f6fef..00000000000000
--- a/arch/sh/lib/div64-generic.c
+++ /dev/null
@@ -1,20 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Generic __div64_32 wrapper for __xdiv64_32.
- */
-
-#include <linux/types.h>
-#include <asm/div64.h>
-
-extern uint64_t __xdiv64_32(u64 n, u32 d);
-
-uint32_t __div64_32(u64 *xp, u32 y)
-{
-	uint32_t rem;
-	uint64_t q = __xdiv64_32(*xp, y);
-
-	rem = *xp - q * y;
-	*xp = q;
-
-	return rem;
-}
diff --git a/arch/sh/lib/div64.S b/arch/sh/lib/div64.S
deleted file mode 100644
index 4a9a966e71b0e7..00000000000000
--- a/arch/sh/lib/div64.S
+++ /dev/null
@@ -1,47 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*	
- * unsigned long __xdiv64_32(unsigned long long n, unsigned long d); 
- */
-
-#include <linux/linkage.h>
-
-.text
-ENTRY(__xdiv64_32)
-#ifdef CONFIG_CPU_LITTLE_ENDIAN
-	mov	r4, r0
-	mov	r5, r1
-#else
-	mov	r4, r1
-	mov	r5, r0
-#endif
-	cmp/hs	r6, r1
-	bf.s	1f
-	 mov	#0, r2
-
-	mov	r1, r2
-	mov	#0, r3
-	div0u
-	.rept	32
-	rotcl	r2
-	div1	r6, r3
-	.endr
-	rotcl	r2
-	mul.l	r6, r2
-	sts	macl, r3
-	sub	r3, r1
-1:
-	div0u
-	.rept	32
-	rotcl	r0
-	div1	r6, r1
-	.endr
-#ifdef CONFIG_CPU_LITTLE_ENDIAN
-	mov	r2, r1
-	rts
-	 rotcl	r0
-#else
-	rotcl	r0
-	mov	r0, r1
-	rts
-	 mov	r2, r0
-#endif
diff --git a/arch/sh/lib/io.c b/arch/sh/lib/io.c
deleted file mode 100644
index ebcf7c0a7335ad..00000000000000
--- a/arch/sh/lib/io.c
+++ /dev/null
@@ -1,79 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/lib/io.c - SH32 optimized I/O routines
- *
- * Copyright (C) 2000  Stuart Menefy
- * Copyright (C) 2005  Paul Mundt
- *
- * Provide real functions which expand to whatever the header file defined.
- * Also definitions of machine independent IO functions.
- */
-#include <linux/module.h>
-#include <linux/io.h>
-
-void __raw_readsl(const void __iomem *addr, void *datap, int len)
-{
-	u32 *data;
-
-	for (data = datap; (len != 0) && (((u32)data & 0x1f) != 0); len--)
-		*data++ = __raw_readl(addr);
-
-	if (likely(len >= (0x20 >> 2))) {
-		int tmp2, tmp3, tmp4, tmp5, tmp6;
-
-		__asm__ __volatile__(
-			"1:			\n\t"
-			"mov.l	@%7, r0		\n\t"
-			"mov.l	@%7, %2		\n\t"
-#ifdef CONFIG_CPU_SH4
-			"movca.l r0, @%0	\n\t"
-#else
-			"mov.l	r0, @%0		\n\t"
-#endif
-			"mov.l	@%7, %3		\n\t"
-			"mov.l	@%7, %4		\n\t"
-			"mov.l	@%7, %5		\n\t"
-			"mov.l	@%7, %6		\n\t"
-			"mov.l	@%7, r7		\n\t"
-			"mov.l	@%7, r0		\n\t"
-			"mov.l	%2, @(0x04,%0)	\n\t"
-			"mov	#0x20>>2, %2	\n\t"
-			"mov.l	%3, @(0x08,%0)	\n\t"
-			"sub	%2, %1		\n\t"
-			"mov.l	%4, @(0x0c,%0)	\n\t"
-			"cmp/hi	%1, %2		! T if 32 > len	\n\t"
-			"mov.l	%5, @(0x10,%0)	\n\t"
-			"mov.l	%6, @(0x14,%0)	\n\t"
-			"mov.l	r7, @(0x18,%0)	\n\t"
-			"mov.l	r0, @(0x1c,%0)	\n\t"
-			"bf.s	1b		\n\t"
-			" add	#0x20, %0	\n\t"
-			: "=&r" (data), "=&r" (len),
-			  "=&r" (tmp2), "=&r" (tmp3), "=&r" (tmp4),
-			  "=&r" (tmp5), "=&r" (tmp6)
-			: "r"(addr), "0" (data), "1" (len)
-			: "r0", "r7", "t", "memory");
-	}
-
-	for (; len != 0; len--)
-		*data++ = __raw_readl(addr);
-}
-EXPORT_SYMBOL(__raw_readsl);
-
-void __raw_writesl(void __iomem *addr, const void *data, int len)
-{
-	if (likely(len != 0)) {
-		int tmp1;
-
-		__asm__ __volatile__ (
-			"1:				\n\t"
-			"mov.l	@%0+, %1	\n\t"
-			"dt		%3		\n\t"
-			"bf.s		1b		\n\t"
-			" mov.l	%1, @%4		\n\t"
-			: "=&r" (data), "=&r" (tmp1)
-			: "0" (data), "r" (len), "r"(addr)
-			: "t", "memory");
-	}
-}
-EXPORT_SYMBOL(__raw_writesl);
diff --git a/arch/sh/lib/libgcc.h b/arch/sh/lib/libgcc.h
deleted file mode 100644
index 58ada9e8f1c2bd..00000000000000
--- a/arch/sh/lib/libgcc.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-#ifndef __ASM_LIBGCC_H
-#define __ASM_LIBGCC_H
-
-#include <asm/byteorder.h>
-
-typedef int word_type __attribute__ ((mode (__word__)));
-
-#ifdef __BIG_ENDIAN
-struct DWstruct {
-	int high, low;
-};
-#elif defined(__LITTLE_ENDIAN)
-struct DWstruct {
-	int low, high;
-};
-#else
-#error I feel sick.
-#endif
-
-typedef union {
-	struct DWstruct s;
-	long long ll;
-} DWunion;
-
-#endif /* __ASM_LIBGCC_H */
diff --git a/arch/sh/lib/lshrdi3.c b/arch/sh/lib/lshrdi3.c
deleted file mode 100644
index 33eaa1edbc3c06..00000000000000
--- a/arch/sh/lib/lshrdi3.c
+++ /dev/null
@@ -1,30 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/module.h>
-
-#include "libgcc.h"
-
-long long __lshrdi3(long long u, word_type b)
-{
-	DWunion uu, w;
-	word_type bm;
-
-	if (b == 0)
-		return u;
-
-	uu.ll = u;
-	bm = 32 - b;
-
-	if (bm <= 0) {
-		w.s.high = 0;
-		w.s.low = (unsigned int) uu.s.high >> -bm;
-	} else {
-		const unsigned int carries = (unsigned int) uu.s.high << bm;
-
-		w.s.high = (unsigned int) uu.s.high >> b;
-		w.s.low = ((unsigned int) uu.s.low >> b) | carries;
-	}
-
-	return w.ll;
-}
-
-EXPORT_SYMBOL(__lshrdi3);
diff --git a/arch/sh/lib/lshrsi3.S b/arch/sh/lib/lshrsi3.S
deleted file mode 100644
index b79b8170061f33..00000000000000
--- a/arch/sh/lib/lshrsi3.S
+++ /dev/null
@@ -1,188 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ WITH GCC-exception-2.0
-
-   Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
-   2004, 2005, 2006
-   Free Software Foundation, Inc.
-*/
-
-!! libgcc routines for the Renesas / SuperH SH CPUs.
-!! Contributed by Steve Chamberlain.
-!! sac@cygnus.com
-
-!! ashiftrt_r4_x, ___ashrsi3, ___ashlsi3, ___lshrsi3 routines
-!! recoded in assembly by Toshiyasu Morita
-!! tm@netcom.com
-
-/* SH2 optimizations for ___ashrsi3, ___ashlsi3, ___lshrsi3 and
-   ELF local label prefixes by J"orn Rennecke
-   amylaar@cygnus.com  */
-
-!
-! __lshrsi3
-!
-! Entry:
-!
-! r4: Value to shift
-! r5: Shifts
-!
-! Exit:
-!
-! r0: Result
-!
-! Destroys:
-!
-! (none)
-!
-! __lshrsi3_r0
-!
-! Entry:
-!
-! r0: Value to shift
-! r5: Shifts
-!
-! Exit:
-!
-! r0: Result
-!
-! Destroys:
-!
-! (none)
-!
-	.global	__lshrsi3
-	.global	__lshrsi3_r0
-	
-	.align	2
-__lshrsi3:
-	mov	r5,r0
-	.align	2
-__lshrsi3_r0:
-	and	#31,r0
-	mov.l	r4,@-r15
-	mov	r0,r4
-	mova	lshrsi3_table,r0
-	mov.b	@(r0,r4),r4
-	add	r4,r0
-	jmp	@r0
-	mov.l	@r15+,r0
-
-	.align	2
-lshrsi3_table:
-	.byte		lshrsi3_0-lshrsi3_table
-	.byte		lshrsi3_1-lshrsi3_table
-	.byte		lshrsi3_2-lshrsi3_table
-	.byte		lshrsi3_3-lshrsi3_table
-	.byte		lshrsi3_4-lshrsi3_table
-	.byte		lshrsi3_5-lshrsi3_table
-	.byte		lshrsi3_6-lshrsi3_table
-	.byte		lshrsi3_7-lshrsi3_table
-	.byte		lshrsi3_8-lshrsi3_table
-	.byte		lshrsi3_9-lshrsi3_table
-	.byte		lshrsi3_10-lshrsi3_table
-	.byte		lshrsi3_11-lshrsi3_table
-	.byte		lshrsi3_12-lshrsi3_table
-	.byte		lshrsi3_13-lshrsi3_table
-	.byte		lshrsi3_14-lshrsi3_table
-	.byte		lshrsi3_15-lshrsi3_table
-	.byte		lshrsi3_16-lshrsi3_table
-	.byte		lshrsi3_17-lshrsi3_table
-	.byte		lshrsi3_18-lshrsi3_table
-	.byte		lshrsi3_19-lshrsi3_table
-	.byte		lshrsi3_20-lshrsi3_table
-	.byte		lshrsi3_21-lshrsi3_table
-	.byte		lshrsi3_22-lshrsi3_table
-	.byte		lshrsi3_23-lshrsi3_table
-	.byte		lshrsi3_24-lshrsi3_table
-	.byte		lshrsi3_25-lshrsi3_table
-	.byte		lshrsi3_26-lshrsi3_table
-	.byte		lshrsi3_27-lshrsi3_table
-	.byte		lshrsi3_28-lshrsi3_table
-	.byte		lshrsi3_29-lshrsi3_table
-	.byte		lshrsi3_30-lshrsi3_table
-	.byte		lshrsi3_31-lshrsi3_table
-
-lshrsi3_6:
-	shlr2	r0
-lshrsi3_4:
-	shlr2	r0
-lshrsi3_2:
-	rts
-	shlr2	r0
-
-lshrsi3_7:
-	shlr2	r0
-lshrsi3_5:
-	shlr2	r0
-lshrsi3_3:
-	shlr2	r0
-lshrsi3_1:
-	rts
-	shlr	r0
-
-lshrsi3_14:
-	shlr2	r0
-lshrsi3_12:
-	shlr2	r0
-lshrsi3_10:
-	shlr2	r0
-lshrsi3_8:
-	rts
-	shlr8	r0
-
-lshrsi3_15:
-	shlr2	r0
-lshrsi3_13:
-	shlr2	r0
-lshrsi3_11:
-	shlr2	r0
-lshrsi3_9:
-	shlr8	r0
-	rts
-	shlr	r0
-
-lshrsi3_22:
-	shlr2	r0
-lshrsi3_20:
-	shlr2	r0
-lshrsi3_18:
-	shlr2	r0
-lshrsi3_16:
-	rts
-	shlr16	r0
-
-lshrsi3_23:
-	shlr2	r0
-lshrsi3_21:
-	shlr2	r0
-lshrsi3_19:
-	shlr2	r0
-lshrsi3_17:
-	shlr16	r0
-	rts
-	shlr	r0
-
-lshrsi3_30:
-	shlr2	r0
-lshrsi3_28:
-	shlr2	r0
-lshrsi3_26:
-	shlr2	r0
-lshrsi3_24:
-	shlr16	r0
-	rts
-	shlr8	r0
-
-lshrsi3_31:
-	shlr2	r0
-lshrsi3_29:
-	shlr2	r0
-lshrsi3_27:
-	shlr2	r0
-lshrsi3_25:
-	shlr16	r0
-	shlr8	r0
-	rts
-	shlr	r0
-
-lshrsi3_0:
-	rts
-	nop
diff --git a/arch/sh/lib/mcount.S b/arch/sh/lib/mcount.S
deleted file mode 100644
index c6ca90cc960618..00000000000000
--- a/arch/sh/lib/mcount.S
+++ /dev/null
@@ -1,287 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * arch/sh/lib/mcount.S
- *
- *  Copyright (C) 2008, 2009  Paul Mundt
- *  Copyright (C) 2008, 2009  Matt Fleming
- */
-#include <asm/ftrace.h>
-#include <asm/thread_info.h>
-#include <asm/asm-offsets.h>
-
-#define MCOUNT_ENTER()		\
-	mov.l	r4, @-r15;	\
-	mov.l	r5, @-r15;	\
-	mov.l	r6, @-r15;	\
-	mov.l	r7, @-r15;	\
-	sts.l	pr, @-r15;	\
-				\
-	mov.l	@(20,r15),r4;	\
-	sts	pr, r5
-
-#define MCOUNT_LEAVE()		\
-	lds.l	@r15+, pr;	\
-	mov.l	@r15+, r7;	\
-	mov.l	@r15+, r6;	\
-	mov.l	@r15+, r5;	\
-	rts;			\
-	 mov.l	@r15+, r4
-
-#ifdef CONFIG_STACK_DEBUG
-/*
- * Perform diagnostic checks on the state of the kernel stack.
- *
- * Check for stack overflow. If there is less than 1KB free
- * then it has overflowed.
- *
- * Make sure the stack pointer contains a valid address. Valid
- * addresses for kernel stacks are anywhere after the bss
- * (after __bss_stop) and anywhere in init_thread_union (init_stack).
- */
-#define STACK_CHECK()					\
-	mov	#(THREAD_SIZE >> 10), r0;		\
-	shll8	r0;					\
-	shll2	r0;					\
-							\
-	/* r1 = sp & (THREAD_SIZE - 1) */		\
-	mov	#-1, r1;				\
-	add	r0, r1;					\
-	and	r15, r1;				\
-							\
-	mov	#TI_SIZE, r3;				\
-	mov	#(STACK_WARN >> 8), r2;			\
-	shll8	r2;					\
-	add	r3, r2;					\
-							\
-	/* Is the stack overflowing? */			\
-	cmp/hi	r2, r1;					\
-	bf	stack_panic;				\
-							\
-	/* If sp > __bss_stop then we're OK. */		\
-	mov.l	.L_ebss, r1;				\
-	cmp/hi	r1, r15;				\
-	bt	1f;					\
-							\
-	/* If sp < init_stack, we're not OK. */		\
-	mov.l	.L_init_thread_union, r1;		\
-	cmp/hs	r1, r15;				\
-	bf	stack_panic;				\
-							\
-	/* If sp > init_stack && sp < __bss_stop, not OK. */	\
-	add	r0, r1;					\
-	cmp/hs	r1, r15;				\
-	bt	stack_panic;				\
-1:
-#else
-#define STACK_CHECK()
-#endif /* CONFIG_STACK_DEBUG */
-
-	.align 2
-	.globl	_mcount
-	.type	_mcount,@function
-	.globl	mcount
-	.type	mcount,@function
-_mcount:
-mcount:
-	STACK_CHECK()
-
-#ifndef CONFIG_FUNCTION_TRACER
-	rts
-	 nop
-#else
-	MCOUNT_ENTER()
-
-#ifdef CONFIG_DYNAMIC_FTRACE
-	.globl	mcount_call
-mcount_call:
-	mov.l	.Lftrace_stub, r6
-#else
-	mov.l	.Lftrace_trace_function, r6
-	mov.l	ftrace_stub, r7
-	cmp/eq	r6, r7
-	bt	skip_trace
-	mov.l	@r6, r6
-#endif
-
-	jsr	@r6
-	 nop
-
-#ifdef CONFIG_FUNCTION_GRAPH_TRACER
-	mov.l   .Lftrace_graph_return, r6
-	mov.l   .Lftrace_stub, r7
-	cmp/eq  r6, r7
-	bt      1f
-
-	mov.l   .Lftrace_graph_caller, r0
-	jmp     @r0
-	 nop
-
-1:
-	mov.l	.Lftrace_graph_entry, r6
-	mov.l	.Lftrace_graph_entry_stub, r7
-	cmp/eq	r6, r7
-	bt	skip_trace
-
-	mov.l   .Lftrace_graph_caller, r0
-	jmp	@r0
-	 nop
-
-	.align 2
-.Lftrace_graph_return:
-	.long   ftrace_graph_return
-.Lftrace_graph_entry:
-	.long   ftrace_graph_entry
-.Lftrace_graph_entry_stub:
-	.long   ftrace_graph_entry_stub
-.Lftrace_graph_caller:
-	.long   ftrace_graph_caller
-#endif /* CONFIG_FUNCTION_GRAPH_TRACER */
-
-	.globl skip_trace
-skip_trace:
-	MCOUNT_LEAVE()
-
-	.align 2
-.Lftrace_trace_function:
-	.long   ftrace_trace_function
-
-#ifdef CONFIG_DYNAMIC_FTRACE
-#ifdef CONFIG_FUNCTION_GRAPH_TRACER
-/*
- * NOTE: Do not move either ftrace_graph_call or ftrace_caller
- * as this will affect the calculation of GRAPH_INSN_OFFSET.
- */
-	.globl ftrace_graph_call
-ftrace_graph_call:
-	mov.l	.Lskip_trace, r0
-	jmp	@r0
-	 nop
-
-	.align 2
-.Lskip_trace:
-	.long	skip_trace
-#endif /* CONFIG_FUNCTION_GRAPH_TRACER */
-
-	.globl ftrace_caller
-ftrace_caller:
-	MCOUNT_ENTER()
-
-	.globl ftrace_call
-ftrace_call:
-	mov.l	.Lftrace_stub, r6
-	jsr	@r6
-	 nop
-
-#ifdef CONFIG_FUNCTION_GRAPH_TRACER
-	bra	ftrace_graph_call
-	 nop
-#else
-	MCOUNT_LEAVE()
-#endif /* CONFIG_FUNCTION_GRAPH_TRACER */
-#endif /* CONFIG_DYNAMIC_FTRACE */
-
-	.align 2
-
-/*
- * NOTE: From here on the locations of the .Lftrace_stub label and
- * ftrace_stub itself are fixed. Adding additional data here will skew
- * the displacement for the memory table and break the block replacement.
- * Place new labels either after the ftrace_stub body, or before
- * ftrace_caller. You have been warned.
- */
-.Lftrace_stub:
-	.long	ftrace_stub
-
-	.globl	ftrace_stub
-ftrace_stub:
-	rts
-	 nop
-
-#ifdef CONFIG_FUNCTION_GRAPH_TRACER
-	.globl	ftrace_graph_caller
-ftrace_graph_caller:
-	mov.l	2f, r1
-	jmp	@r1
-	 nop
-1:
-	/*
-	 * MCOUNT_ENTER() pushed 5 registers onto the stack, so
-	 * the stack address containing our return address is
-	 * r15 + 20.
-	 */
-	mov	#20, r0
-	add	r15, r0
-	mov	r0, r4
-
-	mov.l	.Lprepare_ftrace_return, r0
-	jsr	@r0
-	 nop
-
-	MCOUNT_LEAVE()
-
-	.align 2
-2:	.long	skip_trace
-.Lprepare_ftrace_return:
-	.long	prepare_ftrace_return
-
-	.globl	return_to_handler
-return_to_handler:
-	/*
-	 * Save the return values.
-	 */
-	mov.l	r0, @-r15
-	mov.l	r1, @-r15
-
-	mov	#0, r4
-
-	mov.l	.Lftrace_return_to_handler, r0
-	jsr	@r0
-	 nop
-
-	/*
-	 * The return value from ftrace_return_handler has the real
-	 * address that we should return to.
-	 */
-	lds	r0, pr
-	mov.l	@r15+, r1
-	rts
-	 mov.l	@r15+, r0
-
-
-	.align 2
-.Lftrace_return_to_handler:
-	.long	ftrace_return_to_handler
-#endif /* CONFIG_FUNCTION_GRAPH_TRACER */
-#endif /* CONFIG_FUNCTION_TRACER */
-
-#ifdef CONFIG_STACK_DEBUG
-	.globl	stack_panic
-stack_panic:
-	mov.l	.Ldump_stack, r0
-	jsr	@r0
-	 nop
-
-	mov.l	.Lpanic, r0
-	jsr	@r0
-	 mov.l	.Lpanic_s, r4
-
-	rts
-	 nop
-
-	.align 2
-.L_init_thread_union:
-	.long	init_thread_union
-.L_ebss:
-	.long	__bss_stop
-.Lpanic:
-	.long	panic
-.Lpanic_s:
-	.long	.Lpanic_str
-.Ldump_stack:
-	.long	dump_stack
-
-	.section	.rodata
-	.align 2
-.Lpanic_str:
-	.string "Stack error"
-#endif /* CONFIG_STACK_DEBUG */
diff --git a/arch/sh/lib/memchr.S b/arch/sh/lib/memchr.S
deleted file mode 100644
index 8ded104077aa32..00000000000000
--- a/arch/sh/lib/memchr.S
+++ /dev/null
@@ -1,27 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/* $Id: memchr.S,v 1.1 2000/04/14 16:49:01 mjd Exp $
- *
- * "memchr" implementation of SuperH
- *
- * Copyright (C) 1999  Niibe Yutaka
- *
- */
-
-/*
- * void *memchr(const void *s, int c, size_t n);
- */
-
-#include <linux/linkage.h>
-ENTRY(memchr)
-	tst	r6,r6
-	bt/s	2f
-	 exts.b	r5,r5
-1:	mov.b	@r4,r1
-	cmp/eq	r1,r5
-	bt/s	3f
-	 dt	r6
-	bf/s	1b
-	 add	#1,r4
-2:	mov	#0,r4
-3:	rts
-	 mov	r4,r0
diff --git a/arch/sh/lib/memcpy-sh4.S b/arch/sh/lib/memcpy-sh4.S
deleted file mode 100644
index a2435c0f6302ff..00000000000000
--- a/arch/sh/lib/memcpy-sh4.S
+++ /dev/null
@@ -1,800 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * "memcpy" implementation of SuperH
- *
- * Copyright (C) 1999  Niibe Yutaka
- * Copyright (c) 2002  STMicroelectronics Ltd
- *   Modified from memcpy.S and micro-optimised for SH4
- *   Stuart Menefy (stuart.menefy@st.com)
- *
- */
-#include <linux/linkage.h>
-
-/*
- * void *memcpy(void *dst, const void *src, size_t n);
- *
- * It is assumed that there is no overlap between src and dst.
- * If there is an overlap, then the results are undefined.
- */
-
-	!
-	!	GHIJ KLMN OPQR -->  ...G HIJK LMNO PQR.
-	!
-
-	! Size is 16 or greater, and may have trailing bytes
-
-	.balign	32
-.Lcase1:
-	! Read a long word and write a long word at once
-	! At the start of each iteration, r7 contains last long load
-	add	#-1,r5		!  79 EX
-	mov	r4,r2		!   5 MT (0 cycles latency)
-
-	mov.l	@(r0,r5),r7	!  21 LS (2 cycles latency)
-	add	#-4,r5		!  50 EX
-
-	add	#7,r2		!  79 EX
-	!
-#ifdef CONFIG_CPU_LITTLE_ENDIAN
-	! 6 cycles, 4 bytes per iteration
-3:	mov.l	@(r0,r5),r1	!  21 LS (latency=2)	! NMLK
-	mov	r7, r3		!   5 MT (latency=0)	! RQPO
-
-	cmp/hi	r2,r0		!  57 MT
-	shll16	r3		! 103 EX
-
-	mov	r1,r6		!   5 MT (latency=0)
-	shll8	r3		! 102 EX		! Oxxx
-
-	shlr8	r6		! 106 EX		! xNML
-	mov	r1, r7		!   5 MT (latency=0)
-
-	or	r6,r3		!  82 EX		! ONML
-	bt/s	3b		! 109 BR
-
-	 mov.l	r3,@-r0		!  30 LS
-#else
-3:	mov.l	@(r0,r5),r1	!  21 LS (latency=2)	! KLMN
-	mov	r7,r3		!   5 MT (latency=0)	! OPQR
-
-	cmp/hi	r2,r0		!  57 MT
-	shlr16	r3		! 107 EX
-
-	shlr8	r3		! 106 EX		! xxxO
-	mov	r1,r6		!   5 MT (latency=0)
-
-	shll8	r6		! 102 EX		! LMNx
-	mov	r1,r7		!   5 MT (latency=0)
-
-	or	r6,r3		!  82 EX		! LMNO
-	bt/s	3b		! 109 BR
-
-	 mov.l	r3,@-r0		!  30 LS
-#endif
-	! Finally, copy a byte at once, if necessary
-
-	add	#4,r5		!  50 EX
-	cmp/eq	r4,r0		!  54 MT
-
-	add	#-6,r2		!  50 EX
-	bt	9f		! 109 BR
-
-8:	cmp/hi	r2,r0		!  57 MT
-	mov.b	@(r0,r5),r1	!  20 LS (latency=2)
-
-	bt/s	8b		! 109 BR
-
-	 mov.b	r1,@-r0		!  29 LS
-
-9:	rts
-	 nop
-
-
-	!
-	!	GHIJ KLMN OPQR -->  .GHI JKLM NOPQ R...
-	!
-
-	! Size is 16 or greater, and may have trailing bytes
-
-	.balign	32
-.Lcase3:
-	! Read a long word and write a long word at once
-	! At the start of each iteration, r7 contains last long load
-	add	#-3,r5		! 79 EX
-	mov	r4,r2		!  5 MT (0 cycles latency)
-
-	mov.l	@(r0,r5),r7	! 21 LS (2 cycles latency)
-	add	#-4,r5		! 50 EX
-
-	add	#7,r2		!  79 EX
-	!
-#ifdef CONFIG_CPU_LITTLE_ENDIAN
-	! 6 cycles, 4 bytes per iteration
-3:	mov.l	@(r0,r5),r1	!  21 LS (latency=2)	! NMLK
-	mov	r7, r3		!   5 MT (latency=0)	! RQPO
-
-	cmp/hi	r2,r0		!  57 MT
-	shll8	r3		! 102 EX		! QPOx
-
-	mov	r1,r6		!   5 MT (latency=0)
-	shlr16	r6		! 107 EX
-
-	shlr8	r6		! 106 EX		! xxxN
-	mov	r1, r7		!   5 MT (latency=0)
-
-	or	r6,r3		!  82 EX		! QPON
-	bt/s	3b		! 109 BR
-
-	 mov.l	r3,@-r0		!  30 LS
-#else
-3:	mov	r7,r3		! OPQR
-	shlr8	r3		! xOPQ
-	mov.l	@(r0,r5),r7	! KLMN
-	mov	r7,r6
-	shll16	r6
-	shll8	r6		! Nxxx
-	or	r6,r3		! NOPQ
-	cmp/hi	r2,r0
-	bt/s	3b
-	 mov.l	r3,@-r0
-#endif
-
-	! Finally, copy a byte at once, if necessary
-
-	add	#6,r5		!  50 EX
-	cmp/eq	r4,r0		!  54 MT
-
-	add	#-6,r2		!  50 EX
-	bt	9f		! 109 BR
-
-8:	cmp/hi	r2,r0		!  57 MT
-	mov.b	@(r0,r5),r1	!  20 LS (latency=2)
-
-	bt/s	8b		! 109 BR
-
-	 mov.b	r1,@-r0		!  29 LS
-
-9:	rts
-	 nop
-
-ENTRY(memcpy)
-
-	! Calculate the invariants which will be used in the remainder
-	! of the code:
-	!
-	!      r4   -->  [ ...  ] DST             [ ...  ] SRC
-	!	         [ ...  ]                 [ ...  ]
-	!	           :                        :
-	!      r0   -->  [ ...  ]       r0+r5 --> [ ...  ]
-	!
-	!
-
-	! Short circuit the common case of src, dst and len being 32 bit aligned
-	! and test for zero length move
-
-	mov	r6, r0		!   5 MT (0 cycle latency)
-	or	r4, r0		!  82 EX
-
-	or	r5, r0		!  82 EX
-	tst	r6, r6		!  86 MT
-
-	bt/s	99f		! 111 BR		(zero len)
-	 tst	#3, r0		!  87 MT
-
-	mov	r4, r0		!   5 MT (0 cycle latency)
-	add	r6, r0		!  49 EX
-
-	mov	#16, r1		!   6 EX
-	bt/s	.Lcase00	! 111 BR		(aligned)
-
-	 sub	r4, r5		!  75 EX
-
-	! Arguments are not nicely long word aligned or zero len.
-	! Check for small copies, and if so do a simple byte at a time copy.
-	!
-	! Deciding on an exact value of 'small' is not easy, as the point at which
-	! using the optimised routines become worthwhile varies (these are the
-	! cycle counts for differnet sizes using byte-at-a-time vs. optimised):
-	!	size	byte-at-time	long	word	byte
-	!	16	42		39-40	46-50	50-55
-	!	24	58		43-44	54-58	62-67
-	!	36	82		49-50	66-70	80-85
-	! However the penalty for getting it 'wrong' is much higher for long word
-	! aligned data (and this is more common), so use a value of 16.
-
-	cmp/gt	r6,r1		!  56 MT
-
-	add	#-1,r5		!  50 EX
-	bf/s	6f		! 108 BR		(not small)
-
-	 mov	r5, r3		!   5 MT (latency=0)
-	shlr	r6		! 104 EX
-
-	mov.b	@(r0,r5),r1	!  20 LS (latency=2)
-	bf/s	4f		! 111 BR
-
-	 add	#-1,r3		!  50 EX
-	tst	r6, r6		!  86 MT
-
-	bt/s	98f		! 110 BR
-	 mov.b	r1,@-r0		!  29 LS
-
-	! 4 cycles, 2 bytes per iteration
-3:	mov.b	@(r0,r5),r1	!  20 LS (latency=2)
-
-4:	mov.b	@(r0,r3),r2	!  20 LS (latency=2)
-	dt	r6		!  67 EX
-
-	mov.b	r1,@-r0		!  29 LS
-	bf/s	3b		! 111 BR
-
-	 mov.b	r2,@-r0		!  29 LS
-98:
-	rts
-	 nop
-
-99:	rts
-	 mov	r4, r0
-
-	! Size is not small, so its worthwhile looking for optimisations.
-	! First align destination to a long word boundary.
-	!
-	! r5 = normal value -1
-
-6:	tst	#3, r0		!  87 MT
-        mov	#3, r3		!   6 EX
-
-	bt/s	2f		! 111 BR
-	 and	r0,r3		!  78 EX
-
-	! 3 cycles, 1 byte per iteration
-1:	dt	r3		!  67 EX
-	mov.b	@(r0,r5),r1	!  19 LS (latency=2)
-
-	add	#-1, r6		!  79 EX
-	bf/s	1b		! 109 BR
-
-	 mov.b	r1,@-r0		!  28 LS
-
-2:	add	#1, r5		!  79 EX
-
-	! Now select the appropriate bulk transfer code based on relative
-	! alignment of src and dst.
-
-	mov	r0, r3		!   5 MT (latency=0)
-
-	mov	r5, r0		!   5 MT (latency=0)
-	tst	#1, r0		!  87 MT
-
-	bf/s	1f		! 111 BR
-	 mov	#64, r7		!   6 EX
-
-	! bit 0 clear
-
-	cmp/ge	r7, r6		!  55 MT
-
-	bt/s	2f		! 111 BR
-	 tst	#2, r0		!  87 MT
-
-	! small
-	bt/s	.Lcase0
-	 mov	r3, r0
-
-	bra	.Lcase2
-	 nop
-
-	! big
-2:	bt/s	.Lcase0b
-	 mov	r3, r0
-
-	bra	.Lcase2b
-	 nop
-
-	! bit 0 set
-1:	tst	#2, r0		! 87 MT
-
-	bt/s	.Lcase1
-	 mov	r3, r0
-
-	bra	.Lcase3
-	 nop
-
-
-	!
-	!	GHIJ KLMN OPQR -->  GHIJ KLMN OPQR
-	!
-
-	! src, dst and size are all long word aligned
-	! size is non-zero
-
-	.balign	32
-.Lcase00:
-	mov	#64, r1		!   6 EX
-	mov	r5, r3		!   5 MT (latency=0)
-
-	cmp/gt	r6, r1		!  56 MT
-	add	#-4, r5		!  50 EX
-
-	bf	.Lcase00b	! 108 BR		(big loop)
-	shlr2	r6		! 105 EX
-
-	shlr	r6		! 104 EX
-	mov.l	@(r0, r5), r1	!  21 LS (latency=2)
-
-	bf/s	4f		! 111 BR
-	 add	#-8, r3		!  50 EX
-
-	tst	r6, r6		!  86 MT
-	bt/s	5f		! 110 BR
-
-	 mov.l	r1,@-r0		!  30 LS
-
-	! 4 cycles, 2 long words per iteration
-3:	mov.l	@(r0, r5), r1	!  21 LS (latency=2)
-
-4:	mov.l	@(r0, r3), r2	!  21 LS (latency=2)
-	dt	r6		!  67 EX
-
-	mov.l	r1, @-r0	!  30 LS
-	bf/s	3b		! 109 BR
-
-	 mov.l	r2, @-r0	!  30 LS
-
-5:	rts
-	 nop
-
-
-	! Size is 16 or greater and less than 64, but may have trailing bytes
-
-	.balign	32
-.Lcase0:
-	add	#-4, r5		!  50 EX
-	mov	r4, r7		!   5 MT (latency=0)
-
-	mov.l	@(r0, r5), r1	!  21 LS (latency=2)
-	mov	#4, r2		!   6 EX
-
-	add	#11, r7		!  50 EX
-	tst	r2, r6		!  86 MT
-
-	mov	r5, r3		!   5 MT (latency=0)
-	bt/s	4f		! 111 BR
-
-	 add	#-4, r3		!  50 EX
-	mov.l	r1,@-r0		!  30 LS
-
-	! 4 cycles, 2 long words per iteration
-3:	mov.l	@(r0, r5), r1	!  21 LS (latency=2)
-
-4:	mov.l	@(r0, r3), r2	!  21 LS (latency=2)
-	cmp/hi	r7, r0
-
-	mov.l	r1, @-r0	!  30 LS
-	bt/s	3b		! 109 BR
-
-	 mov.l	r2, @-r0	!  30 LS
-
-	! Copy the final 0-3 bytes
-
-	add	#3,r5		!  50 EX
-
-	cmp/eq	r0, r4		!  54 MT
-	add	#-10, r7	!  50 EX
-
-	bt	9f		! 110 BR
-
-	! 3 cycles, 1 byte per iteration
-1:	mov.b	@(r0,r5),r1	!  19 LS
-	cmp/hi	r7,r0		!  57 MT
-
-	bt/s	1b		! 111 BR
-	 mov.b	r1,@-r0		!  28 LS
-
-9:	rts
-	 nop
-
-	! Size is at least 64 bytes, so will be going round the big loop at least once.
-	!
-	!   r2 = rounded up r4
-	!   r3 = rounded down r0
-
-	.balign	32
-.Lcase0b:
-	add	#-4, r5		!  50 EX
-
-.Lcase00b:
-	mov	r0, r3		!   5 MT (latency=0)
-	mov	#(~0x1f), r1	!   6 EX
-
-	and	r1, r3		!  78 EX
-	mov	r4, r2		!   5 MT (latency=0)
-
-	cmp/eq	r3, r0		!  54 MT
-	add	#0x1f, r2	!  50 EX
-
-	bt/s	1f		! 110 BR
-	 and	r1, r2		!  78 EX
-
-	! copy initial words until cache line aligned
-
-	mov.l	@(r0, r5), r1	!  21 LS (latency=2)
-	tst	#4, r0		!  87 MT
-
-	mov	r5, r6		!   5 MT (latency=0)
-	add	#-4, r6		!  50 EX
-
-	bt/s	4f		! 111 BR
-	 add	#8, r3		!  50 EX
-
-	tst	#0x18, r0	!  87 MT
-
-	bt/s	1f		! 109 BR
-	 mov.l	r1,@-r0		!  30 LS
-
-	! 4 cycles, 2 long words per iteration
-3:	mov.l	@(r0, r5), r1	!  21 LS (latency=2)
-
-4:	mov.l	@(r0, r6), r7	!  21 LS (latency=2)
-	cmp/eq	r3, r0		!  54 MT
-
-	mov.l	r1, @-r0	!  30 LS
-	bf/s	3b		! 109 BR
-
-	 mov.l	r7, @-r0	!  30 LS
-
-	! Copy the cache line aligned blocks
-	!
-	! In use: r0, r2, r4, r5
-	! Scratch: r1, r3, r6, r7
-	!
-	! We could do this with the four scratch registers, but if src
-	! and dest hit the same cache line, this will thrash, so make
-	! use of additional registers.
-	!
-	! We also need r0 as a temporary (for movca), so 'undo' the invariant:
-	!   r5:	 src (was r0+r5)
-	!   r1:	 dest (was r0)
-	! this can be reversed at the end, so we don't need to save any extra
-	! state.
-	!
-1:	mov.l	r8, @-r15	!  30 LS
-	add	r0, r5		!  49 EX
-
-	mov.l	r9, @-r15	!  30 LS
-	mov	r0, r1		!   5 MT (latency=0)
-
-	mov.l	r10, @-r15	!  30 LS
-	add	#-0x1c, r5	!  50 EX
-
-	mov.l	r11, @-r15	!  30 LS
-
-	! 16 cycles, 32 bytes per iteration
-2:	mov.l	@(0x00,r5),r0	! 18 LS (latency=2)
-	add	#-0x20, r1	! 50 EX
-	mov.l	@(0x04,r5),r3	! 18 LS (latency=2)
-	mov.l	@(0x08,r5),r6	! 18 LS (latency=2)
-	mov.l	@(0x0c,r5),r7	! 18 LS (latency=2)
-	mov.l	@(0x10,r5),r8	! 18 LS (latency=2)
-	mov.l	@(0x14,r5),r9	! 18 LS (latency=2)
-	mov.l	@(0x18,r5),r10	! 18 LS (latency=2)
-	mov.l	@(0x1c,r5),r11	! 18 LS (latency=2)
-	movca.l	r0,@r1		! 40 LS (latency=3-7)
-	mov.l	r3,@(0x04,r1)	! 33 LS
-	mov.l	r6,@(0x08,r1)	! 33 LS
-	mov.l	r7,@(0x0c,r1)	! 33 LS
-
-	mov.l	r8,@(0x10,r1)	! 33 LS
-	add	#-0x20, r5	! 50 EX
-
-	mov.l	r9,@(0x14,r1)	! 33 LS
-	cmp/eq	r2,r1		! 54 MT
-
-	mov.l	r10,@(0x18,r1)	!  33 LS
-	bf/s	2b		! 109 BR
-
-	 mov.l	r11,@(0x1c,r1)	!  33 LS
-
-	mov	r1, r0		!   5 MT (latency=0)
-
-	mov.l	@r15+, r11	!  15 LS
-	sub	r1, r5		!  75 EX
-
-	mov.l	@r15+, r10	!  15 LS
-	cmp/eq	r4, r0		!  54 MT
-
-	bf/s	1f		! 109 BR
-	 mov.l	 @r15+, r9	!  15 LS
-
-	rts
-1:	 mov.l	@r15+, r8	!  15 LS
-	sub	r4, r1		!  75 EX		(len remaining)
-
-	! number of trailing bytes is non-zero
-	!
-	! invariants restored (r5 already decremented by 4)
-	! also r1=num bytes remaining
-
-	mov	#4, r2		!   6 EX
-	mov	r4, r7		!   5 MT (latency=0)
-
-	add	#0x1c, r5	!  50 EX		(back to -4)
-	cmp/hs	r2, r1		!  58 MT
-
-	bf/s	5f		! 108 BR
-	 add	 #11, r7	!  50 EX
-
-	mov.l	@(r0, r5), r6	!  21 LS (latency=2)
-	tst	r2, r1		!  86 MT
-
-	mov	r5, r3		!   5 MT (latency=0)
-	bt/s	4f		! 111 BR
-
-	 add	#-4, r3		!  50 EX
-	cmp/hs	r2, r1		!  58 MT
-
-	bt/s	5f		! 111 BR
-	 mov.l	r6,@-r0		!  30 LS
-
-	! 4 cycles, 2 long words per iteration
-3:	mov.l	@(r0, r5), r6	!  21 LS (latency=2)
-
-4:	mov.l	@(r0, r3), r2	!  21 LS (latency=2)
-	cmp/hi	r7, r0
-
-	mov.l	r6, @-r0	!  30 LS
-	bt/s	3b		! 109 BR
-
-	 mov.l	r2, @-r0	!  30 LS
-
-	! Copy the final 0-3 bytes
-
-5:	cmp/eq	r0, r4		!  54 MT
-	add	#-10, r7	!  50 EX
-
-	bt	9f		! 110 BR
-	add	#3,r5		!  50 EX
-
-	! 3 cycles, 1 byte per iteration
-1:	mov.b	@(r0,r5),r1	!  19 LS
-	cmp/hi	r7,r0		!  57 MT
-
-	bt/s	1b		! 111 BR
-	 mov.b	r1,@-r0		!  28 LS
-
-9:	rts
-	 nop
-
-	!
-	!	GHIJ KLMN OPQR -->  ..GH IJKL MNOP QR..
-	!
-
-	.balign	32
-.Lcase2:
-	! Size is 16 or greater and less then 64, but may have trailing bytes
-
-2:	mov	r5, r6		!   5 MT (latency=0)
-	add	#-2,r5		!  50 EX
-
-	mov	r4,r2		!   5 MT (latency=0)
-	add	#-4,r6		!  50 EX
-
-	add	#7,r2		!  50 EX
-3:	mov.w	@(r0,r5),r1	!  20 LS (latency=2)
-
-	mov.w	@(r0,r6),r3	!  20 LS (latency=2)
-	cmp/hi	r2,r0		!  57 MT
-
-	mov.w	r1,@-r0		!  29 LS
-	bt/s	3b		! 111 BR
-
-	 mov.w	r3,@-r0		!  29 LS
-
-	bra	10f
-	 nop
-
-
-	.balign	32
-.Lcase2b:
-	! Size is at least 64 bytes, so will be going round the big loop at least once.
-	!
-	!   r2 = rounded up r4
-	!   r3 = rounded down r0
-
-	mov	r0, r3		!   5 MT (latency=0)
-	mov	#(~0x1f), r1	!   6 EX
-
-	and	r1, r3		!  78 EX
-	mov	r4, r2		!   5 MT (latency=0)
-
-	cmp/eq	r3, r0		!  54 MT
-	add	#0x1f, r2	!  50 EX
-
-	add	#-2, r5		!  50 EX
-	bt/s	1f		! 110 BR
-	 and	r1, r2		!  78 EX
-
-	! Copy a short word one at a time until we are cache line aligned
-	!   Normal values: r0, r2, r3, r4
-	!   Unused: r1, r6, r7
-	!   Mod: r5 (=r5-2)
-	!
-	add	#2, r3		!  50 EX
-
-2:	mov.w	@(r0,r5),r1	!  20 LS (latency=2)
-	cmp/eq	r3,r0		!  54 MT
-
-	bf/s	2b		! 111 BR
-
-	 mov.w	r1,@-r0		!  29 LS
-
-	! Copy the cache line aligned blocks
-	!
-	! In use: r0, r2, r4, r5 (=r5-2)
-	! Scratch: r1, r3, r6, r7
-	!
-	! We could do this with the four scratch registers, but if src
-	! and dest hit the same cache line, this will thrash, so make
-	! use of additional registers.
-	!
-	! We also need r0 as a temporary (for movca), so 'undo' the invariant:
-	!   r5:	 src (was r0+r5)
-	!   r1:	 dest (was r0)
-	! this can be reversed at the end, so we don't need to save any extra
-	! state.
-	!
-1:	mov.l	r8, @-r15	!  30 LS
-	add	r0, r5		!  49 EX
-
-	mov.l	r9, @-r15	!  30 LS
-	mov	r0, r1		!   5 MT (latency=0)
-
-	mov.l	r10, @-r15	!  30 LS
-	add	#-0x1e, r5	!  50 EX
-
-	mov.l	r11, @-r15	!  30 LS
-
-	mov.l	r12, @-r15	!  30 LS
-
-	! 17 cycles, 32 bytes per iteration
-#ifdef CONFIG_CPU_LITTLE_ENDIAN
-2:	mov.w	@r5+, r0	!  14 LS (latency=2)		..JI
-	add	#-0x20, r1	!  50 EX
-
-	mov.l	@r5+, r3	!  15 LS (latency=2)		NMLK
-
-	mov.l	@r5+, r6	!  15 LS (latency=2)		RQPO
-	shll16	r0		! 103 EX			JI..
-
-	mov.l	@r5+, r7	!  15 LS (latency=2)
-	xtrct	r3, r0		!  48 EX			LKJI
-
-	mov.l	@r5+, r8	!  15 LS (latency=2)
-	xtrct	r6, r3		!  48 EX			PONM
-
-	mov.l	@r5+, r9	!  15 LS (latency=2)
-	xtrct	r7, r6		!  48 EX
-
-	mov.l	@r5+, r10	!  15 LS (latency=2)
-	xtrct	r8, r7		!  48 EX
-
-	mov.l	@r5+, r11	!  15 LS (latency=2)
-	xtrct	r9, r8		!  48 EX
-
-	mov.w	@r5+, r12	!  15 LS (latency=2)
-	xtrct	r10, r9		!  48 EX
-
-	movca.l	r0,@r1		!  40 LS (latency=3-7)
-	xtrct	r11, r10	!  48 EX
-
-	mov.l	r3, @(0x04,r1)	!  33 LS
-	xtrct	r12, r11	!  48 EX
-
-	mov.l	r6, @(0x08,r1)	!  33 LS
-
-	mov.l	r7, @(0x0c,r1)	!  33 LS
-
-	mov.l	r8, @(0x10,r1)	!  33 LS
-	add	#-0x40, r5	!  50 EX
-
-	mov.l	r9, @(0x14,r1)	!  33 LS
-	cmp/eq	r2,r1		!  54 MT
-
-	mov.l	r10, @(0x18,r1)	!  33 LS
-	bf/s	2b		! 109 BR
-
-	 mov.l	r11, @(0x1c,r1)	!  33 LS
-#else
-2:	mov.w	@(0x1e,r5), r0	!  17 LS (latency=2)
-	add	#-2, r5		!  50 EX
-
-	mov.l	@(0x1c,r5), r3	!  18 LS (latency=2)
-	add	#-4, r1		!  50 EX
-
-	mov.l	@(0x18,r5), r6	!  18 LS (latency=2)
-	shll16	r0		! 103 EX
-
-	mov.l	@(0x14,r5), r7	!  18 LS (latency=2)
-	xtrct	r3, r0		!  48 EX
-
-	mov.l	@(0x10,r5), r8	!  18 LS (latency=2)
-	xtrct	r6, r3		!  48 EX
-
-	mov.l	@(0x0c,r5), r9	!  18 LS (latency=2)
-	xtrct	r7, r6		!  48 EX
-
-	mov.l	@(0x08,r5), r10	!  18 LS (latency=2)
-	xtrct	r8, r7		!  48 EX
-
-	mov.l	@(0x04,r5), r11	!  18 LS (latency=2)
-	xtrct	r9, r8		!  48 EX
-
-	mov.l   @(0x00,r5), r12 !  18 LS (latency=2)
-    	xtrct	r10, r9		!  48 EX
-
-	movca.l	r0,@r1		!  40 LS (latency=3-7)
-	add	#-0x1c, r1	!  50 EX
-
-	mov.l	r3, @(0x18,r1)	!  33 LS
-	xtrct	r11, r10	!  48 EX
-
-	mov.l	r6, @(0x14,r1)	!  33 LS
-	xtrct	r12, r11	!  48 EX
-
-	mov.l	r7, @(0x10,r1)	!  33 LS
-
-	mov.l	r8, @(0x0c,r1)	!  33 LS
-	add	#-0x1e, r5	!  50 EX
-
-	mov.l	r9, @(0x08,r1)	!  33 LS
-	cmp/eq	r2,r1		!  54 MT
-
-	mov.l	r10, @(0x04,r1)	!  33 LS
-	bf/s	2b		! 109 BR
-
-	 mov.l	r11, @(0x00,r1)	!  33 LS
-#endif
-
-	mov.l	@r15+, r12
-	mov	r1, r0		!   5 MT (latency=0)
-
-	mov.l	@r15+, r11	!  15 LS
-	sub	r1, r5		!  75 EX
-
-	mov.l	@r15+, r10	!  15 LS
-	cmp/eq	r4, r0		!  54 MT
-
-	bf/s	1f		! 109 BR
-	 mov.l	 @r15+, r9	!  15 LS
-
-	rts
-1:	 mov.l	@r15+, r8	!  15 LS
-
-	add	#0x1e, r5	!  50 EX
-
-	! Finish off a short word at a time
-	! r5 must be invariant - 2
-10:	mov	r4,r2		!   5 MT (latency=0)
-	add	#1,r2		!  50 EX
-
-	cmp/hi	r2, r0		!  57 MT
-	bf/s	1f		! 109 BR
-
-	 add	#2, r2		!  50 EX
-
-3:	mov.w	@(r0,r5),r1	!  20 LS
-	cmp/hi	r2,r0		!  57 MT
-
-	bt/s	3b		! 109 BR
-
-	 mov.w	r1,@-r0		!  29 LS
-1:
-
-	!
-	! Finally, copy the last byte if necessary
-	cmp/eq	r4,r0		!  54 MT
-	bt/s	9b
-	 add	#1,r5
-	mov.b	@(r0,r5),r1
-	rts
-	 mov.b	r1,@-r0
-
diff --git a/arch/sh/lib/memcpy.S b/arch/sh/lib/memcpy.S
deleted file mode 100644
index 08ab3062c4b27c..00000000000000
--- a/arch/sh/lib/memcpy.S
+++ /dev/null
@@ -1,228 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/* $Id: memcpy.S,v 1.3 2001/07/27 11:50:52 gniibe Exp $
- *
- * "memcpy" implementation of SuperH
- *
- * Copyright (C) 1999  Niibe Yutaka
- *
- */
-
-/*
- * void *memcpy(void *dst, const void *src, size_t n);
- * No overlap between the memory of DST and of SRC are assumed.
- */
-
-#include <linux/linkage.h>
-ENTRY(memcpy)
-	tst	r6,r6
-	bt/s	9f		! if n=0, do nothing
-	 mov	r4,r0
-	sub	r4,r5		! From here, r5 has the distance to r0
-	add	r6,r0		! From here, r0 points the end of copying point
-	mov	#12,r1
-	cmp/gt	r6,r1
-	bt/s	7f		! if it's too small, copy a byte at once
-	 add	#-1,r5
-	add	#1,r5
-	!			From here, r6 is free
-	!
-	!      r4   -->  [ ...  ] DST             [ ...  ] SRC
-	!	         [ ...  ]                 [ ...  ]
-	!	           :                        :
-	!      r0   -->  [ ...  ]       r0+r5 --> [ ...  ]
-	!
-	!
-	mov	r5,r1
-	mov	#3,r2
-	and	r2,r1
-	shll2	r1
-	mov	r0,r3		! Save the value on R0 to R3
-	mova	jmptable,r0
-	add	r1,r0
-	mov.l	@r0,r1
-	jmp	@r1
-	 mov	r3,r0		! and back to R0
-	.balign	4
-jmptable:
-	.long	case0
-	.long	case1
-	.long	case2
-	.long	case3
-
-	! copy a byte at once
-7:	mov	r4,r2
-	add	#1,r2
-8:
-	cmp/hi	r2,r0
-	mov.b	@(r0,r5),r1
-	bt/s	8b			! while (r0>r2)
-	 mov.b	r1,@-r0
-9:
-	rts
-	 nop
-
-case0:
-	!
-	!	GHIJ KLMN OPQR -->  GHIJ KLMN OPQR
-	!
-	! First, align to long word boundary
-	mov	r0,r3
-	and	r2,r3
-	tst	r3,r3
-	bt/s	2f
-	 add	#-4,r5
-	add	#3,r5
-1:	dt	r3
-	mov.b	@(r0,r5),r1
-	bf/s	1b
-	 mov.b	r1,@-r0
-	!
-	add	#-3,r5
-2:	! Second, copy a long word at once
-	mov	r4,r2
-	add	#7,r2
-3:	mov.l	@(r0,r5),r1
-	cmp/hi	r2,r0
-	bt/s	3b
-	 mov.l	r1,@-r0
-	!
-	! Third, copy a byte at once, if necessary
-	cmp/eq	r4,r0
-	bt/s	9b
-	 add	#3,r5
-	bra	8b
-	 add	#-6,r2
-
-case1:
-	!
-	!	GHIJ KLMN OPQR -->  ...G HIJK LMNO PQR.
-	!
-	! First, align to long word boundary
-	mov	r0,r3
-	and	r2,r3
-	tst	r3,r3
-	bt/s	2f
-	 add	#-1,r5
-1:	dt	r3
-	mov.b	@(r0,r5),r1
-	bf/s	1b
-	 mov.b	r1,@-r0
-	!
-2:	! Second, read a long word and write a long word at once
-	mov.l	@(r0,r5),r1
-	add	#-4,r5
-	mov	r4,r2
-	add	#7,r2
-	!
-#ifdef __LITTLE_ENDIAN__
-3:	mov	r1,r3		! RQPO
-	shll16	r3
-	shll8	r3		! Oxxx
-	mov.l	@(r0,r5),r1	! NMLK
-	mov	r1,r6
-	shlr8	r6		! xNML
-	or	r6,r3		! ONML
-	cmp/hi	r2,r0
-	bt/s	3b
-	 mov.l	r3,@-r0
-#else
-3:	mov	r1,r3		! OPQR
-	shlr16	r3
-	shlr8	r3		! xxxO
-	mov.l	@(r0,r5),r1	! KLMN
-	mov	r1,r6
-	shll8	r6		! LMNx
-	or	r6,r3		! LMNO
-	cmp/hi	r2,r0
-	bt/s	3b
-	 mov.l	r3,@-r0
-#endif
-	!
-	! Third, copy a byte at once, if necessary
-	cmp/eq	r4,r0
-	bt/s	9b
-	 add	#4,r5
-	bra	8b
-	 add	#-6,r2
-
-case2:
-	!
-	!	GHIJ KLMN OPQR -->  ..GH IJKL MNOP QR..
-	!
-	! First, align to word boundary
-	tst	#1,r0
-	bt/s	2f
-	 add	#-1,r5
-	mov.b	@(r0,r5),r1
-	mov.b	r1,@-r0
-	!
-2:	! Second, read a word and write a word at once
-	add	#-1,r5
-	mov	r4,r2
-	add	#3,r2
-	!
-3:	mov.w	@(r0,r5),r1
-	cmp/hi	r2,r0
-	bt/s	3b
-	 mov.w	r1,@-r0
-	!
-	! Third, copy a byte at once, if necessary
-	cmp/eq	r4,r0
-	bt/s	9b
-	 add	#1,r5
-	mov.b	@(r0,r5),r1
-	rts
-	 mov.b	r1,@-r0
-
-case3:
-	!
-	!	GHIJ KLMN OPQR -->  .GHI JKLM NOPQ R...
-	!
-	! First, align to long word boundary
-	mov	r0,r3
-	and	r2,r3
-	tst	r3,r3
-	bt/s	2f
-	 add	#-1,r5
-1:	dt	r3
-	mov.b	@(r0,r5),r1
-	bf/s	1b
-	 mov.b	r1,@-r0
-	!
-2:	! Second, read a long word and write a long word at once
-	add	#-2,r5
-	mov.l	@(r0,r5),r1
-	add	#-4,r5
-	mov	r4,r2
-	add	#7,r2
-	!
-#ifdef __LITTLE_ENDIAN__
-3:	mov	r1,r3		! RQPO
-	shll8	r3		! QPOx
-	mov.l	@(r0,r5),r1	! NMLK
-	mov	r1,r6
-	shlr16	r6
-	shlr8	r6		! xxxN
-	or	r6,r3		! QPON
-	cmp/hi	r2,r0
-	bt/s	3b
-	 mov.l	r3,@-r0
-#else
-3:	mov	r1,r3		! OPQR
-	shlr8	r3		! xOPQ
-	mov.l	@(r0,r5),r1	! KLMN
-	mov	r1,r6
-	shll16	r6
-	shll8	r6		! Nxxx
-	or	r6,r3		! NOPQ
-	cmp/hi	r2,r0
-	bt/s	3b
-	 mov.l	r3,@-r0
-#endif
-	!
-	! Third, copy a byte at once, if necessary
-	cmp/eq	r4,r0
-	bt/s	9b
-	 add	#6,r5
-	bra	8b
-	 add	#-6,r2
diff --git a/arch/sh/lib/memmove.S b/arch/sh/lib/memmove.S
deleted file mode 100644
index bdca321814a95a..00000000000000
--- a/arch/sh/lib/memmove.S
+++ /dev/null
@@ -1,255 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/* $Id: memmove.S,v 1.2 2001/07/27 11:51:09 gniibe Exp $
- *
- * "memmove" implementation of SuperH
- *
- * Copyright (C) 1999  Niibe Yutaka
- *
- */
-
-/*
- * void *memmove(void *dst, const void *src, size_t n);
- * The memory areas may overlap.
- */
-
-#include <linux/linkage.h>
-ENTRY(memmove)
-	! if dest > src, call memcpy (it copies in decreasing order)
-	cmp/hi	r5,r4
-	bf	1f
-	mov.l	2f,r0
-	jmp	@r0
-	 nop
-	.balign 4
-2:	.long	memcpy
-1:
-	sub	r5,r4		! From here, r4 has the distance to r0
-	tst	r6,r6
-	bt/s	9f		! if n=0, do nothing
-	 mov	r5,r0
-	add	r6,r5
-	mov	#12,r1
-	cmp/gt	r6,r1
-	bt/s	8f		! if it's too small, copy a byte at once
-	 add	#-1,r4
-	add	#1,r4
-	!
-	!                [ ...  ] DST             [ ...  ] SRC
-	!	         [ ...  ]                 [ ...  ]
-	!	           :                        :
-	!      r0+r4-->  [ ...  ]       r0    --> [ ...  ]
-	!	           :                        :
-	!	         [ ...  ]                 [ ...  ]
-	!			        r5    -->
-	!
-	mov	r4,r1
-	mov	#3,r2
-	and	r2,r1
-	shll2	r1
-	mov	r0,r3		! Save the value on R0 to R3
-	mova	jmptable,r0
-	add	r1,r0
-	mov.l	@r0,r1
-	jmp	@r1
-	 mov	r3,r0		! and back to R0
-	.balign	4
-jmptable:
-	.long	case0
-	.long	case1
-	.long	case2
-	.long	case3
-
-	! copy a byte at once
-8:	mov.b	@r0+,r1
-	cmp/hs	r5,r0
-	bf/s	8b			! while (r0<r5)
-	 mov.b	r1,@(r0,r4)
-	add	#1,r4
-9:
-	add	r4,r0
-	rts
-	 sub	r6,r0
-
-case_none:
-	bra	8b
-	 add	#-1,r4
-
-case0:
-	!
-	!	GHIJ KLMN OPQR -->  GHIJ KLMN OPQR
-	!
-	! First, align to long word boundary
-	mov	r0,r3
-	and	r2,r3
-	tst	r3,r3
-	bt/s	2f
-	 add	#-1,r4
-	mov	#4,r2
-	sub	r3,r2
-1:	dt	r2
-	mov.b	@r0+,r1
-	bf/s	1b
-	 mov.b	r1,@(r0,r4)
-	!
-2:	! Second, copy a long word at once
-	add	#-3,r4
-	add	#-3,r5
-3:	mov.l	@r0+,r1
-	cmp/hs	r5,r0
-	bf/s	3b
-	 mov.l	r1,@(r0,r4)
-	add	#3,r5
-	!
-	! Third, copy a byte at once, if necessary
-	cmp/eq	r5,r0
-	bt/s	9b
-	 add	#4,r4
-	bra	8b
-	 add	#-1,r4
-
-case3:
-	!
-	!	GHIJ KLMN OPQR -->  ...G HIJK LMNO PQR.
-	!
-	! First, align to long word boundary
-	mov	r0,r3
-	and	r2,r3
-	tst	r3,r3
-	bt/s	2f
-	 add	#-1,r4
-	mov	#4,r2
-	sub	r3,r2
-1:	dt	r2
-	mov.b	@r0+,r1
-	bf/s	1b
-	 mov.b	r1,@(r0,r4)
-	!
-2:	! Second, read a long word and write a long word at once
-	add	#-2,r4
-	mov.l	@(r0,r4),r1
-	add	#-7,r5
-	add	#-4,r4
-	!
-#ifdef __LITTLE_ENDIAN__
-	shll8	r1
-3:	mov	r1,r3		! JIHG
-	shlr8	r3		! xJIH
-	mov.l	@r0+,r1		! NMLK
-	mov	r1,r2
-	shll16	r2
-	shll8	r2		! Kxxx
-	or	r2,r3		! KJIH
-	cmp/hs	r5,r0
-	bf/s	3b
-	 mov.l	r3,@(r0,r4)
-#else
-	shlr8	r1
-3:	mov	r1,r3		! GHIJ
-	shll8	r3		! HIJx
-	mov.l	@r0+,r1		! KLMN
-	mov	r1,r2
-	shlr16	r2
-	shlr8	r2		! xxxK
-	or	r2,r3		! HIJK
-	cmp/hs	r5,r0
-	bf/s	3b
-	 mov.l	r3,@(r0,r4)
-#endif
-	add	#7,r5
-	!
-	! Third, copy a byte at once, if necessary
-	cmp/eq	r5,r0
-	bt/s	9b
-	 add	#7,r4
-	add	#-3,r0
-	bra	8b
-	 add	#-1,r4
-
-case2:
-	!
-	!	GHIJ KLMN OPQR -->  ..GH IJKL MNOP QR..
-	!
-	! First, align to word boundary
-	tst	#1,r0
-	bt/s	2f
-	 add	#-1,r4
-	mov.b	@r0+,r1
-	mov.b	r1,@(r0,r4)
-	!
-2:	! Second, read a word and write a word at once
-	add	#-1,r4
-	add	#-1,r5
-	!
-3:	mov.w	@r0+,r1
-	cmp/hs	r5,r0
-	bf/s	3b
-	 mov.w	r1,@(r0,r4)
-	add	#1,r5
-	!
-	! Third, copy a byte at once, if necessary
-	cmp/eq	r5,r0
-	bt/s	9b
-	 add	#2,r4
-	mov.b	@r0,r1
-	mov.b	r1,@(r0,r4)
-	bra	9b
-	 add	#1,r0
-
-case1:
-	!
-	!	GHIJ KLMN OPQR -->  .GHI JKLM NOPQ R...
-	!
-	! First, align to long word boundary
-	mov	r0,r3
-	and	r2,r3
-	tst	r3,r3
-	bt/s	2f
-	 add	#-1,r4
-	mov	#4,r2
-	sub	r3,r2
-1:	dt	r2
-	mov.b	@r0+,r1
-	bf/s	1b
-	 mov.b	r1,@(r0,r4)
-	!
-2:	! Second, read a long word and write a long word at once
-	mov.l	@(r0,r4),r1
-	add	#-7,r5
-	add	#-4,r4
-	!
-#ifdef __LITTLE_ENDIAN__
-	shll16	r1
-	shll8	r1
-3:	mov	r1,r3		! JIHG
-	shlr16	r3
-	shlr8	r3		! xxxJ
-	mov.l	@r0+,r1		! NMLK
-	mov	r1,r2
-	shll8	r2		! MLKx
-	or	r2,r3		! MLKJ
-	cmp/hs	r5,r0
-	bf/s	3b
-	 mov.l	r3,@(r0,r4)
-#else
-	shlr16	r1
-	shlr8	r1
-3:	mov	r1,r3		! GHIJ
-	shll16	r3
-	shll8	r3		! Jxxx
-	mov.l	@r0+,r1		! KLMN
-	mov	r1,r2
-	shlr8	r2		! xKLM
-	or	r2,r3		! JKLM
-	cmp/hs	r5,r0
-	bf/s	3b		! while(r0<r5)
-	 mov.l	r3,@(r0,r4)
-#endif
-	add	#7,r5
-	!
-	! Third, copy a byte at once, if necessary
-	cmp/eq	r5,r0
-	bt/s	9b
-	 add	#5,r4
-	add	#-3,r0
-	bra	8b
-	 add	#-1,r4
diff --git a/arch/sh/lib/memset-sh4.S b/arch/sh/lib/memset-sh4.S
deleted file mode 100644
index 10649c4cdab8a4..00000000000000
--- a/arch/sh/lib/memset-sh4.S
+++ /dev/null
@@ -1,108 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * "memset" implementation for SH4
- *
- * Copyright (C) 1999  Niibe Yutaka
- * Copyright (c) 2009  STMicroelectronics Limited
- * Author: Stuart Menefy <stuart.menefy:st.com>
- */
-
-/*
- *            void *memset(void *s, int c, size_t n);
- */
-
-#include <linux/linkage.h>
-
-ENTRY(memset)
-	mov	#12,r0
-	add	r6,r4
-	cmp/gt	r6,r0
-	bt/s	40f		! if it's too small, set a byte at once
-	 mov	r4,r0
-	and	#3,r0
-	cmp/eq	#0,r0
-	bt/s	2f		! It's aligned
-	 sub	r0,r6
-1:
-	dt	r0
-	bf/s	1b
-	 mov.b	r5,@-r4
-2:				! make VVVV
-	extu.b	r5,r5
-	swap.b	r5,r0		!   V0
-	or	r0,r5		!   VV
-	swap.w	r5,r0		! VV00
-	or	r0,r5		! VVVV
-
-	! Check if enough bytes need to be copied to be worth the big loop
-	mov	#0x40, r0	! (MT)
-	cmp/gt	r6,r0		! (MT)  64 > len => slow loop
-
-	bt/s	22f
-	 mov	r6,r0
-
-	! align the dst to the cache block size if necessary
-	mov	r4, r3
-	mov	#~(0x1f), r1
-
-	and	r3, r1
-	cmp/eq	r3, r1
-
-	bt/s	11f		! dst is already aligned
-	 sub	r1, r3		! r3-r1 -> r3
-	shlr2	r3		! number of loops
-
-10:	mov.l	r5,@-r4
-	dt	r3
-	bf/s	10b
-	 add	#-4, r6
-
-11:	! dst is 32byte aligned
-	mov	r6,r2
-	mov	#-5,r0
-	shld	r0,r2		! number of loops
-
-	add	#-32, r4
-	mov	r5, r0
-12:
-	movca.l	r0,@r4
-	mov.l	r5,@(4, r4)
-	mov.l	r5,@(8, r4)
-	mov.l	r5,@(12,r4)
-	mov.l	r5,@(16,r4)
-	mov.l	r5,@(20,r4)
-	add	#-0x20, r6
-	mov.l	r5,@(24,r4)
-	dt	r2
-	mov.l	r5,@(28,r4)
-	bf/s	12b
-	 add	#-32, r4
-
-	add	#32, r4
-	mov	#8, r0
-	cmp/ge	r0, r6
-	bf	40f
-
-	mov	r6,r0
-22:
-	shlr2	r0
-	shlr	r0		! r0 = r6 >> 3
-3:
-	dt	r0
-	mov.l	r5,@-r4		! set 8-byte at once
-	bf/s	3b
-	 mov.l	r5,@-r4
-	!
-	mov	#7,r0
-	and	r0,r6
-
-	! fill bytes (length may be zero)
-40:	tst	r6,r6
-	bt	5f
-4:
-	dt	r6
-	bf/s	4b
-	 mov.b	r5,@-r4
-5:
-	rts
-	 mov	r4,r0
diff --git a/arch/sh/lib/memset.S b/arch/sh/lib/memset.S
deleted file mode 100644
index a6d5ec0bd9cf93..00000000000000
--- a/arch/sh/lib/memset.S
+++ /dev/null
@@ -1,59 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/* $Id: memset.S,v 1.1 2000/04/14 16:49:01 mjd Exp $
- *
- * "memset" implementation of SuperH
- *
- * Copyright (C) 1999  Niibe Yutaka
- *
- */
-
-/*
- *            void *memset(void *s, int c, size_t n);
- */
-
-#include <linux/linkage.h>
-
-ENTRY(memset)
-	tst	r6,r6
-	bt/s	5f		! if n=0, do nothing
-	 add	r6,r4
-	mov	#12,r0
-	cmp/gt	r6,r0
-	bt/s	4f		! if it's too small, set a byte at once
-	 mov	r4,r0
-	and	#3,r0
-	cmp/eq	#0,r0
-	bt/s	2f		! It's aligned
-	 sub	r0,r6
-1:
-	dt	r0
-	bf/s	1b
-	 mov.b	r5,@-r4
-2:				! make VVVV
-	extu.b	r5,r5
-	swap.b	r5,r0		!   V0
-	or	r0,r5		!   VV
-	swap.w	r5,r0		! VV00
-	or	r0,r5		! VVVV
-	!
-	mov	r6,r0
-	shlr2	r0
-	shlr	r0		! r0 = r6 >> 3
-3:
-	dt	r0
-	mov.l	r5,@-r4		! set 8-byte at once
-	bf/s	3b
-	 mov.l	r5,@-r4
-	!
-	mov	#7,r0
-	and	r0,r6
-	tst	r6,r6
-	bt	5f
-	! fill bytes
-4:
-	dt	r6
-	bf/s	4b
-	 mov.b	r5,@-r4
-5:
-	rts
-	 mov	r4,r0
diff --git a/arch/sh/lib/movmem.S b/arch/sh/lib/movmem.S
deleted file mode 100644
index 8ac54d6b38a1b9..00000000000000
--- a/arch/sh/lib/movmem.S
+++ /dev/null
@@ -1,217 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ WITH GCC-exception-2.0
-
-   Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
-   2004, 2005, 2006
-   Free Software Foundation, Inc.
-*/
-
-!! libgcc routines for the Renesas / SuperH SH CPUs.
-!! Contributed by Steve Chamberlain.
-!! sac@cygnus.com
-
-!! ashiftrt_r4_x, ___ashrsi3, ___ashlsi3, ___lshrsi3 routines
-!! recoded in assembly by Toshiyasu Morita
-!! tm@netcom.com
-
-/* SH2 optimizations for ___ashrsi3, ___ashlsi3, ___lshrsi3 and
-   ELF local label prefixes by J"orn Rennecke
-   amylaar@cygnus.com  */
-
-	.text
-	.balign	4
-	.global	__movmem
-	.global __movstr
-	.set __movstr, __movmem	
-	/* This would be a lot simpler if r6 contained the byte count
-	   minus 64, and we wouldn't be called here for a byte count of 64.  */
-__movmem:
-	sts.l	pr,@-r15
-	shll2	r6
-	bsr	__movmemSI52+2
-	mov.l	@(48,r5),r0
-	.balign	4
-movmem_loop: /* Reached with rts */
-	mov.l	@(60,r5),r0
-	add	#-64,r6
-	mov.l	r0,@(60,r4)
-	tst	r6,r6
-	mov.l	@(56,r5),r0
-	bt	movmem_done
-	mov.l	r0,@(56,r4)
-	cmp/pl	r6
-	mov.l	@(52,r5),r0
-	add	#64,r5
-	mov.l	r0,@(52,r4)
-	add	#64,r4
-	bt	__movmemSI52
-! done all the large groups, do the remainder
-! jump to movmem+
-	mova	__movmemSI4+4,r0
-	add	r6,r0
-	jmp	@r0
-movmem_done: ! share slot insn, works out aligned.
-	lds.l	@r15+,pr
-	mov.l	r0,@(56,r4)
-	mov.l	@(52,r5),r0
-	rts
-	mov.l	r0,@(52,r4)
-	.balign	4
-
-	.global	__movmemSI64
-	.global __movstrSI64
-	.set	__movstrSI64, __movmemSI64
-__movmemSI64:
-	mov.l	@(60,r5),r0
-	mov.l	r0,@(60,r4)
-	.global	__movmemSI60
-	.global __movstrSI60
-	.set	__movstrSI60, __movmemSI60
-__movmemSI60:
-	mov.l	@(56,r5),r0
-	mov.l	r0,@(56,r4)
-	.global	__movmemSI56
-	.global __movstrSI56
-	.set	__movstrSI56, __movmemSI56
-__movmemSI56:
-	mov.l	@(52,r5),r0
-	mov.l	r0,@(52,r4)
-	.global	__movmemSI52
-	.global __movstrSI52
-	.set	__movstrSI52, __movmemSI52
-__movmemSI52:
-	mov.l	@(48,r5),r0
-	mov.l	r0,@(48,r4)
-	.global	__movmemSI48
-	.global	__movstrSI48
-	.set	__movstrSI48, __movmemSI48
-__movmemSI48:
-	mov.l	@(44,r5),r0
-	mov.l	r0,@(44,r4)
-	.global	__movmemSI44
-	.global	__movstrSI44
-	.set	__movstrSI44, __movmemSI44
-__movmemSI44:
-	mov.l	@(40,r5),r0
-	mov.l	r0,@(40,r4)
-	.global	__movmemSI40
-	.global __movstrSI40
-	.set	__movstrSI40, __movmemSI40
-__movmemSI40:
-	mov.l	@(36,r5),r0
-	mov.l	r0,@(36,r4)
-	.global	__movmemSI36
-	.global	__movstrSI36
-	.set	__movstrSI36, __movmemSI36
-__movmemSI36:
-	mov.l	@(32,r5),r0
-	mov.l	r0,@(32,r4)
-	.global	__movmemSI32
-	.global	__movstrSI32
-	.set	__movstrSI32, __movmemSI32
-__movmemSI32:
-	mov.l	@(28,r5),r0
-	mov.l	r0,@(28,r4)
-	.global	__movmemSI28
-	.global	__movstrSI28
-	.set	__movstrSI28, __movmemSI28
-__movmemSI28:
-	mov.l	@(24,r5),r0
-	mov.l	r0,@(24,r4)
-	.global	__movmemSI24
-	.global	__movstrSI24
-	.set	__movstrSI24, __movmemSI24
-__movmemSI24:
-	mov.l	@(20,r5),r0
-	mov.l	r0,@(20,r4)
-	.global	__movmemSI20
-	.global	__movstrSI20
-	.set	__movstrSI20, __movmemSI20
-__movmemSI20:
-	mov.l	@(16,r5),r0
-	mov.l	r0,@(16,r4)
-	.global	__movmemSI16
-	.global	__movstrSI16
-	.set	__movstrSI16, __movmemSI16
-__movmemSI16:
-	mov.l	@(12,r5),r0
-	mov.l	r0,@(12,r4)
-	.global	__movmemSI12
-	.global	__movstrSI12
-	.set	__movstrSI12, __movmemSI12
-__movmemSI12:
-	mov.l	@(8,r5),r0
-	mov.l	r0,@(8,r4)
-	.global	__movmemSI8
-	.global	__movstrSI8
-	.set	__movstrSI8, __movmemSI8
-__movmemSI8:
-	mov.l	@(4,r5),r0
-	mov.l	r0,@(4,r4)
-	.global	__movmemSI4
-	.global	__movstrSI4
-	.set	__movstrSI4, __movmemSI4
-__movmemSI4:
-	mov.l	@(0,r5),r0
-	rts
-	mov.l	r0,@(0,r4)
-
-	.global	__movmem_i4_even
-	.global	__movstr_i4_even
-	.set	__movstr_i4_even, __movmem_i4_even
-
-	.global	__movmem_i4_odd
-	.global	__movstr_i4_odd
-	.set	__movstr_i4_odd, __movmem_i4_odd
-
-	.global	__movmemSI12_i4
-	.global	__movstrSI12_i4
-	.set	__movstrSI12_i4, __movmemSI12_i4
-
-	.p2align	5
-L_movmem_2mod4_end:
-	mov.l	r0,@(16,r4)
-	rts
-	mov.l	r1,@(20,r4)
-
-	.p2align	2
-
-__movmem_i4_even:
-	mov.l	@r5+,r0
-	bra	L_movmem_start_even
-	mov.l	@r5+,r1
-
-__movmem_i4_odd:
-	mov.l	@r5+,r1
-	add	#-4,r4
-	mov.l	@r5+,r2
-	mov.l	@r5+,r3
-	mov.l	r1,@(4,r4)
-	mov.l	r2,@(8,r4)
-
-L_movmem_loop:
-	mov.l	r3,@(12,r4)
-	dt	r6
-	mov.l	@r5+,r0
-	bt/s	L_movmem_2mod4_end
-	mov.l	@r5+,r1
-	add	#16,r4
-L_movmem_start_even:
-	mov.l	@r5+,r2
-	mov.l	@r5+,r3
-	mov.l	r0,@r4
-	dt	r6
-	mov.l	r1,@(4,r4)
-	bf/s	L_movmem_loop
-	mov.l	r2,@(8,r4)
-	rts
-	mov.l	r3,@(12,r4)
-
-	.p2align	4
-__movmemSI12_i4:
-	mov.l	@r5,r0
-	mov.l	@(4,r5),r1
-	mov.l	@(8,r5),r2
-	mov.l	r0,@r4
-	mov.l	r1,@(4,r4)
-	rts
-	mov.l	r2,@(8,r4)
diff --git a/arch/sh/lib/strlen.S b/arch/sh/lib/strlen.S
deleted file mode 100644
index 80ea53dd34f6dd..00000000000000
--- a/arch/sh/lib/strlen.S
+++ /dev/null
@@ -1,71 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/* $Id: strlen.S,v 1.2 2001/06/29 14:07:15 gniibe Exp $
- *
- * "strlen" implementation of SuperH
- *
- * Copyright (C) 1999  Kaz Kojima
- *
- */
-
-/* size_t strlen (const char *s)  */
-
-#include <linux/linkage.h>
-ENTRY(strlen)
-	mov	r4,r0
-	and	#3,r0
-	tst	r0,r0
-	bt/s	1f
-	 mov	#0,r2
-
-	add	#-1,r0
-	shll2	r0
-	shll	r0
-	braf	r0
-	 nop
-
-	mov.b	@r4+,r1
-	tst	r1,r1
-	bt	8f
-	add	#1,r2
-
-	mov.b	@r4+,r1
-	tst	r1,r1
-	bt	8f
-	add	#1,r2
-
-	mov.b	@r4+,r1
-	tst	r1,r1
-	bt	8f
-	add	#1,r2
-
-1:
-	mov	#0,r3
-2:
-	mov.l	@r4+,r1
-	cmp/str	r3,r1
-	bf/s	2b
-	 add	#4,r2
-
-	add	#-4,r2
-#ifndef __LITTLE_ENDIAN__
-	swap.b	r1,r1
-	swap.w	r1,r1
-	swap.b	r1,r1
-#endif
-	extu.b	r1,r0
-	tst	r0,r0
-	bt/s	8f
-	 shlr8	r1
-	add	#1,r2
-	extu.b	r1,r0
-	tst	r0,r0
-	bt/s	8f
-	 shlr8	r1
-	add	#1,r2
-	extu.b	r1,r0
-	tst	r0,r0
-	bt	8f
-	add	#1,r2
-8:
-	rts
-	 mov	r2,r0
diff --git a/arch/sh/lib/udiv_qrnnd.S b/arch/sh/lib/udiv_qrnnd.S
deleted file mode 100644
index 28938daccd6b44..00000000000000
--- a/arch/sh/lib/udiv_qrnnd.S
+++ /dev/null
@@ -1,60 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ WITH GCC-exception-2.0
-
-   Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
-   2004, 2005, 2006
-   Free Software Foundation, Inc.
-*/
-
-!! libgcc routines for the Renesas / SuperH SH CPUs.
-!! Contributed by Steve Chamberlain.
-!! sac@cygnus.com
-
-!! ashiftrt_r4_x, ___ashrsi3, ___ashlsi3, ___lshrsi3 routines
-!! recoded in assembly by Toshiyasu Morita
-!! tm@netcom.com
-
-/* SH2 optimizations for ___ashrsi3, ___ashlsi3, ___lshrsi3 and
-   ELF local label prefixes by J"orn Rennecke
-   amylaar@cygnus.com  */
-
-	/* r0: rn r1: qn */ /* r0: n1 r4: n0 r5: d r6: d1 */ /* r2: __m */
-	/* n1 < d, but n1 might be larger than d1.  */
-	.global __udiv_qrnnd_16
-	.balign 8
-__udiv_qrnnd_16:
-	div0u
-	cmp/hi r6,r0
-	bt .Lots
-	.rept 16
-	div1 r6,r0 
-	.endr
-	extu.w r0,r1
-	bt 0f
-	add r6,r0
-0:	rotcl r1
-	mulu.w r1,r5
-	xtrct r4,r0
-	swap.w r0,r0
-	sts macl,r2
-	cmp/hs r2,r0
-	sub r2,r0
-	bt 0f
-	addc r5,r0
-	add #-1,r1
-	bt 0f
-1:	add #-1,r1
-	rts
-	add r5,r0
-	.balign 8
-.Lots:
-	sub r5,r0
-	swap.w r4,r1
-	xtrct r0,r1
-	clrt
-	mov r1,r0
-	addc r5,r0
-	mov #-1,r1
-	bf/s 1b
-	 shlr16 r1
-0:	rts
-	 nop
diff --git a/arch/sh/lib/udivsi3.S b/arch/sh/lib/udivsi3.S
deleted file mode 100644
index 09ed1f9deb2ea7..00000000000000
--- a/arch/sh/lib/udivsi3.S
+++ /dev/null
@@ -1,66 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ WITH GCC-exception-2.0
-
-   Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
-   2004, 2005
-   Free Software Foundation, Inc.
-*/
-
-!! libgcc routines for the Renesas / SuperH SH CPUs.
-!! Contributed by Steve Chamberlain.
-!! sac@cygnus.com
-
-	.balign 4
-	.global	__udivsi3
-	.type	__udivsi3, @function
-div8:
-	div1 r5,r4
-div7:
-	div1 r5,r4; div1 r5,r4; div1 r5,r4
-	div1 r5,r4; div1 r5,r4; div1 r5,r4; rts; div1 r5,r4
-
-divx4:
-	div1 r5,r4; rotcl r0
-	div1 r5,r4; rotcl r0
-	div1 r5,r4; rotcl r0
-	rts; div1 r5,r4
-
-__udivsi3:
-	sts.l pr,@-r15
-	extu.w r5,r0
-	cmp/eq r5,r0
-	bf/s large_divisor
-	div0u
-	swap.w r4,r0
-	shlr16 r4
-	bsr div8
-	shll16 r5
-	bsr div7
-	div1 r5,r4
-	xtrct r4,r0
-	xtrct r0,r4
-	bsr div8
-	swap.w r4,r4
-	bsr div7
-	div1 r5,r4
-	lds.l @r15+,pr
-	xtrct r4,r0
-	swap.w r0,r0
-	rotcl r0
-	rts
-	shlr16 r5
-
-large_divisor:
-	mov #0,r0
-	xtrct r4,r0
-	xtrct r0,r4
-	bsr divx4
-	rotcl r0
-	bsr divx4
-	rotcl r0
-	bsr divx4
-	rotcl r0
-	bsr divx4
-	rotcl r0
-	lds.l @r15+,pr
-	rts
-	rotcl r0
diff --git a/arch/sh/lib/udivsi3_i4i-Os.S b/arch/sh/lib/udivsi3_i4i-Os.S
deleted file mode 100644
index fa4e4dff3da142..00000000000000
--- a/arch/sh/lib/udivsi3_i4i-Os.S
+++ /dev/null
@@ -1,128 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ WITH GCC-exception-2.0
- *
- * Copyright (C) 2006 Free Software Foundation, Inc.
- */
-
-/* Moderately Space-optimized libgcc routines for the Renesas SH /
-   STMicroelectronics ST40 CPUs.
-   Contributed by J"orn Rennecke joern.rennecke@st.com.  */
-
-/* Size: 186 bytes jointly for udivsi3_i4i and sdivsi3_i4i
-   sh4-200 run times:
-   udiv small divisor: 55 cycles
-   udiv large divisor: 52 cycles
-   sdiv small divisor, positive result: 59 cycles
-   sdiv large divisor, positive result: 56 cycles
-   sdiv small divisor, negative result: 65 cycles (*)
-   sdiv large divisor, negative result: 62 cycles (*)
-   (*): r2 is restored in the rts delay slot and has a lingering latency
-        of two more cycles.  */
-	.balign 4
-	.global	__udivsi3_i4i
-	.global	__udivsi3_i4
-	.set	__udivsi3_i4, __udivsi3_i4i
-	.type	__udivsi3_i4i, @function
-	.type	__sdivsi3_i4i, @function
-__udivsi3_i4i:
-	sts pr,r1
-	mov.l r4,@-r15
-	extu.w r5,r0
-	cmp/eq r5,r0
-	swap.w r4,r0
-	shlr16 r4
-	bf/s large_divisor
-	div0u
-	mov.l r5,@-r15
-	shll16 r5
-sdiv_small_divisor:
-	div1 r5,r4
-	bsr div6
-	div1 r5,r4
-	div1 r5,r4
-	bsr div6
-	div1 r5,r4
-	xtrct r4,r0
-	xtrct r0,r4
-	bsr div7
-	swap.w r4,r4
-	div1 r5,r4
-	bsr div7
-	div1 r5,r4
-	xtrct r4,r0
-	mov.l @r15+,r5
-	swap.w r0,r0
-	mov.l @r15+,r4
-	jmp @r1
-	rotcl r0
-div7:
-	div1 r5,r4
-div6:
-	            div1 r5,r4; div1 r5,r4; div1 r5,r4
-	div1 r5,r4; div1 r5,r4; rts;        div1 r5,r4
-
-divx3:
-	rotcl r0
-	div1 r5,r4
-	rotcl r0
-	div1 r5,r4
-	rotcl r0
-	rts
-	div1 r5,r4
-
-large_divisor:
-	mov.l r5,@-r15
-sdiv_large_divisor:
-	xor r4,r0
-	.rept 4
-	rotcl r0
-	bsr divx3
-	div1 r5,r4
-	.endr
-	mov.l @r15+,r5
-	mov.l @r15+,r4
-	jmp @r1
-	rotcl r0
-
-	.global	__sdivsi3_i4i
-	.global __sdivsi3_i4
-	.global __sdivsi3
-	.set	__sdivsi3_i4, __sdivsi3_i4i
-	.set	__sdivsi3, __sdivsi3_i4i
-__sdivsi3_i4i:
-	mov.l r4,@-r15
-	cmp/pz r5
-	mov.l r5,@-r15
-	bt/s pos_divisor
-	cmp/pz r4
-	neg r5,r5
-	extu.w r5,r0
-	bt/s neg_result
-	cmp/eq r5,r0
-	neg r4,r4
-pos_result:
-	swap.w r4,r0
-	bra sdiv_check_divisor
-	sts pr,r1
-pos_divisor:
-	extu.w r5,r0
-	bt/s pos_result
-	cmp/eq r5,r0
-	neg r4,r4
-neg_result:
-	mova negate_result,r0
-	;
-	mov r0,r1
-	swap.w r4,r0
-	lds r2,macl
-	sts pr,r2
-sdiv_check_divisor:
-	shlr16 r4
-	bf/s sdiv_large_divisor
-	div0u
-	bra sdiv_small_divisor
-	shll16 r5
-	.balign 4
-negate_result:
-	neg r0,r0
-	jmp @r2
-	sts macl,r2
diff --git a/arch/sh/lib/udivsi3_i4i.S b/arch/sh/lib/udivsi3_i4i.S
deleted file mode 100644
index 6944eb6b4a75ca..00000000000000
--- a/arch/sh/lib/udivsi3_i4i.S
+++ /dev/null
@@ -1,645 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ WITH GCC-exception-2.0
-
-   Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
-   2004, 2005, 2006
-   Free Software Foundation, Inc.
-*/
-
-!! libgcc routines for the Renesas / SuperH SH CPUs.
-!! Contributed by Steve Chamberlain.
-!! sac@cygnus.com
-
-!! ashiftrt_r4_x, ___ashrsi3, ___ashlsi3, ___lshrsi3 routines
-!! recoded in assembly by Toshiyasu Morita
-!! tm@netcom.com
-
-/* SH2 optimizations for ___ashrsi3, ___ashlsi3, ___lshrsi3 and
-   ELF local label prefixes by J"orn Rennecke
-   amylaar@cygnus.com  */
-
-/* This code used shld, thus is not suitable for SH1 / SH2.  */
-
-/* Signed / unsigned division without use of FPU, optimized for SH4.
-   Uses a lookup table for divisors in the range -128 .. +128, and
-   div1 with case distinction for larger divisors in three more ranges.
-   The code is lumped together with the table to allow the use of mova.  */
-#ifdef CONFIG_CPU_LITTLE_ENDIAN
-#define L_LSB 0
-#define L_LSWMSB 1
-#define L_MSWLSB 2
-#else
-#define L_LSB 3
-#define L_LSWMSB 2
-#define L_MSWLSB 1
-#endif
-
-	.balign 4
-	.global	__udivsi3_i4i
-	.global	__udivsi3_i4
-	.set	__udivsi3_i4, __udivsi3_i4i
-	.type	__udivsi3_i4i, @function
-__udivsi3_i4i:
-	mov.w c128_w, r1
-	div0u
-	mov r4,r0
-	shlr8 r0
-	cmp/hi r1,r5
-	extu.w r5,r1
-	bf udiv_le128
-	cmp/eq r5,r1
-	bf udiv_ge64k
-	shlr r0
-	mov r5,r1
-	shll16 r5
-	mov.l r4,@-r15
-	div1 r5,r0
-	mov.l r1,@-r15
-	div1 r5,r0
-	div1 r5,r0
-	bra udiv_25
-	div1 r5,r0
-
-div_le128:
-	mova div_table_ix,r0
-	bra div_le128_2
-	mov.b @(r0,r5),r1
-udiv_le128:
-	mov.l r4,@-r15
-	mova div_table_ix,r0
-	mov.b @(r0,r5),r1
-	mov.l r5,@-r15
-div_le128_2:
-	mova div_table_inv,r0
-	mov.l @(r0,r1),r1
-	mov r5,r0
-	tst #0xfe,r0
-	mova div_table_clz,r0
-	dmulu.l r1,r4
-	mov.b @(r0,r5),r1
-	bt/s div_by_1
-	mov r4,r0
-	mov.l @r15+,r5
-	sts mach,r0
-	/* clrt */
-	addc r4,r0
-	mov.l @r15+,r4
-	rotcr r0
-	rts
-	shld r1,r0
-
-div_by_1_neg:
-	neg r4,r0
-div_by_1:
-	mov.l @r15+,r5
-	rts
-	mov.l @r15+,r4
-
-div_ge64k:
-	bt/s div_r8
-	div0u
-	shll8 r5
-	bra div_ge64k_2
-	div1 r5,r0
-udiv_ge64k:
-	cmp/hi r0,r5
-	mov r5,r1
-	bt udiv_r8
-	shll8 r5
-	mov.l r4,@-r15
-	div1 r5,r0
-	mov.l r1,@-r15
-div_ge64k_2:
-	div1 r5,r0
-	mov.l zero_l,r1
-	.rept 4
-	div1 r5,r0
-	.endr
-	mov.l r1,@-r15
-	div1 r5,r0
-	mov.w m256_w,r1
-	div1 r5,r0
-	mov.b r0,@(L_LSWMSB,r15)
-	xor r4,r0
-	and r1,r0
-	bra div_ge64k_end
-	xor r4,r0
-	
-div_r8:
-	shll16 r4
-	bra div_r8_2
-	shll8 r4
-udiv_r8:
-	mov.l r4,@-r15
-	shll16 r4
-	clrt
-	shll8 r4
-	mov.l r5,@-r15
-div_r8_2:
-	rotcl r4
-	mov r0,r1
-	div1 r5,r1
-	mov r4,r0
-	rotcl r0
-	mov r5,r4
-	div1 r5,r1
-	.rept 5
-	rotcl r0; div1 r5,r1
-	.endr
-	rotcl r0
-	mov.l @r15+,r5
-	div1 r4,r1
-	mov.l @r15+,r4
-	rts
-	rotcl r0
-
-	.global	__sdivsi3_i4i
-	.global __sdivsi3_i4
-	.global	__sdivsi3
-	.set	__sdivsi3_i4, __sdivsi3_i4i
-	.set	__sdivsi3, __sdivsi3_i4i
-	.type	__sdivsi3_i4i, @function
-	/* This is link-compatible with a __sdivsi3 call,
-	   but we effectively clobber only r1.  */
-__sdivsi3_i4i:
-	mov.l r4,@-r15
-	cmp/pz r5
-	mov.w c128_w, r1
-	bt/s pos_divisor
-	cmp/pz r4
-	mov.l r5,@-r15
-	neg r5,r5
-	bt/s neg_result
-	cmp/hi r1,r5
-	neg r4,r4
-pos_result:
-	extu.w r5,r0
-	bf div_le128
-	cmp/eq r5,r0
-	mov r4,r0
-	shlr8 r0
-	bf/s div_ge64k
-	cmp/hi r0,r5
-	div0u
-	shll16 r5
-	div1 r5,r0
-	div1 r5,r0
-	div1 r5,r0
-udiv_25:
-	mov.l zero_l,r1
-	div1 r5,r0
-	div1 r5,r0
-	mov.l r1,@-r15
-	.rept 3
-	div1 r5,r0
-	.endr
-	mov.b r0,@(L_MSWLSB,r15)
-	xtrct r4,r0
-	swap.w r0,r0
-	.rept 8
-	div1 r5,r0
-	.endr
-	mov.b r0,@(L_LSWMSB,r15)
-div_ge64k_end:
-	.rept 8
-	div1 r5,r0
-	.endr
-	mov.l @r15+,r4 ! zero-extension and swap using LS unit.
-	extu.b r0,r0
-	mov.l @r15+,r5
-	or r4,r0
-	mov.l @r15+,r4
-	rts
-	rotcl r0
-
-div_le128_neg:
-	tst #0xfe,r0
-	mova div_table_ix,r0
-	mov.b @(r0,r5),r1
-	mova div_table_inv,r0
-	bt/s div_by_1_neg
-	mov.l @(r0,r1),r1
-	mova div_table_clz,r0
-	dmulu.l r1,r4
-	mov.b @(r0,r5),r1
-	mov.l @r15+,r5
-	sts mach,r0
-	/* clrt */
-	addc r4,r0
-	mov.l @r15+,r4
-	rotcr r0
-	shld r1,r0
-	rts
-	neg r0,r0
-
-pos_divisor:
-	mov.l r5,@-r15
-	bt/s pos_result
-	cmp/hi r1,r5
-	neg r4,r4
-neg_result:
-	extu.w r5,r0
-	bf div_le128_neg
-	cmp/eq r5,r0
-	mov r4,r0
-	shlr8 r0
-	bf/s div_ge64k_neg
-	cmp/hi r0,r5
-	div0u
-	mov.l zero_l,r1
-	shll16 r5
-	div1 r5,r0
-	mov.l r1,@-r15
-	.rept 7
-	div1 r5,r0
-	.endr
-	mov.b r0,@(L_MSWLSB,r15)
-	xtrct r4,r0
-	swap.w r0,r0
-	.rept 8
-	div1 r5,r0
-	.endr
-	mov.b r0,@(L_LSWMSB,r15)
-div_ge64k_neg_end:
-	.rept 8
-	div1 r5,r0
-	.endr
-	mov.l @r15+,r4 ! zero-extension and swap using LS unit.
-	extu.b r0,r1
-	mov.l @r15+,r5
-	or r4,r1
-div_r8_neg_end:
-	mov.l @r15+,r4
-	rotcl r1
-	rts
-	neg r1,r0
-
-div_ge64k_neg:
-	bt/s div_r8_neg
-	div0u
-	shll8 r5
-	mov.l zero_l,r1
-	.rept 6
-	div1 r5,r0
-	.endr
-	mov.l r1,@-r15
-	div1 r5,r0
-	mov.w m256_w,r1
-	div1 r5,r0
-	mov.b r0,@(L_LSWMSB,r15)
-	xor r4,r0
-	and r1,r0
-	bra div_ge64k_neg_end
-	xor r4,r0
-
-c128_w:
-	.word 128
-
-div_r8_neg:
-	clrt
-	shll16 r4
-	mov r4,r1
-	shll8 r1
-	mov r5,r4
-	.rept 7
-	rotcl r1; div1 r5,r0
-	.endr
-	mov.l @r15+,r5
-	rotcl r1
-	bra div_r8_neg_end
-	div1 r4,r0
-
-m256_w:
-	.word 0xff00
-/* This table has been generated by divtab-sh4.c.  */
-	.balign 4
-div_table_clz:
-	.byte	0
-	.byte	1
-	.byte	0
-	.byte	-1
-	.byte	-1
-	.byte	-2
-	.byte	-2
-	.byte	-2
-	.byte	-2
-	.byte	-3
-	.byte	-3
-	.byte	-3
-	.byte	-3
-	.byte	-3
-	.byte	-3
-	.byte	-3
-	.byte	-3
-	.byte	-4
-	.byte	-4
-	.byte	-4
-	.byte	-4
-	.byte	-4
-	.byte	-4
-	.byte	-4
-	.byte	-4
-	.byte	-4
-	.byte	-4
-	.byte	-4
-	.byte	-4
-	.byte	-4
-	.byte	-4
-	.byte	-4
-	.byte	-4
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-5
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-	.byte	-6
-/* Lookup table translating positive divisor to index into table of
-   normalized inverse.  N.B. the '0' entry is also the last entry of the
- previous table, and causes an unaligned access for division by zero.  */
-div_table_ix:
-	.byte	-6
-	.byte	-128
-	.byte	-128
-	.byte	0
-	.byte	-128
-	.byte	-64
-	.byte	0
-	.byte	64
-	.byte	-128
-	.byte	-96
-	.byte	-64
-	.byte	-32
-	.byte	0
-	.byte	32
-	.byte	64
-	.byte	96
-	.byte	-128
-	.byte	-112
-	.byte	-96
-	.byte	-80
-	.byte	-64
-	.byte	-48
-	.byte	-32
-	.byte	-16
-	.byte	0
-	.byte	16
-	.byte	32
-	.byte	48
-	.byte	64
-	.byte	80
-	.byte	96
-	.byte	112
-	.byte	-128
-	.byte	-120
-	.byte	-112
-	.byte	-104
-	.byte	-96
-	.byte	-88
-	.byte	-80
-	.byte	-72
-	.byte	-64
-	.byte	-56
-	.byte	-48
-	.byte	-40
-	.byte	-32
-	.byte	-24
-	.byte	-16
-	.byte	-8
-	.byte	0
-	.byte	8
-	.byte	16
-	.byte	24
-	.byte	32
-	.byte	40
-	.byte	48
-	.byte	56
-	.byte	64
-	.byte	72
-	.byte	80
-	.byte	88
-	.byte	96
-	.byte	104
-	.byte	112
-	.byte	120
-	.byte	-128
-	.byte	-124
-	.byte	-120
-	.byte	-116
-	.byte	-112
-	.byte	-108
-	.byte	-104
-	.byte	-100
-	.byte	-96
-	.byte	-92
-	.byte	-88
-	.byte	-84
-	.byte	-80
-	.byte	-76
-	.byte	-72
-	.byte	-68
-	.byte	-64
-	.byte	-60
-	.byte	-56
-	.byte	-52
-	.byte	-48
-	.byte	-44
-	.byte	-40
-	.byte	-36
-	.byte	-32
-	.byte	-28
-	.byte	-24
-	.byte	-20
-	.byte	-16
-	.byte	-12
-	.byte	-8
-	.byte	-4
-	.byte	0
-	.byte	4
-	.byte	8
-	.byte	12
-	.byte	16
-	.byte	20
-	.byte	24
-	.byte	28
-	.byte	32
-	.byte	36
-	.byte	40
-	.byte	44
-	.byte	48
-	.byte	52
-	.byte	56
-	.byte	60
-	.byte	64
-	.byte	68
-	.byte	72
-	.byte	76
-	.byte	80
-	.byte	84
-	.byte	88
-	.byte	92
-	.byte	96
-	.byte	100
-	.byte	104
-	.byte	108
-	.byte	112
-	.byte	116
-	.byte	120
-	.byte	124
-	.byte	-128
-/* 1/64 .. 1/127, normalized.  There is an implicit leading 1 in bit 32.  */
-	.balign 4
-zero_l:
-	.long	0x0
-	.long	0xF81F81F9
-	.long	0xF07C1F08
-	.long	0xE9131AC0
-	.long	0xE1E1E1E2
-	.long	0xDAE6076C
-	.long	0xD41D41D5
-	.long	0xCD856891
-	.long	0xC71C71C8
-	.long	0xC0E07039
-	.long	0xBACF914D
-	.long	0xB4E81B4F
-	.long	0xAF286BCB
-	.long	0xA98EF607
-	.long	0xA41A41A5
-	.long	0x9EC8E952
-	.long	0x9999999A
-	.long	0x948B0FCE
-	.long	0x8F9C18FA
-	.long	0x8ACB90F7
-	.long	0x86186187
-	.long	0x81818182
-	.long	0x7D05F418
-	.long	0x78A4C818
-	.long	0x745D1746
-	.long	0x702E05C1
-	.long	0x6C16C16D
-	.long	0x68168169
-	.long	0x642C8591
-	.long	0x60581606
-	.long	0x5C9882BA
-	.long	0x58ED2309
-div_table_inv:
-	.long	0x55555556
-	.long	0x51D07EAF
-	.long	0x4E5E0A73
-	.long	0x4AFD6A06
-	.long	0x47AE147B
-	.long	0x446F8657
-	.long	0x41414142
-	.long	0x3E22CBCF
-	.long	0x3B13B13C
-	.long	0x38138139
-	.long	0x3521CFB3
-	.long	0x323E34A3
-	.long	0x2F684BDB
-	.long	0x2C9FB4D9
-	.long	0x29E4129F
-	.long	0x27350B89
-	.long	0x24924925
-	.long	0x21FB7813
-	.long	0x1F7047DD
-	.long	0x1CF06ADB
-	.long	0x1A7B9612
-	.long	0x18118119
-	.long	0x15B1E5F8
-	.long	0x135C8114
-	.long	0x11111112
-	.long	0xECF56BF
-	.long	0xC9714FC
-	.long	0xA6810A7
-	.long	0x8421085
-	.long	0x624DD30
-	.long	0x4104105
-	.long	0x2040811
-	/* maximum error: 0.987342 scaled: 0.921875*/
diff --git a/arch/sh/math-emu/Makefile b/arch/sh/math-emu/Makefile
deleted file mode 100644
index ba06e42c4a58c9..00000000000000
--- a/arch/sh/math-emu/Makefile
+++ /dev/null
@@ -1,2 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0-only
-obj-y	:= math.o
diff --git a/arch/sh/math-emu/math.c b/arch/sh/math-emu/math.c
deleted file mode 100644
index cdaef6501d764a..00000000000000
--- a/arch/sh/math-emu/math.c
+++ /dev/null
@@ -1,506 +0,0 @@
-/*
- * arch/sh/math-emu/math.c
- *
- * Copyright (C) 2006 Takashi YOSHII <takasi-y@ops.dti.ne.jp>
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- */
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/types.h>
-#include <linux/sched/signal.h>
-#include <linux/signal.h>
-#include <linux/perf_event.h>
-
-#include <linux/uaccess.h>
-#include <asm/processor.h>
-#include <asm/io.h>
-
-#include "sfp-util.h"
-#include <math-emu/soft-fp.h>
-#include <math-emu/single.h>
-#include <math-emu/double.h>
-
-#define	FPUL		(fregs->fpul)
-#define FPSCR		(fregs->fpscr)
-#define FPSCR_RM	(FPSCR&3)
-#define FPSCR_DN	((FPSCR>>18)&1)
-#define FPSCR_PR	((FPSCR>>19)&1)
-#define FPSCR_SZ	((FPSCR>>20)&1)
-#define FPSCR_FR	((FPSCR>>21)&1)
-#define FPSCR_MASK	0x003fffffUL
-
-#define BANK(n)	(n^(FPSCR_FR?16:0))
-#define FR	((unsigned long*)(fregs->fp_regs))
-#define FR0	(FR[BANK(0)])
-#define FRn	(FR[BANK(n)])
-#define FRm	(FR[BANK(m)])
-#define DR	((unsigned long long*)(fregs->fp_regs))
-#define DRn	(DR[BANK(n)/2])
-#define DRm	(DR[BANK(m)/2])
-
-#define XREG(n)	(n^16)
-#define XFn	(FR[BANK(XREG(n))])
-#define XFm	(FR[BANK(XREG(m))])
-#define XDn	(DR[BANK(XREG(n))/2])
-#define XDm	(DR[BANK(XREG(m))/2])
-
-#define R0	(regs->regs[0])
-#define Rn	(regs->regs[n])
-#define Rm	(regs->regs[m])
-
-#define MWRITE(d,a)	({if(put_user(d, (typeof (d) __user *)a)) return -EFAULT;})
-#define MREAD(d,a)	({if(get_user(d, (typeof (d) __user *)a)) return -EFAULT;})
-
-#define PACK_S(r,f)	FP_PACK_SP(&r,f)
-#define UNPACK_S(f,r)	FP_UNPACK_SP(f,&r)
-#define PACK_D(r,f) \
-	{u32 t[2]; FP_PACK_DP(t,f); ((u32*)&r)[0]=t[1]; ((u32*)&r)[1]=t[0];}
-#define UNPACK_D(f,r) \
-	{u32 t[2]; t[0]=((u32*)&r)[1]; t[1]=((u32*)&r)[0]; FP_UNPACK_DP(f,t);}
-
-// 2 args instructions.
-#define BOTH_PRmn(op,x) \
-	FP_DECL_EX; if(FPSCR_PR) op(D,x,DRm,DRn); else op(S,x,FRm,FRn);
-
-#define CMP_X(SZ,R,M,N) do{ \
-	FP_DECL_##SZ(Fm); FP_DECL_##SZ(Fn); \
-	UNPACK_##SZ(Fm, M); UNPACK_##SZ(Fn, N); \
-	FP_CMP_##SZ(R, Fn, Fm, 2); }while(0)
-#define EQ_X(SZ,R,M,N) do{ \
-	FP_DECL_##SZ(Fm); FP_DECL_##SZ(Fn); \
-	UNPACK_##SZ(Fm, M); UNPACK_##SZ(Fn, N); \
-	FP_CMP_EQ_##SZ(R, Fn, Fm); }while(0)
-#define CMP(OP) ({ int r; BOTH_PRmn(OP##_X,r); r; })
-
-static int
-fcmp_gt(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
-{
-	if (CMP(CMP) > 0)
-		regs->sr |= 1;
-	else
-		regs->sr &= ~1;
-
-	return 0;
-}
-
-static int
-fcmp_eq(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
-{
-	if (CMP(CMP /*EQ*/) == 0)
-		regs->sr |= 1;
-	else
-		regs->sr &= ~1;
-	return 0;
-}
-
-#define ARITH_X(SZ,OP,M,N) do{ \
-	FP_DECL_##SZ(Fm); FP_DECL_##SZ(Fn); FP_DECL_##SZ(Fr); \
-	UNPACK_##SZ(Fm, M); UNPACK_##SZ(Fn, N); \
-	FP_##OP##_##SZ(Fr, Fn, Fm); \
-	PACK_##SZ(N, Fr); }while(0)
-
-static int
-fadd(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
-{
-	BOTH_PRmn(ARITH_X, ADD);
-	return 0;
-}
-
-static int
-fsub(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
-{
-	BOTH_PRmn(ARITH_X, SUB);
-	return 0;
-}
-
-static int
-fmul(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
-{
-	BOTH_PRmn(ARITH_X, MUL);
-	return 0;
-}
-
-static int
-fdiv(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
-{
-	BOTH_PRmn(ARITH_X, DIV);
-	return 0;
-}
-
-static int
-fmac(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
-{
-	FP_DECL_EX;
-	FP_DECL_S(Fr);
-	FP_DECL_S(Ft);
-	FP_DECL_S(F0);
-	FP_DECL_S(Fm);
-	FP_DECL_S(Fn);
-	UNPACK_S(F0, FR0);
-	UNPACK_S(Fm, FRm);
-	UNPACK_S(Fn, FRn);
-	FP_MUL_S(Ft, Fm, F0);
-	FP_ADD_S(Fr, Fn, Ft);
-	PACK_S(FRn, Fr);
-	return 0;
-}
-
-// to process fmov's extension (odd n for DR access XD).
-#define FMOV_EXT(x) if(x&1) x+=16-1
-
-static int
-fmov_idx_reg(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
-	     int n)
-{
-	if (FPSCR_SZ) {
-		FMOV_EXT(n);
-		MREAD(FRn, Rm + R0 + 4);
-		n++;
-		MREAD(FRn, Rm + R0);
-	} else {
-		MREAD(FRn, Rm + R0);
-	}
-
-	return 0;
-}
-
-static int
-fmov_mem_reg(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
-	     int n)
-{
-	if (FPSCR_SZ) {
-		FMOV_EXT(n);
-		MREAD(FRn, Rm + 4);
-		n++;
-		MREAD(FRn, Rm);
-	} else {
-		MREAD(FRn, Rm);
-	}
-
-	return 0;
-}
-
-static int
-fmov_inc_reg(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
-	     int n)
-{
-	if (FPSCR_SZ) {
-		FMOV_EXT(n);
-		MREAD(FRn, Rm + 4);
-		n++;
-		MREAD(FRn, Rm);
-		Rm += 8;
-	} else {
-		MREAD(FRn, Rm);
-		Rm += 4;
-	}
-
-	return 0;
-}
-
-static int
-fmov_reg_idx(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
-	     int n)
-{
-	if (FPSCR_SZ) {
-		FMOV_EXT(m);
-		MWRITE(FRm, Rn + R0 + 4);
-		m++;
-		MWRITE(FRm, Rn + R0);
-	} else {
-		MWRITE(FRm, Rn + R0);
-	}
-
-	return 0;
-}
-
-static int
-fmov_reg_mem(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
-	     int n)
-{
-	if (FPSCR_SZ) {
-		FMOV_EXT(m);
-		MWRITE(FRm, Rn + 4);
-		m++;
-		MWRITE(FRm, Rn);
-	} else {
-		MWRITE(FRm, Rn);
-	}
-
-	return 0;
-}
-
-static int
-fmov_reg_dec(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
-	     int n)
-{
-	if (FPSCR_SZ) {
-		FMOV_EXT(m);
-		Rn -= 8;
-		MWRITE(FRm, Rn + 4);
-		m++;
-		MWRITE(FRm, Rn);
-	} else {
-		Rn -= 4;
-		MWRITE(FRm, Rn);
-	}
-
-	return 0;
-}
-
-static int
-fmov_reg_reg(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
-	     int n)
-{
-	if (FPSCR_SZ) {
-		FMOV_EXT(m);
-		FMOV_EXT(n);
-		DRn = DRm;
-	} else {
-		FRn = FRm;
-	}
-
-	return 0;
-}
-
-static int
-fnop_mn(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m, int n)
-{
-	return -EINVAL;
-}
-
-// 1 arg instructions.
-#define NOTYETn(i) static int i(struct sh_fpu_soft_struct *fregs, int n) \
-	{ printk( #i " not yet done.\n"); return 0; }
-
-NOTYETn(ftrv)
-NOTYETn(fsqrt)
-NOTYETn(fipr)
-NOTYETn(fsca)
-NOTYETn(fsrra)
-
-#define EMU_FLOAT_X(SZ,N) do { \
-	FP_DECL_##SZ(Fn); \
-	FP_FROM_INT_##SZ(Fn, FPUL, 32, int); \
-	PACK_##SZ(N, Fn); }while(0)
-static int ffloat(struct sh_fpu_soft_struct *fregs, int n)
-{
-	FP_DECL_EX;
-
-	if (FPSCR_PR)
-		EMU_FLOAT_X(D, DRn);
-	else
-		EMU_FLOAT_X(S, FRn);
-
-	return 0;
-}
-
-#define EMU_FTRC_X(SZ,N) do { \
-	FP_DECL_##SZ(Fn); \
-	UNPACK_##SZ(Fn, N); \
-	FP_TO_INT_##SZ(FPUL, Fn, 32, 1); }while(0)
-static int ftrc(struct sh_fpu_soft_struct *fregs, int n)
-{
-	FP_DECL_EX;
-
-	if (FPSCR_PR)
-		EMU_FTRC_X(D, DRn);
-	else
-		EMU_FTRC_X(S, FRn);
-
-	return 0;
-}
-
-static int fcnvsd(struct sh_fpu_soft_struct *fregs, int n)
-{
-	FP_DECL_EX;
-	FP_DECL_S(Fn);
-	FP_DECL_D(Fr);
-	UNPACK_S(Fn, FPUL);
-	FP_CONV(D, S, 2, 1, Fr, Fn);
-	PACK_D(DRn, Fr);
-	return 0;
-}
-
-static int fcnvds(struct sh_fpu_soft_struct *fregs, int n)
-{
-	FP_DECL_EX;
-	FP_DECL_D(Fn);
-	FP_DECL_S(Fr);
-	UNPACK_D(Fn, DRn);
-	FP_CONV(S, D, 1, 2, Fr, Fn);
-	PACK_S(FPUL, Fr);
-	return 0;
-}
-
-static int fxchg(struct sh_fpu_soft_struct *fregs, int flag)
-{
-	FPSCR ^= flag;
-	return 0;
-}
-
-static int fsts(struct sh_fpu_soft_struct *fregs, int n)
-{
-	FRn = FPUL;
-	return 0;
-}
-
-static int flds(struct sh_fpu_soft_struct *fregs, int n)
-{
-	FPUL = FRn;
-	return 0;
-}
-
-static int fneg(struct sh_fpu_soft_struct *fregs, int n)
-{
-	FRn ^= (1 << (_FP_W_TYPE_SIZE - 1));
-	return 0;
-}
-
-static int fabs(struct sh_fpu_soft_struct *fregs, int n)
-{
-	FRn &= ~(1 << (_FP_W_TYPE_SIZE - 1));
-	return 0;
-}
-
-static int fld0(struct sh_fpu_soft_struct *fregs, int n)
-{
-	FRn = 0;
-	return 0;
-}
-
-static int fld1(struct sh_fpu_soft_struct *fregs, int n)
-{
-	FRn = (_FP_EXPBIAS_S << (_FP_FRACBITS_S - 1));
-	return 0;
-}
-
-static int fnop_n(struct sh_fpu_soft_struct *fregs, int n)
-{
-	return -EINVAL;
-}
-
-/// Instruction decoders.
-
-static int id_fxfd(struct sh_fpu_soft_struct *, int);
-static int id_fnxd(struct sh_fpu_soft_struct *, struct pt_regs *, int, int);
-
-static int (*fnxd[])(struct sh_fpu_soft_struct *, int) = {
-	fsts, flds, ffloat, ftrc, fneg, fabs, fsqrt, fsrra,
-	fld0, fld1, fcnvsd, fcnvds, fnop_n, fnop_n, fipr, id_fxfd
-};
-
-static int (*fnmx[])(struct sh_fpu_soft_struct *, struct pt_regs *, int, int) = {
-	fadd, fsub, fmul, fdiv, fcmp_eq, fcmp_gt, fmov_idx_reg, fmov_reg_idx,
-	fmov_mem_reg, fmov_inc_reg, fmov_reg_mem, fmov_reg_dec,
-	fmov_reg_reg, id_fnxd, fmac, fnop_mn};
-
-static int id_fxfd(struct sh_fpu_soft_struct *fregs, int x)
-{
-	const int flag[] = { FPSCR_SZ, FPSCR_PR, FPSCR_FR, 0 };
-	switch (x & 3) {
-	case 3:
-		fxchg(fregs, flag[x >> 2]);
-		break;
-	case 1:
-		ftrv(fregs, x - 1);
-		break;
-	default:
-		fsca(fregs, x);
-	}
-	return 0;
-}
-
-static int
-id_fnxd(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int x, int n)
-{
-	return (fnxd[x])(fregs, n);
-}
-
-static int
-id_fnmx(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, u16 code)
-{
-	int n = (code >> 8) & 0xf, m = (code >> 4) & 0xf, x = code & 0xf;
-	return (fnmx[x])(fregs, regs, m, n);
-}
-
-static int
-id_sys(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, u16 code)
-{
-	int n = ((code >> 8) & 0xf);
-	unsigned long *reg = (code & 0x0010) ? &FPUL : &FPSCR;
-
-	switch (code & 0xf0ff) {
-	case 0x005a:
-	case 0x006a:
-		Rn = *reg;
-		break;
-	case 0x405a:
-	case 0x406a:
-		*reg = Rn;
-		break;
-	case 0x4052:
-	case 0x4062:
-		Rn -= 4;
-		MWRITE(*reg, Rn);
-		break;
-	case 0x4056:
-	case 0x4066:
-		MREAD(*reg, Rn);
-		Rn += 4;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int fpu_emulate(u16 code, struct sh_fpu_soft_struct *fregs, struct pt_regs *regs)
-{
-	if ((code & 0xf000) == 0xf000)
-		return id_fnmx(fregs, regs, code);
-	else
-		return id_sys(fregs, regs, code);
-}
-
-/**
- * fpu_init - Initialize FPU registers
- * @fpu: Pointer to software emulated FPU registers.
- */
-static void fpu_init(struct sh_fpu_soft_struct *fpu)
-{
-	int i;
-
-	fpu->fpscr = FPSCR_INIT;
-	fpu->fpul = 0;
-
-	for (i = 0; i < 16; i++) {
-		fpu->fp_regs[i] = 0;
-		fpu->xfp_regs[i]= 0;
-	}
-}
-
-/**
- * do_fpu_inst - Handle reserved instructions for FPU emulation
- * @inst: instruction code.
- * @regs: registers on stack.
- */
-int do_fpu_inst(unsigned short inst, struct pt_regs *regs)
-{
-	struct task_struct *tsk = current;
-	struct sh_fpu_soft_struct *fpu = &(tsk->thread.xstate->softfpu);
-
-	perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);
-
-	if (!(task_thread_info(tsk)->status & TS_USEDFPU)) {
-		/* initialize once. */
-		fpu_init(fpu);
-		task_thread_info(tsk)->status |= TS_USEDFPU;
-	}
-
-	return fpu_emulate(inst, fpu, regs);
-}
diff --git a/arch/sh/math-emu/sfp-util.h b/arch/sh/math-emu/sfp-util.h
deleted file mode 100644
index 784f541344f36d..00000000000000
--- a/arch/sh/math-emu/sfp-util.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * These are copied from glibc/stdlib/longlong.h
- */
-
-#define add_ssaaaa(sh, sl, ah, al, bh, bl) \
-  do {                                                                  \
-    UWtype __x;                                                         \
-    __x = (al) + (bl);                                                  \
-    (sh) = (ah) + (bh) + (__x < (al));                                  \
-    (sl) = __x;                                                         \
-  } while (0)
-
-#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
-  do {                                                                  \
-    UWtype __x;                                                         \
-    __x = (al) - (bl);                                                  \
-    (sh) = (ah) - (bh) - (__x > (al));                                  \
-    (sl) = __x;                                                         \
-  } while (0)
-
-#define umul_ppmm(w1, w0, u, v) \
-  __asm__ ("dmulu.l %2,%3\n\tsts    macl,%1\n\tsts  mach,%0"	\
-	: "=r" ((u32)(w1)), "=r" ((u32)(w0))	\
-	:  "r" ((u32)(u)),   "r" ((u32)(v))	\
-	: "macl", "mach")
-
-#define __ll_B ((UWtype) 1 << (W_TYPE_SIZE / 2))
-#define __ll_lowpart(t) ((UWtype) (t) & (__ll_B - 1))
-#define __ll_highpart(t) ((UWtype) (t) >> (W_TYPE_SIZE / 2))
-
-#define udiv_qrnnd(q, r, n1, n0, d) \
-  do {									\
-    UWtype __d1, __d0, __q1, __q0;					\
-    UWtype __r1, __r0, __m;						\
-    __d1 = __ll_highpart (d);						\
-    __d0 = __ll_lowpart (d);						\
-									\
-    __r1 = (n1) % __d1;							\
-    __q1 = (n1) / __d1;							\
-    __m = (UWtype) __q1 * __d0;						\
-    __r1 = __r1 * __ll_B | __ll_highpart (n0);				\
-    if (__r1 < __m)							\
-      {									\
-	__q1--, __r1 += (d);						\
-	if (__r1 >= (d)) /* i.e. we didn't get carry when adding to __r1 */\
-	  if (__r1 < __m)						\
-	    __q1--, __r1 += (d);					\
-      }									\
-    __r1 -= __m;							\
-									\
-    __r0 = __r1 % __d1;							\
-    __q0 = __r1 / __d1;							\
-    __m = (UWtype) __q0 * __d0;						\
-    __r0 = __r0 * __ll_B | __ll_lowpart (n0);				\
-    if (__r0 < __m)							\
-      {									\
-	__q0--, __r0 += (d);						\
-	if (__r0 >= (d))						\
-	  if (__r0 < __m)						\
-	    __q0--, __r0 += (d);					\
-      }									\
-    __r0 -= __m;							\
-									\
-    (q) = (UWtype) __q1 * __ll_B | __q0;				\
-    (r) = __r0;								\
-  } while (0)
-
-#define abort()	return 0
-
-#define __BYTE_ORDER __LITTLE_ENDIAN
-
-
diff --git a/arch/sh/mm/Kconfig b/arch/sh/mm/Kconfig
deleted file mode 100644
index 411fdc0901f7ea..00000000000000
--- a/arch/sh/mm/Kconfig
+++ /dev/null
@@ -1,254 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-menu "Memory management options"
-
-config MMU
-        bool "Support for memory management hardware"
-	depends on !CPU_SH2
-	default y
-	help
-	  Some SH processors (such as SH-2/SH-2A) lack an MMU. In order to
-	  boot on these systems, this option must not be set.
-
-	  On other systems (such as the SH-3 and 4) where an MMU exists,
-	  turning this off will boot the kernel on these machines with the
-	  MMU implicitly switched off.
-
-config PAGE_OFFSET
-	hex
-	default "0x80000000" if MMU
-	default "0x00000000"
-
-config ARCH_FORCE_MAX_ORDER
-	int "Maximum zone order"
-	range 9 64 if PAGE_SIZE_16KB
-	default "9" if PAGE_SIZE_16KB
-	range 7 64 if PAGE_SIZE_64KB
-	default "7" if PAGE_SIZE_64KB
-	range 11 64
-	default "14" if !MMU
-	default "11"
-	help
-	  The kernel memory allocator divides physically contiguous memory
-	  blocks into "zones", where each zone is a power of two number of
-	  pages.  This option selects the largest power of two that the kernel
-	  keeps in the memory allocator.  If you need to allocate very large
-	  blocks of physically contiguous memory, then you may need to
-	  increase this value.
-
-	  This config option is actually maximum order plus one. For example,
-	  a value of 11 means that the largest free memory block is 2^10 pages.
-
-	  The page size is not necessarily 4KB. Keep this in mind when
-	  choosing a value for this option.
-
-config MEMORY_START
-	hex "Physical memory start address"
-	default "0x08000000"
-	help
-	  Computers built with Hitachi SuperH processors always
-	  map the ROM starting at address zero.  But the processor
-	  does not specify the range that RAM takes.
-
-	  The physical memory (RAM) start address will be automatically
-	  set to 08000000. Other platforms, such as the Solution Engine
-	  boards typically map RAM at 0C000000.
-
-	  Tweak this only when porting to a new machine which does not
-	  already have a defconfig. Changing it from the known correct
-	  value on any of the known systems will only lead to disaster.
-
-config MEMORY_SIZE
-	hex "Physical memory size"
-	default "0x04000000"
-	help
-	  This sets the default memory size assumed by your SH kernel. It can
-	  be overridden as normal by the 'mem=' argument on the kernel command
-	  line. If unsure, consult your board specifications or just leave it
-	  as 0x04000000 which was the default value before this became
-	  configurable.
-
-# Physical addressing modes
-
-config 29BIT
-	def_bool !32BIT
-	select UNCACHED_MAPPING
-
-config 32BIT
-	bool
-	default !MMU
-
-config PMB
-	bool "Support 32-bit physical addressing through PMB"
-	depends on MMU && CPU_SH4A && !CPU_SH4AL_DSP
-	select 32BIT
-	select UNCACHED_MAPPING
-	help
-	  If you say Y here, physical addressing will be extended to
-	  32-bits through the SH-4A PMB. If this is not set, legacy
-	  29-bit physical addressing will be used.
-
-config X2TLB
-	def_bool y
-	depends on (CPU_SHX2 || CPU_SHX3) && MMU
-
-config VSYSCALL
-	bool "Support vsyscall page"
-	depends on MMU && (CPU_SH3 || CPU_SH4)
-	default y
-	help
-	  This will enable support for the kernel mapping a vDSO page
-	  in process space, and subsequently handing down the entry point
-	  to the libc through the ELF auxiliary vector.
-
-	  From the kernel side this is used for the signal trampoline.
-	  For systems with an MMU that can afford to give up a page,
-	  (the default value) say Y.
-
-config NUMA
-	bool "Non-Uniform Memory Access (NUMA) Support"
-	depends on MMU && SYS_SUPPORTS_NUMA
-	select ARCH_WANT_NUMA_VARIABLE_LOCALITY
-	default n
-	help
-	  Some SH systems have many various memories scattered around
-	  the address space, each with varying latencies. This enables
-	  support for these blocks by binding them to nodes and allowing
-	  memory policies to be used for prioritizing and controlling
-	  allocation behaviour.
-
-config NODES_SHIFT
-	int
-	default "3" if CPU_SUBTYPE_SHX3
-	default "1"
-	depends on NUMA
-
-config ARCH_FLATMEM_ENABLE
-	def_bool y
-	depends on !NUMA
-
-config ARCH_SPARSEMEM_ENABLE
-	def_bool y
-	select SPARSEMEM_STATIC
-
-config ARCH_SPARSEMEM_DEFAULT
-	def_bool y
-
-config ARCH_SELECT_MEMORY_MODEL
-	def_bool y
-
-config ARCH_MEMORY_PROBE
-	def_bool y
-	depends on MEMORY_HOTPLUG
-
-config IOREMAP_FIXED
-       def_bool y
-       depends on X2TLB
-
-config UNCACHED_MAPPING
-	bool
-
-config HAVE_SRAM_POOL
-	bool
-	select GENERIC_ALLOCATOR
-
-choice
-	prompt "Kernel page size"
-	default PAGE_SIZE_4KB
-
-config PAGE_SIZE_4KB
-	bool "4kB"
-	help
-	  This is the default page size used by all SuperH CPUs.
-
-config PAGE_SIZE_8KB
-	bool "8kB"
-	depends on !MMU || X2TLB
-	help
-	  This enables 8kB pages as supported by SH-X2 and later MMUs.
-
-config PAGE_SIZE_16KB
-	bool "16kB"
-	depends on !MMU
-	help
-	  This enables 16kB pages on MMU-less SH systems.
-
-config PAGE_SIZE_64KB
-	bool "64kB"
-	depends on !MMU || CPU_SH4
-	help
-	  This enables support for 64kB pages, possible on all SH-4
-	  CPUs and later.
-
-endchoice
-
-choice
-	prompt "HugeTLB page size"
-	depends on HUGETLB_PAGE
-	default HUGETLB_PAGE_SIZE_1MB if PAGE_SIZE_64KB
-	default HUGETLB_PAGE_SIZE_64K
-
-config HUGETLB_PAGE_SIZE_64K
-	bool "64kB"
-	depends on !PAGE_SIZE_64KB
-
-config HUGETLB_PAGE_SIZE_256K
-	bool "256kB"
-	depends on X2TLB
-
-config HUGETLB_PAGE_SIZE_1MB
-	bool "1MB"
-
-config HUGETLB_PAGE_SIZE_4MB
-	bool "4MB"
-	depends on X2TLB
-
-config HUGETLB_PAGE_SIZE_64MB
-	bool "64MB"
-	depends on X2TLB
-
-endchoice
-
-config SCHED_MC
-	bool "Multi-core scheduler support"
-	depends on SMP
-	default y
-	help
-	  Multi-core scheduler support improves the CPU scheduler's decision
-	  making when dealing with multi-core CPU chips at a cost of slightly
-	  increased overhead in some places. If unsure say N here.
-
-endmenu
-
-menu "Cache configuration"
-
-config SH7705_CACHE_32KB
-	bool "Enable 32KB cache size for SH7705"
-	depends on CPU_SUBTYPE_SH7705
-	default y
-
-choice
-	prompt "Cache mode"
-	default CACHE_WRITEBACK if CPU_SH2A || CPU_SH3 || CPU_SH4
-	default CACHE_WRITETHROUGH if (CPU_SH2 && !CPU_SH2A)
-
-config CACHE_WRITEBACK
-	bool "Write-back"
-
-config CACHE_WRITETHROUGH
-	bool "Write-through"
-	help
-	  Selecting this option will configure the caches in write-through
-	  mode, as opposed to the default write-back configuration.
-
-	  Since there's sill some aliasing issues on SH-4, this option will
-	  unfortunately still require the majority of flushing functions to
-	  be implemented to deal with aliasing.
-
-	  If unsure, say N.
-
-config CACHE_OFF
-	bool "Off"
-
-endchoice
-
-endmenu
diff --git a/arch/sh/mm/Makefile b/arch/sh/mm/Makefile
deleted file mode 100644
index f69ddc70b14658..00000000000000
--- a/arch/sh/mm/Makefile
+++ /dev/null
@@ -1,45 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0
-#
-# Makefile for the Linux SuperH-specific parts of the memory manager.
-#
-
-obj-y			:= alignment.o cache.o init.o consistent.o mmap.o
-
-cacheops-$(CONFIG_CPU_J2)		:= cache-j2.o
-cacheops-$(CONFIG_CPU_SUBTYPE_SH7619)	:= cache-sh2.o
-cacheops-$(CONFIG_CPU_SH2A)		:= cache-sh2a.o
-cacheops-$(CONFIG_CPU_SH3)		:= cache-sh3.o
-cacheops-$(CONFIG_CPU_SH4)		:= cache-sh4.o flush-sh4.o
-cacheops-$(CONFIG_SH7705_CACHE_32KB)	+= cache-sh7705.o
-cacheops-$(CONFIG_CPU_SHX3)		+= cache-shx3.o
-
-obj-y			+= $(cacheops-y)
-
-mmu-y			:= nommu.o extable_32.o
-mmu-$(CONFIG_MMU)	:= extable_32.o fault.o ioremap.o kmap.o \
-			   pgtable.o tlbex_32.o tlbflush_32.o
-
-obj-y			+= $(mmu-y)
-
-debugfs-y			:= asids-debugfs.o
-ifndef CONFIG_CACHE_OFF
-debugfs-$(CONFIG_CPU_SH4)	+= cache-debugfs.o
-endif
-
-ifdef CONFIG_MMU
-debugfs-$(CONFIG_CPU_SH4)	+= tlb-debugfs.o
-tlb-$(CONFIG_CPU_SH3)		:= tlb-sh3.o
-tlb-$(CONFIG_CPU_SH4)		:= tlb-sh4.o tlb-urb.o
-tlb-$(CONFIG_CPU_HAS_PTEAEX)	:= tlb-pteaex.o tlb-urb.o
-obj-y				+= $(tlb-y)
-endif
-
-obj-$(CONFIG_DEBUG_FS)		+= $(debugfs-y)
-obj-$(CONFIG_HUGETLB_PAGE)	+= hugetlbpage.o
-obj-$(CONFIG_PMB)		+= pmb.o
-obj-$(CONFIG_NUMA)		+= numa.o
-obj-$(CONFIG_IOREMAP_FIXED)	+= ioremap_fixed.o
-obj-$(CONFIG_UNCACHED_MAPPING)	+= uncached.o
-obj-$(CONFIG_HAVE_SRAM_POOL)	+= sram.o
-
-GCOV_PROFILE_pmb.o := n
diff --git a/arch/sh/mm/alignment.c b/arch/sh/mm/alignment.c
deleted file mode 100644
index 3a76a766f4232c..00000000000000
--- a/arch/sh/mm/alignment.c
+++ /dev/null
@@ -1,189 +0,0 @@
-/*
- * Alignment access counters and corresponding user-space interfaces.
- *
- * Copyright (C) 2009 ST Microelectronics
- * Copyright (C) 2009 - 2010 Paul Mundt
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/seq_file.h>
-#include <linux/proc_fs.h>
-#include <linux/uaccess.h>
-#include <linux/ratelimit.h>
-#include <asm/alignment.h>
-#include <asm/processor.h>
-
-static unsigned long se_user;
-static unsigned long se_sys;
-static unsigned long se_half;
-static unsigned long se_word;
-static unsigned long se_dword;
-static unsigned long se_multi;
-/* bitfield: 1: warn 2: fixup 4: signal -> combinations 2|4 && 1|2|4 are not
-   valid! */
-static int se_usermode = UM_WARN | UM_FIXUP;
-/* 0: no warning 1: print a warning message, disabled by default */
-static int se_kernmode_warn;
-
-core_param(alignment, se_usermode, int, 0600);
-
-void inc_unaligned_byte_access(void)
-{
-	se_half++;
-}
-
-void inc_unaligned_word_access(void)
-{
-	se_word++;
-}
-
-void inc_unaligned_dword_access(void)
-{
-	se_dword++;
-}
-
-void inc_unaligned_multi_access(void)
-{
-	se_multi++;
-}
-
-void inc_unaligned_user_access(void)
-{
-	se_user++;
-}
-
-void inc_unaligned_kernel_access(void)
-{
-	se_sys++;
-}
-
-/*
- * This defaults to the global policy which can be set from the command
- * line, while processes can overload their preferences via prctl().
- */
-unsigned int unaligned_user_action(void)
-{
-	unsigned int action = se_usermode;
-
-	if (current->thread.flags & SH_THREAD_UAC_SIGBUS) {
-		action &= ~UM_FIXUP;
-		action |= UM_SIGNAL;
-	}
-
-	if (current->thread.flags & SH_THREAD_UAC_NOPRINT)
-		action &= ~UM_WARN;
-
-	return action;
-}
-
-int get_unalign_ctl(struct task_struct *tsk, unsigned long addr)
-{
-	return put_user(tsk->thread.flags & SH_THREAD_UAC_MASK,
-			(unsigned int __user *)addr);
-}
-
-int set_unalign_ctl(struct task_struct *tsk, unsigned int val)
-{
-	tsk->thread.flags = (tsk->thread.flags & ~SH_THREAD_UAC_MASK) |
-			    (val & SH_THREAD_UAC_MASK);
-	return 0;
-}
-
-void unaligned_fixups_notify(struct task_struct *tsk, insn_size_t insn,
-			     struct pt_regs *regs)
-{
-	if (user_mode(regs) && (se_usermode & UM_WARN))
-		pr_notice_ratelimited("Fixing up unaligned userspace access "
-			  "in \"%s\" pid=%d pc=0x%p ins=0x%04hx\n",
-			  tsk->comm, task_pid_nr(tsk),
-			  (void *)instruction_pointer(regs), insn);
-	else if (se_kernmode_warn)
-		pr_notice_ratelimited("Fixing up unaligned kernel access "
-			  "in \"%s\" pid=%d pc=0x%p ins=0x%04hx\n",
-			  tsk->comm, task_pid_nr(tsk),
-			  (void *)instruction_pointer(regs), insn);
-}
-
-static const char *se_usermode_action[] = {
-	"ignored",
-	"warn",
-	"fixup",
-	"fixup+warn",
-	"signal",
-	"signal+warn"
-};
-
-static int alignment_proc_show(struct seq_file *m, void *v)
-{
-	seq_printf(m, "User:\t\t%lu\n", se_user);
-	seq_printf(m, "System:\t\t%lu\n", se_sys);
-	seq_printf(m, "Half:\t\t%lu\n", se_half);
-	seq_printf(m, "Word:\t\t%lu\n", se_word);
-	seq_printf(m, "DWord:\t\t%lu\n", se_dword);
-	seq_printf(m, "Multi:\t\t%lu\n", se_multi);
-	seq_printf(m, "User faults:\t%i (%s)\n", se_usermode,
-			se_usermode_action[se_usermode]);
-	seq_printf(m, "Kernel faults:\t%i (fixup%s)\n", se_kernmode_warn,
-			se_kernmode_warn ? "+warn" : "");
-	return 0;
-}
-
-static int alignment_proc_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, alignment_proc_show, NULL);
-}
-
-static ssize_t alignment_proc_write(struct file *file,
-		const char __user *buffer, size_t count, loff_t *pos)
-{
-	int *data = pde_data(file_inode(file));
-	char mode;
-
-	if (count > 0) {
-		if (get_user(mode, buffer))
-			return -EFAULT;
-		if (mode >= '0' && mode <= '5')
-			*data = mode - '0';
-	}
-	return count;
-}
-
-static const struct proc_ops alignment_proc_ops = {
-	.proc_open	= alignment_proc_open,
-	.proc_read	= seq_read,
-	.proc_lseek	= seq_lseek,
-	.proc_release	= single_release,
-	.proc_write	= alignment_proc_write,
-};
-
-/*
- * This needs to be done after sysctl_init_bases(), otherwise sys/ will be
- * overwritten.  Actually, this shouldn't be in sys/ at all since
- * it isn't a sysctl, and it doesn't contain sysctl information.
- * We now locate it in /proc/cpu/alignment instead.
- */
-static int __init alignment_init(void)
-{
-	struct proc_dir_entry *dir, *res;
-
-	dir = proc_mkdir("cpu", NULL);
-	if (!dir)
-		return -ENOMEM;
-
-	res = proc_create_data("alignment", S_IWUSR | S_IRUGO, dir,
-			       &alignment_proc_ops, &se_usermode);
-	if (!res)
-		return -ENOMEM;
-
-        res = proc_create_data("kernel_alignment", S_IWUSR | S_IRUGO, dir,
-			       &alignment_proc_ops, &se_kernmode_warn);
-        if (!res)
-                return -ENOMEM;
-
-	return 0;
-}
-fs_initcall(alignment_init);
diff --git a/arch/sh/mm/asids-debugfs.c b/arch/sh/mm/asids-debugfs.c
deleted file mode 100644
index d16d6f5ec77499..00000000000000
--- a/arch/sh/mm/asids-debugfs.c
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * debugfs ops for process ASIDs
- *
- *  Copyright (C) 2000, 2001  Paolo Alberelli
- *  Copyright (C) 2003 - 2008  Paul Mundt
- *  Copyright (C) 2003, 2004  Richard Curnow
- *
- * Provides a debugfs file that lists out the ASIDs currently associated
- * with the processes.
- *
- * In the SH-5 case, if the DM.PC register is examined through the debug
- * link, this shows ASID + PC. To make use of this, the PID->ASID
- * relationship needs to be known. This is primarily for debugging.
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- */
-#include <linux/init.h>
-#include <linux/debugfs.h>
-#include <linux/seq_file.h>
-#include <linux/spinlock.h>
-#include <linux/sched/signal.h>
-#include <linux/sched/task.h>
-
-#include <asm/processor.h>
-#include <asm/mmu_context.h>
-
-static int asids_debugfs_show(struct seq_file *file, void *iter)
-{
-	struct task_struct *p;
-
-	read_lock(&tasklist_lock);
-
-	for_each_process(p) {
-		int pid = p->pid;
-
-		if (unlikely(!pid))
-			continue;
-
-		if (p->mm)
-			seq_printf(file, "%5d : %04lx\n", pid,
-				   cpu_asid(smp_processor_id(), p->mm));
-	}
-
-	read_unlock(&tasklist_lock);
-
-	return 0;
-}
-
-DEFINE_SHOW_ATTRIBUTE(asids_debugfs);
-
-static int __init asids_debugfs_init(void)
-{
-	debugfs_create_file("asids", S_IRUSR, arch_debugfs_dir, NULL,
-			    &asids_debugfs_fops);
-	return 0;
-}
-device_initcall(asids_debugfs_init);
diff --git a/arch/sh/mm/cache-debugfs.c b/arch/sh/mm/cache-debugfs.c
deleted file mode 100644
index b0f185169dfa0c..00000000000000
--- a/arch/sh/mm/cache-debugfs.c
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * debugfs ops for the L1 cache
- *
- *  Copyright (C) 2006  Paul Mundt
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- */
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/debugfs.h>
-#include <linux/seq_file.h>
-#include <asm/processor.h>
-#include <linux/uaccess.h>
-#include <asm/cache.h>
-#include <asm/io.h>
-
-enum cache_type {
-	CACHE_TYPE_ICACHE,
-	CACHE_TYPE_DCACHE,
-	CACHE_TYPE_UNIFIED,
-};
-
-static int cache_debugfs_show(struct seq_file *file, void *iter)
-{
-	unsigned int cache_type = (unsigned int)file->private;
-	struct cache_info *cache;
-	unsigned int waysize, way;
-	unsigned long ccr;
-	unsigned long addrstart = 0;
-
-	/*
-	 * Go uncached immediately so we don't skew the results any
-	 * more than we already are..
-	 */
-	jump_to_uncached();
-
-	ccr = __raw_readl(SH_CCR);
-	if ((ccr & CCR_CACHE_ENABLE) == 0) {
-		back_to_cached();
-
-		seq_printf(file, "disabled\n");
-		return 0;
-	}
-
-	if (cache_type == CACHE_TYPE_DCACHE) {
-		addrstart = CACHE_OC_ADDRESS_ARRAY;
-		cache = &current_cpu_data.dcache;
-	} else {
-		addrstart = CACHE_IC_ADDRESS_ARRAY;
-		cache = &current_cpu_data.icache;
-	}
-
-	waysize = cache->sets;
-
-	/*
-	 * If the OC is already in RAM mode, we only have
-	 * half of the entries to consider..
-	 */
-	if ((ccr & CCR_CACHE_ORA) && cache_type == CACHE_TYPE_DCACHE)
-		waysize >>= 1;
-
-	waysize <<= cache->entry_shift;
-
-	for (way = 0; way < cache->ways; way++) {
-		unsigned long addr;
-		unsigned int line;
-
-		seq_printf(file, "-----------------------------------------\n");
-		seq_printf(file, "Way %d\n", way);
-		seq_printf(file, "-----------------------------------------\n");
-
-		for (addr = addrstart, line = 0;
-		     addr < addrstart + waysize;
-		     addr += cache->linesz, line++) {
-			unsigned long data = __raw_readl(addr);
-
-			/* Check the V bit, ignore invalid cachelines */
-			if ((data & 1) == 0)
-				continue;
-
-			/* U: Dirty, cache tag is 10 bits up */
-			seq_printf(file, "%3d: %c 0x%lx\n",
-				   line, data & 2 ? 'U' : ' ',
-				   data & 0x1ffffc00);
-		}
-
-		addrstart += cache->way_incr;
-	}
-
-	back_to_cached();
-
-	return 0;
-}
-
-DEFINE_SHOW_ATTRIBUTE(cache_debugfs);
-
-static int __init cache_debugfs_init(void)
-{
-	debugfs_create_file("dcache", S_IRUSR, arch_debugfs_dir,
-			    (void *)CACHE_TYPE_DCACHE, &cache_debugfs_fops);
-	debugfs_create_file("icache", S_IRUSR, arch_debugfs_dir,
-			    (void *)CACHE_TYPE_ICACHE, &cache_debugfs_fops);
-	return 0;
-}
-module_init(cache_debugfs_init);
-
-MODULE_LICENSE("GPL v2");
diff --git a/arch/sh/mm/cache-j2.c b/arch/sh/mm/cache-j2.c
deleted file mode 100644
index f277862a11f530..00000000000000
--- a/arch/sh/mm/cache-j2.c
+++ /dev/null
@@ -1,64 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * arch/sh/mm/cache-j2.c
- *
- * Copyright (C) 2015-2016 Smart Energy Instruments, Inc.
- */
-
-#include <linux/init.h>
-#include <linux/mm.h>
-#include <linux/cpumask.h>
-
-#include <asm/cache.h>
-#include <asm/addrspace.h>
-#include <asm/processor.h>
-#include <asm/cacheflush.h>
-#include <asm/io.h>
-
-#define ICACHE_ENABLE	0x1
-#define DCACHE_ENABLE	0x2
-#define CACHE_ENABLE	(ICACHE_ENABLE | DCACHE_ENABLE)
-#define ICACHE_FLUSH	0x100
-#define DCACHE_FLUSH	0x200
-#define CACHE_FLUSH	(ICACHE_FLUSH | DCACHE_FLUSH)
-
-u32 __iomem *j2_ccr_base;
-
-static void j2_flush_icache(void *args)
-{
-	unsigned cpu;
-	for_each_possible_cpu(cpu)
-		__raw_writel(CACHE_ENABLE | ICACHE_FLUSH, j2_ccr_base + cpu);
-}
-
-static void j2_flush_dcache(void *args)
-{
-	unsigned cpu;
-	for_each_possible_cpu(cpu)
-		__raw_writel(CACHE_ENABLE | DCACHE_FLUSH, j2_ccr_base + cpu);
-}
-
-static void j2_flush_both(void *args)
-{
-	unsigned cpu;
-	for_each_possible_cpu(cpu)
-		__raw_writel(CACHE_ENABLE | CACHE_FLUSH, j2_ccr_base + cpu);
-}
-
-void __init j2_cache_init(void)
-{
-	if (!j2_ccr_base)
-		return;
-
-	local_flush_cache_all = j2_flush_both;
-	local_flush_cache_mm = j2_flush_both;
-	local_flush_cache_dup_mm = j2_flush_both;
-	local_flush_cache_page = j2_flush_both;
-	local_flush_cache_range = j2_flush_both;
-	local_flush_dcache_page = j2_flush_dcache;
-	local_flush_icache_range = j2_flush_icache;
-	local_flush_icache_page = j2_flush_icache;
-	local_flush_cache_sigtramp = j2_flush_icache;
-
-	pr_info("Initial J2 CCR is %.8x\n", __raw_readl(j2_ccr_base));
-}
diff --git a/arch/sh/mm/cache-sh2.c b/arch/sh/mm/cache-sh2.c
deleted file mode 100644
index f2b6cdbdf9320d..00000000000000
--- a/arch/sh/mm/cache-sh2.c
+++ /dev/null
@@ -1,90 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * arch/sh/mm/cache-sh2.c
- *
- * Copyright (C) 2002 Paul Mundt
- * Copyright (C) 2008 Yoshinori Sato
- */
-
-#include <linux/init.h>
-#include <linux/mm.h>
-
-#include <asm/cache.h>
-#include <asm/addrspace.h>
-#include <asm/processor.h>
-#include <asm/cacheflush.h>
-#include <asm/io.h>
-
-static void sh2__flush_wback_region(void *start, int size)
-{
-	unsigned long v;
-	unsigned long begin, end;
-
-	begin = (unsigned long)start & ~(L1_CACHE_BYTES-1);
-	end = ((unsigned long)start + size + L1_CACHE_BYTES-1)
-		& ~(L1_CACHE_BYTES-1);
-	for (v = begin; v < end; v+=L1_CACHE_BYTES) {
-		unsigned long addr = CACHE_OC_ADDRESS_ARRAY | (v & 0x00000ff0);
-		int way;
-		for (way = 0; way < 4; way++) {
-			unsigned long data =  __raw_readl(addr | (way << 12));
-			if ((data & CACHE_PHYSADDR_MASK) == (v & CACHE_PHYSADDR_MASK)) {
-				data &= ~SH_CACHE_UPDATED;
-				__raw_writel(data, addr | (way << 12));
-			}
-		}
-	}
-}
-
-static void sh2__flush_purge_region(void *start, int size)
-{
-	unsigned long v;
-	unsigned long begin, end;
-
-	begin = (unsigned long)start & ~(L1_CACHE_BYTES-1);
-	end = ((unsigned long)start + size + L1_CACHE_BYTES-1)
-		& ~(L1_CACHE_BYTES-1);
-
-	for (v = begin; v < end; v+=L1_CACHE_BYTES)
-		__raw_writel((v & CACHE_PHYSADDR_MASK),
-			  CACHE_OC_ADDRESS_ARRAY | (v & 0x00000ff0) | 0x00000008);
-}
-
-static void sh2__flush_invalidate_region(void *start, int size)
-{
-#ifdef CONFIG_CACHE_WRITEBACK
-	/*
-	 * SH-2 does not support individual line invalidation, only a
-	 * global invalidate.
-	 */
-	unsigned long ccr;
-	unsigned long flags;
-	local_irq_save(flags);
-	jump_to_uncached();
-
-	ccr = __raw_readl(SH_CCR);
-	ccr |= CCR_CACHE_INVALIDATE;
-	__raw_writel(ccr, SH_CCR);
-
-	back_to_cached();
-	local_irq_restore(flags);
-#else
-	unsigned long v;
-	unsigned long begin, end;
-
-	begin = (unsigned long)start & ~(L1_CACHE_BYTES-1);
-	end = ((unsigned long)start + size + L1_CACHE_BYTES-1)
-		& ~(L1_CACHE_BYTES-1);
-
-	for (v = begin; v < end; v+=L1_CACHE_BYTES)
-		__raw_writel((v & CACHE_PHYSADDR_MASK),
-			  CACHE_OC_ADDRESS_ARRAY | (v & 0x00000ff0) | 0x00000008);
-#endif
-}
-
-void __init sh2_cache_init(void)
-{
-	__flush_wback_region		= sh2__flush_wback_region;
-	__flush_purge_region		= sh2__flush_purge_region;
-	__flush_invalidate_region	= sh2__flush_invalidate_region;
-}
diff --git a/arch/sh/mm/cache-sh2a.c b/arch/sh/mm/cache-sh2a.c
deleted file mode 100644
index 4f7739e707a7e9..00000000000000
--- a/arch/sh/mm/cache-sh2a.c
+++ /dev/null
@@ -1,188 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * arch/sh/mm/cache-sh2a.c
- *
- * Copyright (C) 2008 Yoshinori Sato
- */
-
-#include <linux/init.h>
-#include <linux/mm.h>
-
-#include <asm/cache.h>
-#include <asm/addrspace.h>
-#include <asm/processor.h>
-#include <asm/cacheflush.h>
-#include <asm/io.h>
-
-/*
- * The maximum number of pages we support up to when doing ranged dcache
- * flushing. Anything exceeding this will simply flush the dcache in its
- * entirety.
- */
-#define MAX_OCACHE_PAGES	32
-#define MAX_ICACHE_PAGES	32
-
-#ifdef CONFIG_CACHE_WRITEBACK
-static void sh2a_flush_oc_line(unsigned long v, int way)
-{
-	unsigned long addr = (v & 0x000007f0) | (way << 11);
-	unsigned long data;
-
-	data = __raw_readl(CACHE_OC_ADDRESS_ARRAY | addr);
-	if ((data & CACHE_PHYSADDR_MASK) == (v & CACHE_PHYSADDR_MASK)) {
-		data &= ~SH_CACHE_UPDATED;
-		__raw_writel(data, CACHE_OC_ADDRESS_ARRAY | addr);
-	}
-}
-#endif
-
-static void sh2a_invalidate_line(unsigned long cache_addr, unsigned long v)
-{
-	/* Set associative bit to hit all ways */
-	unsigned long addr = (v & 0x000007f0) | SH_CACHE_ASSOC;
-	__raw_writel((addr & CACHE_PHYSADDR_MASK), cache_addr | addr);
-}
-
-/*
- * Write back the dirty D-caches, but not invalidate them.
- */
-static void sh2a__flush_wback_region(void *start, int size)
-{
-#ifdef CONFIG_CACHE_WRITEBACK
-	unsigned long v;
-	unsigned long begin, end;
-	unsigned long flags;
-	int nr_ways;
-
-	begin = (unsigned long)start & ~(L1_CACHE_BYTES-1);
-	end = ((unsigned long)start + size + L1_CACHE_BYTES-1)
-		& ~(L1_CACHE_BYTES-1);
-	nr_ways = current_cpu_data.dcache.ways;
-
-	local_irq_save(flags);
-	jump_to_uncached();
-
-	/* If there are too many pages then flush the entire cache */
-	if (((end - begin) >> PAGE_SHIFT) >= MAX_OCACHE_PAGES) {
-		begin = CACHE_OC_ADDRESS_ARRAY;
-		end = begin + (nr_ways * current_cpu_data.dcache.way_size);
-
-		for (v = begin; v < end; v += L1_CACHE_BYTES) {
-			unsigned long data = __raw_readl(v);
-			if (data & SH_CACHE_UPDATED)
-				__raw_writel(data & ~SH_CACHE_UPDATED, v);
-		}
-	} else {
-		int way;
-		for (way = 0; way < nr_ways; way++) {
-			for (v = begin; v < end; v += L1_CACHE_BYTES)
-				sh2a_flush_oc_line(v, way);
-		}
-	}
-
-	back_to_cached();
-	local_irq_restore(flags);
-#endif
-}
-
-/*
- * Write back the dirty D-caches and invalidate them.
- */
-static void sh2a__flush_purge_region(void *start, int size)
-{
-	unsigned long v;
-	unsigned long begin, end;
-	unsigned long flags;
-
-	begin = (unsigned long)start & ~(L1_CACHE_BYTES-1);
-	end = ((unsigned long)start + size + L1_CACHE_BYTES-1)
-		& ~(L1_CACHE_BYTES-1);
-
-	local_irq_save(flags);
-	jump_to_uncached();
-
-	for (v = begin; v < end; v+=L1_CACHE_BYTES) {
-#ifdef CONFIG_CACHE_WRITEBACK
-		int way;
-		int nr_ways = current_cpu_data.dcache.ways;
-		for (way = 0; way < nr_ways; way++)
-			sh2a_flush_oc_line(v, way);
-#endif
-		sh2a_invalidate_line(CACHE_OC_ADDRESS_ARRAY, v);
-	}
-
-	back_to_cached();
-	local_irq_restore(flags);
-}
-
-/*
- * Invalidate the D-caches, but no write back please
- */
-static void sh2a__flush_invalidate_region(void *start, int size)
-{
-	unsigned long v;
-	unsigned long begin, end;
-	unsigned long flags;
-
-	begin = (unsigned long)start & ~(L1_CACHE_BYTES-1);
-	end = ((unsigned long)start + size + L1_CACHE_BYTES-1)
-		& ~(L1_CACHE_BYTES-1);
-
-	local_irq_save(flags);
-	jump_to_uncached();
-
-	/* If there are too many pages then just blow the cache */
-	if (((end - begin) >> PAGE_SHIFT) >= MAX_OCACHE_PAGES) {
-		__raw_writel(__raw_readl(SH_CCR) | CCR_OCACHE_INVALIDATE,
-			     SH_CCR);
-	} else {
-		for (v = begin; v < end; v += L1_CACHE_BYTES)
-			sh2a_invalidate_line(CACHE_OC_ADDRESS_ARRAY, v);
-	}
-
-	back_to_cached();
-	local_irq_restore(flags);
-}
-
-/*
- * Write back the range of D-cache, and purge the I-cache.
- */
-static void sh2a_flush_icache_range(void *args)
-{
-	struct flusher_data *data = args;
-	unsigned long start, end;
-	unsigned long v;
-	unsigned long flags;
-
-	start = data->addr1 & ~(L1_CACHE_BYTES-1);
-	end = (data->addr2 + L1_CACHE_BYTES-1) & ~(L1_CACHE_BYTES-1);
-
-#ifdef CONFIG_CACHE_WRITEBACK
-	sh2a__flush_wback_region((void *)start, end-start);
-#endif
-
-	local_irq_save(flags);
-	jump_to_uncached();
-
-	/* I-Cache invalidate */
-	/* If there are too many pages then just blow the cache */
-	if (((end - start) >> PAGE_SHIFT) >= MAX_ICACHE_PAGES) {
-		__raw_writel(__raw_readl(SH_CCR) | CCR_ICACHE_INVALIDATE,
-			     SH_CCR);
-	} else {
-		for (v = start; v < end; v += L1_CACHE_BYTES)
-			sh2a_invalidate_line(CACHE_IC_ADDRESS_ARRAY, v);
-	}
-
-	back_to_cached();
-	local_irq_restore(flags);
-}
-
-void __init sh2a_cache_init(void)
-{
-	local_flush_icache_range	= sh2a_flush_icache_range;
-
-	__flush_wback_region		= sh2a__flush_wback_region;
-	__flush_purge_region		= sh2a__flush_purge_region;
-	__flush_invalidate_region	= sh2a__flush_invalidate_region;
-}
diff --git a/arch/sh/mm/cache-sh3.c b/arch/sh/mm/cache-sh3.c
deleted file mode 100644
index bc595982d396ee..00000000000000
--- a/arch/sh/mm/cache-sh3.c
+++ /dev/null
@@ -1,102 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * arch/sh/mm/cache-sh3.c
- *
- * Copyright (C) 1999, 2000  Niibe Yutaka
- * Copyright (C) 2002 Paul Mundt
- */
-
-#include <linux/init.h>
-#include <linux/mman.h>
-#include <linux/mm.h>
-#include <linux/threads.h>
-#include <asm/addrspace.h>
-#include <asm/page.h>
-#include <asm/processor.h>
-#include <asm/cache.h>
-#include <asm/io.h>
-#include <linux/uaccess.h>
-#include <asm/mmu_context.h>
-#include <asm/cacheflush.h>
-
-/*
- * Write back the dirty D-caches, but not invalidate them.
- *
- * Is this really worth it, or should we just alias this routine
- * to __flush_purge_region too?
- *
- * START: Virtual Address (U0, P1, or P3)
- * SIZE: Size of the region.
- */
-
-static void sh3__flush_wback_region(void *start, int size)
-{
-	unsigned long v, j;
-	unsigned long begin, end;
-	unsigned long flags;
-
-	begin = (unsigned long)start & ~(L1_CACHE_BYTES-1);
-	end = ((unsigned long)start + size + L1_CACHE_BYTES-1)
-		& ~(L1_CACHE_BYTES-1);
-
-	for (v = begin; v < end; v+=L1_CACHE_BYTES) {
-		unsigned long addrstart = CACHE_OC_ADDRESS_ARRAY;
-		for (j = 0; j < current_cpu_data.dcache.ways; j++) {
-			unsigned long data, addr, p;
-
-			p = __pa(v);
-			addr = addrstart | (v & current_cpu_data.dcache.entry_mask);
-			local_irq_save(flags);
-			data = __raw_readl(addr);
-
-			if ((data & CACHE_PHYSADDR_MASK) ==
-			    (p & CACHE_PHYSADDR_MASK)) {
-				data &= ~SH_CACHE_UPDATED;
-				__raw_writel(data, addr);
-				local_irq_restore(flags);
-				break;
-			}
-			local_irq_restore(flags);
-			addrstart += current_cpu_data.dcache.way_incr;
-		}
-	}
-}
-
-/*
- * Write back the dirty D-caches and invalidate them.
- *
- * START: Virtual Address (U0, P1, or P3)
- * SIZE: Size of the region.
- */
-static void sh3__flush_purge_region(void *start, int size)
-{
-	unsigned long v;
-	unsigned long begin, end;
-
-	begin = (unsigned long)start & ~(L1_CACHE_BYTES-1);
-	end = ((unsigned long)start + size + L1_CACHE_BYTES-1)
-		& ~(L1_CACHE_BYTES-1);
-
-	for (v = begin; v < end; v+=L1_CACHE_BYTES) {
-		unsigned long data, addr;
-
-		data = (v & 0xfffffc00); /* _Virtual_ address, ~U, ~V */
-		addr = CACHE_OC_ADDRESS_ARRAY |
-			(v & current_cpu_data.dcache.entry_mask) | SH_CACHE_ASSOC;
-		__raw_writel(data, addr);
-	}
-}
-
-void __init sh3_cache_init(void)
-{
-	__flush_wback_region = sh3__flush_wback_region;
-	__flush_purge_region = sh3__flush_purge_region;
-
-	/*
-	 * No write back please
-	 *
-	 * Except I don't think there's any way to avoid the writeback.
-	 * So we just alias it to sh3__flush_purge_region(). dwmw2.
-	 */
-	__flush_invalidate_region = sh3__flush_purge_region;
-}
diff --git a/arch/sh/mm/cache-sh4.c b/arch/sh/mm/cache-sh4.c
deleted file mode 100644
index 72c2e1b46c0838..00000000000000
--- a/arch/sh/mm/cache-sh4.c
+++ /dev/null
@@ -1,390 +0,0 @@
-/*
- * arch/sh/mm/cache-sh4.c
- *
- * Copyright (C) 1999, 2000, 2002  Niibe Yutaka
- * Copyright (C) 2001 - 2009  Paul Mundt
- * Copyright (C) 2003  Richard Curnow
- * Copyright (c) 2007 STMicroelectronics (R&D) Ltd.
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- */
-#include <linux/init.h>
-#include <linux/mm.h>
-#include <linux/io.h>
-#include <linux/mutex.h>
-#include <linux/fs.h>
-#include <linux/highmem.h>
-#include <linux/pagemap.h>
-#include <asm/mmu_context.h>
-#include <asm/cache_insns.h>
-#include <asm/cacheflush.h>
-
-/*
- * The maximum number of pages we support up to when doing ranged dcache
- * flushing. Anything exceeding this will simply flush the dcache in its
- * entirety.
- */
-#define MAX_ICACHE_PAGES	32
-
-static void __flush_cache_one(unsigned long addr, unsigned long phys,
-			       unsigned long exec_offset);
-
-/*
- * Write back the range of D-cache, and purge the I-cache.
- *
- * Called from kernel/module.c:sys_init_module and routine for a.out format,
- * signal handler code and kprobes code
- */
-static void sh4_flush_icache_range(void *args)
-{
-	struct flusher_data *data = args;
-	unsigned long start, end;
-	unsigned long flags, v;
-	int i;
-
-	start = data->addr1;
-	end = data->addr2;
-
-	/* If there are too many pages then just blow away the caches */
-	if (((end - start) >> PAGE_SHIFT) >= MAX_ICACHE_PAGES) {
-		local_flush_cache_all(NULL);
-		return;
-	}
-
-	/*
-	 * Selectively flush d-cache then invalidate the i-cache.
-	 * This is inefficient, so only use this for small ranges.
-	 */
-	start &= ~(L1_CACHE_BYTES-1);
-	end += L1_CACHE_BYTES-1;
-	end &= ~(L1_CACHE_BYTES-1);
-
-	local_irq_save(flags);
-	jump_to_uncached();
-
-	for (v = start; v < end; v += L1_CACHE_BYTES) {
-		unsigned long icacheaddr;
-		int j, n;
-
-		__ocbwb(v);
-
-		icacheaddr = CACHE_IC_ADDRESS_ARRAY | (v &
-				cpu_data->icache.entry_mask);
-
-		/* Clear i-cache line valid-bit */
-		n = boot_cpu_data.icache.n_aliases;
-		for (i = 0; i < cpu_data->icache.ways; i++) {
-			for (j = 0; j < n; j++)
-				__raw_writel(0, icacheaddr + (j * PAGE_SIZE));
-			icacheaddr += cpu_data->icache.way_incr;
-		}
-	}
-
-	back_to_cached();
-	local_irq_restore(flags);
-}
-
-static inline void flush_cache_one(unsigned long start, unsigned long phys)
-{
-	unsigned long flags, exec_offset = 0;
-
-	/*
-	 * All types of SH-4 require PC to be uncached to operate on the I-cache.
-	 * Some types of SH-4 require PC to be uncached to operate on the D-cache.
-	 */
-	if ((boot_cpu_data.flags & CPU_HAS_P2_FLUSH_BUG) ||
-	    (start < CACHE_OC_ADDRESS_ARRAY))
-		exec_offset = cached_to_uncached;
-
-	local_irq_save(flags);
-	__flush_cache_one(start, phys, exec_offset);
-	local_irq_restore(flags);
-}
-
-/*
- * Write back & invalidate the D-cache of the page.
- * (To avoid "alias" issues)
- */
-static void sh4_flush_dcache_page(void *arg)
-{
-	struct page *page = arg;
-	unsigned long addr = (unsigned long)page_address(page);
-#ifndef CONFIG_SMP
-	struct address_space *mapping = page_mapping_file(page);
-
-	if (mapping && !mapping_mapped(mapping))
-		clear_bit(PG_dcache_clean, &page->flags);
-	else
-#endif
-		flush_cache_one(CACHE_OC_ADDRESS_ARRAY |
-				(addr & shm_align_mask), page_to_phys(page));
-
-	wmb();
-}
-
-/* TODO: Selective icache invalidation through IC address array.. */
-static void flush_icache_all(void)
-{
-	unsigned long flags, ccr;
-
-	local_irq_save(flags);
-	jump_to_uncached();
-
-	/* Flush I-cache */
-	ccr = __raw_readl(SH_CCR);
-	ccr |= CCR_CACHE_ICI;
-	__raw_writel(ccr, SH_CCR);
-
-	/*
-	 * back_to_cached() will take care of the barrier for us, don't add
-	 * another one!
-	 */
-
-	back_to_cached();
-	local_irq_restore(flags);
-}
-
-static void flush_dcache_all(void)
-{
-	unsigned long addr, end_addr, entry_offset;
-
-	end_addr = CACHE_OC_ADDRESS_ARRAY +
-		(current_cpu_data.dcache.sets <<
-		 current_cpu_data.dcache.entry_shift) *
-			current_cpu_data.dcache.ways;
-
-	entry_offset = 1 << current_cpu_data.dcache.entry_shift;
-
-	for (addr = CACHE_OC_ADDRESS_ARRAY; addr < end_addr; ) {
-		__raw_writel(0, addr); addr += entry_offset;
-		__raw_writel(0, addr); addr += entry_offset;
-		__raw_writel(0, addr); addr += entry_offset;
-		__raw_writel(0, addr); addr += entry_offset;
-		__raw_writel(0, addr); addr += entry_offset;
-		__raw_writel(0, addr); addr += entry_offset;
-		__raw_writel(0, addr); addr += entry_offset;
-		__raw_writel(0, addr); addr += entry_offset;
-	}
-}
-
-static void sh4_flush_cache_all(void *unused)
-{
-	flush_dcache_all();
-	flush_icache_all();
-}
-
-/*
- * Note : (RPC) since the caches are physically tagged, the only point
- * of flush_cache_mm for SH-4 is to get rid of aliases from the
- * D-cache.  The assumption elsewhere, e.g. flush_cache_range, is that
- * lines can stay resident so long as the virtual address they were
- * accessed with (hence cache set) is in accord with the physical
- * address (i.e. tag).  It's no different here.
- *
- * Caller takes mm->mmap_lock.
- */
-static void sh4_flush_cache_mm(void *arg)
-{
-	struct mm_struct *mm = arg;
-
-	if (cpu_context(smp_processor_id(), mm) == NO_CONTEXT)
-		return;
-
-	flush_dcache_all();
-}
-
-/*
- * Write back and invalidate I/D-caches for the page.
- *
- * ADDR: Virtual Address (U0 address)
- * PFN: Physical page number
- */
-static void sh4_flush_cache_page(void *args)
-{
-	struct flusher_data *data = args;
-	struct vm_area_struct *vma;
-	struct page *page;
-	unsigned long address, pfn, phys;
-	int map_coherent = 0;
-	pmd_t *pmd;
-	pte_t *pte;
-	void *vaddr;
-
-	vma = data->vma;
-	address = data->addr1 & PAGE_MASK;
-	pfn = data->addr2;
-	phys = pfn << PAGE_SHIFT;
-	page = pfn_to_page(pfn);
-
-	if (cpu_context(smp_processor_id(), vma->vm_mm) == NO_CONTEXT)
-		return;
-
-	pmd = pmd_off(vma->vm_mm, address);
-	pte = pte_offset_kernel(pmd, address);
-
-	/* If the page isn't present, there is nothing to do here. */
-	if (!(pte_val(*pte) & _PAGE_PRESENT))
-		return;
-
-	if ((vma->vm_mm == current->active_mm))
-		vaddr = NULL;
-	else {
-		/*
-		 * Use kmap_coherent or kmap_atomic to do flushes for
-		 * another ASID than the current one.
-		 */
-		map_coherent = (current_cpu_data.dcache.n_aliases &&
-			test_bit(PG_dcache_clean, &page->flags) &&
-			page_mapcount(page));
-		if (map_coherent)
-			vaddr = kmap_coherent(page, address);
-		else
-			vaddr = kmap_atomic(page);
-
-		address = (unsigned long)vaddr;
-	}
-
-	flush_cache_one(CACHE_OC_ADDRESS_ARRAY |
-			(address & shm_align_mask), phys);
-
-	if (vma->vm_flags & VM_EXEC)
-		flush_icache_all();
-
-	if (vaddr) {
-		if (map_coherent)
-			kunmap_coherent(vaddr);
-		else
-			kunmap_atomic(vaddr);
-	}
-}
-
-/*
- * Write back and invalidate D-caches.
- *
- * START, END: Virtual Address (U0 address)
- *
- * NOTE: We need to flush the _physical_ page entry.
- * Flushing the cache lines for U0 only isn't enough.
- * We need to flush for P1 too, which may contain aliases.
- */
-static void sh4_flush_cache_range(void *args)
-{
-	struct flusher_data *data = args;
-	struct vm_area_struct *vma;
-	unsigned long start, end;
-
-	vma = data->vma;
-	start = data->addr1;
-	end = data->addr2;
-
-	if (cpu_context(smp_processor_id(), vma->vm_mm) == NO_CONTEXT)
-		return;
-
-	/*
-	 * If cache is only 4k-per-way, there are never any 'aliases'.  Since
-	 * the cache is physically tagged, the data can just be left in there.
-	 */
-	if (boot_cpu_data.dcache.n_aliases == 0)
-		return;
-
-	flush_dcache_all();
-
-	if (vma->vm_flags & VM_EXEC)
-		flush_icache_all();
-}
-
-/**
- * __flush_cache_one
- *
- * @addr:  address in memory mapped cache array
- * @phys:  P1 address to flush (has to match tags if addr has 'A' bit
- *         set i.e. associative write)
- * @exec_offset: set to 0x20000000 if flush has to be executed from P2
- *               region else 0x0
- *
- * The offset into the cache array implied by 'addr' selects the
- * 'colour' of the virtual address range that will be flushed.  The
- * operation (purge/write-back) is selected by the lower 2 bits of
- * 'phys'.
- */
-static void __flush_cache_one(unsigned long addr, unsigned long phys,
-			       unsigned long exec_offset)
-{
-	int way_count;
-	unsigned long base_addr = addr;
-	struct cache_info *dcache;
-	unsigned long way_incr;
-	unsigned long a, ea, p;
-	unsigned long temp_pc;
-
-	dcache = &boot_cpu_data.dcache;
-	/* Write this way for better assembly. */
-	way_count = dcache->ways;
-	way_incr = dcache->way_incr;
-
-	/*
-	 * Apply exec_offset (i.e. branch to P2 if required.).
-	 *
-	 * FIXME:
-	 *
-	 *	If I write "=r" for the (temp_pc), it puts this in r6 hence
-	 *	trashing exec_offset before it's been added on - why?  Hence
-	 *	"=&r" as a 'workaround'
-	 */
-	asm volatile("mov.l 1f, %0\n\t"
-		     "add   %1, %0\n\t"
-		     "jmp   @%0\n\t"
-		     "nop\n\t"
-		     ".balign 4\n\t"
-		     "1:  .long 2f\n\t"
-		     "2:\n" : "=&r" (temp_pc) : "r" (exec_offset));
-
-	/*
-	 * We know there will be >=1 iteration, so write as do-while to avoid
-	 * pointless nead-of-loop check for 0 iterations.
-	 */
-	do {
-		ea = base_addr + PAGE_SIZE;
-		a = base_addr;
-		p = phys;
-
-		do {
-			*(volatile unsigned long *)a = p;
-			/*
-			 * Next line: intentionally not p+32, saves an add, p
-			 * will do since only the cache tag bits need to
-			 * match.
-			 */
-			*(volatile unsigned long *)(a+32) = p;
-			a += 64;
-			p += 64;
-		} while (a < ea);
-
-		base_addr += way_incr;
-	} while (--way_count != 0);
-}
-
-extern void __weak sh4__flush_region_init(void);
-
-/*
- * SH-4 has virtually indexed and physically tagged cache.
- */
-void __init sh4_cache_init(void)
-{
-	printk("PVR=%08x CVR=%08x PRR=%08x\n",
-		__raw_readl(CCN_PVR),
-		__raw_readl(CCN_CVR),
-		__raw_readl(CCN_PRR));
-
-	local_flush_icache_range	= sh4_flush_icache_range;
-	local_flush_dcache_page		= sh4_flush_dcache_page;
-	local_flush_cache_all		= sh4_flush_cache_all;
-	local_flush_cache_mm		= sh4_flush_cache_mm;
-	local_flush_cache_dup_mm	= sh4_flush_cache_mm;
-	local_flush_cache_page		= sh4_flush_cache_page;
-	local_flush_cache_range		= sh4_flush_cache_range;
-
-	sh4__flush_region_init();
-}
diff --git a/arch/sh/mm/cache-sh7705.c b/arch/sh/mm/cache-sh7705.c
deleted file mode 100644
index 9b63a53a5e46fe..00000000000000
--- a/arch/sh/mm/cache-sh7705.c
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
- * arch/sh/mm/cache-sh7705.c
- *
- * Copyright (C) 1999, 2000  Niibe Yutaka
- * Copyright (C) 2004  Alex Song
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- */
-#include <linux/init.h>
-#include <linux/mman.h>
-#include <linux/mm.h>
-#include <linux/fs.h>
-#include <linux/pagemap.h>
-#include <linux/threads.h>
-#include <asm/addrspace.h>
-#include <asm/page.h>
-#include <asm/processor.h>
-#include <asm/cache.h>
-#include <asm/io.h>
-#include <linux/uaccess.h>
-#include <asm/mmu_context.h>
-#include <asm/cacheflush.h>
-
-/*
- * The 32KB cache on the SH7705 suffers from the same synonym problem
- * as SH4 CPUs
- */
-static inline void cache_wback_all(void)
-{
-	unsigned long ways, waysize, addrstart;
-
-	ways = current_cpu_data.dcache.ways;
-	waysize = current_cpu_data.dcache.sets;
-	waysize <<= current_cpu_data.dcache.entry_shift;
-
-	addrstart = CACHE_OC_ADDRESS_ARRAY;
-
-	do {
-		unsigned long addr;
-
-		for (addr = addrstart;
-		     addr < addrstart + waysize;
-		     addr += current_cpu_data.dcache.linesz) {
-			unsigned long data;
-			int v = SH_CACHE_UPDATED | SH_CACHE_VALID;
-
-			data = __raw_readl(addr);
-
-			if ((data & v) == v)
-				__raw_writel(data & ~v, addr);
-
-		}
-
-		addrstart += current_cpu_data.dcache.way_incr;
-	} while (--ways);
-}
-
-/*
- * Write back the range of D-cache, and purge the I-cache.
- *
- * Called from kernel/module.c:sys_init_module and routine for a.out format.
- */
-static void sh7705_flush_icache_range(void *args)
-{
-	struct flusher_data *data = args;
-	unsigned long start, end;
-
-	start = data->addr1;
-	end = data->addr2;
-
-	__flush_wback_region((void *)start, end - start);
-}
-
-/*
- * Writeback&Invalidate the D-cache of the page
- */
-static void __flush_dcache_page(unsigned long phys)
-{
-	unsigned long ways, waysize, addrstart;
-	unsigned long flags;
-
-	phys |= SH_CACHE_VALID;
-
-	/*
-	 * Here, phys is the physical address of the page. We check all the
-	 * tags in the cache for those with the same page number as this page
-	 * (by masking off the lowest 2 bits of the 19-bit tag; these bits are
-	 * derived from the offset within in the 4k page). Matching valid
-	 * entries are invalidated.
-	 *
-	 * Since 2 bits of the cache index are derived from the virtual page
-	 * number, knowing this would reduce the number of cache entries to be
-	 * searched by a factor of 4. However this function exists to deal with
-	 * potential cache aliasing, therefore the optimisation is probably not
-	 * possible.
-	 */
-	local_irq_save(flags);
-	jump_to_uncached();
-
-	ways = current_cpu_data.dcache.ways;
-	waysize = current_cpu_data.dcache.sets;
-	waysize <<= current_cpu_data.dcache.entry_shift;
-
-	addrstart = CACHE_OC_ADDRESS_ARRAY;
-
-	do {
-		unsigned long addr;
-
-		for (addr = addrstart;
-		     addr < addrstart + waysize;
-		     addr += current_cpu_data.dcache.linesz) {
-			unsigned long data;
-
-			data = __raw_readl(addr) & (0x1ffffC00 | SH_CACHE_VALID);
-		        if (data == phys) {
-				data &= ~(SH_CACHE_VALID | SH_CACHE_UPDATED);
-				__raw_writel(data, addr);
-			}
-		}
-
-		addrstart += current_cpu_data.dcache.way_incr;
-	} while (--ways);
-
-	back_to_cached();
-	local_irq_restore(flags);
-}
-
-/*
- * Write back & invalidate the D-cache of the page.
- * (To avoid "alias" issues)
- */
-static void sh7705_flush_dcache_page(void *arg)
-{
-	struct page *page = arg;
-	struct address_space *mapping = page_mapping_file(page);
-
-	if (mapping && !mapping_mapped(mapping))
-		clear_bit(PG_dcache_clean, &page->flags);
-	else
-		__flush_dcache_page(__pa(page_address(page)));
-}
-
-static void sh7705_flush_cache_all(void *args)
-{
-	unsigned long flags;
-
-	local_irq_save(flags);
-	jump_to_uncached();
-
-	cache_wback_all();
-	back_to_cached();
-	local_irq_restore(flags);
-}
-
-/*
- * Write back and invalidate I/D-caches for the page.
- *
- * ADDRESS: Virtual Address (U0 address)
- */
-static void sh7705_flush_cache_page(void *args)
-{
-	struct flusher_data *data = args;
-	unsigned long pfn = data->addr2;
-
-	__flush_dcache_page(pfn << PAGE_SHIFT);
-}
-
-/*
- * This is called when a page-cache page is about to be mapped into a
- * user process' address space.  It offers an opportunity for a
- * port to ensure d-cache/i-cache coherency if necessary.
- *
- * Not entirely sure why this is necessary on SH3 with 32K cache but
- * without it we get occasional "Memory fault" when loading a program.
- */
-static void sh7705_flush_icache_page(void *page)
-{
-	__flush_purge_region(page_address(page), PAGE_SIZE);
-}
-
-void __init sh7705_cache_init(void)
-{
-	local_flush_icache_range	= sh7705_flush_icache_range;
-	local_flush_dcache_page		= sh7705_flush_dcache_page;
-	local_flush_cache_all		= sh7705_flush_cache_all;
-	local_flush_cache_mm		= sh7705_flush_cache_all;
-	local_flush_cache_dup_mm	= sh7705_flush_cache_all;
-	local_flush_cache_range		= sh7705_flush_cache_all;
-	local_flush_cache_page		= sh7705_flush_cache_page;
-	local_flush_icache_page		= sh7705_flush_icache_page;
-}
diff --git a/arch/sh/mm/cache-shx3.c b/arch/sh/mm/cache-shx3.c
deleted file mode 100644
index 24c58b7dc02265..00000000000000
--- a/arch/sh/mm/cache-shx3.c
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * arch/sh/mm/cache-shx3.c - SH-X3 optimized cache ops
- *
- * Copyright (C) 2010  Paul Mundt
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/io.h>
-#include <asm/cache.h>
-
-#define CCR_CACHE_SNM	0x40000		/* Hardware-assisted synonym avoidance */
-#define CCR_CACHE_IBE	0x1000000	/* ICBI broadcast */
-
-void __init shx3_cache_init(void)
-{
-	unsigned int ccr;
-
-	ccr = __raw_readl(SH_CCR);
-
-	/*
-	 * If we've got cache aliases, resolve them in hardware.
-	 */
-	if (boot_cpu_data.dcache.n_aliases || boot_cpu_data.icache.n_aliases) {
-		ccr |= CCR_CACHE_SNM;
-
-		boot_cpu_data.icache.n_aliases = 0;
-		boot_cpu_data.dcache.n_aliases = 0;
-
-		pr_info("Enabling hardware synonym avoidance\n");
-	}
-
-#ifdef CONFIG_SMP
-	/*
-	 * Broadcast I-cache block invalidations by default.
-	 */
-	ccr |= CCR_CACHE_IBE;
-#endif
-
-	writel_uncached(ccr, SH_CCR);
-}
diff --git a/arch/sh/mm/cache.c b/arch/sh/mm/cache.c
deleted file mode 100644
index 3aef78ceb82090..00000000000000
--- a/arch/sh/mm/cache.c
+++ /dev/null
@@ -1,360 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * arch/sh/mm/cache.c
- *
- * Copyright (C) 1999, 2000, 2002  Niibe Yutaka
- * Copyright (C) 2002 - 2010  Paul Mundt
- */
-#include <linux/mm.h>
-#include <linux/init.h>
-#include <linux/mutex.h>
-#include <linux/fs.h>
-#include <linux/smp.h>
-#include <linux/highmem.h>
-#include <linux/module.h>
-#include <asm/mmu_context.h>
-#include <asm/cacheflush.h>
-
-void (*local_flush_cache_all)(void *args) = cache_noop;
-void (*local_flush_cache_mm)(void *args) = cache_noop;
-void (*local_flush_cache_dup_mm)(void *args) = cache_noop;
-void (*local_flush_cache_page)(void *args) = cache_noop;
-void (*local_flush_cache_range)(void *args) = cache_noop;
-void (*local_flush_dcache_page)(void *args) = cache_noop;
-void (*local_flush_icache_range)(void *args) = cache_noop;
-void (*local_flush_icache_page)(void *args) = cache_noop;
-void (*local_flush_cache_sigtramp)(void *args) = cache_noop;
-
-void (*__flush_wback_region)(void *start, int size);
-EXPORT_SYMBOL(__flush_wback_region);
-void (*__flush_purge_region)(void *start, int size);
-EXPORT_SYMBOL(__flush_purge_region);
-void (*__flush_invalidate_region)(void *start, int size);
-EXPORT_SYMBOL(__flush_invalidate_region);
-
-static inline void noop__flush_region(void *start, int size)
-{
-}
-
-static inline void cacheop_on_each_cpu(void (*func) (void *info), void *info,
-                                   int wait)
-{
-	preempt_disable();
-
-	/* Needing IPI for cross-core flush is SHX3-specific. */
-#ifdef CONFIG_CPU_SHX3
-	/*
-	 * It's possible that this gets called early on when IRQs are
-	 * still disabled due to ioremapping by the boot CPU, so don't
-	 * even attempt IPIs unless there are other CPUs online.
-	 */
-	if (num_online_cpus() > 1)
-		smp_call_function(func, info, wait);
-#endif
-
-	func(info);
-
-	preempt_enable();
-}
-
-void copy_to_user_page(struct vm_area_struct *vma, struct page *page,
-		       unsigned long vaddr, void *dst, const void *src,
-		       unsigned long len)
-{
-	if (boot_cpu_data.dcache.n_aliases && page_mapcount(page) &&
-	    test_bit(PG_dcache_clean, &page->flags)) {
-		void *vto = kmap_coherent(page, vaddr) + (vaddr & ~PAGE_MASK);
-		memcpy(vto, src, len);
-		kunmap_coherent(vto);
-	} else {
-		memcpy(dst, src, len);
-		if (boot_cpu_data.dcache.n_aliases)
-			clear_bit(PG_dcache_clean, &page->flags);
-	}
-
-	if (vma->vm_flags & VM_EXEC)
-		flush_cache_page(vma, vaddr, page_to_pfn(page));
-}
-
-void copy_from_user_page(struct vm_area_struct *vma, struct page *page,
-			 unsigned long vaddr, void *dst, const void *src,
-			 unsigned long len)
-{
-	if (boot_cpu_data.dcache.n_aliases && page_mapcount(page) &&
-	    test_bit(PG_dcache_clean, &page->flags)) {
-		void *vfrom = kmap_coherent(page, vaddr) + (vaddr & ~PAGE_MASK);
-		memcpy(dst, vfrom, len);
-		kunmap_coherent(vfrom);
-	} else {
-		memcpy(dst, src, len);
-		if (boot_cpu_data.dcache.n_aliases)
-			clear_bit(PG_dcache_clean, &page->flags);
-	}
-}
-
-void copy_user_highpage(struct page *to, struct page *from,
-			unsigned long vaddr, struct vm_area_struct *vma)
-{
-	void *vfrom, *vto;
-
-	vto = kmap_atomic(to);
-
-	if (boot_cpu_data.dcache.n_aliases && page_mapcount(from) &&
-	    test_bit(PG_dcache_clean, &from->flags)) {
-		vfrom = kmap_coherent(from, vaddr);
-		copy_page(vto, vfrom);
-		kunmap_coherent(vfrom);
-	} else {
-		vfrom = kmap_atomic(from);
-		copy_page(vto, vfrom);
-		kunmap_atomic(vfrom);
-	}
-
-	if (pages_do_alias((unsigned long)vto, vaddr & PAGE_MASK) ||
-	    (vma->vm_flags & VM_EXEC))
-		__flush_purge_region(vto, PAGE_SIZE);
-
-	kunmap_atomic(vto);
-	/* Make sure this page is cleared on other CPU's too before using it */
-	smp_wmb();
-}
-EXPORT_SYMBOL(copy_user_highpage);
-
-void clear_user_highpage(struct page *page, unsigned long vaddr)
-{
-	void *kaddr = kmap_atomic(page);
-
-	clear_page(kaddr);
-
-	if (pages_do_alias((unsigned long)kaddr, vaddr & PAGE_MASK))
-		__flush_purge_region(kaddr, PAGE_SIZE);
-
-	kunmap_atomic(kaddr);
-}
-EXPORT_SYMBOL(clear_user_highpage);
-
-void __update_cache(struct vm_area_struct *vma,
-		    unsigned long address, pte_t pte)
-{
-	struct page *page;
-	unsigned long pfn = pte_pfn(pte);
-
-	if (!boot_cpu_data.dcache.n_aliases)
-		return;
-
-	page = pfn_to_page(pfn);
-	if (pfn_valid(pfn)) {
-		int dirty = !test_and_set_bit(PG_dcache_clean, &page->flags);
-		if (dirty)
-			__flush_purge_region(page_address(page), PAGE_SIZE);
-	}
-}
-
-void __flush_anon_page(struct page *page, unsigned long vmaddr)
-{
-	unsigned long addr = (unsigned long) page_address(page);
-
-	if (pages_do_alias(addr, vmaddr)) {
-		if (boot_cpu_data.dcache.n_aliases && page_mapcount(page) &&
-		    test_bit(PG_dcache_clean, &page->flags)) {
-			void *kaddr;
-
-			kaddr = kmap_coherent(page, vmaddr);
-			/* XXX.. For now kunmap_coherent() does a purge */
-			/* __flush_purge_region((void *)kaddr, PAGE_SIZE); */
-			kunmap_coherent(kaddr);
-		} else
-			__flush_purge_region((void *)addr, PAGE_SIZE);
-	}
-}
-
-void flush_cache_all(void)
-{
-	cacheop_on_each_cpu(local_flush_cache_all, NULL, 1);
-}
-EXPORT_SYMBOL(flush_cache_all);
-
-void flush_cache_mm(struct mm_struct *mm)
-{
-	if (boot_cpu_data.dcache.n_aliases == 0)
-		return;
-
-	cacheop_on_each_cpu(local_flush_cache_mm, mm, 1);
-}
-
-void flush_cache_dup_mm(struct mm_struct *mm)
-{
-	if (boot_cpu_data.dcache.n_aliases == 0)
-		return;
-
-	cacheop_on_each_cpu(local_flush_cache_dup_mm, mm, 1);
-}
-
-void flush_cache_page(struct vm_area_struct *vma, unsigned long addr,
-		      unsigned long pfn)
-{
-	struct flusher_data data;
-
-	data.vma = vma;
-	data.addr1 = addr;
-	data.addr2 = pfn;
-
-	cacheop_on_each_cpu(local_flush_cache_page, (void *)&data, 1);
-}
-
-void flush_cache_range(struct vm_area_struct *vma, unsigned long start,
-		       unsigned long end)
-{
-	struct flusher_data data;
-
-	data.vma = vma;
-	data.addr1 = start;
-	data.addr2 = end;
-
-	cacheop_on_each_cpu(local_flush_cache_range, (void *)&data, 1);
-}
-EXPORT_SYMBOL(flush_cache_range);
-
-void flush_dcache_page(struct page *page)
-{
-	cacheop_on_each_cpu(local_flush_dcache_page, page, 1);
-}
-EXPORT_SYMBOL(flush_dcache_page);
-
-void flush_icache_range(unsigned long start, unsigned long end)
-{
-	struct flusher_data data;
-
-	data.vma = NULL;
-	data.addr1 = start;
-	data.addr2 = end;
-
-	cacheop_on_each_cpu(local_flush_icache_range, (void *)&data, 1);
-}
-EXPORT_SYMBOL(flush_icache_range);
-
-void flush_icache_page(struct vm_area_struct *vma, struct page *page)
-{
-	/* Nothing uses the VMA, so just pass the struct page along */
-	cacheop_on_each_cpu(local_flush_icache_page, page, 1);
-}
-
-void flush_cache_sigtramp(unsigned long address)
-{
-	cacheop_on_each_cpu(local_flush_cache_sigtramp, (void *)address, 1);
-}
-
-static void compute_alias(struct cache_info *c)
-{
-#ifdef CONFIG_MMU
-	c->alias_mask = ((c->sets - 1) << c->entry_shift) & ~(PAGE_SIZE - 1);
-#else
-	c->alias_mask = 0;
-#endif
-	c->n_aliases = c->alias_mask ? (c->alias_mask >> PAGE_SHIFT) + 1 : 0;
-}
-
-static void __init emit_cache_params(void)
-{
-	printk(KERN_NOTICE "I-cache : n_ways=%d n_sets=%d way_incr=%d\n",
-		boot_cpu_data.icache.ways,
-		boot_cpu_data.icache.sets,
-		boot_cpu_data.icache.way_incr);
-	printk(KERN_NOTICE "I-cache : entry_mask=0x%08x alias_mask=0x%08x n_aliases=%d\n",
-		boot_cpu_data.icache.entry_mask,
-		boot_cpu_data.icache.alias_mask,
-		boot_cpu_data.icache.n_aliases);
-	printk(KERN_NOTICE "D-cache : n_ways=%d n_sets=%d way_incr=%d\n",
-		boot_cpu_data.dcache.ways,
-		boot_cpu_data.dcache.sets,
-		boot_cpu_data.dcache.way_incr);
-	printk(KERN_NOTICE "D-cache : entry_mask=0x%08x alias_mask=0x%08x n_aliases=%d\n",
-		boot_cpu_data.dcache.entry_mask,
-		boot_cpu_data.dcache.alias_mask,
-		boot_cpu_data.dcache.n_aliases);
-
-	/*
-	 * Emit Secondary Cache parameters if the CPU has a probed L2.
-	 */
-	if (boot_cpu_data.flags & CPU_HAS_L2_CACHE) {
-		printk(KERN_NOTICE "S-cache : n_ways=%d n_sets=%d way_incr=%d\n",
-			boot_cpu_data.scache.ways,
-			boot_cpu_data.scache.sets,
-			boot_cpu_data.scache.way_incr);
-		printk(KERN_NOTICE "S-cache : entry_mask=0x%08x alias_mask=0x%08x n_aliases=%d\n",
-			boot_cpu_data.scache.entry_mask,
-			boot_cpu_data.scache.alias_mask,
-			boot_cpu_data.scache.n_aliases);
-	}
-}
-
-void __init cpu_cache_init(void)
-{
-	unsigned int cache_disabled = 0;
-
-#ifdef SH_CCR
-	cache_disabled = !(__raw_readl(SH_CCR) & CCR_CACHE_ENABLE);
-#endif
-
-	compute_alias(&boot_cpu_data.icache);
-	compute_alias(&boot_cpu_data.dcache);
-	compute_alias(&boot_cpu_data.scache);
-
-	__flush_wback_region		= noop__flush_region;
-	__flush_purge_region		= noop__flush_region;
-	__flush_invalidate_region	= noop__flush_region;
-
-	/*
-	 * No flushing is necessary in the disabled cache case so we can
-	 * just keep the noop functions in local_flush_..() and __flush_..()
-	 */
-	if (unlikely(cache_disabled))
-		goto skip;
-
-	if (boot_cpu_data.type == CPU_J2) {
-		extern void __weak j2_cache_init(void);
-
-		j2_cache_init();
-	} else if (boot_cpu_data.family == CPU_FAMILY_SH2) {
-		extern void __weak sh2_cache_init(void);
-
-		sh2_cache_init();
-	}
-
-	if (boot_cpu_data.family == CPU_FAMILY_SH2A) {
-		extern void __weak sh2a_cache_init(void);
-
-		sh2a_cache_init();
-	}
-
-	if (boot_cpu_data.family == CPU_FAMILY_SH3) {
-		extern void __weak sh3_cache_init(void);
-
-		sh3_cache_init();
-
-		if ((boot_cpu_data.type == CPU_SH7705) &&
-		    (boot_cpu_data.dcache.sets == 512)) {
-			extern void __weak sh7705_cache_init(void);
-
-			sh7705_cache_init();
-		}
-	}
-
-	if ((boot_cpu_data.family == CPU_FAMILY_SH4) ||
-	    (boot_cpu_data.family == CPU_FAMILY_SH4A) ||
-	    (boot_cpu_data.family == CPU_FAMILY_SH4AL_DSP)) {
-		extern void __weak sh4_cache_init(void);
-
-		sh4_cache_init();
-
-		if ((boot_cpu_data.type == CPU_SH7786) ||
-		    (boot_cpu_data.type == CPU_SHX3)) {
-			extern void __weak shx3_cache_init(void);
-
-			shx3_cache_init();
-		}
-	}
-
-skip:
-	emit_cache_params();
-}
diff --git a/arch/sh/mm/consistent.c b/arch/sh/mm/consistent.c
deleted file mode 100644
index 0de206c1acfe9f..00000000000000
--- a/arch/sh/mm/consistent.c
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (C) 2004 - 2007  Paul Mundt
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- */
-#include <linux/mm.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/dma-mapping.h>
-#include <linux/io.h>
-
-static int __init memchunk_setup(char *str)
-{
-	return 1; /* accept anything that begins with "memchunk." */
-}
-__setup("memchunk.", memchunk_setup);
-
-static void __init memchunk_cmdline_override(char *name, unsigned long *sizep)
-{
-	char *p = boot_command_line;
-	int k = strlen(name);
-
-	while ((p = strstr(p, "memchunk."))) {
-		p += 9; /* strlen("memchunk.") */
-		if (!strncmp(name, p, k) && p[k] == '=') {
-			p += k + 1;
-			*sizep = memparse(p, NULL);
-			pr_info("%s: forcing memory chunk size to 0x%08lx\n",
-				name, *sizep);
-			break;
-		}
-	}
-}
-
-int __init platform_resource_setup_memory(struct platform_device *pdev,
-					  char *name, unsigned long memsize)
-{
-	struct resource *r;
-	dma_addr_t dma_handle;
-	void *buf;
-
-	r = pdev->resource + pdev->num_resources - 1;
-	if (r->flags) {
-		pr_warn("%s: unable to find empty space for resource\n", name);
-		return -EINVAL;
-	}
-
-	memchunk_cmdline_override(name, &memsize);
-	if (!memsize)
-		return 0;
-
-	buf = dma_alloc_coherent(&pdev->dev, memsize, &dma_handle, GFP_KERNEL);
-	if (!buf) {
-		pr_warn("%s: unable to allocate memory\n", name);
-		return -ENOMEM;
-	}
-
-	r->flags = IORESOURCE_MEM;
-	r->start = dma_handle;
-	r->end = r->start + memsize - 1;
-	r->name = name;
-	return 0;
-}
diff --git a/arch/sh/mm/extable_32.c b/arch/sh/mm/extable_32.c
deleted file mode 100644
index 14312027bb0806..00000000000000
--- a/arch/sh/mm/extable_32.c
+++ /dev/null
@@ -1,24 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * linux/arch/sh/mm/extable.c
- *  Taken from:
- *   linux/arch/i386/mm/extable.c
- */
-
-#include <linux/extable.h>
-#include <linux/uaccess.h>
-
-#include <asm/ptrace.h>
-
-int fixup_exception(struct pt_regs *regs)
-{
-	const struct exception_table_entry *fixup;
-
-	fixup = search_exception_tables(regs->pc);
-	if (fixup) {
-		regs->pc = fixup->fixup;
-		return 1;
-	}
-
-	return 0;
-}
diff --git a/arch/sh/mm/fault.c b/arch/sh/mm/fault.c
deleted file mode 100644
index acd2f5e50bfcd0..00000000000000
--- a/arch/sh/mm/fault.c
+++ /dev/null
@@ -1,504 +0,0 @@
-/*
- * Page fault handler for SH with an MMU.
- *
- *  Copyright (C) 1999  Niibe Yutaka
- *  Copyright (C) 2003 - 2012  Paul Mundt
- *
- *  Based on linux/arch/i386/mm/fault.c:
- *   Copyright (C) 1995  Linus Torvalds
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- */
-#include <linux/kernel.h>
-#include <linux/mm.h>
-#include <linux/sched/signal.h>
-#include <linux/hardirq.h>
-#include <linux/kprobes.h>
-#include <linux/perf_event.h>
-#include <linux/kdebug.h>
-#include <linux/uaccess.h>
-#include <asm/io_trapped.h>
-#include <asm/mmu_context.h>
-#include <asm/tlbflush.h>
-#include <asm/traps.h>
-
-static void
-force_sig_info_fault(int si_signo, int si_code, unsigned long address)
-{
-	force_sig_fault(si_signo, si_code, (void __user *)address);
-}
-
-/*
- * This is useful to dump out the page tables associated with
- * 'addr' in mm 'mm'.
- */
-static void show_pte(struct mm_struct *mm, unsigned long addr)
-{
-	pgd_t *pgd;
-
-	if (mm) {
-		pgd = mm->pgd;
-	} else {
-		pgd = get_TTB();
-
-		if (unlikely(!pgd))
-			pgd = swapper_pg_dir;
-	}
-
-	pr_alert("pgd = %p\n", pgd);
-	pgd += pgd_index(addr);
-	pr_alert("[%08lx] *pgd=%0*llx", addr, (u32)(sizeof(*pgd) * 2),
-		 (u64)pgd_val(*pgd));
-
-	do {
-		p4d_t *p4d;
-		pud_t *pud;
-		pmd_t *pmd;
-		pte_t *pte;
-
-		if (pgd_none(*pgd))
-			break;
-
-		if (pgd_bad(*pgd)) {
-			pr_cont("(bad)");
-			break;
-		}
-
-		p4d = p4d_offset(pgd, addr);
-		if (PTRS_PER_P4D != 1)
-			pr_cont(", *p4d=%0*Lx", (u32)(sizeof(*p4d) * 2),
-			        (u64)p4d_val(*p4d));
-
-		if (p4d_none(*p4d))
-			break;
-
-		if (p4d_bad(*p4d)) {
-			pr_cont("(bad)");
-			break;
-		}
-
-		pud = pud_offset(p4d, addr);
-		if (PTRS_PER_PUD != 1)
-			pr_cont(", *pud=%0*llx", (u32)(sizeof(*pud) * 2),
-				(u64)pud_val(*pud));
-
-		if (pud_none(*pud))
-			break;
-
-		if (pud_bad(*pud)) {
-			pr_cont("(bad)");
-			break;
-		}
-
-		pmd = pmd_offset(pud, addr);
-		if (PTRS_PER_PMD != 1)
-			pr_cont(", *pmd=%0*llx", (u32)(sizeof(*pmd) * 2),
-				(u64)pmd_val(*pmd));
-
-		if (pmd_none(*pmd))
-			break;
-
-		if (pmd_bad(*pmd)) {
-			pr_cont("(bad)");
-			break;
-		}
-
-		/* We must not map this if we have highmem enabled */
-		if (PageHighMem(pfn_to_page(pmd_val(*pmd) >> PAGE_SHIFT)))
-			break;
-
-		pte = pte_offset_kernel(pmd, addr);
-		pr_cont(", *pte=%0*llx", (u32)(sizeof(*pte) * 2),
-			(u64)pte_val(*pte));
-	} while (0);
-
-	pr_cont("\n");
-}
-
-static inline pmd_t *vmalloc_sync_one(pgd_t *pgd, unsigned long address)
-{
-	unsigned index = pgd_index(address);
-	pgd_t *pgd_k;
-	p4d_t *p4d, *p4d_k;
-	pud_t *pud, *pud_k;
-	pmd_t *pmd, *pmd_k;
-
-	pgd += index;
-	pgd_k = init_mm.pgd + index;
-
-	if (!pgd_present(*pgd_k))
-		return NULL;
-
-	p4d = p4d_offset(pgd, address);
-	p4d_k = p4d_offset(pgd_k, address);
-	if (!p4d_present(*p4d_k))
-		return NULL;
-
-	pud = pud_offset(p4d, address);
-	pud_k = pud_offset(p4d_k, address);
-	if (!pud_present(*pud_k))
-		return NULL;
-
-	if (!pud_present(*pud))
-	    set_pud(pud, *pud_k);
-
-	pmd = pmd_offset(pud, address);
-	pmd_k = pmd_offset(pud_k, address);
-	if (!pmd_present(*pmd_k))
-		return NULL;
-
-	if (!pmd_present(*pmd))
-		set_pmd(pmd, *pmd_k);
-	else {
-		/*
-		 * The page tables are fully synchronised so there must
-		 * be another reason for the fault. Return NULL here to
-		 * signal that we have not taken care of the fault.
-		 */
-		BUG_ON(pmd_page(*pmd) != pmd_page(*pmd_k));
-		return NULL;
-	}
-
-	return pmd_k;
-}
-
-#ifdef CONFIG_SH_STORE_QUEUES
-#define __FAULT_ADDR_LIMIT	P3_ADDR_MAX
-#else
-#define __FAULT_ADDR_LIMIT	VMALLOC_END
-#endif
-
-/*
- * Handle a fault on the vmalloc or module mapping area
- */
-static noinline int vmalloc_fault(unsigned long address)
-{
-	pgd_t *pgd_k;
-	pmd_t *pmd_k;
-	pte_t *pte_k;
-
-	/* Make sure we are in vmalloc/module/P3 area: */
-	if (!(address >= VMALLOC_START && address < __FAULT_ADDR_LIMIT))
-		return -1;
-
-	/*
-	 * Synchronize this task's top level page-table
-	 * with the 'reference' page table.
-	 *
-	 * Do _not_ use "current" here. We might be inside
-	 * an interrupt in the middle of a task switch..
-	 */
-	pgd_k = get_TTB();
-	pmd_k = vmalloc_sync_one(pgd_k, address);
-	if (!pmd_k)
-		return -1;
-
-	pte_k = pte_offset_kernel(pmd_k, address);
-	if (!pte_present(*pte_k))
-		return -1;
-
-	return 0;
-}
-
-static void
-show_fault_oops(struct pt_regs *regs, unsigned long address)
-{
-	if (!oops_may_print())
-		return;
-
-	pr_alert("BUG: unable to handle kernel %s at %08lx\n",
-		 address < PAGE_SIZE ? "NULL pointer dereference"
-				     : "paging request",
-		 address);
-	pr_alert("PC:");
-	printk_address(regs->pc, 1);
-
-	show_pte(NULL, address);
-}
-
-static noinline void
-no_context(struct pt_regs *regs, unsigned long error_code,
-	   unsigned long address)
-{
-	/* Are we prepared to handle this kernel fault?  */
-	if (fixup_exception(regs))
-		return;
-
-	if (handle_trapped_io(regs, address))
-		return;
-
-	/*
-	 * Oops. The kernel tried to access some bad page. We'll have to
-	 * terminate things with extreme prejudice.
-	 */
-	bust_spinlocks(1);
-
-	show_fault_oops(regs, address);
-
-	die("Oops", regs, error_code);
-}
-
-static void
-__bad_area_nosemaphore(struct pt_regs *regs, unsigned long error_code,
-		       unsigned long address, int si_code)
-{
-	/* User mode accesses just cause a SIGSEGV */
-	if (user_mode(regs)) {
-		/*
-		 * It's possible to have interrupts off here:
-		 */
-		local_irq_enable();
-
-		force_sig_info_fault(SIGSEGV, si_code, address);
-
-		return;
-	}
-
-	no_context(regs, error_code, address);
-}
-
-static noinline void
-bad_area_nosemaphore(struct pt_regs *regs, unsigned long error_code,
-		     unsigned long address)
-{
-	__bad_area_nosemaphore(regs, error_code, address, SEGV_MAPERR);
-}
-
-static void
-__bad_area(struct pt_regs *regs, unsigned long error_code,
-	   unsigned long address, int si_code)
-{
-	struct mm_struct *mm = current->mm;
-
-	/*
-	 * Something tried to access memory that isn't in our memory map..
-	 * Fix it, but check if it's kernel or user first..
-	 */
-	mmap_read_unlock(mm);
-
-	__bad_area_nosemaphore(regs, error_code, address, si_code);
-}
-
-static noinline void
-bad_area(struct pt_regs *regs, unsigned long error_code, unsigned long address)
-{
-	__bad_area(regs, error_code, address, SEGV_MAPERR);
-}
-
-static noinline void
-bad_area_access_error(struct pt_regs *regs, unsigned long error_code,
-		      unsigned long address)
-{
-	__bad_area(regs, error_code, address, SEGV_ACCERR);
-}
-
-static void
-do_sigbus(struct pt_regs *regs, unsigned long error_code, unsigned long address)
-{
-	struct task_struct *tsk = current;
-	struct mm_struct *mm = tsk->mm;
-
-	mmap_read_unlock(mm);
-
-	/* Kernel mode? Handle exceptions or die: */
-	if (!user_mode(regs))
-		no_context(regs, error_code, address);
-
-	force_sig_info_fault(SIGBUS, BUS_ADRERR, address);
-}
-
-static noinline int
-mm_fault_error(struct pt_regs *regs, unsigned long error_code,
-	       unsigned long address, vm_fault_t fault)
-{
-	/*
-	 * Pagefault was interrupted by SIGKILL. We have no reason to
-	 * continue pagefault.
-	 */
-	if (fault_signal_pending(fault, regs)) {
-		if (!user_mode(regs))
-			no_context(regs, error_code, address);
-		return 1;
-	}
-
-	/* Release mmap_lock first if necessary */
-	if (!(fault & VM_FAULT_RETRY))
-		mmap_read_unlock(current->mm);
-
-	if (!(fault & VM_FAULT_ERROR))
-		return 0;
-
-	if (fault & VM_FAULT_OOM) {
-		/* Kernel mode? Handle exceptions or die: */
-		if (!user_mode(regs)) {
-			no_context(regs, error_code, address);
-			return 1;
-		}
-
-		/*
-		 * We ran out of memory, call the OOM killer, and return the
-		 * userspace (which will retry the fault, or kill us if we got
-		 * oom-killed):
-		 */
-		pagefault_out_of_memory();
-	} else {
-		if (fault & VM_FAULT_SIGBUS)
-			do_sigbus(regs, error_code, address);
-		else if (fault & VM_FAULT_SIGSEGV)
-			bad_area(regs, error_code, address);
-		else
-			BUG();
-	}
-
-	return 1;
-}
-
-static inline int access_error(int error_code, struct vm_area_struct *vma)
-{
-	if (error_code & FAULT_CODE_WRITE) {
-		/* write, present and write, not present: */
-		if (unlikely(!(vma->vm_flags & VM_WRITE)))
-			return 1;
-		return 0;
-	}
-
-	/* ITLB miss on NX page */
-	if (unlikely((error_code & FAULT_CODE_ITLB) &&
-		     !(vma->vm_flags & VM_EXEC)))
-		return 1;
-
-	/* read, not present: */
-	if (unlikely(!vma_is_accessible(vma)))
-		return 1;
-
-	return 0;
-}
-
-static int fault_in_kernel_space(unsigned long address)
-{
-	return address >= TASK_SIZE;
-}
-
-/*
- * This routine handles page faults.  It determines the address,
- * and the problem, and then passes it off to one of the appropriate
- * routines.
- */
-asmlinkage void __kprobes do_page_fault(struct pt_regs *regs,
-					unsigned long error_code,
-					unsigned long address)
-{
-	unsigned long vec;
-	struct task_struct *tsk;
-	struct mm_struct *mm;
-	struct vm_area_struct * vma;
-	vm_fault_t fault;
-	unsigned int flags = FAULT_FLAG_DEFAULT;
-
-	tsk = current;
-	mm = tsk->mm;
-	vec = lookup_exception_vector();
-
-	/*
-	 * We fault-in kernel-space virtual memory on-demand. The
-	 * 'reference' page table is init_mm.pgd.
-	 *
-	 * NOTE! We MUST NOT take any locks for this case. We may
-	 * be in an interrupt or a critical region, and should
-	 * only copy the information from the master page table,
-	 * nothing more.
-	 */
-	if (unlikely(fault_in_kernel_space(address))) {
-		if (vmalloc_fault(address) >= 0)
-			return;
-		if (kprobe_page_fault(regs, vec))
-			return;
-
-		bad_area_nosemaphore(regs, error_code, address);
-		return;
-	}
-
-	if (unlikely(kprobe_page_fault(regs, vec)))
-		return;
-
-	/* Only enable interrupts if they were on before the fault */
-	if ((regs->sr & SR_IMASK) != SR_IMASK)
-		local_irq_enable();
-
-	perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);
-
-	/*
-	 * If we're in an interrupt, have no user context or are running
-	 * with pagefaults disabled then we must not take the fault:
-	 */
-	if (unlikely(faulthandler_disabled() || !mm)) {
-		bad_area_nosemaphore(regs, error_code, address);
-		return;
-	}
-
-retry:
-	mmap_read_lock(mm);
-
-	vma = find_vma(mm, address);
-	if (unlikely(!vma)) {
-		bad_area(regs, error_code, address);
-		return;
-	}
-	if (likely(vma->vm_start <= address))
-		goto good_area;
-	if (unlikely(!(vma->vm_flags & VM_GROWSDOWN))) {
-		bad_area(regs, error_code, address);
-		return;
-	}
-	if (unlikely(expand_stack(vma, address))) {
-		bad_area(regs, error_code, address);
-		return;
-	}
-
-	/*
-	 * Ok, we have a good vm_area for this memory access, so
-	 * we can handle it..
-	 */
-good_area:
-	if (unlikely(access_error(error_code, vma))) {
-		bad_area_access_error(regs, error_code, address);
-		return;
-	}
-
-	set_thread_fault_code(error_code);
-
-	if (user_mode(regs))
-		flags |= FAULT_FLAG_USER;
-	if (error_code & FAULT_CODE_WRITE)
-		flags |= FAULT_FLAG_WRITE;
-
-	/*
-	 * If for any reason at all we couldn't handle the fault,
-	 * make sure we exit gracefully rather than endlessly redo
-	 * the fault.
-	 */
-	fault = handle_mm_fault(vma, address, flags, regs);
-
-	if (unlikely(fault & (VM_FAULT_RETRY | VM_FAULT_ERROR)))
-		if (mm_fault_error(regs, error_code, address, fault))
-			return;
-
-	/* The fault is fully completed (including releasing mmap lock) */
-	if (fault & VM_FAULT_COMPLETED)
-		return;
-
-	if (fault & VM_FAULT_RETRY) {
-		flags |= FAULT_FLAG_TRIED;
-
-		/*
-		 * No need to mmap_read_unlock(mm) as we would
-		 * have already released it in __lock_page_or_retry
-		 * in mm/filemap.c.
-		 */
-		goto retry;
-	}
-
-	mmap_read_unlock(mm);
-}
diff --git a/arch/sh/mm/flush-sh4.c b/arch/sh/mm/flush-sh4.c
deleted file mode 100644
index 8b8ef89721041b..00000000000000
--- a/arch/sh/mm/flush-sh4.c
+++ /dev/null
@@ -1,111 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/mm.h>
-#include <asm/mmu_context.h>
-#include <asm/cache_insns.h>
-#include <asm/cacheflush.h>
-#include <asm/traps.h>
-
-/*
- * Write back the dirty D-caches, but not invalidate them.
- *
- * START: Virtual Address (U0, P1, or P3)
- * SIZE: Size of the region.
- */
-static void sh4__flush_wback_region(void *start, int size)
-{
-	reg_size_t aligned_start, v, cnt, end;
-
-	aligned_start = register_align(start);
-	v = aligned_start & ~(L1_CACHE_BYTES-1);
-	end = (aligned_start + size + L1_CACHE_BYTES-1)
-		& ~(L1_CACHE_BYTES-1);
-	cnt = (end - v) / L1_CACHE_BYTES;
-
-	while (cnt >= 8) {
-		__ocbwb(v); v += L1_CACHE_BYTES;
-		__ocbwb(v); v += L1_CACHE_BYTES;
-		__ocbwb(v); v += L1_CACHE_BYTES;
-		__ocbwb(v); v += L1_CACHE_BYTES;
-		__ocbwb(v); v += L1_CACHE_BYTES;
-		__ocbwb(v); v += L1_CACHE_BYTES;
-		__ocbwb(v); v += L1_CACHE_BYTES;
-		__ocbwb(v); v += L1_CACHE_BYTES;
-		cnt -= 8;
-	}
-
-	while (cnt) {
-		__ocbwb(v); v += L1_CACHE_BYTES;
-		cnt--;
-	}
-}
-
-/*
- * Write back the dirty D-caches and invalidate them.
- *
- * START: Virtual Address (U0, P1, or P3)
- * SIZE: Size of the region.
- */
-static void sh4__flush_purge_region(void *start, int size)
-{
-	reg_size_t aligned_start, v, cnt, end;
-
-	aligned_start = register_align(start);
-	v = aligned_start & ~(L1_CACHE_BYTES-1);
-	end = (aligned_start + size + L1_CACHE_BYTES-1)
-		& ~(L1_CACHE_BYTES-1);
-	cnt = (end - v) / L1_CACHE_BYTES;
-
-	while (cnt >= 8) {
-		__ocbp(v); v += L1_CACHE_BYTES;
-		__ocbp(v); v += L1_CACHE_BYTES;
-		__ocbp(v); v += L1_CACHE_BYTES;
-		__ocbp(v); v += L1_CACHE_BYTES;
-		__ocbp(v); v += L1_CACHE_BYTES;
-		__ocbp(v); v += L1_CACHE_BYTES;
-		__ocbp(v); v += L1_CACHE_BYTES;
-		__ocbp(v); v += L1_CACHE_BYTES;
-		cnt -= 8;
-	}
-	while (cnt) {
-		__ocbp(v); v += L1_CACHE_BYTES;
-		cnt--;
-	}
-}
-
-/*
- * No write back please
- */
-static void sh4__flush_invalidate_region(void *start, int size)
-{
-	reg_size_t aligned_start, v, cnt, end;
-
-	aligned_start = register_align(start);
-	v = aligned_start & ~(L1_CACHE_BYTES-1);
-	end = (aligned_start + size + L1_CACHE_BYTES-1)
-		& ~(L1_CACHE_BYTES-1);
-	cnt = (end - v) / L1_CACHE_BYTES;
-
-	while (cnt >= 8) {
-		__ocbi(v); v += L1_CACHE_BYTES;
-		__ocbi(v); v += L1_CACHE_BYTES;
-		__ocbi(v); v += L1_CACHE_BYTES;
-		__ocbi(v); v += L1_CACHE_BYTES;
-		__ocbi(v); v += L1_CACHE_BYTES;
-		__ocbi(v); v += L1_CACHE_BYTES;
-		__ocbi(v); v += L1_CACHE_BYTES;
-		__ocbi(v); v += L1_CACHE_BYTES;
-		cnt -= 8;
-	}
-
-	while (cnt) {
-		__ocbi(v); v += L1_CACHE_BYTES;
-		cnt--;
-	}
-}
-
-void __init sh4__flush_region_init(void)
-{
-	__flush_wback_region		= sh4__flush_wback_region;
-	__flush_invalidate_region	= sh4__flush_invalidate_region;
-	__flush_purge_region		= sh4__flush_purge_region;
-}
diff --git a/arch/sh/mm/hugetlbpage.c b/arch/sh/mm/hugetlbpage.c
deleted file mode 100644
index 999ab5916e6927..00000000000000
--- a/arch/sh/mm/hugetlbpage.c
+++ /dev/null
@@ -1,82 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * arch/sh/mm/hugetlbpage.c
- *
- * SuperH HugeTLB page support.
- *
- * Cloned from sparc64 by Paul Mundt.
- *
- * Copyright (C) 2002, 2003 David S. Miller (davem@redhat.com)
- */
-
-#include <linux/init.h>
-#include <linux/fs.h>
-#include <linux/mm.h>
-#include <linux/hugetlb.h>
-#include <linux/pagemap.h>
-#include <linux/sysctl.h>
-
-#include <asm/mman.h>
-#include <asm/tlb.h>
-#include <asm/tlbflush.h>
-#include <asm/cacheflush.h>
-
-pte_t *huge_pte_alloc(struct mm_struct *mm, struct vm_area_struct *vma,
-			unsigned long addr, unsigned long sz)
-{
-	pgd_t *pgd;
-	p4d_t *p4d;
-	pud_t *pud;
-	pmd_t *pmd;
-	pte_t *pte = NULL;
-
-	pgd = pgd_offset(mm, addr);
-	if (pgd) {
-		p4d = p4d_alloc(mm, pgd, addr);
-		if (p4d) {
-			pud = pud_alloc(mm, p4d, addr);
-			if (pud) {
-				pmd = pmd_alloc(mm, pud, addr);
-				if (pmd)
-					pte = pte_alloc_map(mm, pmd, addr);
-			}
-		}
-	}
-
-	return pte;
-}
-
-pte_t *huge_pte_offset(struct mm_struct *mm,
-		       unsigned long addr, unsigned long sz)
-{
-	pgd_t *pgd;
-	p4d_t *p4d;
-	pud_t *pud;
-	pmd_t *pmd;
-	pte_t *pte = NULL;
-
-	pgd = pgd_offset(mm, addr);
-	if (pgd) {
-		p4d = p4d_offset(pgd, addr);
-		if (p4d) {
-			pud = pud_offset(p4d, addr);
-			if (pud) {
-				pmd = pmd_offset(pud, addr);
-				if (pmd)
-					pte = pte_offset_map(pmd, addr);
-			}
-		}
-	}
-
-	return pte;
-}
-
-int pmd_huge(pmd_t pmd)
-{
-	return 0;
-}
-
-int pud_huge(pud_t pud)
-{
-	return 0;
-}
diff --git a/arch/sh/mm/init.c b/arch/sh/mm/init.c
deleted file mode 100644
index 506784702430c7..00000000000000
--- a/arch/sh/mm/init.c
+++ /dev/null
@@ -1,424 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * linux/arch/sh/mm/init.c
- *
- *  Copyright (C) 1999  Niibe Yutaka
- *  Copyright (C) 2002 - 2011  Paul Mundt
- *
- *  Based on linux/arch/i386/mm/init.c:
- *   Copyright (C) 1995  Linus Torvalds
- */
-#include <linux/mm.h>
-#include <linux/swap.h>
-#include <linux/init.h>
-#include <linux/gfp.h>
-#include <linux/memblock.h>
-#include <linux/proc_fs.h>
-#include <linux/pagemap.h>
-#include <linux/percpu.h>
-#include <linux/io.h>
-#include <linux/dma-mapping.h>
-#include <linux/export.h>
-#include <asm/mmu_context.h>
-#include <asm/mmzone.h>
-#include <asm/kexec.h>
-#include <asm/tlb.h>
-#include <asm/cacheflush.h>
-#include <asm/sections.h>
-#include <asm/setup.h>
-#include <asm/cache.h>
-#include <asm/pgalloc.h>
-#include <linux/sizes.h>
-#include "ioremap.h"
-
-pgd_t swapper_pg_dir[PTRS_PER_PGD];
-
-void __init generic_mem_init(void)
-{
-	memblock_add(__MEMORY_START, __MEMORY_SIZE);
-}
-
-void __init __weak plat_mem_setup(void)
-{
-	/* Nothing to see here, move along. */
-}
-
-#ifdef CONFIG_MMU
-static pte_t *__get_pte_phys(unsigned long addr)
-{
-	pgd_t *pgd;
-	p4d_t *p4d;
-	pud_t *pud;
-	pmd_t *pmd;
-
-	pgd = pgd_offset_k(addr);
-	if (pgd_none(*pgd)) {
-		pgd_ERROR(*pgd);
-		return NULL;
-	}
-
-	p4d = p4d_alloc(NULL, pgd, addr);
-	if (unlikely(!p4d)) {
-		p4d_ERROR(*p4d);
-		return NULL;
-	}
-
-	pud = pud_alloc(NULL, p4d, addr);
-	if (unlikely(!pud)) {
-		pud_ERROR(*pud);
-		return NULL;
-	}
-
-	pmd = pmd_alloc(NULL, pud, addr);
-	if (unlikely(!pmd)) {
-		pmd_ERROR(*pmd);
-		return NULL;
-	}
-
-	return pte_offset_kernel(pmd, addr);
-}
-
-static void set_pte_phys(unsigned long addr, unsigned long phys, pgprot_t prot)
-{
-	pte_t *pte;
-
-	pte = __get_pte_phys(addr);
-	if (!pte_none(*pte)) {
-		pte_ERROR(*pte);
-		return;
-	}
-
-	set_pte(pte, pfn_pte(phys >> PAGE_SHIFT, prot));
-	local_flush_tlb_one(get_asid(), addr);
-
-	if (pgprot_val(prot) & _PAGE_WIRED)
-		tlb_wire_entry(NULL, addr, *pte);
-}
-
-static void clear_pte_phys(unsigned long addr, pgprot_t prot)
-{
-	pte_t *pte;
-
-	pte = __get_pte_phys(addr);
-
-	if (pgprot_val(prot) & _PAGE_WIRED)
-		tlb_unwire_entry();
-
-	set_pte(pte, pfn_pte(0, __pgprot(0)));
-	local_flush_tlb_one(get_asid(), addr);
-}
-
-void __set_fixmap(enum fixed_addresses idx, unsigned long phys, pgprot_t prot)
-{
-	unsigned long address = __fix_to_virt(idx);
-
-	if (idx >= __end_of_fixed_addresses) {
-		BUG();
-		return;
-	}
-
-	set_pte_phys(address, phys, prot);
-}
-
-void __clear_fixmap(enum fixed_addresses idx, pgprot_t prot)
-{
-	unsigned long address = __fix_to_virt(idx);
-
-	if (idx >= __end_of_fixed_addresses) {
-		BUG();
-		return;
-	}
-
-	clear_pte_phys(address, prot);
-}
-
-static pmd_t * __init one_md_table_init(pud_t *pud)
-{
-	if (pud_none(*pud)) {
-		pmd_t *pmd;
-
-		pmd = memblock_alloc(PAGE_SIZE, PAGE_SIZE);
-		if (!pmd)
-			panic("%s: Failed to allocate %lu bytes align=0x%lx\n",
-			      __func__, PAGE_SIZE, PAGE_SIZE);
-		pud_populate(&init_mm, pud, pmd);
-		BUG_ON(pmd != pmd_offset(pud, 0));
-	}
-
-	return pmd_offset(pud, 0);
-}
-
-static pte_t * __init one_page_table_init(pmd_t *pmd)
-{
-	if (pmd_none(*pmd)) {
-		pte_t *pte;
-
-		pte = memblock_alloc(PAGE_SIZE, PAGE_SIZE);
-		if (!pte)
-			panic("%s: Failed to allocate %lu bytes align=0x%lx\n",
-			      __func__, PAGE_SIZE, PAGE_SIZE);
-		pmd_populate_kernel(&init_mm, pmd, pte);
-		BUG_ON(pte != pte_offset_kernel(pmd, 0));
-	}
-
-	return pte_offset_kernel(pmd, 0);
-}
-
-static pte_t * __init page_table_kmap_check(pte_t *pte, pmd_t *pmd,
-					    unsigned long vaddr, pte_t *lastpte)
-{
-	return pte;
-}
-
-void __init page_table_range_init(unsigned long start, unsigned long end,
-					 pgd_t *pgd_base)
-{
-	pgd_t *pgd;
-	pud_t *pud;
-	pmd_t *pmd;
-	pte_t *pte = NULL;
-	int i, j, k;
-	unsigned long vaddr;
-
-	vaddr = start;
-	i = pgd_index(vaddr);
-	j = pud_index(vaddr);
-	k = pmd_index(vaddr);
-	pgd = pgd_base + i;
-
-	for ( ; (i < PTRS_PER_PGD) && (vaddr != end); pgd++, i++) {
-		pud = (pud_t *)pgd;
-		for ( ; (j < PTRS_PER_PUD) && (vaddr != end); pud++, j++) {
-			pmd = one_md_table_init(pud);
-#ifndef __PAGETABLE_PMD_FOLDED
-			pmd += k;
-#endif
-			for (; (k < PTRS_PER_PMD) && (vaddr != end); pmd++, k++) {
-				pte = page_table_kmap_check(one_page_table_init(pmd),
-							    pmd, vaddr, pte);
-				vaddr += PMD_SIZE;
-			}
-			k = 0;
-		}
-		j = 0;
-	}
-}
-#endif	/* CONFIG_MMU */
-
-void __init allocate_pgdat(unsigned int nid)
-{
-	unsigned long start_pfn, end_pfn;
-
-	get_pfn_range_for_nid(nid, &start_pfn, &end_pfn);
-
-#ifdef CONFIG_NUMA
-	NODE_DATA(nid) = memblock_alloc_try_nid(
-				sizeof(struct pglist_data),
-				SMP_CACHE_BYTES, MEMBLOCK_LOW_LIMIT,
-				MEMBLOCK_ALLOC_ACCESSIBLE, nid);
-	if (!NODE_DATA(nid))
-		panic("Can't allocate pgdat for node %d\n", nid);
-#endif
-
-	NODE_DATA(nid)->node_start_pfn = start_pfn;
-	NODE_DATA(nid)->node_spanned_pages = end_pfn - start_pfn;
-}
-
-static void __init do_init_bootmem(void)
-{
-	unsigned long start_pfn, end_pfn;
-	int i;
-
-	/* Add active regions with valid PFNs. */
-	for_each_mem_pfn_range(i, MAX_NUMNODES, &start_pfn, &end_pfn, NULL)
-		__add_active_range(0, start_pfn, end_pfn);
-
-	/* All of system RAM sits in node 0 for the non-NUMA case */
-	allocate_pgdat(0);
-	node_set_online(0);
-
-	plat_mem_setup();
-
-	sparse_init();
-}
-
-static void __init early_reserve_mem(void)
-{
-	unsigned long start_pfn;
-	u32 zero_base = (u32)__MEMORY_START + (u32)PHYSICAL_OFFSET;
-	u32 start = zero_base + (u32)CONFIG_ZERO_PAGE_OFFSET;
-
-	/*
-	 * Partially used pages are not usable - thus
-	 * we are rounding upwards:
-	 */
-	start_pfn = PFN_UP(__pa(_end));
-
-	/*
-	 * Reserve the kernel text and Reserve the bootmem bitmap. We do
-	 * this in two steps (first step was init_bootmem()), because
-	 * this catches the (definitely buggy) case of us accidentally
-	 * initializing the bootmem allocator with an invalid RAM area.
-	 */
-	memblock_reserve(start, (PFN_PHYS(start_pfn) + PAGE_SIZE - 1) - start);
-
-	/*
-	 * Reserve physical pages below CONFIG_ZERO_PAGE_OFFSET.
-	 */
-	if (CONFIG_ZERO_PAGE_OFFSET != 0)
-		memblock_reserve(zero_base, CONFIG_ZERO_PAGE_OFFSET);
-
-	/*
-	 * Handle additional early reservations
-	 */
-	check_for_initrd();
-	reserve_crashkernel();
-}
-
-void __init paging_init(void)
-{
-	unsigned long max_zone_pfns[MAX_NR_ZONES];
-	unsigned long vaddr, end;
-
-	sh_mv.mv_mem_init();
-
-	early_reserve_mem();
-
-	/*
-	 * Once the early reservations are out of the way, give the
-	 * platforms a chance to kick out some memory.
-	 */
-	if (sh_mv.mv_mem_reserve)
-		sh_mv.mv_mem_reserve();
-
-	memblock_enforce_memory_limit(memory_limit);
-	memblock_allow_resize();
-
-	memblock_dump_all();
-
-	/*
-	 * Determine low and high memory ranges:
-	 */
-	max_low_pfn = max_pfn = memblock_end_of_DRAM() >> PAGE_SHIFT;
-	min_low_pfn = __MEMORY_START >> PAGE_SHIFT;
-
-	nodes_clear(node_online_map);
-
-	memory_start = (unsigned long)__va(__MEMORY_START);
-	memory_end = memory_start + (memory_limit ?: memblock_phys_mem_size());
-
-	uncached_init();
-	pmb_init();
-	do_init_bootmem();
-	ioremap_fixed_init();
-
-	/* We don't need to map the kernel through the TLB, as
-	 * it is permanatly mapped using P1. So clear the
-	 * entire pgd. */
-	memset(swapper_pg_dir, 0, sizeof(swapper_pg_dir));
-
-	/* Set an initial value for the MMU.TTB so we don't have to
-	 * check for a null value. */
-	set_TTB(swapper_pg_dir);
-
-	/*
-	 * Populate the relevant portions of swapper_pg_dir so that
-	 * we can use the fixmap entries without calling kmalloc.
-	 * pte's will be filled in by __set_fixmap().
-	 */
-	vaddr = __fix_to_virt(__end_of_fixed_addresses - 1) & PMD_MASK;
-	end = (FIXADDR_TOP + PMD_SIZE - 1) & PMD_MASK;
-	page_table_range_init(vaddr, end, swapper_pg_dir);
-
-	kmap_coherent_init();
-
-	memset(max_zone_pfns, 0, sizeof(max_zone_pfns));
-	max_zone_pfns[ZONE_NORMAL] = max_low_pfn;
-	free_area_init(max_zone_pfns);
-}
-
-unsigned int mem_init_done = 0;
-
-void __init mem_init(void)
-{
-	pg_data_t *pgdat;
-
-	high_memory = NULL;
-	for_each_online_pgdat(pgdat)
-		high_memory = max_t(void *, high_memory,
-				    __va(pgdat_end_pfn(pgdat) << PAGE_SHIFT));
-
-	memblock_free_all();
-
-	/* Set this up early, so we can take care of the zero page */
-	cpu_cache_init();
-
-	/* clear the zero-page */
-	memset(empty_zero_page, 0, PAGE_SIZE);
-	__flush_wback_region(empty_zero_page, PAGE_SIZE);
-
-	vsyscall_init();
-
-	pr_info("virtual kernel memory layout:\n"
-		"    fixmap  : 0x%08lx - 0x%08lx   (%4ld kB)\n"
-		"    vmalloc : 0x%08lx - 0x%08lx   (%4ld MB)\n"
-		"    lowmem  : 0x%08lx - 0x%08lx   (%4ld MB) (cached)\n"
-#ifdef CONFIG_UNCACHED_MAPPING
-		"            : 0x%08lx - 0x%08lx   (%4ld MB) (uncached)\n"
-#endif
-		"      .init : 0x%08lx - 0x%08lx   (%4ld kB)\n"
-		"      .data : 0x%08lx - 0x%08lx   (%4ld kB)\n"
-		"      .text : 0x%08lx - 0x%08lx   (%4ld kB)\n",
-		FIXADDR_START, FIXADDR_TOP,
-		(FIXADDR_TOP - FIXADDR_START) >> 10,
-
-		(unsigned long)VMALLOC_START, VMALLOC_END,
-		(VMALLOC_END - VMALLOC_START) >> 20,
-
-		(unsigned long)memory_start, (unsigned long)high_memory,
-		((unsigned long)high_memory - (unsigned long)memory_start) >> 20,
-
-#ifdef CONFIG_UNCACHED_MAPPING
-		uncached_start, uncached_end, uncached_size >> 20,
-#endif
-
-		(unsigned long)&__init_begin, (unsigned long)&__init_end,
-		((unsigned long)&__init_end -
-		 (unsigned long)&__init_begin) >> 10,
-
-		(unsigned long)&_etext, (unsigned long)&_edata,
-		((unsigned long)&_edata - (unsigned long)&_etext) >> 10,
-
-		(unsigned long)&_text, (unsigned long)&_etext,
-		((unsigned long)&_etext - (unsigned long)&_text) >> 10);
-
-	mem_init_done = 1;
-}
-
-#ifdef CONFIG_MEMORY_HOTPLUG
-int arch_add_memory(int nid, u64 start, u64 size,
-		    struct mhp_params *params)
-{
-	unsigned long start_pfn = PFN_DOWN(start);
-	unsigned long nr_pages = size >> PAGE_SHIFT;
-	int ret;
-
-	if (WARN_ON_ONCE(params->pgprot.pgprot != PAGE_KERNEL.pgprot))
-		return -EINVAL;
-
-	/* We only have ZONE_NORMAL, so this is easy.. */
-	ret = __add_pages(nid, start_pfn, nr_pages, params);
-	if (unlikely(ret))
-		printk("%s: Failed, __add_pages() == %d\n", __func__, ret);
-
-	return ret;
-}
-
-void arch_remove_memory(u64 start, u64 size, struct vmem_altmap *altmap)
-{
-	unsigned long start_pfn = PFN_DOWN(start);
-	unsigned long nr_pages = size >> PAGE_SHIFT;
-
-	__remove_pages(start_pfn, nr_pages, altmap);
-}
-#endif /* CONFIG_MEMORY_HOTPLUG */
diff --git a/arch/sh/mm/ioremap.c b/arch/sh/mm/ioremap.c
deleted file mode 100644
index 21342581144dee..00000000000000
--- a/arch/sh/mm/ioremap.c
+++ /dev/null
@@ -1,192 +0,0 @@
-/*
- * arch/sh/mm/ioremap.c
- *
- * (C) Copyright 1995 1996 Linus Torvalds
- * (C) Copyright 2005 - 2010  Paul Mundt
- *
- * Re-map IO memory to kernel address space so that we can access it.
- * This is needed for high PCI addresses that aren't mapped in the
- * 640k-1MB IO memory area on PC's
- *
- * This file is subject to the terms and conditions of the GNU General
- * Public License. See the file "COPYING" in the main directory of this
- * archive for more details.
- */
-#include <linux/vmalloc.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/mm.h>
-#include <linux/pci.h>
-#include <linux/io.h>
-#include <asm/io_trapped.h>
-#include <asm/page.h>
-#include <asm/pgalloc.h>
-#include <asm/addrspace.h>
-#include <asm/cacheflush.h>
-#include <asm/tlbflush.h>
-#include <asm/mmu.h>
-#include "ioremap.h"
-
-/*
- * On 32-bit SH, we traditionally have the whole physical address space mapped
- * at all times (as MIPS does), so "ioremap()" and "iounmap()" do not need to do
- * anything but place the address in the proper segment.  This is true for P1
- * and P2 addresses, as well as some P3 ones.  However, most of the P3 addresses
- * and newer cores using extended addressing need to map through page tables, so
- * the ioremap() implementation becomes a bit more complicated.
- */
-#ifdef CONFIG_29BIT
-static void __iomem *
-__ioremap_29bit(phys_addr_t offset, unsigned long size, pgprot_t prot)
-{
-	phys_addr_t last_addr = offset + size - 1;
-
-	/*
-	 * For P1 and P2 space this is trivial, as everything is already
-	 * mapped. Uncached access for P1 addresses are done through P2.
-	 * In the P3 case or for addresses outside of the 29-bit space,
-	 * mapping must be done by the PMB or by using page tables.
-	 */
-	if (likely(PXSEG(offset) < P3SEG && PXSEG(last_addr) < P3SEG)) {
-		u64 flags = pgprot_val(prot);
-
-		/*
-		 * Anything using the legacy PTEA space attributes needs
-		 * to be kicked down to page table mappings.
-		 */
-		if (unlikely(flags & _PAGE_PCC_MASK))
-			return NULL;
-		if (unlikely(flags & _PAGE_CACHABLE))
-			return (void __iomem *)P1SEGADDR(offset);
-
-		return (void __iomem *)P2SEGADDR(offset);
-	}
-
-	/* P4 above the store queues are always mapped. */
-	if (unlikely(offset >= P3_ADDR_MAX))
-		return (void __iomem *)P4SEGADDR(offset);
-
-	return NULL;
-}
-#else
-#define __ioremap_29bit(offset, size, prot)		NULL
-#endif /* CONFIG_29BIT */
-
-/*
- * Remap an arbitrary physical address space into the kernel virtual
- * address space. Needed when the kernel wants to access high addresses
- * directly.
- *
- * NOTE! We need to allow non-page-aligned mappings too: we will obviously
- * have to convert them into an offset in a page-aligned mapping, but the
- * caller shouldn't need to know that small detail.
- */
-void __iomem * __ref
-__ioremap_caller(phys_addr_t phys_addr, unsigned long size,
-		 pgprot_t pgprot, void *caller)
-{
-	struct vm_struct *area;
-	unsigned long offset, last_addr, addr, orig_addr;
-	void __iomem *mapped;
-
-	mapped = __ioremap_trapped(phys_addr, size);
-	if (mapped)
-		return mapped;
-
-	mapped = __ioremap_29bit(phys_addr, size, pgprot);
-	if (mapped)
-		return mapped;
-
-	/* Don't allow wraparound or zero size */
-	last_addr = phys_addr + size - 1;
-	if (!size || last_addr < phys_addr)
-		return NULL;
-
-	/*
-	 * If we can't yet use the regular approach, go the fixmap route.
-	 */
-	if (!mem_init_done)
-		return ioremap_fixed(phys_addr, size, pgprot);
-
-	/*
-	 * First try to remap through the PMB.
-	 * PMB entries are all pre-faulted.
-	 */
-	mapped = pmb_remap_caller(phys_addr, size, pgprot, caller);
-	if (mapped && !IS_ERR(mapped))
-		return mapped;
-
-	/*
-	 * Mappings have to be page-aligned
-	 */
-	offset = phys_addr & ~PAGE_MASK;
-	phys_addr &= PAGE_MASK;
-	size = PAGE_ALIGN(last_addr+1) - phys_addr;
-
-	/*
-	 * Ok, go for it..
-	 */
-	area = get_vm_area_caller(size, VM_IOREMAP, caller);
-	if (!area)
-		return NULL;
-	area->phys_addr = phys_addr;
-	orig_addr = addr = (unsigned long)area->addr;
-
-	if (ioremap_page_range(addr, addr + size, phys_addr, pgprot)) {
-		vunmap((void *)orig_addr);
-		return NULL;
-	}
-
-	return (void __iomem *)(offset + (char *)orig_addr);
-}
-EXPORT_SYMBOL(__ioremap_caller);
-
-/*
- * Simple checks for non-translatable mappings.
- */
-static inline int iomapping_nontranslatable(unsigned long offset)
-{
-#ifdef CONFIG_29BIT
-	/*
-	 * In 29-bit mode this includes the fixed P1/P2 areas, as well as
-	 * parts of P3.
-	 */
-	if (PXSEG(offset) < P3SEG || offset >= P3_ADDR_MAX)
-		return 1;
-#endif
-
-	return 0;
-}
-
-void iounmap(void __iomem *addr)
-{
-	unsigned long vaddr = (unsigned long __force)addr;
-	struct vm_struct *p;
-
-	/*
-	 * Nothing to do if there is no translatable mapping.
-	 */
-	if (iomapping_nontranslatable(vaddr))
-		return;
-
-	/*
-	 * There's no VMA if it's from an early fixed mapping.
-	 */
-	if (iounmap_fixed(addr) == 0)
-		return;
-
-	/*
-	 * If the PMB handled it, there's nothing else to do.
-	 */
-	if (pmb_unmap(addr) == 0)
-		return;
-
-	p = remove_vm_area((void *)(vaddr & PAGE_MASK));
-	if (!p) {
-		printk(KERN_ERR "%s: bad address %p\n", __func__, addr);
-		return;
-	}
-
-	kfree(p);
-}
-EXPORT_SYMBOL(iounmap);
diff --git a/arch/sh/mm/ioremap.h b/arch/sh/mm/ioremap.h
deleted file mode 100644
index f2544e721a3526..00000000000000
--- a/arch/sh/mm/ioremap.h
+++ /dev/null
@@ -1,23 +0,0 @@
-#ifndef _SH_MM_IORMEMAP_H
-#define _SH_MM_IORMEMAP_H 1
-
-#ifdef CONFIG_IOREMAP_FIXED
-void __iomem *ioremap_fixed(phys_addr_t, unsigned long, pgprot_t);
-int iounmap_fixed(void __iomem *);
-void ioremap_fixed_init(void);
-#else
-static inline void __iomem *
-ioremap_fixed(phys_addr_t phys_addr, unsigned long size, pgprot_t prot)
-{
-	BUG();
-	return NULL;
-}
-static inline void ioremap_fixed_init(void)
-{
-}
-static inline int iounmap_fixed(void __iomem *addr)
-{
-	return -EINVAL;
-}
-#endif /* CONFIG_IOREMAP_FIXED */
-#endif /* _SH_MM_IORMEMAP_H */
diff --git a/arch/sh/mm/ioremap_fixed.c b/arch/sh/mm/ioremap_fixed.c
deleted file mode 100644
index 136113bcac2599..00000000000000
--- a/arch/sh/mm/ioremap_fixed.c
+++ /dev/null
@@ -1,135 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Re-map IO memory to kernel address space so that we can access it.
- *
- * These functions should only be used when it is necessary to map a
- * physical address space into the kernel address space before ioremap()
- * can be used, e.g. early in boot before paging_init().
- *
- * Copyright (C) 2009  Matt Fleming
- */
-
-#include <linux/vmalloc.h>
-#include <linux/ioport.h>
-#include <linux/module.h>
-#include <linux/mm.h>
-#include <linux/io.h>
-#include <linux/memblock.h>
-#include <linux/proc_fs.h>
-#include <asm/fixmap.h>
-#include <asm/page.h>
-#include <asm/addrspace.h>
-#include <asm/cacheflush.h>
-#include <asm/tlbflush.h>
-#include <asm/mmu.h>
-#include <asm/mmu_context.h>
-#include "ioremap.h"
-
-struct ioremap_map {
-	void __iomem *addr;
-	unsigned long size;
-	unsigned long fixmap_addr;
-};
-
-static struct ioremap_map ioremap_maps[FIX_N_IOREMAPS];
-
-void __init ioremap_fixed_init(void)
-{
-	struct ioremap_map *map;
-	int i;
-
-	for (i = 0; i < FIX_N_IOREMAPS; i++) {
-		map = &ioremap_maps[i];
-		map->fixmap_addr = __fix_to_virt(FIX_IOREMAP_BEGIN + i);
-	}
-}
-
-void __init __iomem *
-ioremap_fixed(phys_addr_t phys_addr, unsigned long size, pgprot_t prot)
-{
-	enum fixed_addresses idx0, idx;
-	struct ioremap_map *map;
-	unsigned int nrpages;
-	unsigned long offset;
-	int i, slot;
-
-	/*
-	 * Mappings have to be page-aligned
-	 */
-	offset = phys_addr & ~PAGE_MASK;
-	phys_addr &= PAGE_MASK;
-	size = PAGE_ALIGN(phys_addr + size) - phys_addr;
-
-	slot = -1;
-	for (i = 0; i < FIX_N_IOREMAPS; i++) {
-		map = &ioremap_maps[i];
-		if (!map->addr) {
-			map->size = size;
-			slot = i;
-			break;
-		}
-	}
-
-	if (slot < 0)
-		return NULL;
-
-	/*
-	 * Mappings have to fit in the FIX_IOREMAP area.
-	 */
-	nrpages = size >> PAGE_SHIFT;
-	if (nrpages > FIX_N_IOREMAPS)
-		return NULL;
-
-	/*
-	 * Ok, go for it..
-	 */
-	idx0 = FIX_IOREMAP_BEGIN + slot;
-	idx = idx0;
-	while (nrpages > 0) {
-		pgprot_val(prot) |= _PAGE_WIRED;
-		__set_fixmap(idx, phys_addr, prot);
-		phys_addr += PAGE_SIZE;
-		idx++;
-		--nrpages;
-	}
-
-	map->addr = (void __iomem *)(offset + map->fixmap_addr);
-	return map->addr;
-}
-
-int iounmap_fixed(void __iomem *addr)
-{
-	enum fixed_addresses idx;
-	struct ioremap_map *map;
-	unsigned int nrpages;
-	int i, slot;
-
-	slot = -1;
-	for (i = 0; i < FIX_N_IOREMAPS; i++) {
-		map = &ioremap_maps[i];
-		if (map->addr == addr) {
-			slot = i;
-			break;
-		}
-	}
-
-	/*
-	 * If we don't match, it's not for us.
-	 */
-	if (slot < 0)
-		return -EINVAL;
-
-	nrpages = map->size >> PAGE_SHIFT;
-
-	idx = FIX_IOREMAP_BEGIN + slot + nrpages - 1;
-	while (nrpages > 0) {
-		__clear_fixmap(idx, __pgprot(_PAGE_WIRED));
-		--idx;
-		--nrpages;
-	}
-
-	map->size = 0;
-	map->addr = NULL;
-
-	return 0;
-}
diff --git a/arch/sh/mm/kmap.c b/arch/sh/mm/kmap.c
deleted file mode 100644
index 73fd7cc9943076..00000000000000
--- a/arch/sh/mm/kmap.c
+++ /dev/null
@@ -1,65 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * arch/sh/mm/kmap.c
- *
- * Copyright (C) 1999, 2000, 2002  Niibe Yutaka
- * Copyright (C) 2002 - 2009  Paul Mundt
- */
-#include <linux/mm.h>
-#include <linux/init.h>
-#include <linux/mutex.h>
-#include <linux/fs.h>
-#include <linux/highmem.h>
-#include <linux/module.h>
-#include <asm/mmu_context.h>
-#include <asm/cacheflush.h>
-
-static pte_t *kmap_coherent_pte;
-
-void __init kmap_coherent_init(void)
-{
-	unsigned long vaddr;
-
-	/* cache the first coherent kmap pte */
-	vaddr = __fix_to_virt(FIX_CMAP_BEGIN);
-	kmap_coherent_pte = virt_to_kpte(vaddr);
-}
-
-void *kmap_coherent(struct page *page, unsigned long addr)
-{
-	enum fixed_addresses idx;
-	unsigned long vaddr;
-
-	BUG_ON(!test_bit(PG_dcache_clean, &page->flags));
-
-	preempt_disable();
-	pagefault_disable();
-
-	idx = FIX_CMAP_END -
-		(((addr >> PAGE_SHIFT) & (FIX_N_COLOURS - 1)) +
-		 (FIX_N_COLOURS * smp_processor_id()));
-
-	vaddr = __fix_to_virt(idx);
-
-	BUG_ON(!pte_none(*(kmap_coherent_pte - idx)));
-	set_pte(kmap_coherent_pte - idx, mk_pte(page, PAGE_KERNEL));
-
-	return (void *)vaddr;
-}
-
-void kunmap_coherent(void *kvaddr)
-{
-	if (kvaddr >= (void *)FIXADDR_START) {
-		unsigned long vaddr = (unsigned long)kvaddr & PAGE_MASK;
-		enum fixed_addresses idx = __virt_to_fix(vaddr);
-
-		/* XXX.. Kill this later, here for sanity at the moment.. */
-		__flush_purge_region((void *)vaddr, PAGE_SIZE);
-
-		pte_clear(&init_mm, vaddr, kmap_coherent_pte - idx);
-		local_flush_tlb_one(get_asid(), vaddr);
-	}
-
-	pagefault_enable();
-	preempt_enable();
-}
diff --git a/arch/sh/mm/mmap.c b/arch/sh/mm/mmap.c
deleted file mode 100644
index b82199878b4594..00000000000000
--- a/arch/sh/mm/mmap.c
+++ /dev/null
@@ -1,184 +0,0 @@
-/*
- * arch/sh/mm/mmap.c
- *
- * Copyright (C) 2008 - 2009  Paul Mundt
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- */
-#include <linux/io.h>
-#include <linux/mm.h>
-#include <linux/sched/mm.h>
-#include <linux/mman.h>
-#include <linux/module.h>
-#include <asm/page.h>
-#include <asm/processor.h>
-
-unsigned long shm_align_mask = PAGE_SIZE - 1;	/* Sane caches */
-EXPORT_SYMBOL(shm_align_mask);
-
-#ifdef CONFIG_MMU
-static const pgprot_t protection_map[16] = {
-	[VM_NONE]					= PAGE_NONE,
-	[VM_READ]					= PAGE_READONLY,
-	[VM_WRITE]					= PAGE_COPY,
-	[VM_WRITE | VM_READ]				= PAGE_COPY,
-	[VM_EXEC]					= PAGE_EXECREAD,
-	[VM_EXEC | VM_READ]				= PAGE_EXECREAD,
-	[VM_EXEC | VM_WRITE]				= PAGE_COPY,
-	[VM_EXEC | VM_WRITE | VM_READ]			= PAGE_COPY,
-	[VM_SHARED]					= PAGE_NONE,
-	[VM_SHARED | VM_READ]				= PAGE_READONLY,
-	[VM_SHARED | VM_WRITE]				= PAGE_WRITEONLY,
-	[VM_SHARED | VM_WRITE | VM_READ]		= PAGE_SHARED,
-	[VM_SHARED | VM_EXEC]				= PAGE_EXECREAD,
-	[VM_SHARED | VM_EXEC | VM_READ]			= PAGE_EXECREAD,
-	[VM_SHARED | VM_EXEC | VM_WRITE]		= PAGE_RWX,
-	[VM_SHARED | VM_EXEC | VM_WRITE | VM_READ]	= PAGE_RWX
-};
-DECLARE_VM_GET_PAGE_PROT
-
-/*
- * To avoid cache aliases, we map the shared page with same color.
- */
-static inline unsigned long COLOUR_ALIGN(unsigned long addr,
-					 unsigned long pgoff)
-{
-	unsigned long base = (addr + shm_align_mask) & ~shm_align_mask;
-	unsigned long off = (pgoff << PAGE_SHIFT) & shm_align_mask;
-
-	return base + off;
-}
-
-unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,
-	unsigned long len, unsigned long pgoff, unsigned long flags)
-{
-	struct mm_struct *mm = current->mm;
-	struct vm_area_struct *vma;
-	int do_colour_align;
-	struct vm_unmapped_area_info info;
-
-	if (flags & MAP_FIXED) {
-		/* We do not accept a shared mapping if it would violate
-		 * cache aliasing constraints.
-		 */
-		if ((flags & MAP_SHARED) &&
-		    ((addr - (pgoff << PAGE_SHIFT)) & shm_align_mask))
-			return -EINVAL;
-		return addr;
-	}
-
-	if (unlikely(len > TASK_SIZE))
-		return -ENOMEM;
-
-	do_colour_align = 0;
-	if (filp || (flags & MAP_SHARED))
-		do_colour_align = 1;
-
-	if (addr) {
-		if (do_colour_align)
-			addr = COLOUR_ALIGN(addr, pgoff);
-		else
-			addr = PAGE_ALIGN(addr);
-
-		vma = find_vma(mm, addr);
-		if (TASK_SIZE - len >= addr &&
-		    (!vma || addr + len <= vm_start_gap(vma)))
-			return addr;
-	}
-
-	info.flags = 0;
-	info.length = len;
-	info.low_limit = TASK_UNMAPPED_BASE;
-	info.high_limit = TASK_SIZE;
-	info.align_mask = do_colour_align ? (PAGE_MASK & shm_align_mask) : 0;
-	info.align_offset = pgoff << PAGE_SHIFT;
-	return vm_unmapped_area(&info);
-}
-
-unsigned long
-arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,
-			  const unsigned long len, const unsigned long pgoff,
-			  const unsigned long flags)
-{
-	struct vm_area_struct *vma;
-	struct mm_struct *mm = current->mm;
-	unsigned long addr = addr0;
-	int do_colour_align;
-	struct vm_unmapped_area_info info;
-
-	if (flags & MAP_FIXED) {
-		/* We do not accept a shared mapping if it would violate
-		 * cache aliasing constraints.
-		 */
-		if ((flags & MAP_SHARED) &&
-		    ((addr - (pgoff << PAGE_SHIFT)) & shm_align_mask))
-			return -EINVAL;
-		return addr;
-	}
-
-	if (unlikely(len > TASK_SIZE))
-		return -ENOMEM;
-
-	do_colour_align = 0;
-	if (filp || (flags & MAP_SHARED))
-		do_colour_align = 1;
-
-	/* requesting a specific address */
-	if (addr) {
-		if (do_colour_align)
-			addr = COLOUR_ALIGN(addr, pgoff);
-		else
-			addr = PAGE_ALIGN(addr);
-
-		vma = find_vma(mm, addr);
-		if (TASK_SIZE - len >= addr &&
-		    (!vma || addr + len <= vm_start_gap(vma)))
-			return addr;
-	}
-
-	info.flags = VM_UNMAPPED_AREA_TOPDOWN;
-	info.length = len;
-	info.low_limit = PAGE_SIZE;
-	info.high_limit = mm->mmap_base;
-	info.align_mask = do_colour_align ? (PAGE_MASK & shm_align_mask) : 0;
-	info.align_offset = pgoff << PAGE_SHIFT;
-	addr = vm_unmapped_area(&info);
-
-	/*
-	 * A failed mmap() very likely causes application failure,
-	 * so fall back to the bottom-up function here. This scenario
-	 * can happen with large stack limits and large mmap()
-	 * allocations.
-	 */
-	if (addr & ~PAGE_MASK) {
-		VM_BUG_ON(addr != -ENOMEM);
-		info.flags = 0;
-		info.low_limit = TASK_UNMAPPED_BASE;
-		info.high_limit = TASK_SIZE;
-		addr = vm_unmapped_area(&info);
-	}
-
-	return addr;
-}
-#endif /* CONFIG_MMU */
-
-/*
- * You really shouldn't be using read() or write() on /dev/mem.  This
- * might go away in the future.
- */
-int valid_phys_addr_range(phys_addr_t addr, size_t count)
-{
-	if (addr < __MEMORY_START)
-		return 0;
-	if (addr + count > __pa(high_memory))
-		return 0;
-
-	return 1;
-}
-
-int valid_mmap_phys_addr_range(unsigned long pfn, size_t size)
-{
-	return 1;
-}
diff --git a/arch/sh/mm/nommu.c b/arch/sh/mm/nommu.c
deleted file mode 100644
index 78c4b6e6d33ba3..00000000000000
--- a/arch/sh/mm/nommu.c
+++ /dev/null
@@ -1,98 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * arch/sh/mm/nommu.c
- *
- * Various helper routines and stubs for MMUless SH.
- *
- * Copyright (C) 2002 - 2009 Paul Mundt
- */
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/string.h>
-#include <linux/mm.h>
-#include <asm/tlbflush.h>
-#include <asm/page.h>
-#include <linux/uaccess.h>
-
-/*
- * Nothing too terribly exciting here ..
- */
-void copy_page(void *to, void *from)
-{
-	memcpy(to, from, PAGE_SIZE);
-}
-
-__kernel_size_t __copy_user(void *to, const void *from, __kernel_size_t n)
-{
-	memcpy(to, from, n);
-	return 0;
-}
-
-__kernel_size_t __clear_user(void __user *to, __kernel_size_t n)
-{
-	memset((__force void *)to, 0, n);
-	return 0;
-}
-
-void local_flush_tlb_all(void)
-{
-	BUG();
-}
-
-void local_flush_tlb_mm(struct mm_struct *mm)
-{
-	BUG();
-}
-
-void local_flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
-			    unsigned long end)
-{
-	BUG();
-}
-
-void local_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)
-{
-	BUG();
-}
-
-void local_flush_tlb_one(unsigned long asid, unsigned long page)
-{
-	BUG();
-}
-
-void local_flush_tlb_kernel_range(unsigned long start, unsigned long end)
-{
-	BUG();
-}
-
-void __flush_tlb_global(void)
-{
-}
-
-void __update_tlb(struct vm_area_struct *vma, unsigned long address, pte_t pte)
-{
-}
-
-void __init kmap_coherent_init(void)
-{
-}
-
-void *kmap_coherent(struct page *page, unsigned long addr)
-{
-	BUG();
-	return NULL;
-}
-
-void kunmap_coherent(void *kvaddr)
-{
-	BUG();
-}
-
-void __init page_table_range_init(unsigned long start, unsigned long end,
-				  pgd_t *pgd_base)
-{
-}
-
-void __set_fixmap(enum fixed_addresses idx, unsigned long phys, pgprot_t prot)
-{
-}
diff --git a/arch/sh/mm/numa.c b/arch/sh/mm/numa.c
deleted file mode 100644
index 50f0dc1744d049..00000000000000
--- a/arch/sh/mm/numa.c
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * arch/sh/mm/numa.c - Multiple node support for SH machines
- *
- *  Copyright (C) 2007  Paul Mundt
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- */
-#include <linux/module.h>
-#include <linux/memblock.h>
-#include <linux/mm.h>
-#include <linux/numa.h>
-#include <linux/pfn.h>
-#include <asm/sections.h>
-
-struct pglist_data *node_data[MAX_NUMNODES] __read_mostly;
-EXPORT_SYMBOL_GPL(node_data);
-
-/*
- * On SH machines the conventional approach is to stash system RAM
- * in node 0, and other memory blocks in to node 1 and up, ordered by
- * latency. Each node's pgdat is node-local at the beginning of the node,
- * immediately followed by the node mem map.
- */
-void __init setup_bootmem_node(int nid, unsigned long start, unsigned long end)
-{
-	unsigned long start_pfn, end_pfn;
-
-	/* Don't allow bogus node assignment */
-	BUG_ON(nid >= MAX_NUMNODES || nid <= 0);
-
-	start_pfn = PFN_DOWN(start);
-	end_pfn = PFN_DOWN(end);
-
-	pmb_bolt_mapping((unsigned long)__va(start), start, end - start,
-			 PAGE_KERNEL);
-
-	memblock_add(start, end - start);
-
-	__add_active_range(nid, start_pfn, end_pfn);
-
-	/* Node-local pgdat */
-	NODE_DATA(nid) = memblock_alloc_node(sizeof(struct pglist_data),
-					     SMP_CACHE_BYTES, nid);
-	if (!NODE_DATA(nid))
-		panic("%s: Failed to allocate %zu bytes align=0x%x nid=%d\n",
-		      __func__, sizeof(struct pglist_data), SMP_CACHE_BYTES,
-		      nid);
-
-	NODE_DATA(nid)->node_start_pfn = start_pfn;
-	NODE_DATA(nid)->node_spanned_pages = end_pfn - start_pfn;
-
-	/* It's up */
-	node_set_online(nid);
-}
diff --git a/arch/sh/mm/pgtable.c b/arch/sh/mm/pgtable.c
deleted file mode 100644
index cf7ce4b5735954..00000000000000
--- a/arch/sh/mm/pgtable.c
+++ /dev/null
@@ -1,57 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/mm.h>
-#include <linux/slab.h>
-
-static struct kmem_cache *pgd_cachep;
-#if PAGETABLE_LEVELS > 2
-static struct kmem_cache *pmd_cachep;
-#endif
-
-void pgd_ctor(void *x)
-{
-	pgd_t *pgd = x;
-
-	memset(pgd, 0, USER_PTRS_PER_PGD * sizeof(pgd_t));
-	memcpy(pgd + USER_PTRS_PER_PGD,
-	       swapper_pg_dir + USER_PTRS_PER_PGD,
-	       (PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t));
-}
-
-void pgtable_cache_init(void)
-{
-	pgd_cachep = kmem_cache_create("pgd_cache",
-				       PTRS_PER_PGD * (1<<PTE_MAGNITUDE),
-				       PAGE_SIZE, SLAB_PANIC, pgd_ctor);
-#if PAGETABLE_LEVELS > 2
-	pmd_cachep = kmem_cache_create("pmd_cache",
-				       PTRS_PER_PMD * (1<<PTE_MAGNITUDE),
-				       PAGE_SIZE, SLAB_PANIC, NULL);
-#endif
-}
-
-pgd_t *pgd_alloc(struct mm_struct *mm)
-{
-	return kmem_cache_alloc(pgd_cachep, GFP_KERNEL);
-}
-
-void pgd_free(struct mm_struct *mm, pgd_t *pgd)
-{
-	kmem_cache_free(pgd_cachep, pgd);
-}
-
-#if PAGETABLE_LEVELS > 2
-void pud_populate(struct mm_struct *mm, pud_t *pud, pmd_t *pmd)
-{
-	set_pud(pud, __pud((unsigned long)pmd));
-}
-
-pmd_t *pmd_alloc_one(struct mm_struct *mm, unsigned long address)
-{
-	return kmem_cache_alloc(pmd_cachep, GFP_KERNEL | __GFP_ZERO);
-}
-
-void pmd_free(struct mm_struct *mm, pmd_t *pmd)
-{
-	kmem_cache_free(pmd_cachep, pmd);
-}
-#endif /* PAGETABLE_LEVELS > 2 */
diff --git a/arch/sh/mm/pmb.c b/arch/sh/mm/pmb.c
deleted file mode 100644
index 68eb7cc6e56435..00000000000000
--- a/arch/sh/mm/pmb.c
+++ /dev/null
@@ -1,887 +0,0 @@
-/*
- * arch/sh/mm/pmb.c
- *
- * Privileged Space Mapping Buffer (PMB) Support.
- *
- * Copyright (C) 2005 - 2011  Paul Mundt
- * Copyright (C) 2010  Matt Fleming
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/syscore_ops.h>
-#include <linux/cpu.h>
-#include <linux/module.h>
-#include <linux/bitops.h>
-#include <linux/debugfs.h>
-#include <linux/fs.h>
-#include <linux/seq_file.h>
-#include <linux/err.h>
-#include <linux/io.h>
-#include <linux/spinlock.h>
-#include <linux/vmalloc.h>
-#include <linux/pgtable.h>
-#include <asm/cacheflush.h>
-#include <linux/sizes.h>
-#include <linux/uaccess.h>
-#include <asm/page.h>
-#include <asm/mmu.h>
-#include <asm/mmu_context.h>
-
-struct pmb_entry;
-
-struct pmb_entry {
-	unsigned long vpn;
-	unsigned long ppn;
-	unsigned long flags;
-	unsigned long size;
-
-	raw_spinlock_t lock;
-
-	/*
-	 * 0 .. NR_PMB_ENTRIES for specific entry selection, or
-	 * PMB_NO_ENTRY to search for a free one
-	 */
-	int entry;
-
-	/* Adjacent entry link for contiguous multi-entry mappings */
-	struct pmb_entry *link;
-};
-
-static struct {
-	unsigned long size;
-	int flag;
-} pmb_sizes[] = {
-	{ .size	= SZ_512M, .flag = PMB_SZ_512M, },
-	{ .size = SZ_128M, .flag = PMB_SZ_128M, },
-	{ .size = SZ_64M,  .flag = PMB_SZ_64M,  },
-	{ .size = SZ_16M,  .flag = PMB_SZ_16M,  },
-};
-
-static void pmb_unmap_entry(struct pmb_entry *, int depth);
-
-static DEFINE_RWLOCK(pmb_rwlock);
-static struct pmb_entry pmb_entry_list[NR_PMB_ENTRIES];
-static DECLARE_BITMAP(pmb_map, NR_PMB_ENTRIES);
-
-static unsigned int pmb_iomapping_enabled;
-
-static __always_inline unsigned long mk_pmb_entry(unsigned int entry)
-{
-	return (entry & PMB_E_MASK) << PMB_E_SHIFT;
-}
-
-static __always_inline unsigned long mk_pmb_addr(unsigned int entry)
-{
-	return mk_pmb_entry(entry) | PMB_ADDR;
-}
-
-static __always_inline unsigned long mk_pmb_data(unsigned int entry)
-{
-	return mk_pmb_entry(entry) | PMB_DATA;
-}
-
-static __always_inline unsigned int pmb_ppn_in_range(unsigned long ppn)
-{
-	return ppn >= __pa(memory_start) && ppn < __pa(memory_end);
-}
-
-/*
- * Ensure that the PMB entries match our cache configuration.
- *
- * When we are in 32-bit address extended mode, CCR.CB becomes
- * invalid, so care must be taken to manually adjust cacheable
- * translations.
- */
-static __always_inline unsigned long pmb_cache_flags(void)
-{
-	unsigned long flags = 0;
-
-#if defined(CONFIG_CACHE_OFF)
-	flags |= PMB_WT | PMB_UB;
-#elif defined(CONFIG_CACHE_WRITETHROUGH)
-	flags |= PMB_C | PMB_WT | PMB_UB;
-#elif defined(CONFIG_CACHE_WRITEBACK)
-	flags |= PMB_C;
-#endif
-
-	return flags;
-}
-
-/*
- * Convert typical pgprot value to the PMB equivalent
- */
-static inline unsigned long pgprot_to_pmb_flags(pgprot_t prot)
-{
-	unsigned long pmb_flags = 0;
-	u64 flags = pgprot_val(prot);
-
-	if (flags & _PAGE_CACHABLE)
-		pmb_flags |= PMB_C;
-	if (flags & _PAGE_WT)
-		pmb_flags |= PMB_WT | PMB_UB;
-
-	return pmb_flags;
-}
-
-static inline bool pmb_can_merge(struct pmb_entry *a, struct pmb_entry *b)
-{
-	return (b->vpn == (a->vpn + a->size)) &&
-	       (b->ppn == (a->ppn + a->size)) &&
-	       (b->flags == a->flags);
-}
-
-static bool pmb_mapping_exists(unsigned long vaddr, phys_addr_t phys,
-			       unsigned long size)
-{
-	int i;
-
-	read_lock(&pmb_rwlock);
-
-	for (i = 0; i < ARRAY_SIZE(pmb_entry_list); i++) {
-		struct pmb_entry *pmbe, *iter;
-		unsigned long span;
-
-		if (!test_bit(i, pmb_map))
-			continue;
-
-		pmbe = &pmb_entry_list[i];
-
-		/*
-		 * See if VPN and PPN are bounded by an existing mapping.
-		 */
-		if ((vaddr < pmbe->vpn) || (vaddr >= (pmbe->vpn + pmbe->size)))
-			continue;
-		if ((phys < pmbe->ppn) || (phys >= (pmbe->ppn + pmbe->size)))
-			continue;
-
-		/*
-		 * Now see if we're in range of a simple mapping.
-		 */
-		if (size <= pmbe->size) {
-			read_unlock(&pmb_rwlock);
-			return true;
-		}
-
-		span = pmbe->size;
-
-		/*
-		 * Finally for sizes that involve compound mappings, walk
-		 * the chain.
-		 */
-		for (iter = pmbe->link; iter; iter = iter->link)
-			span += iter->size;
-
-		/*
-		 * Nothing else to do if the range requirements are met.
-		 */
-		if (size <= span) {
-			read_unlock(&pmb_rwlock);
-			return true;
-		}
-	}
-
-	read_unlock(&pmb_rwlock);
-	return false;
-}
-
-static bool pmb_size_valid(unsigned long size)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(pmb_sizes); i++)
-		if (pmb_sizes[i].size == size)
-			return true;
-
-	return false;
-}
-
-static inline bool pmb_addr_valid(unsigned long addr, unsigned long size)
-{
-	return (addr >= P1SEG && (addr + size - 1) < P3SEG);
-}
-
-static inline bool pmb_prot_valid(pgprot_t prot)
-{
-	return (pgprot_val(prot) & _PAGE_USER) == 0;
-}
-
-static int pmb_size_to_flags(unsigned long size)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(pmb_sizes); i++)
-		if (pmb_sizes[i].size == size)
-			return pmb_sizes[i].flag;
-
-	return 0;
-}
-
-static int pmb_alloc_entry(void)
-{
-	int pos;
-
-	pos = find_first_zero_bit(pmb_map, NR_PMB_ENTRIES);
-	if (pos >= 0 && pos < NR_PMB_ENTRIES)
-		__set_bit(pos, pmb_map);
-	else
-		pos = -ENOSPC;
-
-	return pos;
-}
-
-static struct pmb_entry *pmb_alloc(unsigned long vpn, unsigned long ppn,
-				   unsigned long flags, int entry)
-{
-	struct pmb_entry *pmbe;
-	unsigned long irqflags;
-	void *ret = NULL;
-	int pos;
-
-	write_lock_irqsave(&pmb_rwlock, irqflags);
-
-	if (entry == PMB_NO_ENTRY) {
-		pos = pmb_alloc_entry();
-		if (unlikely(pos < 0)) {
-			ret = ERR_PTR(pos);
-			goto out;
-		}
-	} else {
-		if (__test_and_set_bit(entry, pmb_map)) {
-			ret = ERR_PTR(-ENOSPC);
-			goto out;
-		}
-
-		pos = entry;
-	}
-
-	write_unlock_irqrestore(&pmb_rwlock, irqflags);
-
-	pmbe = &pmb_entry_list[pos];
-
-	memset(pmbe, 0, sizeof(struct pmb_entry));
-
-	raw_spin_lock_init(&pmbe->lock);
-
-	pmbe->vpn	= vpn;
-	pmbe->ppn	= ppn;
-	pmbe->flags	= flags;
-	pmbe->entry	= pos;
-
-	return pmbe;
-
-out:
-	write_unlock_irqrestore(&pmb_rwlock, irqflags);
-	return ret;
-}
-
-static void pmb_free(struct pmb_entry *pmbe)
-{
-	__clear_bit(pmbe->entry, pmb_map);
-
-	pmbe->entry	= PMB_NO_ENTRY;
-	pmbe->link	= NULL;
-}
-
-/*
- * Must be run uncached.
- */
-static void __set_pmb_entry(struct pmb_entry *pmbe)
-{
-	unsigned long addr, data;
-
-	addr = mk_pmb_addr(pmbe->entry);
-	data = mk_pmb_data(pmbe->entry);
-
-	jump_to_uncached();
-
-	/* Set V-bit */
-	__raw_writel(pmbe->vpn | PMB_V, addr);
-	__raw_writel(pmbe->ppn | pmbe->flags | PMB_V, data);
-
-	back_to_cached();
-}
-
-static void __clear_pmb_entry(struct pmb_entry *pmbe)
-{
-	unsigned long addr, data;
-	unsigned long addr_val, data_val;
-
-	addr = mk_pmb_addr(pmbe->entry);
-	data = mk_pmb_data(pmbe->entry);
-
-	addr_val = __raw_readl(addr);
-	data_val = __raw_readl(data);
-
-	/* Clear V-bit */
-	writel_uncached(addr_val & ~PMB_V, addr);
-	writel_uncached(data_val & ~PMB_V, data);
-}
-
-#ifdef CONFIG_PM
-static void set_pmb_entry(struct pmb_entry *pmbe)
-{
-	unsigned long flags;
-
-	raw_spin_lock_irqsave(&pmbe->lock, flags);
-	__set_pmb_entry(pmbe);
-	raw_spin_unlock_irqrestore(&pmbe->lock, flags);
-}
-#endif /* CONFIG_PM */
-
-int pmb_bolt_mapping(unsigned long vaddr, phys_addr_t phys,
-		     unsigned long size, pgprot_t prot)
-{
-	struct pmb_entry *pmbp, *pmbe;
-	unsigned long orig_addr, orig_size;
-	unsigned long flags, pmb_flags;
-	int i, mapped;
-
-	if (size < SZ_16M)
-		return -EINVAL;
-	if (!pmb_addr_valid(vaddr, size))
-		return -EFAULT;
-	if (pmb_mapping_exists(vaddr, phys, size))
-		return 0;
-
-	orig_addr = vaddr;
-	orig_size = size;
-
-	flush_tlb_kernel_range(vaddr, vaddr + size);
-
-	pmb_flags = pgprot_to_pmb_flags(prot);
-	pmbp = NULL;
-
-	do {
-		for (i = mapped = 0; i < ARRAY_SIZE(pmb_sizes); i++) {
-			if (size < pmb_sizes[i].size)
-				continue;
-
-			pmbe = pmb_alloc(vaddr, phys, pmb_flags |
-					 pmb_sizes[i].flag, PMB_NO_ENTRY);
-			if (IS_ERR(pmbe)) {
-				pmb_unmap_entry(pmbp, mapped);
-				return PTR_ERR(pmbe);
-			}
-
-			raw_spin_lock_irqsave(&pmbe->lock, flags);
-
-			pmbe->size = pmb_sizes[i].size;
-
-			__set_pmb_entry(pmbe);
-
-			phys	+= pmbe->size;
-			vaddr	+= pmbe->size;
-			size	-= pmbe->size;
-
-			/*
-			 * Link adjacent entries that span multiple PMB
-			 * entries for easier tear-down.
-			 */
-			if (likely(pmbp)) {
-				raw_spin_lock_nested(&pmbp->lock,
-						     SINGLE_DEPTH_NESTING);
-				pmbp->link = pmbe;
-				raw_spin_unlock(&pmbp->lock);
-			}
-
-			pmbp = pmbe;
-
-			/*
-			 * Instead of trying smaller sizes on every
-			 * iteration (even if we succeed in allocating
-			 * space), try using pmb_sizes[i].size again.
-			 */
-			i--;
-			mapped++;
-
-			raw_spin_unlock_irqrestore(&pmbe->lock, flags);
-		}
-	} while (size >= SZ_16M);
-
-	flush_cache_vmap(orig_addr, orig_addr + orig_size);
-
-	return 0;
-}
-
-void __iomem *pmb_remap_caller(phys_addr_t phys, unsigned long size,
-			       pgprot_t prot, void *caller)
-{
-	unsigned long vaddr;
-	phys_addr_t offset, last_addr;
-	phys_addr_t align_mask;
-	unsigned long aligned;
-	struct vm_struct *area;
-	int i, ret;
-
-	if (!pmb_iomapping_enabled)
-		return NULL;
-
-	/*
-	 * Small mappings need to go through the TLB.
-	 */
-	if (size < SZ_16M)
-		return ERR_PTR(-EINVAL);
-	if (!pmb_prot_valid(prot))
-		return ERR_PTR(-EINVAL);
-
-	for (i = 0; i < ARRAY_SIZE(pmb_sizes); i++)
-		if (size >= pmb_sizes[i].size)
-			break;
-
-	last_addr = phys + size;
-	align_mask = ~(pmb_sizes[i].size - 1);
-	offset = phys & ~align_mask;
-	phys &= align_mask;
-	aligned = ALIGN(last_addr, pmb_sizes[i].size) - phys;
-
-	/*
-	 * XXX: This should really start from uncached_end, but this
-	 * causes the MMU to reset, so for now we restrict it to the
-	 * 0xb000...0xc000 range.
-	 */
-	area = __get_vm_area_caller(aligned, VM_IOREMAP, 0xb0000000,
-				    P3SEG, caller);
-	if (!area)
-		return NULL;
-
-	area->phys_addr = phys;
-	vaddr = (unsigned long)area->addr;
-
-	ret = pmb_bolt_mapping(vaddr, phys, size, prot);
-	if (unlikely(ret != 0))
-		return ERR_PTR(ret);
-
-	return (void __iomem *)(offset + (char *)vaddr);
-}
-
-int pmb_unmap(void __iomem *addr)
-{
-	struct pmb_entry *pmbe = NULL;
-	unsigned long vaddr = (unsigned long __force)addr;
-	int i, found = 0;
-
-	read_lock(&pmb_rwlock);
-
-	for (i = 0; i < ARRAY_SIZE(pmb_entry_list); i++) {
-		if (test_bit(i, pmb_map)) {
-			pmbe = &pmb_entry_list[i];
-			if (pmbe->vpn == vaddr) {
-				found = 1;
-				break;
-			}
-		}
-	}
-
-	read_unlock(&pmb_rwlock);
-
-	if (found) {
-		pmb_unmap_entry(pmbe, NR_PMB_ENTRIES);
-		return 0;
-	}
-
-	return -EINVAL;
-}
-
-static void __pmb_unmap_entry(struct pmb_entry *pmbe, int depth)
-{
-	do {
-		struct pmb_entry *pmblink = pmbe;
-
-		/*
-		 * We may be called before this pmb_entry has been
-		 * entered into the PMB table via set_pmb_entry(), but
-		 * that's OK because we've allocated a unique slot for
-		 * this entry in pmb_alloc() (even if we haven't filled
-		 * it yet).
-		 *
-		 * Therefore, calling __clear_pmb_entry() is safe as no
-		 * other mapping can be using that slot.
-		 */
-		__clear_pmb_entry(pmbe);
-
-		flush_cache_vunmap(pmbe->vpn, pmbe->vpn + pmbe->size);
-
-		pmbe = pmblink->link;
-
-		pmb_free(pmblink);
-	} while (pmbe && --depth);
-}
-
-static void pmb_unmap_entry(struct pmb_entry *pmbe, int depth)
-{
-	unsigned long flags;
-
-	if (unlikely(!pmbe))
-		return;
-
-	write_lock_irqsave(&pmb_rwlock, flags);
-	__pmb_unmap_entry(pmbe, depth);
-	write_unlock_irqrestore(&pmb_rwlock, flags);
-}
-
-static void __init pmb_notify(void)
-{
-	int i;
-
-	pr_info("PMB: boot mappings:\n");
-
-	read_lock(&pmb_rwlock);
-
-	for (i = 0; i < ARRAY_SIZE(pmb_entry_list); i++) {
-		struct pmb_entry *pmbe;
-
-		if (!test_bit(i, pmb_map))
-			continue;
-
-		pmbe = &pmb_entry_list[i];
-
-		pr_info("       0x%08lx -> 0x%08lx [ %4ldMB %2scached ]\n",
-			pmbe->vpn >> PAGE_SHIFT, pmbe->ppn >> PAGE_SHIFT,
-			pmbe->size >> 20, (pmbe->flags & PMB_C) ? "" : "un");
-	}
-
-	read_unlock(&pmb_rwlock);
-}
-
-/*
- * Sync our software copy of the PMB mappings with those in hardware. The
- * mappings in the hardware PMB were either set up by the bootloader or
- * very early on by the kernel.
- */
-static void __init pmb_synchronize(void)
-{
-	struct pmb_entry *pmbp = NULL;
-	int i, j;
-
-	/*
-	 * Run through the initial boot mappings, log the established
-	 * ones, and blow away anything that falls outside of the valid
-	 * PPN range. Specifically, we only care about existing mappings
-	 * that impact the cached/uncached sections.
-	 *
-	 * Note that touching these can be a bit of a minefield; the boot
-	 * loader can establish multi-page mappings with the same caching
-	 * attributes, so we need to ensure that we aren't modifying a
-	 * mapping that we're presently executing from, or may execute
-	 * from in the case of straddling page boundaries.
-	 *
-	 * In the future we will have to tidy up after the boot loader by
-	 * jumping between the cached and uncached mappings and tearing
-	 * down alternating mappings while executing from the other.
-	 */
-	for (i = 0; i < NR_PMB_ENTRIES; i++) {
-		unsigned long addr, data;
-		unsigned long addr_val, data_val;
-		unsigned long ppn, vpn, flags;
-		unsigned long irqflags;
-		unsigned int size;
-		struct pmb_entry *pmbe;
-
-		addr = mk_pmb_addr(i);
-		data = mk_pmb_data(i);
-
-		addr_val = __raw_readl(addr);
-		data_val = __raw_readl(data);
-
-		/*
-		 * Skip over any bogus entries
-		 */
-		if (!(data_val & PMB_V) || !(addr_val & PMB_V))
-			continue;
-
-		ppn = data_val & PMB_PFN_MASK;
-		vpn = addr_val & PMB_PFN_MASK;
-
-		/*
-		 * Only preserve in-range mappings.
-		 */
-		if (!pmb_ppn_in_range(ppn)) {
-			/*
-			 * Invalidate anything out of bounds.
-			 */
-			writel_uncached(addr_val & ~PMB_V, addr);
-			writel_uncached(data_val & ~PMB_V, data);
-			continue;
-		}
-
-		/*
-		 * Update the caching attributes if necessary
-		 */
-		if (data_val & PMB_C) {
-			data_val &= ~PMB_CACHE_MASK;
-			data_val |= pmb_cache_flags();
-
-			writel_uncached(data_val, data);
-		}
-
-		size = data_val & PMB_SZ_MASK;
-		flags = size | (data_val & PMB_CACHE_MASK);
-
-		pmbe = pmb_alloc(vpn, ppn, flags, i);
-		if (IS_ERR(pmbe)) {
-			WARN_ON_ONCE(1);
-			continue;
-		}
-
-		raw_spin_lock_irqsave(&pmbe->lock, irqflags);
-
-		for (j = 0; j < ARRAY_SIZE(pmb_sizes); j++)
-			if (pmb_sizes[j].flag == size)
-				pmbe->size = pmb_sizes[j].size;
-
-		if (pmbp) {
-			raw_spin_lock_nested(&pmbp->lock, SINGLE_DEPTH_NESTING);
-			/*
-			 * Compare the previous entry against the current one to
-			 * see if the entries span a contiguous mapping. If so,
-			 * setup the entry links accordingly. Compound mappings
-			 * are later coalesced.
-			 */
-			if (pmb_can_merge(pmbp, pmbe))
-				pmbp->link = pmbe;
-			raw_spin_unlock(&pmbp->lock);
-		}
-
-		pmbp = pmbe;
-
-		raw_spin_unlock_irqrestore(&pmbe->lock, irqflags);
-	}
-}
-
-static void __init pmb_merge(struct pmb_entry *head)
-{
-	unsigned long span, newsize;
-	struct pmb_entry *tail;
-	int i = 1, depth = 0;
-
-	span = newsize = head->size;
-
-	tail = head->link;
-	while (tail) {
-		span += tail->size;
-
-		if (pmb_size_valid(span)) {
-			newsize = span;
-			depth = i;
-		}
-
-		/* This is the end of the line.. */
-		if (!tail->link)
-			break;
-
-		tail = tail->link;
-		i++;
-	}
-
-	/*
-	 * The merged page size must be valid.
-	 */
-	if (!depth || !pmb_size_valid(newsize))
-		return;
-
-	head->flags &= ~PMB_SZ_MASK;
-	head->flags |= pmb_size_to_flags(newsize);
-
-	head->size = newsize;
-
-	__pmb_unmap_entry(head->link, depth);
-	__set_pmb_entry(head);
-}
-
-static void __init pmb_coalesce(void)
-{
-	unsigned long flags;
-	int i;
-
-	write_lock_irqsave(&pmb_rwlock, flags);
-
-	for (i = 0; i < ARRAY_SIZE(pmb_entry_list); i++) {
-		struct pmb_entry *pmbe;
-
-		if (!test_bit(i, pmb_map))
-			continue;
-
-		pmbe = &pmb_entry_list[i];
-
-		/*
-		 * We're only interested in compound mappings
-		 */
-		if (!pmbe->link)
-			continue;
-
-		/*
-		 * Nothing to do if it already uses the largest possible
-		 * page size.
-		 */
-		if (pmbe->size == SZ_512M)
-			continue;
-
-		pmb_merge(pmbe);
-	}
-
-	write_unlock_irqrestore(&pmb_rwlock, flags);
-}
-
-#ifdef CONFIG_UNCACHED_MAPPING
-static void __init pmb_resize(void)
-{
-	int i;
-
-	/*
-	 * If the uncached mapping was constructed by the kernel, it will
-	 * already be a reasonable size.
-	 */
-	if (uncached_size == SZ_16M)
-		return;
-
-	read_lock(&pmb_rwlock);
-
-	for (i = 0; i < ARRAY_SIZE(pmb_entry_list); i++) {
-		struct pmb_entry *pmbe;
-		unsigned long flags;
-
-		if (!test_bit(i, pmb_map))
-			continue;
-
-		pmbe = &pmb_entry_list[i];
-
-		if (pmbe->vpn != uncached_start)
-			continue;
-
-		/*
-		 * Found it, now resize it.
-		 */
-		raw_spin_lock_irqsave(&pmbe->lock, flags);
-
-		pmbe->size = SZ_16M;
-		pmbe->flags &= ~PMB_SZ_MASK;
-		pmbe->flags |= pmb_size_to_flags(pmbe->size);
-
-		uncached_resize(pmbe->size);
-
-		__set_pmb_entry(pmbe);
-
-		raw_spin_unlock_irqrestore(&pmbe->lock, flags);
-	}
-
-	read_unlock(&pmb_rwlock);
-}
-#endif
-
-static int __init early_pmb(char *p)
-{
-	if (!p)
-		return 0;
-
-	if (strstr(p, "iomap"))
-		pmb_iomapping_enabled = 1;
-
-	return 0;
-}
-early_param("pmb", early_pmb);
-
-void __init pmb_init(void)
-{
-	/* Synchronize software state */
-	pmb_synchronize();
-
-	/* Attempt to combine compound mappings */
-	pmb_coalesce();
-
-#ifdef CONFIG_UNCACHED_MAPPING
-	/* Resize initial mappings, if necessary */
-	pmb_resize();
-#endif
-
-	/* Log them */
-	pmb_notify();
-
-	writel_uncached(0, PMB_IRMCR);
-
-	/* Flush out the TLB */
-	local_flush_tlb_all();
-	ctrl_barrier();
-}
-
-bool __in_29bit_mode(void)
-{
-        return (__raw_readl(PMB_PASCR) & PASCR_SE) == 0;
-}
-
-static int pmb_debugfs_show(struct seq_file *file, void *iter)
-{
-	int i;
-
-	seq_printf(file, "V: Valid, C: Cacheable, WT: Write-Through\n"
-			 "CB: Copy-Back, B: Buffered, UB: Unbuffered\n");
-	seq_printf(file, "ety   vpn  ppn  size   flags\n");
-
-	for (i = 0; i < NR_PMB_ENTRIES; i++) {
-		unsigned long addr, data;
-		unsigned int size;
-		char *sz_str = NULL;
-
-		addr = __raw_readl(mk_pmb_addr(i));
-		data = __raw_readl(mk_pmb_data(i));
-
-		size = data & PMB_SZ_MASK;
-		sz_str = (size == PMB_SZ_16M)  ? " 16MB":
-			 (size == PMB_SZ_64M)  ? " 64MB":
-			 (size == PMB_SZ_128M) ? "128MB":
-					         "512MB";
-
-		/* 02: V 0x88 0x08 128MB C CB  B */
-		seq_printf(file, "%02d: %c 0x%02lx 0x%02lx %s %c %s %s\n",
-			   i, ((addr & PMB_V) && (data & PMB_V)) ? 'V' : ' ',
-			   (addr >> 24) & 0xff, (data >> 24) & 0xff,
-			   sz_str, (data & PMB_C) ? 'C' : ' ',
-			   (data & PMB_WT) ? "WT" : "CB",
-			   (data & PMB_UB) ? "UB" : " B");
-	}
-
-	return 0;
-}
-
-DEFINE_SHOW_ATTRIBUTE(pmb_debugfs);
-
-static int __init pmb_debugfs_init(void)
-{
-	debugfs_create_file("pmb", S_IFREG | S_IRUGO, arch_debugfs_dir, NULL,
-			    &pmb_debugfs_fops);
-	return 0;
-}
-subsys_initcall(pmb_debugfs_init);
-
-#ifdef CONFIG_PM
-static void pmb_syscore_resume(void)
-{
-	struct pmb_entry *pmbe;
-	int i;
-
-	read_lock(&pmb_rwlock);
-
-	for (i = 0; i < ARRAY_SIZE(pmb_entry_list); i++) {
-		if (test_bit(i, pmb_map)) {
-			pmbe = &pmb_entry_list[i];
-			set_pmb_entry(pmbe);
-		}
-	}
-
-	read_unlock(&pmb_rwlock);
-}
-
-static struct syscore_ops pmb_syscore_ops = {
-	.resume = pmb_syscore_resume,
-};
-
-static int __init pmb_sysdev_init(void)
-{
-	register_syscore_ops(&pmb_syscore_ops);
-	return 0;
-}
-subsys_initcall(pmb_sysdev_init);
-#endif
diff --git a/arch/sh/mm/sram.c b/arch/sh/mm/sram.c
deleted file mode 100644
index 2d8fa718d55e74..00000000000000
--- a/arch/sh/mm/sram.c
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * SRAM pool for tiny memories not otherwise managed.
- *
- * Copyright (C) 2010  Paul Mundt
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- */
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <asm/sram.h>
-
-/*
- * This provides a standard SRAM pool for tiny memories that can be
- * added either by the CPU or the platform code. Typical SRAM sizes
- * to be inserted in to the pool will generally be less than the page
- * size, with anything more reasonably sized handled as a NUMA memory
- * node.
- */
-struct gen_pool *sram_pool;
-
-static int __init sram_pool_init(void)
-{
-	/*
-	 * This is a global pool, we don't care about node locality.
-	 */
-	sram_pool = gen_pool_create(1, -1);
-	if (unlikely(!sram_pool))
-		return -ENOMEM;
-
-	return 0;
-}
-core_initcall(sram_pool_init);
diff --git a/arch/sh/mm/tlb-debugfs.c b/arch/sh/mm/tlb-debugfs.c
deleted file mode 100644
index 11c6148283f3c7..00000000000000
--- a/arch/sh/mm/tlb-debugfs.c
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
- * arch/sh/mm/tlb-debugfs.c
- *
- * debugfs ops for SH-4 ITLB/UTLBs.
- *
- * Copyright (C) 2010  Matt Fleming
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- */
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/debugfs.h>
-#include <linux/seq_file.h>
-#include <asm/processor.h>
-#include <asm/mmu_context.h>
-#include <asm/tlbflush.h>
-
-enum tlb_type {
-	TLB_TYPE_ITLB,
-	TLB_TYPE_UTLB,
-};
-
-static struct {
-	int bits;
-	const char *size;
-} tlb_sizes[] = {
-	{ 0x0, "  1KB" },
-	{ 0x1, "  4KB" },
-	{ 0x2, "  8KB" },
-	{ 0x4, " 64KB" },
-	{ 0x5, "256KB" },
-	{ 0x7, "  1MB" },
-	{ 0x8, "  4MB" },
-	{ 0xc, " 64MB" },
-};
-
-static int tlb_seq_show(struct seq_file *file, void *iter)
-{
-	unsigned int tlb_type = (unsigned int)file->private;
-	unsigned long addr1, addr2, data1, data2;
-	unsigned long flags;
-	unsigned long mmucr;
-	unsigned int nentries, entry;
-	unsigned int urb;
-
-	mmucr = __raw_readl(MMUCR);
-	if ((mmucr & 0x1) == 0) {
-		seq_printf(file, "address translation disabled\n");
-		return 0;
-	}
-
-	if (tlb_type == TLB_TYPE_ITLB) {
-		addr1 = MMU_ITLB_ADDRESS_ARRAY;
-		addr2 = MMU_ITLB_ADDRESS_ARRAY2;
-		data1 = MMU_ITLB_DATA_ARRAY;
-		data2 = MMU_ITLB_DATA_ARRAY2;
-		nentries = 4;
-	} else {
-		addr1 = MMU_UTLB_ADDRESS_ARRAY;
-		addr2 = MMU_UTLB_ADDRESS_ARRAY2;
-		data1 = MMU_UTLB_DATA_ARRAY;
-		data2 = MMU_UTLB_DATA_ARRAY2;
-		nentries = 64;
-	}
-
-	local_irq_save(flags);
-	jump_to_uncached();
-
-	urb = (mmucr & MMUCR_URB) >> MMUCR_URB_SHIFT;
-
-	/* Make the "entry >= urb" test fail. */
-	if (urb == 0)
-		urb = MMUCR_URB_NENTRIES + 1;
-
-	if (tlb_type == TLB_TYPE_ITLB) {
-		addr1 = MMU_ITLB_ADDRESS_ARRAY;
-		addr2 = MMU_ITLB_ADDRESS_ARRAY2;
-		data1 = MMU_ITLB_DATA_ARRAY;
-		data2 = MMU_ITLB_DATA_ARRAY2;
-		nentries = 4;
-	} else {
-		addr1 = MMU_UTLB_ADDRESS_ARRAY;
-		addr2 = MMU_UTLB_ADDRESS_ARRAY2;
-		data1 = MMU_UTLB_DATA_ARRAY;
-		data2 = MMU_UTLB_DATA_ARRAY2;
-		nentries = 64;
-	}
-
-	seq_printf(file, "entry:     vpn        ppn     asid  size valid wired\n");
-
-	for (entry = 0; entry < nentries; entry++) {
-		unsigned long vpn, ppn, asid, size;
-		unsigned long valid;
-		unsigned long val;
-		const char *sz = "    ?";
-		int i;
-
-		val = __raw_readl(addr1 | (entry << MMU_TLB_ENTRY_SHIFT));
-		ctrl_barrier();
-		vpn = val & 0xfffffc00;
-		valid = val & 0x100;
-
-		val = __raw_readl(addr2 | (entry << MMU_TLB_ENTRY_SHIFT));
-		ctrl_barrier();
-		asid = val & MMU_CONTEXT_ASID_MASK;
-
-		val = __raw_readl(data1 | (entry << MMU_TLB_ENTRY_SHIFT));
-		ctrl_barrier();
-		ppn = (val & 0x0ffffc00) << 4;
-
-		val = __raw_readl(data2 | (entry << MMU_TLB_ENTRY_SHIFT));
-		ctrl_barrier();
-		size = (val & 0xf0) >> 4;
-
-		for (i = 0; i < ARRAY_SIZE(tlb_sizes); i++) {
-			if (tlb_sizes[i].bits == size)
-				break;
-		}
-
-		if (i != ARRAY_SIZE(tlb_sizes))
-			sz = tlb_sizes[i].size;
-
-		seq_printf(file, "%2d:    0x%08lx 0x%08lx %5lu %s   %s     %s\n",
-			   entry, vpn, ppn, asid,
-			   sz, valid ? "V" : "-",
-			   (urb <= entry) ? "W" : "-");
-	}
-
-	back_to_cached();
-	local_irq_restore(flags);
-
-	return 0;
-}
-
-static int tlb_debugfs_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, tlb_seq_show, inode->i_private);
-}
-
-static const struct file_operations tlb_debugfs_fops = {
-	.owner		= THIS_MODULE,
-	.open		= tlb_debugfs_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-static int __init tlb_debugfs_init(void)
-{
-	debugfs_create_file("itlb", S_IRUSR, arch_debugfs_dir,
-			    (void *)TLB_TYPE_ITLB, &tlb_debugfs_fops);
-	debugfs_create_file("utlb", S_IRUSR, arch_debugfs_dir,
-			    (void *)TLB_TYPE_UTLB, &tlb_debugfs_fops);
-	return 0;
-}
-module_init(tlb_debugfs_init);
-
-MODULE_LICENSE("GPL v2");
diff --git a/arch/sh/mm/tlb-pteaex.c b/arch/sh/mm/tlb-pteaex.c
deleted file mode 100644
index 4db21adfe5deba..00000000000000
--- a/arch/sh/mm/tlb-pteaex.c
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * arch/sh/mm/tlb-pteaex.c
- *
- * TLB operations for SH-X3 CPUs featuring PTE ASID Extensions.
- *
- * Copyright (C) 2009 Paul Mundt
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- */
-#include <linux/kernel.h>
-#include <linux/mm.h>
-#include <linux/io.h>
-#include <asm/mmu_context.h>
-#include <asm/cacheflush.h>
-
-void __update_tlb(struct vm_area_struct *vma, unsigned long address, pte_t pte)
-{
-	unsigned long flags, pteval, vpn;
-
-	/*
-	 * Handle debugger faulting in for debugee.
-	 */
-	if (vma && current->active_mm != vma->vm_mm)
-		return;
-
-	local_irq_save(flags);
-
-	/* Set PTEH register */
-	vpn = address & MMU_VPN_MASK;
-	__raw_writel(vpn, MMU_PTEH);
-
-	/* Set PTEAEX */
-	__raw_writel(get_asid(), MMU_PTEAEX);
-
-	pteval = pte.pte_low;
-
-	/* Set PTEA register */
-#ifdef CONFIG_X2TLB
-	/*
-	 * For the extended mode TLB this is trivial, only the ESZ and
-	 * EPR bits need to be written out to PTEA, with the remainder of
-	 * the protection bits (with the exception of the compat-mode SZ
-	 * and PR bits, which are cleared) being written out in PTEL.
-	 */
-	__raw_writel(pte.pte_high, MMU_PTEA);
-#endif
-
-	/* Set PTEL register */
-	pteval &= _PAGE_FLAGS_HARDWARE_MASK; /* drop software flags */
-#ifdef CONFIG_CACHE_WRITETHROUGH
-	pteval |= _PAGE_WT;
-#endif
-	/* conveniently, we want all the software flags to be 0 anyway */
-	__raw_writel(pteval, MMU_PTEL);
-
-	/* Load the TLB */
-	asm volatile("ldtlb": /* no output */ : /* no input */ : "memory");
-	local_irq_restore(flags);
-}
-
-/*
- * While SH-X2 extended TLB mode splits out the memory-mapped I/UTLB
- * data arrays, SH-X3 cores with PTEAEX split out the memory-mapped
- * address arrays. In compat mode the second array is inaccessible, while
- * in extended mode, the legacy 8-bit ASID field in address array 1 has
- * undefined behaviour.
- */
-void local_flush_tlb_one(unsigned long asid, unsigned long page)
-{
-	jump_to_uncached();
-	__raw_writel(page, MMU_UTLB_ADDRESS_ARRAY | MMU_PAGE_ASSOC_BIT);
-	__raw_writel(asid, MMU_UTLB_ADDRESS_ARRAY2 | MMU_PAGE_ASSOC_BIT);
-	__raw_writel(page, MMU_ITLB_ADDRESS_ARRAY | MMU_PAGE_ASSOC_BIT);
-	__raw_writel(asid, MMU_ITLB_ADDRESS_ARRAY2 | MMU_PAGE_ASSOC_BIT);
-	back_to_cached();
-}
-
-void local_flush_tlb_all(void)
-{
-	unsigned long flags, status;
-	int i;
-
-	/*
-	 * Flush all the TLB.
-	 */
-	local_irq_save(flags);
-	jump_to_uncached();
-
-	status = __raw_readl(MMUCR);
-	status = ((status & MMUCR_URB) >> MMUCR_URB_SHIFT);
-
-	if (status == 0)
-		status = MMUCR_URB_NENTRIES;
-
-	for (i = 0; i < status; i++)
-		__raw_writel(0x0, MMU_UTLB_ADDRESS_ARRAY | (i << 8));
-
-	for (i = 0; i < 4; i++)
-		__raw_writel(0x0, MMU_ITLB_ADDRESS_ARRAY | (i << 8));
-
-	back_to_cached();
-	ctrl_barrier();
-	local_irq_restore(flags);
-}
diff --git a/arch/sh/mm/tlb-sh3.c b/arch/sh/mm/tlb-sh3.c
deleted file mode 100644
index fb400afc2a496a..00000000000000
--- a/arch/sh/mm/tlb-sh3.c
+++ /dev/null
@@ -1,95 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * arch/sh/mm/tlb-sh3.c
- *
- * SH-3 specific TLB operations
- *
- * Copyright (C) 1999  Niibe Yutaka
- * Copyright (C) 2002  Paul Mundt
- */
-#include <linux/signal.h>
-#include <linux/sched.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/types.h>
-#include <linux/ptrace.h>
-#include <linux/mman.h>
-#include <linux/mm.h>
-#include <linux/smp.h>
-#include <linux/interrupt.h>
-
-#include <asm/io.h>
-#include <linux/uaccess.h>
-#include <asm/mmu_context.h>
-#include <asm/cacheflush.h>
-
-void __update_tlb(struct vm_area_struct *vma, unsigned long address, pte_t pte)
-{
-	unsigned long flags, pteval, vpn;
-
-	/*
-	 * Handle debugger faulting in for debugee.
-	 */
-	if (vma && current->active_mm != vma->vm_mm)
-		return;
-
-	local_irq_save(flags);
-
-	/* Set PTEH register */
-	vpn = (address & MMU_VPN_MASK) | get_asid();
-	__raw_writel(vpn, MMU_PTEH);
-
-	pteval = pte_val(pte);
-
-	/* Set PTEL register */
-	pteval &= _PAGE_FLAGS_HARDWARE_MASK; /* drop software flags */
-	/* conveniently, we want all the software flags to be 0 anyway */
-	__raw_writel(pteval, MMU_PTEL);
-
-	/* Load the TLB */
-	asm volatile("ldtlb": /* no output */ : /* no input */ : "memory");
-	local_irq_restore(flags);
-}
-
-void local_flush_tlb_one(unsigned long asid, unsigned long page)
-{
-	unsigned long addr, data;
-	int i, ways = MMU_NTLB_WAYS;
-
-	/*
-	 * NOTE: PTEH.ASID should be set to this MM
-	 *       _AND_ we need to write ASID to the array.
-	 *
-	 * It would be simple if we didn't need to set PTEH.ASID...
-	 */
-	addr = MMU_TLB_ADDRESS_ARRAY | (page & 0x1F000);
-	data = (page & 0xfffe0000) | asid; /* VALID bit is off */
-
-	if ((current_cpu_data.flags & CPU_HAS_MMU_PAGE_ASSOC)) {
-		addr |= MMU_PAGE_ASSOC_BIT;
-		ways = 1;	/* we already know the way .. */
-	}
-
-	for (i = 0; i < ways; i++)
-		__raw_writel(data, addr + (i << 8));
-}
-
-void local_flush_tlb_all(void)
-{
-	unsigned long flags, status;
-
-	/*
-	 * Flush all the TLB.
-	 *
-	 * Write to the MMU control register's bit:
-	 *	TF-bit for SH-3, TI-bit for SH-4.
-	 *      It's same position, bit #2.
-	 */
-	local_irq_save(flags);
-	status = __raw_readl(MMUCR);
-	status |= 0x04;
-	__raw_writel(status, MMUCR);
-	ctrl_barrier();
-	local_irq_restore(flags);
-}
diff --git a/arch/sh/mm/tlb-sh4.c b/arch/sh/mm/tlb-sh4.c
deleted file mode 100644
index aa0a9f4680a1b1..00000000000000
--- a/arch/sh/mm/tlb-sh4.c
+++ /dev/null
@@ -1,108 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * arch/sh/mm/tlb-sh4.c
- *
- * SH-4 specific TLB operations
- *
- * Copyright (C) 1999  Niibe Yutaka
- * Copyright (C) 2002 - 2007 Paul Mundt
- */
-#include <linux/kernel.h>
-#include <linux/mm.h>
-#include <linux/io.h>
-#include <asm/mmu_context.h>
-#include <asm/cacheflush.h>
-
-void __update_tlb(struct vm_area_struct *vma, unsigned long address, pte_t pte)
-{
-	unsigned long flags, pteval, vpn;
-
-	/*
-	 * Handle debugger faulting in for debugee.
-	 */
-	if (vma && current->active_mm != vma->vm_mm)
-		return;
-
-	local_irq_save(flags);
-
-	/* Set PTEH register */
-	vpn = (address & MMU_VPN_MASK) | get_asid();
-	__raw_writel(vpn, MMU_PTEH);
-
-	pteval = pte.pte_low;
-
-	/* Set PTEA register */
-#ifdef CONFIG_X2TLB
-	/*
-	 * For the extended mode TLB this is trivial, only the ESZ and
-	 * EPR bits need to be written out to PTEA, with the remainder of
-	 * the protection bits (with the exception of the compat-mode SZ
-	 * and PR bits, which are cleared) being written out in PTEL.
-	 */
-	__raw_writel(pte.pte_high, MMU_PTEA);
-#else
-	if (cpu_data->flags & CPU_HAS_PTEA) {
-		/* The last 3 bits and the first one of pteval contains
-		 * the PTEA timing control and space attribute bits
-		 */
-		__raw_writel(copy_ptea_attributes(pteval), MMU_PTEA);
-	}
-#endif
-
-	/* Set PTEL register */
-	pteval &= _PAGE_FLAGS_HARDWARE_MASK; /* drop software flags */
-#ifdef CONFIG_CACHE_WRITETHROUGH
-	pteval |= _PAGE_WT;
-#endif
-	/* conveniently, we want all the software flags to be 0 anyway */
-	__raw_writel(pteval, MMU_PTEL);
-
-	/* Load the TLB */
-	asm volatile("ldtlb": /* no output */ : /* no input */ : "memory");
-	local_irq_restore(flags);
-}
-
-void local_flush_tlb_one(unsigned long asid, unsigned long page)
-{
-	unsigned long addr, data;
-
-	/*
-	 * NOTE: PTEH.ASID should be set to this MM
-	 *       _AND_ we need to write ASID to the array.
-	 *
-	 * It would be simple if we didn't need to set PTEH.ASID...
-	 */
-	addr = MMU_UTLB_ADDRESS_ARRAY | MMU_PAGE_ASSOC_BIT;
-	data = page | asid; /* VALID bit is off */
-	jump_to_uncached();
-	__raw_writel(data, addr);
-	back_to_cached();
-}
-
-void local_flush_tlb_all(void)
-{
-	unsigned long flags, status;
-	int i;
-
-	/*
-	 * Flush all the TLB.
-	 */
-	local_irq_save(flags);
-	jump_to_uncached();
-
-	status = __raw_readl(MMUCR);
-	status = ((status & MMUCR_URB) >> MMUCR_URB_SHIFT);
-
-	if (status == 0)
-		status = MMUCR_URB_NENTRIES;
-
-	for (i = 0; i < status; i++)
-		__raw_writel(0x0, MMU_UTLB_ADDRESS_ARRAY | (i << 8));
-
-	for (i = 0; i < 4; i++)
-		__raw_writel(0x0, MMU_ITLB_ADDRESS_ARRAY | (i << 8));
-
-	back_to_cached();
-	ctrl_barrier();
-	local_irq_restore(flags);
-}
diff --git a/arch/sh/mm/tlb-urb.c b/arch/sh/mm/tlb-urb.c
deleted file mode 100644
index c92ce20db39bf4..00000000000000
--- a/arch/sh/mm/tlb-urb.c
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * arch/sh/mm/tlb-urb.c
- *
- * TLB entry wiring helpers for URB-equipped parts.
- *
- * Copyright (C) 2010  Matt Fleming
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- */
-#include <linux/mm.h>
-#include <linux/io.h>
-#include <asm/tlb.h>
-#include <asm/mmu_context.h>
-
-/*
- * Load the entry for 'addr' into the TLB and wire the entry.
- */
-void tlb_wire_entry(struct vm_area_struct *vma, unsigned long addr, pte_t pte)
-{
-	unsigned long status, flags;
-	int urb;
-
-	local_irq_save(flags);
-
-	status = __raw_readl(MMUCR);
-	urb = (status & MMUCR_URB) >> MMUCR_URB_SHIFT;
-	status &= ~MMUCR_URC;
-
-	/*
-	 * Make sure we're not trying to wire the last TLB entry slot.
-	 */
-	BUG_ON(!--urb);
-
-	urb = urb % MMUCR_URB_NENTRIES;
-
-	/*
-	 * Insert this entry into the highest non-wired TLB slot (via
-	 * the URC field).
-	 */
-	status |= (urb << MMUCR_URC_SHIFT);
-	__raw_writel(status, MMUCR);
-	ctrl_barrier();
-
-	/* Load the entry into the TLB */
-	__update_tlb(vma, addr, pte);
-
-	/* ... and wire it up. */
-	status = __raw_readl(MMUCR);
-
-	status &= ~MMUCR_URB;
-	status |= (urb << MMUCR_URB_SHIFT);
-
-	__raw_writel(status, MMUCR);
-	ctrl_barrier();
-
-	local_irq_restore(flags);
-}
-
-/*
- * Unwire the last wired TLB entry.
- *
- * It should also be noted that it is not possible to wire and unwire
- * TLB entries in an arbitrary order. If you wire TLB entry N, followed
- * by entry N+1, you must unwire entry N+1 first, then entry N. In this
- * respect, it works like a stack or LIFO queue.
- */
-void tlb_unwire_entry(void)
-{
-	unsigned long status, flags;
-	int urb;
-
-	local_irq_save(flags);
-
-	status = __raw_readl(MMUCR);
-	urb = (status & MMUCR_URB) >> MMUCR_URB_SHIFT;
-	status &= ~MMUCR_URB;
-
-	/*
-	 * Make sure we're not trying to unwire a TLB entry when none
-	 * have been wired.
-	 */
-	BUG_ON(urb++ == MMUCR_URB_NENTRIES);
-
-	urb = urb % MMUCR_URB_NENTRIES;
-
-	status |= (urb << MMUCR_URB_SHIFT);
-	__raw_writel(status, MMUCR);
-	ctrl_barrier();
-
-	local_irq_restore(flags);
-}
diff --git a/arch/sh/mm/tlbex_32.c b/arch/sh/mm/tlbex_32.c
deleted file mode 100644
index 1c53868632ee4c..00000000000000
--- a/arch/sh/mm/tlbex_32.c
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * TLB miss handler for SH with an MMU.
- *
- *  Copyright (C) 1999  Niibe Yutaka
- *  Copyright (C) 2003 - 2012  Paul Mundt
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- */
-#include <linux/kernel.h>
-#include <linux/mm.h>
-#include <linux/kprobes.h>
-#include <linux/kdebug.h>
-#include <asm/mmu_context.h>
-#include <asm/thread_info.h>
-
-/*
- * Called with interrupts disabled.
- */
-asmlinkage int __kprobes
-handle_tlbmiss(struct pt_regs *regs, unsigned long error_code,
-	       unsigned long address)
-{
-	pgd_t *pgd;
-	p4d_t *p4d;
-	pud_t *pud;
-	pmd_t *pmd;
-	pte_t *pte;
-	pte_t entry;
-
-	/*
-	 * We don't take page faults for P1, P2, and parts of P4, these
-	 * are always mapped, whether it be due to legacy behaviour in
-	 * 29-bit mode, or due to PMB configuration in 32-bit mode.
-	 */
-	if (address >= P3SEG && address < P3_ADDR_MAX) {
-		pgd = pgd_offset_k(address);
-	} else {
-		if (unlikely(address >= TASK_SIZE || !current->mm))
-			return 1;
-
-		pgd = pgd_offset(current->mm, address);
-	}
-
-	p4d = p4d_offset(pgd, address);
-	if (p4d_none_or_clear_bad(p4d))
-		return 1;
-	pud = pud_offset(p4d, address);
-	if (pud_none_or_clear_bad(pud))
-		return 1;
-	pmd = pmd_offset(pud, address);
-	if (pmd_none_or_clear_bad(pmd))
-		return 1;
-	pte = pte_offset_kernel(pmd, address);
-	entry = *pte;
-	if (unlikely(pte_none(entry) || pte_not_present(entry)))
-		return 1;
-	if (unlikely(error_code && !pte_write(entry)))
-		return 1;
-
-	if (error_code)
-		entry = pte_mkdirty(entry);
-	entry = pte_mkyoung(entry);
-
-	set_pte(pte, entry);
-
-#if defined(CONFIG_CPU_SH4) && !defined(CONFIG_SMP)
-	/*
-	 * SH-4 does not set MMUCR.RC to the corresponding TLB entry in
-	 * the case of an initial page write exception, so we need to
-	 * flush it in order to avoid potential TLB entry duplication.
-	 */
-	if (error_code == FAULT_CODE_INITIAL)
-		local_flush_tlb_one(get_asid(), address & PAGE_MASK);
-#endif
-
-	set_thread_fault_code(error_code);
-	update_mmu_cache(NULL, address, pte);
-
-	return 0;
-}
diff --git a/arch/sh/mm/tlbflush_32.c b/arch/sh/mm/tlbflush_32.c
deleted file mode 100644
index a6a20d6de4c0b9..00000000000000
--- a/arch/sh/mm/tlbflush_32.c
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * TLB flushing operations for SH with an MMU.
- *
- *  Copyright (C) 1999  Niibe Yutaka
- *  Copyright (C) 2003  Paul Mundt
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- */
-#include <linux/mm.h>
-#include <asm/mmu_context.h>
-#include <asm/tlbflush.h>
-
-void local_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)
-{
-	unsigned int cpu = smp_processor_id();
-
-	if (vma->vm_mm && cpu_context(cpu, vma->vm_mm) != NO_CONTEXT) {
-		unsigned long flags;
-		unsigned long asid;
-		unsigned long saved_asid = MMU_NO_ASID;
-
-		asid = cpu_asid(cpu, vma->vm_mm);
-		page &= PAGE_MASK;
-
-		local_irq_save(flags);
-		if (vma->vm_mm != current->mm) {
-			saved_asid = get_asid();
-			set_asid(asid);
-		}
-		local_flush_tlb_one(asid, page);
-		if (saved_asid != MMU_NO_ASID)
-			set_asid(saved_asid);
-		local_irq_restore(flags);
-	}
-}
-
-void local_flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
-			   unsigned long end)
-{
-	struct mm_struct *mm = vma->vm_mm;
-	unsigned int cpu = smp_processor_id();
-
-	if (cpu_context(cpu, mm) != NO_CONTEXT) {
-		unsigned long flags;
-		int size;
-
-		local_irq_save(flags);
-		size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
-		if (size > (MMU_NTLB_ENTRIES/4)) { /* Too many TLB to flush */
-			cpu_context(cpu, mm) = NO_CONTEXT;
-			if (mm == current->mm)
-				activate_context(mm, cpu);
-		} else {
-			unsigned long asid;
-			unsigned long saved_asid = MMU_NO_ASID;
-
-			asid = cpu_asid(cpu, mm);
-			start &= PAGE_MASK;
-			end += (PAGE_SIZE - 1);
-			end &= PAGE_MASK;
-			if (mm != current->mm) {
-				saved_asid = get_asid();
-				set_asid(asid);
-			}
-			while (start < end) {
-				local_flush_tlb_one(asid, start);
-				start += PAGE_SIZE;
-			}
-			if (saved_asid != MMU_NO_ASID)
-				set_asid(saved_asid);
-		}
-		local_irq_restore(flags);
-	}
-}
-
-void local_flush_tlb_kernel_range(unsigned long start, unsigned long end)
-{
-	unsigned int cpu = smp_processor_id();
-	unsigned long flags;
-	int size;
-
-	local_irq_save(flags);
-	size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
-	if (size > (MMU_NTLB_ENTRIES/4)) { /* Too many TLB to flush */
-		local_flush_tlb_all();
-	} else {
-		unsigned long asid;
-		unsigned long saved_asid = get_asid();
-
-		asid = cpu_asid(cpu, &init_mm);
-		start &= PAGE_MASK;
-		end += (PAGE_SIZE - 1);
-		end &= PAGE_MASK;
-		set_asid(asid);
-		while (start < end) {
-			local_flush_tlb_one(asid, start);
-			start += PAGE_SIZE;
-		}
-		set_asid(saved_asid);
-	}
-	local_irq_restore(flags);
-}
-
-void local_flush_tlb_mm(struct mm_struct *mm)
-{
-	unsigned int cpu = smp_processor_id();
-
-	/* Invalidate all TLB of this process. */
-	/* Instead of invalidating each TLB, we get new MMU context. */
-	if (cpu_context(cpu, mm) != NO_CONTEXT) {
-		unsigned long flags;
-
-		local_irq_save(flags);
-		cpu_context(cpu, mm) = NO_CONTEXT;
-		if (mm == current->mm)
-			activate_context(mm, cpu);
-		local_irq_restore(flags);
-	}
-}
-
-void __flush_tlb_global(void)
-{
-	unsigned long flags;
-
-	local_irq_save(flags);
-
-	/*
-	 * This is the most destructive of the TLB flushing options,
-	 * and will tear down all of the UTLB/ITLB mappings, including
-	 * wired entries.
-	 */
-	__raw_writel(__raw_readl(MMUCR) | MMUCR_TI, MMUCR);
-
-	local_irq_restore(flags);
-}
diff --git a/arch/sh/mm/uncached.c b/arch/sh/mm/uncached.c
deleted file mode 100644
index bd1585e8efed92..00000000000000
--- a/arch/sh/mm/uncached.c
+++ /dev/null
@@ -1,44 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/sizes.h>
-#include <asm/page.h>
-#include <asm/addrspace.h>
-
-/*
- * This is the offset of the uncached section from its cached alias.
- *
- * Legacy platforms handle trivial transitions between cached and
- * uncached segments by making use of the 1:1 mapping relationship in
- * 512MB lowmem, others via a special uncached mapping.
- *
- * Default value only valid in 29 bit mode, in 32bit mode this will be
- * updated by the early PMB initialization code.
- */
-unsigned long cached_to_uncached = SZ_512M;
-unsigned long uncached_size = SZ_512M;
-unsigned long uncached_start, uncached_end;
-EXPORT_SYMBOL(uncached_start);
-EXPORT_SYMBOL(uncached_end);
-
-int virt_addr_uncached(unsigned long kaddr)
-{
-	return (kaddr >= uncached_start) && (kaddr < uncached_end);
-}
-EXPORT_SYMBOL(virt_addr_uncached);
-
-void __init uncached_init(void)
-{
-#if defined(CONFIG_29BIT) || !defined(CONFIG_MMU)
-	uncached_start = P2SEG;
-#else
-	uncached_start = memory_end;
-#endif
-	uncached_end = uncached_start + uncached_size;
-}
-
-void __init uncached_resize(unsigned long size)
-{
-	uncached_size = size;
-	uncached_end = uncached_start + uncached_size;
-}
diff --git a/arch/sh/tools/Makefile b/arch/sh/tools/Makefile
deleted file mode 100644
index e5ba31c79fe0af..00000000000000
--- a/arch/sh/tools/Makefile
+++ /dev/null
@@ -1,16 +0,0 @@
-#
-# arch/sh/tools/Makefile
-#
-# Copyright (C) 2003  Paul Mundt
-#
-# This file is subject to the terms and conditions of the GNU General Public
-# License.  See the file "COPYING" in the main directory of this archive
-# for more details.
-#
-# Shamelessly cloned from ARM.
-#
-
-include/generated/machtypes.h: $(src)/gen-mach-types $(src)/mach-types
-	@echo '  Generating $@'
-	$(Q)mkdir -p $(dir $@)
-	$(Q)LC_ALL=C $(AWK) -f $^ > $@
diff --git a/arch/sh/tools/gen-mach-types b/arch/sh/tools/gen-mach-types
deleted file mode 100644
index 6d7c2d8eaf5504..00000000000000
--- a/arch/sh/tools/gen-mach-types
+++ /dev/null
@@ -1,48 +0,0 @@
-#!/bin/awk
-# SPDX-License-Identifier: GPL-2.0
-#
-# Awk script to generate include/generated/machtypes.h
-# Heavily based on arch/arm/tools/gen-mach-types
-#
-BEGIN	{ nr = 0 }
-/^#/	{ next }
-/^[ 	]*$/ { next }
-
-NF == 2 {
-	  mach[nr] = $1;
-	  config[nr] = "CONFIG_"$2;
-	  nr++;
-	}
-
-END	{
-	  printf("/*\n");
-	  printf(" * Automagically generated, don't touch.\n");
-	  printf(" */\n");
-	  printf("#ifndef __ASM_SH_MACHTYPES_H\n");
-	  printf("#define __ASM_SH_MACHTYPES_H\n");
-	  printf("\n");
-	  printf("/*\n");
-	  printf(" * We'll use the following MACH_xxx defs for placeholders for the time\n");
-	  printf(" * being .. these will all go away once sh_machtype is assigned per-board.\n");
-	  printf(" *\n");
-	  printf(" * For now we leave things the way they are for backwards compatibility.\n");
-	  printf(" */\n");
-	  printf("\n");
-	  printf("/* Mach types */\n");
-
-	  for (i = 0; i < nr; i++) {
-	      printf("#ifdef %s\n", config[i]);
-	      printf("  #define MACH_%s\t\t1\n", mach[i]);
-	      printf("#else\n");
-	      printf("  #define MACH_%s\t\t0\n", mach[i]);
-	      printf("#endif\n");
-	    }
-
-	  printf("\n");
-	  printf("/* Machtype checks */\n");
-	  for (i = 0; i < nr; i++)
-	      printf("#define mach_is_%s()\t\t\t(MACH_%s)\n",
-	     	 tolower(mach[i]), mach[i]);
-	  printf("\n");
-	  printf("#endif /* __ASM_SH_MACHTYPES_H */\n");
-	}
diff --git a/arch/sh/tools/mach-types b/arch/sh/tools/mach-types
deleted file mode 100644
index 29e648855d509f..00000000000000
--- a/arch/sh/tools/mach-types
+++ /dev/null
@@ -1,67 +0,0 @@
-#
-# MACH_<xxx>		CONFIG_<xxx>
-#
-
-#
-# List of board groups.
-#
-SE			SH_SOLUTION_ENGINE
-HIGHLANDER		SH_HIGHLANDER
-RTS7751R2D		SH_RTS7751R2D
-RSK			SH_RSK
-ALPHA_BOARD		SH_ALPHA_BOARD
-
-#
-# List of companion chips / MFDs.
-#
-HD64461			HD64461
-
-#
-# List of boards.
-#
-7206SE			SH_7206_SOLUTION_ENGINE
-7343SE			SH_7343_SOLUTION_ENGINE
-7619SE			SH_7619_SOLUTION_ENGINE
-7721SE			SH_7721_SOLUTION_ENGINE
-7722SE			SH_7722_SOLUTION_ENGINE
-7724SE			SH_7724_SOLUTION_ENGINE
-7751SE			SH_7751_SOLUTION_ENGINE
-7780SE			SH_7780_SOLUTION_ENGINE
-HP6XX			SH_HP6XX
-DREAMCAST		SH_DREAMCAST
-SNAPGEAR		SH_SECUREEDGE5410
-EDOSK7705		SH_EDOSK7705
-EDOSK7760		SH_EDOSK7760
-SDK7786			SH_SDK7786
-SH4202_MICRODEV		SH_SH4202_MICRODEV
-SH03			SH_SH03
-LANDISK			SH_LANDISK
-R7780RP			SH_R7780RP
-R7780MP			SH_R7780MP
-R7785RP			SH_R7785RP
-TITAN			SH_TITAN
-SHMIN			SH_SHMIN
-LBOXRE2			SH_LBOX_RE2
-X3PROTO			SH_X3PROTO
-MAGICPANELR2		SH_MAGIC_PANEL_R2
-R2D_PLUS		RTS7751R2D_PLUS
-R2D_1			RTS7751R2D_1
-SDK7780			SH_SDK7780
-MIGOR			SH_MIGOR
-RSK7201			SH_RSK7201
-RSK7203			SH_RSK7203
-RSK7264			SH_RSK7264
-RSK7269			SH_RSK7269
-AP325RXA		SH_AP325RXA
-SH2007			SH_SH2007
-SH7757LCR		SH_SH7757LCR
-SH7763RDP		SH_SH7763RDP
-SH7785LCR		SH_SH7785LCR
-SH7785LCR_PT		SH_SH7785LCR_PT
-URQUELL			SH_URQUELL
-ESPT			SH_ESPT
-POLARIS			SH_POLARIS
-KFR2R09			SH_KFR2R09
-ECOVEC			SH_ECOVEC
-APSH4A3A		SH_APSH4A3A
-APSH4AD0A		SH_APSH4AD0A
diff --git a/drivers/clocksource/sh_cmt.c b/drivers/clocksource/sh_cmt.c
index 7b952aa52c0b99..7fed3529bbaf82 100644
--- a/drivers/clocksource/sh_cmt.c
+++ b/drivers/clocksource/sh_cmt.c
@@ -26,10 +26,6 @@
 #include <linux/slab.h>
 #include <linux/spinlock.h>
 
-#ifdef CONFIG_SUPERH
-#include <asm/platform_early.h>
-#endif
-
 struct sh_cmt_device;
 
 /*
@@ -1170,10 +1166,6 @@ static void __exit sh_cmt_exit(void)
 	platform_driver_unregister(&sh_cmt_device_driver);
 }
 
-#ifdef CONFIG_SUPERH
-sh_early_platform_init("earlytimer", &sh_cmt_device_driver);
-#endif
-
 subsys_initcall(sh_cmt_init);
 module_exit(sh_cmt_exit);
 
diff --git a/drivers/clocksource/sh_mtu2.c b/drivers/clocksource/sh_mtu2.c
index 169a1fccc49749..e81e978513f80e 100644
--- a/drivers/clocksource/sh_mtu2.c
+++ b/drivers/clocksource/sh_mtu2.c
@@ -23,10 +23,6 @@
 #include <linux/slab.h>
 #include <linux/spinlock.h>
 
-#ifdef CONFIG_SUPERH
-#include <asm/platform_early.h>
-#endif
-
 struct sh_mtu2_device;
 
 struct sh_mtu2_channel {
@@ -521,10 +517,6 @@ static void __exit sh_mtu2_exit(void)
 	platform_driver_unregister(&sh_mtu2_device_driver);
 }
 
-#ifdef CONFIG_SUPERH
-sh_early_platform_init("earlytimer", &sh_mtu2_device_driver);
-#endif
-
 subsys_initcall(sh_mtu2_init);
 module_exit(sh_mtu2_exit);
 
diff --git a/drivers/clocksource/sh_tmu.c b/drivers/clocksource/sh_tmu.c
index b00dec0655cb28..596e9146ad54e9 100644
--- a/drivers/clocksource/sh_tmu.c
+++ b/drivers/clocksource/sh_tmu.c
@@ -24,10 +24,6 @@
 #include <linux/slab.h>
 #include <linux/spinlock.h>
 
-#ifdef CONFIG_SUPERH
-#include <asm/platform_early.h>
-#endif
-
 enum sh_tmu_model {
 	SH_TMU,
 	SH_TMU_SH3,
@@ -670,10 +666,6 @@ static void __exit sh_tmu_exit(void)
 	platform_driver_unregister(&sh_tmu_device_driver);
 }
 
-#ifdef CONFIG_SUPERH
-sh_early_platform_init("earlytimer", &sh_tmu_device_driver);
-#endif
-
 subsys_initcall(sh_tmu_init);
 module_exit(sh_tmu_exit);
 
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index a7bfddf08fa7ba..22602c512a6e50 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -1027,7 +1027,7 @@ config I2C_SH7760
 
 config I2C_SH_MOBILE
 	tristate "SuperH Mobile I2C Controller"
-	depends on ARCH_SHMOBILE || ARCH_RENESAS || COMPILE_TEST
+	depends on ARCH_RENESAS || COMPILE_TEST
 	help
 	  If you say yes to this option, support will be included for the
 	  built-in I2C interface on the Renesas SH-Mobile processor.
@@ -1112,7 +1112,7 @@ config I2C_SYNQUACER
 
 config I2C_TEGRA
 	tristate "NVIDIA Tegra internal I2C controller"
-	depends on ARCH_TEGRA || (COMPILE_TEST && (ARC || ARM || ARM64 || M68K || RISCV || SUPERH || SPARC))
+	depends on ARCH_TEGRA || (COMPILE_TEST && (ARC || ARM || ARM64 || M68K || RISCV || SPARC))
 	# COMPILE_TEST needs architectures with readsX()/writesX() primitives
 	help
 	  If you say yes to this option, support will be included for the
diff --git a/drivers/media/platform/renesas/Kconfig b/drivers/media/platform/renesas/Kconfig
index ed788e991f74b3..0231672a7e1c32 100644
--- a/drivers/media/platform/renesas/Kconfig
+++ b/drivers/media/platform/renesas/Kconfig
@@ -8,7 +8,7 @@ config VIDEO_RENESAS_CEU
 	tristate "Renesas Capture Engine Unit (CEU) driver"
 	depends on V4L_PLATFORM_DRIVERS
 	depends on VIDEO_DEV
-	depends on ARCH_SHMOBILE || ARCH_R7S72100 || COMPILE_TEST
+	depends on ARCH_R7S72100 || COMPILE_TEST
 	select VIDEOBUF2_DMA_CONTIG
 	select V4L2_FWNODE
 	help
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 5e19a961c34d7b..4d421d4030b7c9 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -720,7 +720,7 @@ config MMC_TMIO
 
 config MMC_SDHI
 	tristate "Renesas SDHI SD/SDIO controller support"
-	depends on SUPERH || ARCH_RENESAS || COMPILE_TEST
+	depends on ARCH_RENESAS || COMPILE_TEST
 	select MMC_TMIO_CORE
 	select RESET_CONTROLLER if ARCH_RENESAS
 	help
@@ -730,7 +730,7 @@ config MMC_SDHI
 config MMC_SDHI_SYS_DMAC
 	tristate "DMA for SDHI SD/SDIO controllers using SYS-DMAC"
 	depends on MMC_SDHI
-	default MMC_SDHI if (SUPERH || ARM)
+	default MMC_SDHI if ARM
 	help
 	  This provides DMA support for SDHI SD/SDIO controllers
 	  using SYS-DMAC via DMA Engine. This supports the controllers
@@ -882,7 +882,7 @@ config MMC_DW_ROCKCHIP
 
 config MMC_SH_MMCIF
 	tristate "SuperH Internal MMCIF support"
-	depends on SUPERH || ARCH_RENESAS || COMPILE_TEST
+	depends on ARCH_RENESAS || COMPILE_TEST
 	help
 	  This selects the MMC Host Interface controller (MMCIF) found in various
 	  Renesas SoCs for SH and ARM architectures.
diff --git a/drivers/mmc/host/sh_mmcif.c b/drivers/mmc/host/sh_mmcif.c
index 0fd4c9d644dd51..96b9a19697b985 100644
--- a/drivers/mmc/host/sh_mmcif.c
+++ b/drivers/mmc/host/sh_mmcif.c
@@ -427,21 +427,12 @@ static void sh_mmcif_request_dma(struct sh_mmcif_host *host)
 	host->dma_active = false;
 
 	/* We can only either use DMA for both Tx and Rx or not use it at all */
-	if (IS_ENABLED(CONFIG_SUPERH) && dev->platform_data) {
-		struct sh_mmcif_plat_data *pdata = dev->platform_data;
-
-		host->chan_tx = sh_mmcif_request_dma_pdata(host,
-							pdata->slave_id_tx);
-		host->chan_rx = sh_mmcif_request_dma_pdata(host,
-							pdata->slave_id_rx);
-	} else {
-		host->chan_tx = dma_request_chan(dev, "tx");
-		if (IS_ERR(host->chan_tx))
-			host->chan_tx = NULL;
-		host->chan_rx = dma_request_chan(dev, "rx");
-		if (IS_ERR(host->chan_rx))
-			host->chan_rx = NULL;
-	}
+	host->chan_tx = dma_request_chan(dev, "tx");
+	if (IS_ERR(host->chan_tx))
+		host->chan_tx = NULL;
+	host->chan_rx = dma_request_chan(dev, "rx");
+	if (IS_ERR(host->chan_rx))
+		host->chan_rx = NULL;
 	dev_dbg(dev, "%s: got channel TX %p RX %p\n", __func__, host->chan_tx,
 		host->chan_rx);
 
diff --git a/drivers/net/ethernet/8390/Kconfig b/drivers/net/ethernet/8390/Kconfig
index a4130e643342f2..eb90de04c88419 100644
--- a/drivers/net/ethernet/8390/Kconfig
+++ b/drivers/net/ethernet/8390/Kconfig
@@ -31,7 +31,7 @@ config PCMCIA_AXNET
 
 config AX88796
 	tristate "ASIX AX88796 NE2000 clone support" if !ZORRO
-	depends on (ARM || MIPS || SUPERH || ZORRO || COMPILE_TEST)
+	depends on (ARM || MIPS || ZORRO || COMPILE_TEST)
 	select CRC32
 	select PHYLIB
 	select MDIO_BITBANG
diff --git a/drivers/net/ethernet/renesas/Kconfig b/drivers/net/ethernet/renesas/Kconfig
index 3ceb57408ed0c0..c48164ec682f50 100644
--- a/drivers/net/ethernet/renesas/Kconfig
+++ b/drivers/net/ethernet/renesas/Kconfig
@@ -18,7 +18,7 @@ if NET_VENDOR_RENESAS
 
 config SH_ETH
 	tristate "Renesas SuperH Ethernet support"
-	depends on ARCH_RENESAS || SUPERH || COMPILE_TEST
+	depends on ARCH_RENESAS || COMPILE_TEST
 	select CRC32
 	select MII
 	select MDIO_BITBANG
diff --git a/drivers/net/ethernet/smsc/Kconfig b/drivers/net/ethernet/smsc/Kconfig
index 5f22a8a4d27b97..a6ddc3d07534ad 100644
--- a/drivers/net/ethernet/smsc/Kconfig
+++ b/drivers/net/ethernet/smsc/Kconfig
@@ -8,7 +8,7 @@ config NET_VENDOR_SMSC
 	default y
 	depends on ARM || ARM64 || ATARI_ETHERNAT || COLDFIRE || \
 		   ISA || MAC || MIPS || NIOS2 || PCI || \
-		   PCMCIA || SUPERH || XTENSA || COMPILE_TEST
+		   PCMCIA || XTENSA || COMPILE_TEST
 	help
 	  If you have a network (Ethernet) card belonging to this class, say Y.
 
@@ -40,7 +40,7 @@ config SMC91X
 	select MII
 	depends on !OF || GPIOLIB
 	depends on ARM || ARM64 || ATARI_ETHERNAT || COLDFIRE || \
-		   MIPS || NIOS2 || SUPERH || XTENSA || COMPILE_TEST
+		   MIPS || NIOS2 || XTENSA || COMPILE_TEST
 	help
 	  This is a driver for SMC's 91x series of Ethernet chipsets,
 	  including the SMC91C94 and the SMC91C111. Say Y if you want it
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index 677d2601d30571..db9e2c516b5ff1 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -1452,7 +1452,7 @@ config RTC_DRV_SA1100
 
 config RTC_DRV_SH
 	tristate "SuperH On-Chip RTC"
-	depends on SUPERH || ARCH_RENESAS
+	depends on ARCH_RENESAS
 	help
 	  Say Y here to enable support for the on-chip RTC found in
 	  most SuperH processors. This RTC is also found in RZ/A SoCs.
@@ -1544,7 +1544,7 @@ config RTC_DRV_GENERIC
 	tristate "Generic RTC support"
 	# Please consider writing a new RTC driver instead of using the generic
 	# RTC abstraction
-	depends on PARISC || M68K || PPC || SUPERH || COMPILE_TEST
+	depends on PARISC || M68K || PPC || COMPILE_TEST
 	help
 	  Say Y or M here to enable RTC support on systems using the generic
 	  RTC abstraction. If you do not know what you are doing, you should
diff --git a/drivers/rtc/rtc-sh.c b/drivers/rtc/rtc-sh.c
index cd146b5741431f..2151a3b7c5b986 100644
--- a/drivers/rtc/rtc-sh.c
+++ b/drivers/rtc/rtc-sh.c
@@ -25,15 +25,12 @@
 #include <linux/log2.h>
 #include <linux/clk.h>
 #include <linux/slab.h>
-#ifdef CONFIG_SUPERH
-#include <asm/rtc.h>
-#else
+
 /* Default values for RZ/A RTC */
 #define rtc_reg_size		sizeof(u16)
 #define RTC_BIT_INVERTED        0	/* no chip bugs */
 #define RTC_CAP_4_DIGIT_YEAR    (1 << 0)
 #define RTC_DEF_CAPABILITIES    RTC_CAP_4_DIGIT_YEAR
-#endif
 
 #define DRV_NAME	"sh-rtc"
 
@@ -537,19 +534,6 @@ static int __init sh_rtc_probe(struct platform_device *pdev)
 
 	rtc->capabilities = RTC_DEF_CAPABILITIES;
 
-#ifdef CONFIG_SUPERH
-	if (dev_get_platdata(&pdev->dev)) {
-		struct sh_rtc_platform_info *pinfo =
-			dev_get_platdata(&pdev->dev);
-
-		/*
-		 * Some CPUs have special capabilities in addition to the
-		 * default set. Add those in here.
-		 */
-		rtc->capabilities |= pinfo->capabilities;
-	}
-#endif
-
 	if (rtc->carry_irq <= 0) {
 		/* register shared periodic/carry/alarm irq */
 		ret = devm_request_irq(&pdev->dev, rtc->periodic_irq,
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 3b1c0878bb8572..2c5226adf5e1d3 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -809,7 +809,7 @@ config SPI_RPCIF
 
 config SPI_RSPI
 	tristate "Renesas RSPI/QSPI controller"
-	depends on SUPERH || ARCH_RENESAS || COMPILE_TEST
+	depends on ARCH_RENESAS || COMPILE_TEST
 	help
 	  SPI driver for Renesas RSPI and QSPI blocks.
 
@@ -878,7 +878,7 @@ config SPI_SC18IS602
 config SPI_SH_MSIOF
 	tristate "SuperH MSIOF SPI controller"
 	depends on HAVE_CLK
-	depends on ARCH_SHMOBILE || ARCH_RENESAS || COMPILE_TEST
+	depends on ARCH_RENESAS || COMPILE_TEST
 	help
 	  SPI driver for SuperH and SH Mobile MSIOF blocks.
 
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
index c55b947f3cdbb7..32f8ffd423cbb2 100644
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -641,7 +641,7 @@ config SERIAL_IP22_ZILOG_CONSOLE
 
 config SERIAL_SH_SCI
 	tristate "SuperH SCI(F) serial port support"
-	depends on SUPERH || ARCH_RENESAS || COMPILE_TEST
+	depends on ARCH_RENESAS || COMPILE_TEST
 	select SERIAL_CORE
 	select SERIAL_MCTRL_GPIO if GPIOLIB
 
@@ -650,7 +650,6 @@ config SERIAL_SH_SCI_NR_UARTS
 	range 1 64 if 64BIT
 	range 1 32 if !64BIT
 	depends on SERIAL_SH_SCI
-	default "10" if SUPERH
 	default "18" if ARCH_RENESAS
 	default "2"
 
diff --git a/drivers/tty/serial/sh-sci.c b/drivers/tty/serial/sh-sci.c
index 7bd0807209299b..cc475670181529 100644
--- a/drivers/tty/serial/sh-sci.c
+++ b/drivers/tty/serial/sh-sci.c
@@ -49,11 +49,6 @@
 #include <linux/tty.h>
 #include <linux/tty_flip.h>
 
-#ifdef CONFIG_SUPERH
-#include <asm/sh_bios.h>
-#include <asm/platform_early.h>
-#endif
-
 #include "serial_mctrl_gpio.h"
 #include "sh-sci.h"
 
@@ -3050,49 +3045,6 @@ static struct console serial_console = {
 	.data		= &sci_uart_driver,
 };
 
-#ifdef CONFIG_SUPERH
-static char early_serial_buf[32];
-
-static int early_serial_console_setup(struct console *co, char *options)
-{
-	/*
-	 * This early console is always registered using the earlyprintk=
-	 * parameter, which does not call add_preferred_console(). Thus
-	 * @options is always NULL and the options for this early console
-	 * are passed using a custom buffer.
-	 */
-	WARN_ON(options);
-
-	return serial_console_setup(co, early_serial_buf);
-}
-
-static struct console early_serial_console = {
-	.name           = "early_ttySC",
-	.write          = serial_console_write,
-	.setup		= early_serial_console_setup,
-	.flags          = CON_PRINTBUFFER,
-	.index		= -1,
-};
-
-static int sci_probe_earlyprintk(struct platform_device *pdev)
-{
-	const struct plat_sci_port *cfg = dev_get_platdata(&pdev->dev);
-
-	if (early_serial_console.data)
-		return -EEXIST;
-
-	early_serial_console.index = pdev->id;
-
-	sci_init_single(pdev, &sci_ports[pdev->id], pdev->id, cfg, true);
-
-	if (!strstr(early_serial_buf, "keep"))
-		early_serial_console.flags |= CON_BOOT;
-
-	register_console(&early_serial_console);
-	return 0;
-}
-#endif
-
 #define SCI_CONSOLE	(&serial_console)
 
 #else
@@ -3323,11 +3275,6 @@ static int sci_probe(struct platform_device *dev)
 	 * the special early probe. We don't have sufficient device state
 	 * to make it beyond this yet.
 	 */
-#ifdef CONFIG_SUPERH
-	if (is_sh_early_platform_device(dev))
-		return sci_probe_earlyprintk(dev);
-#endif
-
 	if (dev->dev.of_node) {
 		p = sci_parse_dt(dev, &dev_id);
 		if (IS_ERR(p))
@@ -3421,10 +3368,6 @@ static void __exit sci_exit(void)
 		uart_unregister_driver(&sci_uart_driver);
 }
 
-#if defined(CONFIG_SUPERH) && defined(CONFIG_SERIAL_SH_SCI_CONSOLE)
-sh_early_platform_init_buffer("earlyprintk", &sci_driver,
-			   early_serial_buf, ARRAY_SIZE(early_serial_buf));
-#endif
 #ifdef CONFIG_SERIAL_SH_SCI_EARLYCON
 static struct plat_sci_port port_cfg __initdata;
 
diff --git a/drivers/tty/vt/keyboard.c b/drivers/tty/vt/keyboard.c
index be8313cdbac360..fa9082f941feeb 100644
--- a/drivers/tty/vt/keyboard.c
+++ b/drivers/tty/vt/keyboard.c
@@ -1275,7 +1275,7 @@ static void kbd_bh(struct tasklet_struct *unused)
 
 #if defined(CONFIG_X86) || defined(CONFIG_IA64) || defined(CONFIG_ALPHA) ||\
     defined(CONFIG_MIPS) || defined(CONFIG_PPC) || defined(CONFIG_SPARC) ||\
-    defined(CONFIG_PARISC) || defined(CONFIG_SUPERH) ||\
+    defined(CONFIG_PARISC) ||\
     (defined(CONFIG_ARM) && defined(CONFIG_KEYBOARD_ATKBD) && !defined(CONFIG_ARCH_RPC))
 
 static inline bool kbd_is_hw_raw(const struct input_dev *dev)
diff --git a/drivers/usb/renesas_usbhs/Kconfig b/drivers/usb/renesas_usbhs/Kconfig
index d6b3fef3e55b03..be240d11cfb49a 100644
--- a/drivers/usb/renesas_usbhs/Kconfig
+++ b/drivers/usb/renesas_usbhs/Kconfig
@@ -6,7 +6,7 @@
 config USB_RENESAS_USBHS
 	tristate 'Renesas USBHS controller'
 	depends on USB_GADGET
-	depends on ARCH_RENESAS || SUPERH || COMPILE_TEST
+	depends on ARCH_RENESAS || COMPILE_TEST
 	depends on EXTCON || !EXTCON # if EXTCON=m, USBHS cannot be built-in
 	help
 	  Renesas USBHS is a discrete USB host and peripheral controller chip
diff --git a/drivers/video/console/Kconfig b/drivers/video/console/Kconfig
index 22cea5082ac461..9860caa3512816 100644
--- a/drivers/video/console/Kconfig
+++ b/drivers/video/console/Kconfig
@@ -7,7 +7,7 @@ menu "Console display driver support"
 
 config VGA_CONSOLE
 	bool "VGA text console" if EXPERT || !X86
-	depends on !4xx && !PPC_8xx && !SPARC && !M68K && !PARISC &&  !SUPERH && \
+	depends on !4xx && !PPC_8xx && !SPARC && !M68K && !PARISC && \
 		(!ARM || ARCH_FOOTBRIDGE || ARCH_INTEGRATOR || ARCH_NETWINDER) && \
 		!ARM64 && !ARC && !MICROBLAZE && !OPENRISC && !S390 && !UML
 	select APERTURE_HELPERS if (DRM || FB || VFIO_PCI_CORE)
diff --git a/drivers/video/logo/Kconfig b/drivers/video/logo/Kconfig
index 6d6f8c08792dc8..e75b514b721b3f 100644
--- a/drivers/video/logo/Kconfig
+++ b/drivers/video/logo/Kconfig
@@ -53,19 +53,4 @@ config LOGO_SUN_CLUT224
 	depends on SPARC
 	default y
 
-config LOGO_SUPERH_MONO
-	bool "Black and white SuperH Linux logo"
-	depends on SUPERH
-	default y
-
-config LOGO_SUPERH_VGA16
-	bool "16-color SuperH Linux logo"
-	depends on SUPERH
-	default y
-
-config LOGO_SUPERH_CLUT224
-	bool "224-color SuperH Linux logo"
-	depends on SUPERH
-	default y
-
 endif # LOGO
diff --git a/drivers/video/logo/Makefile b/drivers/video/logo/Makefile
index 895c60b8402ea1..c4f348fa400741 100644
--- a/drivers/video/logo/Makefile
+++ b/drivers/video/logo/Makefile
@@ -10,9 +10,6 @@ obj-$(CONFIG_LOGO_MAC_CLUT224)		+= logo_mac_clut224.o
 obj-$(CONFIG_LOGO_PARISC_CLUT224)	+= logo_parisc_clut224.o
 obj-$(CONFIG_LOGO_SGI_CLUT224)		+= logo_sgi_clut224.o
 obj-$(CONFIG_LOGO_SUN_CLUT224)		+= logo_sun_clut224.o
-obj-$(CONFIG_LOGO_SUPERH_MONO)		+= logo_superh_mono.o
-obj-$(CONFIG_LOGO_SUPERH_VGA16)		+= logo_superh_vga16.o
-obj-$(CONFIG_LOGO_SUPERH_CLUT224)	+= logo_superh_clut224.o
 
 obj-$(CONFIG_SPU_BASE)			+= logo_spe_clut224.o
 
diff --git a/drivers/video/logo/logo.c b/drivers/video/logo/logo.c
index 141f15a9a45906..0269def4262117 100644
--- a/drivers/video/logo/logo.c
+++ b/drivers/video/logo/logo.c
@@ -52,10 +52,6 @@ const struct linux_logo * __ref fb_find_logo(int depth)
 #ifdef CONFIG_LOGO_LINUX_MONO
 		/* Generic Linux logo */
 		logo = &logo_linux_mono;
-#endif
-#ifdef CONFIG_LOGO_SUPERH_MONO
-		/* SuperH Linux logo */
-		logo = &logo_superh_mono;
 #endif
 	}
 	
@@ -63,10 +59,6 @@ const struct linux_logo * __ref fb_find_logo(int depth)
 #ifdef CONFIG_LOGO_LINUX_VGA16
 		/* Generic Linux logo */
 		logo = &logo_linux_vga16;
-#endif
-#ifdef CONFIG_LOGO_SUPERH_VGA16
-		/* SuperH Linux logo */
-		logo = &logo_superh_vga16;
 #endif
 	}
 	
@@ -95,10 +87,6 @@ const struct linux_logo * __ref fb_find_logo(int depth)
 #ifdef CONFIG_LOGO_SUN_CLUT224
 		/* Sun Linux logo */
 		logo = &logo_sun_clut224;
-#endif
-#ifdef CONFIG_LOGO_SUPERH_CLUT224
-		/* SuperH Linux logo */
-		logo = &logo_superh_clut224;
 #endif
 	}
 	return logo;
diff --git a/drivers/video/logo/logo_superh_clut224.ppm b/drivers/video/logo/logo_superh_clut224.ppm
deleted file mode 100644
index 0241aacee18009..00000000000000
--- a/drivers/video/logo/logo_superh_clut224.ppm
+++ /dev/null
@@ -1,1604 +0,0 @@
-P3
-# 224-color SuperH Linux logo
-80 80
-255
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  6   6   6   6   6   6  10  10  10  10  10  10
- 10  10  10   6   6   6   6   6   6   6   6   6
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   6   6   6  10  10  10  14  14  13
- 22  22  22  26  26  26  30  30  30  34  34  34
- 30  30  30  30  30  30  26  26  26  18  18  18
- 14  14  13  10  10  10   6   6   6   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  6   6   6  14  14  13  26  26  26  42  42  43
- 54  54  54  66  66  66  78  78  78  78  78  78
- 78  78  78  74  74  74  66  66  66  54  54  54
- 42  42  43  26  26  26  18  18  18  10  10  10
-  6   6   6   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  10  10  10
- 22  22  22  42  42  43  66  66  66  86  86  86
- 66  66  66  38  38  38  38  38  38  22  22  22
- 26  26  26  34  34  34  54  54  54  66  66  66
- 86  86  86  70  70  70  46  46  46  26  26  26
- 14  14  13   6   6   6   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2  10  10  10  26  26  26
- 50  50  50  82  82  82  58  58  58   6   6   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  6   6   6  54  54  54  86  86  86  66  66  66
- 38  38  38  18  18  18   6   6   6   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   6   6   6  22  22  22  50  50  50
- 78  78  78  34  34  34   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   6   6   6  70  70  70
- 78  78  78  46  46  46  22  22  22   6   6   6
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  6   6   6  18  18  18  42  42  43  82  82  82
- 26  26  26   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6  14  14  13
- 46  46  46  34  34  34   6   6   6   2   2   6
- 42  42  43  78  78  78  42  42  43  18  18  18
-  6   6   6   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
- 10  10  10  30  30  30  66  66  66  58  58  58
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6  26  26  26
- 86  86  86 102 102 102  46  46  46  10  10  10
-  2   2   6  58  58  58  70  70  70  34  34  34
- 10  10  10   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
- 14  14  13  42  42  43  86  86  86  10  10  10
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6  30  30  30
- 94  94  93  94  94  93  58  58  58  26  26  26
-  2   2   6   6   6   6  78  78  78  54  54  54
- 22  22  22   6   6   6   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   6   6   6
- 22  22  22  62  62  62  62  62  62   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6  26  26  26
- 54  54  54  38  38  38  18  18  18  10  10  10
-  2   2   6   2   2   6  34  34  34  82  82  82
- 38  38  38  14  14  13   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   6   6   6
- 30  30  30  78  78  78  30  30  30   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6  10  10  10
- 10  10  10   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6  78  78  78
- 50  50  50  18  18  18   6   6   6   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  10  10  10
- 38  38  38  86  86  86  14  14  13   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6  54  54  54
- 66  66  66  26  26  26   6   6   6   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  14  14  13
- 42  42  43  82  82  82   2   2   6   2   2   6
-  2   2   6   6   6   6  10  10  10   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6   6   6   6
- 14  14  13  10  10  10   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6  18  18  18
- 82  82  82  34  34  34  10  10  10   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  14  14  13
- 46  46  46  86  86  86   2   2   6   2   2   6
-  6   6   6   6   6   6  22  22  22  34  34  34
-  6   6   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6  18  18  18  34  34  34
- 10  10  10  50  50  50  22  22  22   2   2   6
-  2   2   6   2   2   6   2   2   6  10  10  10
- 86  86  86  42  42  43  14  14  13   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  14  14  13
- 46  46  46  86  86  86   2   2   6   2   2   6
- 38  38  38 118 118 118  94  94  93  22  22  22
- 22  22  22   2   2   6   2   2   6   2   2   6
- 14  14  13  86  86  86 138 138 142 163 163 163
-154 154 154  38  38  38  26  26  26   6   6   6
-  2   2   6   2   2   6   2   2   6   2   2   6
- 86  86  86  46  46  46  14  14  13   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  14  14  13
- 46  46  46  86  86  86   2   2   6  14  14  13
-134 134 134 198 198 196 194 194 194 118 118 118
- 10  10  10   2   2   6   2   2   6   6   6   6
-102  98  90 186 186 186 210 210 210 218 218 218
-214 214 214 134 134 134  14  14  13   6   6   6
-  2   2   6   2   2   6   2   2   6   2   2   6
- 86  86  86  50  50  50  18  18  18   6   6   6
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  14  14  13
- 46  46  46  86  86  86   2   2   6  54  54  54
-218 218 218 194 194 194 226 226 226 246 246 246
- 58  58  58   2   2   6   2   2   6  30  30  30
-210 210 210 254 254 254 174 174 174 122 122 122
-223 222 222 234 234 234  74  74  74   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
- 70  70  70  58  58  58  22  22  22   6   6   6
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  14  14  13
- 46  46  46  82  82  82   2   2   6 106 106 105
-170 170 170  26  26  26  86  86  86 226 226 226
-122 122 122  10  10  10  14  14  13  46  46  46
-230 230 228 190 190 187   6   6   6  70  70  70
- 89  90  90 238 238 238 158 158 158   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
- 70  70  70  58  58  58  22  22  22   6   6   6
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  14  14  13
- 42  42  43  86  86  86   6   6   6 118 118 118
-106 106 105   6   6   6  70  70  70 150 150 150
-130 130 130  18  18  18  38  38  38  54  54  54
-223 222 222 106 106 105   2   2   6  14  14  13
- 46  46  46 190 190 187 198 198 196   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
- 74  74  74  62  62  62  22  22  22   6   6   6
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  14  14  13
- 42  42  43  94  94  93  14  14  13 102 102 102
-130 130 130   2   2   6  18  18  18 118 118 118
-122 100  66 122  94  10 122  94  10 104  78  10
-163 163 163 106 106 105   2   2   6   2   2   6
-  2   2   6 194 194 194 194 194 194   6   6   6
-  2   2   6   2   2   6   2   2   6   2   2   6
- 74  74  74  62  62  62  22  22  22   6   6   6
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  10  10  10
- 38  38  38  89  90  90  14  14  13  58  58  58
-210 210 210  26  26  26  60  40   9 154 114  10
-226 170  10 241 186  13 229 174  11 186 146  17
-214 174  14 178 147  70  38  26  10   2   2   6
- 70  70  70 246 246 246 138 138 142   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
- 70  70  70  66  66  66  26  26  26   6   6   6
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  10  10  10
- 38  38  38  86  86  86  14  14  13  10  10  10
-194 194 194 190 166 114 195 134  10 229 174  11
-238 182  14 234 190  10 234 196  18 238 202  21
-246 206  46 244 212  20 234 196  18 186 146  17
-218 194 134 206 206 194  42  42  43   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
- 50  50  50  74  74  74  30  30  30   6   6   6
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  10  10  10
- 34  34  34  86  86  86  14  14  13   2   2   6
-122  86  26 195 134  10 220 162  10 238 182  14
-241 186  13 234 196  18 244 212  20 246 217  53
-246 217  53 246 217  39 244 212  20 244 212  20
-244 212  20 224 188  14 122  86  26   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
- 50  50  50  82  82  82  34  34  34  10  10  10
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  10  10  10
- 34  34  34  82  82  82  30  30  30  60  40   9
-181 122   9 204 146  11 229 174  11 238 182  14
-234 190  10 238 202  21 244 212  20 246 218  74
-246 217  39 244 212  20 244 212  20 244 212  20
-224 188  14 214 174  14 186 146  17   6   6   6
-  2   2   6   2   2   6   2   2   6   2   2   6
- 26  26  26  94  94  93  42  42  43  14  14  13
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  10  10  10
- 30  30  30  78  78  78  50  50  50 105  70   7
-195 134  10 219 158  11 238 178  14 241 186  13
-234 196  18 244 212  20 246 217  53 241 214  34
-244 212  20 244 212  20 244 212  20 197 151  13
-204 146  11 219 158  11 158 118  10   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  6   6   6  89  90  90  54  54  54  18  18  18
-  6   6   6   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  10  10  10
- 30  30  30  78  78  78  46  46  46  22  22  22
-138  94   6 210 162  12 238 182  14 238 190  10
-238 202  21 244 212  20 244 212  20 244 212  20
-244 212  20 202 164  20 186 134  10 211 150  11
-219 158  11 211 150  11 104  78  10   2   2   6
-  6   6   6  54  54  54  14  14  13   2   2   6
-  2   2   6  62  62  62  74  74  74  30  30  30
- 10  10  10   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  10  10  10
- 34  34  34  78  78  78  50  50  50   6   6   6
- 92  69  26 138 102  14 190 146  14 224 188  14
-238 202  21 234 196  18 214 174  14 190 146  14
-170 122  12 195 134  10 211 150  11 214 154  10
-202 147  31 182 158 106 102  98  90   2   2   6
-  2   2   6  78  78  78 118 118 118  58  58  58
-  2   2   6  22  22  22  89  90  90  46  46  46
- 18  18  18   6   6   6   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  10  10  10
- 38  38  38  86  86  86  50  50  50   6   6   6
-130 130 130 173 154 115 158 106   9 170 122  12
-197 151  13 186 146  17 197 139  12 204 146  11
-204 146  11 204 146  11 197 139  12 190 166 114
-194 194 194 198 198 196 174 174 174  14  14  13
-  2   2   6  22  22  22 118 118 118 118 118 118
- 22  22  22   2   2   6  74  74  74  70  70  70
- 30  30  30  10  10  10   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   6   6   6  18  18  18
- 50  50  50 102 102 102  26  26  26  10  10  10
-138 138 142 190 190 187 173 154 115 158 106   9
-197 139  12 204 146  11 197 139  12 195 134  10
-181 122   9 188 140  34 191 178 145 186 186 186
-201 202 203 223 222 222 214 214 214  66  66  66
-  2   2   6   2   2   6  50  50  50  62  62  62
-  6   6   6   2   2   6  10  10  10  89  90  90
- 50  50  50  18  18  18   6   6   6   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2  10  10  10  34  34  34
- 74  74  74  74  74  74   2   2   6   6   6   6
-146 146 146 198 198 196 190 190 187 178 166 146
-154 122  54 158 106   9 158 106   9 170 126  38
-173 154 115 186 186 186 190 190 187 210 210 210
-246 246 246 254 254 254 254 254 254 182 182 182
-  6   6   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6  62  62  62
- 74  74  74  34  34  34  14  14  13   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2  10  10  10  22  22  22  54  54  54
- 94  94  93  18  18  18   2   2   6  46  46  46
-234 234 234 223 222 222 190 190 187 190 190 187
-190 190 187 186 186 186 186 186 186 190 190 187
-190 190 187 194 194 194 214 214 214 242 242 242
-254 254 254 254 254 254 254 254 254 254 254 254
- 82  82  82   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6  14  14  13
- 86  86  86  54  54  54  22  22  22   6   6   6
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  6   6   6  18  18  18  46  46  46  89  90  90
- 46  46  46  18  18  18   6   6   6 182 182 182
-254 254 254 246 246 246 206 206 206 190 190 187
-190 190 187 190 190 187 190 190 187 190 190 187
-206 206 206 230 230 228 250 250 250 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-201 202 203  14  14  13   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
- 42  42  43  86  86  86  42  42  43  18  18  18
-  6   6   6   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   6   6   6
- 14  14  13  38  38  38  74  74  74  66  66  66
-  2   2   6   6   6   6  89  90  90 250 250 250
-254 254 254 254 254 254 238 238 238 198 198 196
-190 190 187 190 190 187 194 194 194 223 222 222
-246 246 246 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254  82  82  82   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6  78  78  78  70  70  70  34  34  34
- 14  14  13   6   6   6   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  14  14  13
- 34  34  34  66  66  66  78  78  78   6   6   6
-  2   2   6  18  18  18 218 218 218 254 254 254
-254 254 254 254 254 254 254 254 254 246 246 246
-226 226 226 230 230 228 246 246 246 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 174 174 174   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6  18  18  18  89  90  90  62  62  62
- 30  30  30  10  10  10   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2  10  10  10  26  26  26
- 58  58  58  89  90  90  18  18  18   2   2   6
-  2   2   6 110 110 110 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-250 250 250 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 230 230 228  18  18  18   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6  18  18  18  94  94  93
- 54  54  54  26  26  26  10  10  10   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   6   6   6  22  22  22  50  50  50
- 89  90  90  26  26  26   2   2   6   2   2   6
- 14  14  13 194 194 194 250 250 250 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-250 250 250 242 242 242  54  54  54   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6  38  38  38
- 86  86  86  50  50  50  22  22  22   6   6   6
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  6   6   6  14  14  13  38  38  38  82  82  82
- 34  34  34   2   2   6   2   2   6   2   2   6
- 42  42  43 194 194 194 246 246 246 254 254 254
-254 254 254 254 254 254 254 254 254 250 250 250
-242 242 242 242 242 242 250 250 250 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 250 250 250 246 246 246 238 238 238
-226 226 226 230 230 228 102 102 102   6   6   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
- 38  38  38  82  82  82  42  42  43  14  14  13
-  6   6   6   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
- 10  10  10  26  26  26  62  62  62  66  66  66
-  2   2   6   2   2   6   2   2   6   6   6   6
- 70  70  70 170 170 170 206 206 206 234 234 234
-246 246 246 250 250 250 250 250 250 238 238 238
-226 226 226 230 230 228 238 238 238 250 250 250
-250 250 250 250 250 250 246 246 246 230 230 228
-214 214 214 206 206 206 201 202 203 201 202 203
-198 198 196 201 202 203 182 182 182  18  18  18
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6  62  62  62  66  66  66  30  30  30
- 10  10  10   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
- 14  14  13  42  42  43  82  82  82  18  18  18
-  2   2   6   2   2   6   2   2   6  10  10  10
- 94  94  93 182 182 182 218 218 218 242 242 242
-250 250 250 254 254 254 254 254 254 250 250 250
-234 234 234 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 246 246 246
-238 238 238 226 226 226 210 210 210 201 202 203
-194 194 194 194 194 194 210 210 210 158 158 158
-  6   6   6  14  14  13  50  50  50  14  14  13
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   6   6   6  86  86  86  46  46  46
- 18  18  18   6   6   6   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   6   6   6
- 22  22  22  54  54  54  70  70  70   2   2   6
-  2   2   6  10  10  10   2   2   6  22  22  22
-166 166 166 230 230 228 250 250 250 254 254 254
-254 254 254 254 254 254 254 254 254 250 250 250
-242 242 242 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 246 246 246
-230 230 228 206 206 206 198 198 196 226 226 226
- 94  94  93   2   2   6   6   6   6  38  38  38
- 30  30  30   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6  62  62  62  66  66  66
- 26  26  26  10  10  10   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  10  10  10
- 30  30  30  74  74  74  50  50  50   2   2   6
- 26  26  26  26  26  26   2   2   6 106 106 105
-238 238 238 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 246 246 246 218 218 218 201 202 203
-210 210 210  14  14  13   2   2   6   2   2   6
- 30  30  30  22  22  22   2   2   6   2   2   6
-  2   2   6   2   2   6  18  18  18  86  86  86
- 42  42  43  14  14  13   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  14  14  13
- 42  42  43  89  90  90  22  22  22   2   2   6
- 42  42  43   2   2   6  18  18  18 218 218 218
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 250 250 250 223 222 222
-218 218 218 102 102 102   2   2   6  14  14  13
- 18  18  18  38  38  38  10  10  10   2   2   6
-  2   2   6   2   2   6   2   2   6  78  78  78
- 58  58  58  22  22  22   6   6   6   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   6   6   6  18  18  18
- 54  54  54  82  82  82   2   2   6  26  26  26
- 22  22  22   2   2   6 122 122 122 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 250 250 250
-238 238 238 198 198 196   6   6   6  38  38  38
- 58  58  58  26  26  26  38  38  38   2   2   6
-  2   2   6   2   2   6   2   2   6  46  46  46
- 78  78  78  30  30  30  10  10  10   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2  10  10  10  30  30  30
- 74  74  74  58  58  58   2   2   6  42  42  43
-  2   2   6  22  22  22 230 230 228 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 250 250 250
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 246 246 246  46  46  46  38  38  38
- 42  42  43  14  14  13  38  38  38  14  14  13
-  2   2   6   2   2   6   2   2   6   6   6   6
- 86  86  86  46  46  46  14  14  13   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   6   6   6  14  14  13  42  42  43
- 89  90  90  18  18  18  18  18  18  26  26  26
-  2   2   6 118 118 118 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 250 250 250 238 238 238
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254  94  94  93   6   6   6
-  2   2   6   2   2   6  10  10  10  34  34  34
-  2   2   6   2   2   6   2   2   6   2   2   6
- 74  74  74  58  58  58  22  22  22   6   6   6
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2  10  10  10  26  26  26  66  66  66
- 82  82  82   2   2   6  38  38  38   6   6   6
- 14  14  13 210 210 210 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 246 246 246 242 242 242
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 146 146 146   2   2   6
-  2   2   6   2   2   6   2   2   6  46  46  46
-  2   2   6   2   2   6   2   2   6   2   2   6
- 42  42  43  74  74  74  30  30  30  10  10  10
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  6   6   6  14  14  13  42  42  43  89  90  90
- 26  26  26   6   6   6  42  42  43   2   2   6
- 74  74  74 250 250 250 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 242 242 242 242 242 242
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 182 182 182   2   2   6
-  2   2   6   2   2   6   2   2   6  46  46  46
-  2   2   6   2   2   6   2   2   6   2   2   6
- 10  10  10  86  86  86  38  38  38  10  10  10
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
- 10  10  10  26  26  26  66  66  66  82  82  82
-  2   2   6  22  22  22  18  18  18   2   2   6
-150 150 150 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 234 234 234 242 242 242
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 206 206 206   2   2   6
-  2   2   6   2   2   6   2   2   6  38  38  38
-  2   2   6   2   2   6   2   2   6   2   2   6
-  6   6   6  86  86  86  46  46  46  14  14  13
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   6   6   6
- 18  18  18  46  46  46  86  86  86  18  18  18
-  2   2   6  34  34  34  10  10  10   6   6   6
-210 210 210 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 234 234 234 242 242 242
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 223 222 222   6   6   6
-  2   2   6   2   2   6   6   6   6  30  30  30
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6  82  82  82  54  54  54  18  18  18
-  6   6   6   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  10  10  10
- 26  26  26  66  66  66  62  62  62   2   2   6
-  2   2   6  38  38  38  10  10  10  26  26  26
-238 238 238 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 230 230 228 238 238 238
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 230 230 228   6   6   6
-  2   2   6   2   2   6  10  10  10  30  30  30
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6  66  66  66  58  58  58  22  22  22
-  6   6   6   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  10  10  10
- 38  38  38  78  78  78   6   6   6   2   2   6
-  2   2   6  46  46  46  14  14  13  42  42  43
-246 246 246 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 230 230 228 242 242 242
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 234 234 234  10  10  10
-  2   2   6   2   2   6  22  22  22  14  14  13
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6  66  66  66  62  62  62  22  22  22
-  6   6   6   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   6   6   6  18  18  18
- 50  50  50  74  74  74   2   2   6   2   2   6
- 14  14  13  70  70  70  34  34  34  62  62  62
-250 250 250 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 230 230 228 246 246 246
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 234 234 234  14  14  13
-  2   2   6   2   2   6  30  30  30   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6  66  66  66  62  62  62  22  22  22
-  6   6   6   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   6   6   6  18  18  18
- 54  54  54  62  62  62   2   2   6   2   2   6
-  2   2   6  30  30  30  46  46  46  70  70  70
-250 250 250 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 230 230 228 246 246 246
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 226 226 226  10  10  10
-  2   2   6   6   6   6  30  30  30   2   2   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6  66  66  66  58  58  58  22  22  22
-  6   6   6   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   6   6   6  22  22  22
- 58  58  58  62  62  62   2   2   6   2   2   6
-  2   2   6   2   2   6  30  30  30  78  78  78
-250 250 250 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 230 230 228 246 246 246
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 206 206 206   2   2   6
- 22  22  22  34  34  34  18  14   6  22  22  22
- 26  26  26  18  18  18   6   6   6   2   2   6
-  2   2   6  82  82  82  54  54  54  18  18  18
-  6   6   6   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   6   6   6  26  26  26
- 62  62  62 106 106 105  74  51  11 186 134  10
-210 162  12 122  94  10   6   6   6  62  62  62
-238 238 238 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 230 230 228 246 246 246
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 158 158 158  18  18  18
- 14  14  13   2   2   6   2   2   6   2   2   6
-  6   6   6  18  18  18  66  66  66  38  38  38
-  6   6   6  94  94  93  50  50  50  18  18  18
-  6   6   6   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   6   6   6
- 10  10  10  10  10  10  18  18  18  38  38  38
- 78  78  78 142 134 106 219 158  11 241 186  13
-246 190  14 246 190  14 158 118  10  10  10  10
- 89  90  90 238 238 238 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 230 230 228 250 250 250
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 246 230 190
-238 206  90 238 206  90 188 140  34  38  26  10
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6  38  38  38  46  46  46
- 26  26  26 106 106 105  54  54  54  18  18  18
-  6   6   6   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   6   6   6  14  14  13  22  22  22
- 30  30  30  38  38  38  50  50  50  70  70  70
-106 106 105 188 140  34 226 170  10 241 186  13
-246 190  14 246 190  14 246 190  14 154 114  10
-  6   6   6  74  74  74 226 226 226 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 230 230 228 250 250 250
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 233 188  64
-240 198  14 244 212  20 234 196  18  38  30  10
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   6   6   6  30  30  30  26  26  26
-202 164  20 154 142  90  66  66  66  26  26  26
-  6   6   6   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  6   6   6  18  18  18  38  38  38  58  58  58
- 78  78  78  86  86  86 102 102 102 122 122 122
-178 147  70 211 150  11 234 174  12 246 186  14
-246 190  14 246 190  14 246 190  14 238 190  10
-104  78  10   2   2   6  46  46  46 198 198 196
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 234 234 234 242 242 242
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 222 175  59
-241 186  13 240 198  14 210 162  12  18  18  18
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6   6   6   6 122  94  10
-238 202  21 234 196  18  82  82  82  34  34  34
- 10  10  10   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
- 14  14  13  38  38  38  70  70  70 154 122  54
-188 140  34 204 146  11 197 139  12 197 139  12
-214 154  10 226 170  10 241 186  13 246 190  14
-246 190  14 246 190  14 246 190  14 246 190  14
-229 174  11  49  35   6   2   2   6  22  22  22
-158 158 158 250 250 250 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 250 250 250 242 242 242 222 175  59
-238 182  14 241 186  13 214 154  10  49  35   6
-  2   2   6   2   2   6   2   2   6   2   2   6
-  2   2   6   2   2   6  60  40   9 229 174  11
-238 190  10 241 186  13 114 102  78  42  42  43
- 14  14  13   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   6   6   6
- 22  22  22  54  54  54 154 122  54 214 154  10
-226 170  10 229 174  11 226 170  10 226 170  10
-238 178  14 241 186  13 246 190  14 246 190  14
-246 190  14 246 190  14 246 190  14 246 190  14
-240 198  14 186 146  17  10  10  10   2   2   6
-  6   6   6 118 118 118 242 242 242 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 230 230 228 198 198 196 206 170  74
-238 178  14 238 178  14 211 150  11 138  94   6
- 18  14   6   2   2   6   2   2   6   2   2   6
-  6   6   6  70  46   6 204 146  11 238 178  14
-238 182  14 238 182  14 126 114  90  58  58  58
- 22  22  22   6   6   6   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  10  10  10
- 30  30  30  70  70  70 182 134  38 226 170  10
-238 182  14 241 186  13 241 186  13 246 186  14
-246 190  14 246 190  14 246 190  14 246 190  14
-246 190  14 246 190  14 246 190  14 246 190  14
-246 190  14 234 196  18  98  70   6   2   2   6
-  2   2   6   2   2   6  66  66  66 223 222 222
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 206 206 206 198 198 196 207 165  68
-229 174  11 229 174  11 219 158  11 195 134  10
-163 110  10 118  82  10 104  78  10 118  82  10
-164 114   8 197 139  12 226 170  10 238 182  14
-241 186  13 241 186  13 162 146  94  78  78  78
- 34  34  34  14  14  13   6   6   6   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   6   6   6
- 30  30  30  78  78  78 188 140  34 226 170  10
-238 182  14 246 190  14 246 190  14 246 190  14
-246 190  14 246 190  14 246 190  14 246 190  14
-246 190  14 246 190  14 246 190  14 246 190  14
-246 190  14 240 198  14 202 164  20  18  18  18
-  2   2   6   2   2   6   2   2   6  38  38  38
-218 218 218 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-250 250 250 206 206 206 198 198 196 207 165  68
-226 170  10 238 178  14 226 166  13 211 150  11
-204 146  11 197 139  12 195 134  10 197 139  12
-211 150  11 226 170  10 241 186  13 246 190  14
-246 190  14 246 186  14 229 174  11 126 114  90
- 62  62  62  30  30  30  14  14  13   6   6   6
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2  10  10  10
- 30  30  30  78  78  78 174 134  50 226 166  13
-238 182  14 246 190  14 246 190  14 246 190  14
-246 190  14 246 190  14 246 190  14 246 190  14
-246 190  14 246 190  14 246 190  14 246 190  14
-246 190  14 246 190  14 240 198  14 138 102  14
-  2   2   6   2   2   6   2   2   6   2   2   6
- 78  78  78 250 250 250 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-250 250 250 214 214 214 198 198 196 192 148  44
-220 162  10 238 178  14 234 174  12 226 166  13
-219 158  11 214 154  10 214 154  10 219 158  11
-226 170  10 238 182  14 246 190  14 246 190  14
-246 190  14 246 190  14 241 186  13 206 160  36
-102 102 102  58  58  58  30  30  30  14  14  13
-  6   6   6   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2  10  10  10  86  86  86 150 150 150
-170 170 170 186 186 186 226 210 207 231 220 218
-246 230 190 246 230 190 246 230 190 246 230 190
-238 206  90 246 190  14 246 190  14 246 190  14
-246 190  14 246 190  14 246 190  14 246 190  14
-246 190  14 246 190  14 240 198  14 224 188  14
- 60  40   9   2   2   6   6   6   6   2   2   6
- 22  22  22 238 238 238 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 226 226 226 186 186 186 182 134  38
-219 158  11 238 178  14 238 182  14 238 178  14
-229 174  11 226 170  10 226 170  10 229 174  11
-238 178  14 241 186  13 246 190  14 246 190  14
-246 190  14 240 198  14 246 230 190 246 230 190
-226 210 207 186 186 186 110 110 110  38  38  38
- 26  26  26 122 122 122 138 138 142 138 138 142
-138 138 142 102  98  90   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
- 14  14  13 154 154 154 246 246 246 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-246 230 190 238 206  90 240 198  14 240 198  14
-240 198  14 240 198  14 246 190  14 246 190  14
-246 190  14 240 198  14 240 198  14 238 202  21
-206 160  36  18  18  18  22  22  22  30  30  30
- 70  70  70 246 246 246 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 254 254 254 254 254 254 254 254 254
-254 254 254 230 230 228 118 118 118 170 126  38
-220 162  10 238 178  14 241 186  13 246 190  14
-234 196  18 246 190  14 246 190  14 234 196  18
-246 190  14 246 206  46 238 206  90 246 206  46
-240 198  14 246 230 190 254 254 254 254 254 254
-254 254 254 252 251 251 205 195 190 110 110 110
-134 134 134 242 242 242 250 250 250 254 254 254
-250 250 250 138 138 142 102  98  90   2   2   2
-  2   2   2   2   2   2   3   3   3  18  14   6
-150 150 150 242 242 242 239 159 153 249 100  93
-249 100  93 249 100  93 249 100  93 249 100  93
-249 100  93 249 100  93 249 100  93 249 100  93
-239 159 153 246 218  74 246 246 246 246 246 246
-246 246 246 246 246 246 238 206  90 246 190  14
-246 230 190 246 246 246 246 246 246 246 246 246
-246 230 190 138 102  14 182 182 182 242 242 242
-252 251 251 252 251 251 252 251 251 252 251 251
-252 251 251 252 251 251 254 254 254 252 251 251
-252 251 251 252 251 251 246 246 246 252 251 251
-254 254 254 252 251 251 252 251 251 254 254 254
-254 254 254 252 251 251 242 242 242 238 238 238
-238 206  90 238 178  14 241 186  13 246 230 190
-246 246 246 246 246 246 246 246 246 246 230 190
-246 230 190 246 246 246 252 251 251 246 230 190
-246 230 190 246 230 190 249 100  93 249 100  93
-249 100  93 249 100  93 218 194 134 218 194 134
-234 234 234 212 132  53 249 100  93 249 100  93
-249 100  93 239 159 153 138 138 142 102  98  90
-  2   2   2   2   2   2  10  10  10 150 150 150
-242 242 242 249 100  93 254   3   3 254   3   3
-254   3   3 254   3   3 254   3   3 254   3   3
-254   3   3 254   3   3 254   3   3 254   3   3
-239 159 153 246 246 246 246 230 190 246 230 190
-246 230 190 246 230 190 246 230 190 246 230 190
-246 230 190 246 230 190 246 230 190 246 230 190
-246 230 190 246 230 190 238 238 238 246 230 190
-246 230 190 246 230 190 246 230 190 246 246 246
-231 220 218 218 194 134 218 194 134 226 210 207
-246 246 246 246 246 246 246 246 246 252 251 251
-246 246 246 226 210 207 218 194 134 218 194 134
-239 159 153 218 194 134 226 210 207 246 230 190
-246 246 246 238 206  90 246 230 190 246 230 190
-246 230 190 246 230 190 246 230 190 246 230 190
-246 246 246 226 210 207 239 159 153 226 210 207
-246 246 246 239 159 153 254   3   3 254   3   3
-254   3   3 254   3   3 218 194 134 246 246 246
-231 220 218 254  21  21 254   3   3 254   3   3
-254   3   3 212 132  53 250 250 250 122 122 122
-  2   2   2   2   2   2  89  90  90 246 246 246
-239 159 153 254   3   3 254   3   3 254   3   3
-254   3   3 254   3   3 254   3   3 254   3   3
-254   3   3 254   3   3 254   3   3 254  21  21
-226 210 207 226 210 207 254  21  21 254  21  21
-254  21  21 254  21  21 239 159 153 252 251 251
-249 100  93 254  21  21 254  21  21 254  21  21
-249 100  93 246 246 246 249 100  93 254  21  21
-254  21  21 254  21  21 249 100  93 249 100  93
-254  21  21 254   3   3 254   3   3 254  21  21
-212 132  53 246 246 246 252 251 251 226 210 207
-254  56  56 254  21  21 254   3   3 254   3   3
-254   3   3 254   3   3 254   3   3 254  21  21
-249 100  93 242 242 242 246 246 246 249 100  93
-254  21  21 254  21  21 254  21  21 249 100  93
-249 100  93 254   3   3 254   3   3 254  56  56
-246 246 246 249 100  93 254   3   3 254   3   3
-254   3   3 254  21  21 246 230 190 252 251 251
-239 159 153 254   3   3 254   3   3 254   3   3
-254   3   3 218 194 134 246 246 246  58  58  58
-  2   2   2   6   6   6 182 182 182 252 251 251
-254  56  56 254   3   3 254   3   3 254   3   3
-254   3   3 249 100  93 239 159 153 239 159 153
-239 159 153 212 132  53 249 100  93 249 100  93
-246 246 246 212 132  53 254   3   3 254   3   3
-254   3   3 254  21  21 238 238 238 246 230 190
-254  21  21 254   3   3 254   3   3 254   3   3
-239 159 153 246 230 190 254  21  21 254   3   3
-254   3   3 254   3   3 254  21  21 254   3   3
-254   3   3 254   3   3 254   3   3 254   3   3
-254  21  21 246 246 246 231 220 218 254  21  21
-254   3   3 254   3   3 254   3   3 254   3   3
-254  21  21 254  21  21 254   3   3 254   3   3
-254   3   3 239 159 153 246 230 190 254  21  21
-254   3   3 254   3   3 254   3   3 254  56  56
-254   3   3 254   3   3 254   3   3 212 132  53
-246 246 246 254  21  21 254   3   3 254   3   3
-254   3   3 249 100  93 246 246 246 246 246 246
-249 100  93 254   3   3 254   3   3 254   3   3
-254  21  21 242 242 242 214 214 214  14  14  13
-  2   2   2   6   6   6 210 210 210 252 251 251
-254  56  56 254   3   3 254   3   3 254   3   3
-254   3   3 249 100  93 239 159 153 239 159 153
-239 159 153 239 159 153 238 238 238 246 246 246
-246 246 246 254  56  56 254   3   3 254   3   3
-254   3   3 249 100  93 246 246 246 239 159 153
-254   3   3 254   3   3 254   3   3 254   3   3
-246 230 190 239 159 153 254   3   3 254   3   3
-254   3   3 254   3   3 254  21  21 254  21  21
-254   3   3 254   3   3 254   3   3 254   3   3
-254   3   3 246 246 246 249 100  93 254   3   3
-254   3   3 254   3   3 254  21  21 218 194 134
-242 242 242 239 159 153 254   3   3 254   3   3
-254   3   3 249 100  93 239 159 153 254   3   3
-254   3   3 254   3   3 254   3   3 254   3   3
-254   3   3 254   3   3 254   3   3 218 194 134
-226 210 207 254   3   3 254   3   3 254   3   3
-254   3   3 254  21  21 254  21  21 254  21  21
-254   3   3 254   3   3 254   3   3 254   3   3
-249 100  93 254 254 254 158 158 158   2   2   2
-  2   2   2  10  10  10 186 186 186 246 246 246
-254  56  56 254   3   3 254   3   3 254   3   3
-254   3   3 254   3   3 254   3   3 254   3   3
-254   3   3 254   3   3 254  56  56 252 251 251
-246 230 190 254  21  21 254   3   3 254   3   3
-254   3   3 239 159 153 252 251 251 249 100  93
-254   3   3 254   3   3 254   3   3 254  56  56
-252 251 251 249 100  93 254   3   3 254   3   3
-254   3   3 254  21  21 218 194 134 226 210 207
-254  56  56 254   3   3 254   3   3 254   3   3
-254  56  56 231 220 218 254  21  21 254   3   3
-254   3   3 254   3   3 254  21  21 254  56  56
-254  56  56 254  56  56 254   3   3 254   3   3
-254   3   3 239 159 153 249 100  93 254   3   3
-254   3   3 254   3   3 254   3   3 254   3   3
-254   3   3 254   3   3 254  21  21 246 246 246
-212 132  53 254   3   3 254   3   3 254   3   3
-254   3   3 254   3   3 254   3   3 254   3   3
-254   3   3 254   3   3 254   3   3 254   3   3
-239 159 153 252 251 251  89  90  90   2   2   2
-  2   2   2   6   6   6  50  50  50 206 206 206
-226 210 207 249 100  93 254  56  56 254  21  21
-254  21  21 254  21  21 254   3   3 254   3   3
-254   3   3 254   3   3 254   3   3 238 238 238
-239 159 153 254   3   3 254   3   3 254   3   3
-254  21  21 226 210 207 238 238 238 254  21  21
-254   3   3 254   3   3 254   3   3 212 132  53
-238 238 238 254  56  56 254   3   3 254   3   3
-254   3   3 239 159 153 246 246 246 246 246 246
-254  56  56 254   3   3 254   3   3 254   3   3
-249 100  93 239 159 153 254   3   3 254   3   3
-254   3   3 254   3   3 254   3   3 254   3   3
-254   3   3 254   3   3 254   3   3 254   3   3
-254  21  21 226 210 207 254  56  56 254   3   3
-254   3   3 254   3   3 254  21  21 249 100  93
-239 159 153 239 159 153 239 159 153 246 246 246
-254  56  56 254   3   3 254   3   3 254   3   3
-254   3   3 254  21  21 254  21  21 254   3   3
-254   3   3 254   3   3 254   3   3 254   3   3
-246 230 190 242 242 242  26  26  26   2   2   2
-  6   6   6  50  50  50 206 206 206 226 210 207
-231 220 218 231 220 218 231 220 218 246 230 190
-246 230 190 239 159 153 254   3   3 254   3   3
-254   3   3 254   3   3 254  21  21 246 246 246
-249 100  93 254   3   3 254   3   3 254   3   3
-254  21  21 231 220 218 239 159 153 254   3   3
-254   3   3 254   3   3 254   3   3 218 194 134
-218 194 134 254   3   3 254   3   3 254   3   3
-254   3   3 239 159 153 246 230 190 239 159 153
-254   3   3 254   3   3 254   3   3 254   3   3
-239 159 153 212 132  53 254   3   3 254   3   3
-254   3   3 254  21  21 218 194 134 231 220 218
-231 220 218 231 220 218 226 210 207 218 194 134
-226 210 207 231 220 218 254   3   3 254   3   3
-254   3   3 254   3   3 212 132  53 246 246 246
-252 251 251 252 251 251 242 242 242 231 220 218
-254  21  21 254   3   3 254   3   3 254   3   3
-249 100  93 242 242 242 238 238 238 254  56  56
-254   3   3 254   3   3 254   3   3 254  56  56
-246 246 246 194 194 194   6   6   6   2   2   2
- 22  22  22 210 210 210 246 230 190 254  56  56
-254  21  21 254  21  21 254  21  21 254  21  21
-254  21  21 254  21  21 254   3   3 254   3   3
-254   3   3 254   3   3 249 100  93 246 246 246
-254  56  56 254   3   3 254   3   3 254   3   3
-254   3   3 254  21  21 254  21  21 254   3   3
-254   3   3 254   3   3 254  56  56 242 242 242
-212 132  53 254   3   3 254   3   3 254   3   3
-254   3   3 254  21  21 254  21  21 254   3   3
-254   3   3 254   3   3 254   3   3 254  56  56
-238 238 238 212 132  53 254   3   3 254   3   3
-254   3   3 254   3   3 254  56  56 249 100  93
-249 100  93 249 100  93 254  56  56 254  56  56
-246 246 246 239 159 153 254   3   3 254   3   3
-254   3   3 254  21  21 231 220 218 246 246 246
-206 170  74 182 158 106 246 246 246 239 159 153
-254   3   3 254   3   3 254   3   3 254   3   3
-218 194 134 242 242 242 246 230 190 254  21  21
-254   3   3 254   3   3 254   3   3 212 132  53
-252 251 251 131 126 116   6   6   6   2   2   2
- 89  90  90 246 246 246 239 159 153 254   3   3
-254   3   3 254   3   3 254   3   3 254   3   3
-254   3   3 254   3   3 254   3   3 254   3   3
-254   3   3 254  21  21 226 210 207 246 246 246
-249 100  93 254   3   3 254   3   3 254   3   3
-254   3   3 254   3   3 254   3   3 254   3   3
-254   3   3 254  56  56 226 210 207 252 251 251
-254  56  56 254   3   3 254   3   3 254   3   3
-254  56  56 254  21  21 254   3   3 254   3   3
-254   3   3 254   3   3 254  21  21 218 194 134
-238 238 238 226 210 207 254  21  21 254   3   3
-254   3   3 254   3   3 254   3   3 254   3   3
-254   3   3 254   3   3 254   3   3 239 159 153
-252 251 251 249 100  93 254   3   3 254   3   3
-254   3   3 254  56  56 246 246 246 231 220 218
-138 102  14 198 198 196 252 251 251 249 100  93
-254   3   3 254   3   3 254   3   3 254  21  21
-246 230 190 252 251 251 239 159 153 254   3   3
-254   3   3 254   3   3 254   3   3 218 194 134
-242 242 242  62  62  62   6   6   6   2   2   2
- 58  58  58 122 122 122 218 194 134 212 132  53
-249 100  93 249 100  93 254  56  56 254  56  56
-254  56  56 254  56  56 254  56  56 249 100  93
-212 132  53 246 230 190 214 214 214 146 146 146
-242 242 242 239 159 153 249 100  93 254  56  56
-254  56  56 254  56  56 254  56  56 249 100  93
-239 159 153 246 230 190 246 246 246 246 230 190
-254  21  21 254   3   3 254   3   3 254   3   3
-239 159 153 218 194 134 249 100  93 254  56  56
-254  56  56 249 100  93 226 210 207 230 230 228
- 89  90  90 231 220 218 226 210 207 249 100  93
-249 100  93 254  56  56 254  56  56 254  56  56
-249 100  93 249 100  93 239 159 153 238 238 238
-218 194 134 239 159 153 212 132  53 249 100  93
-249 100  93 239 159 153 231 220 218 154 142  90
-102 102 102 146 146 146 170 170 170 239 159 153
-249 100  93 249 100  93 249 100  93 239 159 153
-218 218 218 130 130 130 239 159 153 249 100  93
-249 100  93 249 100  93 212 132  53 246 230 190
-118 118 118  18  14   6   6   6   6   2   2   2
-  2   2   2  58  58  58 118 118 118 242 242 242
-254 254 254 250 250 250 246 246 246 246 246 246
-246 246 246 246 246 246 246 246 246 252 251 251
-252 251 251 214 214 214  50  50  50  18  18  18
-138 138 142 246 246 246 252 251 251 246 246 246
-246 246 246 246 246 246 246 246 246 252 251 251
-252 251 251 231 220 218 252 251 251 239 159 153
-254   3   3 254   3   3 254   3   3 254  21  21
-231 220 218 238 238 238 252 251 251 242 242 242
-252 251 251 252 251 251 230 230 228  74  74  74
- 18  18  18  62  62  62 226 226 226 254 254 254
-252 251 251 246 246 246 246 246 246 252 251 251
-252 251 251 252 251 251 250 250 250 150 150 150
-162 146  94 205 195 190 252 251 251 252 251 251
-252 251 251 226 210 207 142 134 106  86  86  86
- 58  58  58  34  34  34 122 122 122 163 163 163
-252 251 251 254 254 254 250 250 250 223 222 222
-102  98  90  78  78  78 130 130 130 254 254 254
-254 254 254 254 254 254 246 246 246 118 118 118
- 18  14   6   3   3   3   2   2   2   2   2   2
-  2   2   2   2   2   2  58  58  58 122 122 122
-150 150 150 170 170 170 182 182 182 190 190 187
-201 202 203 201 202 203 190 190 187 170 170 170
-118 118 118  30  30  30   6   6   6   6   6   6
- 10  10  10  86  86  86 150 150 150 182 182 182
-201 202 203 201 202 203 190 190 187 174 174 174
-134 134 134 146 146 146 190 190 187 239 159 153
-249 100  93 249 100  93 249 100  93 249 100  93
-234 234 234 138 138 142 166 166 166 198 198 196
-190 190 187 138 138 142  42  42  43   6   6   6
-  3   3   3   6   6   6  50  50  50 138 138 142
-174 174 174 198 198 196 198 198 196 182 182 182
-163 163 163 138 138 142 102  98  90  70  70  70
- 94  86  75 158 158 158 178 166 146 170 170 170
-174 174 174 138 138 142  74  74  74  50  50  50
- 26  26  26  14  14  13  10  10  10 118 118 118
-130 130 130 130 130 130 130 130 130 102  98  90
-  6   6   6   3   3   3  78  78  78 130 130 130
-130 130 130 130 130 130 118 118 118  18  14   6
-  3   3   3   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   6   6   6   6   6   6
- 10  10  10  10  10  10   6   6   6   2   2   2
-  2   2   2   2   2   2   2   2   2   6   6   6
-  6   6   6   6   6   6   6   6   6   6   6   6
- 14  14  13  14  14  13  22  22  22  22  22  22
- 34  34  34  42  42  43 122 122 122 174 174 174
-254 254 254 254 254 254 254 254 254 238 238 238
-138 138 142   6   6   6   6   6   6  10  10  10
-  6   6   6   2   2   2   2   2   2   6   6   6
-  6   6   6   6   6   6   6   6   6   2   2   2
-  6   6   6  10  10  10  10  10  10   6   6   6
-  2   2   2   6   6   6  14  14  13  30  30  30
- 42  42  43  54  54  54  62  62  62  62  62  62
- 54  54  54  42  42  43  30  30  30  18  18  18
- 10  10  10   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  6   6   6   2   2   2   6   6   6   2   2   2
-  2   2   2   2   2   2   2   2   2  10  10  10
- 10  10  10  10  10  10  14  14  13 106 106 105
-163 163 163 170 170 170 166 166 166 138 138 142
-  6   6   6   6   6   6   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  6   6   6   6   6   6   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   6   6   6
- 18  18  18  22  22  22  22  22  22  22  22  22
- 18  18  18  14  14  13  10  10  10   6   6   6
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
-  2   2   2   2   2   2   2   2   2   2   2   2
diff --git a/drivers/video/logo/logo_superh_vga16.ppm b/drivers/video/logo/logo_superh_vga16.ppm
deleted file mode 100644
index a8ffcd72951b53..00000000000000
--- a/drivers/video/logo/logo_superh_vga16.ppm
+++ /dev/null
@@ -1,1604 +0,0 @@
-P3
-# 16-color SuperH Linux logo
-80 80
-255
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85  85  85  85  85  85  85  85  85  85
- 85  85  85  85  85  85  85  85  85   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0  85  85  85  85  85  85
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
- 85  85  85  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0  85  85  85  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85 170 170 170   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0  85  85  85   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-170 170 170 170 170 170  85  85  85   0   0   0
-  0   0   0   0   0   0  85  85  85   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0  85  85  85   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0  85  85  85   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0  85  85  85 170 170 170   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0 170 170 170 170 170 170
-170 170 170   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
- 85  85  85 170 170 170 170 170 170 170 170 170
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0 170 170 170 255 255 255 255 255 255
-255 255 255 170 170 170   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0  85  85  85
-170 170 170 170 170 170 255 255 255 255 255 255
-  0   0   0   0   0   0   0   0   0   0   0   0
-170 170 170 255 255 255 170 170 170 170 170 170
-255 255 255 170 170 170   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0  85  85  85
-170 170 170   0   0   0   0   0   0 255 255 255
- 85  85  85   0   0   0   0   0   0   0   0   0
-255 255 255 170 170 170   0   0   0  85  85  85
-170 170 170 255 255 255 170 170 170   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0  85  85  85
- 85  85  85   0   0   0   0   0   0 170 170 170
- 85  85  85   0   0   0   0   0   0   0   0   0
-255 255 255  85  85  85   0   0   0   0   0   0
- 85  85  85 255 255 255 170 170 170   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0  85  85  85
-170 170 170   0   0   0   0   0   0 170 170 170
- 85  85  85  85  85  85  85  85  85  85  85  85
-255 255 255  85  85  85   0   0   0   0   0   0
- 85  85  85 255 255 255 170 170 170   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-255 255 255   0   0   0   0   0   0 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0   0   0   0   0   0   0
- 85  85  85 255 255 255   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-170 170 170 170 170 170 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-170 170 170 170 170 170   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85  85  85  85   0   0   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0 170  85   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85  85  85  85   0   0   0
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0 170  85   0
-170  85   0 170  85   0  85  85  85   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0  85  85  85   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85  85  85  85   0   0   0
- 85  85  85 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-170  85   0 170  85   0 170  85   0 170  85   0
-170  85   0 170  85   0  85  85  85   0   0   0
-  0   0   0  85  85  85 170 170 170  85  85  85
-  0   0   0   0   0   0  85  85  85   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85  85  85  85   0   0   0
- 85  85  85 170  85   0 170  85   0 170  85   0
-170  85   0 170  85   0 170  85   0 170  85   0
-170  85   0 170  85   0 170  85   0 170  85   0
-170 170 170 170 170 170 170 170 170   0   0   0
-  0   0   0   0   0   0 170 170 170 170 170 170
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
- 85  85  85 170 170 170 170  85   0 170  85   0
-170  85   0 170  85   0 170  85   0 170  85   0
-170  85   0 170  85   0 170 170 170 170 170 170
-170 170 170 170 170 170 170 170 170  85  85  85
-  0   0   0   0   0   0  85  85  85  85  85  85
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
- 85  85  85 170 170 170 170 170 170 170  85   0
-170  85   0 170  85   0 170  85   0 170  85   0
-170 170 170 170 170 170 170 170 170 170 170 170
-255 255 255 255 255 255 255 255 255 170 170 170
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0  85  85  85
-255 255 255 255 255 255 170 170 170 170 170 170
-170 170 170 170 170 170 170 170 170 170 170 170
-170 170 170 170 170 170 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0 170 170 170
-255 255 255 255 255 255 170 170 170 170 170 170
-170 170 170 170 170 170 170 170 170 170 170 170
-170 170 170 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-170 170 170   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0  85  85  85 255 255 255
-255 255 255 255 255 255 255 255 255 170 170 170
-170 170 170 170 170 170 170 170 170 170 170 170
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0  85  85  85   0   0   0
-  0   0   0  85  85  85 170 170 170 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0  85  85  85   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0  85  85  85 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 170 170 170   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0  85  85  85 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0   0   0   0
- 85  85  85 170 170 170 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255  85  85  85   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85 170 170 170 170 170 170 170 170 170
-255 255 255 255 255 255 255 255 255 170 170 170
-170 170 170 170 170 170 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-170 170 170 170 170 170 170 170 170 170 170 170
-170 170 170 170 170 170 170 170 170  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-170 170 170 170 170 170 170 170 170 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-170 170 170 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 170 170 170 170 170 170
-170 170 170 170 170 170 170 170 170  85  85  85
-  0   0   0   0   0   0  85  85  85   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0  85  85  85   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0  85  85  85   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-170 170 170 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 170 170 170 170 170 170 170 170 170
-  0   0   0   0   0   0   0   0   0  85  85  85
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0  85  85  85   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0  85  85  85   0   0   0
- 85  85  85   0   0   0   0   0   0  85  85  85
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 170 170 170 170 170 170
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0 170 170 170
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-170 170 170  85  85  85   0   0   0   0   0   0
-  0   0   0  85  85  85  85  85  85   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0  85  85  85
-  0   0   0   0   0   0  85  85  85 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 170 170 170   0   0   0  85  85  85
- 85  85  85   0   0   0  85  85  85   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0  85  85  85
-  0   0   0  85  85  85 170 170 170 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 170 170 170   0   0   0  85  85  85
- 85  85  85   0   0   0  85  85  85   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0  85  85  85
-  0   0   0 170 170 170 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255  85  85  85   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0  85  85  85   0   0   0
-  0   0   0 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 170 170 170   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0  85  85  85   0   0   0
- 85  85  85 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 170 170 170   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0  85  85  85   0   0   0   0   0   0
-170 170 170 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 170 170 170   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0  85  85  85   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 170 170 170 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 170 170 170 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0  85  85  85
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 170 170 170 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0  85  85  85
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 170 170 170 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0  85  85  85  85  85  85
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 170 170 170 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 170 170 170 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255   0   0   0
- 85  85  85  85  85  85  85  85  85  85  85  85
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85   0   0   0 170  85   0
-255 255  85 170  85   0   0   0   0   0   0   0
- 85  85  85 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 170 170 170 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255  85  85  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85  85  85  85   0   0   0
-  0   0   0  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0   0   0   0
-  0   0   0  85  85  85 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 170 170 170 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255  85 170  85   0 255 255  85   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0  85  85  85  85  85  85
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-  0   0   0   0   0   0  85  85  85 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255  85
-170  85   0 255 255  85 170  85   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-170  85   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0   0   0   0   0   0   0  85  85  85
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 170  85   0
-255 255  85 170  85   0 255 255  85   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0 170  85   0
-255 255  85 170  85   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85   0   0   0   0   0   0   0   0   0
- 85  85  85 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255  85
-170  85   0 255 255  85 170  85   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0 255 255  85
-170  85   0 255 255  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85   0   0   0   0   0   0
-  0   0   0  85  85  85 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 170 170 170 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0 255 255  85 170  85   0
-255 255  85 170  85   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85   0   0   0
-  0   0   0   0   0   0  85  85  85 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 170 170 170 170 170 170 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 170 170 170 170 170 170 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 170 170 170 170 170 170 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0  85  85  85 170 170 170
-170 170 170 170 170 170 170 170 170 255 255 255
-170 170 170 255 255 255 170 170 170 255 255  85
-170 170 170 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0   0   0   0   0   0   0   0   0   0
-  0   0   0 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 170 170 170 170 170 170 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255 255 170 170 170
-255 255  85 170 170 170  85  85  85   0   0   0
-  0   0   0  85  85  85 170 170 170  85  85  85
-170 170 170  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0 170 170 170 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255  85 170 170 170 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85 170  85   0 255 255  85 170  85   0
-255 255  85   0   0   0   0   0   0   0   0   0
- 85  85  85 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 170 170 170 170 170 170 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85 170  85   0 255 255  85
-170  85   0 255 255  85 170 170 170 255 255  85
-170  85   0 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255  85  85  85  85  85  85
- 85  85  85 255 255 255 255 255 255 255 255 255
-255 255 255 170 170 170  85  85  85   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-170 170 170 255 255 255 170 170 170 255  85  85
-255  85  85 255  85  85 255  85  85 255  85  85
-255  85  85 255  85  85 255  85  85 255  85  85
-170 170 170 255 255  85 255 255 255 255 255 255
-255 255 255 255 255 255 170 170 170 255 255  85
-170 170 170 255 255 255 255 255 255 255 255 255
-170 170 170 255 255  85 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 170  85   0 255 255  85 170 170 170
-255 255 255 255 255 255 255 255 255 170 170 170
-255 255  85 255 255 255 255 255 255 255 255 255
-255 255  85 255 255 255 255  85  85 255  85  85
-255  85  85 255  85  85 170 170 170 170 170 170
-255 255 255 170 170 170 255  85  85 255  85  85
-255  85  85 170 170 170 170 170 170  85  85  85
-  0   0   0   0   0   0   0   0   0 170 170 170
-255 255 255 255  85  85 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-170 170 170 255 255 255 170 170 170 255 255 255
-255 255 255 170 170 170 255 255 255 170 170 170
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 170 170 170 255 255 255 255 255 255
-255 255 255 170 170 170 255 255 255 255 255 255
-255 255 255 170 170 170 170 170 170 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 170 170 170 170 170 170 170 170 170
-170 170 170 170 170 170 170 170 170 255 255 255
-255 255 255 255 255  85 170 170 170 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 170 170 170 170 170 170 170 170 170
-255 255 255 170 170 170 170   0   0 255  85  85
-170   0   0 255  85  85 170 170 170 255 255 255
-170 170 170 170   0   0 170   0   0 170   0   0
-170   0   0 255  85  85 255 255 255  85  85  85
-  0   0   0   0   0   0  85  85  85 255 255 255
-170 170 170 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-170 170 170 255 255 255 170   0   0 170   0   0
-170   0   0 170   0   0 170 170 170 255 255 255
-255  85  85 170   0   0 170   0   0 170   0   0
-255  85  85 255 255 255 255  85  85 170   0   0
-170   0   0 170   0   0 255  85  85 255  85  85
-170   0   0 170   0   0 170   0   0 170   0   0
-255  85  85 255 255 255 255 255 255 170 170 170
-255  85  85 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-255  85  85 255 255 255 255 255 255 255  85  85
-170   0   0 170   0   0 170   0   0 255  85  85
-255  85  85 170   0   0 170   0   0 255  85  85
-255 255 255 255  85  85 170   0   0 170   0   0
-170   0   0 255  85  85 255 255 255 255 255 255
-170 170 170 170   0   0 170   0   0 170   0   0
-255  85  85 170 170 170 255 255 255  85  85  85
-  0   0   0   0   0   0 170 170 170 255 255 255
-255  85  85 170   0   0 170   0   0 170   0   0
-170   0   0 255  85  85 170 170 170 170 170 170
-170 170 170 255  85  85 255  85  85 170 170 170
-255 255 255 255  85  85 170   0   0 170   0   0
-170   0   0 255  85  85 255 255 255 170 170 170
-170   0   0 170   0   0 170   0   0 170   0   0
-170 170 170 255 255 255 170   0   0 170   0   0
-170   0   0 170   0   0 255  85  85 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-170   0   0 255 255 255 255 255 255 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-255  85  85 170   0   0 170   0   0 170   0   0
-170   0   0 170 170 170 255 255 255 170   0   0
-170   0   0 170   0   0 170   0   0 255  85  85
-170   0   0 170   0   0 170   0   0 255  85  85
-255 255 255 170   0   0 170   0   0 170   0   0
-170   0   0 255  85  85 255 255 255 255 255 255
-255  85  85 170   0   0 170   0   0 170   0   0
-170   0   0 255 255 255 255 255 255   0   0   0
-  0   0   0   0   0   0 170 170 170 255 255 255
-255  85  85 170   0   0 170   0   0 170   0   0
-170   0   0 255  85  85 255  85  85 170 170 170
-170 170 170 170 170 170 255 255 255 255 255 255
-255 255 255 255  85  85 170   0   0 170   0   0
-170   0   0 255  85  85 255 255 255 170 170 170
-170   0   0 170   0   0 170   0   0 170   0   0
-255 255 255 170 170 170 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-170   0   0 255 255 255 255  85  85 170   0   0
-170   0   0 170   0   0 170   0   0 170 170 170
-255 255 255 170 170 170 170   0   0 170   0   0
-170   0   0 255  85  85 170 170 170 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 170 170 170
-255 255 255 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-255  85  85 255 255 255 170 170 170   0   0   0
-  0   0   0   0   0   0 170 170 170 255 255 255
-255  85  85 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 255  85  85 255 255 255
-255 255 255 170   0   0 170   0   0 170   0   0
-170   0   0 255  85  85 255 255 255 255  85  85
-170   0   0 170   0   0 170   0   0 255  85  85
-255 255 255 255  85  85 170   0   0 170   0   0
-170   0   0 255  85  85 170 170 170 255 255 255
-170   0   0 170   0   0 170   0   0 170   0   0
-255  85  85 170 170 170 255  85  85 170   0   0
-170   0   0 170   0   0 255  85  85 255  85  85
-255  85  85 255  85  85 170   0   0 170   0   0
-170   0   0 170 170 170 255  85  85 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 255  85  85 255 255 255
-255  85  85 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-170 170 170 255 255 255  85  85  85   0   0   0
-  0   0   0   0   0   0   0   0   0 255 255 255
-170 170 170 255  85  85 255  85  85 170   0   0
-255  85  85 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 255 255 255
-170 170 170 170   0   0 170   0   0 170   0   0
-255  85  85 170 170 170 255 255 255 255  85  85
-170   0   0 170   0   0 170   0   0 255  85  85
-255 255 255 255  85  85 170   0   0 170   0   0
-170   0   0 255  85  85 255 255 255 255 255 255
-255  85  85 170   0   0 170   0   0 170   0   0
-255  85  85 170 170 170 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-170   0   0 255 255 255 255  85  85 170   0   0
-170   0   0 170   0   0 170   0   0 255  85  85
-170 170 170 255  85  85 170 170 170 255 255 255
-255  85  85 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 255  85  85 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-255 255 255 255 255 255   0   0   0   0   0   0
-  0   0   0  85  85  85 170 170 170 170 170 170
-255 255 255 255 255 255 170 170 170 255 255 255
-255 255 255 170 170 170 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 255 255 255
-255  85  85 170   0   0 170   0   0 170   0   0
-170   0   0 255 255 255 170 170 170 170   0   0
-170   0   0 170   0   0 170   0   0 170 170 170
-170 170 170 170   0   0 170   0   0 170   0   0
-170   0   0 170 170 170 255 255 255 255  85  85
-170   0   0 170   0   0 170   0   0 170   0   0
-170 170 170 255  85  85 170   0   0 170   0   0
-170   0   0 170   0   0 255 255 255 170 170 170
-255 255 255 255 255 255 170 170 170 255 255 255
-170 170 170 255 255 255 170   0   0 170   0   0
-170   0   0 170   0   0 170 170 170 255 255 255
-255 255 255 255 255 255 255 255 255 170 170 170
-170   0   0 170   0   0 170   0   0 170   0   0
-170 170 170 255 255 255 255 255 255 255  85  85
-170   0   0 170   0   0 170   0   0 255  85  85
-255 255 255 170 170 170   0   0   0   0   0   0
-  0   0   0 255 255 255 255 255 255 255  85  85
-170   0   0 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 255  85  85 255 255 255
-255  85  85 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 255  85  85 255 255 255
-255  85  85 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 255  85  85 170   0   0
-170   0   0 170   0   0 170   0   0 255  85  85
-255 255 255 170 170 170 170   0   0 170   0   0
-170   0   0 170   0   0 255  85  85 255  85  85
-255  85  85 255  85  85 170   0   0 255  85  85
-255 255 255 170 170 170 170   0   0 170   0   0
-170   0   0 170   0   0 255 255 255 255 255 255
-255  85  85 170 170 170 255 255 255 170 170 170
-170   0   0 170   0   0 170   0   0 170   0   0
-170 170 170 170 170 170 255 255 255 170   0   0
-170   0   0 170   0   0 170   0   0 255  85  85
-255 255 255 170 170 170   0   0   0   0   0   0
- 85  85  85 255 255 255 255  85  85 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-170   0   0 255  85  85 170 170 170 255 255 255
-255  85  85 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-170   0   0 255  85  85 170 170 170 255 255 255
-255  85  85 170   0   0 170   0   0 170   0   0
-255  85  85 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 170 170 170
-255 255 255 170 170 170 255  85  85 170   0   0
-170   0   0 170   0   0 170   0   0 170   0   0
-170   0   0 170   0   0 170   0   0 170 170 170
-255 255 255 255  85  85 170   0   0 170   0   0
-170   0   0 255  85  85 255 255 255 170 170 170
-170  85   0 170 170 170 255 255 255 255  85  85
-170   0   0 170   0   0 170   0   0 255  85  85
-255 255 255 255 255 255 170 170 170 170   0   0
-170   0   0 170   0   0 170   0   0 170 170 170
-255 255 255  85  85  85   0   0   0   0   0   0
- 85  85  85 170 170 170 170 170 170 170 170 170
-255  85  85 255  85  85 255  85  85 255  85  85
-255  85  85 255  85  85 255  85  85 255  85  85
-255  85  85 255 255 255 170 170 170 170 170 170
-255 255 255 170 170 170 255  85  85 255  85  85
-255  85  85 255  85  85 255  85  85 255  85  85
-255  85  85 255 255 255 255 255 255 255 255 255
-170   0   0 170   0   0 170   0   0 170   0   0
-170 170 170 170 170 170 255  85  85 255  85  85
-255  85  85 255  85  85 170 170 170 255 255 255
- 85  85  85 170 170 170 255 255 255 255  85  85
-255  85  85 255  85  85 255  85  85 255  85  85
-255  85  85 255  85  85 170 170 170 255 255 255
-170 170 170 255  85  85 170 170 170 255  85  85
-255  85  85 170 170 170 255 255  85 170 170 170
-  0   0   0  85  85  85 170 170 170 255  85  85
-170 170 170 255  85  85 255  85  85 255  85  85
-255 255 255 255  85  85 170 170 170 255  85  85
-170 170 170 255  85  85 170 170 170 255 255 255
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85 170  85   0 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255   0   0   0   0   0   0
-170 170 170 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255 255  85  85
-170   0   0 170   0   0 170   0   0 170   0   0
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255  85  85  85
-  0   0   0  85  85  85 170 170 170 255 255 255
-255 255 255 255 255 255 255 255 255 255 255 255
-255 255 255 255 255 255 255 255 255  85  85  85
-170 170 170 255 255  85 255 255 255 255 255 255
-255 255 255 255 255 255 255  85  85   0   0   0
-  0   0   0   0   0   0 170 170 170 170 170 170
-255 255 255 255 255 255 255 255 255 255 255 255
- 85  85  85  85  85  85 170 170 170 255 255 255
-255 255 255 255 255 255 255 255 255 170  85   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0  85  85  85  85  85  85
-170 170 170 170 170 170 170 170 170 170 170 170
-170 170 170 170 170 170 170 170 170 170 170 170
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0  85  85  85 170 170 170 170 170 170
-170 170 170 170 170 170 170 170 170 170 170 170
- 85  85  85  85  85  85 170 170 170 170 170 170
-255  85  85 255  85  85 255  85  85 255  85  85
-255 255 255 170  85   0 170 170 170 170 170 170
-170 170 170 170 170 170   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0 170 170 170
-170 170 170 170 170 170 170 170 170 170 170 170
-170 170 170  85  85  85 170  85   0   0   0   0
-  0   0   0  85  85  85  85  85  85 170 170 170
- 85  85  85  85  85  85   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-170 170 170  85  85  85 170 170 170  85  85  85
-  0   0   0   0   0   0  85  85  85  85  85  85
-170 170 170  85  85  85 170 170 170   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0  85  85  85 170 170 170
-255 255 255 255 255 255 255 255 255 255 255 255
- 85  85  85   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0  85  85  85
-170 170 170 170 170 170 170 170 170 170 170 170
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
-  0   0   0   0   0   0   0   0   0   0   0   0
diff --git a/fs/Kconfig.binfmt b/fs/Kconfig.binfmt
index 93539aac0e5b2e..acfa591b604611 100644
--- a/fs/Kconfig.binfmt
+++ b/fs/Kconfig.binfmt
@@ -58,7 +58,7 @@ config ARCH_USE_GNU_PROPERTY
 config BINFMT_ELF_FDPIC
 	bool "Kernel support for FDPIC ELF binaries"
 	default y if !BINFMT_ELF
-	depends on ARM || ((M68K || SUPERH || XTENSA) && !MMU)
+	depends on ARM || ((M68K || XTENSA) && !MMU)
 	select ELFCORE
 	help
 	  ELF FDPIC binaries are based on ELF, but allow the individual load
diff --git a/fs/minix/Kconfig b/fs/minix/Kconfig
index de2003974ff0d0..8bf3547f9aa2e2 100644
--- a/fs/minix/Kconfig
+++ b/fs/minix/Kconfig
@@ -19,7 +19,7 @@ config MINIX_FS
 
 config MINIX_FS_NATIVE_ENDIAN
 	def_bool MINIX_FS
-	depends on MICROBLAZE || MIPS || S390 || SUPERH || SPARC || XTENSA || (M68K && !MMU)
+	depends on MICROBLAZE || MIPS || S390 || SPARC || XTENSA || (M68K && !MMU)
 
 config MINIX_FS_BIG_ENDIAN_16BIT_INDEXED
 	def_bool MINIX_FS
diff --git a/include/linux/cpuhotplug.h b/include/linux/cpuhotplug.h
index 6c6859bfc454cf..c977e87caf67a0 100644
--- a/include/linux/cpuhotplug.h
+++ b/include/linux/cpuhotplug.h
@@ -64,7 +64,6 @@ enum cpuhp_state {
 	CPUHP_PERF_X86_PREPARE,
 	CPUHP_PERF_X86_AMD_UNCORE_PREP,
 	CPUHP_PERF_POWER,
-	CPUHP_PERF_SUPERH,
 	CPUHP_X86_HPET_DEAD,
 	CPUHP_X86_APB_DEAD,
 	CPUHP_X86_MCE_DEAD,
diff --git a/include/linux/sh_intc.h b/include/linux/sh_intc.h
index c255273b02810e..f0fe4cf51b7e56 100644
--- a/include/linux/sh_intc.h
+++ b/include/linux/sh_intc.h
@@ -4,11 +4,7 @@
 
 #include <linux/ioport.h>
 
-#ifdef CONFIG_SUPERH
-#define INTC_NR_IRQS	512
-#else
 #define INTC_NR_IRQS	1024
-#endif
 
 /*
  * Convert back and forth between INTEVT and IRQ values.
diff --git a/init/Kconfig b/init/Kconfig
index 0958846b005e15..a5566d69cc9c94 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1535,7 +1535,7 @@ config MULTIUSER
 
 config SGETMASK_SYSCALL
 	bool "sgetmask/ssetmask syscalls support" if EXPERT
-	def_bool PARISC || M68K || PPC || MIPS || X86 || SPARC || MICROBLAZE || SUPERH
+	def_bool PARISC || M68K || PPC || MIPS || X86 || SPARC || MICROBLAZE
 	help
 	  sys_sgetmask and sys_ssetmask are obsolete system calls
 	  no longer supported in libc but still enabled by default in some
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 137d4abe3eda11..e1ce74fb991b25 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -2362,8 +2362,7 @@ static struct ctl_table vm_table[] = {
 		.proc_handler	= numa_zonelist_order_handler,
 	},
 #endif
-#if (defined(CONFIG_X86_32) && !defined(CONFIG_UML))|| \
-   (defined(CONFIG_SUPERH) && defined(CONFIG_VSYSCALL))
+#if defined(CONFIG_X86_32) && !defined(CONFIG_UML)
 	{
 		.procname	= "vdso_enabled",
 #ifdef CONFIG_X86_32
diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug
index 881c3f84e88a32..c51d1f181913f3 100644
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -514,7 +514,7 @@ config ARCH_WANT_FRAME_POINTERS
 
 config FRAME_POINTER
 	bool "Compile the kernel with frame pointers"
-	depends on DEBUG_KERNEL && (M68K || UML || SUPERH) || ARCH_WANT_FRAME_POINTERS
+	depends on DEBUG_KERNEL && (M68K || UML) || ARCH_WANT_FRAME_POINTERS
 	default y if (DEBUG_INFO && UML) || ARCH_WANT_FRAME_POINTERS
 	help
 	  If you say Y here the resulting kernel image will be slightly
diff --git a/lib/math/div64.c b/lib/math/div64.c
index 55a81782e2717f..7c51cd1fc9d527 100644
--- a/lib/math/div64.c
+++ b/lib/math/div64.c
@@ -14,8 +14,8 @@
  *
  * Code generated for this function might be very inefficient
  * for some CPUs. __div64_32() can be overridden by linking arch-specific
- * assembly versions such as arch/ppc/lib/div64.S and arch/sh/lib/div64.S
- * or by defining a preprocessor macro in arch/include/asm/div64.h.
+ * assembly versions such as arch/ppc/lib/div64.S or by defining a preprocessor
+ * macro in arch/include/asm/div64.h.
  */
 
 #include <linux/bitops.h>
diff --git a/lib/test_user_copy.c b/lib/test_user_copy.c
index 5ff04d8fe97163..b762c629b59545 100644
--- a/lib/test_user_copy.c
+++ b/lib/test_user_copy.c
@@ -26,8 +26,7 @@
 			    !defined(CONFIG_M68K) &&		\
 			    !defined(CONFIG_MICROBLAZE) &&	\
 			    !defined(CONFIG_NIOS2) &&		\
-			    !defined(CONFIG_PPC32) &&		\
-			    !defined(CONFIG_SUPERH))
+			    !defined(CONFIG_PPC32))
 # define TEST_U64
 #endif
 
diff --git a/scripts/coccinelle/misc/cond_no_effect.cocci b/scripts/coccinelle/misc/cond_no_effect.cocci
index 91d16a81d1da94..05564c2b86b0f3 100644
--- a/scripts/coccinelle/misc/cond_no_effect.cocci
+++ b/scripts/coccinelle/misc/cond_no_effect.cocci
@@ -14,18 +14,7 @@
 // In the Linux kernel it does not seem to actually report
 // false positives except for those that were documented as
 // being intentional.
-// the two known cases are:
-//   arch/sh/kernel/traps_64.c:read_opcode()
-//        } else if ((pc & 1) == 0) {
-//              /* SHcompact */
-//              /* TODO : provide handling for this.  We don't really support
-//                 user-mode SHcompact yet, and for a kernel fault, this would
-//                 have to come from a module built for SHcompact.  */
-//              return -EFAULT;
-//      } else {
-//              /* misaligned */
-//              return -EFAULT;
-//      }
+// the one known case is:
 //   fs/kernfs/file.c:kernfs_fop_open()
 //       * Both paths of the branch look the same.  They're supposed to
 //       * look that way and give @of->mutex different static lockdep keys.
diff --git a/scripts/head-object-list.txt b/scripts/head-object-list.txt
index b074134cfac210..4b844a1e3be88e 100644
--- a/scripts/head-object-list.txt
+++ b/scripts/head-object-list.txt
@@ -39,7 +39,6 @@ arch/powerpc/kernel/fpu.o
 arch/powerpc/kernel/vector.o
 arch/powerpc/kernel/prom_init.o
 arch/s390/kernel/head64.o
-arch/sh/kernel/head_32.o
 arch/sparc/kernel/head_32.o
 arch/sparc/kernel/head_64.o
 arch/x86/kernel/head_32.o
diff --git a/sound/soc/sh/Kconfig b/sound/soc/sh/Kconfig
index 7bddfd5e38d6cf..793a0326f32b46 100644
--- a/sound/soc/sh/Kconfig
+++ b/sound/soc/sh/Kconfig
@@ -1,6 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0
 menu "SoC Audio support for Renesas SoCs"
-	depends on SUPERH || ARCH_RENESAS || COMPILE_TEST
+	depends on ARCH_RENESAS || COMPILE_TEST
 
 config SND_SOC_PCM_SH7760
 	tristate "SoC Audio support for Renesas SH7760"
@@ -23,7 +23,7 @@ config SND_SOC_SH4_SSI
 
 config SND_SOC_SH4_FSI
 	tristate "SH4 FSI support"
-	depends on SUPERH || COMMON_CLK
+	depends on COMMON_CLK
 	select SND_SIMPLE_CARD
 	help
 	  This option enables FSI sound support
diff --git a/tools/include/asm/barrier.h b/tools/include/asm/barrier.h
index 8d378c57cb0114..ca1979459a127f 100644
--- a/tools/include/asm/barrier.h
+++ b/tools/include/asm/barrier.h
@@ -10,8 +10,6 @@
 #include "../../arch/powerpc/include/asm/barrier.h"
 #elif defined(__s390__)
 #include "../../arch/s390/include/asm/barrier.h"
-#elif defined(__sh__)
-#include "../../arch/sh/include/asm/barrier.h"
 #elif defined(__sparc__)
 #include "../../arch/sparc/include/asm/barrier.h"
 #elif defined(__tile__)
diff --git a/tools/perf/util/dwarf-regs.c b/tools/perf/util/dwarf-regs.c
index 3fa4486742cdfe..54fdbfb22ec274 100644
--- a/tools/perf/util/dwarf-regs.c
+++ b/tools/perf/util/dwarf-regs.c
@@ -19,7 +19,6 @@
 #include "../arch/x86/include/dwarf-regs-table.h"
 #include "../arch/arm/include/dwarf-regs-table.h"
 #include "../arch/arm64/include/dwarf-regs-table.h"
-#include "../arch/sh/include/dwarf-regs-table.h"
 #include "../arch/powerpc/include/dwarf-regs-table.h"
 #include "../arch/s390/include/dwarf-regs-table.h"
 #include "../arch/sparc/include/dwarf-regs-table.h"
-- 
2.39.0

