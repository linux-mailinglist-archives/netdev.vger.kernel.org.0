Return-Path: <netdev-owner@vger.kernel.org>
X-Original-To: lists+netdev@lfdr.de
Delivered-To: lists+netdev@lfdr.de
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.lfdr.de (Postfix) with ESMTP id 79C2D1C47F
	for <lists+netdev@lfdr.de>; Tue, 14 May 2019 10:15:50 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726058AbfENIPs (ORCPT <rfc822;lists+netdev@lfdr.de>);
        Tue, 14 May 2019 04:15:48 -0400
Received: from mail-wr1-f47.google.com ([209.85.221.47]:43860 "EHLO
        mail-wr1-f47.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1725899AbfENIPs (ORCPT
        <rfc822;netdev@vger.kernel.org>); Tue, 14 May 2019 04:15:48 -0400
Received: by mail-wr1-f47.google.com with SMTP id r4so18065343wro.10
        for <netdev@vger.kernel.org>; Tue, 14 May 2019 01:15:47 -0700 (PDT)
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:date:from:to:cc:subject:message-id:mime-version
         :content-disposition:user-agent;
        bh=fo831Rv+pGwZxOpXpL7A74tnI9dct76ZpcdoJOpQoH4=;
        b=oj6QI0b7fL79UfqKLwKknXVEflgNMoE+gbcQahAnWe+8buAIyrzfjha3g7bKeTTtOa
         Tr33j1t+GkraY1TifqaKXlDgPr0ge84jczgPomI21UHCElpK+DuU8hwfAlkQAmnmjyIc
         1w/uCZ47lkwEJUBXXU5Rze65b+roztmznuTpuk9mC2bUjTFawMgykDv2KNsPG3f/JoBB
         e92Pn5Z5vw/ziBjM/vrXo0xBKlIWBhc4rEnA4oiO2sI5AIPorTabhqfGkTVWE0s9pmS/
         4lA5ye5NNKckHnSZobxDkllMBsDuVMhL6hQPR60YrjaAwClPZDzwa/7OdLmppEHf/Ghw
         zh1g==
X-Gm-Message-State: APjAAAVWAzZuio/Bouh7nqp4TrHNO0X/cMlU9KdV1DCSlTT6Q6Joz58C
        EmNJG+SWrDV6EmOq+mDpBzKepTroiJc=
X-Google-Smtp-Source: APXvYqzXUED3YY24fAx2pL2x5N9aovdW3hN1e2c8peRKnX7PnV1Xr4S9W7T/CpgIgrFl04rQNaxefw==
X-Received: by 2002:adf:f5d1:: with SMTP id k17mr19973852wrp.281.1557821746594;
        Tue, 14 May 2019 01:15:46 -0700 (PDT)
Received: from steredhat (host151-251-static.12-87-b.business.telecomitalia.it. [87.12.251.151])
        by smtp.gmail.com with ESMTPSA id c20sm19255377wre.28.2019.05.14.01.15.45
        (version=TLS1_2 cipher=ECDHE-RSA-CHACHA20-POLY1305 bits=256/256);
        Tue, 14 May 2019 01:15:45 -0700 (PDT)
Date:   Tue, 14 May 2019 10:15:43 +0200
From:   Stefano Garzarella <sgarzare@redhat.com>
To:     netdev@vger.kernel.org, Stefan Hajnoczi <stefanha@redhat.com>,
        Dexuan Cui <decui@microsoft.com>,
        Jorgen Hansen <jhansen@vmware.com>
Cc:     "David S. Miller" <davem@davemloft.net>,
        Vishnu Dasa <vdasa@vmware.com>,
        "K. Y. Srinivasan" <kys@microsoft.com>,
        Haiyang Zhang <haiyangz@microsoft.com>,
        Stephen Hemminger <sthemmin@microsoft.com>,
        Sasha Levin <sashal@kernel.org>
Subject: [RFC] vsock: proposal to support multiple transports at runtime
Message-ID: <20190514081543.f6nphcilgjuemlet@steredhat>
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: NeoMutt/20180716
Sender: netdev-owner@vger.kernel.org
Precedence: bulk
List-ID: <netdev.vger.kernel.org>
X-Mailing-List: netdev@vger.kernel.org

Hi guys,
I'm currently interested on implement a multi-transport support for VSOCK in
order to handle nested VMs.

As Stefan suggested me, I started to look at this discussion:
https://lkml.org/lkml/2017/8/17/551
Below I tried to summarize a proposal for a discussion, following the ideas
from Dexuan, Jorgen, and Stefan.


We can define two types of transport that we have to handle at the same time
(e.g. in a nested VM we would have both types of transport running together):

- 'host side transport', it runs in the host and it is used to communicate with
  the guests of a specific hypervisor (KVM, VMWare or HyperV)

  Should we support multiple 'host side transport' running at the same time?

- 'guest side transport'. it runs in the guest and it is used to communicate
  with the host transport


The main goal is to find a way to decide what transport use in these cases:
1. connect() / sendto()

	a. use the 'host side transport', if the destination is the guest
	   (dest_cid > VMADDR_CID_HOST).
	   If we want to support multiple 'host side transport' running at the
	   same time, we should assign CIDs uniquely across all transports.
	   In this way, a packet generated by the host side will get directed
	   to the appropriate transport based on the CID

	b. use the 'guest side transport', if the destination is the host
	   (dest_cid == VMADDR_CID_HOST)


2. listen() / recvfrom()

	a. use the 'host side transport', if the socket is bound to
	   VMADDR_CID_HOST, or it is bound to VMADDR_CID_ANY and there is no
	   guest transport.
	   We could also define a new VMADDR_CID_LISTEN_FROM_GUEST in order to
	   address this case.
	   If we want to support multiple 'host side transport' running at the
	   same time, we should find a way to allow an application to bound a
	   specific host transport (e.g. adding new VMADDR_CID_LISTEN_FROM_KVM,
	   VMADDR_CID_LISTEN_FROM_VMWARE, VMADDR_CID_LISTEN_FROM_HYPERV)

	b. use the 'guest side transport', if the socket is bound to local CID
	   different from the VMADDR_CID_HOST (guest CID get with
	   IOCTL_VM_SOCKETS_GET_LOCAL_CID), or it is bound to VMADDR_CID_ANY
	   (to be backward compatible).
	   Also in this case, we could define a new VMADDR_CID_LISTEN_FROM_HOST.

Thanks in advance for your comments and suggestions.

Cheers,
Stefano
