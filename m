Return-Path: <netdev-owner@vger.kernel.org>
X-Original-To: lists+netdev@lfdr.de
Delivered-To: lists+netdev@lfdr.de
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.lfdr.de (Postfix) with ESMTP id 577A05FC64
	for <lists+netdev@lfdr.de>; Thu,  4 Jul 2019 19:19:35 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727477AbfGDRTc (ORCPT <rfc822;lists+netdev@lfdr.de>);
        Thu, 4 Jul 2019 13:19:32 -0400
Received: from resqmta-ch2-04v.sys.comcast.net ([69.252.207.36]:48160 "EHLO
        resqmta-ch2-04v.sys.comcast.net" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S1726885AbfGDRTb (ORCPT
        <rfc822;netdev@vger.kernel.org>); Thu, 4 Jul 2019 13:19:31 -0400
X-Greylist: delayed 488 seconds by postgrey-1.27 at vger.kernel.org; Thu, 04 Jul 2019 13:19:31 EDT
Received: from resomta-ch2-04v.sys.comcast.net ([69.252.207.100])
        by resqmta-ch2-04v.sys.comcast.net with ESMTP
        id j52ghYR70UhOfj5GVhHNGK; Thu, 04 Jul 2019 17:11:23 +0000
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=comcastmailservice.net; s=20180828_2048; t=1562260283;
        bh=TVpK/aPQOmRt6Ogg2rR2y/hhw/MUZpLcnKg1OULEeIw=;
        h=Received:Received:From:Subject:Reply-To:To:Message-ID:Date:
         MIME-Version:Content-Type;
        b=KfWj9O+PJP7UqZNoQaQz3aAWqSRTu/G+/ukLGnnFq712H9ZocLeqX/v2kfaTYUHjB
         Sz88piWuC3nXCLBKxzMcSaxhzZNCBSnQNh1KmA5qNmry8FXiSukyQoZoG7IDEI1ClC
         DjZ/aA7s/MJLuk8uUiJgzengOv+TBimWGmd5DA/gMg8FpWPd8Bn5noabulJbZamSmq
         7cKr89hmDdI+Wgj89jmhVYfd4P9d5Lb8eIvkjWzoKPyVjCsmSw1dCWeKf1oJ4ZHzyT
         uWbXkSSdfzlVA4bzstXJ6ICA1FkNvVcJ6nOsj2+Gf8LkkO0DUP23Ibk6wuUt9xJY4e
         VTB5UknW9uR0A==
Received: from [IPv6:2001:558:6040:22:2171:426f:b27e:296d] ([IPv6:2001:558:6040:22:2171:426f:b27e:296d])
        by resomta-ch2-04v.sys.comcast.net with ESMTPSA
        id j5GUhnmjdSfLWj5GUhrGPW; Thu, 04 Jul 2019 17:11:23 +0000
X-Xfinity-VMeta: sc=0;st=legit
From:   James Feeney <james@nurealm.net>
Subject: "local" interfaces, in forwarding state, are mutually "blind", and
 fail to connect
Reply-To: james@nurealm.net
To:     netdev@vger.kernel.org
Message-ID: <a56eee49-49dc-1e61-19a4-6dfb6bd66f3e@nurealm.net>
Date:   Thu, 4 Jul 2019 11:11:21 -0600
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101
 Thunderbird/60.7.2
MIME-Version: 1.0
Content-Type: text/plain; charset=utf-8
Content-Language: en-US
Content-Transfer-Encoding: 7bit
Sender: netdev-owner@vger.kernel.org
Precedence: bulk
List-ID: <netdev.vger.kernel.org>
X-Mailing-List: netdev@vger.kernel.org

I have a question - maybe someone can point me in the right direction?

When there exist two or more "local" interfaces on the "host" system, where sysctl "net.ipv4.conf.<blah>.forwarding=1" has been set, and where each interface has an IP address on a different subnet, then, when a frame arrives at an interface, and is addressed to an IP address on some other "local" interface, that frame is never actually delivered to this other "local" interface, but instead, is "looped-back" at the connected "local" interface, and given a *fake* "source" IP address, as if the response had actually been generated by the other "local" interface.

When the incoming frame is of an ICMP echo request, and the outgoing response is an ICMP echo reply, this "fake source address" behavior seems to be of no consequence, except that an interface in a "down" state will still respond to ping.  Parenthetically, then, what is the definition of the "down" state?

However, when the incoming request is, as an example, a domain query, addressed to the IP address of the daemon, and the domain daemon is only binding to the *other* "local" interface, then the domain request is never delivered to this other "local" interface, the one actually addressed, and the frame is never received by the daemon.  The request fails, and there is no response.

At first glance this kernel behavior seems "broken".  Should the frame not *actually* be delivered to this *other* "local" interface?  Why should this "local"/"internal" packet routing fail?  Is that "on purpose"?

Now, the simplest solution to the problem is to just have the daemon also bind to all of whichever "local" interfaces are meant to receive these domain requests, in this example.  But still, I am wondering if this failure to actually deliver the frame, to the *other* "local" interface, that was actually addressed, is not some kind of improper behavior.

And then, a "follow-up" question, is there some otherwise simplistic manual reconfiguration of the kernel routing tables that would achieve the kind of behavior I would naively expect, that the incoming frame from one "local" interface would actually be delivered to the *other* "local" interface, that was *actually* addressed, so that the domain daemon, in this example, would be able to respond to the request, even when that daemon were only "listening" on the *other* "local" interface, the one addressed?  And, without using a bridge interface, bridging these separate "local" interfaces, intended to be on different subnets?

Thanks
James
