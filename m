Return-Path: <netdev-owner@vger.kernel.org>
X-Original-To: lists+netdev@lfdr.de
Delivered-To: lists+netdev@lfdr.de
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.lfdr.de (Postfix) with ESMTP id 086EF12236F
	for <lists+netdev@lfdr.de>; Tue, 17 Dec 2019 06:12:38 +0100 (CET)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727241AbfLQFM3 (ORCPT <rfc822;lists+netdev@lfdr.de>);
        Tue, 17 Dec 2019 00:12:29 -0500
Received: from mxout2.idt.com ([157.165.5.26]:54554 "EHLO mxout2.idt.com"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
        id S1726920AbfLQFM0 (ORCPT <rfc822;netdev@vger.kernel.org>);
        Tue, 17 Dec 2019 00:12:26 -0500
X-Greylist: delayed 540 seconds by postgrey-1.27 at vger.kernel.org; Tue, 17 Dec 2019 00:12:21 EST
Received: from mail3.idt.com (localhost [127.0.0.1])
        by mxout2.idt.com (8.14.4/8.14.4) with ESMTP id xBH53GXn031489;
        Mon, 16 Dec 2019 21:03:16 -0800
Received: from corpml1.corp.idt.com (corpml1.corp.idt.com [157.165.140.20])
        by mail3.idt.com (8.14.4/8.14.4) with ESMTP id xBH53GQZ026487;
        Mon, 16 Dec 2019 21:03:16 -0800
Received: from vcheng-VirtualBox.localdomain (corpimss2.corp.idt.com [157.165.141.30])
        by corpml1.corp.idt.com (8.11.7p1+Sun/8.11.7) with ESMTP id xBH53EV16989;
        Mon, 16 Dec 2019 21:03:14 -0800 (PST)
From:   vincent.cheng.xh@renesas.com
To:     robh+dt@kernel.org, mark.rutland@arm.com, richardcochran@gmail.com
Cc:     devicetree@vger.kernel.org, netdev@vger.kernel.org,
        linux-kernel@vger.kernel.org,
        Vincent Cheng <vincent.cheng.xh@renesas.com>
Subject: [PATCH net-next 2/3] ptp: clockmatrix: Remove IDT references or replace with Renesas.
Date:   Tue, 17 Dec 2019 00:03:07 -0500
Message-Id: <1576558988-20837-3-git-send-email-vincent.cheng.xh@renesas.com>
X-Mailer: git-send-email 2.7.4
In-Reply-To: <1576558988-20837-1-git-send-email-vincent.cheng.xh@renesas.com>
References: <1576558988-20837-1-git-send-email-vincent.cheng.xh@renesas.com>
X-TM-AS-MML: disable
Sender: netdev-owner@vger.kernel.org
Precedence: bulk
List-ID: <netdev.vger.kernel.org>
X-Mailing-List: netdev@vger.kernel.org

From: Vincent Cheng <vincent.cheng.xh@renesas.com>

Renesas Electronics Corporation completed acquisition of IDT in 2019.

This patch removes IDT references or replaces IDT with Renesas.
Renamed idt8a340_reg.h to clockmatrix_reg.h.
There were no functional changes.

Signed-off-by: Vincent Cheng <vincent.cheng.xh@renesas.com>
---
 drivers/ptp/Kconfig           |   6 +-
 drivers/ptp/Makefile          |   2 +-
 drivers/ptp/clockmatrix_reg.h | 661 ++++++++++++++++++++++++++++++++++++++++++
 drivers/ptp/idt8a340_reg.h    | 659 -----------------------------------------
 drivers/ptp/ptp_clockmatrix.c | 652 ++++++++++++++++++++---------------------
 drivers/ptp/ptp_clockmatrix.h |  28 +-
 6 files changed, 997 insertions(+), 1011 deletions(-)
 create mode 100644 drivers/ptp/clockmatrix_reg.h
 delete mode 100644 drivers/ptp/idt8a340_reg.h

diff --git a/drivers/ptp/Kconfig b/drivers/ptp/Kconfig
index b0d1b8d..865a8a4 100644
--- a/drivers/ptp/Kconfig
+++ b/drivers/ptp/Kconfig
@@ -119,12 +119,12 @@ config PTP_1588_CLOCK_KVM
 	  To compile this driver as a module, choose M here: the module
 	  will be called ptp_kvm.
 
-config PTP_1588_CLOCK_IDTCM
-	tristate "IDT CLOCKMATRIX as PTP clock"
+config PTP_1588_CLOCK_CM
+	tristate "Renesas CLOCKMATRIX as PTP clock"
 	depends on PTP_1588_CLOCK && I2C
 	default n
 	help
-	  This driver adds support for using IDT CLOCKMATRIX(TM) as a PTP
+	  This driver adds support for using Renesas CLOCKMATRIX(TM) as a PTP
 	  clock. This clock is only useful if your time stamping MAC
 	  is connected to the IDT chip.
 
diff --git a/drivers/ptp/Makefile b/drivers/ptp/Makefile
index 69a06f8..cfe1ea9 100644
--- a/drivers/ptp/Makefile
+++ b/drivers/ptp/Makefile
@@ -12,4 +12,4 @@ obj-$(CONFIG_PTP_1588_CLOCK_KVM)	+= ptp_kvm.o
 obj-$(CONFIG_PTP_1588_CLOCK_QORIQ)	+= ptp-qoriq.o
 ptp-qoriq-y				+= ptp_qoriq.o
 ptp-qoriq-$(CONFIG_DEBUG_FS)		+= ptp_qoriq_debugfs.o
-obj-$(CONFIG_PTP_1588_CLOCK_IDTCM)	+= ptp_clockmatrix.o
\ No newline at end of file
+obj-$(CONFIG_PTP_1588_CLOCK_CM)		+= ptp_clockmatrix.o
diff --git a/drivers/ptp/clockmatrix_reg.h b/drivers/ptp/clockmatrix_reg.h
new file mode 100644
index 0000000..0f4195c
--- /dev/null
+++ b/drivers/ptp/clockmatrix_reg.h
@@ -0,0 +1,661 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/* clockmatrix_reg.h
+ *
+ * Originally generated by regen.tcl on Thu Feb 14 19:23:44 PST 2019
+ * https://github.com/richardcochran/regen
+ *
+ * Hand modified to include some HW registers.
+ * Based on 4.8.0, SCSR rev C commit a03c7ae5
+ */
+#ifndef HAVE_CLOCKMATRIX_REG
+#define HAVE_CLOCKMATRIX_REG
+
+#define PAGE_ADDR_BASE                    0x0000
+#define PAGE_ADDR                         0x00fc
+
+#define HW_REVISION                       0x8180
+#define REV_ID                            0x007a
+
+#define HW_DPLL_0                         (0x8a00)
+#define HW_DPLL_1                         (0x8b00)
+#define HW_DPLL_2                         (0x8c00)
+#define HW_DPLL_3                         (0x8d00)
+
+#define HW_DPLL_TOD_SW_TRIG_ADDR__0       (0x080)
+#define HW_DPLL_TOD_CTRL_1                (0x089)
+#define HW_DPLL_TOD_CTRL_2                (0x08A)
+#define HW_DPLL_TOD_OVR__0                (0x098)
+#define HW_DPLL_TOD_OUT_0__0              (0x0B0)
+
+#define HW_Q0_Q1_CH_SYNC_CTRL_0           (0xa740)
+#define HW_Q0_Q1_CH_SYNC_CTRL_1           (0xa741)
+#define HW_Q2_Q3_CH_SYNC_CTRL_0           (0xa742)
+#define HW_Q2_Q3_CH_SYNC_CTRL_1           (0xa743)
+#define HW_Q4_Q5_CH_SYNC_CTRL_0           (0xa744)
+#define HW_Q4_Q5_CH_SYNC_CTRL_1           (0xa745)
+#define HW_Q6_Q7_CH_SYNC_CTRL_0           (0xa746)
+#define HW_Q6_Q7_CH_SYNC_CTRL_1           (0xa747)
+#define HW_Q8_CH_SYNC_CTRL_0              (0xa748)
+#define HW_Q8_CH_SYNC_CTRL_1              (0xa749)
+#define HW_Q9_CH_SYNC_CTRL_0              (0xa74a)
+#define HW_Q9_CH_SYNC_CTRL_1              (0xa74b)
+#define HW_Q10_CH_SYNC_CTRL_0             (0xa74c)
+#define HW_Q10_CH_SYNC_CTRL_1             (0xa74d)
+#define HW_Q11_CH_SYNC_CTRL_0             (0xa74e)
+#define HW_Q11_CH_SYNC_CTRL_1             (0xa74f)
+
+#define SYNC_SOURCE_DPLL0_TOD_PPS	0x14
+#define SYNC_SOURCE_DPLL1_TOD_PPS	0x15
+#define SYNC_SOURCE_DPLL2_TOD_PPS	0x16
+#define SYNC_SOURCE_DPLL3_TOD_PPS	0x17
+
+#define SYNCTRL1_MASTER_SYNC_RST	BIT(7)
+#define SYNCTRL1_MASTER_SYNC_TRIG	BIT(5)
+#define SYNCTRL1_TOD_SYNC_TRIG		BIT(4)
+#define SYNCTRL1_FBDIV_FRAME_SYNC_TRIG	BIT(3)
+#define SYNCTRL1_FBDIV_SYNC_TRIG	BIT(2)
+#define SYNCTRL1_Q1_DIV_SYNC_TRIG	BIT(1)
+#define SYNCTRL1_Q0_DIV_SYNC_TRIG	BIT(0)
+
+#define RESET_CTRL                        0xc000
+#define SM_RESET                          0x0012
+#define SM_RESET_CMD                      0x5A
+
+#define GENERAL_STATUS                    0xc014
+#define HW_REV_ID                         0x000A
+#define BOND_ID                           0x000B
+#define HW_CSR_ID                         0x000C
+#define HW_IRQ_ID                         0x000E
+
+#define MAJ_REL                           0x0010
+#define MIN_REL                           0x0011
+#define HOTFIX_REL                        0x0012
+
+#define PIPELINE_ID                       0x0014
+#define BUILD_ID                          0x0018
+
+#define JTAG_DEVICE_ID                    0x001c
+#define PRODUCT_ID                        0x001e
+
+#define OTP_SCSR_CONFIG_SELECT            0x0022
+
+#define STATUS                            0xc03c
+#define USER_GPIO0_TO_7_STATUS            0x008a
+#define USER_GPIO8_TO_15_STATUS           0x008b
+
+#define GPIO_USER_CONTROL                 0xc160
+#define GPIO0_TO_7_OUT                    0x0000
+#define GPIO8_TO_15_OUT                   0x0001
+
+#define STICKY_STATUS_CLEAR               0xc164
+
+#define GPIO_TOD_NOTIFICATION_CLEAR       0xc16c
+
+#define ALERT_CFG                         0xc188
+
+#define SYS_DPLL_XO                       0xc194
+
+#define SYS_APLL                          0xc19c
+
+#define INPUT_0                           0xc1b0
+
+#define INPUT_1                           0xc1c0
+
+#define INPUT_2                           0xc1d0
+
+#define INPUT_3                           0xc200
+
+#define INPUT_4                           0xc210
+
+#define INPUT_5                           0xc220
+
+#define INPUT_6                           0xc230
+
+#define INPUT_7                           0xc240
+
+#define INPUT_8                           0xc250
+
+#define INPUT_9                           0xc260
+
+#define INPUT_10                          0xc280
+
+#define INPUT_11                          0xc290
+
+#define INPUT_12                          0xc2a0
+
+#define INPUT_13                          0xc2b0
+
+#define INPUT_14                          0xc2c0
+
+#define INPUT_15                          0xc2d0
+
+#define REF_MON_0                         0xc2e0
+
+#define REF_MON_1                         0xc2ec
+
+#define REF_MON_2                         0xc300
+
+#define REF_MON_3                         0xc30c
+
+#define REF_MON_4                         0xc318
+
+#define REF_MON_5                         0xc324
+
+#define REF_MON_6                         0xc330
+
+#define REF_MON_7                         0xc33c
+
+#define REF_MON_8                         0xc348
+
+#define REF_MON_9                         0xc354
+
+#define REF_MON_10                        0xc360
+
+#define REF_MON_11                        0xc36c
+
+#define REF_MON_12                        0xc380
+
+#define REF_MON_13                        0xc38c
+
+#define REF_MON_14                        0xc398
+
+#define REF_MON_15                        0xc3a4
+
+#define DPLL_0                            0xc3b0
+#define DPLL_CTRL_REG_0                   0x0002
+#define DPLL_CTRL_REG_1                   0x0003
+#define DPLL_CTRL_REG_2                   0x0004
+#define DPLL_TOD_SYNC_CFG                 0x0031
+#define DPLL_COMBO_SLAVE_CFG_0            0x0032
+#define DPLL_COMBO_SLAVE_CFG_1            0x0033
+#define DPLL_SLAVE_REF_CFG                0x0034
+#define DPLL_REF_MODE                     0x0035
+#define DPLL_PHASE_MEASUREMENT_CFG        0x0036
+#define DPLL_MODE                         0x0037
+
+#define DPLL_1                            0xc400
+
+#define DPLL_2                            0xc438
+
+#define DPLL_3                            0xc480
+
+#define DPLL_4                            0xc4b8
+
+#define DPLL_5                            0xc500
+
+#define DPLL_6                            0xc538
+
+#define DPLL_7                            0xc580
+
+#define SYS_DPLL                          0xc5b8
+
+#define DPLL_CTRL_0                       0xc600
+#define DPLL_CTRL_DPLL_MANU_REF_CFG       0x0001
+
+#define DPLL_CTRL_1                       0xc63c
+
+#define DPLL_CTRL_2                       0xc680
+
+#define DPLL_CTRL_3                       0xc6bc
+
+#define DPLL_CTRL_4                       0xc700
+
+#define DPLL_CTRL_5                       0xc73c
+
+#define DPLL_CTRL_6                       0xc780
+
+#define DPLL_CTRL_7                       0xc7bc
+
+#define SYS_DPLL_CTRL                     0xc800
+
+#define DPLL_PHASE_0                      0xc818
+
+/* Signed 42-bit FFO in units of 2^(-53) */
+#define DPLL_WR_PHASE                     0x0000
+
+#define DPLL_PHASE_1                      0xc81c
+
+#define DPLL_PHASE_2                      0xc820
+
+#define DPLL_PHASE_3                      0xc824
+
+#define DPLL_PHASE_4                      0xc828
+
+#define DPLL_PHASE_5                      0xc82c
+
+#define DPLL_PHASE_6                      0xc830
+
+#define DPLL_PHASE_7                      0xc834
+
+#define DPLL_FREQ_0                       0xc838
+
+/* Signed 42-bit FFO in units of 2^(-53) */
+#define DPLL_WR_FREQ                      0x0000
+
+#define DPLL_FREQ_1                       0xc840
+
+#define DPLL_FREQ_2                       0xc848
+
+#define DPLL_FREQ_3                       0xc850
+
+#define DPLL_FREQ_4                       0xc858
+
+#define DPLL_FREQ_5                       0xc860
+
+#define DPLL_FREQ_6                       0xc868
+
+#define DPLL_FREQ_7                       0xc870
+
+#define DPLL_PHASE_PULL_IN_0              0xc880
+#define PULL_IN_OFFSET                    0x0000 /* Signed 32 bit */
+#define PULL_IN_SLOPE_LIMIT               0x0004 /* Unsigned 24 bit */
+#define PULL_IN_CTRL                      0x0007
+
+#define DPLL_PHASE_PULL_IN_1              0xc888
+
+#define DPLL_PHASE_PULL_IN_2              0xc890
+
+#define DPLL_PHASE_PULL_IN_3              0xc898
+
+#define DPLL_PHASE_PULL_IN_4              0xc8a0
+
+#define DPLL_PHASE_PULL_IN_5              0xc8a8
+
+#define DPLL_PHASE_PULL_IN_6              0xc8b0
+
+#define DPLL_PHASE_PULL_IN_7              0xc8b8
+
+#define GPIO_CFG                          0xc8c0
+#define GPIO_CFG_GBL                      0x0000
+
+#define GPIO_0                            0xc8c2
+#define GPIO_DCO_INC_DEC                  0x0000
+#define GPIO_OUT_CTRL_0                   0x0001
+#define GPIO_OUT_CTRL_1                   0x0002
+#define GPIO_TOD_TRIG                     0x0003
+#define GPIO_DPLL_INDICATOR               0x0004
+#define GPIO_LOS_INDICATOR                0x0005
+#define GPIO_REF_INPUT_DSQ_0              0x0006
+#define GPIO_REF_INPUT_DSQ_1              0x0007
+#define GPIO_REF_INPUT_DSQ_2              0x0008
+#define GPIO_REF_INPUT_DSQ_3              0x0009
+#define GPIO_MAN_CLK_SEL_0                0x000a
+#define GPIO_MAN_CLK_SEL_1                0x000b
+#define GPIO_MAN_CLK_SEL_2                0x000c
+#define GPIO_SLAVE                        0x000d
+#define GPIO_ALERT_OUT_CFG                0x000e
+#define GPIO_TOD_NOTIFICATION_CFG         0x000f
+#define GPIO_CTRL                         0x0010
+
+#define GPIO_1                            0xc8d4
+
+#define GPIO_2                            0xc8e6
+
+#define GPIO_3                            0xc900
+
+#define GPIO_4                            0xc912
+
+#define GPIO_5                            0xc924
+
+#define GPIO_6                            0xc936
+
+#define GPIO_7                            0xc948
+
+#define GPIO_8                            0xc95a
+
+#define GPIO_9                            0xc980
+
+#define GPIO_10                           0xc992
+
+#define GPIO_11                           0xc9a4
+
+#define GPIO_12                           0xc9b6
+
+#define GPIO_13                           0xc9c8
+
+#define GPIO_14                           0xc9da
+
+#define GPIO_15                           0xca00
+
+#define OUT_DIV_MUX                       0xca12
+
+#define OUTPUT_0                          0xca14
+/* FOD frequency output divider value */
+#define OUT_DIV                           0x0000
+#define OUT_DUTY_CYCLE_HIGH               0x0004
+#define OUT_CTRL_0                        0x0008
+#define OUT_CTRL_1                        0x0009
+/* Phase adjustment in FOD cycles */
+#define OUT_PHASE_ADJ                     0x000c
+
+#define OUTPUT_1                          0xca24
+
+#define OUTPUT_2                          0xca34
+
+#define OUTPUT_3                          0xca44
+
+#define OUTPUT_4                          0xca54
+
+#define OUTPUT_5                          0xca64
+
+#define OUTPUT_6                          0xca80
+
+#define OUTPUT_7                          0xca90
+
+#define OUTPUT_8                          0xcaa0
+
+#define OUTPUT_9                          0xcab0
+
+#define OUTPUT_10                         0xcac0
+
+#define OUTPUT_11                         0xcad0
+
+#define SERIAL                            0xcae0
+
+#define PWM_ENCODER_0                     0xcb00
+
+#define PWM_ENCODER_1                     0xcb08
+
+#define PWM_ENCODER_2                     0xcb10
+
+#define PWM_ENCODER_3                     0xcb18
+
+#define PWM_ENCODER_4                     0xcb20
+
+#define PWM_ENCODER_5                     0xcb28
+
+#define PWM_ENCODER_6                     0xcb30
+
+#define PWM_ENCODER_7                     0xcb38
+
+#define PWM_DECODER_0                     0xcb40
+
+#define PWM_DECODER_1                     0xcb48
+
+#define PWM_DECODER_2                     0xcb50
+
+#define PWM_DECODER_3                     0xcb58
+
+#define PWM_DECODER_4                     0xcb60
+
+#define PWM_DECODER_5                     0xcb68
+
+#define PWM_DECODER_6                     0xcb70
+
+#define PWM_DECODER_7                     0xcb80
+
+#define PWM_DECODER_8                     0xcb88
+
+#define PWM_DECODER_9                     0xcb90
+
+#define PWM_DECODER_10                    0xcb98
+
+#define PWM_DECODER_11                    0xcba0
+
+#define PWM_DECODER_12                    0xcba8
+
+#define PWM_DECODER_13                    0xcbb0
+
+#define PWM_DECODER_14                    0xcbb8
+
+#define PWM_DECODER_15                    0xcbc0
+
+#define PWM_USER_DATA                     0xcbc8
+
+#define TOD_0                             0xcbcc
+
+/* Enable TOD counter, output channel sync and even-PPS mode */
+#define TOD_CFG                           0x0000
+
+#define TOD_1                             0xcbce
+
+#define TOD_2                             0xcbd0
+
+#define TOD_3                             0xcbd2
+
+
+#define TOD_WRITE_0                       0xcc00
+/* 8-bit subns, 32-bit ns, 48-bit seconds */
+#define TOD_WRITE                         0x0000
+/* Counter increments after TOD write is completed */
+#define TOD_WRITE_COUNTER                 0x000c
+/* TOD write trigger configuration */
+#define TOD_WRITE_SELECT_CFG_0            0x000d
+/* TOD write trigger selection */
+#define TOD_WRITE_CMD                     0x000f
+
+#define TOD_WRITE_1                       0xcc10
+
+#define TOD_WRITE_2                       0xcc20
+
+#define TOD_WRITE_3                       0xcc30
+
+#define TOD_READ_PRIMARY_0                0xcc40
+/* 8-bit subns, 32-bit ns, 48-bit seconds */
+#define TOD_READ_PRIMARY                  0x0000
+/* Counter increments after TOD write is completed */
+#define TOD_READ_PRIMARY_COUNTER          0x000b
+/* Read trigger configuration */
+#define TOD_READ_PRIMARY_SEL_CFG_0        0x000c
+/* Read trigger selection */
+#define TOD_READ_PRIMARY_CMD              0x000e
+
+#define TOD_READ_PRIMARY_1                0xcc50
+
+#define TOD_READ_PRIMARY_2                0xcc60
+
+#define TOD_READ_PRIMARY_3                0xcc80
+
+#define TOD_READ_SECONDARY_0              0xcc90
+
+#define TOD_READ_SECONDARY_1              0xcca0
+
+#define TOD_READ_SECONDARY_2              0xccb0
+
+#define TOD_READ_SECONDARY_3              0xccc0
+
+#define OUTPUT_TDC_CFG                    0xccd0
+
+#define OUTPUT_TDC_0                      0xcd00
+
+#define OUTPUT_TDC_1                      0xcd08
+
+#define OUTPUT_TDC_2                      0xcd10
+
+#define OUTPUT_TDC_3                      0xcd18
+
+#define INPUT_TDC                         0xcd20
+
+#define SCRATCH                           0xcf50
+
+#define EEPROM                            0xcf68
+
+#define OTP                               0xcf70
+
+#define BYTE                              0xcf80
+
+/* Bit definitions for the MAJ_REL register */
+#define MAJOR_SHIFT                       (1)
+#define MAJOR_MASK                        (0x7f)
+#define PR_BUILD                          BIT(0)
+
+/* Bit definitions for the USER_GPIO0_TO_7_STATUS register */
+#define GPIO0_LEVEL                       BIT(0)
+#define GPIO1_LEVEL                       BIT(1)
+#define GPIO2_LEVEL                       BIT(2)
+#define GPIO3_LEVEL                       BIT(3)
+#define GPIO4_LEVEL                       BIT(4)
+#define GPIO5_LEVEL                       BIT(5)
+#define GPIO6_LEVEL                       BIT(6)
+#define GPIO7_LEVEL                       BIT(7)
+
+/* Bit definitions for the USER_GPIO8_TO_15_STATUS register */
+#define GPIO8_LEVEL                       BIT(0)
+#define GPIO9_LEVEL                       BIT(1)
+#define GPIO10_LEVEL                      BIT(2)
+#define GPIO11_LEVEL                      BIT(3)
+#define GPIO12_LEVEL                      BIT(4)
+#define GPIO13_LEVEL                      BIT(5)
+#define GPIO14_LEVEL                      BIT(6)
+#define GPIO15_LEVEL                      BIT(7)
+
+/* Bit definitions for the GPIO0_TO_7_OUT register */
+#define GPIO0_DRIVE_LEVEL                 BIT(0)
+#define GPIO1_DRIVE_LEVEL                 BIT(1)
+#define GPIO2_DRIVE_LEVEL                 BIT(2)
+#define GPIO3_DRIVE_LEVEL                 BIT(3)
+#define GPIO4_DRIVE_LEVEL                 BIT(4)
+#define GPIO5_DRIVE_LEVEL                 BIT(5)
+#define GPIO6_DRIVE_LEVEL                 BIT(6)
+#define GPIO7_DRIVE_LEVEL                 BIT(7)
+
+/* Bit definitions for the GPIO8_TO_15_OUT register */
+#define GPIO8_DRIVE_LEVEL                 BIT(0)
+#define GPIO9_DRIVE_LEVEL                 BIT(1)
+#define GPIO10_DRIVE_LEVEL                BIT(2)
+#define GPIO11_DRIVE_LEVEL                BIT(3)
+#define GPIO12_DRIVE_LEVEL                BIT(4)
+#define GPIO13_DRIVE_LEVEL                BIT(5)
+#define GPIO14_DRIVE_LEVEL                BIT(6)
+#define GPIO15_DRIVE_LEVEL                BIT(7)
+
+/* Bit definitions for the DPLL_TOD_SYNC_CFG register */
+#define TOD_SYNC_SOURCE_SHIFT             (1)
+#define TOD_SYNC_SOURCE_MASK              (0x3)
+#define TOD_SYNC_EN                       BIT(0)
+
+/* Bit definitions for the DPLL_MODE register */
+#define WRITE_TIMER_MODE                  BIT(6)
+#define PLL_MODE_SHIFT                    (3)
+#define PLL_MODE_MASK                     (0x7)
+#define STATE_MODE_SHIFT                  (0)
+#define STATE_MODE_MASK                   (0x7)
+
+/* Bit definitions for the GPIO_CFG_GBL register */
+#define SUPPLY_MODE_SHIFT                 (0)
+#define SUPPLY_MODE_MASK                  (0x3)
+
+/* Bit definitions for the GPIO_DCO_INC_DEC register */
+#define INCDEC_DPLL_INDEX_SHIFT           (0)
+#define INCDEC_DPLL_INDEX_MASK            (0x7)
+
+/* Bit definitions for the GPIO_OUT_CTRL_0 register */
+#define CTRL_OUT_0                        BIT(0)
+#define CTRL_OUT_1                        BIT(1)
+#define CTRL_OUT_2                        BIT(2)
+#define CTRL_OUT_3                        BIT(3)
+#define CTRL_OUT_4                        BIT(4)
+#define CTRL_OUT_5                        BIT(5)
+#define CTRL_OUT_6                        BIT(6)
+#define CTRL_OUT_7                        BIT(7)
+
+/* Bit definitions for the GPIO_OUT_CTRL_1 register */
+#define CTRL_OUT_8                        BIT(0)
+#define CTRL_OUT_9                        BIT(1)
+#define CTRL_OUT_10                       BIT(2)
+#define CTRL_OUT_11                       BIT(3)
+#define CTRL_OUT_12                       BIT(4)
+#define CTRL_OUT_13                       BIT(5)
+#define CTRL_OUT_14                       BIT(6)
+#define CTRL_OUT_15                       BIT(7)
+
+/* Bit definitions for the GPIO_TOD_TRIG register */
+#define TOD_TRIG_0                        BIT(0)
+#define TOD_TRIG_1                        BIT(1)
+#define TOD_TRIG_2                        BIT(2)
+#define TOD_TRIG_3                        BIT(3)
+
+/* Bit definitions for the GPIO_DPLL_INDICATOR register */
+#define IND_DPLL_INDEX_SHIFT              (0)
+#define IND_DPLL_INDEX_MASK               (0x7)
+
+/* Bit definitions for the GPIO_LOS_INDICATOR register */
+#define REFMON_INDEX_SHIFT                (0)
+#define REFMON_INDEX_MASK                 (0xf)
+/* Active level of LOS indicator, 0=low 1=high */
+#define ACTIVE_LEVEL                      BIT(4)
+
+/* Bit definitions for the GPIO_REF_INPUT_DSQ_0 register */
+#define DSQ_INP_0                         BIT(0)
+#define DSQ_INP_1                         BIT(1)
+#define DSQ_INP_2                         BIT(2)
+#define DSQ_INP_3                         BIT(3)
+#define DSQ_INP_4                         BIT(4)
+#define DSQ_INP_5                         BIT(5)
+#define DSQ_INP_6                         BIT(6)
+#define DSQ_INP_7                         BIT(7)
+
+/* Bit definitions for the GPIO_REF_INPUT_DSQ_1 register */
+#define DSQ_INP_8                         BIT(0)
+#define DSQ_INP_9                         BIT(1)
+#define DSQ_INP_10                        BIT(2)
+#define DSQ_INP_11                        BIT(3)
+#define DSQ_INP_12                        BIT(4)
+#define DSQ_INP_13                        BIT(5)
+#define DSQ_INP_14                        BIT(6)
+#define DSQ_INP_15                        BIT(7)
+
+/* Bit definitions for the GPIO_REF_INPUT_DSQ_2 register */
+#define DSQ_DPLL_0                        BIT(0)
+#define DSQ_DPLL_1                        BIT(1)
+#define DSQ_DPLL_2                        BIT(2)
+#define DSQ_DPLL_3                        BIT(3)
+#define DSQ_DPLL_4                        BIT(4)
+#define DSQ_DPLL_5                        BIT(5)
+#define DSQ_DPLL_6                        BIT(6)
+#define DSQ_DPLL_7                        BIT(7)
+
+/* Bit definitions for the GPIO_REF_INPUT_DSQ_3 register */
+#define DSQ_DPLL_SYS                      BIT(0)
+#define GPIO_DSQ_LEVEL                    BIT(1)
+
+/* Bit definitions for the GPIO_TOD_NOTIFICATION_CFG register */
+#define DPLL_TOD_SHIFT                    (0)
+#define DPLL_TOD_MASK                     (0x3)
+#define TOD_READ_SECONDARY                BIT(2)
+#define GPIO_ASSERT_LEVEL                 BIT(3)
+
+/* Bit definitions for the GPIO_CTRL register */
+#define GPIO_FUNCTION_EN                  BIT(0)
+#define GPIO_CMOS_OD_MODE                 BIT(1)
+#define GPIO_CONTROL_DIR                  BIT(2)
+#define GPIO_PU_PD_MODE                   BIT(3)
+#define GPIO_FUNCTION_SHIFT               (4)
+#define GPIO_FUNCTION_MASK                (0xf)
+
+/* Bit definitions for the OUT_CTRL_1 register */
+#define OUT_SYNC_DISABLE                  BIT(7)
+#define SQUELCH_VALUE                     BIT(6)
+#define SQUELCH_DISABLE                   BIT(5)
+#define PAD_VDDO_SHIFT                    (2)
+#define PAD_VDDO_MASK                     (0x7)
+#define PAD_CMOSDRV_SHIFT                 (0)
+#define PAD_CMOSDRV_MASK                  (0x3)
+
+/* Bit definitions for the TOD_CFG register */
+#define TOD_EVEN_PPS_MODE                 BIT(2)
+#define TOD_OUT_SYNC_ENABLE               BIT(1)
+#define TOD_ENABLE                        BIT(0)
+
+/* Bit definitions for the TOD_WRITE_SELECT_CFG_0 register */
+#define WR_PWM_DECODER_INDEX_SHIFT        (4)
+#define WR_PWM_DECODER_INDEX_MASK         (0xf)
+#define WR_REF_INDEX_SHIFT                (0)
+#define WR_REF_INDEX_MASK                 (0xf)
+
+/* Bit definitions for the TOD_WRITE_CMD register */
+#define TOD_WRITE_SELECTION_SHIFT         (0)
+#define TOD_WRITE_SELECTION_MASK          (0xf)
+
+/* Bit definitions for the TOD_READ_PRIMARY_SEL_CFG_0 register */
+#define RD_PWM_DECODER_INDEX_SHIFT        (4)
+#define RD_PWM_DECODER_INDEX_MASK         (0xf)
+#define RD_REF_INDEX_SHIFT                (0)
+#define RD_REF_INDEX_MASK                 (0xf)
+
+/* Bit definitions for the TOD_READ_PRIMARY_CMD register */
+#define TOD_READ_TRIGGER_MODE             BIT(4)
+#define TOD_READ_TRIGGER_SHIFT            (0)
+#define TOD_READ_TRIGGER_MASK             (0xf)
+
+#endif
diff --git a/drivers/ptp/idt8a340_reg.h b/drivers/ptp/idt8a340_reg.h
deleted file mode 100644
index 9263bc3..0000000
--- a/drivers/ptp/idt8a340_reg.h
+++ /dev/null
@@ -1,659 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/* idt8a340_reg.h
- *
- * Originally generated by regen.tcl on Thu Feb 14 19:23:44 PST 2019
- * https://github.com/richardcochran/regen
- *
- * Hand modified to include some HW registers.
- * Based on 4.8.0, SCSR rev C commit a03c7ae5
- */
-#ifndef HAVE_IDT8A340_REG
-#define HAVE_IDT8A340_REG
-
-#define PAGE_ADDR_BASE                    0x0000
-#define PAGE_ADDR                         0x00fc
-
-#define HW_REVISION                       0x8180
-#define REV_ID                            0x007a
-
-#define HW_DPLL_0                         (0x8a00)
-#define HW_DPLL_1                         (0x8b00)
-#define HW_DPLL_2                         (0x8c00)
-#define HW_DPLL_3                         (0x8d00)
-
-#define HW_DPLL_TOD_SW_TRIG_ADDR__0       (0x080)
-#define HW_DPLL_TOD_CTRL_1                (0x089)
-#define HW_DPLL_TOD_CTRL_2                (0x08A)
-#define HW_DPLL_TOD_OVR__0                (0x098)
-#define HW_DPLL_TOD_OUT_0__0              (0x0B0)
-
-#define HW_Q0_Q1_CH_SYNC_CTRL_0           (0xa740)
-#define HW_Q0_Q1_CH_SYNC_CTRL_1           (0xa741)
-#define HW_Q2_Q3_CH_SYNC_CTRL_0           (0xa742)
-#define HW_Q2_Q3_CH_SYNC_CTRL_1           (0xa743)
-#define HW_Q4_Q5_CH_SYNC_CTRL_0           (0xa744)
-#define HW_Q4_Q5_CH_SYNC_CTRL_1           (0xa745)
-#define HW_Q6_Q7_CH_SYNC_CTRL_0           (0xa746)
-#define HW_Q6_Q7_CH_SYNC_CTRL_1           (0xa747)
-#define HW_Q8_CH_SYNC_CTRL_0              (0xa748)
-#define HW_Q8_CH_SYNC_CTRL_1              (0xa749)
-#define HW_Q9_CH_SYNC_CTRL_0              (0xa74a)
-#define HW_Q9_CH_SYNC_CTRL_1              (0xa74b)
-#define HW_Q10_CH_SYNC_CTRL_0             (0xa74c)
-#define HW_Q10_CH_SYNC_CTRL_1             (0xa74d)
-#define HW_Q11_CH_SYNC_CTRL_0             (0xa74e)
-#define HW_Q11_CH_SYNC_CTRL_1             (0xa74f)
-
-#define SYNC_SOURCE_DPLL0_TOD_PPS	0x14
-#define SYNC_SOURCE_DPLL1_TOD_PPS	0x15
-#define SYNC_SOURCE_DPLL2_TOD_PPS	0x16
-#define SYNC_SOURCE_DPLL3_TOD_PPS	0x17
-
-#define SYNCTRL1_MASTER_SYNC_RST	BIT(7)
-#define SYNCTRL1_MASTER_SYNC_TRIG	BIT(5)
-#define SYNCTRL1_TOD_SYNC_TRIG		BIT(4)
-#define SYNCTRL1_FBDIV_FRAME_SYNC_TRIG	BIT(3)
-#define SYNCTRL1_FBDIV_SYNC_TRIG	BIT(2)
-#define SYNCTRL1_Q1_DIV_SYNC_TRIG	BIT(1)
-#define SYNCTRL1_Q0_DIV_SYNC_TRIG	BIT(0)
-
-#define RESET_CTRL                        0xc000
-#define SM_RESET                          0x0012
-#define SM_RESET_CMD                      0x5A
-
-#define GENERAL_STATUS                    0xc014
-#define HW_REV_ID                         0x000A
-#define BOND_ID                           0x000B
-#define HW_CSR_ID                         0x000C
-#define HW_IRQ_ID                         0x000E
-
-#define MAJ_REL                           0x0010
-#define MIN_REL                           0x0011
-#define HOTFIX_REL                        0x0012
-
-#define PIPELINE_ID                       0x0014
-#define BUILD_ID                          0x0018
-
-#define JTAG_DEVICE_ID                    0x001c
-#define PRODUCT_ID                        0x001e
-
-#define STATUS                            0xc03c
-#define USER_GPIO0_TO_7_STATUS            0x008a
-#define USER_GPIO8_TO_15_STATUS           0x008b
-
-#define GPIO_USER_CONTROL                 0xc160
-#define GPIO0_TO_7_OUT                    0x0000
-#define GPIO8_TO_15_OUT                   0x0001
-
-#define STICKY_STATUS_CLEAR               0xc164
-
-#define GPIO_TOD_NOTIFICATION_CLEAR       0xc16c
-
-#define ALERT_CFG                         0xc188
-
-#define SYS_DPLL_XO                       0xc194
-
-#define SYS_APLL                          0xc19c
-
-#define INPUT_0                           0xc1b0
-
-#define INPUT_1                           0xc1c0
-
-#define INPUT_2                           0xc1d0
-
-#define INPUT_3                           0xc200
-
-#define INPUT_4                           0xc210
-
-#define INPUT_5                           0xc220
-
-#define INPUT_6                           0xc230
-
-#define INPUT_7                           0xc240
-
-#define INPUT_8                           0xc250
-
-#define INPUT_9                           0xc260
-
-#define INPUT_10                          0xc280
-
-#define INPUT_11                          0xc290
-
-#define INPUT_12                          0xc2a0
-
-#define INPUT_13                          0xc2b0
-
-#define INPUT_14                          0xc2c0
-
-#define INPUT_15                          0xc2d0
-
-#define REF_MON_0                         0xc2e0
-
-#define REF_MON_1                         0xc2ec
-
-#define REF_MON_2                         0xc300
-
-#define REF_MON_3                         0xc30c
-
-#define REF_MON_4                         0xc318
-
-#define REF_MON_5                         0xc324
-
-#define REF_MON_6                         0xc330
-
-#define REF_MON_7                         0xc33c
-
-#define REF_MON_8                         0xc348
-
-#define REF_MON_9                         0xc354
-
-#define REF_MON_10                        0xc360
-
-#define REF_MON_11                        0xc36c
-
-#define REF_MON_12                        0xc380
-
-#define REF_MON_13                        0xc38c
-
-#define REF_MON_14                        0xc398
-
-#define REF_MON_15                        0xc3a4
-
-#define DPLL_0                            0xc3b0
-#define DPLL_CTRL_REG_0                   0x0002
-#define DPLL_CTRL_REG_1                   0x0003
-#define DPLL_CTRL_REG_2                   0x0004
-#define DPLL_TOD_SYNC_CFG                 0x0031
-#define DPLL_COMBO_SLAVE_CFG_0            0x0032
-#define DPLL_COMBO_SLAVE_CFG_1            0x0033
-#define DPLL_SLAVE_REF_CFG                0x0034
-#define DPLL_REF_MODE                     0x0035
-#define DPLL_PHASE_MEASUREMENT_CFG        0x0036
-#define DPLL_MODE                         0x0037
-
-#define DPLL_1                            0xc400
-
-#define DPLL_2                            0xc438
-
-#define DPLL_3                            0xc480
-
-#define DPLL_4                            0xc4b8
-
-#define DPLL_5                            0xc500
-
-#define DPLL_6                            0xc538
-
-#define DPLL_7                            0xc580
-
-#define SYS_DPLL                          0xc5b8
-
-#define DPLL_CTRL_0                       0xc600
-#define DPLL_CTRL_DPLL_MANU_REF_CFG       0x0001
-
-#define DPLL_CTRL_1                       0xc63c
-
-#define DPLL_CTRL_2                       0xc680
-
-#define DPLL_CTRL_3                       0xc6bc
-
-#define DPLL_CTRL_4                       0xc700
-
-#define DPLL_CTRL_5                       0xc73c
-
-#define DPLL_CTRL_6                       0xc780
-
-#define DPLL_CTRL_7                       0xc7bc
-
-#define SYS_DPLL_CTRL                     0xc800
-
-#define DPLL_PHASE_0                      0xc818
-
-/* Signed 42-bit FFO in units of 2^(-53) */
-#define DPLL_WR_PHASE                     0x0000
-
-#define DPLL_PHASE_1                      0xc81c
-
-#define DPLL_PHASE_2                      0xc820
-
-#define DPLL_PHASE_3                      0xc824
-
-#define DPLL_PHASE_4                      0xc828
-
-#define DPLL_PHASE_5                      0xc82c
-
-#define DPLL_PHASE_6                      0xc830
-
-#define DPLL_PHASE_7                      0xc834
-
-#define DPLL_FREQ_0                       0xc838
-
-/* Signed 42-bit FFO in units of 2^(-53) */
-#define DPLL_WR_FREQ                      0x0000
-
-#define DPLL_FREQ_1                       0xc840
-
-#define DPLL_FREQ_2                       0xc848
-
-#define DPLL_FREQ_3                       0xc850
-
-#define DPLL_FREQ_4                       0xc858
-
-#define DPLL_FREQ_5                       0xc860
-
-#define DPLL_FREQ_6                       0xc868
-
-#define DPLL_FREQ_7                       0xc870
-
-#define DPLL_PHASE_PULL_IN_0              0xc880
-#define PULL_IN_OFFSET                    0x0000 /* Signed 32 bit */
-#define PULL_IN_SLOPE_LIMIT               0x0004 /* Unsigned 24 bit */
-#define PULL_IN_CTRL                      0x0007
-
-#define DPLL_PHASE_PULL_IN_1              0xc888
-
-#define DPLL_PHASE_PULL_IN_2              0xc890
-
-#define DPLL_PHASE_PULL_IN_3              0xc898
-
-#define DPLL_PHASE_PULL_IN_4              0xc8a0
-
-#define DPLL_PHASE_PULL_IN_5              0xc8a8
-
-#define DPLL_PHASE_PULL_IN_6              0xc8b0
-
-#define DPLL_PHASE_PULL_IN_7              0xc8b8
-
-#define GPIO_CFG                          0xc8c0
-#define GPIO_CFG_GBL                      0x0000
-
-#define GPIO_0                            0xc8c2
-#define GPIO_DCO_INC_DEC                  0x0000
-#define GPIO_OUT_CTRL_0                   0x0001
-#define GPIO_OUT_CTRL_1                   0x0002
-#define GPIO_TOD_TRIG                     0x0003
-#define GPIO_DPLL_INDICATOR               0x0004
-#define GPIO_LOS_INDICATOR                0x0005
-#define GPIO_REF_INPUT_DSQ_0              0x0006
-#define GPIO_REF_INPUT_DSQ_1              0x0007
-#define GPIO_REF_INPUT_DSQ_2              0x0008
-#define GPIO_REF_INPUT_DSQ_3              0x0009
-#define GPIO_MAN_CLK_SEL_0                0x000a
-#define GPIO_MAN_CLK_SEL_1                0x000b
-#define GPIO_MAN_CLK_SEL_2                0x000c
-#define GPIO_SLAVE                        0x000d
-#define GPIO_ALERT_OUT_CFG                0x000e
-#define GPIO_TOD_NOTIFICATION_CFG         0x000f
-#define GPIO_CTRL                         0x0010
-
-#define GPIO_1                            0xc8d4
-
-#define GPIO_2                            0xc8e6
-
-#define GPIO_3                            0xc900
-
-#define GPIO_4                            0xc912
-
-#define GPIO_5                            0xc924
-
-#define GPIO_6                            0xc936
-
-#define GPIO_7                            0xc948
-
-#define GPIO_8                            0xc95a
-
-#define GPIO_9                            0xc980
-
-#define GPIO_10                           0xc992
-
-#define GPIO_11                           0xc9a4
-
-#define GPIO_12                           0xc9b6
-
-#define GPIO_13                           0xc9c8
-
-#define GPIO_14                           0xc9da
-
-#define GPIO_15                           0xca00
-
-#define OUT_DIV_MUX                       0xca12
-
-#define OUTPUT_0                          0xca14
-/* FOD frequency output divider value */
-#define OUT_DIV                           0x0000
-#define OUT_DUTY_CYCLE_HIGH               0x0004
-#define OUT_CTRL_0                        0x0008
-#define OUT_CTRL_1                        0x0009
-/* Phase adjustment in FOD cycles */
-#define OUT_PHASE_ADJ                     0x000c
-
-#define OUTPUT_1                          0xca24
-
-#define OUTPUT_2                          0xca34
-
-#define OUTPUT_3                          0xca44
-
-#define OUTPUT_4                          0xca54
-
-#define OUTPUT_5                          0xca64
-
-#define OUTPUT_6                          0xca80
-
-#define OUTPUT_7                          0xca90
-
-#define OUTPUT_8                          0xcaa0
-
-#define OUTPUT_9                          0xcab0
-
-#define OUTPUT_10                         0xcac0
-
-#define OUTPUT_11                         0xcad0
-
-#define SERIAL                            0xcae0
-
-#define PWM_ENCODER_0                     0xcb00
-
-#define PWM_ENCODER_1                     0xcb08
-
-#define PWM_ENCODER_2                     0xcb10
-
-#define PWM_ENCODER_3                     0xcb18
-
-#define PWM_ENCODER_4                     0xcb20
-
-#define PWM_ENCODER_5                     0xcb28
-
-#define PWM_ENCODER_6                     0xcb30
-
-#define PWM_ENCODER_7                     0xcb38
-
-#define PWM_DECODER_0                     0xcb40
-
-#define PWM_DECODER_1                     0xcb48
-
-#define PWM_DECODER_2                     0xcb50
-
-#define PWM_DECODER_3                     0xcb58
-
-#define PWM_DECODER_4                     0xcb60
-
-#define PWM_DECODER_5                     0xcb68
-
-#define PWM_DECODER_6                     0xcb70
-
-#define PWM_DECODER_7                     0xcb80
-
-#define PWM_DECODER_8                     0xcb88
-
-#define PWM_DECODER_9                     0xcb90
-
-#define PWM_DECODER_10                    0xcb98
-
-#define PWM_DECODER_11                    0xcba0
-
-#define PWM_DECODER_12                    0xcba8
-
-#define PWM_DECODER_13                    0xcbb0
-
-#define PWM_DECODER_14                    0xcbb8
-
-#define PWM_DECODER_15                    0xcbc0
-
-#define PWM_USER_DATA                     0xcbc8
-
-#define TOD_0                             0xcbcc
-
-/* Enable TOD counter, output channel sync and even-PPS mode */
-#define TOD_CFG                           0x0000
-
-#define TOD_1                             0xcbce
-
-#define TOD_2                             0xcbd0
-
-#define TOD_3                             0xcbd2
-
-
-#define TOD_WRITE_0                       0xcc00
-/* 8-bit subns, 32-bit ns, 48-bit seconds */
-#define TOD_WRITE                         0x0000
-/* Counter increments after TOD write is completed */
-#define TOD_WRITE_COUNTER                 0x000c
-/* TOD write trigger configuration */
-#define TOD_WRITE_SELECT_CFG_0            0x000d
-/* TOD write trigger selection */
-#define TOD_WRITE_CMD                     0x000f
-
-#define TOD_WRITE_1                       0xcc10
-
-#define TOD_WRITE_2                       0xcc20
-
-#define TOD_WRITE_3                       0xcc30
-
-#define TOD_READ_PRIMARY_0                0xcc40
-/* 8-bit subns, 32-bit ns, 48-bit seconds */
-#define TOD_READ_PRIMARY                  0x0000
-/* Counter increments after TOD write is completed */
-#define TOD_READ_PRIMARY_COUNTER          0x000b
-/* Read trigger configuration */
-#define TOD_READ_PRIMARY_SEL_CFG_0        0x000c
-/* Read trigger selection */
-#define TOD_READ_PRIMARY_CMD              0x000e
-
-#define TOD_READ_PRIMARY_1                0xcc50
-
-#define TOD_READ_PRIMARY_2                0xcc60
-
-#define TOD_READ_PRIMARY_3                0xcc80
-
-#define TOD_READ_SECONDARY_0              0xcc90
-
-#define TOD_READ_SECONDARY_1              0xcca0
-
-#define TOD_READ_SECONDARY_2              0xccb0
-
-#define TOD_READ_SECONDARY_3              0xccc0
-
-#define OUTPUT_TDC_CFG                    0xccd0
-
-#define OUTPUT_TDC_0                      0xcd00
-
-#define OUTPUT_TDC_1                      0xcd08
-
-#define OUTPUT_TDC_2                      0xcd10
-
-#define OUTPUT_TDC_3                      0xcd18
-
-#define INPUT_TDC                         0xcd20
-
-#define SCRATCH                           0xcf50
-
-#define EEPROM                            0xcf68
-
-#define OTP                               0xcf70
-
-#define BYTE                              0xcf80
-
-/* Bit definitions for the MAJ_REL register */
-#define MAJOR_SHIFT                       (1)
-#define MAJOR_MASK                        (0x7f)
-#define PR_BUILD                          BIT(0)
-
-/* Bit definitions for the USER_GPIO0_TO_7_STATUS register */
-#define GPIO0_LEVEL                       BIT(0)
-#define GPIO1_LEVEL                       BIT(1)
-#define GPIO2_LEVEL                       BIT(2)
-#define GPIO3_LEVEL                       BIT(3)
-#define GPIO4_LEVEL                       BIT(4)
-#define GPIO5_LEVEL                       BIT(5)
-#define GPIO6_LEVEL                       BIT(6)
-#define GPIO7_LEVEL                       BIT(7)
-
-/* Bit definitions for the USER_GPIO8_TO_15_STATUS register */
-#define GPIO8_LEVEL                       BIT(0)
-#define GPIO9_LEVEL                       BIT(1)
-#define GPIO10_LEVEL                      BIT(2)
-#define GPIO11_LEVEL                      BIT(3)
-#define GPIO12_LEVEL                      BIT(4)
-#define GPIO13_LEVEL                      BIT(5)
-#define GPIO14_LEVEL                      BIT(6)
-#define GPIO15_LEVEL                      BIT(7)
-
-/* Bit definitions for the GPIO0_TO_7_OUT register */
-#define GPIO0_DRIVE_LEVEL                 BIT(0)
-#define GPIO1_DRIVE_LEVEL                 BIT(1)
-#define GPIO2_DRIVE_LEVEL                 BIT(2)
-#define GPIO3_DRIVE_LEVEL                 BIT(3)
-#define GPIO4_DRIVE_LEVEL                 BIT(4)
-#define GPIO5_DRIVE_LEVEL                 BIT(5)
-#define GPIO6_DRIVE_LEVEL                 BIT(6)
-#define GPIO7_DRIVE_LEVEL                 BIT(7)
-
-/* Bit definitions for the GPIO8_TO_15_OUT register */
-#define GPIO8_DRIVE_LEVEL                 BIT(0)
-#define GPIO9_DRIVE_LEVEL                 BIT(1)
-#define GPIO10_DRIVE_LEVEL                BIT(2)
-#define GPIO11_DRIVE_LEVEL                BIT(3)
-#define GPIO12_DRIVE_LEVEL                BIT(4)
-#define GPIO13_DRIVE_LEVEL                BIT(5)
-#define GPIO14_DRIVE_LEVEL                BIT(6)
-#define GPIO15_DRIVE_LEVEL                BIT(7)
-
-/* Bit definitions for the DPLL_TOD_SYNC_CFG register */
-#define TOD_SYNC_SOURCE_SHIFT             (1)
-#define TOD_SYNC_SOURCE_MASK              (0x3)
-#define TOD_SYNC_EN                       BIT(0)
-
-/* Bit definitions for the DPLL_MODE register */
-#define WRITE_TIMER_MODE                  BIT(6)
-#define PLL_MODE_SHIFT                    (3)
-#define PLL_MODE_MASK                     (0x7)
-#define STATE_MODE_SHIFT                  (0)
-#define STATE_MODE_MASK                   (0x7)
-
-/* Bit definitions for the GPIO_CFG_GBL register */
-#define SUPPLY_MODE_SHIFT                 (0)
-#define SUPPLY_MODE_MASK                  (0x3)
-
-/* Bit definitions for the GPIO_DCO_INC_DEC register */
-#define INCDEC_DPLL_INDEX_SHIFT           (0)
-#define INCDEC_DPLL_INDEX_MASK            (0x7)
-
-/* Bit definitions for the GPIO_OUT_CTRL_0 register */
-#define CTRL_OUT_0                        BIT(0)
-#define CTRL_OUT_1                        BIT(1)
-#define CTRL_OUT_2                        BIT(2)
-#define CTRL_OUT_3                        BIT(3)
-#define CTRL_OUT_4                        BIT(4)
-#define CTRL_OUT_5                        BIT(5)
-#define CTRL_OUT_6                        BIT(6)
-#define CTRL_OUT_7                        BIT(7)
-
-/* Bit definitions for the GPIO_OUT_CTRL_1 register */
-#define CTRL_OUT_8                        BIT(0)
-#define CTRL_OUT_9                        BIT(1)
-#define CTRL_OUT_10                       BIT(2)
-#define CTRL_OUT_11                       BIT(3)
-#define CTRL_OUT_12                       BIT(4)
-#define CTRL_OUT_13                       BIT(5)
-#define CTRL_OUT_14                       BIT(6)
-#define CTRL_OUT_15                       BIT(7)
-
-/* Bit definitions for the GPIO_TOD_TRIG register */
-#define TOD_TRIG_0                        BIT(0)
-#define TOD_TRIG_1                        BIT(1)
-#define TOD_TRIG_2                        BIT(2)
-#define TOD_TRIG_3                        BIT(3)
-
-/* Bit definitions for the GPIO_DPLL_INDICATOR register */
-#define IND_DPLL_INDEX_SHIFT              (0)
-#define IND_DPLL_INDEX_MASK               (0x7)
-
-/* Bit definitions for the GPIO_LOS_INDICATOR register */
-#define REFMON_INDEX_SHIFT                (0)
-#define REFMON_INDEX_MASK                 (0xf)
-/* Active level of LOS indicator, 0=low 1=high */
-#define ACTIVE_LEVEL                      BIT(4)
-
-/* Bit definitions for the GPIO_REF_INPUT_DSQ_0 register */
-#define DSQ_INP_0                         BIT(0)
-#define DSQ_INP_1                         BIT(1)
-#define DSQ_INP_2                         BIT(2)
-#define DSQ_INP_3                         BIT(3)
-#define DSQ_INP_4                         BIT(4)
-#define DSQ_INP_5                         BIT(5)
-#define DSQ_INP_6                         BIT(6)
-#define DSQ_INP_7                         BIT(7)
-
-/* Bit definitions for the GPIO_REF_INPUT_DSQ_1 register */
-#define DSQ_INP_8                         BIT(0)
-#define DSQ_INP_9                         BIT(1)
-#define DSQ_INP_10                        BIT(2)
-#define DSQ_INP_11                        BIT(3)
-#define DSQ_INP_12                        BIT(4)
-#define DSQ_INP_13                        BIT(5)
-#define DSQ_INP_14                        BIT(6)
-#define DSQ_INP_15                        BIT(7)
-
-/* Bit definitions for the GPIO_REF_INPUT_DSQ_2 register */
-#define DSQ_DPLL_0                        BIT(0)
-#define DSQ_DPLL_1                        BIT(1)
-#define DSQ_DPLL_2                        BIT(2)
-#define DSQ_DPLL_3                        BIT(3)
-#define DSQ_DPLL_4                        BIT(4)
-#define DSQ_DPLL_5                        BIT(5)
-#define DSQ_DPLL_6                        BIT(6)
-#define DSQ_DPLL_7                        BIT(7)
-
-/* Bit definitions for the GPIO_REF_INPUT_DSQ_3 register */
-#define DSQ_DPLL_SYS                      BIT(0)
-#define GPIO_DSQ_LEVEL                    BIT(1)
-
-/* Bit definitions for the GPIO_TOD_NOTIFICATION_CFG register */
-#define DPLL_TOD_SHIFT                    (0)
-#define DPLL_TOD_MASK                     (0x3)
-#define TOD_READ_SECONDARY                BIT(2)
-#define GPIO_ASSERT_LEVEL                 BIT(3)
-
-/* Bit definitions for the GPIO_CTRL register */
-#define GPIO_FUNCTION_EN                  BIT(0)
-#define GPIO_CMOS_OD_MODE                 BIT(1)
-#define GPIO_CONTROL_DIR                  BIT(2)
-#define GPIO_PU_PD_MODE                   BIT(3)
-#define GPIO_FUNCTION_SHIFT               (4)
-#define GPIO_FUNCTION_MASK                (0xf)
-
-/* Bit definitions for the OUT_CTRL_1 register */
-#define OUT_SYNC_DISABLE                  BIT(7)
-#define SQUELCH_VALUE                     BIT(6)
-#define SQUELCH_DISABLE                   BIT(5)
-#define PAD_VDDO_SHIFT                    (2)
-#define PAD_VDDO_MASK                     (0x7)
-#define PAD_CMOSDRV_SHIFT                 (0)
-#define PAD_CMOSDRV_MASK                  (0x3)
-
-/* Bit definitions for the TOD_CFG register */
-#define TOD_EVEN_PPS_MODE                 BIT(2)
-#define TOD_OUT_SYNC_ENABLE               BIT(1)
-#define TOD_ENABLE                        BIT(0)
-
-/* Bit definitions for the TOD_WRITE_SELECT_CFG_0 register */
-#define WR_PWM_DECODER_INDEX_SHIFT        (4)
-#define WR_PWM_DECODER_INDEX_MASK         (0xf)
-#define WR_REF_INDEX_SHIFT                (0)
-#define WR_REF_INDEX_MASK                 (0xf)
-
-/* Bit definitions for the TOD_WRITE_CMD register */
-#define TOD_WRITE_SELECTION_SHIFT         (0)
-#define TOD_WRITE_SELECTION_MASK          (0xf)
-
-/* Bit definitions for the TOD_READ_PRIMARY_SEL_CFG_0 register */
-#define RD_PWM_DECODER_INDEX_SHIFT        (4)
-#define RD_PWM_DECODER_INDEX_MASK         (0xf)
-#define RD_REF_INDEX_SHIFT                (0)
-#define RD_REF_INDEX_MASK                 (0xf)
-
-/* Bit definitions for the TOD_READ_PRIMARY_CMD register */
-#define TOD_READ_TRIGGER_MODE             BIT(4)
-#define TOD_READ_TRIGGER_SHIFT            (0)
-#define TOD_READ_TRIGGER_MASK             (0xf)
-
-#endif
diff --git a/drivers/ptp/ptp_clockmatrix.c b/drivers/ptp/ptp_clockmatrix.c
index a5110b7..66e3266 100644
--- a/drivers/ptp/ptp_clockmatrix.c
+++ b/drivers/ptp/ptp_clockmatrix.c
@@ -1,9 +1,9 @@
 // SPDX-License-Identifier: GPL-2.0+
 /*
- * PTP hardware clock driver for the IDT ClockMatrix(TM) family of timing and
- * synchronization devices.
+ * PTP hardware clock driver for the Renesas (IDT) ClockMatrix(TM) family of
+ * timing and synchronization devices.
  *
- * Copyright (C) 2019 Integrated Device Technology, Inc., a Renesas Company.
+ * Copyright (C) 2019 Renesas Electronics Corporation. All rights reserved.
  */
 #include <linux/firmware.h>
 #include <linux/i2c.h>
@@ -16,7 +16,7 @@
 #include "ptp_private.h"
 #include "ptp_clockmatrix.h"
 
-MODULE_DESCRIPTION("Driver for IDT ClockMatrix(TM) family");
+MODULE_DESCRIPTION("Driver for Renesas (IDT) ClockMatrix(TM) family");
 MODULE_AUTHOR("Richard Cochran <richardcochran@gmail.com>");
 MODULE_AUTHOR("IDT support-1588 <IDT-support-1588@lm.renesas.com>");
 MODULE_VERSION("1.0");
@@ -84,13 +84,13 @@ static int timespec_to_char_array(struct timespec64 const *ts,
 	return 0;
 }
 
-static int idtcm_xfer(struct idtcm *idtcm,
-		      u8 regaddr,
-		      u8 *buf,
-		      u16 count,
-		      bool write)
+static int cm_xfer(struct cm *cm,
+		   u8 regaddr,
+		   u8 *buf,
+		   u16 count,
+		   bool write)
 {
-	struct i2c_client *client = idtcm->client;
+	struct i2c_client *client = cm->client;
 	struct i2c_msg msg[2];
 	int cnt;
 
@@ -118,12 +118,12 @@ static int idtcm_xfer(struct idtcm *idtcm,
 	return 0;
 }
 
-static int idtcm_page_offset(struct idtcm *idtcm, u8 val)
+static int cm_page_offset(struct cm *cm, u8 val)
 {
 	u8 buf[4];
 	int err;
 
-	if (idtcm->page_offset == val)
+	if (cm->page_offset == val)
 		return 0;
 
 	buf[0] = 0x0;
@@ -131,21 +131,21 @@ static int idtcm_page_offset(struct idtcm *idtcm, u8 val)
 	buf[2] = 0x10;
 	buf[3] = 0x20;
 
-	err = idtcm_xfer(idtcm, PAGE_ADDR, buf, sizeof(buf), 1);
+	err = cm_xfer(cm, PAGE_ADDR, buf, sizeof(buf), 1);
 
 	if (err)
-		dev_err(&idtcm->client->dev, "failed to set page offset\n");
+		dev_err(&cm->client->dev, "failed to set page offset\n");
 	else
-		idtcm->page_offset = val;
+		cm->page_offset = val;
 
 	return err;
 }
 
-static int _idtcm_rdwr(struct idtcm *idtcm,
-		       u16 regaddr,
-		       u8 *buf,
-		       u16 count,
-		       bool write)
+static int _cm_rdwr(struct cm *cm,
+		    u16 regaddr,
+		    u8 *buf,
+		    u16 count,
+		    bool write)
 {
 	u8 hi;
 	u8 lo;
@@ -154,44 +154,44 @@ static int _idtcm_rdwr(struct idtcm *idtcm,
 	hi = (regaddr >> 8) & 0xff;
 	lo = regaddr & 0xff;
 
-	err = idtcm_page_offset(idtcm, hi);
+	err = cm_page_offset(cm, hi);
 
 	if (err)
 		goto out;
 
-	err = idtcm_xfer(idtcm, lo, buf, count, write);
+	err = cm_xfer(cm, lo, buf, count, write);
 out:
 	return err;
 }
 
-static int idtcm_read(struct idtcm *idtcm,
-		      u16 module,
-		      u16 regaddr,
-		      u8 *buf,
-		      u16 count)
+static int cm_read(struct cm *cm,
+		   u16 module,
+		   u16 regaddr,
+		   u8 *buf,
+		   u16 count)
 {
-	return _idtcm_rdwr(idtcm, module + regaddr, buf, count, false);
+	return _cm_rdwr(cm, module + regaddr, buf, count, false);
 }
 
-static int idtcm_write(struct idtcm *idtcm,
-		       u16 module,
-		       u16 regaddr,
-		       u8 *buf,
-		       u16 count)
+static int cm_write(struct cm *cm,
+		    u16 module,
+		    u16 regaddr,
+		    u8 *buf,
+		    u16 count)
 {
-	return _idtcm_rdwr(idtcm, module + regaddr, buf, count, true);
+	return _cm_rdwr(cm, module + regaddr, buf, count, true);
 }
 
-static int _idtcm_gettime(struct idtcm_channel *channel,
-			  struct timespec64 *ts)
+static int _cm_gettime(struct cm_channel *channel,
+		       struct timespec64 *ts)
 {
-	struct idtcm *idtcm = channel->idtcm;
+	struct cm *cm = channel->cm;
 	u8 buf[TOD_BYTE_COUNT];
 	u8 trigger;
 	int err;
 
-	err = idtcm_read(idtcm, channel->tod_read_primary,
-			 TOD_READ_PRIMARY_CMD, &trigger, sizeof(trigger));
+	err = cm_read(cm, channel->tod_read_primary,
+		      TOD_READ_PRIMARY_CMD, &trigger, sizeof(trigger));
 	if (err)
 		return err;
 
@@ -199,17 +199,17 @@ static int _idtcm_gettime(struct idtcm_channel *channel,
 	trigger |= (1 << TOD_READ_TRIGGER_SHIFT);
 	trigger |= TOD_READ_TRIGGER_MODE;
 
-	err = idtcm_write(idtcm, channel->tod_read_primary,
-			  TOD_READ_PRIMARY_CMD, &trigger, sizeof(trigger));
+	err = cm_write(cm, channel->tod_read_primary,
+		       TOD_READ_PRIMARY_CMD, &trigger, sizeof(trigger));
 
 	if (err)
 		return err;
 
-	if (idtcm->calculate_overhead_flag)
-		idtcm->start_time = ktime_get_raw();
+	if (cm->calculate_overhead_flag)
+		cm->start_time = ktime_get_raw();
 
-	err = idtcm_read(idtcm, channel->tod_read_primary,
-			 TOD_READ_PRIMARY, buf, sizeof(buf));
+	err = cm_read(cm, channel->tod_read_primary,
+		      TOD_READ_PRIMARY, buf, sizeof(buf));
 
 	if (err)
 		return err;
@@ -219,7 +219,7 @@ static int _idtcm_gettime(struct idtcm_channel *channel,
 	return err;
 }
 
-static int _sync_pll_output(struct idtcm *idtcm,
+static int _sync_pll_output(struct cm *cm,
 			    u8 pll,
 			    u8 sync_src,
 			    u8 qn,
@@ -273,11 +273,11 @@ static int _sync_pll_output(struct idtcm *idtcm,
 	val = SYNCTRL1_MASTER_SYNC_RST;
 
 	/* Place master sync in reset */
-	err = idtcm_write(idtcm, 0, sync_ctrl1, &val, sizeof(val));
+	err = cm_write(cm, 0, sync_ctrl1, &val, sizeof(val));
 	if (err)
 		return err;
 
-	err = idtcm_write(idtcm, 0, sync_ctrl0, &sync_src, sizeof(sync_src));
+	err = cm_write(cm, 0, sync_ctrl0, &sync_src, sizeof(sync_src));
 	if (err)
 		return err;
 
@@ -290,20 +290,20 @@ static int _sync_pll_output(struct idtcm *idtcm,
 	if (qn_plus_1)
 		val |= SYNCTRL1_Q1_DIV_SYNC_TRIG;
 
-	err = idtcm_write(idtcm, 0, sync_ctrl1, &val, sizeof(val));
+	err = cm_write(cm, 0, sync_ctrl1, &val, sizeof(val));
 	if (err)
 		return err;
 
 	/* Place master sync out of reset */
 	val &= ~(SYNCTRL1_MASTER_SYNC_RST);
-	err = idtcm_write(idtcm, 0, sync_ctrl1, &val, sizeof(val));
+	err = cm_write(cm, 0, sync_ctrl1, &val, sizeof(val));
 
 	return err;
 }
 
-static int idtcm_sync_pps_output(struct idtcm_channel *channel)
+static int cm_sync_pps_output(struct cm_channel *channel)
 {
-	struct idtcm *idtcm = channel->idtcm;
+	struct cm *cm = channel->cm;
 
 	u8 pll;
 	u8 sync_src;
@@ -344,7 +344,7 @@ static int idtcm_sync_pps_output(struct idtcm_channel *channel)
 		}
 
 		if ((qn != 0) || (qn_plus_1 != 0))
-			err = _sync_pll_output(idtcm, pll, sync_src, qn,
+			err = _sync_pll_output(cm, pll, sync_src, qn,
 					       qn_plus_1);
 
 		if (err)
@@ -354,11 +354,11 @@ static int idtcm_sync_pps_output(struct idtcm_channel *channel)
 	return err;
 }
 
-static int _idtcm_set_dpll_tod(struct idtcm_channel *channel,
-			       struct timespec64 const *ts,
-			       enum hw_tod_write_trig_sel wr_trig)
+static int _cm_set_dpll_tod(struct cm_channel *channel,
+			    struct timespec64 const *ts,
+			    enum hw_tod_write_trig_sel wr_trig)
 {
-	struct idtcm *idtcm = channel->idtcm;
+	struct cm *cm = channel->cm;
 
 	u8 buf[TOD_BYTE_COUNT];
 	u8 cmd;
@@ -367,8 +367,8 @@ static int _idtcm_set_dpll_tod(struct idtcm_channel *channel,
 	s64 total_overhead_ns;
 
 	/* Configure HW TOD write trigger. */
-	err = idtcm_read(idtcm, channel->hw_dpll_n, HW_DPLL_TOD_CTRL_1,
-			 &cmd, sizeof(cmd));
+	err = cm_read(cm, channel->hw_dpll_n, HW_DPLL_TOD_CTRL_1,
+		      &cmd, sizeof(cmd));
 
 	if (err)
 		return err;
@@ -376,8 +376,8 @@ static int _idtcm_set_dpll_tod(struct idtcm_channel *channel,
 	cmd &= ~(0x0f);
 	cmd |= wr_trig | 0x08;
 
-	err = idtcm_write(idtcm, channel->hw_dpll_n, HW_DPLL_TOD_CTRL_1,
-			  &cmd, sizeof(cmd));
+	err = cm_write(cm, channel->hw_dpll_n, HW_DPLL_TOD_CTRL_1,
+		       &cmd, sizeof(cmd));
 
 	if (err)
 		return err;
@@ -389,8 +389,8 @@ static int _idtcm_set_dpll_tod(struct idtcm_channel *channel,
 		if (err)
 			return err;
 
-		err = idtcm_write(idtcm, channel->hw_dpll_n,
-				  HW_DPLL_TOD_OVR__0, buf, sizeof(buf));
+		err = cm_write(cm, channel->hw_dpll_n,
+			       HW_DPLL_TOD_OVR__0, buf, sizeof(buf));
 
 		if (err)
 			return err;
@@ -399,20 +399,21 @@ static int _idtcm_set_dpll_tod(struct idtcm_channel *channel,
 	/* ARM HW TOD write trigger. */
 	cmd &= ~(0x08);
 
-	err = idtcm_write(idtcm, channel->hw_dpll_n, HW_DPLL_TOD_CTRL_1,
-			  &cmd, sizeof(cmd));
+	err = cm_write(cm, channel->hw_dpll_n, HW_DPLL_TOD_CTRL_1,
+		       &cmd, sizeof(cmd));
 
 	if (wr_trig == HW_TOD_WR_TRIG_SEL_MSB) {
 
-		if (idtcm->calculate_overhead_flag) {
+		if (cm->calculate_overhead_flag) {
+			/* Assumption: I2C @ 400KHz */
 			total_overhead_ns =  ktime_to_ns(ktime_get_raw()
-							 - idtcm->start_time)
-					     + idtcm->tod_write_overhead_ns
+							 - cm->start_time)
+					     + cm->tod_write_overhead_ns
 					     + SETTIME_CORRECTION;
 
 			timespec64_add_ns(&local_ts, total_overhead_ns);
 
-			idtcm->calculate_overhead_flag = 0;
+			cm->calculate_overhead_flag = 0;
 		}
 
 		err = timespec_to_char_array(&local_ts, buf, sizeof(buf));
@@ -420,33 +421,33 @@ static int _idtcm_set_dpll_tod(struct idtcm_channel *channel,
 		if (err)
 			return err;
 
-		err = idtcm_write(idtcm, channel->hw_dpll_n,
-				  HW_DPLL_TOD_OVR__0, buf, sizeof(buf));
+		err = cm_write(cm, channel->hw_dpll_n,
+			       HW_DPLL_TOD_OVR__0, buf, sizeof(buf));
 	}
 
 	return err;
 }
 
-static int _idtcm_settime(struct idtcm_channel *channel,
-			  struct timespec64 const *ts,
-			  enum hw_tod_write_trig_sel wr_trig)
+static int _cm_settime(struct cm_channel *channel,
+		       struct timespec64 const *ts,
+		       enum hw_tod_write_trig_sel wr_trig)
 {
-	struct idtcm *idtcm = channel->idtcm;
+	struct cm *cm = channel->cm;
 	s32 retval;
 	int err;
 	int i;
 	u8 trig_sel;
 
-	err = _idtcm_set_dpll_tod(channel, ts, wr_trig);
+	err = _cm_set_dpll_tod(channel, ts, wr_trig);
 
 	if (err)
 		return err;
 
 	/* Wait for the operation to complete. */
 	for (i = 0; i < 10000; i++) {
-		err = idtcm_read(idtcm, channel->hw_dpll_n,
-				 HW_DPLL_TOD_CTRL_1, &trig_sel,
-				 sizeof(trig_sel));
+		err = cm_read(cm, channel->hw_dpll_n,
+			      HW_DPLL_TOD_CTRL_1, &trig_sel,
+			      sizeof(trig_sel));
 
 		if (err)
 			return err;
@@ -460,17 +461,17 @@ static int _idtcm_settime(struct idtcm_channel *channel,
 	if (err)
 		return err;
 
-	retval = idtcm_sync_pps_output(channel);
+	retval = cm_sync_pps_output(channel);
 
 	return retval;
 }
 
-static int idtcm_set_phase_pull_in_offset(struct idtcm_channel *channel,
-					  s32 offset_ns)
+static int cm_set_phase_pull_in_offset(struct cm_channel *channel,
+				       s32 offset_ns)
 {
 	int err;
 	int i;
-	struct idtcm *idtcm = channel->idtcm;
+	struct cm *cm = channel->cm;
 
 	u8 buf[4];
 
@@ -479,18 +480,18 @@ static int idtcm_set_phase_pull_in_offset(struct idtcm_channel *channel,
 		offset_ns >>= 8;
 	}
 
-	err = idtcm_write(idtcm, channel->dpll_phase_pull_in, PULL_IN_OFFSET,
-			  buf, sizeof(buf));
+	err = cm_write(cm, channel->dpll_phase_pull_in, PULL_IN_OFFSET,
+		       buf, sizeof(buf));
 
 	return err;
 }
 
-static int idtcm_set_phase_pull_in_slope_limit(struct idtcm_channel *channel,
-					       u32 max_ffo_ppb)
+static int cm_set_phase_pull_in_slope_limit(struct cm_channel *channel,
+					    u32 max_ffo_ppb)
 {
 	int err;
 	u8 i;
-	struct idtcm *idtcm = channel->idtcm;
+	struct cm *cm = channel->cm;
 
 	u8 buf[3];
 
@@ -502,29 +503,29 @@ static int idtcm_set_phase_pull_in_slope_limit(struct idtcm_channel *channel,
 		max_ffo_ppb >>= 8;
 	}
 
-	err = idtcm_write(idtcm, channel->dpll_phase_pull_in,
-			  PULL_IN_SLOPE_LIMIT, buf, sizeof(buf));
+	err = cm_write(cm, channel->dpll_phase_pull_in,
+		       PULL_IN_SLOPE_LIMIT, buf, sizeof(buf));
 
 	return err;
 }
 
-static int idtcm_start_phase_pull_in(struct idtcm_channel *channel)
+static int cm_start_phase_pull_in(struct cm_channel *channel)
 {
 	int err;
-	struct idtcm *idtcm = channel->idtcm;
+	struct cm *cm = channel->cm;
 
 	u8 buf;
 
-	err = idtcm_read(idtcm, channel->dpll_phase_pull_in, PULL_IN_CTRL,
-			 &buf, sizeof(buf));
+	err = cm_read(cm, channel->dpll_phase_pull_in, PULL_IN_CTRL,
+		      &buf, sizeof(buf));
 
 	if (err)
 		return err;
 
 	if (buf == 0) {
 		buf = 0x01;
-		err = idtcm_write(idtcm, channel->dpll_phase_pull_in,
-				  PULL_IN_CTRL, &buf, sizeof(buf));
+		err = cm_write(cm, channel->dpll_phase_pull_in,
+			       PULL_IN_CTRL, &buf, sizeof(buf));
 	} else {
 		err = -EBUSY;
 	}
@@ -532,40 +533,40 @@ static int idtcm_start_phase_pull_in(struct idtcm_channel *channel)
 	return err;
 }
 
-static int idtcm_do_phase_pull_in(struct idtcm_channel *channel,
-				  s32 offset_ns,
-				  u32 max_ffo_ppb)
+static int cm_do_phase_pull_in(struct cm_channel *channel,
+			       s32 offset_ns,
+			       u32 max_ffo_ppb)
 {
 	int err;
 
-	err = idtcm_set_phase_pull_in_offset(channel, -offset_ns);
+	err = cm_set_phase_pull_in_offset(channel, -offset_ns);
 
 	if (err)
 		return err;
 
-	err = idtcm_set_phase_pull_in_slope_limit(channel, max_ffo_ppb);
+	err = cm_set_phase_pull_in_slope_limit(channel, max_ffo_ppb);
 
 	if (err)
 		return err;
 
-	err = idtcm_start_phase_pull_in(channel);
+	err = cm_start_phase_pull_in(channel);
 
 	return err;
 }
 
-static int _idtcm_adjtime(struct idtcm_channel *channel, s64 delta)
+static int _cm_adjtime(struct cm_channel *channel, s64 delta)
 {
 	int err;
-	struct idtcm *idtcm = channel->idtcm;
+	struct cm *cm = channel->cm;
 	struct timespec64 ts;
 	s64 now;
 
 	if (abs(delta) < PHASE_PULL_IN_THRESHOLD_NS) {
-		err = idtcm_do_phase_pull_in(channel, delta, 0);
+		err = cm_do_phase_pull_in(channel, delta, 0);
 	} else {
-		idtcm->calculate_overhead_flag = 1;
+		cm->calculate_overhead_flag = 1;
 
-		err = _idtcm_gettime(channel, &ts);
+		err = _cm_gettime(channel, &ts);
 
 		if (err)
 			return err;
@@ -575,18 +576,18 @@ static int _idtcm_adjtime(struct idtcm_channel *channel, s64 delta)
 
 		ts = ns_to_timespec64(now);
 
-		err = _idtcm_settime(channel, &ts, HW_TOD_WR_TRIG_SEL_MSB);
+		err = _cm_settime(channel, &ts, HW_TOD_WR_TRIG_SEL_MSB);
 	}
 
 	return err;
 }
 
-static int idtcm_state_machine_reset(struct idtcm *idtcm)
+static int cm_state_machine_reset(struct cm *cm)
 {
 	int err;
 	u8 byte = SM_RESET_CMD;
 
-	err = idtcm_write(idtcm, RESET_CTRL, SM_RESET, &byte, sizeof(byte));
+	err = cm_write(cm, RESET_CTRL, SM_RESET, &byte, sizeof(byte));
 
 	if (!err)
 		msleep_interruptible(POST_SM_RESET_DELAY_MS);
@@ -594,109 +595,93 @@ static int idtcm_state_machine_reset(struct idtcm *idtcm)
 	return err;
 }
 
-static int idtcm_read_hw_rev_id(struct idtcm *idtcm, u8 *hw_rev_id)
+static int cm_read_hw_rev_id(struct cm *cm, u8 *hw_rev_id)
 {
-	return idtcm_read(idtcm,
-			  GENERAL_STATUS,
-			  HW_REV_ID,
-			  hw_rev_id,
-			  sizeof(u8));
+	return cm_read(cm, GENERAL_STATUS, HW_REV_ID, hw_rev_id, sizeof(u8));
 }
 
-static int idtcm_read_bond_id(struct idtcm *idtcm, u8 *bond_id)
+static int cm_read_bond_id(struct cm *cm, u8 *bond_id)
 {
-	return idtcm_read(idtcm,
-			  GENERAL_STATUS,
-			  BOND_ID,
-			  bond_id,
-			  sizeof(u8));
+	return cm_read(cm, GENERAL_STATUS, BOND_ID, bond_id, sizeof(u8));
 }
 
-static int idtcm_read_hw_csr_id(struct idtcm *idtcm, u16 *hw_csr_id)
+static int cm_read_hw_csr_id(struct cm *cm, u16 *hw_csr_id)
 {
 	int err;
 	u8 buf[2] = {0};
 
-	err = idtcm_read(idtcm, GENERAL_STATUS, HW_CSR_ID, buf, sizeof(buf));
+	err = cm_read(cm, GENERAL_STATUS, HW_CSR_ID, buf, sizeof(buf));
 
 	*hw_csr_id = (buf[1] << 8) | buf[0];
 
 	return err;
 }
 
-static int idtcm_read_hw_irq_id(struct idtcm *idtcm, u16 *hw_irq_id)
+static int cm_read_hw_irq_id(struct cm *cm, u16 *hw_irq_id)
 {
 	int err;
 	u8 buf[2] = {0};
 
-	err = idtcm_read(idtcm, GENERAL_STATUS, HW_IRQ_ID, buf, sizeof(buf));
+	err = cm_read(cm, GENERAL_STATUS, HW_IRQ_ID, buf, sizeof(buf));
 
 	*hw_irq_id = (buf[1] << 8) | buf[0];
 
 	return err;
 }
 
-static int idtcm_read_product_id(struct idtcm *idtcm, u16 *product_id)
+static int cm_read_product_id(struct cm *cm, u16 *product_id)
 {
 	int err;
 	u8 buf[2] = {0};
 
-	err = idtcm_read(idtcm, GENERAL_STATUS, PRODUCT_ID, buf, sizeof(buf));
+	err = cm_read(cm, GENERAL_STATUS, PRODUCT_ID, buf, sizeof(buf));
 
 	*product_id = (buf[1] << 8) | buf[0];
 
 	return err;
 }
 
-static int idtcm_read_major_release(struct idtcm *idtcm, u8 *major)
+static int cm_read_major_release(struct cm *cm, u8 *major)
 {
 	int err;
 	u8 buf = 0;
 
-	err = idtcm_read(idtcm, GENERAL_STATUS, MAJ_REL, &buf, sizeof(buf));
+	err = cm_read(cm, GENERAL_STATUS, MAJ_REL, &buf, sizeof(buf));
 
 	*major = buf >> 1;
 
 	return err;
 }
 
-static int idtcm_read_minor_release(struct idtcm *idtcm, u8 *minor)
+static int cm_read_minor_release(struct cm *cm, u8 *minor)
 {
-	return idtcm_read(idtcm, GENERAL_STATUS, MIN_REL, minor, sizeof(u8));
+	return cm_read(cm, GENERAL_STATUS, MIN_REL, minor, sizeof(u8));
 }
 
-static int idtcm_read_hotfix_release(struct idtcm *idtcm, u8 *hotfix)
+static int cm_read_hotfix_release(struct cm *cm, u8 *hotfix)
 {
-	return idtcm_read(idtcm,
-			  GENERAL_STATUS,
-			  HOTFIX_REL,
-			  hotfix,
-			  sizeof(u8));
+	return cm_read(cm, GENERAL_STATUS, HOTFIX_REL, hotfix, sizeof(u8));
 }
 
-static int idtcm_read_pipeline(struct idtcm *idtcm, u32 *pipeline)
+static int cm_read_pipeline(struct cm *cm, u32 *pipeline)
 {
 	int err;
 	u8 buf[4] = {0};
 
-	err = idtcm_read(idtcm,
-			 GENERAL_STATUS,
-			 PIPELINE_ID,
-			 &buf[0],
-			 sizeof(buf));
+	err = cm_read(cm, GENERAL_STATUS, PIPELINE_ID, &buf[0], sizeof(buf));
 
 	*pipeline = (buf[3] << 24) | (buf[2] << 16) | (buf[1] << 8) | buf[0];
 
 	return err;
 }
 
-static int process_pll_mask(struct idtcm *idtcm, u32 addr, u8 val, u8 *mask)
+static int process_pll_mask(struct cm *cm, u32 addr, u8 val, u8 *mask)
 {
 	int err = 0;
 
 	if (addr == PLL_MASK_ADDR) {
 		if ((val & 0xf0) || !(val & 0xf)) {
-			dev_err(&idtcm->client->dev,
+			dev_err(&cm->client->dev,
 				"Invalid PLL mask 0x%hhx\n", val);
 			err = -EINVAL;
 		}
@@ -706,34 +691,34 @@ static int process_pll_mask(struct idtcm *idtcm, u32 addr, u8 val, u8 *mask)
 	return err;
 }
 
-static int set_pll_output_mask(struct idtcm *idtcm, u16 addr, u8 val)
+static int set_pll_output_mask(struct cm *cm, u16 addr, u8 val)
 {
 	int err = 0;
 
 	switch (addr) {
 	case OUTPUT_MASK_PLL0_ADDR:
-		SET_U16_LSB(idtcm->channel[0].output_mask, val);
+		SET_U16_LSB(cm->channel[0].output_mask, val);
 		break;
 	case OUTPUT_MASK_PLL0_ADDR + 1:
-		SET_U16_MSB(idtcm->channel[0].output_mask, val);
+		SET_U16_MSB(cm->channel[0].output_mask, val);
 		break;
 	case OUTPUT_MASK_PLL1_ADDR:
-		SET_U16_LSB(idtcm->channel[1].output_mask, val);
+		SET_U16_LSB(cm->channel[1].output_mask, val);
 		break;
 	case OUTPUT_MASK_PLL1_ADDR + 1:
-		SET_U16_MSB(idtcm->channel[1].output_mask, val);
+		SET_U16_MSB(cm->channel[1].output_mask, val);
 		break;
 	case OUTPUT_MASK_PLL2_ADDR:
-		SET_U16_LSB(idtcm->channel[2].output_mask, val);
+		SET_U16_LSB(cm->channel[2].output_mask, val);
 		break;
 	case OUTPUT_MASK_PLL2_ADDR + 1:
-		SET_U16_MSB(idtcm->channel[2].output_mask, val);
+		SET_U16_MSB(cm->channel[2].output_mask, val);
 		break;
 	case OUTPUT_MASK_PLL3_ADDR:
-		SET_U16_LSB(idtcm->channel[3].output_mask, val);
+		SET_U16_LSB(cm->channel[3].output_mask, val);
 		break;
 	case OUTPUT_MASK_PLL3_ADDR + 1:
-		SET_U16_MSB(idtcm->channel[3].output_mask, val);
+		SET_U16_MSB(cm->channel[3].output_mask, val);
 		break;
 	default:
 		err = -EINVAL;
@@ -743,66 +728,66 @@ static int set_pll_output_mask(struct idtcm *idtcm, u16 addr, u8 val)
 	return err;
 }
 
-static int check_and_set_masks(struct idtcm *idtcm,
+static int check_and_set_masks(struct cm *cm,
 			       u16 regaddr,
 			       u8 val)
 {
 	int err = 0;
 
-	if (set_pll_output_mask(idtcm, regaddr, val)) {
+	if (set_pll_output_mask(cm, regaddr, val)) {
 		/* Not an output mask, check for pll mask */
-		err = process_pll_mask(idtcm, regaddr, val, &idtcm->pll_mask);
+		err = process_pll_mask(cm, regaddr, val, &cm->pll_mask);
 	}
 
 	return err;
 }
 
-static void display_pll_and_output_masks(struct idtcm *idtcm)
+static void display_pll_and_output_masks(struct cm *cm)
 {
 	u8 i;
 	u8 mask;
 
-	dev_dbg(&idtcm->client->dev, "pllmask = 0x%02x\n", idtcm->pll_mask);
+	dev_dbg(&cm->client->dev, "pllmask = 0x%02x\n", cm->pll_mask);
 
 	for (i = 0; i < MAX_PHC_PLL; i++) {
 		mask = 1 << i;
 
-		if (mask & idtcm->pll_mask)
-			dev_dbg(&idtcm->client->dev,
+		if (mask & cm->pll_mask)
+			dev_dbg(&cm->client->dev,
 				"PLL%d output_mask = 0x%04x\n",
-				i, idtcm->channel[i].output_mask);
+				i, cm->channel[i].output_mask);
 	}
 }
 
-static int idtcm_load_firmware(struct idtcm *idtcm,
+static int cm_load_firmware(struct cm *cm,
 			       struct device *dev)
 {
 	const struct firmware *fw;
-	struct idtcm_fwrc *rec;
+	struct cm_fwrc *rec;
 	u32 regaddr;
 	int err;
 	s32 len;
 	u8 val;
 	u8 loaddr;
 
-	dev_dbg(&idtcm->client->dev, "requesting firmware '%s'\n", FW_FILENAME);
+	dev_dbg(&cm->client->dev, "requesting firmware '%s'\n", FW_FILENAME);
 
 	err = request_firmware(&fw, FW_FILENAME, dev);
 
 	if (err)
 		return err;
 
-	dev_dbg(&idtcm->client->dev, "firmware size %zu bytes\n", fw->size);
+	dev_dbg(&cm->client->dev, "firmware size %zu bytes\n", fw->size);
 
-	rec = (struct idtcm_fwrc *) fw->data;
+	rec = (struct cm_fwrc *) fw->data;
 
 	if (fw->size > 0)
-		idtcm_state_machine_reset(idtcm);
+		cm_state_machine_reset(cm);
 
 	for (len = fw->size; len > 0; len -= sizeof(*rec)) {
 
 		if (rec->reserved) {
-			dev_err(&idtcm->client->dev,
+			dev_err(&cm->client->dev,
 				"bad firmware, reserved field non-zero\n");
 			err = -EINVAL;
 		} else {
@@ -814,7 +799,7 @@ static int idtcm_load_firmware(struct idtcm *idtcm,
 
 			rec++;
 
-			err = check_and_set_masks(idtcm, regaddr, val);
+			err = check_and_set_masks(cm, regaddr, val);
 		}
 
 		if (err == 0) {
@@ -828,23 +813,23 @@ static int idtcm_load_firmware(struct idtcm *idtcm,
 			     || ((loaddr > 0xfb) && (loaddr <= 0xff)))
 				continue;
 
-			err = idtcm_write(idtcm, regaddr, 0, &val, sizeof(val));
+			err = cm_write(cm, regaddr, 0, &val, sizeof(val));
 		}
 
 		if (err)
 			goto out;
 	}
 
-	display_pll_and_output_masks(idtcm);
+	display_pll_and_output_masks(cm);
 
 out:
 	release_firmware(fw);
 	return err;
 }
 
-static int idtcm_pps_enable(struct idtcm_channel *channel, bool enable)
+static int cm_pps_enable(struct cm_channel *channel, bool enable)
 {
-	struct idtcm *idtcm = channel->idtcm;
+	struct cm *cm = channel->cm;
 	u32 module;
 	u8 val;
 	int err;
@@ -870,7 +855,7 @@ static int idtcm_pps_enable(struct idtcm_channel *channel, bool enable)
 		return -EINVAL;
 	}
 
-	err = idtcm_read(idtcm, module, OUT_CTRL_1, &val, sizeof(val));
+	err = cm_read(cm, module, OUT_CTRL_1, &val, sizeof(val));
 
 	if (err)
 		return err;
@@ -880,7 +865,7 @@ static int idtcm_pps_enable(struct idtcm_channel *channel, bool enable)
 	else
 		val &= ~SQUELCH_DISABLE;
 
-	err = idtcm_write(idtcm, module, OUT_CTRL_1, &val, sizeof(val));
+	err = cm_write(cm, module, OUT_CTRL_1, &val, sizeof(val));
 
 	if (err)
 		return err;
@@ -888,15 +873,15 @@ static int idtcm_pps_enable(struct idtcm_channel *channel, bool enable)
 	return 0;
 }
 
-static int idtcm_set_pll_mode(struct idtcm_channel *channel,
-			      enum pll_mode pll_mode)
+static int cm_set_pll_mode(struct cm_channel *channel,
+			   enum pll_mode pll_mode)
 {
-	struct idtcm *idtcm = channel->idtcm;
+	struct cm *cm = channel->cm;
 	int err;
 	u8 dpll_mode;
 
-	err = idtcm_read(idtcm, channel->dpll_n, DPLL_MODE,
-			 &dpll_mode, sizeof(dpll_mode));
+	err = cm_read(cm, channel->dpll_n, DPLL_MODE,
+		      &dpll_mode, sizeof(dpll_mode));
 	if (err)
 		return err;
 
@@ -906,8 +891,8 @@ static int idtcm_set_pll_mode(struct idtcm_channel *channel,
 
 	channel->pll_mode = pll_mode;
 
-	err = idtcm_write(idtcm, channel->dpll_n, DPLL_MODE,
-			  &dpll_mode, sizeof(dpll_mode));
+	err = cm_write(cm, channel->dpll_n, DPLL_MODE,
+		       &dpll_mode, sizeof(dpll_mode));
 	if (err)
 		return err;
 
@@ -916,11 +901,11 @@ static int idtcm_set_pll_mode(struct idtcm_channel *channel,
 
 /* PTP Hardware Clock interface */
 
-static int idtcm_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
+static int cm_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
 {
-	struct idtcm_channel *channel =
-		container_of(ptp, struct idtcm_channel, caps);
-	struct idtcm *idtcm = channel->idtcm;
+	struct cm_channel *channel =
+		container_of(ptp, struct cm_channel, caps);
+	struct cm *cm = channel->cm;
 	u8 i;
 	bool neg_adj = 0;
 	int err;
@@ -928,7 +913,7 @@ static int idtcm_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
 	s64 fcw;
 
 	if (channel->pll_mode  != PLL_MODE_WRITE_FREQUENCY) {
-		err = idtcm_set_pll_mode(channel, PLL_MODE_WRITE_FREQUENCY);
+		err = cm_set_pll_mode(channel, PLL_MODE_WRITE_FREQUENCY);
 		if (err)
 			return err;
 	}
@@ -964,81 +949,80 @@ static int idtcm_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
 		fcw >>= 8;
 	}
 
-	mutex_lock(&idtcm->reg_lock);
+	mutex_lock(&cm->reg_lock);
 
-	err = idtcm_write(idtcm, channel->dpll_freq, DPLL_WR_FREQ,
-			  buf, sizeof(buf));
+	err = cm_write(cm, channel->dpll_freq, DPLL_WR_FREQ, buf, sizeof(buf));
 
-	mutex_unlock(&idtcm->reg_lock);
+	mutex_unlock(&cm->reg_lock);
 	return err;
 }
 
-static int idtcm_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)
+static int cm_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)
 {
-	struct idtcm_channel *channel =
-		container_of(ptp, struct idtcm_channel, caps);
-	struct idtcm *idtcm = channel->idtcm;
+	struct cm_channel *channel =
+		container_of(ptp, struct cm_channel, caps);
+	struct cm *cm = channel->cm;
 	int err;
 
-	mutex_lock(&idtcm->reg_lock);
+	mutex_lock(&cm->reg_lock);
 
-	err = _idtcm_gettime(channel, ts);
+	err = _cm_gettime(channel, ts);
 
-	mutex_unlock(&idtcm->reg_lock);
+	mutex_unlock(&cm->reg_lock);
 
 	return err;
 }
 
-static int idtcm_settime(struct ptp_clock_info *ptp,
+static int cm_settime(struct ptp_clock_info *ptp,
 			 const struct timespec64 *ts)
 {
-	struct idtcm_channel *channel =
-		container_of(ptp, struct idtcm_channel, caps);
-	struct idtcm *idtcm = channel->idtcm;
+	struct cm_channel *channel =
+		container_of(ptp, struct cm_channel, caps);
+	struct cm *cm = channel->cm;
 	int err;
 
-	mutex_lock(&idtcm->reg_lock);
+	mutex_lock(&cm->reg_lock);
 
-	err = _idtcm_settime(channel, ts, HW_TOD_WR_TRIG_SEL_MSB);
+	err = _cm_settime(channel, ts, HW_TOD_WR_TRIG_SEL_MSB);
 
-	mutex_unlock(&idtcm->reg_lock);
+	mutex_unlock(&cm->reg_lock);
 
 	return err;
 }
 
-static int idtcm_adjtime(struct ptp_clock_info *ptp, s64 delta)
+static int cm_adjtime(struct ptp_clock_info *ptp, s64 delta)
 {
-	struct idtcm_channel *channel =
-		container_of(ptp, struct idtcm_channel, caps);
-	struct idtcm *idtcm = channel->idtcm;
+	struct cm_channel *channel =
+		container_of(ptp, struct cm_channel, caps);
+	struct cm *cm = channel->cm;
 	int err;
 
-	mutex_lock(&idtcm->reg_lock);
+	mutex_lock(&cm->reg_lock);
 
-	err = _idtcm_adjtime(channel, delta);
+	err = _cm_adjtime(channel, delta);
 
-	mutex_unlock(&idtcm->reg_lock);
+	mutex_unlock(&cm->reg_lock);
 
 	return err;
 }
 
-static int idtcm_enable(struct ptp_clock_info *ptp,
+static int cm_enable(struct ptp_clock_info *ptp,
 			struct ptp_clock_request *rq, int on)
 {
-	struct idtcm_channel *channel =
-		container_of(ptp, struct idtcm_channel, caps);
+	struct cm_channel *channel =
+		container_of(ptp, struct cm_channel, caps);
 
 	switch (rq->type) {
 	case PTP_CLK_REQ_PEROUT:
 		if (!on)
-			return idtcm_pps_enable(channel, false);
+			return cm_pps_enable(channel, false);
 
 		/* Only accept a 1-PPS aligned to the second. */
 		if (rq->perout.start.nsec || rq->perout.period.sec != 1 ||
 		    rq->perout.period.nsec)
 			return -ERANGE;
 
-		return idtcm_pps_enable(channel, true);
+		return cm_pps_enable(channel, true);
 	default:
 		break;
 	}
@@ -1046,34 +1030,34 @@ static int idtcm_enable(struct ptp_clock_info *ptp,
 	return -EOPNOTSUPP;
 }
 
-static int idtcm_enable_tod(struct idtcm_channel *channel)
+static int cm_enable_tod(struct cm_channel *channel)
 {
-	struct idtcm *idtcm = channel->idtcm;
+	struct cm *cm = channel->cm;
 	struct timespec64 ts = {0, 0};
 	u8 cfg;
 	int err;
 
-	err = idtcm_pps_enable(channel, false);
+	err = cm_pps_enable(channel, false);
 	if (err)
 		return err;
 
 	/*
 	 * Start the TOD clock ticking.
 	 */
-	err = idtcm_read(idtcm, channel->tod_n, TOD_CFG, &cfg, sizeof(cfg));
+	err = cm_read(cm, channel->tod_n, TOD_CFG, &cfg, sizeof(cfg));
 	if (err)
 		return err;
 
 	cfg |= TOD_ENABLE;
 
-	err = idtcm_write(idtcm, channel->tod_n, TOD_CFG, &cfg, sizeof(cfg));
+	err = cm_write(cm, channel->tod_n, TOD_CFG, &cfg, sizeof(cfg));
 	if (err)
 		return err;
 
-	return _idtcm_settime(channel, &ts, HW_TOD_WR_TRIG_SEL_MSB);
+	return _cm_settime(channel, &ts, HW_TOD_WR_TRIG_SEL_MSB);
 }
 
-static void idtcm_display_version_info(struct idtcm *idtcm)
+static void cm_display_version_info(struct cm *cm)
 {
 	u8 major;
 	u8 minor;
@@ -1085,43 +1069,43 @@ static void idtcm_display_version_info(struct idtcm *idtcm)
 	u8 hw_rev_id;
 	u8 bond_id;
 
-	idtcm_read_major_release(idtcm, &major);
-	idtcm_read_minor_release(idtcm, &minor);
-	idtcm_read_hotfix_release(idtcm, &hotfix);
-	idtcm_read_pipeline(idtcm, &pipeline);
+	cm_read_major_release(cm, &major);
+	cm_read_minor_release(cm, &minor);
+	cm_read_hotfix_release(cm, &hotfix);
+	cm_read_pipeline(cm, &pipeline);
 
-	idtcm_read_product_id(idtcm, &product_id);
-	idtcm_read_hw_rev_id(idtcm, &hw_rev_id);
-	idtcm_read_bond_id(idtcm, &bond_id);
-	idtcm_read_hw_csr_id(idtcm, &csr_id);
-	idtcm_read_hw_irq_id(idtcm, &irq_id);
+	cm_read_product_id(cm, &product_id);
+	cm_read_hw_rev_id(cm, &hw_rev_id);
+	cm_read_bond_id(cm, &bond_id);
+	cm_read_hw_csr_id(cm, &csr_id);
+	cm_read_hw_irq_id(cm, &irq_id);
 
-	dev_info(&idtcm->client->dev, "Version:  %d.%d.%d, Pipeline %u\t"
+	dev_info(&cm->client->dev, "Version:  %d.%d.%d, Pipeline %u\t"
 		 "0x%04x, Rev %d, Bond %d, CSR %d, IRQ %d\n",
 		 major, minor, hotfix, pipeline,
 		 product_id, hw_rev_id, bond_id, csr_id, irq_id);
 }
 
-static struct ptp_clock_info idtcm_caps = {
+static struct ptp_clock_info cm_caps = {
 	.owner		= THIS_MODULE,
 	.max_adj	= 244000,
 	.n_per_out	= 1,
-	.adjfreq	= &idtcm_adjfreq,
-	.adjtime	= &idtcm_adjtime,
-	.gettime64	= &idtcm_gettime,
-	.settime64	= &idtcm_settime,
-	.enable		= &idtcm_enable,
+	.adjfreq	= &cm_adjfreq,
+	.adjtime	= &cm_adjtime,
+	.gettime64	= &cm_gettime,
+	.settime64	= &cm_settime,
+	.enable		= &cm_enable,
 };
 
-static int idtcm_enable_channel(struct idtcm *idtcm, u32 index)
+static int cm_enable_channel(struct cm *cm, u32 index)
 {
-	struct idtcm_channel *channel;
+	struct cm_channel *channel;
 	int err;
 
 	if (!(index < MAX_PHC_PLL))
 		return -EINVAL;
 
-	channel = &idtcm->channel[index];
+	channel = &cm->channel[index];
 
 	switch (index) {
 	case 0:
@@ -1172,17 +1156,17 @@ static int idtcm_enable_channel(struct idtcm *idtcm, u32 index)
 		return -EINVAL;
 	}
 
-	channel->idtcm = idtcm;
+	channel->cm = cm;
 
-	channel->caps = idtcm_caps;
+	channel->caps = cm_caps;
 	snprintf(channel->caps.name, sizeof(channel->caps.name),
-		 "IDT CM PLL%u", index);
+		 "Renesas CM PLL%u", index);
 
-	err = idtcm_set_pll_mode(channel, PLL_MODE_WRITE_FREQUENCY);
+	err = cm_set_pll_mode(channel, PLL_MODE_WRITE_FREQUENCY);
 	if (err)
 		return err;
 
-	err = idtcm_enable_tod(channel);
+	err = cm_enable_tod(channel);
 	if (err)
 		return err;
 
@@ -1197,37 +1181,37 @@ static int idtcm_enable_channel(struct idtcm *idtcm, u32 index)
 	if (!channel->ptp_clock)
 		return -ENOTSUPP;
 
-	dev_info(&idtcm->client->dev, "PLL%d registered as ptp%d\n",
+	dev_info(&cm->client->dev, "PLL%d registered as ptp%d\n",
 		 index, channel->ptp_clock->index);
 
 	return 0;
 }
 
-static void ptp_clock_unregister_all(struct idtcm *idtcm)
+static void ptp_clock_unregister_all(struct cm *cm)
 {
 	u8 i;
-	struct idtcm_channel *channel;
+	struct cm_channel *channel;
 
 	for (i = 0; i < MAX_PHC_PLL; i++) {
 
-		channel = &idtcm->channel[i];
+		channel = &cm->channel[i];
 
 		if (channel->ptp_clock)
 			ptp_clock_unregister(channel->ptp_clock);
 	}
 }
 
-static void set_default_masks(struct idtcm *idtcm)
+static void set_default_masks(struct cm *cm)
 {
-	idtcm->pll_mask = DEFAULT_PLL_MASK;
+	cm->pll_mask = DEFAULT_PLL_MASK;
 
-	idtcm->channel[0].output_mask = DEFAULT_OUTPUT_MASK_PLL0;
-	idtcm->channel[1].output_mask = DEFAULT_OUTPUT_MASK_PLL1;
-	idtcm->channel[2].output_mask = DEFAULT_OUTPUT_MASK_PLL2;
-	idtcm->channel[3].output_mask = DEFAULT_OUTPUT_MASK_PLL3;
+	cm->channel[0].output_mask = DEFAULT_OUTPUT_MASK_PLL0;
+	cm->channel[1].output_mask = DEFAULT_OUTPUT_MASK_PLL1;
+	cm->channel[2].output_mask = DEFAULT_OUTPUT_MASK_PLL2;
+	cm->channel[3].output_mask = DEFAULT_OUTPUT_MASK_PLL3;
 }
 
-static int set_tod_write_overhead(struct idtcm *idtcm)
+static int set_tod_write_overhead(struct cm *cm)
 {
 	int err;
 	u8 i;
@@ -1239,17 +1223,17 @@ static int set_tod_write_overhead(struct idtcm *idtcm)
 
 	char buf[TOD_BYTE_COUNT];
 
-	struct idtcm_channel *channel = &idtcm->channel[2];
+	struct cm_channel *channel = &cm->channel[2];
 
 	/* Set page offset */
-	idtcm_write(idtcm, channel->hw_dpll_n, HW_DPLL_TOD_OVR__0,
+	cm_write(cm, channel->hw_dpll_n, HW_DPLL_TOD_OVR__0,
 		    buf, sizeof(buf));
 
 	for (i = 0; i < TOD_WRITE_OVERHEAD_COUNT_MAX; i++) {
 
 		start = ktime_get_raw();
 
-		err = idtcm_write(idtcm, channel->hw_dpll_n,
+		err = cm_write(cm, channel->hw_dpll_n,
 				  HW_DPLL_TOD_OVR__0, buf, sizeof(buf));
 
 		if (err)
@@ -1260,126 +1244,126 @@ static int set_tod_write_overhead(struct idtcm *idtcm)
 		total_ns += ktime_to_ns(stop - start);
 	}
 
-	idtcm->tod_write_overhead_ns = div_s64(total_ns,
-					       TOD_WRITE_OVERHEAD_COUNT_MAX);
+	cm->tod_write_overhead_ns = div_s64(total_ns,
+					    TOD_WRITE_OVERHEAD_COUNT_MAX);
 
 	return err;
 }
 
-static int idtcm_probe(struct i2c_client *client,
-		       const struct i2c_device_id *id)
+static int cm_probe(struct i2c_client *client,
+		    const struct i2c_device_id *id)
 {
-	struct idtcm *idtcm;
+	struct cm *cm;
 	int err;
 	u8 i;
 
 	/* Unused for now */
 	(void)id;
 
-	idtcm = devm_kzalloc(&client->dev, sizeof(struct idtcm), GFP_KERNEL);
+	cm = devm_kzalloc(&client->dev, sizeof(struct cm), GFP_KERNEL);
 
-	if (!idtcm)
+	if (!cm)
 		return -ENOMEM;
 
-	idtcm->client = client;
-	idtcm->page_offset = 0xff;
-	idtcm->calculate_overhead_flag = 0;
+	cm->client = client;
+	cm->page_offset = 0xff;
+	cm->calculate_overhead_flag = 0;
 
-	set_default_masks(idtcm);
+	set_default_masks(cm);
 
-	mutex_init(&idtcm->reg_lock);
-	mutex_lock(&idtcm->reg_lock);
+	mutex_init(&cm->reg_lock);
+	mutex_lock(&cm->reg_lock);
 
-	idtcm_display_version_info(idtcm);
+	cm_display_version_info(cm);
 
-	err = set_tod_write_overhead(idtcm);
+	err = set_tod_write_overhead(cm);
 
 	if (err) {
-		mutex_unlock(&idtcm->reg_lock);
+		mutex_unlock(&cm->reg_lock);
 		return err;
 	}
 
-	err = idtcm_load_firmware(idtcm, &client->dev);
+	err = cm_load_firmware(cm, &client->dev);
 
 	if (err)
-		dev_warn(&idtcm->client->dev,
+		dev_warn(&cm->client->dev,
 			 "loading firmware failed with %d\n", err);
 
-	if (idtcm->pll_mask) {
+	if (cm->pll_mask) {
 		for (i = 0; i < MAX_PHC_PLL; i++) {
-			if (idtcm->pll_mask & (1 << i)) {
-				err = idtcm_enable_channel(idtcm, i);
+			if (cm->pll_mask & (1 << i)) {
+				err = cm_enable_channel(cm, i);
 				if (err)
 					break;
 			}
 		}
 	} else {
-		dev_err(&idtcm->client->dev,
+		dev_err(&cm->client->dev,
 			"no PLLs flagged as PHCs, nothing to do\n");
 		err = -ENODEV;
 	}
 
-	mutex_unlock(&idtcm->reg_lock);
+	mutex_unlock(&cm->reg_lock);
 
 	if (err) {
-		ptp_clock_unregister_all(idtcm);
+		ptp_clock_unregister_all(cm);
 		return err;
 	}
 
-	i2c_set_clientdata(client, idtcm);
+	i2c_set_clientdata(client, cm);
 
 	return 0;
 }
 
-static int idtcm_remove(struct i2c_client *client)
+static int cm_remove(struct i2c_client *client)
 {
-	struct idtcm *idtcm = i2c_get_clientdata(client);
+	struct cm *cm = i2c_get_clientdata(client);
 
-	ptp_clock_unregister_all(idtcm);
+	ptp_clock_unregister_all(cm);
 
-	mutex_destroy(&idtcm->reg_lock);
+	mutex_destroy(&cm->reg_lock);
 
 	return 0;
 }
 
 #ifdef CONFIG_OF
-static const struct of_device_id idtcm_dt_id[] = {
-	{ .compatible = "idt,8a34000" },
-	{ .compatible = "idt,8a34001" },
-	{ .compatible = "idt,8a34002" },
-	{ .compatible = "idt,8a34003" },
-	{ .compatible = "idt,8a34004" },
-	{ .compatible = "idt,8a34005" },
-	{ .compatible = "idt,8a34006" },
-	{ .compatible = "idt,8a34007" },
-	{ .compatible = "idt,8a34008" },
-	{ .compatible = "idt,8a34009" },
-	{ .compatible = "idt,8a34010" },
-	{ .compatible = "idt,8a34011" },
-	{ .compatible = "idt,8a34012" },
-	{ .compatible = "idt,8a34013" },
-	{ .compatible = "idt,8a34014" },
-	{ .compatible = "idt,8a34015" },
-	{ .compatible = "idt,8a34016" },
-	{ .compatible = "idt,8a34017" },
-	{ .compatible = "idt,8a34018" },
-	{ .compatible = "idt,8a34019" },
-	{ .compatible = "idt,8a34040" },
-	{ .compatible = "idt,8a34041" },
-	{ .compatible = "idt,8a34042" },
-	{ .compatible = "idt,8a34043" },
-	{ .compatible = "idt,8a34044" },
-	{ .compatible = "idt,8a34045" },
-	{ .compatible = "idt,8a34046" },
-	{ .compatible = "idt,8a34047" },
-	{ .compatible = "idt,8a34048" },
-	{ .compatible = "idt,8a34049" },
+static const struct of_device_id cm_dt_id[] = {
+	{ .compatible = "renesas,8a34000" },
+	{ .compatible = "renesas,8a34001" },
+	{ .compatible = "renesas,8a34002" },
+	{ .compatible = "renesas,8a34003" },
+	{ .compatible = "renesas,8a34004" },
+	{ .compatible = "renesas,8a34005" },
+	{ .compatible = "renesas,8a34006" },
+	{ .compatible = "renesas,8a34007" },
+	{ .compatible = "renesas,8a34008" },
+	{ .compatible = "renesas,8a34009" },
+	{ .compatible = "renesas,8a34010" },
+	{ .compatible = "renesas,8a34011" },
+	{ .compatible = "renesas,8a34012" },
+	{ .compatible = "renesas,8a34013" },
+	{ .compatible = "renesas,8a34014" },
+	{ .compatible = "renesas,8a34015" },
+	{ .compatible = "renesas,8a34016" },
+	{ .compatible = "renesas,8a34017" },
+	{ .compatible = "renesas,8a34018" },
+	{ .compatible = "renesas,8a34019" },
+	{ .compatible = "renesas,8a34040" },
+	{ .compatible = "renesas,8a34041" },
+	{ .compatible = "renesas,8a34042" },
+	{ .compatible = "renesas,8a34043" },
+	{ .compatible = "renesas,8a34044" },
+	{ .compatible = "renesas,8a34045" },
+	{ .compatible = "renesas,8a34046" },
+	{ .compatible = "renesas,8a34047" },
+	{ .compatible = "renesas,8a34048" },
+	{ .compatible = "renesas,8a34049" },
 	{},
 };
-MODULE_DEVICE_TABLE(of, idtcm_dt_id);
+MODULE_DEVICE_TABLE(of, cm_dt_id);
 #endif
 
-static const struct i2c_device_id idtcm_i2c_id[] = {
+static const struct i2c_device_id cm_i2c_id[] = {
 	{ "8a34000" },
 	{ "8a34001" },
 	{ "8a34002" },
@@ -1412,16 +1396,16 @@ static const struct i2c_device_id idtcm_i2c_id[] = {
 	{ "8a34049" },
 	{},
 };
-MODULE_DEVICE_TABLE(i2c, idtcm_i2c_id);
+MODULE_DEVICE_TABLE(i2c, cm_i2c_id);
 
-static struct i2c_driver idtcm_driver = {
+static struct i2c_driver cm_driver = {
 	.driver = {
-		.of_match_table	= of_match_ptr(idtcm_dt_id),
-		.name		= "idtcm",
+		.of_match_table	= of_match_ptr(cm_dt_id),
+		.name		= "cm",
 	},
-	.probe		= idtcm_probe,
-	.remove		= idtcm_remove,
-	.id_table	= idtcm_i2c_id,
+	.probe		= cm_probe,
+	.remove		= cm_remove,
+	.id_table	= cm_i2c_id,
 };
 
-module_i2c_driver(idtcm_driver);
+module_i2c_driver(cm_driver);
diff --git a/drivers/ptp/ptp_clockmatrix.h b/drivers/ptp/ptp_clockmatrix.h
index 6c1f93a..5d50ce5 100644
--- a/drivers/ptp/ptp_clockmatrix.h
+++ b/drivers/ptp/ptp_clockmatrix.h
@@ -1,18 +1,18 @@
 /* SPDX-License-Identifier: GPL-2.0+ */
 /*
- * PTP hardware clock driver for the IDT ClockMatrix(TM) family of timing and
- * synchronization devices.
+ * PTP hardware clock driver for the Renesas (IDT) ClockMatrix(TM) family of
+ * timing and synchronization devices.
  *
- * Copyright (C) 2019 Integrated Device Technology, Inc., a Renesas Company.
+ * Copyright (C) 2019 Renesas Electronics Corporation. All rights reserved.
  */
-#ifndef PTP_IDTCLOCKMATRIX_H
-#define PTP_IDTCLOCKMATRIX_H
+#ifndef PTP_CLOCKMATRIX_H
+#define PTP_CLOCKMATRIX_H
 
 #include <linux/ktime.h>
 
-#include "idt8a340_reg.h"
+#include "clockmatrix_reg.h"
 
-#define FW_FILENAME	"idtcm.bin"
+#define FW_FILENAME	"cm_tcs.bin"
 #define MAX_PHC_PLL	4
 
 #define PLL_MASK_ADDR		(0xFFA5)
@@ -60,12 +60,12 @@ enum hw_tod_write_trig_sel {
 	WR_TRIG_SEL_MAX = HW_TOD_WR_TRIG_SEL_FOD_SYNC,
 };
 
-struct idtcm;
+struct cm;
 
-struct idtcm_channel {
+struct cm_channel {
 	struct ptp_clock_info	caps;
 	struct ptp_clock	*ptp_clock;
-	struct idtcm		*idtcm;
+	struct cm		*cm;
 	u16			dpll_phase;
 	u16			dpll_freq;
 	u16			dpll_n;
@@ -79,8 +79,8 @@ struct idtcm_channel {
 	u16			output_mask;
 };
 
-struct idtcm {
-	struct idtcm_channel	channel[MAX_PHC_PLL];
+struct cm {
+	struct cm_channel	channel[MAX_PHC_PLL];
 	struct i2c_client	*client;
 	u8			page_offset;
 	u8			pll_mask;
@@ -94,11 +94,11 @@ struct idtcm {
 	struct mutex		reg_lock;
 };
 
-struct idtcm_fwrc {
+struct cm_fwrc {
 	u8 hiaddr;
 	u8 loaddr;
 	u8 value;
 	u8 reserved;
 } __packed;
 
-#endif /* PTP_IDTCLOCKMATRIX_H */
+#endif /* PTP_CLOCKMATRIX_H */
-- 
2.7.4

